# FHIR Data Model Design

## Overview

The [HAPI FHIR](https://hapifhir.io/hapi-fhir/docs/model/working_with_resources.html) ecosystem (implemented in Java)
includes data model classes representing FHIR resources and data types.
These data model classes include a number of getters and setters for the basic properties of that data model along with
many convenience methods.
These HAPI FHIR data models provided the inspiration for the design for the data models generated by this project.

A proof-of-concept (POC) project was undertaken to arrive at a design for TypeScript that could easily be applied to
generated data models.
This POC project resulted in contents for a core library that contains the base data models, implementations of the FHIR
primitive data types, and various utilities required by the data models.
These are implemented in the `@paq-ts-fhir/fhir-core` library.
The generated data model projects take this library as their sole dependency.
Additionally, a set of implementation patterns were identified to facilitate code generation of data models for
resources and complex data types.

## Class Hierarchy

The FHIR data model class hierarchy is based on the [FHIR Type Framework](https://hl7.org/fhir/types.html) as documented
in [FHIR Type Framework](fhir-type-framework.md).

All FHIR resource data models extend either `Resource` or `DomainResource`.
According to the FHIR specification, only `DomainResource`, `Bundle`, `Parameters`, and `Binary` extend `Resource`.
All other FHIR resources extend `DomainResource`.
All FHIR complex data types extend either `DataType` or `BackboneType`.
All FHIR primitive data types extend `PrimitiveType<T>` where `T` represents the FHIR primitive as defined in the
[FHIR Specification](https://www.hl7.org/fhir/datatypes.html#primitive) and implemented in the `@paq-ts-fhir/fhir-core`
library.

## Element Definition Patterns

Th FHIR `StructureDefinition.snapshot.element` defines a set of FHIR `ElementDefinition`s.
These `ElementDefinition`s are used to define each data model class private fields that are accessed via public class
methods.
Furthermore, these public class methods can be grouped into common patterns based on the element's cardinality and its
data type.
These patterns are:

- Optional single field (cardinality `0..1`)
  - BackboneElement/BackboneType types
  - Choice data type
  - Complex data type
  - EnumCodeType
  - Primitive data type
  - Reference data type
  - Resource data type (only `Bundle` and `Parameters`)
- Required single field (cardinality `1..1`)
  - BackboneElement/BackboneType types
  - Choice data type
  - Complex data type
  - EnumCodeType
  - Primitive data type
  - Reference data type
- Optional list field (cardinality `0..*`)
  - BackboneElement/BackboneType types
  - Complex data type
  - EnumCodeType
  - Primitive data type
  - Reference data type
  - Resource data type (only `DomainResource`)
- Required list field (cardinality `1..*`)
  - BackboneElement/BackboneType types
  - Complex data type
  - EnumCodeType
  - Primitive data type
  - Reference data type

### Pattern Notes

- BackboneElement/BackboneType types are treated as base implementations
  - [BackboneElement](https://hl7.org/fhir/types.html#BackboneElement): "The base definition for complex elements
    defined as part of a resource definition â€” that is, elements that have children that are defined in the resource.'
    These are implemented as separate data model classes.
  - [BackboneType](https://www.hl7.org/fhir/types.html#BackboneType): "The base definition for the few datatypes that
    allow modifier extensions"
- [Choice](https://hl7.org/fhir/formats.html#choice) data type can only be specified for single data elements (`0..1` or `1..1`).
  Both choice data types and the FHIR [Open Type Element](https://hl7.org/fhir/datatypes.html#open) are defined as an
  array of permissible FHIR types in the `ElementDefinition.type` element within the `StructureDefinition`.
  These are implemented using TypeScript decorators on setter methods to restrict the use of the allowed data types.
  They are also used to generate data type specific public "has" and "get" methods.
- Complex data type is generated from its FHIR `StructureDefinition` and has no additional implementation specialization.
- EnumCodeType is a derived primitive data type used to support/enforce the `code` values using a "pseudo-enum" set of
  valid code values. This data type is not defined by FHIR. It is an implementation approach inspired by HAPI FHIR.
  It makes use of a generated class that defines the allowed code values as defined by the ValueSet identified in the
  `ElementDefinition.binding` element in the `StructureDefinition`.
- Primitive data types are defined in the `@paq-ts-fhir/fhir-core` library.
  They properly handle the requirements of [Primitive Types](https://hl7.org/fhir/datatypes.html#primitive) and their
  [JSON Representation](https://hl7.org/fhir/datatypes.html#representations).
- Reference data type is a standard FHIR complex data type. It is represented as a separate pattern because it is
  implemented using TypeScript decorators on setter methods to restrict the use of the allowed reference type targets.
- Resource data type is only specified for `Bundle` (`0..1`), `Parameters` (`0..1`), and `DomainResource` (`0..*`).

### Pseudo-Enum Classes

To support EnumCodeType, pseudo-enum classes are generated that provide enumerations of the allowed code values.
FHIR CodeSystem artifacts are identified to get the allowed codes used to create the pseudo-enum classes.
The following rules determine these CodeSystem artifacts.
For a each `ElementDefinition` item included in the `StructureDefinition.snapshot.element`:

- A single `ElementDefinition.type` having a primitive `code` data type is selected
- Its `ElementDefinition.binding` must exist having `ElementDefinition.binding.strength` of `required` and a defined
  `ElementDefinition.binding.valueSet` url.
- A FHIR ValueSet is retrieved for the given `ElementDefinition.binding.valueSet` url.
- The retrieved ValueSet contains one and only one `ValueSet.compose.include` definition.
- The single `ValueSet.compose.include` definition has a `ValueSet.compose.include[0].system` providing the `CodeSystem.url`
  for the FHIR CodeSystem having the allowed code values. Non-FHIR CodeSystems are not used.
- The retrieved CodeSystem has `CodeSystem.content` of `complete` and its `CodeSystem.concept` includes one or more
  concept definitions with the allowed `CodeSystem.concept[i].code` value.

ValueSets having more than one `ValueSet.compose.include` definition are ignored (i.e., merging CodeSystem codes is not
supported).
CodeSystems having hierarchical codes are flattened before the pseudo-enum class is actually generated.
