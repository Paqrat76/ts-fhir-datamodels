// Jest Snapshot v1, https://jestjs.io/docs/snapshot-testing

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 1`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * AddressUseEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/address-use
 * CodeSystem.name: AddressUse
 * CodeSystem.description: The use of an address.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: AddressUseEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem AddressUse](http://hl7.org/fhir/address-use)
 */
export class AddressUseEnum implements IFhirCodeEnum {
  public static readonly HOME = new FhirCodeDefinition(
    'HOME',
    'home',
    'http://hl7.org/fhir/address-use',
    'Home',
    'A communication address at a home.',
  );
  public static readonly WORK = new FhirCodeDefinition(
    'WORK',
    'work',
    'http://hl7.org/fhir/address-use',
    'Work',
    'An office address. First choice for business related contacts during business hours.',
  );
  public static readonly TEMP = new FhirCodeDefinition(
    'TEMP',
    'temp',
    'http://hl7.org/fhir/address-use',
    'Temporary',
    'A temporary address. The period can provide more detailed information.',
  );
  public static readonly OLD = new FhirCodeDefinition(
    'OLD',
    'old',
    'http://hl7.org/fhir/address-use',
    'Old / Incorrect',
    'This address is no longer in use (or was never correct but retained for records).',
  );
  public static readonly BILLING = new FhirCodeDefinition(
    'BILLING',
    'billing',
    'http://hl7.org/fhir/address-use',
    'Billing',
    'An address to be used to send bills, invoices, receipts etc.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      AddressUseEnum.HOME,
      AddressUseEnum.WORK,
      AddressUseEnum.TEMP,
      AddressUseEnum.OLD,
      AddressUseEnum.BILLING,
      AddressUseEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (AddressUseEnum.HOME.code === code) {
      return AddressUseEnum.HOME;
    } else if (AddressUseEnum.WORK.code === code) {
      return AddressUseEnum.WORK;
    } else if (AddressUseEnum.TEMP.code === code) {
      return AddressUseEnum.TEMP;
    } else if (AddressUseEnum.OLD.code === code) {
      return AddressUseEnum.OLD;
    } else if (AddressUseEnum.BILLING.code === code) {
      return AddressUseEnum.BILLING;
    } else if (AddressUseEnum.NULL.code === code) {
      return AddressUseEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown AddressUseEnum 'code' value '\${String(code)}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "AddressUseEnum",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 2`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * AddressTypeEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/address-type
 * CodeSystem.name: AddressType
 * CodeSystem.description: The type of an address (physical / postal).
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: AddressTypeEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem AddressType](http://hl7.org/fhir/address-type)
 */
export class AddressTypeEnum implements IFhirCodeEnum {
  public static readonly POSTAL = new FhirCodeDefinition(
    'POSTAL',
    'postal',
    'http://hl7.org/fhir/address-type',
    'Postal',
    'Mailing addresses - PO Boxes and care-of addresses.',
  );
  public static readonly PHYSICAL = new FhirCodeDefinition(
    'PHYSICAL',
    'physical',
    'http://hl7.org/fhir/address-type',
    'Physical',
    'A physical address that can be visited.',
  );
  public static readonly BOTH = new FhirCodeDefinition(
    'BOTH',
    'both',
    'http://hl7.org/fhir/address-type',
    'Postal &amp; Physical',
    'An address that is both physical and postal.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      AddressTypeEnum.POSTAL,
      AddressTypeEnum.PHYSICAL,
      AddressTypeEnum.BOTH,
      AddressTypeEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (AddressTypeEnum.POSTAL.code === code) {
      return AddressTypeEnum.POSTAL;
    } else if (AddressTypeEnum.PHYSICAL.code === code) {
      return AddressTypeEnum.PHYSICAL;
    } else if (AddressTypeEnum.BOTH.code === code) {
      return AddressTypeEnum.BOTH;
    } else if (AddressTypeEnum.NULL.code === code) {
      return AddressTypeEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown AddressTypeEnum 'code' value '\${String(code)}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "AddressTypeEnum",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 3`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * QuantityComparatorEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/quantity-comparator
 * CodeSystem.name: QuantityComparator
 * CodeSystem.description: How the Quantity should be understood and represented.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: QuantityComparatorEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem QuantityComparator](http://hl7.org/fhir/quantity-comparator)
 */
export class QuantityComparatorEnum implements IFhirCodeEnum {
  public static readonly LESS_THAN = new FhirCodeDefinition(
    'LESS_THAN',
    '<',
    'http://hl7.org/fhir/quantity-comparator',
    'Less than',
    'The actual value is less than the given value.',
  );
  public static readonly LESS_THAN_OR_EQUAL_TO = new FhirCodeDefinition(
    'LESS_THAN_OR_EQUAL_TO',
    '<=',
    'http://hl7.org/fhir/quantity-comparator',
    'Less or Equal to',
    'The actual value is less than or equal to the given value.',
  );
  public static readonly GREATER_THAN_OR_EQUAL_TO = new FhirCodeDefinition(
    'GREATER_THAN_OR_EQUAL_TO',
    '>=',
    'http://hl7.org/fhir/quantity-comparator',
    'Greater or Equal to',
    'The actual value is greater than or equal to the given value.',
  );
  public static readonly GREATER_THAN = new FhirCodeDefinition(
    'GREATER_THAN',
    '>',
    'http://hl7.org/fhir/quantity-comparator',
    'Greater than',
    'The actual value is greater than the given value.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      QuantityComparatorEnum.LESS_THAN,
      QuantityComparatorEnum.LESS_THAN_OR_EQUAL_TO,
      QuantityComparatorEnum.GREATER_THAN_OR_EQUAL_TO,
      QuantityComparatorEnum.GREATER_THAN,
      QuantityComparatorEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (QuantityComparatorEnum.LESS_THAN.code === code) {
      return QuantityComparatorEnum.LESS_THAN;
    } else if (QuantityComparatorEnum.LESS_THAN_OR_EQUAL_TO.code === code) {
      return QuantityComparatorEnum.LESS_THAN_OR_EQUAL_TO;
    } else if (QuantityComparatorEnum.GREATER_THAN_OR_EQUAL_TO.code === code) {
      return QuantityComparatorEnum.GREATER_THAN_OR_EQUAL_TO;
    } else if (QuantityComparatorEnum.GREATER_THAN.code === code) {
      return QuantityComparatorEnum.GREATER_THAN;
    } else if (QuantityComparatorEnum.NULL.code === code) {
      return QuantityComparatorEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown QuantityComparatorEnum 'code' value '\${String(code)}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "QuantityComparatorEnum",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 4`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * DaysOfWeekEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/days-of-week
 * CodeSystem.name: DaysOfWeek
 * CodeSystem.description: The days of the week.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: DaysOfWeekEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem DaysOfWeek](http://hl7.org/fhir/days-of-week)
 */
export class DaysOfWeekEnum implements IFhirCodeEnum {
  public static readonly MON = new FhirCodeDefinition(
    'MON',
    'mon',
    'http://hl7.org/fhir/days-of-week',
    'Monday',
    'Monday.',
  );
  public static readonly TUE = new FhirCodeDefinition(
    'TUE',
    'tue',
    'http://hl7.org/fhir/days-of-week',
    'Tuesday',
    'Tuesday.',
  );
  public static readonly WED = new FhirCodeDefinition(
    'WED',
    'wed',
    'http://hl7.org/fhir/days-of-week',
    'Wednesday',
    'Wednesday.',
  );
  public static readonly THU = new FhirCodeDefinition(
    'THU',
    'thu',
    'http://hl7.org/fhir/days-of-week',
    'Thursday',
    'Thursday.',
  );
  public static readonly FRI = new FhirCodeDefinition(
    'FRI',
    'fri',
    'http://hl7.org/fhir/days-of-week',
    'Friday',
    'Friday.',
  );
  public static readonly SAT = new FhirCodeDefinition(
    'SAT',
    'sat',
    'http://hl7.org/fhir/days-of-week',
    'Saturday',
    'Saturday.',
  );
  public static readonly SUN = new FhirCodeDefinition(
    'SUN',
    'sun',
    'http://hl7.org/fhir/days-of-week',
    'Sunday',
    'Sunday.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      DaysOfWeekEnum.MON,
      DaysOfWeekEnum.TUE,
      DaysOfWeekEnum.WED,
      DaysOfWeekEnum.THU,
      DaysOfWeekEnum.FRI,
      DaysOfWeekEnum.SAT,
      DaysOfWeekEnum.SUN,
      DaysOfWeekEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (DaysOfWeekEnum.MON.code === code) {
      return DaysOfWeekEnum.MON;
    } else if (DaysOfWeekEnum.TUE.code === code) {
      return DaysOfWeekEnum.TUE;
    } else if (DaysOfWeekEnum.WED.code === code) {
      return DaysOfWeekEnum.WED;
    } else if (DaysOfWeekEnum.THU.code === code) {
      return DaysOfWeekEnum.THU;
    } else if (DaysOfWeekEnum.FRI.code === code) {
      return DaysOfWeekEnum.FRI;
    } else if (DaysOfWeekEnum.SAT.code === code) {
      return DaysOfWeekEnum.SAT;
    } else if (DaysOfWeekEnum.SUN.code === code) {
      return DaysOfWeekEnum.SUN;
    } else if (DaysOfWeekEnum.NULL.code === code) {
      return DaysOfWeekEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown DaysOfWeekEnum 'code' value '\${String(code)}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "DaysOfWeekEnum",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 5`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * ContactPointSystemEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/contact-point-system
 * CodeSystem.name: ContactPointSystem
 * CodeSystem.description: Telecommunications form for contact point.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: ContactPointSystemEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem ContactPointSystem](http://hl7.org/fhir/contact-point-system)
 */
export class ContactPointSystemEnum implements IFhirCodeEnum {
  public static readonly PHONE = new FhirCodeDefinition(
    'PHONE',
    'phone',
    'http://hl7.org/fhir/contact-point-system',
    'Phone',
    'The value is a telephone number used for voice calls. Use of full international numbers starting with + is recommended to enable automatic dialing support but not required.',
  );
  public static readonly FAX = new FhirCodeDefinition(
    'FAX',
    'fax',
    'http://hl7.org/fhir/contact-point-system',
    'Fax',
    'The value is a fax machine. Use of full international numbers starting with + is recommended to enable automatic dialing support but not required.',
  );
  public static readonly EMAIL = new FhirCodeDefinition(
    'EMAIL',
    'email',
    'http://hl7.org/fhir/contact-point-system',
    'Email',
    'The value is an email address.',
  );
  public static readonly PAGER = new FhirCodeDefinition(
    'PAGER',
    'pager',
    'http://hl7.org/fhir/contact-point-system',
    'Pager',
    'The value is a pager number. These may be local pager numbers that are only usable on a particular pager system.',
  );
  public static readonly URL = new FhirCodeDefinition(
    'URL',
    'url',
    'http://hl7.org/fhir/contact-point-system',
    'URL',
    'A contact that is not a phone, fax, pager or email address and is expressed as a URL.  This is intended for various institutional or personal contacts including web sites, blogs, Skype, Twitter, Facebook, etc. Do not use for email addresses.',
  );
  public static readonly SMS = new FhirCodeDefinition(
    'SMS',
    'sms',
    'http://hl7.org/fhir/contact-point-system',
    'SMS',
    'A contact that can be used for sending an sms message (e.g. mobile phones, some landlines).',
  );
  public static readonly OTHER = new FhirCodeDefinition(
    'OTHER',
    'other',
    'http://hl7.org/fhir/contact-point-system',
    'Other',
    'A contact that is not a phone, fax, page or email address and is not expressible as a URL.  E.g. Internal mail address.  This SHOULD NOT be used for contacts that are expressible as a URL (e.g. Skype, Twitter, Facebook, etc.)  Extensions may be used to distinguish "other" contact types.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      ContactPointSystemEnum.PHONE,
      ContactPointSystemEnum.FAX,
      ContactPointSystemEnum.EMAIL,
      ContactPointSystemEnum.PAGER,
      ContactPointSystemEnum.URL,
      ContactPointSystemEnum.SMS,
      ContactPointSystemEnum.OTHER,
      ContactPointSystemEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (ContactPointSystemEnum.PHONE.code === code) {
      return ContactPointSystemEnum.PHONE;
    } else if (ContactPointSystemEnum.FAX.code === code) {
      return ContactPointSystemEnum.FAX;
    } else if (ContactPointSystemEnum.EMAIL.code === code) {
      return ContactPointSystemEnum.EMAIL;
    } else if (ContactPointSystemEnum.PAGER.code === code) {
      return ContactPointSystemEnum.PAGER;
    } else if (ContactPointSystemEnum.URL.code === code) {
      return ContactPointSystemEnum.URL;
    } else if (ContactPointSystemEnum.SMS.code === code) {
      return ContactPointSystemEnum.SMS;
    } else if (ContactPointSystemEnum.OTHER.code === code) {
      return ContactPointSystemEnum.OTHER;
    } else if (ContactPointSystemEnum.NULL.code === code) {
      return ContactPointSystemEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown ContactPointSystemEnum 'code' value '\${String(code)}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "ContactPointSystemEnum",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 6`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * ContactPointUseEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/contact-point-use
 * CodeSystem.name: ContactPointUse
 * CodeSystem.description: Use of contact point.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: ContactPointUseEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem ContactPointUse](http://hl7.org/fhir/contact-point-use)
 */
export class ContactPointUseEnum implements IFhirCodeEnum {
  public static readonly HOME = new FhirCodeDefinition(
    'HOME',
    'home',
    'http://hl7.org/fhir/contact-point-use',
    'Home',
    'A communication contact point at a home; attempted contacts for business purposes might intrude privacy and chances are one will contact family or other household members instead of the person one wishes to call. Typically used with urgent cases, or if no other contacts are available.',
  );
  public static readonly WORK = new FhirCodeDefinition(
    'WORK',
    'work',
    'http://hl7.org/fhir/contact-point-use',
    'Work',
    'An office contact point. First choice for business related contacts during business hours.',
  );
  public static readonly TEMP = new FhirCodeDefinition(
    'TEMP',
    'temp',
    'http://hl7.org/fhir/contact-point-use',
    'Temp',
    'A temporary contact point. The period can provide more detailed information.',
  );
  public static readonly OLD = new FhirCodeDefinition(
    'OLD',
    'old',
    'http://hl7.org/fhir/contact-point-use',
    'Old',
    'This contact point is no longer in use (or was never correct, but retained for records).',
  );
  public static readonly MOBILE = new FhirCodeDefinition(
    'MOBILE',
    'mobile',
    'http://hl7.org/fhir/contact-point-use',
    'Mobile',
    'A telecommunication device that moves and stays with its owner. May have characteristics of all other use codes, suitable for urgent matters, not the first choice for routine business.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      ContactPointUseEnum.HOME,
      ContactPointUseEnum.WORK,
      ContactPointUseEnum.TEMP,
      ContactPointUseEnum.OLD,
      ContactPointUseEnum.MOBILE,
      ContactPointUseEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (ContactPointUseEnum.HOME.code === code) {
      return ContactPointUseEnum.HOME;
    } else if (ContactPointUseEnum.WORK.code === code) {
      return ContactPointUseEnum.WORK;
    } else if (ContactPointUseEnum.TEMP.code === code) {
      return ContactPointUseEnum.TEMP;
    } else if (ContactPointUseEnum.OLD.code === code) {
      return ContactPointUseEnum.OLD;
    } else if (ContactPointUseEnum.MOBILE.code === code) {
      return ContactPointUseEnum.MOBILE;
    } else if (ContactPointUseEnum.NULL.code === code) {
      return ContactPointUseEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown ContactPointUseEnum 'code' value '\${String(code)}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "ContactPointUseEnum",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 7`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * ContributorTypeEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/contributor-type
 * CodeSystem.name: ContributorType
 * CodeSystem.description: The type of contributor.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: ContributorTypeEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem ContributorType](http://hl7.org/fhir/contributor-type)
 */
export class ContributorTypeEnum implements IFhirCodeEnum {
  public static readonly AUTHOR = new FhirCodeDefinition(
    'AUTHOR',
    'author',
    'http://hl7.org/fhir/contributor-type',
    'Author',
    'An author of the content of the module.',
  );
  public static readonly EDITOR = new FhirCodeDefinition(
    'EDITOR',
    'editor',
    'http://hl7.org/fhir/contributor-type',
    'Editor',
    'An editor of the content of the module.',
  );
  public static readonly REVIEWER = new FhirCodeDefinition(
    'REVIEWER',
    'reviewer',
    'http://hl7.org/fhir/contributor-type',
    'Reviewer',
    'A reviewer of the content of the module.',
  );
  public static readonly ENDORSER = new FhirCodeDefinition(
    'ENDORSER',
    'endorser',
    'http://hl7.org/fhir/contributor-type',
    'Endorser',
    'An endorser of the content of the module.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      ContributorTypeEnum.AUTHOR,
      ContributorTypeEnum.EDITOR,
      ContributorTypeEnum.REVIEWER,
      ContributorTypeEnum.ENDORSER,
      ContributorTypeEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (ContributorTypeEnum.AUTHOR.code === code) {
      return ContributorTypeEnum.AUTHOR;
    } else if (ContributorTypeEnum.EDITOR.code === code) {
      return ContributorTypeEnum.EDITOR;
    } else if (ContributorTypeEnum.REVIEWER.code === code) {
      return ContributorTypeEnum.REVIEWER;
    } else if (ContributorTypeEnum.ENDORSER.code === code) {
      return ContributorTypeEnum.ENDORSER;
    } else if (ContributorTypeEnum.NULL.code === code) {
      return ContributorTypeEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown ContributorTypeEnum 'code' value '\${String(code)}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "ContributorTypeEnum",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 8`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * SearchComparatorEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/search-comparator
 * CodeSystem.name: SearchComparator
 * CodeSystem.description: What Search Comparator Codes are supported in search.
 * CodeSystem.version: 5.0.0
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: SearchComparatorEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem SearchComparator](http://hl7.org/fhir/search-comparator)
 */
export class SearchComparatorEnum implements IFhirCodeEnum {
  public static readonly EQ = new FhirCodeDefinition(
    'EQ',
    'eq',
    'http://hl7.org/fhir/search-comparator',
    'Equals',
    'the value for the parameter in the resource is equal to the provided value.',
  );
  public static readonly NE = new FhirCodeDefinition(
    'NE',
    'ne',
    'http://hl7.org/fhir/search-comparator',
    'Not Equals',
    'the value for the parameter in the resource is not equal to the provided value.',
  );
  public static readonly GT = new FhirCodeDefinition(
    'GT',
    'gt',
    'http://hl7.org/fhir/search-comparator',
    'Greater Than',
    'the value for the parameter in the resource is greater than the provided value.',
  );
  public static readonly LT = new FhirCodeDefinition(
    'LT',
    'lt',
    'http://hl7.org/fhir/search-comparator',
    'Less Than',
    'the value for the parameter in the resource is less than the provided value.',
  );
  public static readonly GE = new FhirCodeDefinition(
    'GE',
    'ge',
    'http://hl7.org/fhir/search-comparator',
    'Greater or Equals',
    'the value for the parameter in the resource is greater or equal to the provided value.',
  );
  public static readonly LE = new FhirCodeDefinition(
    'LE',
    'le',
    'http://hl7.org/fhir/search-comparator',
    'Less of Equal',
    'the value for the parameter in the resource is less or equal to the provided value.',
  );
  public static readonly SA = new FhirCodeDefinition(
    'SA',
    'sa',
    'http://hl7.org/fhir/search-comparator',
    'Starts After',
    'the value for the parameter in the resource starts after the provided value.',
  );
  public static readonly EB = new FhirCodeDefinition(
    'EB',
    'eb',
    'http://hl7.org/fhir/search-comparator',
    'Ends Before',
    'the value for the parameter in the resource ends before the provided value.',
  );
  public static readonly AP = new FhirCodeDefinition(
    'AP',
    'ap',
    'http://hl7.org/fhir/search-comparator',
    'Approximately',
    'the value for the parameter in the resource is approximately the same to the provided value.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      SearchComparatorEnum.EQ,
      SearchComparatorEnum.NE,
      SearchComparatorEnum.GT,
      SearchComparatorEnum.LT,
      SearchComparatorEnum.GE,
      SearchComparatorEnum.LE,
      SearchComparatorEnum.SA,
      SearchComparatorEnum.EB,
      SearchComparatorEnum.AP,
      SearchComparatorEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (SearchComparatorEnum.EQ.code === code) {
      return SearchComparatorEnum.EQ;
    } else if (SearchComparatorEnum.NE.code === code) {
      return SearchComparatorEnum.NE;
    } else if (SearchComparatorEnum.GT.code === code) {
      return SearchComparatorEnum.GT;
    } else if (SearchComparatorEnum.LT.code === code) {
      return SearchComparatorEnum.LT;
    } else if (SearchComparatorEnum.GE.code === code) {
      return SearchComparatorEnum.GE;
    } else if (SearchComparatorEnum.LE.code === code) {
      return SearchComparatorEnum.LE;
    } else if (SearchComparatorEnum.SA.code === code) {
      return SearchComparatorEnum.SA;
    } else if (SearchComparatorEnum.EB.code === code) {
      return SearchComparatorEnum.EB;
    } else if (SearchComparatorEnum.AP.code === code) {
      return SearchComparatorEnum.AP;
    } else if (SearchComparatorEnum.NULL.code === code) {
      return SearchComparatorEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown SearchComparatorEnum 'code' value '\${String(code)}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "SearchComparatorEnum",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 9`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * SortDirectionEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/sort-direction
 * CodeSystem.name: SortDirection
 * CodeSystem.description: The possible sort directions, ascending or descending.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: SortDirectionEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem SortDirection](http://hl7.org/fhir/sort-direction)
 */
export class SortDirectionEnum implements IFhirCodeEnum {
  public static readonly ASCENDING = new FhirCodeDefinition(
    'ASCENDING',
    'ascending',
    'http://hl7.org/fhir/sort-direction',
    'Ascending',
    'Sort by the value ascending, so that lower values appear first.',
  );
  public static readonly DESCENDING = new FhirCodeDefinition(
    'DESCENDING',
    'descending',
    'http://hl7.org/fhir/sort-direction',
    'Descending',
    'Sort by the value descending, so that lower values appear last.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      SortDirectionEnum.ASCENDING,
      SortDirectionEnum.DESCENDING,
      SortDirectionEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (SortDirectionEnum.ASCENDING.code === code) {
      return SortDirectionEnum.ASCENDING;
    } else if (SortDirectionEnum.DESCENDING.code === code) {
      return SortDirectionEnum.DESCENDING;
    } else if (SortDirectionEnum.NULL.code === code) {
      return SortDirectionEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown SortDirectionEnum 'code' value '\${String(code)}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "SortDirectionEnum",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 10`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * NameUseEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/name-use
 * CodeSystem.name: NameUse
 * CodeSystem.description: The use of a human name.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: NameUseEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem NameUse](http://hl7.org/fhir/name-use)
 */
export class NameUseEnum implements IFhirCodeEnum {
  public static readonly USUAL = new FhirCodeDefinition(
    'USUAL',
    'usual',
    'http://hl7.org/fhir/name-use',
    'Usual',
    'Known as/conventional/the one you normally use.',
  );
  public static readonly OFFICIAL = new FhirCodeDefinition(
    'OFFICIAL',
    'official',
    'http://hl7.org/fhir/name-use',
    'Official',
    'The formal name as registered in an official (government) registry, but which name might not be commonly used. May be called "legal name".',
  );
  public static readonly TEMP = new FhirCodeDefinition(
    'TEMP',
    'temp',
    'http://hl7.org/fhir/name-use',
    'Temp',
    'A temporary name. Name.period can provide more detailed information. This may also be used for temporary names assigned at birth or in emergency situations.',
  );
  public static readonly NICKNAME = new FhirCodeDefinition(
    'NICKNAME',
    'nickname',
    'http://hl7.org/fhir/name-use',
    'Nickname',
    'A name that is used to address the person in an informal manner, but is not part of their formal or usual name.',
  );
  public static readonly ANONYMOUS = new FhirCodeDefinition(
    'ANONYMOUS',
    'anonymous',
    'http://hl7.org/fhir/name-use',
    'Anonymous',
    'Anonymous assigned name, alias, or pseudonym (used to protect a person\\'s identity for privacy reasons).',
  );
  public static readonly OLD = new FhirCodeDefinition(
    'OLD',
    'old',
    'http://hl7.org/fhir/name-use',
    'Old',
    'This name is no longer in use (or was never correct, but retained for records).',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      NameUseEnum.USUAL,
      NameUseEnum.OFFICIAL,
      NameUseEnum.TEMP,
      NameUseEnum.NICKNAME,
      NameUseEnum.ANONYMOUS,
      NameUseEnum.OLD,
      NameUseEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (NameUseEnum.USUAL.code === code) {
      return NameUseEnum.USUAL;
    } else if (NameUseEnum.OFFICIAL.code === code) {
      return NameUseEnum.OFFICIAL;
    } else if (NameUseEnum.TEMP.code === code) {
      return NameUseEnum.TEMP;
    } else if (NameUseEnum.NICKNAME.code === code) {
      return NameUseEnum.NICKNAME;
    } else if (NameUseEnum.ANONYMOUS.code === code) {
      return NameUseEnum.ANONYMOUS;
    } else if (NameUseEnum.OLD.code === code) {
      return NameUseEnum.OLD;
    } else if (NameUseEnum.NULL.code === code) {
      return NameUseEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown NameUseEnum 'code' value '\${String(code)}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "NameUseEnum",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 11`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * IdentifierUseEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/identifier-use
 * CodeSystem.name: IdentifierUse
 * CodeSystem.description: Identifies the purpose for this identifier, if known .
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: IdentifierUseEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem IdentifierUse](http://hl7.org/fhir/identifier-use)
 */
export class IdentifierUseEnum implements IFhirCodeEnum {
  public static readonly USUAL = new FhirCodeDefinition(
    'USUAL',
    'usual',
    'http://hl7.org/fhir/identifier-use',
    'Usual',
    'The identifier recommended for display and use in real-world interactions.',
  );
  public static readonly OFFICIAL = new FhirCodeDefinition(
    'OFFICIAL',
    'official',
    'http://hl7.org/fhir/identifier-use',
    'Official',
    'The identifier considered to be most trusted for the identification of this item. Sometimes also known as "primary" and "main". The determination of "official" is subjective and implementation guides often provide additional guidelines for use.',
  );
  public static readonly TEMP = new FhirCodeDefinition(
    'TEMP',
    'temp',
    'http://hl7.org/fhir/identifier-use',
    'Temp',
    'A temporary identifier.',
  );
  public static readonly SECONDARY = new FhirCodeDefinition(
    'SECONDARY',
    'secondary',
    'http://hl7.org/fhir/identifier-use',
    'Secondary',
    'An identifier that was assigned in secondary use - it serves to identify the object in a relative context, but cannot be consistently assigned to the same object again in a different context.',
  );
  public static readonly OLD = new FhirCodeDefinition(
    'OLD',
    'old',
    'http://hl7.org/fhir/identifier-use',
    'Old',
    'The identifier id no longer considered valid, but may be relevant for search purposes.  E.g. Changes to identifier schemes, account merges, etc.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      IdentifierUseEnum.USUAL,
      IdentifierUseEnum.OFFICIAL,
      IdentifierUseEnum.TEMP,
      IdentifierUseEnum.SECONDARY,
      IdentifierUseEnum.OLD,
      IdentifierUseEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (IdentifierUseEnum.USUAL.code === code) {
      return IdentifierUseEnum.USUAL;
    } else if (IdentifierUseEnum.OFFICIAL.code === code) {
      return IdentifierUseEnum.OFFICIAL;
    } else if (IdentifierUseEnum.TEMP.code === code) {
      return IdentifierUseEnum.TEMP;
    } else if (IdentifierUseEnum.SECONDARY.code === code) {
      return IdentifierUseEnum.SECONDARY;
    } else if (IdentifierUseEnum.OLD.code === code) {
      return IdentifierUseEnum.OLD;
    } else if (IdentifierUseEnum.NULL.code === code) {
      return IdentifierUseEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown IdentifierUseEnum 'code' value '\${String(code)}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "IdentifierUseEnum",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 12`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * PriceComponentTypeEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/price-component-type
 * CodeSystem.name: PriceComponentType
 * CodeSystem.description: Codes indicating the kind of the price component.
 * CodeSystem.version: 5.0.0
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: PriceComponentTypeEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem PriceComponentType](http://hl7.org/fhir/price-component-type)
 */
export class PriceComponentTypeEnum implements IFhirCodeEnum {
  public static readonly BASE = new FhirCodeDefinition(
    'BASE',
    'base',
    'http://hl7.org/fhir/price-component-type',
    'base price',
    'the amount is the base price used for calculating the total price before applying surcharges, discount or taxes.',
  );
  public static readonly SURCHARGE = new FhirCodeDefinition(
    'SURCHARGE',
    'surcharge',
    'http://hl7.org/fhir/price-component-type',
    'surcharge',
    'the amount is a surcharge applied on the base price.',
  );
  public static readonly DEDUCTION = new FhirCodeDefinition(
    'DEDUCTION',
    'deduction',
    'http://hl7.org/fhir/price-component-type',
    'deduction',
    'the amount is a deduction applied on the base price.',
  );
  public static readonly DISCOUNT = new FhirCodeDefinition(
    'DISCOUNT',
    'discount',
    'http://hl7.org/fhir/price-component-type',
    'discount',
    'the amount is a discount applied on the base price.',
  );
  public static readonly TAX = new FhirCodeDefinition(
    'TAX',
    'tax',
    'http://hl7.org/fhir/price-component-type',
    'tax',
    'the amount is the tax component of the total price.',
  );
  public static readonly INFORMATIONAL = new FhirCodeDefinition(
    'INFORMATIONAL',
    'informational',
    'http://hl7.org/fhir/price-component-type',
    'informational',
    'the amount is of informational character, it has not been applied in the calculation of the total price.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      PriceComponentTypeEnum.BASE,
      PriceComponentTypeEnum.SURCHARGE,
      PriceComponentTypeEnum.DEDUCTION,
      PriceComponentTypeEnum.DISCOUNT,
      PriceComponentTypeEnum.TAX,
      PriceComponentTypeEnum.INFORMATIONAL,
      PriceComponentTypeEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (PriceComponentTypeEnum.BASE.code === code) {
      return PriceComponentTypeEnum.BASE;
    } else if (PriceComponentTypeEnum.SURCHARGE.code === code) {
      return PriceComponentTypeEnum.SURCHARGE;
    } else if (PriceComponentTypeEnum.DEDUCTION.code === code) {
      return PriceComponentTypeEnum.DEDUCTION;
    } else if (PriceComponentTypeEnum.DISCOUNT.code === code) {
      return PriceComponentTypeEnum.DISCOUNT;
    } else if (PriceComponentTypeEnum.TAX.code === code) {
      return PriceComponentTypeEnum.TAX;
    } else if (PriceComponentTypeEnum.INFORMATIONAL.code === code) {
      return PriceComponentTypeEnum.INFORMATIONAL;
    } else if (PriceComponentTypeEnum.NULL.code === code) {
      return PriceComponentTypeEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown PriceComponentTypeEnum 'code' value '\${String(code)}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "PriceComponentTypeEnum",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 13`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * NarrativeStatusEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/narrative-status
 * CodeSystem.name: NarrativeStatus
 * CodeSystem.description: The status of a resource narrative.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: NarrativeStatusEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem NarrativeStatus](http://hl7.org/fhir/narrative-status)
 */
export class NarrativeStatusEnum implements IFhirCodeEnum {
  public static readonly GENERATED = new FhirCodeDefinition(
    'GENERATED',
    'generated',
    'http://hl7.org/fhir/narrative-status',
    'Generated',
    'The contents of the narrative are entirely generated from the core elements in the content.',
  );
  public static readonly EXTENSIONS = new FhirCodeDefinition(
    'EXTENSIONS',
    'extensions',
    'http://hl7.org/fhir/narrative-status',
    'Extensions',
    'The contents of the narrative are entirely generated from the core elements in the content and some of the content is generated from extensions. The narrative SHALL reflect the impact of all modifier extensions.',
  );
  public static readonly ADDITIONAL = new FhirCodeDefinition(
    'ADDITIONAL',
    'additional',
    'http://hl7.org/fhir/narrative-status',
    'Additional',
    'The contents of the narrative may contain additional information not found in the structured data. Note that there is no computable way to determine what the extra information is, other than by human inspection.',
  );
  public static readonly EMPTY = new FhirCodeDefinition(
    'EMPTY',
    'empty',
    'http://hl7.org/fhir/narrative-status',
    'Empty',
    'The contents of the narrative are some equivalent of "No human-readable text provided in this case".',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      NarrativeStatusEnum.GENERATED,
      NarrativeStatusEnum.EXTENSIONS,
      NarrativeStatusEnum.ADDITIONAL,
      NarrativeStatusEnum.EMPTY,
      NarrativeStatusEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (NarrativeStatusEnum.GENERATED.code === code) {
      return NarrativeStatusEnum.GENERATED;
    } else if (NarrativeStatusEnum.EXTENSIONS.code === code) {
      return NarrativeStatusEnum.EXTENSIONS;
    } else if (NarrativeStatusEnum.ADDITIONAL.code === code) {
      return NarrativeStatusEnum.ADDITIONAL;
    } else if (NarrativeStatusEnum.EMPTY.code === code) {
      return NarrativeStatusEnum.EMPTY;
    } else if (NarrativeStatusEnum.NULL.code === code) {
      return NarrativeStatusEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown NarrativeStatusEnum 'code' value '\${String(code)}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "NarrativeStatusEnum",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 14`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * OperationParameterUseEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/operation-parameter-use
 * CodeSystem.name: OperationParameterUse
 * CodeSystem.description: Whether an operation parameter is an input or an output parameter.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: OperationParameterUseEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem OperationParameterUse](http://hl7.org/fhir/operation-parameter-use)
 */
export class OperationParameterUseEnum implements IFhirCodeEnum {
  public static readonly IN = new FhirCodeDefinition(
    'IN',
    'in',
    'http://hl7.org/fhir/operation-parameter-use',
    'In',
    'This is an input parameter.',
  );
  public static readonly OUT = new FhirCodeDefinition(
    'OUT',
    'out',
    'http://hl7.org/fhir/operation-parameter-use',
    'Out',
    'This is an output parameter.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      OperationParameterUseEnum.IN,
      OperationParameterUseEnum.OUT,
      OperationParameterUseEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (OperationParameterUseEnum.IN.code === code) {
      return OperationParameterUseEnum.IN;
    } else if (OperationParameterUseEnum.OUT.code === code) {
      return OperationParameterUseEnum.OUT;
    } else if (OperationParameterUseEnum.NULL.code === code) {
      return OperationParameterUseEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown OperationParameterUseEnum 'code' value '\${String(code)}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "OperationParameterUseEnum",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 15`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * RelatedArtifactTypeEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/related-artifact-type
 * CodeSystem.name: RelatedArtifactType
 * CodeSystem.description: The type of relationship to the related artifact.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: RelatedArtifactTypeEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem RelatedArtifactType](http://hl7.org/fhir/related-artifact-type)
 */
export class RelatedArtifactTypeEnum implements IFhirCodeEnum {
  public static readonly DOCUMENTATION = new FhirCodeDefinition(
    'DOCUMENTATION',
    'documentation',
    'http://hl7.org/fhir/related-artifact-type',
    'Documentation',
    'Additional documentation for the knowledge resource. This would include additional instructions on usage as well as additional information on clinical context or appropriateness.',
  );
  public static readonly JUSTIFICATION = new FhirCodeDefinition(
    'JUSTIFICATION',
    'justification',
    'http://hl7.org/fhir/related-artifact-type',
    'Justification',
    'A summary of the justification for the knowledge resource including supporting evidence, relevant guidelines, or other clinically important information. This information is intended to provide a way to make the justification for the knowledge resource available to the consumer of interventions or results produced by the knowledge resource.',
  );
  public static readonly CITATION = new FhirCodeDefinition(
    'CITATION',
    'citation',
    'http://hl7.org/fhir/related-artifact-type',
    'Citation',
    'Bibliographic citation for papers, references, or other relevant material for the knowledge resource. This is intended to allow for citation of related material, but that was not necessarily specifically prepared in connection with this knowledge resource.',
  );
  public static readonly PREDECESSOR = new FhirCodeDefinition(
    'PREDECESSOR',
    'predecessor',
    'http://hl7.org/fhir/related-artifact-type',
    'Predecessor',
    'The previous version of the knowledge resource.',
  );
  public static readonly SUCCESSOR = new FhirCodeDefinition(
    'SUCCESSOR',
    'successor',
    'http://hl7.org/fhir/related-artifact-type',
    'Successor',
    'The next version of the knowledge resource.',
  );
  public static readonly DERIVED_FROM = new FhirCodeDefinition(
    'DERIVED_FROM',
    'derived-from',
    'http://hl7.org/fhir/related-artifact-type',
    'Derived From',
    'The knowledge resource is derived from the related artifact. This is intended to capture the relationship in which a particular knowledge resource is based on the content of another artifact, but is modified to capture either a different set of overall requirements, or a more specific set of requirements such as those involved in a particular institution or clinical setting.',
  );
  public static readonly DEPENDS_ON = new FhirCodeDefinition(
    'DEPENDS_ON',
    'depends-on',
    'http://hl7.org/fhir/related-artifact-type',
    'Depends On',
    'The knowledge resource depends on the given related artifact.',
  );
  public static readonly COMPOSED_OF = new FhirCodeDefinition(
    'COMPOSED_OF',
    'composed-of',
    'http://hl7.org/fhir/related-artifact-type',
    'Composed Of',
    'The knowledge resource is composed of the given related artifact.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      RelatedArtifactTypeEnum.DOCUMENTATION,
      RelatedArtifactTypeEnum.JUSTIFICATION,
      RelatedArtifactTypeEnum.CITATION,
      RelatedArtifactTypeEnum.PREDECESSOR,
      RelatedArtifactTypeEnum.SUCCESSOR,
      RelatedArtifactTypeEnum.DERIVED_FROM,
      RelatedArtifactTypeEnum.DEPENDS_ON,
      RelatedArtifactTypeEnum.COMPOSED_OF,
      RelatedArtifactTypeEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (RelatedArtifactTypeEnum.DOCUMENTATION.code === code) {
      return RelatedArtifactTypeEnum.DOCUMENTATION;
    } else if (RelatedArtifactTypeEnum.JUSTIFICATION.code === code) {
      return RelatedArtifactTypeEnum.JUSTIFICATION;
    } else if (RelatedArtifactTypeEnum.CITATION.code === code) {
      return RelatedArtifactTypeEnum.CITATION;
    } else if (RelatedArtifactTypeEnum.PREDECESSOR.code === code) {
      return RelatedArtifactTypeEnum.PREDECESSOR;
    } else if (RelatedArtifactTypeEnum.SUCCESSOR.code === code) {
      return RelatedArtifactTypeEnum.SUCCESSOR;
    } else if (RelatedArtifactTypeEnum.DERIVED_FROM.code === code) {
      return RelatedArtifactTypeEnum.DERIVED_FROM;
    } else if (RelatedArtifactTypeEnum.DEPENDS_ON.code === code) {
      return RelatedArtifactTypeEnum.DEPENDS_ON;
    } else if (RelatedArtifactTypeEnum.COMPOSED_OF.code === code) {
      return RelatedArtifactTypeEnum.COMPOSED_OF;
    } else if (RelatedArtifactTypeEnum.NULL.code === code) {
      return RelatedArtifactTypeEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown RelatedArtifactTypeEnum 'code' value '\${String(code)}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "RelatedArtifactTypeEnum",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 16`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * PublicationStatusEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/publication-status
 * CodeSystem.name: PublicationStatus
 * CodeSystem.description: The lifecycle status of an artifact.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: PublicationStatusEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem PublicationStatus](http://hl7.org/fhir/publication-status)
 */
export class PublicationStatusEnum implements IFhirCodeEnum {
  public static readonly DRAFT = new FhirCodeDefinition(
    'DRAFT',
    'draft',
    'http://hl7.org/fhir/publication-status',
    'Draft',
    'This resource is still under development and is not yet considered to be ready for normal use.',
  );
  public static readonly ACTIVE = new FhirCodeDefinition(
    'ACTIVE',
    'active',
    'http://hl7.org/fhir/publication-status',
    'Active',
    'This resource is ready for normal use.',
  );
  public static readonly RETIRED = new FhirCodeDefinition(
    'RETIRED',
    'retired',
    'http://hl7.org/fhir/publication-status',
    'Retired',
    'This resource has been withdrawn or superseded and should no longer be used.',
  );
  public static readonly UNKNOWN = new FhirCodeDefinition(
    'UNKNOWN',
    'unknown',
    'http://hl7.org/fhir/publication-status',
    'Unknown',
    'The authoring system does not know which of the status values currently applies for this resource.  Note: This concept is not to be used for "other" - one of the listed statuses is presumed to apply, it\\'s just not known which one.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      PublicationStatusEnum.DRAFT,
      PublicationStatusEnum.ACTIVE,
      PublicationStatusEnum.RETIRED,
      PublicationStatusEnum.UNKNOWN,
      PublicationStatusEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (PublicationStatusEnum.DRAFT.code === code) {
      return PublicationStatusEnum.DRAFT;
    } else if (PublicationStatusEnum.ACTIVE.code === code) {
      return PublicationStatusEnum.ACTIVE;
    } else if (PublicationStatusEnum.RETIRED.code === code) {
      return PublicationStatusEnum.RETIRED;
    } else if (PublicationStatusEnum.UNKNOWN.code === code) {
      return PublicationStatusEnum.UNKNOWN;
    } else if (PublicationStatusEnum.NULL.code === code) {
      return PublicationStatusEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown PublicationStatusEnum 'code' value '\${String(code)}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "PublicationStatusEnum",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 17`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * TriggerTypeEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/trigger-type
 * CodeSystem.name: TriggerType
 * CodeSystem.description: The type of trigger.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: TriggerTypeEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem TriggerType](http://hl7.org/fhir/trigger-type)
 */
export class TriggerTypeEnum implements IFhirCodeEnum {
  public static readonly NAMED_EVENT = new FhirCodeDefinition(
    'NAMED_EVENT',
    'named-event',
    'http://hl7.org/fhir/trigger-type',
    'Named Event',
    'The trigger occurs in response to a specific named event, and no other information about the trigger is specified. Named events are completely pre-coordinated, and the formal semantics of the trigger are not provided.',
  );
  public static readonly PERIODIC = new FhirCodeDefinition(
    'PERIODIC',
    'periodic',
    'http://hl7.org/fhir/trigger-type',
    'Periodic',
    'The trigger occurs at a specific time or periodically as described by a timing or schedule. A periodic event cannot have any data elements, but may have a name assigned as a shorthand for the event.',
  );
  public static readonly DATA_CHANGED = new FhirCodeDefinition(
    'DATA_CHANGED',
    'data-changed',
    'http://hl7.org/fhir/trigger-type',
    'Data Changed',
    'The trigger occurs whenever data of a particular type is changed in any way, either added, modified, or removed.',
  );
  public static readonly DATA_ACCESSED = new FhirCodeDefinition(
    'DATA_ACCESSED',
    'data-accessed',
    'http://hl7.org/fhir/trigger-type',
    'Data Accessed',
    'The trigger occurs whenever data of a particular type is accessed.',
  );
  public static readonly DATA_ACCESS_ENDED = new FhirCodeDefinition(
    'DATA_ACCESS_ENDED',
    'data-access-ended',
    'http://hl7.org/fhir/trigger-type',
    'Data Access Ended',
    'The trigger occurs whenever access to data of a particular type is completed.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      TriggerTypeEnum.NAMED_EVENT,
      TriggerTypeEnum.PERIODIC,
      TriggerTypeEnum.DATA_CHANGED,
      TriggerTypeEnum.DATA_ACCESSED,
      TriggerTypeEnum.DATA_ACCESS_ENDED,
      TriggerTypeEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (TriggerTypeEnum.NAMED_EVENT.code === code) {
      return TriggerTypeEnum.NAMED_EVENT;
    } else if (TriggerTypeEnum.PERIODIC.code === code) {
      return TriggerTypeEnum.PERIODIC;
    } else if (TriggerTypeEnum.DATA_CHANGED.code === code) {
      return TriggerTypeEnum.DATA_CHANGED;
    } else if (TriggerTypeEnum.DATA_ACCESSED.code === code) {
      return TriggerTypeEnum.DATA_ACCESSED;
    } else if (TriggerTypeEnum.DATA_ACCESS_ENDED.code === code) {
      return TriggerTypeEnum.DATA_ACCESS_ENDED;
    } else if (TriggerTypeEnum.NULL.code === code) {
      return TriggerTypeEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown TriggerTypeEnum 'code' value '\${String(code)}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "TriggerTypeEnum",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 18`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * AdministrativeGenderEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/administrative-gender
 * CodeSystem.name: AdministrativeGender
 * CodeSystem.description: The gender of a person used for administrative purposes.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: AdministrativeGenderEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem AdministrativeGender](http://hl7.org/fhir/administrative-gender)
 */
export class AdministrativeGenderEnum implements IFhirCodeEnum {
  public static readonly MALE = new FhirCodeDefinition(
    'MALE',
    'male',
    'http://hl7.org/fhir/administrative-gender',
    'Male',
    'Male.',
  );
  public static readonly FEMALE = new FhirCodeDefinition(
    'FEMALE',
    'female',
    'http://hl7.org/fhir/administrative-gender',
    'Female',
    'Female.',
  );
  public static readonly OTHER = new FhirCodeDefinition(
    'OTHER',
    'other',
    'http://hl7.org/fhir/administrative-gender',
    'Other',
    'Other.',
  );
  public static readonly UNKNOWN = new FhirCodeDefinition(
    'UNKNOWN',
    'unknown',
    'http://hl7.org/fhir/administrative-gender',
    'Unknown',
    'Unknown.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      AdministrativeGenderEnum.MALE,
      AdministrativeGenderEnum.FEMALE,
      AdministrativeGenderEnum.OTHER,
      AdministrativeGenderEnum.UNKNOWN,
      AdministrativeGenderEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (AdministrativeGenderEnum.MALE.code === code) {
      return AdministrativeGenderEnum.MALE;
    } else if (AdministrativeGenderEnum.FEMALE.code === code) {
      return AdministrativeGenderEnum.FEMALE;
    } else if (AdministrativeGenderEnum.OTHER.code === code) {
      return AdministrativeGenderEnum.OTHER;
    } else if (AdministrativeGenderEnum.UNKNOWN.code === code) {
      return AdministrativeGenderEnum.UNKNOWN;
    } else if (AdministrativeGenderEnum.NULL.code === code) {
      return AdministrativeGenderEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown AdministrativeGenderEnum 'code' value '\${String(code)}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "AdministrativeGenderEnum",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 19`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * LinkTypeEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/link-type
 * CodeSystem.name: LinkType
 * CodeSystem.description: The type of link between this patient resource and another patient resource.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: LinkTypeEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem LinkType](http://hl7.org/fhir/link-type)
 */
export class LinkTypeEnum implements IFhirCodeEnum {
  public static readonly REPLACED_BY = new FhirCodeDefinition(
    'REPLACED_BY',
    'replaced-by',
    'http://hl7.org/fhir/link-type',
    'Replaced-by',
    'The patient resource containing this link must no longer be used. The link points forward to another patient resource that must be used in lieu of the patient resource that contains this link.',
  );
  public static readonly REPLACES = new FhirCodeDefinition(
    'REPLACES',
    'replaces',
    'http://hl7.org/fhir/link-type',
    'Replaces',
    'The patient resource containing this link is the current active patient record. The link points back to an inactive patient resource that has been merged into this resource, and should be consulted to retrieve additional referenced information.',
  );
  public static readonly REFER = new FhirCodeDefinition(
    'REFER',
    'refer',
    'http://hl7.org/fhir/link-type',
    'Refer',
    'The patient resource containing this link is in use and valid but not considered the main source of information about a patient. The link points forward to another patient resource that should be consulted to retrieve additional patient information.',
  );
  public static readonly SEEALSO = new FhirCodeDefinition(
    'SEEALSO',
    'seealso',
    'http://hl7.org/fhir/link-type',
    'See also',
    'The patient resource containing this link is in use and valid, but points to another patient resource that is known to contain data about the same person. Data in this resource might overlap or contradict information found in the other patient resource. This link does not indicate any relative importance of the resources concerned, and both should be regarded as equally valid.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      LinkTypeEnum.REPLACED_BY,
      LinkTypeEnum.REPLACES,
      LinkTypeEnum.REFER,
      LinkTypeEnum.SEEALSO,
      LinkTypeEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (LinkTypeEnum.REPLACED_BY.code === code) {
      return LinkTypeEnum.REPLACED_BY;
    } else if (LinkTypeEnum.REPLACES.code === code) {
      return LinkTypeEnum.REPLACES;
    } else if (LinkTypeEnum.REFER.code === code) {
      return LinkTypeEnum.REFER;
    } else if (LinkTypeEnum.SEEALSO.code === code) {
      return LinkTypeEnum.SEEALSO;
    } else if (LinkTypeEnum.NULL.code === code) {
      return LinkTypeEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown LinkTypeEnum 'code' value '\${String(code)}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "LinkTypeEnum",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 20`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * TaskCodeEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/CodeSystem/task-code
 * CodeSystem.name: TaskCode
 * CodeSystem.description: Codes indicating the type of action that is expected to be performed
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: TaskCodeEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem TaskCode](http://hl7.org/fhir/CodeSystem/task-code)
 */
export class TaskCodeEnum implements IFhirCodeEnum {
  public static readonly APPROVE = new FhirCodeDefinition(
    'APPROVE',
    'approve',
    'http://hl7.org/fhir/CodeSystem/task-code',
    'Activate/approve the focal resource',
    'Take what actions are needed to transition the focus resource from \\'draft\\' to \\'active\\' or \\'in-progress\\', as appropriate for the resource type.  This may involve additing additional content, approval, validation, etc.',
  );
  public static readonly FULFILL = new FhirCodeDefinition(
    'FULFILL',
    'fulfill',
    'http://hl7.org/fhir/CodeSystem/task-code',
    'Fulfill the focal request',
    'Act to perform the actions defined in the focus request.  This might result in a \\'more assertive\\' request (order for a plan or proposal, filler order for a placer order), but is intend to eventually result in events.  The degree of fulfillment requested might be limited by Task.restriction.',
  );
  public static readonly ABORT = new FhirCodeDefinition(
    'ABORT',
    'abort',
    'http://hl7.org/fhir/CodeSystem/task-code',
    'Mark the focal resource as no longer active',
    'Abort, cancel or withdraw the focal resource, as appropriate for the type of resource.',
  );
  public static readonly REPLACE = new FhirCodeDefinition(
    'REPLACE',
    'replace',
    'http://hl7.org/fhir/CodeSystem/task-code',
    'Replace the focal resource with the input resource',
    'Replace the focal resource with the specified input resource',
  );
  public static readonly CHANGE = new FhirCodeDefinition(
    'CHANGE',
    'change',
    'http://hl7.org/fhir/CodeSystem/task-code',
    'Change the focal resource',
    'Update the focal resource of the owning system to reflect the content specified as the Task.focus',
  );
  public static readonly SUSPEND = new FhirCodeDefinition(
    'SUSPEND',
    'suspend',
    'http://hl7.org/fhir/CodeSystem/task-code',
    'Suspend the focal resource',
    'Transition the focal resource from \\'active\\' or \\'in-progress\\' to \\'suspended\\'',
  );
  public static readonly RESUME = new FhirCodeDefinition(
    'RESUME',
    'resume',
    'http://hl7.org/fhir/CodeSystem/task-code',
    'Re-activate the focal resource',
    'Transition the focal resource from \\'suspended\\' to \\'active\\' or \\'in-progress\\' as appropriate for the resource type.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      TaskCodeEnum.APPROVE,
      TaskCodeEnum.FULFILL,
      TaskCodeEnum.ABORT,
      TaskCodeEnum.REPLACE,
      TaskCodeEnum.CHANGE,
      TaskCodeEnum.SUSPEND,
      TaskCodeEnum.RESUME,
      TaskCodeEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (TaskCodeEnum.APPROVE.code === code) {
      return TaskCodeEnum.APPROVE;
    } else if (TaskCodeEnum.FULFILL.code === code) {
      return TaskCodeEnum.FULFILL;
    } else if (TaskCodeEnum.ABORT.code === code) {
      return TaskCodeEnum.ABORT;
    } else if (TaskCodeEnum.REPLACE.code === code) {
      return TaskCodeEnum.REPLACE;
    } else if (TaskCodeEnum.CHANGE.code === code) {
      return TaskCodeEnum.CHANGE;
    } else if (TaskCodeEnum.SUSPEND.code === code) {
      return TaskCodeEnum.SUSPEND;
    } else if (TaskCodeEnum.RESUME.code === code) {
      return TaskCodeEnum.RESUME;
    } else if (TaskCodeEnum.NULL.code === code) {
      return TaskCodeEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown TaskCodeEnum 'code' value '\${String(code)}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "TaskCodeEnum",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 21`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * TaskStatusEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/task-status
 * CodeSystem.name: TaskStatus
 * CodeSystem.description: The current status of the task.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: TaskStatusEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem TaskStatus](http://hl7.org/fhir/task-status)
 */
export class TaskStatusEnum implements IFhirCodeEnum {
  public static readonly DRAFT = new FhirCodeDefinition(
    'DRAFT',
    'draft',
    'http://hl7.org/fhir/task-status',
    'Draft',
    'The task is not yet ready to be acted upon.',
  );
  public static readonly REQUESTED = new FhirCodeDefinition(
    'REQUESTED',
    'requested',
    'http://hl7.org/fhir/task-status',
    'Requested',
    'The task is ready to be acted upon and action is sought.',
  );
  public static readonly RECEIVED = new FhirCodeDefinition(
    'RECEIVED',
    'received',
    'http://hl7.org/fhir/task-status',
    'Received',
    'A potential performer has claimed ownership of the task and is evaluating whether to perform it.',
  );
  public static readonly ACCEPTED = new FhirCodeDefinition(
    'ACCEPTED',
    'accepted',
    'http://hl7.org/fhir/task-status',
    'Accepted',
    'The potential performer has agreed to execute the task but has not yet started work.',
  );
  public static readonly REJECTED = new FhirCodeDefinition(
    'REJECTED',
    'rejected',
    'http://hl7.org/fhir/task-status',
    'Rejected',
    'The potential performer who claimed ownership of the task has decided not to execute it prior to performing any action.',
  );
  public static readonly READY = new FhirCodeDefinition(
    'READY',
    'ready',
    'http://hl7.org/fhir/task-status',
    'Ready',
    'The task is ready to be performed, but no action has yet been taken.  Used in place of requested/received/accepted/rejected when request assignment and acceptance is a given.',
  );
  public static readonly CANCELLED = new FhirCodeDefinition(
    'CANCELLED',
    'cancelled',
    'http://hl7.org/fhir/task-status',
    'Cancelled',
    'The task was not completed.',
  );
  public static readonly IN_PROGRESS = new FhirCodeDefinition(
    'IN_PROGRESS',
    'in-progress',
    'http://hl7.org/fhir/task-status',
    'In Progress',
    'The task has been started but is not yet complete.',
  );
  public static readonly ON_HOLD = new FhirCodeDefinition(
    'ON_HOLD',
    'on-hold',
    'http://hl7.org/fhir/task-status',
    'On Hold',
    'The task has been started but work has been paused.',
  );
  public static readonly FAILED = new FhirCodeDefinition(
    'FAILED',
    'failed',
    'http://hl7.org/fhir/task-status',
    'Failed',
    'The task was attempted but could not be completed due to some error.',
  );
  public static readonly COMPLETED = new FhirCodeDefinition(
    'COMPLETED',
    'completed',
    'http://hl7.org/fhir/task-status',
    'Completed',
    'The task has been completed.',
  );
  public static readonly ENTERED_IN_ERROR = new FhirCodeDefinition(
    'ENTERED_IN_ERROR',
    'entered-in-error',
    'http://hl7.org/fhir/task-status',
    'Entered in Error',
    'The task should never have existed and is retained only because of the possibility it may have used.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      TaskStatusEnum.DRAFT,
      TaskStatusEnum.REQUESTED,
      TaskStatusEnum.RECEIVED,
      TaskStatusEnum.ACCEPTED,
      TaskStatusEnum.REJECTED,
      TaskStatusEnum.READY,
      TaskStatusEnum.CANCELLED,
      TaskStatusEnum.IN_PROGRESS,
      TaskStatusEnum.ON_HOLD,
      TaskStatusEnum.FAILED,
      TaskStatusEnum.COMPLETED,
      TaskStatusEnum.ENTERED_IN_ERROR,
      TaskStatusEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (TaskStatusEnum.DRAFT.code === code) {
      return TaskStatusEnum.DRAFT;
    } else if (TaskStatusEnum.REQUESTED.code === code) {
      return TaskStatusEnum.REQUESTED;
    } else if (TaskStatusEnum.RECEIVED.code === code) {
      return TaskStatusEnum.RECEIVED;
    } else if (TaskStatusEnum.ACCEPTED.code === code) {
      return TaskStatusEnum.ACCEPTED;
    } else if (TaskStatusEnum.REJECTED.code === code) {
      return TaskStatusEnum.REJECTED;
    } else if (TaskStatusEnum.READY.code === code) {
      return TaskStatusEnum.READY;
    } else if (TaskStatusEnum.CANCELLED.code === code) {
      return TaskStatusEnum.CANCELLED;
    } else if (TaskStatusEnum.IN_PROGRESS.code === code) {
      return TaskStatusEnum.IN_PROGRESS;
    } else if (TaskStatusEnum.ON_HOLD.code === code) {
      return TaskStatusEnum.ON_HOLD;
    } else if (TaskStatusEnum.FAILED.code === code) {
      return TaskStatusEnum.FAILED;
    } else if (TaskStatusEnum.COMPLETED.code === code) {
      return TaskStatusEnum.COMPLETED;
    } else if (TaskStatusEnum.ENTERED_IN_ERROR.code === code) {
      return TaskStatusEnum.ENTERED_IN_ERROR;
    } else if (TaskStatusEnum.NULL.code === code) {
      return TaskStatusEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown TaskStatusEnum 'code' value '\${String(code)}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "TaskStatusEnum",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 22`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * ConsentStateCodesEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/consent-state-codes
 * CodeSystem.name: ConsentStateCodes
 * CodeSystem.description: Indicates the state of the consent.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: ConsentStateCodesEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem ConsentStateCodes](http://hl7.org/fhir/consent-state-codes)
 */
export class ConsentStateCodesEnum implements IFhirCodeEnum {
  public static readonly DRAFT = new FhirCodeDefinition(
    'DRAFT',
    'draft',
    'http://hl7.org/fhir/consent-state-codes',
    'Pending',
    'The consent is in development or awaiting use but is not yet intended to be acted upon.',
  );
  public static readonly PROPOSED = new FhirCodeDefinition(
    'PROPOSED',
    'proposed',
    'http://hl7.org/fhir/consent-state-codes',
    'Proposed',
    'The consent has been proposed but not yet agreed to by all parties. The negotiation stage.',
  );
  public static readonly ACTIVE = new FhirCodeDefinition(
    'ACTIVE',
    'active',
    'http://hl7.org/fhir/consent-state-codes',
    'Active',
    'The consent is to be followed and enforced.',
  );
  public static readonly REJECTED = new FhirCodeDefinition(
    'REJECTED',
    'rejected',
    'http://hl7.org/fhir/consent-state-codes',
    'Rejected',
    'The consent has been rejected by one or more of the parties.',
  );
  public static readonly INACTIVE = new FhirCodeDefinition(
    'INACTIVE',
    'inactive',
    'http://hl7.org/fhir/consent-state-codes',
    'Inactive',
    'The consent is terminated or replaced.',
  );
  public static readonly ENTERED_IN_ERROR = new FhirCodeDefinition(
    'ENTERED_IN_ERROR',
    'entered-in-error',
    'http://hl7.org/fhir/consent-state-codes',
    'Entered in Error',
    'The consent was created wrongly (e.g. wrong patient) and should be ignored.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      ConsentStateCodesEnum.DRAFT,
      ConsentStateCodesEnum.PROPOSED,
      ConsentStateCodesEnum.ACTIVE,
      ConsentStateCodesEnum.REJECTED,
      ConsentStateCodesEnum.INACTIVE,
      ConsentStateCodesEnum.ENTERED_IN_ERROR,
      ConsentStateCodesEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (ConsentStateCodesEnum.DRAFT.code === code) {
      return ConsentStateCodesEnum.DRAFT;
    } else if (ConsentStateCodesEnum.PROPOSED.code === code) {
      return ConsentStateCodesEnum.PROPOSED;
    } else if (ConsentStateCodesEnum.ACTIVE.code === code) {
      return ConsentStateCodesEnum.ACTIVE;
    } else if (ConsentStateCodesEnum.REJECTED.code === code) {
      return ConsentStateCodesEnum.REJECTED;
    } else if (ConsentStateCodesEnum.INACTIVE.code === code) {
      return ConsentStateCodesEnum.INACTIVE;
    } else if (ConsentStateCodesEnum.ENTERED_IN_ERROR.code === code) {
      return ConsentStateCodesEnum.ENTERED_IN_ERROR;
    } else if (ConsentStateCodesEnum.NULL.code === code) {
      return ConsentStateCodesEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown ConsentStateCodesEnum 'code' value '\${String(code)}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "ConsentStateCodesEnum",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 23`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from by the FHIR Package Generator.
 * DO NOT make any modifications!
 * 
 * index.ts Module
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

export * from './AddressTypeEnum';
export * from './AddressUseEnum';
export * from './AdministrativeGenderEnum';
export * from './ConsentStateCodesEnum';
export * from './ContactPointSystemEnum';
export * from './ContactPointUseEnum';
export * from './ContributorTypeEnum';
export * from './DaysOfWeekEnum';
export * from './IdentifierUseEnum';
export * from './LinkTypeEnum';
export * from './NameUseEnum';
export * from './NarrativeStatusEnum';
export * from './OperationParameterUseEnum';
export * from './PriceComponentTypeEnum';
export * from './PublicationStatusEnum';
export * from './QuantityComparatorEnum';
export * from './RelatedArtifactTypeEnum';
export * from './SearchComparatorEnum';
export * from './SortDirectionEnum';
export * from './TaskCodeEnum';
export * from './TaskStatusEnum';
export * from './TriggerTypeEnum';
",
  "fileExtension": "ts",
  "filename": "index",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 24`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * Address Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/Address
 * StructureDefinition.name: Address
 * StructureDefinition.description: Base StructureDefinition for Address Type: An address expressed using postal conventions (as opposed to GPS or other location definition formats).  This data type may be used to convey addresses for use in delivering mail as well as for visiting locations which might not be valid for mail delivery.  There are a variety of postal address formats defined around the world.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  CodeType,
  DataType,
  EnumCodeType,
  FhirDataTypeParser,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  PrimitiveTypeJson,
  StringType,
  assertEnumCodeType,
  assertFhirType,
  assertFhirTypeList,
  copyListValues,
  fhirCode,
  fhirCodeSchema,
  fhirString,
  fhirStringSchema,
  getPrimitiveTypeJson,
  getPrimitiveTypeListJson,
  isDefined,
  isDefinedList,
  isElementEmpty,
  isEmpty,
  parseCodeType,
  parseFhirPrimitiveData,
  parseStringType,
  setFhirComplexJson,
  setFhirPrimitiveJson,
  setFhirPrimitiveListJson,
} from '@paq-ts-fhir/fhir-core';
import {
  AddressTypeEnum,
  AddressUseEnum,
  PARSABLE_DATATYPE_MAP,
  Period,
} from '../index';

/**
 * Address Class
 *
 * @remarks
 * Base StructureDefinition for Address Type: An address expressed using postal conventions (as opposed to GPS or other location definition formats).  This data type may be used to convey addresses for use in delivering mail as well as for visiting locations which might not be valid for mail delivery.  There are a variety of postal address formats defined around the world.
 *
 * Need to be able to record postal addresses, along with notes about their use.
 *
 * **FHIR Specification**
 * - **Short:** An address expressed using postal conventions (as opposed to GPS or other location definition formats)
 * - **Definition:** An address expressed using postal conventions (as opposed to GPS or other location definition formats).  This data type may be used to convey addresses for use in delivering mail as well as for visiting locations which might not be valid for mail delivery.  There are a variety of postal address formats defined around the world.
 * - **Comment:** Note: address is intended to describe postal addresses for administrative purposes, not to describe absolute geographical coordinates.  Postal addresses are often used as proxies for physical locations (also see the [Location](https://hl7.org/fhir/location.html#) resource).
 * - **FHIR Version:** 4.0.1
 *
 * @category DataModel: ComplexType
 * @see [FHIR Address](http://hl7.org/fhir/StructureDefinition/Address)
 */
export class Address extends DataType implements IBase {
  constructor() {
    super();

    this.addressUseEnum = new AddressUseEnum();
    this.addressTypeEnum = new AddressTypeEnum();
  }

  /**
   * Parse the provided \`Address\` JSON to instantiate the Address data model.
   *
   * @param sourceJson - JSON representing FHIR \`Address\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Address
   * @returns Address data model or undefined for \`Address\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Address | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Address';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Address();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'use';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      instance.setUseElement(datatype);
    }

    fieldName = 'type';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      instance.setTypeElement(datatype);
    }

    fieldName = 'text';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setTextElement(datatype);
    }

    fieldName = 'line';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: StringType | undefined = parseStringType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addLineElement(datatype);
        }
      });
    }

    fieldName = 'city';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setCityElement(datatype);
    }

    fieldName = 'district';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setDistrictElement(datatype);
    }

    fieldName = 'state';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setStateElement(datatype);
    }

    fieldName = 'postalCode';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setPostalCodeElement(datatype);
    }

    fieldName = 'country';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setCountryElement(datatype);
    }

    fieldName = 'period';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Period | undefined = fhirDataTypeParser.parser<Period>(Period, classJsonObj[fieldName]!, sourceField);
      instance.setPeriod(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: AddressUse
   *
   * @see {@link AddressUseEnum }
   */
  private readonly addressUseEnum: AddressUseEnum;

  /**
   * Address.use Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** home | work | temp | old | billing - purpose of this address
   * - **Definition:** The purpose of this address.
   * - **Comment:** Applications can assume that an address is current unless it explicitly says that it is temporary or old.
   * - **Requirements:** Allows an appropriate address to be chosen from a list of many.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** true
   * - **isModifierReason:** This is labeled as &quot;Is Modifier&quot; because applications should not mistake a temporary or old address etc.for a current/permanent one
   * - **isSummary:** true
   */
  private use?: EnumCodeType | undefined;

  /**
   * FHIR CodeSystem: AddressType
   *
   * @see {@link AddressTypeEnum }
   */
  private readonly addressTypeEnum: AddressTypeEnum;

  /**
   * Address.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** postal | physical | both
   * - **Definition:** Distinguishes between physical addresses (those you can visit) and mailing addresses (e.g. PO Boxes and care-of addresses). Most addresses are both.
   * - **Comment:** The definition of Address states that "address is intended to describe postal addresses, not physical locations". However, many applications track whether an address has a dual purpose of being a location that can be visited as well as being a valid delivery destination, and Postal addresses are often used as proxies for physical locations (also see the [Location](https://hl7.org/fhir/location.html#) resource).
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private type_?: EnumCodeType | undefined;

  /**
   * Address.text Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Text representation of the address
   * - **Definition:** Specifies the entire address as it should be displayed e.g. on a postal label. This may be provided instead of or as well as the specific parts.
   * - **Comment:** Can provide both a text representation and parts. Applications updating an address SHALL ensure that  when both text and parts are present,  no content is included in the text that isn\\'t found in a part.
   * - **Requirements:** A renderable, unencoded form.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private text?: StringType | undefined;

  /**
   * Address.line Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Street name, number, direction & P.O. Box etc.
   * - **Definition:** This component contains the house number, apartment number, street name, street direction,  P.O. Box number, delivery hints, and similar address information.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private line?: StringType[] | undefined;

  /**
   * Address.city Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Name of city, town etc.
   * - **Definition:** The name of the city, town, suburb, village or other community or delivery center.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private city?: StringType | undefined;

  /**
   * Address.district Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** District name (aka county)
   * - **Definition:** The name of the administrative area (county).
   * - **Comment:** District is sometimes known as county, but in some regions \\'county\\' is used in place of city (municipality), so county name should be conveyed in city instead.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private district?: StringType | undefined;

  /**
   * Address.state Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Sub-unit of country (abbreviations ok)
   * - **Definition:** Sub-unit of a country with limited sovereignty in a federally organized country. A code may be used if codes are in common use (e.g. US 2 letter state codes).
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private state?: StringType | undefined;

  /**
   * Address.postalCode Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Postal code for area
   * - **Definition:** A postal code designating a region defined by the postal service.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private postalCode?: StringType | undefined;

  /**
   * Address.country Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Country (e.g. can be ISO 3166 2 or 3 letter code)
   * - **Definition:** Country - a nation as commonly understood or generally accepted.
   * - **Comment:** ISO 3166 3 letter codes can be used in place of a human readable country name.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private country?: StringType | undefined;

  /**
   * Address.period Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Time period when address was/is in use
   * - **Definition:** Time period when address was/is in use.
   * - **Requirements:** Allows addresses to be placed in historical context.
   * - **FHIR Type:** \`Period\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private period?: Period | undefined;


  /**
   * @returns the \`use\` property value as a EnumCodeType if defined; else undefined
   */
  public getUseEnumType(): EnumCodeType | undefined {
    return this.use;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`use\` property.
   *
   * @param enumType - the \`use\` value
   * @returns this
   */
  public setUseEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid Address.use';
      assertEnumCodeType<AddressUseEnum>(enumType, AddressUseEnum, errMsgPrefix);
      this.use = enumType;
    } else {
      this.use = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`use\` property exists and has a value; \`false\` otherwise
   */
  public hasUseEnumType(): boolean {
    return isDefined<EnumCodeType>(this.use) && !this.use.isEmpty() && this.use.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`use\` property value as a CodeType if defined; else undefined
   */
  public getUseElement(): CodeType | undefined {
    if (this.use === undefined) {
      return undefined;
    }
    return this.use as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`use\` property.
   *
   * @param element - the \`use\` value
   * @returns this
   */
  public setUseElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Address.use; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.use = new EnumCodeType(element, this.addressUseEnum);
    } else {
      this.use = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`use\` property exists and has a value; \`false\` otherwise
   */
  public hasUseElement(): boolean {
    return this.hasUseEnumType();
  }

  /**
   * @returns the \`use\` property value as a fhirCode if defined; else undefined
   */
  public getUse(): fhirCode | undefined {
    if (this.use === undefined) {
      return undefined;
    }
    return this.use.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`use\` property.
   *
   * @param value - the \`use\` value
   * @returns this
   */
  public setUse(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Address.use; Provided value is not an instance of fhirCode.\`;
      this.use = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.addressUseEnum);
    } else {
      this.use = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`use\` property exists and has a value; \`false\` otherwise
   */
  public hasUse(): boolean {
    return this.hasUseEnumType();
  }

  /**
   * @returns the \`type_\` property value as a EnumCodeType if defined; else undefined
   */
  public getTypeEnumType(): EnumCodeType | undefined {
    return this.type_;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`type_\` property.
   *
   * @param enumType - the \`type_\` value
   * @returns this
   */
  public setTypeEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid Address.type';
      assertEnumCodeType<AddressTypeEnum>(enumType, AddressTypeEnum, errMsgPrefix);
      this.type_ = enumType;
    } else {
      this.type_ = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasTypeEnumType(): boolean {
    return isDefined<EnumCodeType>(this.type_) && !this.type_.isEmpty() && this.type_.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`type_\` property value as a CodeType if defined; else undefined
   */
  public getTypeElement(): CodeType | undefined {
    if (this.type_ === undefined) {
      return undefined;
    }
    return this.type_ as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`type_\` property.
   *
   * @param element - the \`type_\` value
   * @returns this
   */
  public setTypeElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Address.type; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.type_ = new EnumCodeType(element, this.addressTypeEnum);
    } else {
      this.type_ = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasTypeElement(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the \`type_\` property value as a fhirCode if defined; else undefined
   */
  public getType(): fhirCode | undefined {
    if (this.type_ === undefined) {
      return undefined;
    }
    return this.type_.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`type_\` property.
   *
   * @param value - the \`type_\` value
   * @returns this
   */
  public setType(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Address.type; Provided value is not an instance of fhirCode.\`;
      this.type_ = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.addressTypeEnum);
    } else {
      this.type_ = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasType(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the \`text\` property value as a StringType object if defined; else an empty StringType object
   */
  public getTextElement(): StringType {
    return this.text ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`text\` property.
   *
   * @param element - the \`text\` value
   * @returns this
   */
  public setTextElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Address.text; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.text = element;
    } else {
      this.text = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`text\` property exists and has a value; \`false\` otherwise
   */
  public hasTextElement(): boolean {
    return isDefined<StringType>(this.text) && !this.text.isEmpty();
  }

  /**
   * @returns the \`text\` property value as a fhirString if defined; else undefined
   */
  public getText(): fhirString | undefined {
    return this.text?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`text\` property.
   *
   * @param value - the \`text\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setText(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Address.text (\${String(value)})\`;
      this.text = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.text = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`text\` property exists and has a value; \`false\` otherwise
   */
  public hasText(): boolean {
    return this.hasTextElement();
  }

  /**
   * @returns the \`line\` property value as a StringType array
   */
  public getLineElement(): StringType[] {
    return this.line ?? ([] as StringType[]);
  }

  /**
   * Assigns the provided StringType array value to the \`line\` property.
   *
   * @param element - the \`line\` array value
   * @returns this
   */
  public setLineElement(element: StringType[] | undefined): this {
    if (isDefinedList<StringType>(element)) {
      const optErrMsg = \`Invalid Address.line; Provided value array has an element that is not an instance of StringType.\`;
      assertFhirTypeList<StringType>(element, StringType, optErrMsg);
      this.line = element;
    } else {
      this.line = undefined;
    }
    return this;
  }

  /**
   * Add the provided StringType value to the \`line\` array property.
   *
   * @param element - the \`line\` value
   * @returns this
   */
  public addLineElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Address.line; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.initLine();
      this.line?.push(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`line\` property exists and has a value; \`false\` otherwise
   */
  public hasLineElement(): boolean {
    return isDefinedList<StringType>(this.line) && this.line.some((item: StringType) => !item.isEmpty());
  }

  /**
   * @returns the \`line\` property value as a fhirString array
   */
  public getLine(): fhirString[] {
    this.initLine();
    const lineValues = [] as fhirString[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.line!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        lineValues.push(value);
      }
    }
    return lineValues;
  }

  /**
   * Assigns the provided primitive value array to the \`line\` property.
   *
   * @param value - the \`line\` value array
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setLine(value: fhirString[] | undefined): this {
    if (isDefinedList<fhirString>(value)) {
      const lineElements = [] as StringType[];
      for (const lineValue of value) {
        const optErrMsg = \`Invalid Address.line array item (\${String(lineValue)})\`;
        const element = new StringType(parseFhirPrimitiveData(lineValue, fhirStringSchema, optErrMsg));
        lineElements.push(element);
      }
      this.line = lineElements;
    } else {
      this.line = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`line\` array property.
   *
   * @param value - the \`line\` value
   * @returns this
   */
  public addLine(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Address.line array item (\${String(value)})\`;
      const element = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
      this.initLine();
      this.addLineElement(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`line\` property exists and has a value; \`false\` otherwise
   */
  public hasLine(): boolean {
    return this.hasLineElement();
  }

  /**
   * Initialize the \`line\` property
   */
  private initLine(): void {
    if (!this.hasLine()) {
      this.line = [] as StringType[];
    }
  }

  /**
   * @returns the \`city\` property value as a StringType object if defined; else an empty StringType object
   */
  public getCityElement(): StringType {
    return this.city ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`city\` property.
   *
   * @param element - the \`city\` value
   * @returns this
   */
  public setCityElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Address.city; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.city = element;
    } else {
      this.city = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`city\` property exists and has a value; \`false\` otherwise
   */
  public hasCityElement(): boolean {
    return isDefined<StringType>(this.city) && !this.city.isEmpty();
  }

  /**
   * @returns the \`city\` property value as a fhirString if defined; else undefined
   */
  public getCity(): fhirString | undefined {
    return this.city?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`city\` property.
   *
   * @param value - the \`city\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setCity(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Address.city (\${String(value)})\`;
      this.city = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.city = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`city\` property exists and has a value; \`false\` otherwise
   */
  public hasCity(): boolean {
    return this.hasCityElement();
  }

  /**
   * @returns the \`district\` property value as a StringType object if defined; else an empty StringType object
   */
  public getDistrictElement(): StringType {
    return this.district ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`district\` property.
   *
   * @param element - the \`district\` value
   * @returns this
   */
  public setDistrictElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Address.district; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.district = element;
    } else {
      this.district = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`district\` property exists and has a value; \`false\` otherwise
   */
  public hasDistrictElement(): boolean {
    return isDefined<StringType>(this.district) && !this.district.isEmpty();
  }

  /**
   * @returns the \`district\` property value as a fhirString if defined; else undefined
   */
  public getDistrict(): fhirString | undefined {
    return this.district?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`district\` property.
   *
   * @param value - the \`district\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setDistrict(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Address.district (\${String(value)})\`;
      this.district = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.district = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`district\` property exists and has a value; \`false\` otherwise
   */
  public hasDistrict(): boolean {
    return this.hasDistrictElement();
  }

  /**
   * @returns the \`state\` property value as a StringType object if defined; else an empty StringType object
   */
  public getStateElement(): StringType {
    return this.state ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`state\` property.
   *
   * @param element - the \`state\` value
   * @returns this
   */
  public setStateElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Address.state; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.state = element;
    } else {
      this.state = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`state\` property exists and has a value; \`false\` otherwise
   */
  public hasStateElement(): boolean {
    return isDefined<StringType>(this.state) && !this.state.isEmpty();
  }

  /**
   * @returns the \`state\` property value as a fhirString if defined; else undefined
   */
  public getState(): fhirString | undefined {
    return this.state?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`state\` property.
   *
   * @param value - the \`state\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setState(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Address.state (\${String(value)})\`;
      this.state = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.state = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`state\` property exists and has a value; \`false\` otherwise
   */
  public hasState(): boolean {
    return this.hasStateElement();
  }

  /**
   * @returns the \`postalCode\` property value as a StringType object if defined; else an empty StringType object
   */
  public getPostalCodeElement(): StringType {
    return this.postalCode ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`postalCode\` property.
   *
   * @param element - the \`postalCode\` value
   * @returns this
   */
  public setPostalCodeElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Address.postalCode; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.postalCode = element;
    } else {
      this.postalCode = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`postalCode\` property exists and has a value; \`false\` otherwise
   */
  public hasPostalCodeElement(): boolean {
    return isDefined<StringType>(this.postalCode) && !this.postalCode.isEmpty();
  }

  /**
   * @returns the \`postalCode\` property value as a fhirString if defined; else undefined
   */
  public getPostalCode(): fhirString | undefined {
    return this.postalCode?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`postalCode\` property.
   *
   * @param value - the \`postalCode\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setPostalCode(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Address.postalCode (\${String(value)})\`;
      this.postalCode = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.postalCode = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`postalCode\` property exists and has a value; \`false\` otherwise
   */
  public hasPostalCode(): boolean {
    return this.hasPostalCodeElement();
  }

  /**
   * @returns the \`country\` property value as a StringType object if defined; else an empty StringType object
   */
  public getCountryElement(): StringType {
    return this.country ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`country\` property.
   *
   * @param element - the \`country\` value
   * @returns this
   */
  public setCountryElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Address.country; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.country = element;
    } else {
      this.country = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`country\` property exists and has a value; \`false\` otherwise
   */
  public hasCountryElement(): boolean {
    return isDefined<StringType>(this.country) && !this.country.isEmpty();
  }

  /**
   * @returns the \`country\` property value as a fhirString if defined; else undefined
   */
  public getCountry(): fhirString | undefined {
    return this.country?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`country\` property.
   *
   * @param value - the \`country\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setCountry(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Address.country (\${String(value)})\`;
      this.country = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.country = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`country\` property exists and has a value; \`false\` otherwise
   */
  public hasCountry(): boolean {
    return this.hasCountryElement();
  }

  /**
   * @returns the \`period\` property value as a Period object if defined; else an empty Period object
   */
  public getPeriod(): Period {
    return this.period ?? new Period();
  }

  /**
   * Assigns the provided Period object value to the \`period\` property.
   *
   * @param value - the \`period\` object value
   * @returns this
   */
  public setPeriod(value: Period | undefined): this {
    if (isDefined<Period>(value)) {
      const optErrMsg = \`Invalid Address.period; Provided element is not an instance of Period.\`;
      assertFhirType<Period>(value, Period, optErrMsg);
      this.period = value;
    } else {
      this.period = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`period\` property exists and has a value; \`false\` otherwise
   */
  public hasPeriod(): boolean {
    return isDefined<Period>(this.period) && !this.period.isEmpty();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Address';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.use,
      this.type_,
      this.text,
      this.line,
      this.city,
      this.district,
      this.state,
      this.postalCode,
      this.country,
      this.period,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Address {
    const dest = new Address();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Address): void {
    super.copyValues(dest);
    dest.use = this.use?.copy();
    dest.type_ = this.type_?.copy();
    dest.text = this.text?.copy();
    const lineList = copyListValues<StringType>(this.line);
    dest.line = lineList.length === 0 ? undefined : lineList;
    dest.city = this.city?.copy();
    dest.district = this.district?.copy();
    dest.state = this.state?.copy();
    dest.postalCode = this.postalCode?.copy();
    dest.country = this.country?.copy();
    dest.period = this.period?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasUseElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getUseElement()!, 'use', jsonObj);
    }

    if (this.hasTypeElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getTypeElement()!, 'type', jsonObj);
    }

    if (this.hasTextElement()) {
      setFhirPrimitiveJson<fhirString>(this.getTextElement(), 'text', jsonObj);
    }

    if (this.hasLine()) {
      setFhirPrimitiveListJson(this.getLineElement(), 'line', jsonObj);
    }

    if (this.hasCityElement()) {
      setFhirPrimitiveJson<fhirString>(this.getCityElement(), 'city', jsonObj);
    }

    if (this.hasDistrictElement()) {
      setFhirPrimitiveJson<fhirString>(this.getDistrictElement(), 'district', jsonObj);
    }

    if (this.hasStateElement()) {
      setFhirPrimitiveJson<fhirString>(this.getStateElement(), 'state', jsonObj);
    }

    if (this.hasPostalCodeElement()) {
      setFhirPrimitiveJson<fhirString>(this.getPostalCodeElement(), 'postalCode', jsonObj);
    }

    if (this.hasCountryElement()) {
      setFhirPrimitiveJson<fhirString>(this.getCountryElement(), 'country', jsonObj);
    }

    if (this.hasPeriod()) {
      setFhirComplexJson(this.getPeriod(), 'period', jsonObj);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "Address",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 25`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * Age Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/Age
 * StructureDefinition.name: Age
 * StructureDefinition.description: Age Type: A duration of time during which an organism (or a process) has existed.
 * StructureDefinition.fhirVersion: 5.0.0
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  CodeType,
  DataType,
  DecimalType,
  EnumCodeType,
  FhirDataTypeParser,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  StringType,
  UriType,
  assertEnumCodeType,
  assertFhirType,
  fhirCode,
  fhirCodeSchema,
  fhirDecimal,
  fhirDecimalSchema,
  fhirString,
  fhirStringSchema,
  fhirUri,
  fhirUriSchema,
  getPrimitiveTypeJson,
  isDefined,
  isElementEmpty,
  isEmpty,
  parseCodeType,
  parseDecimalType,
  parseFhirPrimitiveData,
  parseStringType,
  parseUriType,
  setFhirPrimitiveJson,
} from '@paq-ts-fhir/fhir-core';
import {
  PARSABLE_DATATYPE_MAP,
  QuantityComparatorEnum,
} from '../index';

/**
 * Age Class
 *
 * @remarks
 * Age Type: A duration of time during which an organism (or a process) has existed.
 *
 * **FHIR Specification**
 * - **Short:** A duration of time during which an organism (or a process) has existed
 * - **Definition:** A duration of time during which an organism (or a process) has existed.
 * - **Comment:** The context of use may frequently define what kind of quantity this is and therefore what kind of units can be used. The context of use may also restrict the values for the comparator.
 * - **FHIR Version:** 5.0.0
 *
 * @category DataModel: ComplexType
 * @see [FHIR Age](http://hl7.org/fhir/StructureDefinition/Age)
 */
export class Age extends DataType implements IBase {
  constructor() {
    super();

    this.quantityComparatorEnum = new QuantityComparatorEnum();
  }

  /**
   * Parse the provided \`Age\` JSON to instantiate the Age data model.
   *
   * @param sourceJson - JSON representing FHIR \`Age\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Age
   * @returns Age data model or undefined for \`Age\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Age | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Age';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Age();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'value';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = parseDecimalType(dtJson, dtSiblingJson);
      instance.setValueElement(datatype);
    }

    fieldName = 'comparator';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      instance.setComparatorElement(datatype);
    }

    fieldName = 'unit';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setUnitElement(datatype);
    }

    fieldName = 'system';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = parseUriType(dtJson, dtSiblingJson);
      instance.setSystemElement(datatype);
    }

    fieldName = 'code';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      instance.setCodeElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Age.value Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Numerical value (with implicit precision)
   * - **Definition:** The value of the measured amount. The value includes an implicit precision in the presentation of the value.
   * - **Comment:** The implicit precision in the value should always be honored. Monetary values have their own rules for handling precision (refer to standard accounting text books).
   * - **Requirements:** Precision is handled implicitly in almost all cases of measurement.
   * - **FHIR Type:** \`decimal\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private value?: DecimalType | undefined;

  /**
   * FHIR CodeSystem: QuantityComparator
   *
   * @see {@link QuantityComparatorEnum }
   */
  private readonly quantityComparatorEnum: QuantityComparatorEnum;

  /**
   * Age.comparator Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** < | <= | >= | > | ad - how to understand the value
   * - **Definition:** How the value should be understood and represented - whether the actual value is greater or less than the stated value due to measurement issues; e.g. if the comparator is "<" , then the real value is < stated value.
   * - **Requirements:** Need a framework for handling measures where the value is <5ug/L or >400mg/L due to the limitations of measuring methodology.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** true
   * - **isModifierReason:** This is labeled as &quot;Is Modifier&quot; because the comparator modifies the interpretation of the value significantly. If there is no comparator, then there is no modification of the value
   * - **isSummary:** true
   */
  private comparator?: EnumCodeType | undefined;

  /**
   * Age.unit Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Unit representation
   * - **Definition:** A human-readable form of the unit.
   * - **Requirements:** There are many representations for units of measure and in many contexts, particular representations are fixed and required. I.e. mcg for micrograms.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private unit?: StringType | undefined;

  /**
   * Age.system Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** System that defines coded unit form
   * - **Definition:** The identification of the system that provides the coded form of the unit.
   * - **Requirements:** Need to know the system that defines the coded form of the unit.
   * - **FHIR Type:** \`uri\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private system?: UriType | undefined;

  /**
   * Age.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Coded form of the unit
   * - **Definition:** A computer processable form of the unit in some unit representation system.
   * - **Comment:** The preferred system is UCUM, but SNOMED CT can also be used (for customary units) or ISO 4217 for currency.  The context of use may additionally require a code from a particular system.
   * - **Requirements:** Need a computable form of the unit that is fixed across all forms. UCUM provides this for quantities, but SNOMED CT provides many units of interest.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code?: CodeType | undefined;


  /**
   * @returns the \`value\` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getValueElement(): DecimalType {
    return this.value ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`value\` property.
   *
   * @param element - the \`value\` value
   * @returns this
   */
  public setValueElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = \`Invalid Age.value; Provided element is not an instance of DecimalType.\`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.value = element;
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`value\` property exists and has a value; \`false\` otherwise
   */
  public hasValueElement(): boolean {
    return isDefined<DecimalType>(this.value) && !this.value.isEmpty();
  }

  /**
   * @returns the \`value\` property value as a fhirDecimal if defined; else undefined
   */
  public getValue(): fhirDecimal | undefined {
    return this.value?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`value\` property.
   *
   * @param value - the \`value\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setValue(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = \`Invalid Age.value (\${String(value)})\`;
      this.value = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`value\` property exists and has a value; \`false\` otherwise
   */
  public hasValue(): boolean {
    return this.hasValueElement();
  }

  /**
   * @returns the \`comparator\` property value as a EnumCodeType if defined; else undefined
   */
  public getComparatorEnumType(): EnumCodeType | undefined {
    return this.comparator;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`comparator\` property.
   *
   * @param enumType - the \`comparator\` value
   * @returns this
   */
  public setComparatorEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid Age.comparator';
      assertEnumCodeType<QuantityComparatorEnum>(enumType, QuantityComparatorEnum, errMsgPrefix);
      this.comparator = enumType;
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`comparator\` property exists and has a value; \`false\` otherwise
   */
  public hasComparatorEnumType(): boolean {
    return isDefined<EnumCodeType>(this.comparator) && !this.comparator.isEmpty() && this.comparator.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`comparator\` property value as a CodeType if defined; else undefined
   */
  public getComparatorElement(): CodeType | undefined {
    if (this.comparator === undefined) {
      return undefined;
    }
    return this.comparator as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`comparator\` property.
   *
   * @param element - the \`comparator\` value
   * @returns this
   */
  public setComparatorElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Age.comparator; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.comparator = new EnumCodeType(element, this.quantityComparatorEnum);
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`comparator\` property exists and has a value; \`false\` otherwise
   */
  public hasComparatorElement(): boolean {
    return this.hasComparatorEnumType();
  }

  /**
   * @returns the \`comparator\` property value as a fhirCode if defined; else undefined
   */
  public getComparator(): fhirCode | undefined {
    if (this.comparator === undefined) {
      return undefined;
    }
    return this.comparator.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`comparator\` property.
   *
   * @param value - the \`comparator\` value
   * @returns this
   */
  public setComparator(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Age.comparator; Provided value is not an instance of fhirCode.\`;
      this.comparator = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.quantityComparatorEnum);
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`comparator\` property exists and has a value; \`false\` otherwise
   */
  public hasComparator(): boolean {
    return this.hasComparatorEnumType();
  }

  /**
   * @returns the \`unit\` property value as a StringType object if defined; else an empty StringType object
   */
  public getUnitElement(): StringType {
    return this.unit ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`unit\` property.
   *
   * @param element - the \`unit\` value
   * @returns this
   */
  public setUnitElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Age.unit; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.unit = element;
    } else {
      this.unit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`unit\` property exists and has a value; \`false\` otherwise
   */
  public hasUnitElement(): boolean {
    return isDefined<StringType>(this.unit) && !this.unit.isEmpty();
  }

  /**
   * @returns the \`unit\` property value as a fhirString if defined; else undefined
   */
  public getUnit(): fhirString | undefined {
    return this.unit?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`unit\` property.
   *
   * @param value - the \`unit\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setUnit(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Age.unit (\${String(value)})\`;
      this.unit = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.unit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`unit\` property exists and has a value; \`false\` otherwise
   */
  public hasUnit(): boolean {
    return this.hasUnitElement();
  }

  /**
   * @returns the \`system\` property value as a UriType object if defined; else an empty UriType object
   */
  public getSystemElement(): UriType {
    return this.system ?? new UriType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`system\` property.
   *
   * @param element - the \`system\` value
   * @returns this
   */
  public setSystemElement(element: UriType | undefined): this {
    if (isDefined<UriType>(element)) {
      const optErrMsg = \`Invalid Age.system; Provided element is not an instance of UriType.\`;
      assertFhirType<UriType>(element, UriType, optErrMsg);
      this.system = element;
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`system\` property exists and has a value; \`false\` otherwise
   */
  public hasSystemElement(): boolean {
    return isDefined<UriType>(this.system) && !this.system.isEmpty();
  }

  /**
   * @returns the \`system\` property value as a fhirUri if defined; else undefined
   */
  public getSystem(): fhirUri | undefined {
    return this.system?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`system\` property.
   *
   * @param value - the \`system\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setSystem(value: fhirUri | undefined): this {
    if (isDefined<fhirUri>(value)) {
      const optErrMsg = \`Invalid Age.system (\${String(value)})\`;
      this.system = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`system\` property exists and has a value; \`false\` otherwise
   */
  public hasSystem(): boolean {
    return this.hasSystemElement();
  }

  /**
   * @returns the \`code\` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getCodeElement(): CodeType {
    return this.code ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`code\` property.
   *
   * @param element - the \`code\` value
   * @returns this
   */
  public setCodeElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Age.code; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.code = element;
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`code\` property exists and has a value; \`false\` otherwise
   */
  public hasCodeElement(): boolean {
    return isDefined<CodeType>(this.code) && !this.code.isEmpty();
  }

  /**
   * @returns the \`code\` property value as a fhirCode if defined; else undefined
   */
  public getCode(): fhirCode | undefined {
    return this.code?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`code\` property.
   *
   * @param value - the \`code\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setCode(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Age.code (\${String(value)})\`;
      this.code = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`code\` property exists and has a value; \`false\` otherwise
   */
  public hasCode(): boolean {
    return this.hasCodeElement();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Age';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.value,
      this.comparator,
      this.unit,
      this.system,
      this.code,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Age {
    const dest = new Age();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Age): void {
    super.copyValues(dest);
    dest.value = this.value?.copy();
    dest.comparator = this.comparator?.copy();
    dest.unit = this.unit?.copy();
    dest.system = this.system?.copy();
    dest.code = this.code?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasValueElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getValueElement(), 'value', jsonObj);
    }

    if (this.hasComparatorElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getComparatorElement()!, 'comparator', jsonObj);
    }

    if (this.hasUnitElement()) {
      setFhirPrimitiveJson<fhirString>(this.getUnitElement(), 'unit', jsonObj);
    }

    if (this.hasSystemElement()) {
      setFhirPrimitiveJson<fhirUri>(this.getSystemElement(), 'system', jsonObj);
    }

    if (this.hasCodeElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getCodeElement(), 'code', jsonObj);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "Age",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 26`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * Annotation Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/Annotation
 * StructureDefinition.name: Annotation
 * StructureDefinition.description: Annotation Type: A  text note which also  contains information about who made the statement and when.
 * StructureDefinition.fhirVersion: 5.0.0
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  ChoiceDataTypes,
  ChoiceDataTypesMeta,
  DataType,
  DateTimeType,
  FhirDataTypeParser,
  FhirError,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  InvalidTypeError,
  JSON,
  MarkdownType,
  PrimitiveType,
  REQUIRED_PROPERTIES_DO_NOT_EXIST,
  REQUIRED_PROPERTIES_REQD_IN_JSON,
  StringType,
  assertFhirType,
  assertIsDefined,
  fhirDateTime,
  fhirDateTimeSchema,
  fhirMarkdown,
  fhirMarkdownSchema,
  getPrimitiveTypeJson,
  isDefined,
  isElementEmpty,
  isEmpty,
  parseDateTimeType,
  parseFhirPrimitiveData,
  parseMarkdownType,
  setFhirPrimitiveJson,
  setPolymorphicValueJson,
} from '@paq-ts-fhir/fhir-core';
import {
  PARSABLE_DATATYPE_MAP,
  Reference,
} from '../index';

// eslint-disable-next-line @typescript-eslint/no-explicit-any -- Symbol.metadata polyfill secret sauce for decorator metadata
(Symbol.metadata as any) ??= Symbol('Symbol.metadata');

/**
 * Annotation Class
 *
 * @remarks
 * Annotation Type: A  text note which also  contains information about who made the statement and when.
 *
 * **FHIR Specification**
 * - **Short:** Text node with attribution
 * - **Definition:** A  text note which also  contains information about who made the statement and when.
 * - **Comment:** For systems that do not have structured annotations, they can simply communicate a single annotation with no author or time.  This element may need to be included in narrative because of the potential for modifying information.  *Annotations SHOULD NOT* be used to communicate "modifying" information that could be computable. (This is a SHOULD because enforcing user behavior is nearly impossible).
 * - **FHIR Version:** 5.0.0
 *
 * @category DataModel: ComplexType
 * @see [FHIR Annotation](http://hl7.org/fhir/StructureDefinition/Annotation)
 */
export class Annotation extends DataType implements IBase {
  constructor(text: MarkdownType | fhirMarkdown | null = null) {
    super();

    this.text = null;
    if (isDefined<MarkdownType | fhirMarkdown>(text)) {
      if (text instanceof PrimitiveType) {
        this.setTextElement(text);
      } else {
        this.setText(text);
      }
    }
  }

  /**
   * Parse the provided \`Annotation\` JSON to instantiate the Annotation data model.
   *
   * @param sourceJson - JSON representing FHIR \`Annotation\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Annotation
   * @returns Annotation data model or undefined for \`Annotation\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Annotation | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Annotation';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Annotation();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const classMetadata: DecoratorMetadataObject | null = Annotation[Symbol.metadata];
    const errorMessage = \`DecoratorMetadataObject does not exist for Annotation\`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    const missingReqdProperties: string[] = [];

    fieldName = 'author[x]';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const author: DataType | undefined = fhirDataTypeParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setAuthor(author);

    fieldName = 'time';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DateTimeType | undefined = parseDateTimeType(dtJson, dtSiblingJson);
      instance.setTimeElement(datatype);
    }

    fieldName = 'text';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: MarkdownType | undefined = parseMarkdownType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setTextElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Annotation.author[x] Element
   *
   * @decorator \`@ChoiceDataTypesMeta('Annotation.author[x]', ['Reference','string',]\`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Individual responsible for the annotation
   * - **Definition:** The individual responsible for making the annotation.
   * - **Comment:** Organization is used when there\\'s no need for specific attribution as to who made the comment.
   * - **FHIR Types:**
   *     'Reference',
   *     'string',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('Annotation.author[x]',[
    'Reference',
    'string',
  ])
  private author?: DataType | undefined;

  /**
   * Annotation.time Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** When the annotation was made
   * - **Definition:** Indicates when this particular annotation was made.
   * - **FHIR Type:** \`dateTime\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private time?: DateTimeType | undefined;

  /**
   * Annotation.text Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The annotation  - text content (as markdown)
   * - **Definition:** The text of the annotation in markdown format.
   * - **FHIR Type:** \`markdown\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private text: MarkdownType | null;


  /**
   * @returns the \`author\` property value as a DataType object if defined; else undefined
   */
  public getAuthor(): DataType | undefined {
    return this.author;
  }

  /**
   * Assigns the provided DataType object value to the \`author\` property.
   *
   * @decorator \`@ChoiceDataTypes('Annotation.author[x]')\`
   *
   * @param value - the \`author\` object value
   * @returns this
   */
  @ChoiceDataTypes('Annotation.author[x]')
  public setAuthor(value: DataType | undefined): this {
    if (isDefined<DataType>(value)) {
      // assertFhirType<DataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.author = value;
    } else {
      this.author = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`author\` property exists and has a value; \`false\` otherwise
   */
  public hasAuthor(): boolean {
    return isDefined<DataType>(this.author) && !this.author.isEmpty();
  }

  // *** NOTE ***
  // Next "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the \`author\` property value as a Reference object if defined; else undefined
   */
  public getAuthorReference(): Reference | undefined {
    if (!isDefined<DataType | undefined>(this.author)) {
      return undefined;
    }
    if (!(this.author instanceof Reference)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Annotation.author[x]: Expected Reference but encountered \${this.author.fhirType()}\`,
      );
    }
    return this.author;
  }

  /**
   * @returns \`true\` if the \`author\` property exists as a Reference and has a value; \`false\` otherwise
   */
  public hasAuthorReference(): boolean {
    return this.hasAuthor() && this.author instanceof Reference;
  }

  /**
   * @returns the \`author\` property value as a StringType object if defined; else undefined
   */
  public getAuthorStringType(): StringType | undefined {
    if (!isDefined<DataType | undefined>(this.author)) {
      return undefined;
    }
    if (!(this.author instanceof StringType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Annotation.author[x]: Expected StringType but encountered \${this.author.fhirType()}\`,
      );
    }
    return this.author;
  }

  /**
   * @returns \`true\` if the \`author\` property exists as a StringType and has a value; \`false\` otherwise
   */
  public hasAuthorStringType(): boolean {
    return this.hasAuthor() && this.author instanceof StringType;
  }

  /**
   * @returns the \`time\` property value as a DateTimeType object if defined; else an empty DateTimeType object
   */
  public getTimeElement(): DateTimeType {
    return this.time ?? new DateTimeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`time\` property.
   *
   * @param element - the \`time\` value
   * @returns this
   */
  public setTimeElement(element: DateTimeType | undefined): this {
    if (isDefined<DateTimeType>(element)) {
      const optErrMsg = \`Invalid Annotation.time; Provided element is not an instance of DateTimeType.\`;
      assertFhirType<DateTimeType>(element, DateTimeType, optErrMsg);
      this.time = element;
    } else {
      this.time = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`time\` property exists and has a value; \`false\` otherwise
   */
  public hasTimeElement(): boolean {
    return isDefined<DateTimeType>(this.time) && !this.time.isEmpty();
  }

  /**
   * @returns the \`time\` property value as a fhirDateTime if defined; else undefined
   */
  public getTime(): fhirDateTime | undefined {
    return this.time?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`time\` property.
   *
   * @param value - the \`time\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setTime(value: fhirDateTime | undefined): this {
    if (isDefined<fhirDateTime>(value)) {
      const optErrMsg = \`Invalid Annotation.time (\${String(value)})\`;
      this.time = new DateTimeType(parseFhirPrimitiveData(value, fhirDateTimeSchema, optErrMsg));
    } else {
      this.time = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`time\` property exists and has a value; \`false\` otherwise
   */
  public hasTime(): boolean {
    return this.hasTimeElement();
  }

  /**
   * @returns the \`text\` property value as a MarkdownType object if defined; else null
   */
  public getTextElement(): MarkdownType | null {
    return this.text;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`text\` property.
   *
   * @param element - the \`text\` value
   * @returns this
   */
  public setTextElement(element: MarkdownType): this {
    assertIsDefined<MarkdownType>(element, \`Annotation.text is required\`);
    const optErrMsg = \`Invalid Annotation.text; Provided value is not an instance of MarkdownType.\`;
    assertFhirType<MarkdownType>(element, MarkdownType, optErrMsg);
    this.text = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`text\` property exists and has a value; \`false\` otherwise
   */
  public hasTextElement(): boolean {
    return isDefined<MarkdownType>(this.text) && !this.text.isEmpty();
  }

  /**
   * @returns the \`text\` property value as a fhirMarkdown if defined; else null
   */
  public getText(): fhirMarkdown | null {
    if (this.text?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.text.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`text\` property.
   *
   * @param value - the \`text\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setText(value: fhirMarkdown): this {
    assertIsDefined<fhirMarkdown>(value, \`Annotation.text is required\`);
    const optErrMsg = \`Invalid Annotation.text (\${String(value)})\`;
    this.text = new MarkdownType(parseFhirPrimitiveData(value, fhirMarkdownSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`text\` property exists and has a value; \`false\` otherwise
   */
  public hasText(): boolean {
    return this.hasTextElement();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Annotation';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.author,
      this.time,
      this.text,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Annotation {
    const dest = new Annotation();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Annotation): void {
    super.copyValues(dest);
    dest.author = this.author?.copy();
    dest.time = this.time?.copy();
    dest.text = this.text ? this.text.copy() : null;
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasAuthor()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getAuthor()!, 'author', jsonObj);
    }

    if (this.hasTimeElement()) {
      setFhirPrimitiveJson<fhirDateTime>(this.getTimeElement(), 'time', jsonObj);
    }

    if (this.hasTextElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirMarkdown>(this.getTextElement()!, 'text', jsonObj);
    } else {
      missingReqdProperties.push(\`Annotation.text\`);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "Annotation",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 27`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * Attachment Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/Attachment
 * StructureDefinition.name: Attachment
 * StructureDefinition.description: Attachment Type: For referring to data content defined in other formats.
 * StructureDefinition.fhirVersion: 5.0.0
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  Base64BinaryType,
  CodeType,
  DataType,
  DateTimeType,
  DecimalType,
  FhirDataTypeParser,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  Integer64Type,
  JSON,
  PositiveIntType,
  StringType,
  UrlType,
  assertFhirType,
  fhirBase64Binary,
  fhirBase64BinarySchema,
  fhirCode,
  fhirCodeSchema,
  fhirDateTime,
  fhirDateTimeSchema,
  fhirDecimal,
  fhirDecimalSchema,
  fhirInteger64,
  fhirInteger64Schema,
  fhirPositiveInt,
  fhirPositiveIntSchema,
  fhirString,
  fhirStringSchema,
  fhirUrl,
  fhirUrlSchema,
  getPrimitiveTypeJson,
  isDefined,
  isElementEmpty,
  isEmpty,
  parseBase64BinaryType,
  parseCodeType,
  parseDateTimeType,
  parseDecimalType,
  parseFhirPrimitiveData,
  parseInteger64Type,
  parsePositiveIntType,
  parseStringType,
  parseUrlType,
  setFhirPrimitiveJson,
} from '@paq-ts-fhir/fhir-core';
import {
  PARSABLE_DATATYPE_MAP,
} from '../index';

/**
 * Attachment Class
 *
 * @remarks
 * Attachment Type: For referring to data content defined in other formats.
 *
 * Many models need to include data defined in other specifications that is complex and opaque to the healthcare model. This includes documents, media recordings, structured data, etc.
 *
 * **FHIR Specification**
 * - **Short:** Content in a format defined elsewhere
 * - **Definition:** For referring to data content defined in other formats.
 * - **Comment:** When providing a summary view (for example with Observation.value[x]) Attachment should be represented with a brief display text such as "Signed Procedure Consent".
 * - **FHIR Version:** 5.0.0
 *
 * @category DataModel: ComplexType
 * @see [FHIR Attachment](http://hl7.org/fhir/StructureDefinition/Attachment)
 */
export class Attachment extends DataType implements IBase {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`Attachment\` JSON to instantiate the Attachment data model.
   *
   * @param sourceJson - JSON representing FHIR \`Attachment\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Attachment
   * @returns Attachment data model or undefined for \`Attachment\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Attachment | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Attachment';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Attachment();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'contentType';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      instance.setContentTypeElement(datatype);
    }

    fieldName = 'language';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      instance.setLanguageElement(datatype);
    }

    fieldName = 'data';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: Base64BinaryType | undefined = parseBase64BinaryType(dtJson, dtSiblingJson);
      instance.setDataElement(datatype);
    }

    fieldName = 'url';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UrlType | undefined = parseUrlType(dtJson, dtSiblingJson);
      instance.setUrlElement(datatype);
    }

    fieldName = 'size';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: Integer64Type | undefined = parseInteger64Type(dtJson, dtSiblingJson);
      instance.setSizeElement(datatype);
    }

    fieldName = 'hash';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: Base64BinaryType | undefined = parseBase64BinaryType(dtJson, dtSiblingJson);
      instance.setHashElement(datatype);
    }

    fieldName = 'title';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setTitleElement(datatype);
    }

    fieldName = 'creation';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DateTimeType | undefined = parseDateTimeType(dtJson, dtSiblingJson);
      instance.setCreationElement(datatype);
    }

    fieldName = 'height';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = parsePositiveIntType(dtJson, dtSiblingJson);
      instance.setHeightElement(datatype);
    }

    fieldName = 'width';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = parsePositiveIntType(dtJson, dtSiblingJson);
      instance.setWidthElement(datatype);
    }

    fieldName = 'frames';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = parsePositiveIntType(dtJson, dtSiblingJson);
      instance.setFramesElement(datatype);
    }

    fieldName = 'duration';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = parseDecimalType(dtJson, dtSiblingJson);
      instance.setDurationElement(datatype);
    }

    fieldName = 'pages';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = parsePositiveIntType(dtJson, dtSiblingJson);
      instance.setPagesElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Attachment.contentType Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Mime type of the content, with charset etc.
   * - **Definition:** Identifies the type of the data in the attachment and allows a method to be chosen to interpret or render the data. Includes mime type parameters such as charset where appropriate.
   * - **Requirements:** Processors of the data need to be able to know how to interpret the data.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private contentType?: CodeType | undefined;

  /**
   * Attachment.language Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Human language of the content (BCP-47)
   * - **Definition:** The human language of the content. The value can be any valid value according to BCP 47.
   * - **Requirements:** Users need to be able to choose between the languages in a set of attachments.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private language?: CodeType | undefined;

  /**
   * Attachment.data Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Data inline, base64ed
   * - **Definition:** The actual data of the attachment - a sequence of bytes, base64 encoded.
   * - **Comment:** The base64-encoded data SHALL be expressed in the same character set as the base resource XML or JSON.
   * - **Requirements:** The data needs to able to be transmitted inline.
   * - **FHIR Type:** \`base64Binary\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private data?: Base64BinaryType | undefined;

  /**
   * Attachment.url Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Uri where the data can be found
   * - **Definition:** A location where the data can be accessed.
   * - **Comment:** If both data and url are provided, the url SHALL point to the same content as the data contains. Urls may be relative references or may reference transient locations such as a wrapping envelope using cid: though this has ramifications for using signatures. Relative URLs are interpreted relative to the service url, like a resource reference, rather than relative to the resource itself. If a URL is provided, it SHALL resolve to actual data.
   * - **Requirements:** The data needs to be transmitted by reference.
   * - **FHIR Type:** \`url\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private url?: UrlType | undefined;

  /**
   * Attachment.size Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Number of bytes of content (if url provided)
   * - **Definition:** The number of bytes of data that make up this attachment (before base64 encoding, if that is done).
   * - **Comment:** The number of bytes is redundant if the data is provided as a base64binary, but is useful if the data is provided as a url reference.
   * - **Requirements:** Representing the size allows applications to determine whether they should fetch the content automatically in advance, or refuse to fetch it at all.
   * - **FHIR Type:** \`integer64\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private size?: Integer64Type | undefined;

  /**
   * Attachment.hash Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Hash of the data (sha-1, base64ed)
   * - **Definition:** The calculated hash of the data using SHA-1. Represented using base64.
   * - **Comment:** The hash is calculated on the data prior to base64 encoding, if the data is based64 encoded. The hash is not intended to support digital signatures. Where protection against malicious threats a digital signature should be considered, see [Provenance.signature](https://hl7.org/fhir/provenance-definitions.html#Provenance.signature) for mechanism to protect a resource with a digital signature.
   * - **Requirements:** Included so that applications can verify that the contents of a location have not changed due to technical failures (e.g., storage rot, transport glitch, incorrect version).
   * - **FHIR Type:** \`base64Binary\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private hash?: Base64BinaryType | undefined;

  /**
   * Attachment.title Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Label to display in place of the data
   * - **Definition:** A label or set of text to display in place of the data.
   * - **Comment:** May sometimes be derived from the source filename.
   * - **Requirements:** Applications need a label to display to a human user in place of the actual data if the data cannot be rendered or perceived by the viewer.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private title?: StringType | undefined;

  /**
   * Attachment.creation Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Date attachment was first created
   * - **Definition:** The date that the attachment was first created.
   * - **Requirements:** This is often tracked as an integrity issue for use of the attachment.
   * - **FHIR Type:** \`dateTime\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private creation?: DateTimeType | undefined;

  /**
   * Attachment.height Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Height of the image in pixels (photo/video)
   * - **Definition:** Height of the image in pixels (photo/video).
   * - **FHIR Type:** \`positiveInt\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private height?: PositiveIntType | undefined;

  /**
   * Attachment.width Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Width of the image in pixels (photo/video)
   * - **Definition:** Width of the image in pixels (photo/video).
   * - **FHIR Type:** \`positiveInt\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private width?: PositiveIntType | undefined;

  /**
   * Attachment.frames Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Number of frames if > 1 (photo)
   * - **Definition:** The number of frames in a photo. This is used with a multi-page fax, or an imaging acquisition context that takes multiple slices in a single image, or an animated gif. If there is more than one frame, this SHALL have a value in order to alert interface software that a multi-frame capable rendering widget is required.
   * - **Comment:** if the number of frames is not supplied, the value may be unknown. Applications should not assume that there is only one frame unless it is explicitly stated.
   * - **FHIR Type:** \`positiveInt\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private frames?: PositiveIntType | undefined;

  /**
   * Attachment.duration Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Length in seconds (audio / video)
   * - **Definition:** The duration of the recording in seconds - for audio and video.
   * - **Comment:** The duration might differ from occurrencePeriod if recording was paused.
   * - **FHIR Type:** \`decimal\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private duration?: DecimalType | undefined;

  /**
   * Attachment.pages Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Number of printed pages
   * - **Definition:** The number of pages when printed.
   * - **FHIR Type:** \`positiveInt\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private pages?: PositiveIntType | undefined;


  /**
   * @returns the \`contentType\` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getContentTypeElement(): CodeType {
    return this.contentType ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`contentType\` property.
   *
   * @param element - the \`contentType\` value
   * @returns this
   */
  public setContentTypeElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Attachment.contentType; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.contentType = element;
    } else {
      this.contentType = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`contentType\` property exists and has a value; \`false\` otherwise
   */
  public hasContentTypeElement(): boolean {
    return isDefined<CodeType>(this.contentType) && !this.contentType.isEmpty();
  }

  /**
   * @returns the \`contentType\` property value as a fhirCode if defined; else undefined
   */
  public getContentType(): fhirCode | undefined {
    return this.contentType?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`contentType\` property.
   *
   * @param value - the \`contentType\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setContentType(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Attachment.contentType (\${String(value)})\`;
      this.contentType = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.contentType = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`contentType\` property exists and has a value; \`false\` otherwise
   */
  public hasContentType(): boolean {
    return this.hasContentTypeElement();
  }

  /**
   * @returns the \`language\` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getLanguageElement(): CodeType {
    return this.language ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`language\` property.
   *
   * @param element - the \`language\` value
   * @returns this
   */
  public setLanguageElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Attachment.language; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.language = element;
    } else {
      this.language = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`language\` property exists and has a value; \`false\` otherwise
   */
  public hasLanguageElement(): boolean {
    return isDefined<CodeType>(this.language) && !this.language.isEmpty();
  }

  /**
   * @returns the \`language\` property value as a fhirCode if defined; else undefined
   */
  public getLanguage(): fhirCode | undefined {
    return this.language?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`language\` property.
   *
   * @param value - the \`language\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setLanguage(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Attachment.language (\${String(value)})\`;
      this.language = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.language = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`language\` property exists and has a value; \`false\` otherwise
   */
  public hasLanguage(): boolean {
    return this.hasLanguageElement();
  }

  /**
   * @returns the \`data\` property value as a Base64BinaryType object if defined; else an empty Base64BinaryType object
   */
  public getDataElement(): Base64BinaryType {
    return this.data ?? new Base64BinaryType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`data\` property.
   *
   * @param element - the \`data\` value
   * @returns this
   */
  public setDataElement(element: Base64BinaryType | undefined): this {
    if (isDefined<Base64BinaryType>(element)) {
      const optErrMsg = \`Invalid Attachment.data; Provided element is not an instance of Base64BinaryType.\`;
      assertFhirType<Base64BinaryType>(element, Base64BinaryType, optErrMsg);
      this.data = element;
    } else {
      this.data = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`data\` property exists and has a value; \`false\` otherwise
   */
  public hasDataElement(): boolean {
    return isDefined<Base64BinaryType>(this.data) && !this.data.isEmpty();
  }

  /**
   * @returns the \`data\` property value as a fhirBase64Binary if defined; else undefined
   */
  public getData(): fhirBase64Binary | undefined {
    return this.data?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`data\` property.
   *
   * @param value - the \`data\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setData(value: fhirBase64Binary | undefined): this {
    if (isDefined<fhirBase64Binary>(value)) {
      const optErrMsg = \`Invalid Attachment.data (\${String(value)})\`;
      this.data = new Base64BinaryType(parseFhirPrimitiveData(value, fhirBase64BinarySchema, optErrMsg));
    } else {
      this.data = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`data\` property exists and has a value; \`false\` otherwise
   */
  public hasData(): boolean {
    return this.hasDataElement();
  }

  /**
   * @returns the \`url\` property value as a UrlType object if defined; else an empty UrlType object
   */
  public getUrlElement(): UrlType {
    return this.url ?? new UrlType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`url\` property.
   *
   * @param element - the \`url\` value
   * @returns this
   */
  public setUrlElement(element: UrlType | undefined): this {
    if (isDefined<UrlType>(element)) {
      const optErrMsg = \`Invalid Attachment.url; Provided element is not an instance of UrlType.\`;
      assertFhirType<UrlType>(element, UrlType, optErrMsg);
      this.url = element;
    } else {
      this.url = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`url\` property exists and has a value; \`false\` otherwise
   */
  public hasUrlElement(): boolean {
    return isDefined<UrlType>(this.url) && !this.url.isEmpty();
  }

  /**
   * @returns the \`url\` property value as a fhirUrl if defined; else undefined
   */
  public getUrl(): fhirUrl | undefined {
    return this.url?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`url\` property.
   *
   * @param value - the \`url\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setUrl(value: fhirUrl | undefined): this {
    if (isDefined<fhirUrl>(value)) {
      const optErrMsg = \`Invalid Attachment.url (\${String(value)})\`;
      this.url = new UrlType(parseFhirPrimitiveData(value, fhirUrlSchema, optErrMsg));
    } else {
      this.url = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`url\` property exists and has a value; \`false\` otherwise
   */
  public hasUrl(): boolean {
    return this.hasUrlElement();
  }

  /**
   * @returns the \`size\` property value as a Integer64Type object if defined; else an empty Integer64Type object
   */
  public getSizeElement(): Integer64Type {
    return this.size ?? new Integer64Type();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`size\` property.
   *
   * @param element - the \`size\` value
   * @returns this
   */
  public setSizeElement(element: Integer64Type | undefined): this {
    if (isDefined<Integer64Type>(element)) {
      const optErrMsg = \`Invalid Attachment.size; Provided element is not an instance of Integer64Type.\`;
      assertFhirType<Integer64Type>(element, Integer64Type, optErrMsg);
      this.size = element;
    } else {
      this.size = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`size\` property exists and has a value; \`false\` otherwise
   */
  public hasSizeElement(): boolean {
    return isDefined<Integer64Type>(this.size) && !this.size.isEmpty();
  }

  /**
   * @returns the \`size\` property value as a fhirInteger64 if defined; else undefined
   */
  public getSize(): fhirInteger64 | undefined {
    return this.size?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`size\` property.
   *
   * @param value - the \`size\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setSize(value: fhirInteger64 | undefined): this {
    if (isDefined<fhirInteger64>(value)) {
      const optErrMsg = \`Invalid Attachment.size (\${String(value)})\`;
      this.size = new Integer64Type(parseFhirPrimitiveData(value, fhirInteger64Schema, optErrMsg));
    } else {
      this.size = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`size\` property exists and has a value; \`false\` otherwise
   */
  public hasSize(): boolean {
    return this.hasSizeElement();
  }

  /**
   * @returns the \`hash\` property value as a Base64BinaryType object if defined; else an empty Base64BinaryType object
   */
  public getHashElement(): Base64BinaryType {
    return this.hash ?? new Base64BinaryType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`hash\` property.
   *
   * @param element - the \`hash\` value
   * @returns this
   */
  public setHashElement(element: Base64BinaryType | undefined): this {
    if (isDefined<Base64BinaryType>(element)) {
      const optErrMsg = \`Invalid Attachment.hash; Provided element is not an instance of Base64BinaryType.\`;
      assertFhirType<Base64BinaryType>(element, Base64BinaryType, optErrMsg);
      this.hash = element;
    } else {
      this.hash = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`hash\` property exists and has a value; \`false\` otherwise
   */
  public hasHashElement(): boolean {
    return isDefined<Base64BinaryType>(this.hash) && !this.hash.isEmpty();
  }

  /**
   * @returns the \`hash\` property value as a fhirBase64Binary if defined; else undefined
   */
  public getHash(): fhirBase64Binary | undefined {
    return this.hash?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`hash\` property.
   *
   * @param value - the \`hash\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setHash(value: fhirBase64Binary | undefined): this {
    if (isDefined<fhirBase64Binary>(value)) {
      const optErrMsg = \`Invalid Attachment.hash (\${String(value)})\`;
      this.hash = new Base64BinaryType(parseFhirPrimitiveData(value, fhirBase64BinarySchema, optErrMsg));
    } else {
      this.hash = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`hash\` property exists and has a value; \`false\` otherwise
   */
  public hasHash(): boolean {
    return this.hasHashElement();
  }

  /**
   * @returns the \`title\` property value as a StringType object if defined; else an empty StringType object
   */
  public getTitleElement(): StringType {
    return this.title ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`title\` property.
   *
   * @param element - the \`title\` value
   * @returns this
   */
  public setTitleElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Attachment.title; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.title = element;
    } else {
      this.title = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`title\` property exists and has a value; \`false\` otherwise
   */
  public hasTitleElement(): boolean {
    return isDefined<StringType>(this.title) && !this.title.isEmpty();
  }

  /**
   * @returns the \`title\` property value as a fhirString if defined; else undefined
   */
  public getTitle(): fhirString | undefined {
    return this.title?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`title\` property.
   *
   * @param value - the \`title\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setTitle(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Attachment.title (\${String(value)})\`;
      this.title = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.title = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`title\` property exists and has a value; \`false\` otherwise
   */
  public hasTitle(): boolean {
    return this.hasTitleElement();
  }

  /**
   * @returns the \`creation\` property value as a DateTimeType object if defined; else an empty DateTimeType object
   */
  public getCreationElement(): DateTimeType {
    return this.creation ?? new DateTimeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`creation\` property.
   *
   * @param element - the \`creation\` value
   * @returns this
   */
  public setCreationElement(element: DateTimeType | undefined): this {
    if (isDefined<DateTimeType>(element)) {
      const optErrMsg = \`Invalid Attachment.creation; Provided element is not an instance of DateTimeType.\`;
      assertFhirType<DateTimeType>(element, DateTimeType, optErrMsg);
      this.creation = element;
    } else {
      this.creation = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`creation\` property exists and has a value; \`false\` otherwise
   */
  public hasCreationElement(): boolean {
    return isDefined<DateTimeType>(this.creation) && !this.creation.isEmpty();
  }

  /**
   * @returns the \`creation\` property value as a fhirDateTime if defined; else undefined
   */
  public getCreation(): fhirDateTime | undefined {
    return this.creation?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`creation\` property.
   *
   * @param value - the \`creation\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setCreation(value: fhirDateTime | undefined): this {
    if (isDefined<fhirDateTime>(value)) {
      const optErrMsg = \`Invalid Attachment.creation (\${String(value)})\`;
      this.creation = new DateTimeType(parseFhirPrimitiveData(value, fhirDateTimeSchema, optErrMsg));
    } else {
      this.creation = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`creation\` property exists and has a value; \`false\` otherwise
   */
  public hasCreation(): boolean {
    return this.hasCreationElement();
  }

  /**
   * @returns the \`height\` property value as a PositiveIntType object if defined; else an empty PositiveIntType object
   */
  public getHeightElement(): PositiveIntType {
    return this.height ?? new PositiveIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`height\` property.
   *
   * @param element - the \`height\` value
   * @returns this
   */
  public setHeightElement(element: PositiveIntType | undefined): this {
    if (isDefined<PositiveIntType>(element)) {
      const optErrMsg = \`Invalid Attachment.height; Provided element is not an instance of PositiveIntType.\`;
      assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
      this.height = element;
    } else {
      this.height = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`height\` property exists and has a value; \`false\` otherwise
   */
  public hasHeightElement(): boolean {
    return isDefined<PositiveIntType>(this.height) && !this.height.isEmpty();
  }

  /**
   * @returns the \`height\` property value as a fhirPositiveInt if defined; else undefined
   */
  public getHeight(): fhirPositiveInt | undefined {
    return this.height?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`height\` property.
   *
   * @param value - the \`height\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setHeight(value: fhirPositiveInt | undefined): this {
    if (isDefined<fhirPositiveInt>(value)) {
      const optErrMsg = \`Invalid Attachment.height (\${String(value)})\`;
      this.height = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    } else {
      this.height = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`height\` property exists and has a value; \`false\` otherwise
   */
  public hasHeight(): boolean {
    return this.hasHeightElement();
  }

  /**
   * @returns the \`width\` property value as a PositiveIntType object if defined; else an empty PositiveIntType object
   */
  public getWidthElement(): PositiveIntType {
    return this.width ?? new PositiveIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`width\` property.
   *
   * @param element - the \`width\` value
   * @returns this
   */
  public setWidthElement(element: PositiveIntType | undefined): this {
    if (isDefined<PositiveIntType>(element)) {
      const optErrMsg = \`Invalid Attachment.width; Provided element is not an instance of PositiveIntType.\`;
      assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
      this.width = element;
    } else {
      this.width = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`width\` property exists and has a value; \`false\` otherwise
   */
  public hasWidthElement(): boolean {
    return isDefined<PositiveIntType>(this.width) && !this.width.isEmpty();
  }

  /**
   * @returns the \`width\` property value as a fhirPositiveInt if defined; else undefined
   */
  public getWidth(): fhirPositiveInt | undefined {
    return this.width?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`width\` property.
   *
   * @param value - the \`width\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setWidth(value: fhirPositiveInt | undefined): this {
    if (isDefined<fhirPositiveInt>(value)) {
      const optErrMsg = \`Invalid Attachment.width (\${String(value)})\`;
      this.width = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    } else {
      this.width = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`width\` property exists and has a value; \`false\` otherwise
   */
  public hasWidth(): boolean {
    return this.hasWidthElement();
  }

  /**
   * @returns the \`frames\` property value as a PositiveIntType object if defined; else an empty PositiveIntType object
   */
  public getFramesElement(): PositiveIntType {
    return this.frames ?? new PositiveIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`frames\` property.
   *
   * @param element - the \`frames\` value
   * @returns this
   */
  public setFramesElement(element: PositiveIntType | undefined): this {
    if (isDefined<PositiveIntType>(element)) {
      const optErrMsg = \`Invalid Attachment.frames; Provided element is not an instance of PositiveIntType.\`;
      assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
      this.frames = element;
    } else {
      this.frames = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`frames\` property exists and has a value; \`false\` otherwise
   */
  public hasFramesElement(): boolean {
    return isDefined<PositiveIntType>(this.frames) && !this.frames.isEmpty();
  }

  /**
   * @returns the \`frames\` property value as a fhirPositiveInt if defined; else undefined
   */
  public getFrames(): fhirPositiveInt | undefined {
    return this.frames?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`frames\` property.
   *
   * @param value - the \`frames\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setFrames(value: fhirPositiveInt | undefined): this {
    if (isDefined<fhirPositiveInt>(value)) {
      const optErrMsg = \`Invalid Attachment.frames (\${String(value)})\`;
      this.frames = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    } else {
      this.frames = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`frames\` property exists and has a value; \`false\` otherwise
   */
  public hasFrames(): boolean {
    return this.hasFramesElement();
  }

  /**
   * @returns the \`duration\` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getDurationElement(): DecimalType {
    return this.duration ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`duration\` property.
   *
   * @param element - the \`duration\` value
   * @returns this
   */
  public setDurationElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = \`Invalid Attachment.duration; Provided element is not an instance of DecimalType.\`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.duration = element;
    } else {
      this.duration = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`duration\` property exists and has a value; \`false\` otherwise
   */
  public hasDurationElement(): boolean {
    return isDefined<DecimalType>(this.duration) && !this.duration.isEmpty();
  }

  /**
   * @returns the \`duration\` property value as a fhirDecimal if defined; else undefined
   */
  public getDuration(): fhirDecimal | undefined {
    return this.duration?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`duration\` property.
   *
   * @param value - the \`duration\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setDuration(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = \`Invalid Attachment.duration (\${String(value)})\`;
      this.duration = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.duration = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`duration\` property exists and has a value; \`false\` otherwise
   */
  public hasDuration(): boolean {
    return this.hasDurationElement();
  }

  /**
   * @returns the \`pages\` property value as a PositiveIntType object if defined; else an empty PositiveIntType object
   */
  public getPagesElement(): PositiveIntType {
    return this.pages ?? new PositiveIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`pages\` property.
   *
   * @param element - the \`pages\` value
   * @returns this
   */
  public setPagesElement(element: PositiveIntType | undefined): this {
    if (isDefined<PositiveIntType>(element)) {
      const optErrMsg = \`Invalid Attachment.pages; Provided element is not an instance of PositiveIntType.\`;
      assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
      this.pages = element;
    } else {
      this.pages = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`pages\` property exists and has a value; \`false\` otherwise
   */
  public hasPagesElement(): boolean {
    return isDefined<PositiveIntType>(this.pages) && !this.pages.isEmpty();
  }

  /**
   * @returns the \`pages\` property value as a fhirPositiveInt if defined; else undefined
   */
  public getPages(): fhirPositiveInt | undefined {
    return this.pages?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`pages\` property.
   *
   * @param value - the \`pages\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setPages(value: fhirPositiveInt | undefined): this {
    if (isDefined<fhirPositiveInt>(value)) {
      const optErrMsg = \`Invalid Attachment.pages (\${String(value)})\`;
      this.pages = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    } else {
      this.pages = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`pages\` property exists and has a value; \`false\` otherwise
   */
  public hasPages(): boolean {
    return this.hasPagesElement();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Attachment';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.contentType,
      this.language,
      this.data,
      this.url,
      this.size,
      this.hash,
      this.title,
      this.creation,
      this.height,
      this.width,
      this.frames,
      this.duration,
      this.pages,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Attachment {
    const dest = new Attachment();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Attachment): void {
    super.copyValues(dest);
    dest.contentType = this.contentType?.copy();
    dest.language = this.language?.copy();
    dest.data = this.data?.copy();
    dest.url = this.url?.copy();
    dest.size = this.size?.copy();
    dest.hash = this.hash?.copy();
    dest.title = this.title?.copy();
    dest.creation = this.creation?.copy();
    dest.height = this.height?.copy();
    dest.width = this.width?.copy();
    dest.frames = this.frames?.copy();
    dest.duration = this.duration?.copy();
    dest.pages = this.pages?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasContentTypeElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getContentTypeElement(), 'contentType', jsonObj);
    }

    if (this.hasLanguageElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getLanguageElement(), 'language', jsonObj);
    }

    if (this.hasDataElement()) {
      setFhirPrimitiveJson<fhirBase64Binary>(this.getDataElement(), 'data', jsonObj);
    }

    if (this.hasUrlElement()) {
      setFhirPrimitiveJson<fhirUrl>(this.getUrlElement(), 'url', jsonObj);
    }

    if (this.hasSizeElement()) {
      setFhirPrimitiveJson<fhirInteger64>(this.getSizeElement(), 'size', jsonObj);
    }

    if (this.hasHashElement()) {
      setFhirPrimitiveJson<fhirBase64Binary>(this.getHashElement(), 'hash', jsonObj);
    }

    if (this.hasTitleElement()) {
      setFhirPrimitiveJson<fhirString>(this.getTitleElement(), 'title', jsonObj);
    }

    if (this.hasCreationElement()) {
      setFhirPrimitiveJson<fhirDateTime>(this.getCreationElement(), 'creation', jsonObj);
    }

    if (this.hasHeightElement()) {
      setFhirPrimitiveJson<fhirPositiveInt>(this.getHeightElement(), 'height', jsonObj);
    }

    if (this.hasWidthElement()) {
      setFhirPrimitiveJson<fhirPositiveInt>(this.getWidthElement(), 'width', jsonObj);
    }

    if (this.hasFramesElement()) {
      setFhirPrimitiveJson<fhirPositiveInt>(this.getFramesElement(), 'frames', jsonObj);
    }

    if (this.hasDurationElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getDurationElement(), 'duration', jsonObj);
    }

    if (this.hasPagesElement()) {
      setFhirPrimitiveJson<fhirPositiveInt>(this.getPagesElement(), 'pages', jsonObj);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "Attachment",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 28`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * Availability Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/Availability
 * StructureDefinition.name: Availability
 * StructureDefinition.description: Availability Type: Availability data for an {item}.
 * StructureDefinition.fhirVersion: 5.0.0
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  BooleanType,
  CodeType,
  DataType,
  Element,
  EnumCodeType,
  FhirDataTypeParser,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  PrimitiveTypeJson,
  StringType,
  TimeType,
  assertEnumCodeType,
  assertEnumCodeTypeList,
  assertFhirType,
  assertFhirTypeList,
  copyListValues,
  fhirBoolean,
  fhirBooleanSchema,
  fhirCode,
  fhirCodeSchema,
  fhirString,
  fhirStringSchema,
  fhirTime,
  fhirTimeSchema,
  getPrimitiveTypeJson,
  getPrimitiveTypeListJson,
  isDefined,
  isDefinedList,
  isElementEmpty,
  isEmpty,
  parseBooleanType,
  parseCodeType,
  parseFhirPrimitiveData,
  parseStringType,
  parseTimeType,
  setFhirComplexJson,
  setFhirComplexListJson,
  setFhirPrimitiveJson,
  setFhirPrimitiveListJson,
} from '@paq-ts-fhir/fhir-core';
import {
  DaysOfWeekEnum,
  PARSABLE_DATATYPE_MAP,
  Period,
} from '../index';

/**
 * Availability Class
 *
 * @remarks
 * Availability Type: Availability data for an {item}.
 *
 * **FHIR Specification**
 * - **Short:** Availability data for an {item}
 * - **Definition:** Availability data for an {item}.
 * - **FHIR Version:** 5.0.0
 *
 * @category DataModel: ComplexType
 * @see [FHIR Availability](http://hl7.org/fhir/StructureDefinition/Availability)
 */
export class Availability extends DataType implements IBase {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`Availability\` JSON to instantiate the Availability data model.
   *
   * @param sourceJson - JSON representing FHIR \`Availability\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Availability
   * @returns Availability data model or undefined for \`Availability\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Availability | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Availability';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Availability();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';

    fieldName = 'availableTime';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: AvailabilityAvailableTimeComponent | undefined = fhirDataTypeParser.parser<AvailabilityAvailableTimeComponent>(AvailabilityAvailableTimeComponent, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addAvailableTime(datatype);
        }
      });
    }

    fieldName = 'notAvailableTime';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: AvailabilityNotAvailableTimeComponent | undefined = fhirDataTypeParser.parser<AvailabilityNotAvailableTimeComponent>(AvailabilityNotAvailableTimeComponent, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addNotAvailableTime(datatype);
        }
      });
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Availability.availableTime Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Times the {item} is available
   * - **Definition:** Times the {item} is available.
   * - **Requirements:** A collection of times that the {item} is available.
   * - **FHIR Type:** \`Element\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private availableTime?: AvailabilityAvailableTimeComponent[] | undefined;

  /**
   * Availability.notAvailableTime Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Not available during this time due to provided reason
   * - **Definition:** Not available during this time due to provided reason.
   * - **Requirements:** The {item} is not available during this period of time due to the provided reason.
   * - **FHIR Type:** \`Element\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private notAvailableTime?: AvailabilityNotAvailableTimeComponent[] | undefined;


  /**
   * @returns the \`availableTime\` property value as a AvailabilityAvailableTimeComponent array
   */
  public getAvailableTime(): AvailabilityAvailableTimeComponent[] {
    return this.availableTime ?? ([] as AvailabilityAvailableTimeComponent[]);
  }

  /**
   * Assigns the provided AvailabilityAvailableTimeComponent array value to the \`availableTime\` property.
   *
   * @param value - the \`availableTime\` array value
   * @returns this
   */
  public setAvailableTime(value: AvailabilityAvailableTimeComponent[] | undefined): this {
    if (isDefinedList<AvailabilityAvailableTimeComponent>(value)) {
      const optErrMsg = \`Invalid Availability.availableTime; Provided value array has an element that is not an instance of AvailabilityAvailableTimeComponent.\`;
      assertFhirTypeList<AvailabilityAvailableTimeComponent>(value, AvailabilityAvailableTimeComponent, optErrMsg);
      this.availableTime = value;
    } else {
      this.availableTime = undefined;
    }
    return this;
  }

  /**
   * Add the provided AvailabilityAvailableTimeComponent value to the \`availableTime\` array property.
   *
   * @param value - the \`availableTime\` value
   * @returns this
   */
  public addAvailableTime(value: AvailabilityAvailableTimeComponent | undefined): this {
    if (isDefined<AvailabilityAvailableTimeComponent>(value)) {
      const optErrMsg = \`Invalid Availability.availableTime; Provided element is not an instance of AvailabilityAvailableTimeComponent.\`;
      assertFhirType<AvailabilityAvailableTimeComponent>(value, AvailabilityAvailableTimeComponent, optErrMsg);
      this.initAvailableTime();
      this.availableTime?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`availableTime\` property exists and has a value; \`false\` otherwise
   */
  public hasAvailableTime(): boolean {
    return isDefinedList<AvailabilityAvailableTimeComponent>(this.availableTime) && this.availableTime.some((item: AvailabilityAvailableTimeComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`availableTime\` property
   */
  private initAvailableTime(): void {
    if(!this.hasAvailableTime()) {
      this.availableTime = [] as AvailabilityAvailableTimeComponent[];
    }
  }

  /**
   * @returns the \`notAvailableTime\` property value as a AvailabilityNotAvailableTimeComponent array
   */
  public getNotAvailableTime(): AvailabilityNotAvailableTimeComponent[] {
    return this.notAvailableTime ?? ([] as AvailabilityNotAvailableTimeComponent[]);
  }

  /**
   * Assigns the provided AvailabilityNotAvailableTimeComponent array value to the \`notAvailableTime\` property.
   *
   * @param value - the \`notAvailableTime\` array value
   * @returns this
   */
  public setNotAvailableTime(value: AvailabilityNotAvailableTimeComponent[] | undefined): this {
    if (isDefinedList<AvailabilityNotAvailableTimeComponent>(value)) {
      const optErrMsg = \`Invalid Availability.notAvailableTime; Provided value array has an element that is not an instance of AvailabilityNotAvailableTimeComponent.\`;
      assertFhirTypeList<AvailabilityNotAvailableTimeComponent>(value, AvailabilityNotAvailableTimeComponent, optErrMsg);
      this.notAvailableTime = value;
    } else {
      this.notAvailableTime = undefined;
    }
    return this;
  }

  /**
   * Add the provided AvailabilityNotAvailableTimeComponent value to the \`notAvailableTime\` array property.
   *
   * @param value - the \`notAvailableTime\` value
   * @returns this
   */
  public addNotAvailableTime(value: AvailabilityNotAvailableTimeComponent | undefined): this {
    if (isDefined<AvailabilityNotAvailableTimeComponent>(value)) {
      const optErrMsg = \`Invalid Availability.notAvailableTime; Provided element is not an instance of AvailabilityNotAvailableTimeComponent.\`;
      assertFhirType<AvailabilityNotAvailableTimeComponent>(value, AvailabilityNotAvailableTimeComponent, optErrMsg);
      this.initNotAvailableTime();
      this.notAvailableTime?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`notAvailableTime\` property exists and has a value; \`false\` otherwise
   */
  public hasNotAvailableTime(): boolean {
    return isDefinedList<AvailabilityNotAvailableTimeComponent>(this.notAvailableTime) && this.notAvailableTime.some((item: AvailabilityNotAvailableTimeComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`notAvailableTime\` property
   */
  private initNotAvailableTime(): void {
    if(!this.hasNotAvailableTime()) {
      this.notAvailableTime = [] as AvailabilityNotAvailableTimeComponent[];
    }
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Availability';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.availableTime,
      this.notAvailableTime,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Availability {
    const dest = new Availability();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Availability): void {
    super.copyValues(dest);
    const availableTimeList = copyListValues<AvailabilityAvailableTimeComponent>(this.availableTime);
    dest.availableTime = availableTimeList.length === 0 ? undefined : availableTimeList;
    const notAvailableTimeList = copyListValues<AvailabilityNotAvailableTimeComponent>(this.notAvailableTime);
    dest.notAvailableTime = notAvailableTimeList.length === 0 ? undefined : notAvailableTimeList;
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasAvailableTime()) {
      setFhirComplexListJson(this.getAvailableTime(), 'availableTime', jsonObj);
    }

    if (this.hasNotAvailableTime()) {
      setFhirComplexListJson(this.getNotAvailableTime(), 'notAvailableTime', jsonObj);
    }

    return jsonObj;
  }
}


/**
 * AvailabilityAvailableTimeComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Times the {item} is available
 * - **Definition:** Times the {item} is available.
 * - **Requirements:** A collection of times that the {item} is available.
 *
 * @category DataModel: ComplexType
 * @see [FHIR Availability](http://hl7.org/fhir/StructureDefinition/Availability)
 */
export class AvailabilityAvailableTimeComponent extends Element {
  constructor() {
    super();

    this.daysOfWeekEnum = new DaysOfWeekEnum();
  }

  /**
   * Parse the provided \`AvailabilityAvailableTimeComponent\` JSON to instantiate the AvailabilityAvailableTimeComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`AvailabilityAvailableTimeComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to AvailabilityAvailableTimeComponent
   * @returns AvailabilityAvailableTimeComponent data model or undefined for \`AvailabilityAvailableTimeComponent\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): AvailabilityAvailableTimeComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'AvailabilityAvailableTimeComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new AvailabilityAvailableTimeComponent();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'daysOfWeek';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: CodeType | undefined = parseCodeType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addDaysOfWeekElement(datatype);
        }
      });
    }

    fieldName = 'allDay';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'boolean';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: BooleanType | undefined = parseBooleanType(dtJson, dtSiblingJson);
      instance.setAllDayElement(datatype);
    }

    fieldName = 'availableStartTime';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: TimeType | undefined = parseTimeType(dtJson, dtSiblingJson);
      instance.setAvailableStartTimeElement(datatype);
    }

    fieldName = 'availableEndTime';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: TimeType | undefined = parseTimeType(dtJson, dtSiblingJson);
      instance.setAvailableEndTimeElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: DaysOfWeek
   *
   * @see {@link DaysOfWeekEnum }
   */
  private readonly daysOfWeekEnum: DaysOfWeekEnum;

  /**
   * Availability.availableTime.daysOfWeek Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** mon | tue | wed | thu | fri | sat | sun
   * - **Definition:** mon | tue | wed | thu | fri | sat | sun.
   * - **Requirements:** Indicates which days of the week are available between the start and end Times.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private daysOfWeek?: EnumCodeType[] | undefined;

  /**
   * Availability.availableTime.allDay Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Always available? i.e. 24 hour service
   * - **Definition:** Always available? i.e. 24 hour service.
   * - **Requirements:** Is this always available? (hence times are irrelevant) i.e. 24 hour service.
   * - **FHIR Type:** \`boolean\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private allDay?: BooleanType | undefined;

  /**
   * Availability.availableTime.availableStartTime Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Opening time of day (ignored if allDay = true)
   * - **Definition:** Opening time of day (ignored if allDay = true).
   * - **Comment:** The timezone is expected to be specified or implied by the context this datatype is used.
   * - **Requirements:** The opening time of day. Note: If the AllDay flag is set, then this time is ignored.
   * - **FHIR Type:** \`time\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private availableStartTime?: TimeType | undefined;

  /**
   * Availability.availableTime.availableEndTime Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Closing time of day (ignored if allDay = true)
   * - **Definition:** Closing time of day (ignored if allDay = true).
   * - **Comment:** The timezone is expected to be specified or implied by the context this datatype is used.
   * - **Requirements:** The closing time of day. Note: If the AllDay flag is set, then this time is ignored.
   * - **FHIR Type:** \`time\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private availableEndTime?: TimeType | undefined;


  /**
   * @returns the \`daysOfWeek\` property value as a EnumCodeType array
   */
  public getDaysOfWeekEnumType(): EnumCodeType[] {
    return this.daysOfWeek ?? ([] as EnumCodeType[]);
  }

  /**
   * Assigns the provided EnumCodeType array value to the \`daysOfWeek\` property.
   *
   * @param enumType - the \`daysOfWeek\` array value
   * @returns this
   */
  public setDaysOfWeekEnumType(enumType: EnumCodeType[] | undefined): this {
    if (isDefinedList<EnumCodeType>(enumType)) {
      const errMsgPrefix = \`Invalid Availability.availableTime.daysOfWeek\`;
      assertEnumCodeTypeList<DaysOfWeekEnum>(enumType, DaysOfWeekEnum, errMsgPrefix);
      this.daysOfWeek = enumType;
    } else {
      this.daysOfWeek = undefined;
    }
    return this;
  }

  /**
   * Add the provided EnumCodeType value to the \`daysOfWeek\` array property.
   *
   * @param enumType - the \`daysOfWeek\` value
   * @returns this
   */
  public addDaysOfWeekEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = \`Invalid Availability.availableTime.daysOfWeek)\`;
      assertEnumCodeType<DaysOfWeekEnum>(enumType, DaysOfWeekEnum, errMsgPrefix);
      this.initDaysOfWeek();
      this.daysOfWeek?.push(enumType);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`daysOfWeek\` property exists and has a value; \`false\` otherwise
   */
  public hasDaysOfWeekEnumType(): boolean {
    return isDefinedList<EnumCodeType>(this.daysOfWeek) && this.daysOfWeek.some((item: EnumCodeType) => !item.isEmpty()) && this.daysOfWeek.every((item: EnumCodeType) => item.fhirCodeEnumeration.length > 0);
  }

  /**
   * @returns the \`daysOfWeek\` property value as a CodeType array
   */
  public getDaysOfWeekElement(): CodeType[] {
    if (this.daysOfWeek === undefined) {
      return [] as CodeType[];
    }
    return this.daysOfWeek as CodeType[];
  }

  /**
   * Assigns the provided PrimitiveType array value to the \`daysOfWeek\` property.
   *
   * @param element - the \`daysOfWeek\` array value
   * @returns this
   */
  public setDaysOfWeekElement(element: CodeType[] | undefined): this {
    if (isDefinedList<CodeType>(element)) {
      const optErrMsg = \`Invalid Availability.availableTime.daysOfWeek; Provided element array has an element that is not an instance of CodeType.\`;
      assertFhirTypeList<CodeType>(element, CodeType, optErrMsg);
      const enumCodeTypes = [] as EnumCodeType[];
      element.forEach((type: CodeType) => {
        enumCodeTypes.push(new EnumCodeType(type, this.daysOfWeekEnum));
      });
      this.daysOfWeek = enumCodeTypes;
    } else {
      this.daysOfWeek = undefined;
    }
    return this;
  }

  /**
   * Add the provided PrimitiveType value to the \`daysOfWeek\` array property.
   *
   * @param element - the \`daysOfWeek\` value
   * @returns this
   */
  public addDaysOfWeekElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Availability.availableTime.daysOfWeek; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.initDaysOfWeek();
      this.daysOfWeek?.push(new EnumCodeType(element, this.daysOfWeekEnum));
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`daysOfWeek\` property exists and has a value; \`false\` otherwise
   */
  public hasDaysOfWeekElement(): boolean {
    return this.hasDaysOfWeekEnumType();
  }

  /**
   * @returns the \`daysOfWeek\` property value as a fhirCode array
   */
  public getDaysOfWeek(): fhirCode[] {
    if (this.daysOfWeek === undefined) {
      return [] as fhirCode[];
    }
    const values = [] as fhirCode[];
    for (const item of this.daysOfWeek) {
      values.push(item.fhirCode.code);
    }
    return values;
  }

  /**
   * Assigns the provided primitive value array to the \`daysOfWeek\` property.
   *
   * @param value - the \`daysOfWeek\` value array
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setDaysOfWeek(value: fhirCode[] | undefined): this {
    if (isDefinedList<fhirCode>(value)) {
      const enumCodeTypes = [] as EnumCodeType[];
      const optErrMsg = \`Invalid Availability.availableTime.daysOfWeek; Provided value is not an instance of fhirCode.\`;
      value.forEach((val: fhirCode) => {
        enumCodeTypes.push(new EnumCodeType(parseFhirPrimitiveData(val, fhirCodeSchema, optErrMsg), this.daysOfWeekEnum));
      });
      this.daysOfWeek = enumCodeTypes;
    } else {
      this.daysOfWeek = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`daysOfWeek\` array property.
   *
   * @param value - the \`daysOfWeek\` value
   * @returns this
   */
  public addDaysOfWeek(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      this.initDaysOfWeek();
      const optErrMsg = \`Invalid Availability.availableTime.daysOfWeek; Provided value is not an instance of fhirCode.\`;
      this.daysOfWeek?.push(new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.daysOfWeekEnum));
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`daysOfWeek\` property exists and has a value; \`false\` otherwise
   */
  public hasDaysOfWeek(): boolean {
    return this.hasDaysOfWeekEnumType();
  }

  /**
   * Initialize the daysOfWeek property
   */
  private initDaysOfWeek(): void {
    if(!this.hasDaysOfWeekEnumType()) {
      this.daysOfWeek = [] as EnumCodeType[];
    }
  }

  /**
   * @returns the \`allDay\` property value as a BooleanType object if defined; else an empty BooleanType object
   */
  public getAllDayElement(): BooleanType {
    return this.allDay ?? new BooleanType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`allDay\` property.
   *
   * @param element - the \`allDay\` value
   * @returns this
   */
  public setAllDayElement(element: BooleanType | undefined): this {
    if (isDefined<BooleanType>(element)) {
      const optErrMsg = \`Invalid Availability.availableTime.allDay; Provided element is not an instance of BooleanType.\`;
      assertFhirType<BooleanType>(element, BooleanType, optErrMsg);
      this.allDay = element;
    } else {
      this.allDay = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`allDay\` property exists and has a value; \`false\` otherwise
   */
  public hasAllDayElement(): boolean {
    return isDefined<BooleanType>(this.allDay) && !this.allDay.isEmpty();
  }

  /**
   * @returns the \`allDay\` property value as a fhirBoolean if defined; else undefined
   */
  public getAllDay(): fhirBoolean | undefined {
    return this.allDay?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`allDay\` property.
   *
   * @param value - the \`allDay\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setAllDay(value: fhirBoolean | undefined): this {
    if (isDefined<fhirBoolean>(value)) {
      const optErrMsg = \`Invalid Availability.availableTime.allDay (\${String(value)})\`;
      this.allDay = new BooleanType(parseFhirPrimitiveData(value, fhirBooleanSchema, optErrMsg));
    } else {
      this.allDay = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`allDay\` property exists and has a value; \`false\` otherwise
   */
  public hasAllDay(): boolean {
    return this.hasAllDayElement();
  }

  /**
   * @returns the \`availableStartTime\` property value as a TimeType object if defined; else an empty TimeType object
   */
  public getAvailableStartTimeElement(): TimeType {
    return this.availableStartTime ?? new TimeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`availableStartTime\` property.
   *
   * @param element - the \`availableStartTime\` value
   * @returns this
   */
  public setAvailableStartTimeElement(element: TimeType | undefined): this {
    if (isDefined<TimeType>(element)) {
      const optErrMsg = \`Invalid Availability.availableTime.availableStartTime; Provided element is not an instance of TimeType.\`;
      assertFhirType<TimeType>(element, TimeType, optErrMsg);
      this.availableStartTime = element;
    } else {
      this.availableStartTime = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`availableStartTime\` property exists and has a value; \`false\` otherwise
   */
  public hasAvailableStartTimeElement(): boolean {
    return isDefined<TimeType>(this.availableStartTime) && !this.availableStartTime.isEmpty();
  }

  /**
   * @returns the \`availableStartTime\` property value as a fhirTime if defined; else undefined
   */
  public getAvailableStartTime(): fhirTime | undefined {
    return this.availableStartTime?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`availableStartTime\` property.
   *
   * @param value - the \`availableStartTime\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setAvailableStartTime(value: fhirTime | undefined): this {
    if (isDefined<fhirTime>(value)) {
      const optErrMsg = \`Invalid Availability.availableTime.availableStartTime (\${String(value)})\`;
      this.availableStartTime = new TimeType(parseFhirPrimitiveData(value, fhirTimeSchema, optErrMsg));
    } else {
      this.availableStartTime = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`availableStartTime\` property exists and has a value; \`false\` otherwise
   */
  public hasAvailableStartTime(): boolean {
    return this.hasAvailableStartTimeElement();
  }

  /**
   * @returns the \`availableEndTime\` property value as a TimeType object if defined; else an empty TimeType object
   */
  public getAvailableEndTimeElement(): TimeType {
    return this.availableEndTime ?? new TimeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`availableEndTime\` property.
   *
   * @param element - the \`availableEndTime\` value
   * @returns this
   */
  public setAvailableEndTimeElement(element: TimeType | undefined): this {
    if (isDefined<TimeType>(element)) {
      const optErrMsg = \`Invalid Availability.availableTime.availableEndTime; Provided element is not an instance of TimeType.\`;
      assertFhirType<TimeType>(element, TimeType, optErrMsg);
      this.availableEndTime = element;
    } else {
      this.availableEndTime = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`availableEndTime\` property exists and has a value; \`false\` otherwise
   */
  public hasAvailableEndTimeElement(): boolean {
    return isDefined<TimeType>(this.availableEndTime) && !this.availableEndTime.isEmpty();
  }

  /**
   * @returns the \`availableEndTime\` property value as a fhirTime if defined; else undefined
   */
  public getAvailableEndTime(): fhirTime | undefined {
    return this.availableEndTime?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`availableEndTime\` property.
   *
   * @param value - the \`availableEndTime\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setAvailableEndTime(value: fhirTime | undefined): this {
    if (isDefined<fhirTime>(value)) {
      const optErrMsg = \`Invalid Availability.availableTime.availableEndTime (\${String(value)})\`;
      this.availableEndTime = new TimeType(parseFhirPrimitiveData(value, fhirTimeSchema, optErrMsg));
    } else {
      this.availableEndTime = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`availableEndTime\` property exists and has a value; \`false\` otherwise
   */
  public hasAvailableEndTime(): boolean {
    return this.hasAvailableEndTimeElement();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Availability.availableTime';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.daysOfWeek,
      this.allDay,
      this.availableStartTime,
      this.availableEndTime,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): AvailabilityAvailableTimeComponent {
    const dest = new AvailabilityAvailableTimeComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: AvailabilityAvailableTimeComponent): void {
    super.copyValues(dest);
    const daysOfWeekList = copyListValues<EnumCodeType>(this.daysOfWeek);
    dest.daysOfWeek = daysOfWeekList.length === 0 ? undefined : daysOfWeekList;
    dest.allDay = this.allDay?.copy();
    dest.availableStartTime = this.availableStartTime?.copy();
    dest.availableEndTime = this.availableEndTime?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasDaysOfWeekElement()) {
      setFhirPrimitiveListJson<fhirCode>(this.getDaysOfWeekElement(), 'daysOfWeek', jsonObj);
    }

    if (this.hasAllDayElement()) {
      setFhirPrimitiveJson<fhirBoolean>(this.getAllDayElement(), 'allDay', jsonObj);
    }

    if (this.hasAvailableStartTimeElement()) {
      setFhirPrimitiveJson<fhirTime>(this.getAvailableStartTimeElement(), 'availableStartTime', jsonObj);
    }

    if (this.hasAvailableEndTimeElement()) {
      setFhirPrimitiveJson<fhirTime>(this.getAvailableEndTimeElement(), 'availableEndTime', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * AvailabilityNotAvailableTimeComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Not available during this time due to provided reason
 * - **Definition:** Not available during this time due to provided reason.
 * - **Requirements:** The {item} is not available during this period of time due to the provided reason.
 *
 * @category DataModel: ComplexType
 * @see [FHIR Availability](http://hl7.org/fhir/StructureDefinition/Availability)
 */
export class AvailabilityNotAvailableTimeComponent extends Element {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`AvailabilityNotAvailableTimeComponent\` JSON to instantiate the AvailabilityNotAvailableTimeComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`AvailabilityNotAvailableTimeComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to AvailabilityNotAvailableTimeComponent
   * @returns AvailabilityNotAvailableTimeComponent data model or undefined for \`AvailabilityNotAvailableTimeComponent\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): AvailabilityNotAvailableTimeComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'AvailabilityNotAvailableTimeComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new AvailabilityNotAvailableTimeComponent();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    

    fieldName = 'description';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setDescriptionElement(datatype);
    }

    fieldName = 'during';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Period | undefined = fhirDataTypeParser.parser<Period>(Period, classJsonObj[fieldName]!, sourceField);
      instance.setDuring(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Availability.notAvailableTime.description Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Reason presented to the user explaining why time not available
   * - **Definition:** Reason presented to the user explaining why time not available.
   * - **Comment:** The reason will generally be provided to give the textual reason for displaying when the {item} is not available, e.g. \\'Closed public holidays\\' or \\'Independence Day\\'. In cases such as this, the \`during\` might not be included and local knowledge would be required in such cases (as don\\'t desire to keep updating when the holiday occurs each year). e.g.2: \\'Closed for maintenance over the summer\\' for this example you would want to include the \`during\` period, unless this was a university hospital and the "summer" period was well known, but would recommend its inclusion anyway.
   * - **Requirements:** The reason that can be presented to the user as to why this time is not available.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private description?: StringType | undefined;

  /**
   * Availability.notAvailableTime.during Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Service not available during this period
   * - **Definition:** Service not available during this period.
   * - **Requirements:** The {item} is not available (seasonally or for a public holiday) during this period.
   * - **FHIR Type:** \`Period\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private during?: Period | undefined;


  /**
   * @returns the \`description\` property value as a StringType object if defined; else an empty StringType object
   */
  public getDescriptionElement(): StringType {
    return this.description ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`description\` property.
   *
   * @param element - the \`description\` value
   * @returns this
   */
  public setDescriptionElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Availability.notAvailableTime.description; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.description = element;
    } else {
      this.description = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`description\` property exists and has a value; \`false\` otherwise
   */
  public hasDescriptionElement(): boolean {
    return isDefined<StringType>(this.description) && !this.description.isEmpty();
  }

  /**
   * @returns the \`description\` property value as a fhirString if defined; else undefined
   */
  public getDescription(): fhirString | undefined {
    return this.description?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`description\` property.
   *
   * @param value - the \`description\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setDescription(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Availability.notAvailableTime.description (\${String(value)})\`;
      this.description = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.description = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`description\` property exists and has a value; \`false\` otherwise
   */
  public hasDescription(): boolean {
    return this.hasDescriptionElement();
  }

  /**
   * @returns the \`during\` property value as a Period object if defined; else an empty Period object
   */
  public getDuring(): Period {
    return this.during ?? new Period();
  }

  /**
   * Assigns the provided During object value to the \`during\` property.
   *
   * @param value - the \`during\` object value
   * @returns this
   */
  public setDuring(value: Period | undefined): this {
    if (isDefined<Period>(value)) {
      const optErrMsg = \`Invalid Availability.notAvailableTime.during; Provided element is not an instance of Period.\`;
      assertFhirType<Period>(value, Period, optErrMsg);
      this.during = value;
    } else {
      this.during = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`during\` property exists and has a value; \`false\` otherwise
   */
  public hasDuring(): boolean {
    return isDefined<Period>(this.during) && !this.during.isEmpty();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Availability.notAvailableTime';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.description,
      this.during,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): AvailabilityNotAvailableTimeComponent {
    const dest = new AvailabilityNotAvailableTimeComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: AvailabilityNotAvailableTimeComponent): void {
    super.copyValues(dest);
    dest.description = this.description?.copy();
    dest.during = this.during?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasDescriptionElement()) {
      setFhirPrimitiveJson<fhirString>(this.getDescriptionElement(), 'description', jsonObj);
    }

    if (this.hasDuring()) {
      setFhirComplexJson(this.getDuring(), 'during', jsonObj);
    }

    return jsonObj;
  }
}
",
  "fileExtension": "ts",
  "filename": "Availability",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 29`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * CodeableConcept Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/CodeableConcept
 * StructureDefinition.name: CodeableConcept
 * StructureDefinition.description: Base StructureDefinition for CodeableConcept Type: A concept that may be defined by a formal reference to a terminology or ontology or may be provided by text.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  DataType,
  FhirDataTypeParser,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  StringType,
  assertFhirType,
  assertFhirTypeList,
  copyListValues,
  fhirString,
  fhirStringSchema,
  getPrimitiveTypeJson,
  isDefined,
  isDefinedList,
  isElementEmpty,
  isEmpty,
  parseFhirPrimitiveData,
  parseStringType,
  setFhirComplexListJson,
  setFhirPrimitiveJson,
} from '@paq-ts-fhir/fhir-core';
import {
  Coding,
  PARSABLE_DATATYPE_MAP,
} from '../index';

/**
 * CodeableConcept Class
 *
 * @remarks
 * Base StructureDefinition for CodeableConcept Type: A concept that may be defined by a formal reference to a terminology or ontology or may be provided by text.
 *
 * This is a common pattern in healthcare - a concept that may be defined by one or more codes from formal definitions including LOINC and SNOMED CT, and/or defined by the provision of text that captures a human sense of the concept.
 *
 * **FHIR Specification**
 * - **Short:** Concept - reference to a terminology or just  text
 * - **Definition:** A concept that may be defined by a formal reference to a terminology or ontology or may be provided by text.
 * - **Comment:** Not all terminology uses fit this general pattern. In some cases, models should not use CodeableConcept and use Coding directly and provide their own structure for managing text, codings, translations and the relationship between elements and pre- and post-coordination.
 * - **FHIR Version:** 4.0.1
 *
 * @category DataModel: ComplexType
 * @see [FHIR CodeableConcept](http://hl7.org/fhir/StructureDefinition/CodeableConcept)
 */
export class CodeableConcept extends DataType implements IBase {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`CodeableConcept\` JSON to instantiate the CodeableConcept data model.
   *
   * @param sourceJson - JSON representing FHIR \`CodeableConcept\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to CodeableConcept
   * @returns CodeableConcept data model or undefined for \`CodeableConcept\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): CodeableConcept | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'CodeableConcept';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new CodeableConcept();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    

    fieldName = 'coding';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Coding | undefined = fhirDataTypeParser.parser<Coding>(Coding, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addCoding(datatype);
        }
      });
    }

    fieldName = 'text';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setTextElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * CodeableConcept.coding Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Code defined by a terminology system
   * - **Definition:** A reference to a code defined by a terminology system.
   * - **Comment:** Codes may be defined very casually in enumerations, or code lists, up to very formal definitions such as SNOMED CT - see the HL7 v3 Core Principles for more information.  Ordering of codings is undefined and SHALL NOT be used to infer meaning. Generally, at most only one of the coding values will be labeled as UserSelected = true.
   * - **Requirements:** Allows for alternative encodings within a code system, and translations to other code systems.
   * - **FHIR Type:** \`Coding\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private coding?: Coding[] | undefined;

  /**
   * CodeableConcept.text Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Plain text representation of the concept
   * - **Definition:** A human language representation of the concept as seen/selected/uttered by the user who entered the data and/or which represents the intended meaning of the user.
   * - **Comment:** Very often the text is the same as a displayName of one of the codings.
   * - **Requirements:** The codes from the terminologies do not always capture the correct meaning with all the nuances of the human using them, or sometimes there is no appropriate code at all. In these cases, the text is used to capture the full meaning of the source.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private text?: StringType | undefined;


  /**
   * @returns the \`coding\` property value as a Coding array
   */
  public getCoding(): Coding[] {
    return this.coding ?? ([] as Coding[]);
  }

  /**
   * Assigns the provided Coding array value to the \`coding\` property.
   *
   * @param value - the \`coding\` array value
   * @returns this
   */
  public setCoding(value: Coding[] | undefined): this {
    if (isDefinedList<Coding>(value)) {
      const optErrMsg = \`Invalid CodeableConcept.coding; Provided value array has an element that is not an instance of Coding.\`;
      assertFhirTypeList<Coding>(value, Coding, optErrMsg);
      this.coding = value;
    } else {
      this.coding = undefined;
    }
    return this;
  }

  /**
   * Add the provided Coding value to the \`coding\` array property.
   *
   * @param value - the \`coding\` value
   * @returns this
   */
  public addCoding(value: Coding | undefined): this {
    if (isDefined<Coding>(value)) {
      const optErrMsg = \`Invalid CodeableConcept.coding; Provided element is not an instance of Coding.\`;
      assertFhirType<Coding>(value, Coding, optErrMsg);
      this.initCoding();
      this.coding?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`coding\` property exists and has a value; \`false\` otherwise
   */
  public hasCoding(): boolean {
    return isDefinedList<Coding>(this.coding) && this.coding.some((item: Coding) => !item.isEmpty());
  }

  /**
   * Initialize the \`coding\` property
   */
  private initCoding(): void {
    if(!this.hasCoding()) {
      this.coding = [] as Coding[];
    }
  }

  /**
   * @returns the \`text\` property value as a StringType object if defined; else an empty StringType object
   */
  public getTextElement(): StringType {
    return this.text ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`text\` property.
   *
   * @param element - the \`text\` value
   * @returns this
   */
  public setTextElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid CodeableConcept.text; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.text = element;
    } else {
      this.text = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`text\` property exists and has a value; \`false\` otherwise
   */
  public hasTextElement(): boolean {
    return isDefined<StringType>(this.text) && !this.text.isEmpty();
  }

  /**
   * @returns the \`text\` property value as a fhirString if defined; else undefined
   */
  public getText(): fhirString | undefined {
    return this.text?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`text\` property.
   *
   * @param value - the \`text\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setText(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid CodeableConcept.text (\${String(value)})\`;
      this.text = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.text = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`text\` property exists and has a value; \`false\` otherwise
   */
  public hasText(): boolean {
    return this.hasTextElement();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'CodeableConcept';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.coding,
      this.text,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): CodeableConcept {
    const dest = new CodeableConcept();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: CodeableConcept): void {
    super.copyValues(dest);
    const codingList = copyListValues<Coding>(this.coding);
    dest.coding = codingList.length === 0 ? undefined : codingList;
    dest.text = this.text?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasCoding()) {
      setFhirComplexListJson(this.getCoding(), 'coding', jsonObj);
    }

    if (this.hasTextElement()) {
      setFhirPrimitiveJson<fhirString>(this.getTextElement(), 'text', jsonObj);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "CodeableConcept",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 30`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * CodeableReference Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/CodeableReference
 * StructureDefinition.name: CodeableReference
 * StructureDefinition.description: CodeableReference Type: A reference to a resource (by instance), or instead, a reference to a concept defined in a terminology or ontology (by class).
 * StructureDefinition.fhirVersion: 5.0.0
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  DataType,
  FhirDataTypeParser,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  assertFhirType,
  isDefined,
  isElementEmpty,
  isEmpty,
  setFhirComplexJson,
} from '@paq-ts-fhir/fhir-core';
import {
  CodeableConcept,
  PARSABLE_DATATYPE_MAP,
  Reference,
  ReferenceTargets,
} from '../index';

/**
 * CodeableReference Class
 *
 * @remarks
 * CodeableReference Type: A reference to a resource (by instance), or instead, a reference to a concept defined in a terminology or ontology (by class).
 *
 * This is a common pattern in record keeping - a reference may be made to a specific condition, observation, plan, or definition, or a reference may be made to a general concept defined in a knowledge base somewhere.
 *
 * **FHIR Specification**
 * - **Short:** Reference to a resource or a concept
 * - **Definition:** A reference to a resource (by instance), or instead, a reference to a concept defined in a terminology or ontology (by class).
 * - **FHIR Version:** 5.0.0
 *
 * @category DataModel: ComplexType
 * @see [FHIR CodeableReference](http://hl7.org/fhir/StructureDefinition/CodeableReference)
 */
export class CodeableReference extends DataType implements IBase {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`CodeableReference\` JSON to instantiate the CodeableReference data model.
   *
   * @param sourceJson - JSON representing FHIR \`CodeableReference\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to CodeableReference
   * @returns CodeableReference data model or undefined for \`CodeableReference\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): CodeableReference | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'CodeableReference';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new CodeableReference();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';

    fieldName = 'concept';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = fhirDataTypeParser.parser<CodeableConcept>(CodeableConcept, classJsonObj[fieldName]!, sourceField);
      instance.setConcept(datatype);
    }

    fieldName = 'reference';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = fhirDataTypeParser.parser<Reference>(Reference, classJsonObj[fieldName]!, sourceField);
      instance.setReference(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * CodeableReference.concept Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Reference to a concept (by class)
   * - **Definition:** A reference to a concept - e.g. the information is identified by its general class to the degree of precision found in the terminology.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private concept?: CodeableConcept | undefined;

  /**
   * CodeableReference.reference Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Reference to a resource (by instance)
   * - **Definition:** A reference to a resource the provides exact details about the information being referenced.
   * - **FHIR Type:** \`Reference\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private reference?: Reference | undefined;


  /**
   * @returns the \`concept\` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getConcept(): CodeableConcept {
    return this.concept ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Concept object value to the \`concept\` property.
   *
   * @param value - the \`concept\` object value
   * @returns this
   */
  public setConcept(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid CodeableReference.concept; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.concept = value;
    } else {
      this.concept = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`concept\` property exists and has a value; \`false\` otherwise
   */
  public hasConcept(): boolean {
    return isDefined<CodeableConcept>(this.concept) && !this.concept.isEmpty();
  }

  /**
   * @returns the \`reference\` property value as a Reference object; else an empty Reference object
   */
  public getReference(): Reference {
    return this.reference ?? new Reference();
  }

  /**
   * Assigns the provided Reference object value to the \`reference\` property.
   *
   * @decorator \`@ReferenceTargets('CodeableReference.reference', [])\`
   *
   * @param value - the \`reference\` object value
   * @returns this
   */
  @ReferenceTargets('CodeableReference.reference', [])
  public setReference(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.reference = value;
    } else {
      this.reference = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`reference\` property exists and has a value; \`false\` otherwise
   */
  public hasReference(): boolean {
    return isDefined<Reference>(this.reference) && !this.reference.isEmpty();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'CodeableReference';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.concept,
      this.reference,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): CodeableReference {
    const dest = new CodeableReference();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: CodeableReference): void {
    super.copyValues(dest);
    dest.concept = this.concept?.copy();
    dest.reference = this.reference?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasConcept()) {
      setFhirComplexJson(this.getConcept(), 'concept', jsonObj);
    }

    if (this.hasReference()) {
      setFhirComplexJson(this.getReference(), 'reference', jsonObj);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "CodeableReference",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 31`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * Coding Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/Coding
 * StructureDefinition.name: Coding
 * StructureDefinition.description: Base StructureDefinition for Coding Type: A reference to a code defined by a terminology system.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  BooleanType,
  CodeType,
  DataType,
  FhirDataTypeParser,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  StringType,
  UriType,
  assertFhirType,
  fhirBoolean,
  fhirBooleanSchema,
  fhirCode,
  fhirCodeSchema,
  fhirString,
  fhirStringSchema,
  fhirUri,
  fhirUriSchema,
  getPrimitiveTypeJson,
  isDefined,
  isElementEmpty,
  isEmpty,
  parseBooleanType,
  parseCodeType,
  parseFhirPrimitiveData,
  parseStringType,
  parseUriType,
  setFhirPrimitiveJson,
} from '@paq-ts-fhir/fhir-core';
import {
  PARSABLE_DATATYPE_MAP,
} from '../index';

/**
 * Coding Class
 *
 * @remarks
 * Base StructureDefinition for Coding Type: A reference to a code defined by a terminology system.
 *
 * References to codes are very common in healthcare models.
 *
 * **FHIR Specification**
 * - **Short:** A reference to a code defined by a terminology system
 * - **Definition:** A reference to a code defined by a terminology system.
 * - **Comment:** Codes may be defined very casually in enumerations or code lists, up to very formal definitions such as SNOMED CT - see the HL7 v3 Core Principles for more information.
 * - **FHIR Version:** 4.0.1
 *
 * @category DataModel: ComplexType
 * @see [FHIR Coding](http://hl7.org/fhir/StructureDefinition/Coding)
 */
export class Coding extends DataType implements IBase {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`Coding\` JSON to instantiate the Coding data model.
   *
   * @param sourceJson - JSON representing FHIR \`Coding\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Coding
   * @returns Coding data model or undefined for \`Coding\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Coding | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Coding';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Coding();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'system';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = parseUriType(dtJson, dtSiblingJson);
      instance.setSystemElement(datatype);
    }

    fieldName = 'version';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setVersionElement(datatype);
    }

    fieldName = 'code';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      instance.setCodeElement(datatype);
    }

    fieldName = 'display';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setDisplayElement(datatype);
    }

    fieldName = 'userSelected';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'boolean';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: BooleanType | undefined = parseBooleanType(dtJson, dtSiblingJson);
      instance.setUserSelectedElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Coding.system Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Identity of the terminology system
   * - **Definition:** The identification of the code system that defines the meaning of the symbol in the code.
   * - **Comment:** The URI may be an OID (urn:oid:...) or a UUID (urn:uuid:...).  OIDs and UUIDs SHALL be references to the HL7 OID registry. Otherwise, the URI should come from HL7\\'s list of FHIR defined special URIs or it should reference to some definition that establishes the system clearly and unambiguously.
   * - **Requirements:** Need to be unambiguous about the source of the definition of the symbol.
   * - **FHIR Type:** \`uri\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private system?: UriType | undefined;

  /**
   * Coding.version Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Version of the system - if relevant
   * - **Definition:** The version of the code system which was used when choosing this code. Note that a well-maintained code system does not need the version reported, because the meaning of codes is consistent across versions. However this cannot consistently be assured, and when the meaning is not guaranteed to be consistent, the version SHOULD be exchanged.
   * - **Comment:** Where the terminology does not clearly define what string should be used to identify code system versions, the recommendation is to use the date (expressed in FHIR date format) on which that version was officially published as the version date.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private version?: StringType | undefined;

  /**
   * Coding.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Symbol in syntax defined by the system
   * - **Definition:** A symbol in syntax defined by the system. The symbol may be a predefined code or an expression in a syntax defined by the coding system (e.g. post-coordination).
   * - **Requirements:** Need to refer to a particular code in the system.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code?: CodeType | undefined;

  /**
   * Coding.display Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Representation defined by the system
   * - **Definition:** A representation of the meaning of the code in the system, following the rules of the system.
   * - **Requirements:** Need to be able to carry a human-readable meaning of the code for readers that do not know  the system.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private display?: StringType | undefined;

  /**
   * Coding.userSelected Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** If this coding was chosen directly by the user
   * - **Definition:** Indicates that this coding was chosen by a user directly - e.g. off a pick list of available items (codes or displays).
   * - **Comment:** Amongst a set of alternatives, a directly chosen code is the most appropriate starting point for new translations. There is some ambiguity about what exactly \\'directly chosen\\' implies, and trading partner agreement may be needed to clarify the use of this element and its consequences more completely.
   * - **Requirements:** This has been identified as a clinical safety criterium - that this exact system/code pair was chosen explicitly, rather than inferred by the system based on some rules or language processing.
   * - **FHIR Type:** \`boolean\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private userSelected?: BooleanType | undefined;


  /**
   * @returns the \`system\` property value as a UriType object if defined; else an empty UriType object
   */
  public getSystemElement(): UriType {
    return this.system ?? new UriType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`system\` property.
   *
   * @param element - the \`system\` value
   * @returns this
   */
  public setSystemElement(element: UriType | undefined): this {
    if (isDefined<UriType>(element)) {
      const optErrMsg = \`Invalid Coding.system; Provided element is not an instance of UriType.\`;
      assertFhirType<UriType>(element, UriType, optErrMsg);
      this.system = element;
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`system\` property exists and has a value; \`false\` otherwise
   */
  public hasSystemElement(): boolean {
    return isDefined<UriType>(this.system) && !this.system.isEmpty();
  }

  /**
   * @returns the \`system\` property value as a fhirUri if defined; else undefined
   */
  public getSystem(): fhirUri | undefined {
    return this.system?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`system\` property.
   *
   * @param value - the \`system\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setSystem(value: fhirUri | undefined): this {
    if (isDefined<fhirUri>(value)) {
      const optErrMsg = \`Invalid Coding.system (\${String(value)})\`;
      this.system = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`system\` property exists and has a value; \`false\` otherwise
   */
  public hasSystem(): boolean {
    return this.hasSystemElement();
  }

  /**
   * @returns the \`version\` property value as a StringType object if defined; else an empty StringType object
   */
  public getVersionElement(): StringType {
    return this.version ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`version\` property.
   *
   * @param element - the \`version\` value
   * @returns this
   */
  public setVersionElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Coding.version; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.version = element;
    } else {
      this.version = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`version\` property exists and has a value; \`false\` otherwise
   */
  public hasVersionElement(): boolean {
    return isDefined<StringType>(this.version) && !this.version.isEmpty();
  }

  /**
   * @returns the \`version\` property value as a fhirString if defined; else undefined
   */
  public getVersion(): fhirString | undefined {
    return this.version?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`version\` property.
   *
   * @param value - the \`version\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setVersion(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Coding.version (\${String(value)})\`;
      this.version = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.version = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`version\` property exists and has a value; \`false\` otherwise
   */
  public hasVersion(): boolean {
    return this.hasVersionElement();
  }

  /**
   * @returns the \`code\` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getCodeElement(): CodeType {
    return this.code ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`code\` property.
   *
   * @param element - the \`code\` value
   * @returns this
   */
  public setCodeElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Coding.code; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.code = element;
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`code\` property exists and has a value; \`false\` otherwise
   */
  public hasCodeElement(): boolean {
    return isDefined<CodeType>(this.code) && !this.code.isEmpty();
  }

  /**
   * @returns the \`code\` property value as a fhirCode if defined; else undefined
   */
  public getCode(): fhirCode | undefined {
    return this.code?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`code\` property.
   *
   * @param value - the \`code\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setCode(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Coding.code (\${String(value)})\`;
      this.code = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`code\` property exists and has a value; \`false\` otherwise
   */
  public hasCode(): boolean {
    return this.hasCodeElement();
  }

  /**
   * @returns the \`display\` property value as a StringType object if defined; else an empty StringType object
   */
  public getDisplayElement(): StringType {
    return this.display ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`display\` property.
   *
   * @param element - the \`display\` value
   * @returns this
   */
  public setDisplayElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Coding.display; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.display = element;
    } else {
      this.display = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`display\` property exists and has a value; \`false\` otherwise
   */
  public hasDisplayElement(): boolean {
    return isDefined<StringType>(this.display) && !this.display.isEmpty();
  }

  /**
   * @returns the \`display\` property value as a fhirString if defined; else undefined
   */
  public getDisplay(): fhirString | undefined {
    return this.display?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`display\` property.
   *
   * @param value - the \`display\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setDisplay(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Coding.display (\${String(value)})\`;
      this.display = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.display = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`display\` property exists and has a value; \`false\` otherwise
   */
  public hasDisplay(): boolean {
    return this.hasDisplayElement();
  }

  /**
   * @returns the \`userSelected\` property value as a BooleanType object if defined; else an empty BooleanType object
   */
  public getUserSelectedElement(): BooleanType {
    return this.userSelected ?? new BooleanType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`userSelected\` property.
   *
   * @param element - the \`userSelected\` value
   * @returns this
   */
  public setUserSelectedElement(element: BooleanType | undefined): this {
    if (isDefined<BooleanType>(element)) {
      const optErrMsg = \`Invalid Coding.userSelected; Provided element is not an instance of BooleanType.\`;
      assertFhirType<BooleanType>(element, BooleanType, optErrMsg);
      this.userSelected = element;
    } else {
      this.userSelected = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`userSelected\` property exists and has a value; \`false\` otherwise
   */
  public hasUserSelectedElement(): boolean {
    return isDefined<BooleanType>(this.userSelected) && !this.userSelected.isEmpty();
  }

  /**
   * @returns the \`userSelected\` property value as a fhirBoolean if defined; else undefined
   */
  public getUserSelected(): fhirBoolean | undefined {
    return this.userSelected?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`userSelected\` property.
   *
   * @param value - the \`userSelected\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setUserSelected(value: fhirBoolean | undefined): this {
    if (isDefined<fhirBoolean>(value)) {
      const optErrMsg = \`Invalid Coding.userSelected (\${String(value)})\`;
      this.userSelected = new BooleanType(parseFhirPrimitiveData(value, fhirBooleanSchema, optErrMsg));
    } else {
      this.userSelected = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`userSelected\` property exists and has a value; \`false\` otherwise
   */
  public hasUserSelected(): boolean {
    return this.hasUserSelectedElement();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Coding';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.system,
      this.version,
      this.code,
      this.display,
      this.userSelected,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Coding {
    const dest = new Coding();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Coding): void {
    super.copyValues(dest);
    dest.system = this.system?.copy();
    dest.version = this.version?.copy();
    dest.code = this.code?.copy();
    dest.display = this.display?.copy();
    dest.userSelected = this.userSelected?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasSystemElement()) {
      setFhirPrimitiveJson<fhirUri>(this.getSystemElement(), 'system', jsonObj);
    }

    if (this.hasVersionElement()) {
      setFhirPrimitiveJson<fhirString>(this.getVersionElement(), 'version', jsonObj);
    }

    if (this.hasCodeElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getCodeElement(), 'code', jsonObj);
    }

    if (this.hasDisplayElement()) {
      setFhirPrimitiveJson<fhirString>(this.getDisplayElement(), 'display', jsonObj);
    }

    if (this.hasUserSelectedElement()) {
      setFhirPrimitiveJson<fhirBoolean>(this.getUserSelectedElement(), 'userSelected', jsonObj);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "Coding",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 32`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * ContactDetail Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/ContactDetail
 * StructureDefinition.name: ContactDetail
 * StructureDefinition.description: ContactDetail Type: Specifies contact information for a person or organization.
 * StructureDefinition.fhirVersion: 5.0.0
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  DataType,
  FhirDataTypeParser,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  StringType,
  assertFhirType,
  assertFhirTypeList,
  copyListValues,
  fhirString,
  fhirStringSchema,
  getPrimitiveTypeJson,
  isDefined,
  isDefinedList,
  isElementEmpty,
  isEmpty,
  parseFhirPrimitiveData,
  parseStringType,
  setFhirComplexListJson,
  setFhirPrimitiveJson,
} from '@paq-ts-fhir/fhir-core';
import {
  ContactPoint,
  PARSABLE_DATATYPE_MAP,
} from '../index';

/**
 * ContactDetail Class
 *
 * @remarks
 * ContactDetail Type: Specifies contact information for a person or organization.
 *
 * Need to track contact information in the same way across multiple resources.
 *
 * **FHIR Specification**
 * - **Short:** Contact information
 * - **Definition:** Specifies contact information for a person or organization.
 * - **FHIR Version:** 5.0.0
 *
 * @category DataModel: ComplexType
 * @see [FHIR ContactDetail](http://hl7.org/fhir/StructureDefinition/ContactDetail)
 */
export class ContactDetail extends DataType implements IBase {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`ContactDetail\` JSON to instantiate the ContactDetail data model.
   *
   * @param sourceJson - JSON representing FHIR \`ContactDetail\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to ContactDetail
   * @returns ContactDetail data model or undefined for \`ContactDetail\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): ContactDetail | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'ContactDetail';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new ContactDetail();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    

    fieldName = 'name';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setNameElement(datatype);
    }

    fieldName = 'telecom';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: ContactPoint | undefined = fhirDataTypeParser.parser<ContactPoint>(ContactPoint, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addTelecom(datatype);
        }
      });
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * ContactDetail.name Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Name of an individual to contact
   * - **Definition:** The name of an individual to contact.
   * - **Comment:** If there is no named individual, the telecom information is for the organization as a whole.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private name?: StringType | undefined;

  /**
   * ContactDetail.telecom Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Contact details for individual or organization
   * - **Definition:** The contact details for the individual (if a name was provided) or the organization.
   * - **FHIR Type:** \`ContactPoint\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private telecom?: ContactPoint[] | undefined;


  /**
   * @returns the \`name\` property value as a StringType object if defined; else an empty StringType object
   */
  public getNameElement(): StringType {
    return this.name ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`name\` property.
   *
   * @param element - the \`name\` value
   * @returns this
   */
  public setNameElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid ContactDetail.name; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.name = element;
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`name\` property exists and has a value; \`false\` otherwise
   */
  public hasNameElement(): boolean {
    return isDefined<StringType>(this.name) && !this.name.isEmpty();
  }

  /**
   * @returns the \`name\` property value as a fhirString if defined; else undefined
   */
  public getName(): fhirString | undefined {
    return this.name?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`name\` property.
   *
   * @param value - the \`name\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setName(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid ContactDetail.name (\${String(value)})\`;
      this.name = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`name\` property exists and has a value; \`false\` otherwise
   */
  public hasName(): boolean {
    return this.hasNameElement();
  }

  /**
   * @returns the \`telecom\` property value as a ContactPoint array
   */
  public getTelecom(): ContactPoint[] {
    return this.telecom ?? ([] as ContactPoint[]);
  }

  /**
   * Assigns the provided ContactPoint array value to the \`telecom\` property.
   *
   * @param value - the \`telecom\` array value
   * @returns this
   */
  public setTelecom(value: ContactPoint[] | undefined): this {
    if (isDefinedList<ContactPoint>(value)) {
      const optErrMsg = \`Invalid ContactDetail.telecom; Provided value array has an element that is not an instance of ContactPoint.\`;
      assertFhirTypeList<ContactPoint>(value, ContactPoint, optErrMsg);
      this.telecom = value;
    } else {
      this.telecom = undefined;
    }
    return this;
  }

  /**
   * Add the provided ContactPoint value to the \`telecom\` array property.
   *
   * @param value - the \`telecom\` value
   * @returns this
   */
  public addTelecom(value: ContactPoint | undefined): this {
    if (isDefined<ContactPoint>(value)) {
      const optErrMsg = \`Invalid ContactDetail.telecom; Provided element is not an instance of ContactPoint.\`;
      assertFhirType<ContactPoint>(value, ContactPoint, optErrMsg);
      this.initTelecom();
      this.telecom?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`telecom\` property exists and has a value; \`false\` otherwise
   */
  public hasTelecom(): boolean {
    return isDefinedList<ContactPoint>(this.telecom) && this.telecom.some((item: ContactPoint) => !item.isEmpty());
  }

  /**
   * Initialize the \`telecom\` property
   */
  private initTelecom(): void {
    if(!this.hasTelecom()) {
      this.telecom = [] as ContactPoint[];
    }
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'ContactDetail';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.name,
      this.telecom,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): ContactDetail {
    const dest = new ContactDetail();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: ContactDetail): void {
    super.copyValues(dest);
    dest.name = this.name?.copy();
    const telecomList = copyListValues<ContactPoint>(this.telecom);
    dest.telecom = telecomList.length === 0 ? undefined : telecomList;
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasNameElement()) {
      setFhirPrimitiveJson<fhirString>(this.getNameElement(), 'name', jsonObj);
    }

    if (this.hasTelecom()) {
      setFhirComplexListJson(this.getTelecom(), 'telecom', jsonObj);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "ContactDetail",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 33`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * ContactPoint Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/ContactPoint
 * StructureDefinition.name: ContactPoint
 * StructureDefinition.description: ContactPoint Type: Details for all kinds of technology mediated contact points for a person or organization, including telephone, email, etc.
 * StructureDefinition.fhirVersion: 5.0.0
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  CodeType,
  DataType,
  EnumCodeType,
  FhirDataTypeParser,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  PositiveIntType,
  StringType,
  assertEnumCodeType,
  assertFhirType,
  fhirCode,
  fhirCodeSchema,
  fhirPositiveInt,
  fhirPositiveIntSchema,
  fhirString,
  fhirStringSchema,
  getPrimitiveTypeJson,
  isDefined,
  isElementEmpty,
  isEmpty,
  parseCodeType,
  parseFhirPrimitiveData,
  parsePositiveIntType,
  parseStringType,
  setFhirComplexJson,
  setFhirPrimitiveJson,
} from '@paq-ts-fhir/fhir-core';
import {
  ContactPointSystemEnum,
  ContactPointUseEnum,
  PARSABLE_DATATYPE_MAP,
  Period,
} from '../index';

/**
 * ContactPoint Class
 *
 * @remarks
 * ContactPoint Type: Details for all kinds of technology mediated contact points for a person or organization, including telephone, email, etc.
 *
 * Need to track phone, fax, mobile, sms numbers, email addresses, twitter tags, etc.
 *
 * **FHIR Specification**
 * - **Short:** Details of a Technology mediated contact point (phone, fax, email, etc.)
 * - **Definition:** Details for all kinds of technology mediated contact points for a person or organization, including telephone, email, etc.
 * - **FHIR Version:** 5.0.0
 *
 * @category DataModel: ComplexType
 * @see [FHIR ContactPoint](http://hl7.org/fhir/StructureDefinition/ContactPoint)
 */
export class ContactPoint extends DataType implements IBase {
  constructor() {
    super();

    this.contactPointSystemEnum = new ContactPointSystemEnum();
    this.contactPointUseEnum = new ContactPointUseEnum();
  }

  /**
   * Parse the provided \`ContactPoint\` JSON to instantiate the ContactPoint data model.
   *
   * @param sourceJson - JSON representing FHIR \`ContactPoint\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to ContactPoint
   * @returns ContactPoint data model or undefined for \`ContactPoint\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): ContactPoint | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'ContactPoint';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new ContactPoint();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'system';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      instance.setSystemElement(datatype);
    }

    fieldName = 'value';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setValueElement(datatype);
    }

    fieldName = 'use';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      instance.setUseElement(datatype);
    }

    fieldName = 'rank';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = parsePositiveIntType(dtJson, dtSiblingJson);
      instance.setRankElement(datatype);
    }

    fieldName = 'period';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Period | undefined = fhirDataTypeParser.parser<Period>(Period, classJsonObj[fieldName]!, sourceField);
      instance.setPeriod(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: ContactPointSystem
   *
   * @see {@link ContactPointSystemEnum }
   */
  private readonly contactPointSystemEnum: ContactPointSystemEnum;

  /**
   * ContactPoint.system Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** phone | fax | email | pager | url | sms | other
   * - **Definition:** Telecommunications form for contact point - what communications system is required to make use of the contact.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private system?: EnumCodeType | undefined;

  /**
   * ContactPoint.value Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The actual contact point details
   * - **Definition:** The actual contact point details, in a form that is meaningful to the designated communication system (i.e. phone number or email address).
   * - **Comment:** Additional text data such as phone extension numbers, or notes about use of the contact are sometimes included in the value.
   * - **Requirements:** Need to support legacy numbers that are not in a tightly controlled format.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private value?: StringType | undefined;

  /**
   * FHIR CodeSystem: ContactPointUse
   *
   * @see {@link ContactPointUseEnum }
   */
  private readonly contactPointUseEnum: ContactPointUseEnum;

  /**
   * ContactPoint.use Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** home | work | temp | old | mobile - purpose of this contact point
   * - **Definition:** Identifies the purpose for the contact point.
   * - **Comment:** Applications can assume that a contact is current unless it explicitly says that it is temporary or old.
   * - **Requirements:** Need to track the way a person uses this contact, so a user can choose which is appropriate for their purpose.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** true
   * - **isModifierReason:** This is labeled as &quot;Is Modifier&quot; because applications should not mistake a temporary or old contact etc.for a current/permanent one
   * - **isSummary:** true
   */
  private use?: EnumCodeType | undefined;

  /**
   * ContactPoint.rank Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Specify preferred order of use (1 = highest)
   * - **Definition:** Specifies a preferred order in which to use a set of contacts. ContactPoints with lower rank values are more preferred than those with higher rank values.
   * - **Comment:** Note that rank does not necessarily follow the order in which the contacts are represented in the instance. Ranks need not be unique.  E.g. it\\'s possible to have multiple contacts with rank=1.  If the ranks have different systems or uses, this would be interpreted to mean "X is my most preferred phone number, Y is my most preferred email address" or "X is my preferred home email and Y is my preferred work email".  If the system and use for equally-ranked contacts are the same, then the level of preference is equivalent for both repetitions.  Ranks need not be sequential and not all repetitions must have a rank.  For example, it\\'s possible to have 4 contacts with ranks of 2, 5 and two with no rank specified.  That would be interpreted to mean the first is preferred over the second and no preference stated for the remaining contacts.
   * - **FHIR Type:** \`positiveInt\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private rank?: PositiveIntType | undefined;

  /**
   * ContactPoint.period Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Time period when the contact point was/is in use
   * - **Definition:** Time period when the contact point was/is in use.
   * - **FHIR Type:** \`Period\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private period?: Period | undefined;


  /**
   * @returns the \`system\` property value as a EnumCodeType if defined; else undefined
   */
  public getSystemEnumType(): EnumCodeType | undefined {
    return this.system;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`system\` property.
   *
   * @param enumType - the \`system\` value
   * @returns this
   */
  public setSystemEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid ContactPoint.system';
      assertEnumCodeType<ContactPointSystemEnum>(enumType, ContactPointSystemEnum, errMsgPrefix);
      this.system = enumType;
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`system\` property exists and has a value; \`false\` otherwise
   */
  public hasSystemEnumType(): boolean {
    return isDefined<EnumCodeType>(this.system) && !this.system.isEmpty() && this.system.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`system\` property value as a CodeType if defined; else undefined
   */
  public getSystemElement(): CodeType | undefined {
    if (this.system === undefined) {
      return undefined;
    }
    return this.system as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`system\` property.
   *
   * @param element - the \`system\` value
   * @returns this
   */
  public setSystemElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid ContactPoint.system; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.system = new EnumCodeType(element, this.contactPointSystemEnum);
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`system\` property exists and has a value; \`false\` otherwise
   */
  public hasSystemElement(): boolean {
    return this.hasSystemEnumType();
  }

  /**
   * @returns the \`system\` property value as a fhirCode if defined; else undefined
   */
  public getSystem(): fhirCode | undefined {
    if (this.system === undefined) {
      return undefined;
    }
    return this.system.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`system\` property.
   *
   * @param value - the \`system\` value
   * @returns this
   */
  public setSystem(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid ContactPoint.system; Provided value is not an instance of fhirCode.\`;
      this.system = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.contactPointSystemEnum);
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`system\` property exists and has a value; \`false\` otherwise
   */
  public hasSystem(): boolean {
    return this.hasSystemEnumType();
  }

  /**
   * @returns the \`value\` property value as a StringType object if defined; else an empty StringType object
   */
  public getValueElement(): StringType {
    return this.value ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`value\` property.
   *
   * @param element - the \`value\` value
   * @returns this
   */
  public setValueElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid ContactPoint.value; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.value = element;
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`value\` property exists and has a value; \`false\` otherwise
   */
  public hasValueElement(): boolean {
    return isDefined<StringType>(this.value) && !this.value.isEmpty();
  }

  /**
   * @returns the \`value\` property value as a fhirString if defined; else undefined
   */
  public getValue(): fhirString | undefined {
    return this.value?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`value\` property.
   *
   * @param value - the \`value\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setValue(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid ContactPoint.value (\${String(value)})\`;
      this.value = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`value\` property exists and has a value; \`false\` otherwise
   */
  public hasValue(): boolean {
    return this.hasValueElement();
  }

  /**
   * @returns the \`use\` property value as a EnumCodeType if defined; else undefined
   */
  public getUseEnumType(): EnumCodeType | undefined {
    return this.use;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`use\` property.
   *
   * @param enumType - the \`use\` value
   * @returns this
   */
  public setUseEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid ContactPoint.use';
      assertEnumCodeType<ContactPointUseEnum>(enumType, ContactPointUseEnum, errMsgPrefix);
      this.use = enumType;
    } else {
      this.use = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`use\` property exists and has a value; \`false\` otherwise
   */
  public hasUseEnumType(): boolean {
    return isDefined<EnumCodeType>(this.use) && !this.use.isEmpty() && this.use.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`use\` property value as a CodeType if defined; else undefined
   */
  public getUseElement(): CodeType | undefined {
    if (this.use === undefined) {
      return undefined;
    }
    return this.use as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`use\` property.
   *
   * @param element - the \`use\` value
   * @returns this
   */
  public setUseElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid ContactPoint.use; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.use = new EnumCodeType(element, this.contactPointUseEnum);
    } else {
      this.use = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`use\` property exists and has a value; \`false\` otherwise
   */
  public hasUseElement(): boolean {
    return this.hasUseEnumType();
  }

  /**
   * @returns the \`use\` property value as a fhirCode if defined; else undefined
   */
  public getUse(): fhirCode | undefined {
    if (this.use === undefined) {
      return undefined;
    }
    return this.use.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`use\` property.
   *
   * @param value - the \`use\` value
   * @returns this
   */
  public setUse(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid ContactPoint.use; Provided value is not an instance of fhirCode.\`;
      this.use = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.contactPointUseEnum);
    } else {
      this.use = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`use\` property exists and has a value; \`false\` otherwise
   */
  public hasUse(): boolean {
    return this.hasUseEnumType();
  }

  /**
   * @returns the \`rank\` property value as a PositiveIntType object if defined; else an empty PositiveIntType object
   */
  public getRankElement(): PositiveIntType {
    return this.rank ?? new PositiveIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`rank\` property.
   *
   * @param element - the \`rank\` value
   * @returns this
   */
  public setRankElement(element: PositiveIntType | undefined): this {
    if (isDefined<PositiveIntType>(element)) {
      const optErrMsg = \`Invalid ContactPoint.rank; Provided element is not an instance of PositiveIntType.\`;
      assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
      this.rank = element;
    } else {
      this.rank = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`rank\` property exists and has a value; \`false\` otherwise
   */
  public hasRankElement(): boolean {
    return isDefined<PositiveIntType>(this.rank) && !this.rank.isEmpty();
  }

  /**
   * @returns the \`rank\` property value as a fhirPositiveInt if defined; else undefined
   */
  public getRank(): fhirPositiveInt | undefined {
    return this.rank?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`rank\` property.
   *
   * @param value - the \`rank\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setRank(value: fhirPositiveInt | undefined): this {
    if (isDefined<fhirPositiveInt>(value)) {
      const optErrMsg = \`Invalid ContactPoint.rank (\${String(value)})\`;
      this.rank = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    } else {
      this.rank = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`rank\` property exists and has a value; \`false\` otherwise
   */
  public hasRank(): boolean {
    return this.hasRankElement();
  }

  /**
   * @returns the \`period\` property value as a Period object if defined; else an empty Period object
   */
  public getPeriod(): Period {
    return this.period ?? new Period();
  }

  /**
   * Assigns the provided Period object value to the \`period\` property.
   *
   * @param value - the \`period\` object value
   * @returns this
   */
  public setPeriod(value: Period | undefined): this {
    if (isDefined<Period>(value)) {
      const optErrMsg = \`Invalid ContactPoint.period; Provided element is not an instance of Period.\`;
      assertFhirType<Period>(value, Period, optErrMsg);
      this.period = value;
    } else {
      this.period = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`period\` property exists and has a value; \`false\` otherwise
   */
  public hasPeriod(): boolean {
    return isDefined<Period>(this.period) && !this.period.isEmpty();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'ContactPoint';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.system,
      this.value,
      this.use,
      this.rank,
      this.period,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): ContactPoint {
    const dest = new ContactPoint();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: ContactPoint): void {
    super.copyValues(dest);
    dest.system = this.system?.copy();
    dest.value = this.value?.copy();
    dest.use = this.use?.copy();
    dest.rank = this.rank?.copy();
    dest.period = this.period?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasSystemElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getSystemElement()!, 'system', jsonObj);
    }

    if (this.hasValueElement()) {
      setFhirPrimitiveJson<fhirString>(this.getValueElement(), 'value', jsonObj);
    }

    if (this.hasUseElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getUseElement()!, 'use', jsonObj);
    }

    if (this.hasRankElement()) {
      setFhirPrimitiveJson<fhirPositiveInt>(this.getRankElement(), 'rank', jsonObj);
    }

    if (this.hasPeriod()) {
      setFhirComplexJson(this.getPeriod(), 'period', jsonObj);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "ContactPoint",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 34`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * Contributor Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/Contributor
 * StructureDefinition.name: Contributor
 * StructureDefinition.description: Base StructureDefinition for Contributor Type: A contributor to the content of a knowledge asset, including authors, editors, reviewers, and endorsers.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  CodeType,
  DataType,
  EnumCodeType,
  FhirDataTypeParser,
  FhirError,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  PrimitiveType,
  REQUIRED_PROPERTIES_DO_NOT_EXIST,
  REQUIRED_PROPERTIES_REQD_IN_JSON,
  StringType,
  assertEnumCodeType,
  assertFhirType,
  assertFhirTypeList,
  assertIsDefined,
  constructorCodeValueAsEnumCodeType,
  copyListValues,
  fhirCode,
  fhirCodeSchema,
  fhirString,
  fhirStringSchema,
  getPrimitiveTypeJson,
  isDefined,
  isDefinedList,
  isElementEmpty,
  isEmpty,
  parseCodeType,
  parseFhirPrimitiveData,
  parseStringType,
  setFhirComplexListJson,
  setFhirPrimitiveJson,
} from '@paq-ts-fhir/fhir-core';
import {
  ContactDetail,
  ContributorTypeEnum,
  PARSABLE_DATATYPE_MAP,
} from '../index';

/**
 * Contributor Class
 *
 * @remarks
 * Base StructureDefinition for Contributor Type: A contributor to the content of a knowledge asset, including authors, editors, reviewers, and endorsers.
 *
 * Need to track contributor information in the same way across multiple resources.
 *
 * **FHIR Specification**
 * - **Short:** Contributor information
 * - **Definition:** A contributor to the content of a knowledge asset, including authors, editors, reviewers, and endorsers.
 * - **FHIR Version:** 4.0.1
 *
 * @category DataModel: ComplexType
 * @see [FHIR Contributor](http://hl7.org/fhir/StructureDefinition/Contributor)
 */
export class Contributor extends DataType implements IBase {
  constructor(type_: EnumCodeType | CodeType | null = null, name: StringType | fhirString | null = null) {
    super();

    this.contributorTypeEnum = new ContributorTypeEnum();

    this.type_ = constructorCodeValueAsEnumCodeType<ContributorTypeEnum>(
      type_,
      ContributorTypeEnum,
      this.contributorTypeEnum,
      '.type',
    );

    this.name = null;
    if (isDefined<StringType | fhirString>(name)) {
      if (name instanceof PrimitiveType) {
        this.setNameElement(name);
      } else {
        this.setName(name);
      }
    }
  }

  /**
   * Parse the provided \`Contributor\` JSON to instantiate the Contributor data model.
   *
   * @param sourceJson - JSON representing FHIR \`Contributor\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Contributor
   * @returns Contributor data model or undefined for \`Contributor\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Contributor | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Contributor';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Contributor();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'type';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setTypeElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'name';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setNameElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'contact';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: ContactDetail | undefined = fhirDataTypeParser.parser<ContactDetail>(ContactDetail, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addContact(datatype);
        }
      });
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: ContributorType
   *
   * @see {@link ContributorTypeEnum }
   */
  private readonly contributorTypeEnum: ContributorTypeEnum;

  /**
   * Contributor.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** author | editor | reviewer | endorser
   * - **Definition:** The type of contributor.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private type_: EnumCodeType | null;

  /**
   * Contributor.name Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Who contributed the content
   * - **Definition:** The name of the individual or organization responsible for the contribution.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private name: StringType | null;

  /**
   * Contributor.contact Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Contact details of the contributor
   * - **Definition:** Contact details to assist a user in finding and communicating with the contributor.
   * - **FHIR Type:** \`ContactDetail\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private contact?: ContactDetail[] | undefined;


  /**
   * @returns the \`type_\` property value as a EnumCodeType if defined; else null
   */
  public getTypeEnumType(): EnumCodeType | null {
    return this.type_;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`type_\` property.
   *
   * @param enumType - the \`type_\` value
   * @returns this
   */
  public setTypeEnumType(enumType: EnumCodeType): this {
    assertIsDefined<EnumCodeType>(enumType, \`Contributor.type is required\`);
    const errMsgPrefix = \`Invalid Contributor.type\`;
    assertEnumCodeType<ContributorTypeEnum>(enumType, ContributorTypeEnum, errMsgPrefix);
    this.type_ = enumType;
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasTypeEnumType(): boolean {
    return isDefined<EnumCodeType>(this.type_) && !this.type_.isEmpty() && this.type_.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`type_\` property value as a CodeType if defined; else null
   */
  public getTypeElement(): CodeType | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_ as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`type_\` property.
   *
   * @param element - the \`type_\` value
   * @returns this
   */
  public setTypeElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, \`Contributor.type is required\`);
    const optErrMsg = \`Invalid Contributor.type; Provided value is not an instance of CodeType.\`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.type_ = new EnumCodeType(element, this.contributorTypeEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasTypeElement(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the \`type_\` property value as a fhirCode if defined; else null
   */
  public getType(): fhirCode | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`type_\` property.
   *
   * @param value - the \`type_\` value
   * @returns this
   */
  public setType(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, \`Contributor.type is required\`);
    const optErrMsg = \`Invalid Contributor.type (\${String(value)})\`;
    this.type_ = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.contributorTypeEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasType(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the \`name\` property value as a StringType object if defined; else null
   */
  public getNameElement(): StringType | null {
    return this.name;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`name\` property.
   *
   * @param element - the \`name\` value
   * @returns this
   */
  public setNameElement(element: StringType): this {
    assertIsDefined<StringType>(element, \`Contributor.name is required\`);
    const optErrMsg = \`Invalid Contributor.name; Provided value is not an instance of StringType.\`;
    assertFhirType<StringType>(element, StringType, optErrMsg);
    this.name = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`name\` property exists and has a value; \`false\` otherwise
   */
  public hasNameElement(): boolean {
    return isDefined<StringType>(this.name) && !this.name.isEmpty();
  }

  /**
   * @returns the \`name\` property value as a fhirString if defined; else null
   */
  public getName(): fhirString | null {
    if (this.name?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.name.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`name\` property.
   *
   * @param value - the \`name\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setName(value: fhirString): this {
    assertIsDefined<fhirString>(value, \`Contributor.name is required\`);
    const optErrMsg = \`Invalid Contributor.name (\${String(value)})\`;
    this.name = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`name\` property exists and has a value; \`false\` otherwise
   */
  public hasName(): boolean {
    return this.hasNameElement();
  }

  /**
   * @returns the \`contact\` property value as a ContactDetail array
   */
  public getContact(): ContactDetail[] {
    return this.contact ?? ([] as ContactDetail[]);
  }

  /**
   * Assigns the provided ContactDetail array value to the \`contact\` property.
   *
   * @param value - the \`contact\` array value
   * @returns this
   */
  public setContact(value: ContactDetail[] | undefined): this {
    if (isDefinedList<ContactDetail>(value)) {
      const optErrMsg = \`Invalid Contributor.contact; Provided value array has an element that is not an instance of ContactDetail.\`;
      assertFhirTypeList<ContactDetail>(value, ContactDetail, optErrMsg);
      this.contact = value;
    } else {
      this.contact = undefined;
    }
    return this;
  }

  /**
   * Add the provided ContactDetail value to the \`contact\` array property.
   *
   * @param value - the \`contact\` value
   * @returns this
   */
  public addContact(value: ContactDetail | undefined): this {
    if (isDefined<ContactDetail>(value)) {
      const optErrMsg = \`Invalid Contributor.contact; Provided element is not an instance of ContactDetail.\`;
      assertFhirType<ContactDetail>(value, ContactDetail, optErrMsg);
      this.initContact();
      this.contact?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`contact\` property exists and has a value; \`false\` otherwise
   */
  public hasContact(): boolean {
    return isDefinedList<ContactDetail>(this.contact) && this.contact.some((item: ContactDetail) => !item.isEmpty());
  }

  /**
   * Initialize the \`contact\` property
   */
  private initContact(): void {
    if(!this.hasContact()) {
      this.contact = [] as ContactDetail[];
    }
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Contributor';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.type_,
      this.name,
      this.contact,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Contributor {
    const dest = new Contributor();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Contributor): void {
    super.copyValues(dest);
    dest.type_ = this.type_ ? this.type_.copy() : null;
    dest.name = this.name ? this.name.copy() : null;
    const contactList = copyListValues<ContactDetail>(this.contact);
    dest.contact = contactList.length === 0 ? undefined : contactList;
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasTypeElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getTypeElement()!, 'type', jsonObj);
    } else {
      missingReqdProperties.push(\`Contributor.type\`);
    }

    if (this.hasNameElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirString>(this.getNameElement()!, 'name', jsonObj);
    } else {
      missingReqdProperties.push(\`Contributor.name\`);
    }

    if (this.hasContact()) {
      setFhirComplexListJson(this.getContact(), 'contact', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "Contributor",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 35`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * Count Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/Count
 * StructureDefinition.name: Count
 * StructureDefinition.description: Count Type: A measured amount (or an amount that can potentially be measured). Note that measured amounts include amounts that are not precisely quantified, including amounts involving arbitrary units and floating currencies.
 * StructureDefinition.fhirVersion: 5.0.0
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  CodeType,
  DataType,
  DecimalType,
  EnumCodeType,
  FhirDataTypeParser,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  StringType,
  UriType,
  assertEnumCodeType,
  assertFhirType,
  fhirCode,
  fhirCodeSchema,
  fhirDecimal,
  fhirDecimalSchema,
  fhirString,
  fhirStringSchema,
  fhirUri,
  fhirUriSchema,
  getPrimitiveTypeJson,
  isDefined,
  isElementEmpty,
  isEmpty,
  parseCodeType,
  parseDecimalType,
  parseFhirPrimitiveData,
  parseStringType,
  parseUriType,
  setFhirPrimitiveJson,
} from '@paq-ts-fhir/fhir-core';
import {
  PARSABLE_DATATYPE_MAP,
  QuantityComparatorEnum,
} from '../index';

/**
 * Count Class
 *
 * @remarks
 * Count Type: A measured amount (or an amount that can potentially be measured). Note that measured amounts include amounts that are not precisely quantified, including amounts involving arbitrary units and floating currencies.
 *
 * Need to able to capture all sorts of measured values, even if the measured value are not precisely quantified. Values include exact measures such as 3.51g, customary units such as 3 tablets, and currencies such as $100.32USD.
 *
 * **FHIR Specification**
 * - **Short:** A measured or measurable amount
 * - **Definition:** A measured amount (or an amount that can potentially be measured). Note that measured amounts include amounts that are not precisely quantified, including amounts involving arbitrary units and floating currencies.
 * - **Comment:** The context of use may frequently define what kind of quantity this is and therefore what kind of units can be used. The context of use may also restrict the values for the comparator.
 * - **FHIR Version:** 5.0.0
 *
 * @category DataModel: ComplexType
 * @see [FHIR Count](http://hl7.org/fhir/StructureDefinition/Count)
 */
export class Count extends DataType implements IBase {
  constructor() {
    super();

    this.quantityComparatorEnum = new QuantityComparatorEnum();
  }

  /**
   * Parse the provided \`Count\` JSON to instantiate the Count data model.
   *
   * @param sourceJson - JSON representing FHIR \`Count\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Count
   * @returns Count data model or undefined for \`Count\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Count | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Count';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Count();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'value';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = parseDecimalType(dtJson, dtSiblingJson);
      instance.setValueElement(datatype);
    }

    fieldName = 'comparator';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      instance.setComparatorElement(datatype);
    }

    fieldName = 'unit';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setUnitElement(datatype);
    }

    fieldName = 'system';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = parseUriType(dtJson, dtSiblingJson);
      instance.setSystemElement(datatype);
    }

    fieldName = 'code';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      instance.setCodeElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Count.value Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Numerical value (with implicit precision)
   * - **Definition:** The value of the measured amount. The value includes an implicit precision in the presentation of the value.
   * - **Comment:** The implicit precision in the value should always be honored. Monetary values have their own rules for handling precision (refer to standard accounting text books).
   * - **Requirements:** Precision is handled implicitly in almost all cases of measurement.
   * - **FHIR Type:** \`decimal\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private value?: DecimalType | undefined;

  /**
   * FHIR CodeSystem: QuantityComparator
   *
   * @see {@link QuantityComparatorEnum }
   */
  private readonly quantityComparatorEnum: QuantityComparatorEnum;

  /**
   * Count.comparator Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** < | <= | >= | > | ad - how to understand the value
   * - **Definition:** How the value should be understood and represented - whether the actual value is greater or less than the stated value due to measurement issues; e.g. if the comparator is "<" , then the real value is < stated value.
   * - **Requirements:** Need a framework for handling measures where the value is <5ug/L or >400mg/L due to the limitations of measuring methodology.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** true
   * - **isModifierReason:** This is labeled as &quot;Is Modifier&quot; because the comparator modifies the interpretation of the value significantly. If there is no comparator, then there is no modification of the value
   * - **isSummary:** true
   */
  private comparator?: EnumCodeType | undefined;

  /**
   * Count.unit Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Unit representation
   * - **Definition:** A human-readable form of the unit.
   * - **Requirements:** There are many representations for units of measure and in many contexts, particular representations are fixed and required. I.e. mcg for micrograms.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private unit?: StringType | undefined;

  /**
   * Count.system Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** System that defines coded unit form
   * - **Definition:** The identification of the system that provides the coded form of the unit.
   * - **Requirements:** Need to know the system that defines the coded form of the unit.
   * - **FHIR Type:** \`uri\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private system?: UriType | undefined;

  /**
   * Count.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Coded form of the unit
   * - **Definition:** A computer processable form of the unit in some unit representation system.
   * - **Comment:** The preferred system is UCUM, but SNOMED CT can also be used (for customary units) or ISO 4217 for currency.  The context of use may additionally require a code from a particular system.
   * - **Requirements:** Need a computable form of the unit that is fixed across all forms. UCUM provides this for quantities, but SNOMED CT provides many units of interest.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code?: CodeType | undefined;


  /**
   * @returns the \`value\` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getValueElement(): DecimalType {
    return this.value ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`value\` property.
   *
   * @param element - the \`value\` value
   * @returns this
   */
  public setValueElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = \`Invalid Count.value; Provided element is not an instance of DecimalType.\`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.value = element;
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`value\` property exists and has a value; \`false\` otherwise
   */
  public hasValueElement(): boolean {
    return isDefined<DecimalType>(this.value) && !this.value.isEmpty();
  }

  /**
   * @returns the \`value\` property value as a fhirDecimal if defined; else undefined
   */
  public getValue(): fhirDecimal | undefined {
    return this.value?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`value\` property.
   *
   * @param value - the \`value\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setValue(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = \`Invalid Count.value (\${String(value)})\`;
      this.value = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`value\` property exists and has a value; \`false\` otherwise
   */
  public hasValue(): boolean {
    return this.hasValueElement();
  }

  /**
   * @returns the \`comparator\` property value as a EnumCodeType if defined; else undefined
   */
  public getComparatorEnumType(): EnumCodeType | undefined {
    return this.comparator;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`comparator\` property.
   *
   * @param enumType - the \`comparator\` value
   * @returns this
   */
  public setComparatorEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid Count.comparator';
      assertEnumCodeType<QuantityComparatorEnum>(enumType, QuantityComparatorEnum, errMsgPrefix);
      this.comparator = enumType;
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`comparator\` property exists and has a value; \`false\` otherwise
   */
  public hasComparatorEnumType(): boolean {
    return isDefined<EnumCodeType>(this.comparator) && !this.comparator.isEmpty() && this.comparator.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`comparator\` property value as a CodeType if defined; else undefined
   */
  public getComparatorElement(): CodeType | undefined {
    if (this.comparator === undefined) {
      return undefined;
    }
    return this.comparator as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`comparator\` property.
   *
   * @param element - the \`comparator\` value
   * @returns this
   */
  public setComparatorElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Count.comparator; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.comparator = new EnumCodeType(element, this.quantityComparatorEnum);
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`comparator\` property exists and has a value; \`false\` otherwise
   */
  public hasComparatorElement(): boolean {
    return this.hasComparatorEnumType();
  }

  /**
   * @returns the \`comparator\` property value as a fhirCode if defined; else undefined
   */
  public getComparator(): fhirCode | undefined {
    if (this.comparator === undefined) {
      return undefined;
    }
    return this.comparator.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`comparator\` property.
   *
   * @param value - the \`comparator\` value
   * @returns this
   */
  public setComparator(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Count.comparator; Provided value is not an instance of fhirCode.\`;
      this.comparator = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.quantityComparatorEnum);
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`comparator\` property exists and has a value; \`false\` otherwise
   */
  public hasComparator(): boolean {
    return this.hasComparatorEnumType();
  }

  /**
   * @returns the \`unit\` property value as a StringType object if defined; else an empty StringType object
   */
  public getUnitElement(): StringType {
    return this.unit ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`unit\` property.
   *
   * @param element - the \`unit\` value
   * @returns this
   */
  public setUnitElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Count.unit; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.unit = element;
    } else {
      this.unit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`unit\` property exists and has a value; \`false\` otherwise
   */
  public hasUnitElement(): boolean {
    return isDefined<StringType>(this.unit) && !this.unit.isEmpty();
  }

  /**
   * @returns the \`unit\` property value as a fhirString if defined; else undefined
   */
  public getUnit(): fhirString | undefined {
    return this.unit?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`unit\` property.
   *
   * @param value - the \`unit\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setUnit(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Count.unit (\${String(value)})\`;
      this.unit = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.unit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`unit\` property exists and has a value; \`false\` otherwise
   */
  public hasUnit(): boolean {
    return this.hasUnitElement();
  }

  /**
   * @returns the \`system\` property value as a UriType object if defined; else an empty UriType object
   */
  public getSystemElement(): UriType {
    return this.system ?? new UriType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`system\` property.
   *
   * @param element - the \`system\` value
   * @returns this
   */
  public setSystemElement(element: UriType | undefined): this {
    if (isDefined<UriType>(element)) {
      const optErrMsg = \`Invalid Count.system; Provided element is not an instance of UriType.\`;
      assertFhirType<UriType>(element, UriType, optErrMsg);
      this.system = element;
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`system\` property exists and has a value; \`false\` otherwise
   */
  public hasSystemElement(): boolean {
    return isDefined<UriType>(this.system) && !this.system.isEmpty();
  }

  /**
   * @returns the \`system\` property value as a fhirUri if defined; else undefined
   */
  public getSystem(): fhirUri | undefined {
    return this.system?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`system\` property.
   *
   * @param value - the \`system\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setSystem(value: fhirUri | undefined): this {
    if (isDefined<fhirUri>(value)) {
      const optErrMsg = \`Invalid Count.system (\${String(value)})\`;
      this.system = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`system\` property exists and has a value; \`false\` otherwise
   */
  public hasSystem(): boolean {
    return this.hasSystemElement();
  }

  /**
   * @returns the \`code\` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getCodeElement(): CodeType {
    return this.code ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`code\` property.
   *
   * @param element - the \`code\` value
   * @returns this
   */
  public setCodeElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Count.code; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.code = element;
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`code\` property exists and has a value; \`false\` otherwise
   */
  public hasCodeElement(): boolean {
    return isDefined<CodeType>(this.code) && !this.code.isEmpty();
  }

  /**
   * @returns the \`code\` property value as a fhirCode if defined; else undefined
   */
  public getCode(): fhirCode | undefined {
    return this.code?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`code\` property.
   *
   * @param value - the \`code\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setCode(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Count.code (\${String(value)})\`;
      this.code = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`code\` property exists and has a value; \`false\` otherwise
   */
  public hasCode(): boolean {
    return this.hasCodeElement();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Count';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.value,
      this.comparator,
      this.unit,
      this.system,
      this.code,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Count {
    const dest = new Count();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Count): void {
    super.copyValues(dest);
    dest.value = this.value?.copy();
    dest.comparator = this.comparator?.copy();
    dest.unit = this.unit?.copy();
    dest.system = this.system?.copy();
    dest.code = this.code?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasValueElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getValueElement(), 'value', jsonObj);
    }

    if (this.hasComparatorElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getComparatorElement()!, 'comparator', jsonObj);
    }

    if (this.hasUnitElement()) {
      setFhirPrimitiveJson<fhirString>(this.getUnitElement(), 'unit', jsonObj);
    }

    if (this.hasSystemElement()) {
      setFhirPrimitiveJson<fhirUri>(this.getSystemElement(), 'system', jsonObj);
    }

    if (this.hasCodeElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getCodeElement(), 'code', jsonObj);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "Count",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 36`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * DataRequirement Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/DataRequirement
 * StructureDefinition.name: DataRequirement
 * StructureDefinition.description: DataRequirement Type: Describes a required data item for evaluation in terms of the type of data, and optional code or date-based filters of the data.
 * StructureDefinition.fhirVersion: 5.0.0
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  CanonicalType,
  ChoiceDataTypes,
  ChoiceDataTypesMeta,
  CodeType,
  DataType,
  DateTimeType,
  Element,
  EnumCodeType,
  FhirDataTypeParser,
  FhirError,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  InvalidTypeError,
  JSON,
  PositiveIntType,
  PrimitiveType,
  PrimitiveTypeJson,
  REQUIRED_PROPERTIES_DO_NOT_EXIST,
  REQUIRED_PROPERTIES_REQD_IN_JSON,
  StringType,
  assertEnumCodeType,
  assertFhirType,
  assertFhirTypeList,
  assertIsDefined,
  constructorCodeValueAsEnumCodeType,
  copyListValues,
  fhirCanonical,
  fhirCanonicalSchema,
  fhirCode,
  fhirCodeSchema,
  fhirPositiveInt,
  fhirPositiveIntSchema,
  fhirString,
  fhirStringSchema,
  getPrimitiveTypeJson,
  getPrimitiveTypeListJson,
  isDefined,
  isDefinedList,
  isElementEmpty,
  isEmpty,
  parseCanonicalType,
  parseCodeType,
  parseFhirPrimitiveData,
  parsePositiveIntType,
  parseStringType,
  setFhirComplexListJson,
  setFhirPrimitiveJson,
  setFhirPrimitiveListJson,
  setPolymorphicValueJson,
} from '@paq-ts-fhir/fhir-core';
import {
  CodeableConcept,
  Coding,
  Duration,
  PARSABLE_DATATYPE_MAP,
  Period,
  Reference,
  SearchComparatorEnum,
  SortDirectionEnum,
} from '../index';

// eslint-disable-next-line @typescript-eslint/no-explicit-any -- Symbol.metadata polyfill secret sauce for decorator metadata
(Symbol.metadata as any) ??= Symbol('Symbol.metadata');

/**
 * DataRequirement Class
 *
 * @remarks
 * DataRequirement Type: Describes a required data item for evaluation in terms of the type of data, and optional code or date-based filters of the data.
 *
 * **FHIR Specification**
 * - **Short:** Describes a required data item
 * - **Definition:** Describes a required data item for evaluation in terms of the type of data, and optional code or date-based filters of the data.
 * - **FHIR Version:** 5.0.0
 *
 * @category DataModel: ComplexType
 * @see [FHIR DataRequirement](http://hl7.org/fhir/StructureDefinition/DataRequirement)
 */
export class DataRequirement extends DataType implements IBase {
  constructor(type_: CodeType | fhirCode | null = null) {
    super();

    this.type_ = null;
    if (isDefined<CodeType | fhirCode>(type_)) {
      if (type_ instanceof PrimitiveType) {
        this.setTypeElement(type_);
      } else {
        this.setType(type_);
      }
    }
  }

  /**
   * Parse the provided \`DataRequirement\` JSON to instantiate the DataRequirement data model.
   *
   * @param sourceJson - JSON representing FHIR \`DataRequirement\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to DataRequirement
   * @returns DataRequirement data model or undefined for \`DataRequirement\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): DataRequirement | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'DataRequirement';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new DataRequirement();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const classMetadata: DecoratorMetadataObject | null = DataRequirement[Symbol.metadata];
    const errorMessage = \`DecoratorMetadataObject does not exist for DataRequirement\`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    const missingReqdProperties: string[] = [];

    fieldName = 'type';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setTypeElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'profile';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: CanonicalType | undefined = parseCanonicalType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addProfileElement(datatype);
        }
      });
    }

    fieldName = 'subject[x]';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const subject: DataType | undefined = fhirDataTypeParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setSubject(subject);

    fieldName = 'mustSupport';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: StringType | undefined = parseStringType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addMustSupportElement(datatype);
        }
      });
    }

    fieldName = 'codeFilter';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: DataRequirementCodeFilterComponent | undefined = fhirDataTypeParser.parser<DataRequirementCodeFilterComponent>(DataRequirementCodeFilterComponent, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addCodeFilter(datatype);
        }
      });
    }

    fieldName = 'dateFilter';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: DataRequirementDateFilterComponent | undefined = fhirDataTypeParser.parser<DataRequirementDateFilterComponent>(DataRequirementDateFilterComponent, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addDateFilter(datatype);
        }
      });
    }

    fieldName = 'valueFilter';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: DataRequirementValueFilterComponent | undefined = fhirDataTypeParser.parser<DataRequirementValueFilterComponent>(DataRequirementValueFilterComponent, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addValueFilter(datatype);
        }
      });
    }

    fieldName = 'limit';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = parsePositiveIntType(dtJson, dtSiblingJson);
      instance.setLimitElement(datatype);
    }

    fieldName = 'sort';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: DataRequirementSortComponent | undefined = fhirDataTypeParser.parser<DataRequirementSortComponent>(DataRequirementSortComponent, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addSort(datatype);
        }
      });
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * DataRequirement.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The type of the required data
   * - **Definition:** The type of the required data, specified as the type name of a resource. For profiles, this value is set to the type of the base resource of the profile.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private type_: CodeType | null;

  /**
   * DataRequirement.profile Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The profile of the required data
   * - **Definition:** The profile of the required data, specified as the uri of the profile definition.
   * - **FHIR Type:** \`canonical\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/StructureDefinition',
   *     ]
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private profile?: CanonicalType[] | undefined;

  /**
   * DataRequirement.subject[x] Element
   *
   * @decorator \`@ChoiceDataTypesMeta('DataRequirement.subject[x]', ['CodeableConcept','Reference',]\`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** E.g. Patient, Practitioner, RelatedPerson, Organization, Location, Device
   * - **Definition:** The intended subjects of the data requirement. If this element is not provided, a Patient subject is assumed.
   * - **Comment:** The subject of a data requirement is critical, as the data being specified is determined with respect to a particular subject. This corresponds roughly to the notion of a Compartment in that it limits what data is available based on its relationship to the subject. In CQL, this corresponds to the context declaration.
   * - **FHIR Types:**
   *     'CodeableConcept',
   *     'Reference',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('DataRequirement.subject[x]',[
    'CodeableConcept',
    'Reference',
  ])
  private subject?: DataType | undefined;

  /**
   * DataRequirement.mustSupport Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Indicates specific structure elements that are referenced by the knowledge module
   * - **Definition:** Indicates that specific elements of the type are referenced by the knowledge module and must be supported by the consumer in order to obtain an effective evaluation. This does not mean that a value is required for this element, only that the consuming system must understand the element and be able to provide values for it if they are available.  The value of mustSupport SHALL be a FHIRPath resolvable on the type of the DataRequirement. The path SHALL consist only of identifiers, constant indexers, and .resolve() (see the [Simple FHIRPath Profile](https://hl7.org/fhir/fhirpath.html#simple) for full details).
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private mustSupport?: StringType[] | undefined;

  /**
   * DataRequirement.codeFilter Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** What codes are expected
   * - **Definition:** Code filters specify additional constraints on the data, specifying the value set of interest for a particular element of the data. Each code filter defines an additional constraint on the data, i.e. code filters are AND\\'ed, not OR\\'ed.
   * - **FHIR Type:** \`Element\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private codeFilter?: DataRequirementCodeFilterComponent[] | undefined;

  /**
   * DataRequirement.dateFilter Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** What dates/date ranges are expected
   * - **Definition:** Date filters specify additional constraints on the data in terms of the applicable date range for specific elements. Each date filter specifies an additional constraint on the data, i.e. date filters are AND\\'ed, not OR\\'ed.
   * - **FHIR Type:** \`Element\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private dateFilter?: DataRequirementDateFilterComponent[] | undefined;

  /**
   * DataRequirement.valueFilter Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** What values are expected
   * - **Definition:** Value filters specify additional constraints on the data for elements other than code-valued or date-valued. Each value filter specifies an additional constraint on the data (i.e. valueFilters are AND\\'ed, not OR\\'ed).
   * - **FHIR Type:** \`Element\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private valueFilter?: DataRequirementValueFilterComponent[] | undefined;

  /**
   * DataRequirement.limit Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Number of results
   * - **Definition:** Specifies a maximum number of results that are required (uses the _count search parameter).
   * - **Comment:** This element can be used in combination with the sort element to specify quota requirements such as "the most recent 5" or "the highest 5".
   * - **Requirements:** Enables the requirement "most recent 5 results" to be expressed.
   * - **FHIR Type:** \`positiveInt\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private limit?: PositiveIntType | undefined;

  /**
   * DataRequirement.sort Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Order of the results
   * - **Definition:** Specifies the order of the results to be returned.
   * - **Comment:** This element can be used in combination with the sort element to specify quota requirements such as "the most recent 5" or "the highest 5". When multiple sorts are specified, they are applied in the order they appear in the resource.
   * - **Requirements:** Enables the requirement "most recent 5 results" to be expressed.
   * - **FHIR Type:** \`Element\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private sort?: DataRequirementSortComponent[] | undefined;


  /**
   * @returns the \`type_\` property value as a CodeType object if defined; else null
   */
  public getTypeElement(): CodeType | null {
    return this.type_;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`type_\` property.
   *
   * @param element - the \`type_\` value
   * @returns this
   */
  public setTypeElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, \`DataRequirement.type is required\`);
    const optErrMsg = \`Invalid DataRequirement.type; Provided value is not an instance of CodeType.\`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.type_ = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasTypeElement(): boolean {
    return isDefined<CodeType>(this.type_) && !this.type_.isEmpty();
  }

  /**
   * @returns the \`type_\` property value as a fhirCode if defined; else null
   */
  public getType(): fhirCode | null {
    if (this.type_?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.type_.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`type_\` property.
   *
   * @param value - the \`type_\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setType(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, \`DataRequirement.type is required\`);
    const optErrMsg = \`Invalid DataRequirement.type (\${String(value)})\`;
    this.type_ = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasType(): boolean {
    return this.hasTypeElement();
  }

  /**
   * @returns the \`profile\` property value as a CanonicalType array
   */
  public getProfileElement(): CanonicalType[] {
    return this.profile ?? ([] as CanonicalType[]);
  }

  /**
   * Assigns the provided CanonicalType array value to the \`profile\` property.
   *
   * @param element - the \`profile\` array value
   * @returns this
   */
  public setProfileElement(element: CanonicalType[] | undefined): this {
    if (isDefinedList<CanonicalType>(element)) {
      const optErrMsg = \`Invalid DataRequirement.profile; Provided value array has an element that is not an instance of CanonicalType.\`;
      assertFhirTypeList<CanonicalType>(element, CanonicalType, optErrMsg);
      this.profile = element;
    } else {
      this.profile = undefined;
    }
    return this;
  }

  /**
   * Add the provided CanonicalType value to the \`profile\` array property.
   *
   * @param element - the \`profile\` value
   * @returns this
   */
  public addProfileElement(element: CanonicalType | undefined): this {
    if (isDefined<CanonicalType>(element)) {
      const optErrMsg = \`Invalid DataRequirement.profile; Provided element is not an instance of CanonicalType.\`;
      assertFhirType<CanonicalType>(element, CanonicalType, optErrMsg);
      this.initProfile();
      this.profile?.push(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`profile\` property exists and has a value; \`false\` otherwise
   */
  public hasProfileElement(): boolean {
    return isDefinedList<CanonicalType>(this.profile) && this.profile.some((item: CanonicalType) => !item.isEmpty());
  }

  /**
   * @returns the \`profile\` property value as a fhirCanonical array
   */
  public getProfile(): fhirCanonical[] {
    this.initProfile();
    const profileValues = [] as fhirCanonical[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.profile!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        profileValues.push(value);
      }
    }
    return profileValues;
  }

  /**
   * Assigns the provided primitive value array to the \`profile\` property.
   *
   * @param value - the \`profile\` value array
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setProfile(value: fhirCanonical[] | undefined): this {
    if (isDefinedList<fhirCanonical>(value)) {
      const profileElements = [] as CanonicalType[];
      for (const profileValue of value) {
        const optErrMsg = \`Invalid DataRequirement.profile array item (\${String(profileValue)})\`;
        const element = new CanonicalType(parseFhirPrimitiveData(profileValue, fhirCanonicalSchema, optErrMsg));
        profileElements.push(element);
      }
      this.profile = profileElements;
    } else {
      this.profile = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`profile\` array property.
   *
   * @param value - the \`profile\` value
   * @returns this
   */
  public addProfile(value: fhirCanonical | undefined): this {
    if (isDefined<fhirCanonical>(value)) {
      const optErrMsg = \`Invalid DataRequirement.profile array item (\${String(value)})\`;
      const element = new CanonicalType(parseFhirPrimitiveData(value, fhirCanonicalSchema, optErrMsg));
      this.initProfile();
      this.addProfileElement(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`profile\` property exists and has a value; \`false\` otherwise
   */
  public hasProfile(): boolean {
    return this.hasProfileElement();
  }

  /**
   * Initialize the \`profile\` property
   */
  private initProfile(): void {
    if (!this.hasProfile()) {
      this.profile = [] as CanonicalType[];
    }
  }

  /**
   * @returns the \`subject\` property value as a DataType object if defined; else undefined
   */
  public getSubject(): DataType | undefined {
    return this.subject;
  }

  /**
   * Assigns the provided DataType object value to the \`subject\` property.
   *
   * @decorator \`@ChoiceDataTypes('DataRequirement.subject[x]')\`
   *
   * @param value - the \`subject\` object value
   * @returns this
   */
  @ChoiceDataTypes('DataRequirement.subject[x]')
  public setSubject(value: DataType | undefined): this {
    if (isDefined<DataType>(value)) {
      // assertFhirType<DataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.subject = value;
    } else {
      this.subject = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`subject\` property exists and has a value; \`false\` otherwise
   */
  public hasSubject(): boolean {
    return isDefined<DataType>(this.subject) && !this.subject.isEmpty();
  }

  // *** NOTE ***
  // Next "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the \`subject\` property value as a CodeableConcept object if defined; else undefined
   */
  public getSubjectCodeableConcept(): CodeableConcept | undefined {
    if (!isDefined<DataType | undefined>(this.subject)) {
      return undefined;
    }
    if (!(this.subject instanceof CodeableConcept)) {
      throw new InvalidTypeError(
        \`DataType mismatch for DataRequirement.subject[x]: Expected CodeableConcept but encountered \${this.subject.fhirType()}\`,
      );
    }
    return this.subject;
  }

  /**
   * @returns \`true\` if the \`subject\` property exists as a CodeableConcept and has a value; \`false\` otherwise
   */
  public hasSubjectCodeableConcept(): boolean {
    return this.hasSubject() && this.subject instanceof CodeableConcept;
  }

  /**
   * @returns the \`subject\` property value as a Reference object if defined; else undefined
   */
  public getSubjectReference(): Reference | undefined {
    if (!isDefined<DataType | undefined>(this.subject)) {
      return undefined;
    }
    if (!(this.subject instanceof Reference)) {
      throw new InvalidTypeError(
        \`DataType mismatch for DataRequirement.subject[x]: Expected Reference but encountered \${this.subject.fhirType()}\`,
      );
    }
    return this.subject;
  }

  /**
   * @returns \`true\` if the \`subject\` property exists as a Reference and has a value; \`false\` otherwise
   */
  public hasSubjectReference(): boolean {
    return this.hasSubject() && this.subject instanceof Reference;
  }

  /**
   * @returns the \`mustSupport\` property value as a StringType array
   */
  public getMustSupportElement(): StringType[] {
    return this.mustSupport ?? ([] as StringType[]);
  }

  /**
   * Assigns the provided StringType array value to the \`mustSupport\` property.
   *
   * @param element - the \`mustSupport\` array value
   * @returns this
   */
  public setMustSupportElement(element: StringType[] | undefined): this {
    if (isDefinedList<StringType>(element)) {
      const optErrMsg = \`Invalid DataRequirement.mustSupport; Provided value array has an element that is not an instance of StringType.\`;
      assertFhirTypeList<StringType>(element, StringType, optErrMsg);
      this.mustSupport = element;
    } else {
      this.mustSupport = undefined;
    }
    return this;
  }

  /**
   * Add the provided StringType value to the \`mustSupport\` array property.
   *
   * @param element - the \`mustSupport\` value
   * @returns this
   */
  public addMustSupportElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid DataRequirement.mustSupport; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.initMustSupport();
      this.mustSupport?.push(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`mustSupport\` property exists and has a value; \`false\` otherwise
   */
  public hasMustSupportElement(): boolean {
    return isDefinedList<StringType>(this.mustSupport) && this.mustSupport.some((item: StringType) => !item.isEmpty());
  }

  /**
   * @returns the \`mustSupport\` property value as a fhirString array
   */
  public getMustSupport(): fhirString[] {
    this.initMustSupport();
    const mustSupportValues = [] as fhirString[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.mustSupport!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        mustSupportValues.push(value);
      }
    }
    return mustSupportValues;
  }

  /**
   * Assigns the provided primitive value array to the \`mustSupport\` property.
   *
   * @param value - the \`mustSupport\` value array
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setMustSupport(value: fhirString[] | undefined): this {
    if (isDefinedList<fhirString>(value)) {
      const mustSupportElements = [] as StringType[];
      for (const mustSupportValue of value) {
        const optErrMsg = \`Invalid DataRequirement.mustSupport array item (\${String(mustSupportValue)})\`;
        const element = new StringType(parseFhirPrimitiveData(mustSupportValue, fhirStringSchema, optErrMsg));
        mustSupportElements.push(element);
      }
      this.mustSupport = mustSupportElements;
    } else {
      this.mustSupport = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`mustSupport\` array property.
   *
   * @param value - the \`mustSupport\` value
   * @returns this
   */
  public addMustSupport(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid DataRequirement.mustSupport array item (\${String(value)})\`;
      const element = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
      this.initMustSupport();
      this.addMustSupportElement(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`mustSupport\` property exists and has a value; \`false\` otherwise
   */
  public hasMustSupport(): boolean {
    return this.hasMustSupportElement();
  }

  /**
   * Initialize the \`mustSupport\` property
   */
  private initMustSupport(): void {
    if (!this.hasMustSupport()) {
      this.mustSupport = [] as StringType[];
    }
  }

  /**
   * @returns the \`codeFilter\` property value as a DataRequirementCodeFilterComponent array
   */
  public getCodeFilter(): DataRequirementCodeFilterComponent[] {
    return this.codeFilter ?? ([] as DataRequirementCodeFilterComponent[]);
  }

  /**
   * Assigns the provided DataRequirementCodeFilterComponent array value to the \`codeFilter\` property.
   *
   * @param value - the \`codeFilter\` array value
   * @returns this
   */
  public setCodeFilter(value: DataRequirementCodeFilterComponent[] | undefined): this {
    if (isDefinedList<DataRequirementCodeFilterComponent>(value)) {
      const optErrMsg = \`Invalid DataRequirement.codeFilter; Provided value array has an element that is not an instance of DataRequirementCodeFilterComponent.\`;
      assertFhirTypeList<DataRequirementCodeFilterComponent>(value, DataRequirementCodeFilterComponent, optErrMsg);
      this.codeFilter = value;
    } else {
      this.codeFilter = undefined;
    }
    return this;
  }

  /**
   * Add the provided DataRequirementCodeFilterComponent value to the \`codeFilter\` array property.
   *
   * @param value - the \`codeFilter\` value
   * @returns this
   */
  public addCodeFilter(value: DataRequirementCodeFilterComponent | undefined): this {
    if (isDefined<DataRequirementCodeFilterComponent>(value)) {
      const optErrMsg = \`Invalid DataRequirement.codeFilter; Provided element is not an instance of DataRequirementCodeFilterComponent.\`;
      assertFhirType<DataRequirementCodeFilterComponent>(value, DataRequirementCodeFilterComponent, optErrMsg);
      this.initCodeFilter();
      this.codeFilter?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`codeFilter\` property exists and has a value; \`false\` otherwise
   */
  public hasCodeFilter(): boolean {
    return isDefinedList<DataRequirementCodeFilterComponent>(this.codeFilter) && this.codeFilter.some((item: DataRequirementCodeFilterComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`codeFilter\` property
   */
  private initCodeFilter(): void {
    if(!this.hasCodeFilter()) {
      this.codeFilter = [] as DataRequirementCodeFilterComponent[];
    }
  }

  /**
   * @returns the \`dateFilter\` property value as a DataRequirementDateFilterComponent array
   */
  public getDateFilter(): DataRequirementDateFilterComponent[] {
    return this.dateFilter ?? ([] as DataRequirementDateFilterComponent[]);
  }

  /**
   * Assigns the provided DataRequirementDateFilterComponent array value to the \`dateFilter\` property.
   *
   * @param value - the \`dateFilter\` array value
   * @returns this
   */
  public setDateFilter(value: DataRequirementDateFilterComponent[] | undefined): this {
    if (isDefinedList<DataRequirementDateFilterComponent>(value)) {
      const optErrMsg = \`Invalid DataRequirement.dateFilter; Provided value array has an element that is not an instance of DataRequirementDateFilterComponent.\`;
      assertFhirTypeList<DataRequirementDateFilterComponent>(value, DataRequirementDateFilterComponent, optErrMsg);
      this.dateFilter = value;
    } else {
      this.dateFilter = undefined;
    }
    return this;
  }

  /**
   * Add the provided DataRequirementDateFilterComponent value to the \`dateFilter\` array property.
   *
   * @param value - the \`dateFilter\` value
   * @returns this
   */
  public addDateFilter(value: DataRequirementDateFilterComponent | undefined): this {
    if (isDefined<DataRequirementDateFilterComponent>(value)) {
      const optErrMsg = \`Invalid DataRequirement.dateFilter; Provided element is not an instance of DataRequirementDateFilterComponent.\`;
      assertFhirType<DataRequirementDateFilterComponent>(value, DataRequirementDateFilterComponent, optErrMsg);
      this.initDateFilter();
      this.dateFilter?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`dateFilter\` property exists and has a value; \`false\` otherwise
   */
  public hasDateFilter(): boolean {
    return isDefinedList<DataRequirementDateFilterComponent>(this.dateFilter) && this.dateFilter.some((item: DataRequirementDateFilterComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`dateFilter\` property
   */
  private initDateFilter(): void {
    if(!this.hasDateFilter()) {
      this.dateFilter = [] as DataRequirementDateFilterComponent[];
    }
  }

  /**
   * @returns the \`valueFilter\` property value as a DataRequirementValueFilterComponent array
   */
  public getValueFilter(): DataRequirementValueFilterComponent[] {
    return this.valueFilter ?? ([] as DataRequirementValueFilterComponent[]);
  }

  /**
   * Assigns the provided DataRequirementValueFilterComponent array value to the \`valueFilter\` property.
   *
   * @param value - the \`valueFilter\` array value
   * @returns this
   */
  public setValueFilter(value: DataRequirementValueFilterComponent[] | undefined): this {
    if (isDefinedList<DataRequirementValueFilterComponent>(value)) {
      const optErrMsg = \`Invalid DataRequirement.valueFilter; Provided value array has an element that is not an instance of DataRequirementValueFilterComponent.\`;
      assertFhirTypeList<DataRequirementValueFilterComponent>(value, DataRequirementValueFilterComponent, optErrMsg);
      this.valueFilter = value;
    } else {
      this.valueFilter = undefined;
    }
    return this;
  }

  /**
   * Add the provided DataRequirementValueFilterComponent value to the \`valueFilter\` array property.
   *
   * @param value - the \`valueFilter\` value
   * @returns this
   */
  public addValueFilter(value: DataRequirementValueFilterComponent | undefined): this {
    if (isDefined<DataRequirementValueFilterComponent>(value)) {
      const optErrMsg = \`Invalid DataRequirement.valueFilter; Provided element is not an instance of DataRequirementValueFilterComponent.\`;
      assertFhirType<DataRequirementValueFilterComponent>(value, DataRequirementValueFilterComponent, optErrMsg);
      this.initValueFilter();
      this.valueFilter?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`valueFilter\` property exists and has a value; \`false\` otherwise
   */
  public hasValueFilter(): boolean {
    return isDefinedList<DataRequirementValueFilterComponent>(this.valueFilter) && this.valueFilter.some((item: DataRequirementValueFilterComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`valueFilter\` property
   */
  private initValueFilter(): void {
    if(!this.hasValueFilter()) {
      this.valueFilter = [] as DataRequirementValueFilterComponent[];
    }
  }

  /**
   * @returns the \`limit\` property value as a PositiveIntType object if defined; else an empty PositiveIntType object
   */
  public getLimitElement(): PositiveIntType {
    return this.limit ?? new PositiveIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`limit\` property.
   *
   * @param element - the \`limit\` value
   * @returns this
   */
  public setLimitElement(element: PositiveIntType | undefined): this {
    if (isDefined<PositiveIntType>(element)) {
      const optErrMsg = \`Invalid DataRequirement.limit; Provided element is not an instance of PositiveIntType.\`;
      assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
      this.limit = element;
    } else {
      this.limit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`limit\` property exists and has a value; \`false\` otherwise
   */
  public hasLimitElement(): boolean {
    return isDefined<PositiveIntType>(this.limit) && !this.limit.isEmpty();
  }

  /**
   * @returns the \`limit\` property value as a fhirPositiveInt if defined; else undefined
   */
  public getLimit(): fhirPositiveInt | undefined {
    return this.limit?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`limit\` property.
   *
   * @param value - the \`limit\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setLimit(value: fhirPositiveInt | undefined): this {
    if (isDefined<fhirPositiveInt>(value)) {
      const optErrMsg = \`Invalid DataRequirement.limit (\${String(value)})\`;
      this.limit = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    } else {
      this.limit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`limit\` property exists and has a value; \`false\` otherwise
   */
  public hasLimit(): boolean {
    return this.hasLimitElement();
  }

  /**
   * @returns the \`sort\` property value as a DataRequirementSortComponent array
   */
  public getSort(): DataRequirementSortComponent[] {
    return this.sort ?? ([] as DataRequirementSortComponent[]);
  }

  /**
   * Assigns the provided DataRequirementSortComponent array value to the \`sort\` property.
   *
   * @param value - the \`sort\` array value
   * @returns this
   */
  public setSort(value: DataRequirementSortComponent[] | undefined): this {
    if (isDefinedList<DataRequirementSortComponent>(value)) {
      const optErrMsg = \`Invalid DataRequirement.sort; Provided value array has an element that is not an instance of DataRequirementSortComponent.\`;
      assertFhirTypeList<DataRequirementSortComponent>(value, DataRequirementSortComponent, optErrMsg);
      this.sort = value;
    } else {
      this.sort = undefined;
    }
    return this;
  }

  /**
   * Add the provided DataRequirementSortComponent value to the \`sort\` array property.
   *
   * @param value - the \`sort\` value
   * @returns this
   */
  public addSort(value: DataRequirementSortComponent | undefined): this {
    if (isDefined<DataRequirementSortComponent>(value)) {
      const optErrMsg = \`Invalid DataRequirement.sort; Provided element is not an instance of DataRequirementSortComponent.\`;
      assertFhirType<DataRequirementSortComponent>(value, DataRequirementSortComponent, optErrMsg);
      this.initSort();
      this.sort?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`sort\` property exists and has a value; \`false\` otherwise
   */
  public hasSort(): boolean {
    return isDefinedList<DataRequirementSortComponent>(this.sort) && this.sort.some((item: DataRequirementSortComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`sort\` property
   */
  private initSort(): void {
    if(!this.hasSort()) {
      this.sort = [] as DataRequirementSortComponent[];
    }
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'DataRequirement';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.type_,
      this.profile,
      this.subject,
      this.mustSupport,
      this.codeFilter,
      this.dateFilter,
      this.valueFilter,
      this.limit,
      this.sort,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): DataRequirement {
    const dest = new DataRequirement();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: DataRequirement): void {
    super.copyValues(dest);
    dest.type_ = this.type_ ? this.type_.copy() : null;
    const profileList = copyListValues<CanonicalType>(this.profile);
    dest.profile = profileList.length === 0 ? undefined : profileList;
    dest.subject = this.subject?.copy();
    const mustSupportList = copyListValues<StringType>(this.mustSupport);
    dest.mustSupport = mustSupportList.length === 0 ? undefined : mustSupportList;
    const codeFilterList = copyListValues<DataRequirementCodeFilterComponent>(this.codeFilter);
    dest.codeFilter = codeFilterList.length === 0 ? undefined : codeFilterList;
    const dateFilterList = copyListValues<DataRequirementDateFilterComponent>(this.dateFilter);
    dest.dateFilter = dateFilterList.length === 0 ? undefined : dateFilterList;
    const valueFilterList = copyListValues<DataRequirementValueFilterComponent>(this.valueFilter);
    dest.valueFilter = valueFilterList.length === 0 ? undefined : valueFilterList;
    dest.limit = this.limit?.copy();
    const sortList = copyListValues<DataRequirementSortComponent>(this.sort);
    dest.sort = sortList.length === 0 ? undefined : sortList;
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasTypeElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getTypeElement()!, 'type', jsonObj);
    } else {
      missingReqdProperties.push(\`DataRequirement.type\`);
    }

    if (this.hasProfile()) {
      setFhirPrimitiveListJson(this.getProfileElement(), 'profile', jsonObj);
    }

    if (this.hasSubject()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getSubject()!, 'subject', jsonObj);
    }

    if (this.hasMustSupport()) {
      setFhirPrimitiveListJson(this.getMustSupportElement(), 'mustSupport', jsonObj);
    }

    if (this.hasCodeFilter()) {
      setFhirComplexListJson(this.getCodeFilter(), 'codeFilter', jsonObj);
    }

    if (this.hasDateFilter()) {
      setFhirComplexListJson(this.getDateFilter(), 'dateFilter', jsonObj);
    }

    if (this.hasValueFilter()) {
      setFhirComplexListJson(this.getValueFilter(), 'valueFilter', jsonObj);
    }

    if (this.hasLimitElement()) {
      setFhirPrimitiveJson<fhirPositiveInt>(this.getLimitElement(), 'limit', jsonObj);
    }

    if (this.hasSort()) {
      setFhirComplexListJson(this.getSort(), 'sort', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}


/**
 * DataRequirementCodeFilterComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** What codes are expected
 * - **Definition:** Code filters specify additional constraints on the data, specifying the value set of interest for a particular element of the data. Each code filter defines an additional constraint on the data, i.e. code filters are AND\\'ed, not OR\\'ed.
 *
 * @category DataModel: ComplexType
 * @see [FHIR DataRequirement](http://hl7.org/fhir/StructureDefinition/DataRequirement)
 */
export class DataRequirementCodeFilterComponent extends Element {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`DataRequirementCodeFilterComponent\` JSON to instantiate the DataRequirementCodeFilterComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`DataRequirementCodeFilterComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to DataRequirementCodeFilterComponent
   * @returns DataRequirementCodeFilterComponent data model or undefined for \`DataRequirementCodeFilterComponent\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): DataRequirementCodeFilterComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'DataRequirementCodeFilterComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new DataRequirementCodeFilterComponent();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'path';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setPathElement(datatype);
    }

    fieldName = 'searchParam';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setSearchParamElement(datatype);
    }

    fieldName = 'valueSet';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CanonicalType | undefined = parseCanonicalType(dtJson, dtSiblingJson);
      instance.setValueSetElement(datatype);
    }

    fieldName = 'code';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Coding | undefined = fhirDataTypeParser.parser<Coding>(Coding, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addCode(datatype);
        }
      });
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * DataRequirement.codeFilter.path Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A code-valued attribute to filter on
   * - **Definition:** The code-valued attribute of the filter. The specified path SHALL be a FHIRPath resolvable on the specified type of the DataRequirement, and SHALL consist only of identifiers, constant indexers, and .resolve(). The path is allowed to contain qualifiers (.) to traverse sub-elements, as well as indexers ([x]) to traverse multiple-cardinality sub-elements (see the [Simple FHIRPath Profile](https://hl7.org/fhir/fhirpath.html#simple) for full details). Note that the index must be an integer constant. The path must resolve to an element of type code, Coding, or CodeableConcept.
   * - **Comment:** The path attribute contains a [Simple FHIRPath Subset](https://hl7.org/fhir/fhirpath.html#simple) that allows path traversal, but not calculation.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private path?: StringType | undefined;

  /**
   * DataRequirement.codeFilter.searchParam Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A coded (token) parameter to search on
   * - **Definition:** A token parameter that refers to a search parameter defined on the specified type of the DataRequirement, and which searches on elements of type code, Coding, or CodeableConcept.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private searchParam?: StringType | undefined;

  /**
   * DataRequirement.codeFilter.valueSet Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** ValueSet for the filter
   * - **Definition:** The valueset for the code filter. The valueSet and code elements are additive. If valueSet is specified, the filter will return only those data items for which the value of the code-valued element specified in the path is a member of the specified valueset.
   * - **FHIR Type:** \`canonical\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/ValueSet',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private valueSet?: CanonicalType | undefined;

  /**
   * DataRequirement.codeFilter.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** What code is expected
   * - **Definition:** The codes for the code filter. If values are given, the filter will return only those data items for which the code-valued attribute specified by the path has a value that is one of the specified codes. If codes are specified in addition to a value set, the filter returns items matching a code in the value set or one of the specified codes.
   * - **FHIR Type:** \`Coding\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code?: Coding[] | undefined;


  /**
   * @returns the \`path\` property value as a StringType object if defined; else an empty StringType object
   */
  public getPathElement(): StringType {
    return this.path ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`path\` property.
   *
   * @param element - the \`path\` value
   * @returns this
   */
  public setPathElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid DataRequirement.codeFilter.path; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.path = element;
    } else {
      this.path = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`path\` property exists and has a value; \`false\` otherwise
   */
  public hasPathElement(): boolean {
    return isDefined<StringType>(this.path) && !this.path.isEmpty();
  }

  /**
   * @returns the \`path\` property value as a fhirString if defined; else undefined
   */
  public getPath(): fhirString | undefined {
    return this.path?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`path\` property.
   *
   * @param value - the \`path\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setPath(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid DataRequirement.codeFilter.path (\${String(value)})\`;
      this.path = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.path = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`path\` property exists and has a value; \`false\` otherwise
   */
  public hasPath(): boolean {
    return this.hasPathElement();
  }

  /**
   * @returns the \`searchParam\` property value as a StringType object if defined; else an empty StringType object
   */
  public getSearchParamElement(): StringType {
    return this.searchParam ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`searchParam\` property.
   *
   * @param element - the \`searchParam\` value
   * @returns this
   */
  public setSearchParamElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid DataRequirement.codeFilter.searchParam; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.searchParam = element;
    } else {
      this.searchParam = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`searchParam\` property exists and has a value; \`false\` otherwise
   */
  public hasSearchParamElement(): boolean {
    return isDefined<StringType>(this.searchParam) && !this.searchParam.isEmpty();
  }

  /**
   * @returns the \`searchParam\` property value as a fhirString if defined; else undefined
   */
  public getSearchParam(): fhirString | undefined {
    return this.searchParam?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`searchParam\` property.
   *
   * @param value - the \`searchParam\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setSearchParam(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid DataRequirement.codeFilter.searchParam (\${String(value)})\`;
      this.searchParam = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.searchParam = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`searchParam\` property exists and has a value; \`false\` otherwise
   */
  public hasSearchParam(): boolean {
    return this.hasSearchParamElement();
  }

  /**
   * @returns the \`valueSet\` property value as a CanonicalType object if defined; else an empty CanonicalType object
   */
  public getValueSetElement(): CanonicalType {
    return this.valueSet ?? new CanonicalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`valueSet\` property.
   *
   * @param element - the \`valueSet\` value
   * @returns this
   */
  public setValueSetElement(element: CanonicalType | undefined): this {
    if (isDefined<CanonicalType>(element)) {
      const optErrMsg = \`Invalid DataRequirement.codeFilter.valueSet; Provided element is not an instance of CanonicalType.\`;
      assertFhirType<CanonicalType>(element, CanonicalType, optErrMsg);
      this.valueSet = element;
    } else {
      this.valueSet = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`valueSet\` property exists and has a value; \`false\` otherwise
   */
  public hasValueSetElement(): boolean {
    return isDefined<CanonicalType>(this.valueSet) && !this.valueSet.isEmpty();
  }

  /**
   * @returns the \`valueSet\` property value as a fhirCanonical if defined; else undefined
   */
  public getValueSet(): fhirCanonical | undefined {
    return this.valueSet?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`valueSet\` property.
   *
   * @param value - the \`valueSet\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setValueSet(value: fhirCanonical | undefined): this {
    if (isDefined<fhirCanonical>(value)) {
      const optErrMsg = \`Invalid DataRequirement.codeFilter.valueSet (\${String(value)})\`;
      this.valueSet = new CanonicalType(parseFhirPrimitiveData(value, fhirCanonicalSchema, optErrMsg));
    } else {
      this.valueSet = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`valueSet\` property exists and has a value; \`false\` otherwise
   */
  public hasValueSet(): boolean {
    return this.hasValueSetElement();
  }

  /**
   * @returns the \`code\` property value as a Coding array
   */
  public getCode(): Coding[] {
    return this.code ?? ([] as Coding[]);
  }

  /**
   * Assigns the provided Coding array value to the \`code\` property.
   *
   * @param value - the \`code\` array value
   * @returns this
   */
  public setCode(value: Coding[] | undefined): this {
    if (isDefinedList<Coding>(value)) {
      const optErrMsg = \`Invalid DataRequirement.codeFilter.code; Provided value array has an element that is not an instance of Coding.\`;
      assertFhirTypeList<Coding>(value, Coding, optErrMsg);
      this.code = value;
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * Add the provided Coding value to the \`code\` array property.
   *
   * @param value - the \`code\` value
   * @returns this
   */
  public addCode(value: Coding | undefined): this {
    if (isDefined<Coding>(value)) {
      const optErrMsg = \`Invalid DataRequirement.codeFilter.code; Provided element is not an instance of Coding.\`;
      assertFhirType<Coding>(value, Coding, optErrMsg);
      this.initCode();
      this.code?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`code\` property exists and has a value; \`false\` otherwise
   */
  public hasCode(): boolean {
    return isDefinedList<Coding>(this.code) && this.code.some((item: Coding) => !item.isEmpty());
  }

  /**
   * Initialize the \`code\` property
   */
  private initCode(): void {
    if(!this.hasCode()) {
      this.code = [] as Coding[];
    }
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'DataRequirement.codeFilter';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.path,
      this.searchParam,
      this.valueSet,
      this.code,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): DataRequirementCodeFilterComponent {
    const dest = new DataRequirementCodeFilterComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: DataRequirementCodeFilterComponent): void {
    super.copyValues(dest);
    dest.path = this.path?.copy();
    dest.searchParam = this.searchParam?.copy();
    dest.valueSet = this.valueSet?.copy();
    const codeList = copyListValues<Coding>(this.code);
    dest.code = codeList.length === 0 ? undefined : codeList;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasPathElement()) {
      setFhirPrimitiveJson<fhirString>(this.getPathElement(), 'path', jsonObj);
    }

    if (this.hasSearchParamElement()) {
      setFhirPrimitiveJson<fhirString>(this.getSearchParamElement(), 'searchParam', jsonObj);
    }

    if (this.hasValueSetElement()) {
      setFhirPrimitiveJson<fhirCanonical>(this.getValueSetElement(), 'valueSet', jsonObj);
    }

    if (this.hasCode()) {
      setFhirComplexListJson(this.getCode(), 'code', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * DataRequirementDateFilterComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** What dates/date ranges are expected
 * - **Definition:** Date filters specify additional constraints on the data in terms of the applicable date range for specific elements. Each date filter specifies an additional constraint on the data, i.e. date filters are AND\\'ed, not OR\\'ed.
 *
 * @category DataModel: ComplexType
 * @see [FHIR DataRequirement](http://hl7.org/fhir/StructureDefinition/DataRequirement)
 */
export class DataRequirementDateFilterComponent extends Element {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`DataRequirementDateFilterComponent\` JSON to instantiate the DataRequirementDateFilterComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`DataRequirementDateFilterComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to DataRequirementDateFilterComponent
   * @returns DataRequirementDateFilterComponent data model or undefined for \`DataRequirementDateFilterComponent\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): DataRequirementDateFilterComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'DataRequirementDateFilterComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new DataRequirementDateFilterComponent();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const classMetadata: DecoratorMetadataObject | null = DataRequirementDateFilterComponent[Symbol.metadata];
    const errorMessage = \`DecoratorMetadataObject does not exist for DataRequirementDateFilterComponent\`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    fieldName = 'path';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setPathElement(datatype);
    }

    fieldName = 'searchParam';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setSearchParamElement(datatype);
    }

    fieldName = 'value[x]';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const value: DataType | undefined = fhirDataTypeParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setValue(value);

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * DataRequirement.dateFilter.path Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A date-valued attribute to filter on
   * - **Definition:** The date-valued attribute of the filter. The specified path SHALL be a FHIRPath resolvable on the specified type of the DataRequirement, and SHALL consist only of identifiers, constant indexers, and .resolve(). The path is allowed to contain qualifiers (.) to traverse sub-elements, as well as indexers ([x]) to traverse multiple-cardinality sub-elements (see the [Simple FHIRPath Profile](https://hl7.org/fhir/fhirpath.html#simple) for full details). Note that the index must be an integer constant. The path must resolve to an element of type date, dateTime, Period, Schedule, or Timing.
   * - **Comment:** The path attribute contains a [Simple FHIR Subset](https://hl7.org/fhir/fhirpath.html#simple) that allows path traversal, but not calculation.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private path?: StringType | undefined;

  /**
   * DataRequirement.dateFilter.searchParam Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A date valued parameter to search on
   * - **Definition:** A date parameter that refers to a search parameter defined on the specified type of the DataRequirement, and which searches on elements of type date, dateTime, Period, Schedule, or Timing.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private searchParam?: StringType | undefined;

  /**
   * DataRequirement.dateFilter.value[x] Element
   *
   * @decorator \`@ChoiceDataTypesMeta('DataRequirement.dateFilter.value[x]', ['dateTime','Period','Duration',]\`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The value of the filter, as a Period, DateTime, or Duration value
   * - **Definition:** The value of the filter. If period is specified, the filter will return only those data items that fall within the bounds determined by the Period, inclusive of the period boundaries. If dateTime is specified, the filter will return only those data items that are equal to the specified dateTime. If a Duration is specified, the filter will return only those data items that fall within Duration before now.
   * - **FHIR Types:**
   *     'dateTime',
   *     'Period',
   *     'Duration',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('DataRequirement.dateFilter.value[x]',[
    'dateTime',
    'Period',
    'Duration',
  ])
  private value?: DataType | undefined;


  /**
   * @returns the \`path\` property value as a StringType object if defined; else an empty StringType object
   */
  public getPathElement(): StringType {
    return this.path ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`path\` property.
   *
   * @param element - the \`path\` value
   * @returns this
   */
  public setPathElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid DataRequirement.dateFilter.path; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.path = element;
    } else {
      this.path = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`path\` property exists and has a value; \`false\` otherwise
   */
  public hasPathElement(): boolean {
    return isDefined<StringType>(this.path) && !this.path.isEmpty();
  }

  /**
   * @returns the \`path\` property value as a fhirString if defined; else undefined
   */
  public getPath(): fhirString | undefined {
    return this.path?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`path\` property.
   *
   * @param value - the \`path\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setPath(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid DataRequirement.dateFilter.path (\${String(value)})\`;
      this.path = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.path = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`path\` property exists and has a value; \`false\` otherwise
   */
  public hasPath(): boolean {
    return this.hasPathElement();
  }

  /**
   * @returns the \`searchParam\` property value as a StringType object if defined; else an empty StringType object
   */
  public getSearchParamElement(): StringType {
    return this.searchParam ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`searchParam\` property.
   *
   * @param element - the \`searchParam\` value
   * @returns this
   */
  public setSearchParamElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid DataRequirement.dateFilter.searchParam; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.searchParam = element;
    } else {
      this.searchParam = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`searchParam\` property exists and has a value; \`false\` otherwise
   */
  public hasSearchParamElement(): boolean {
    return isDefined<StringType>(this.searchParam) && !this.searchParam.isEmpty();
  }

  /**
   * @returns the \`searchParam\` property value as a fhirString if defined; else undefined
   */
  public getSearchParam(): fhirString | undefined {
    return this.searchParam?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`searchParam\` property.
   *
   * @param value - the \`searchParam\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setSearchParam(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid DataRequirement.dateFilter.searchParam (\${String(value)})\`;
      this.searchParam = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.searchParam = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`searchParam\` property exists and has a value; \`false\` otherwise
   */
  public hasSearchParam(): boolean {
    return this.hasSearchParamElement();
  }

  /**
   * @returns the \`value\` property value as a DataType object if defined; else undefined
   */
  public getValue(): DataType | undefined {
    return this.value;
  }

  /**
   * Assigns the provided DataType object value to the \`value\` property.
   *
   * @decorator \`@ChoiceDataTypes('DataRequirement.dateFilter.value[x]')\`
   *
   * @param value - the \`value\` object value
   * @returns this
   */
  @ChoiceDataTypes('DataRequirement.dateFilter.value[x]')
  public setValue(value: DataType | undefined): this {
    if (isDefined<DataType>(value)) {
      // assertFhirType<DataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.value = value;
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`value\` property exists and has a value; \`false\` otherwise
   */
  public hasValue(): boolean {
    return isDefined<DataType>(this.value) && !this.value.isEmpty();
  }

  // *** NOTE ***
  // Next "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the \`value\` property value as a DateTimeType object if defined; else undefined
   */
  public getValueDateTimeType(): DateTimeType | undefined {
    if (!isDefined<DataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof DateTimeType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for DataRequirement.dateFilter.value[x]: Expected DateTimeType but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a DateTimeType and has a value; \`false\` otherwise
   */
  public hasValueDateTimeType(): boolean {
    return this.hasValue() && this.value instanceof DateTimeType;
  }

  /**
   * @returns the \`value\` property value as a Period object if defined; else undefined
   */
  public getValuePeriod(): Period | undefined {
    if (!isDefined<DataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Period)) {
      throw new InvalidTypeError(
        \`DataType mismatch for DataRequirement.dateFilter.value[x]: Expected Period but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a Period and has a value; \`false\` otherwise
   */
  public hasValuePeriod(): boolean {
    return this.hasValue() && this.value instanceof Period;
  }

  /**
   * @returns the \`value\` property value as a Duration object if defined; else undefined
   */
  public getValueDuration(): Duration | undefined {
    if (!isDefined<DataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Duration)) {
      throw new InvalidTypeError(
        \`DataType mismatch for DataRequirement.dateFilter.value[x]: Expected Duration but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a Duration and has a value; \`false\` otherwise
   */
  public hasValueDuration(): boolean {
    return this.hasValue() && this.value instanceof Duration;
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'DataRequirement.dateFilter';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.path,
      this.searchParam,
      this.value,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): DataRequirementDateFilterComponent {
    const dest = new DataRequirementDateFilterComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: DataRequirementDateFilterComponent): void {
    super.copyValues(dest);
    dest.path = this.path?.copy();
    dest.searchParam = this.searchParam?.copy();
    dest.value = this.value?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasPathElement()) {
      setFhirPrimitiveJson<fhirString>(this.getPathElement(), 'path', jsonObj);
    }

    if (this.hasSearchParamElement()) {
      setFhirPrimitiveJson<fhirString>(this.getSearchParamElement(), 'searchParam', jsonObj);
    }

    if (this.hasValue()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getValue()!, 'value', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * DataRequirementValueFilterComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** What values are expected
 * - **Definition:** Value filters specify additional constraints on the data for elements other than code-valued or date-valued. Each value filter specifies an additional constraint on the data (i.e. valueFilters are AND\\'ed, not OR\\'ed).
 *
 * @category DataModel: ComplexType
 * @see [FHIR DataRequirement](http://hl7.org/fhir/StructureDefinition/DataRequirement)
 */
export class DataRequirementValueFilterComponent extends Element {
  constructor() {
    super();

    this.searchComparatorEnum = new SearchComparatorEnum();
  }

  /**
   * Parse the provided \`DataRequirementValueFilterComponent\` JSON to instantiate the DataRequirementValueFilterComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`DataRequirementValueFilterComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to DataRequirementValueFilterComponent
   * @returns DataRequirementValueFilterComponent data model or undefined for \`DataRequirementValueFilterComponent\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): DataRequirementValueFilterComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'DataRequirementValueFilterComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new DataRequirementValueFilterComponent();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const classMetadata: DecoratorMetadataObject | null = DataRequirementValueFilterComponent[Symbol.metadata];
    const errorMessage = \`DecoratorMetadataObject does not exist for DataRequirementValueFilterComponent\`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    fieldName = 'path';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setPathElement(datatype);
    }

    fieldName = 'searchParam';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setSearchParamElement(datatype);
    }

    fieldName = 'comparator';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      instance.setComparatorElement(datatype);
    }

    fieldName = 'value[x]';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const value: DataType | undefined = fhirDataTypeParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setValue(value);

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * DataRequirement.valueFilter.path Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** An attribute to filter on
   * - **Definition:** The attribute of the filter. The specified path SHALL be a FHIRPath resolvable on the specified type of the DataRequirement, and SHALL consist only of identifiers, constant indexers, and .resolve(). The path is allowed to contain qualifiers (.) to traverse sub-elements, as well as indexers ([x]) to traverse multiple-cardinality sub-elements (see the [Simple FHIRPath Profile](https://hl7.org/fhir/fhirpath.html#simple) for full details). Note that the index must be an integer constant. The path must resolve to an element of a type that is comparable to the valueFilter.value[x] element for the filter.
   * - **Comment:** The path attribute contains a [Simple FHIR Subset](https://hl7.org/fhir/fhirpath.html#simple) that allows path traversal, but not calculation.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private path?: StringType | undefined;

  /**
   * DataRequirement.valueFilter.searchParam Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A parameter to search on
   * - **Definition:** A search parameter defined on the specified type of the DataRequirement, and which searches on elements of a type compatible with the type of the valueFilter.value[x] for the filter.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private searchParam?: StringType | undefined;

  /**
   * FHIR CodeSystem: SearchComparator
   *
   * @see {@link SearchComparatorEnum }
   */
  private readonly searchComparatorEnum: SearchComparatorEnum;

  /**
   * DataRequirement.valueFilter.comparator Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** eq | gt | lt | ge | le | sa | eb
   * - **Definition:** The comparator to be used to determine whether the value is matching.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private comparator?: EnumCodeType | undefined;

  /**
   * DataRequirement.valueFilter.value[x] Element
   *
   * @decorator \`@ChoiceDataTypesMeta('DataRequirement.valueFilter.value[x]', ['dateTime','Period','Duration',]\`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The value of the filter, as a Period, DateTime, or Duration value
   * - **Definition:** The value of the filter.
   * - **FHIR Types:**
   *     'dateTime',
   *     'Period',
   *     'Duration',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('DataRequirement.valueFilter.value[x]',[
    'dateTime',
    'Period',
    'Duration',
  ])
  private value?: DataType | undefined;


  /**
   * @returns the \`path\` property value as a StringType object if defined; else an empty StringType object
   */
  public getPathElement(): StringType {
    return this.path ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`path\` property.
   *
   * @param element - the \`path\` value
   * @returns this
   */
  public setPathElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid DataRequirement.valueFilter.path; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.path = element;
    } else {
      this.path = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`path\` property exists and has a value; \`false\` otherwise
   */
  public hasPathElement(): boolean {
    return isDefined<StringType>(this.path) && !this.path.isEmpty();
  }

  /**
   * @returns the \`path\` property value as a fhirString if defined; else undefined
   */
  public getPath(): fhirString | undefined {
    return this.path?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`path\` property.
   *
   * @param value - the \`path\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setPath(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid DataRequirement.valueFilter.path (\${String(value)})\`;
      this.path = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.path = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`path\` property exists and has a value; \`false\` otherwise
   */
  public hasPath(): boolean {
    return this.hasPathElement();
  }

  /**
   * @returns the \`searchParam\` property value as a StringType object if defined; else an empty StringType object
   */
  public getSearchParamElement(): StringType {
    return this.searchParam ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`searchParam\` property.
   *
   * @param element - the \`searchParam\` value
   * @returns this
   */
  public setSearchParamElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid DataRequirement.valueFilter.searchParam; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.searchParam = element;
    } else {
      this.searchParam = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`searchParam\` property exists and has a value; \`false\` otherwise
   */
  public hasSearchParamElement(): boolean {
    return isDefined<StringType>(this.searchParam) && !this.searchParam.isEmpty();
  }

  /**
   * @returns the \`searchParam\` property value as a fhirString if defined; else undefined
   */
  public getSearchParam(): fhirString | undefined {
    return this.searchParam?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`searchParam\` property.
   *
   * @param value - the \`searchParam\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setSearchParam(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid DataRequirement.valueFilter.searchParam (\${String(value)})\`;
      this.searchParam = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.searchParam = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`searchParam\` property exists and has a value; \`false\` otherwise
   */
  public hasSearchParam(): boolean {
    return this.hasSearchParamElement();
  }

  /**
   * @returns the \`comparator\` property value as a EnumCodeType if defined; else undefined
   */
  public getComparatorEnumType(): EnumCodeType | undefined {
    return this.comparator;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`comparator\` property.
   *
   * @param enumType - the \`comparator\` value
   * @returns this
   */
  public setComparatorEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid DataRequirement.valueFilter.comparator';
      assertEnumCodeType<SearchComparatorEnum>(enumType, SearchComparatorEnum, errMsgPrefix);
      this.comparator = enumType;
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`comparator\` property exists and has a value; \`false\` otherwise
   */
  public hasComparatorEnumType(): boolean {
    return isDefined<EnumCodeType>(this.comparator) && !this.comparator.isEmpty() && this.comparator.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`comparator\` property value as a CodeType if defined; else undefined
   */
  public getComparatorElement(): CodeType | undefined {
    if (this.comparator === undefined) {
      return undefined;
    }
    return this.comparator as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`comparator\` property.
   *
   * @param element - the \`comparator\` value
   * @returns this
   */
  public setComparatorElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid DataRequirement.valueFilter.comparator; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.comparator = new EnumCodeType(element, this.searchComparatorEnum);
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`comparator\` property exists and has a value; \`false\` otherwise
   */
  public hasComparatorElement(): boolean {
    return this.hasComparatorEnumType();
  }

  /**
   * @returns the \`comparator\` property value as a fhirCode if defined; else undefined
   */
  public getComparator(): fhirCode | undefined {
    if (this.comparator === undefined) {
      return undefined;
    }
    return this.comparator.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`comparator\` property.
   *
   * @param value - the \`comparator\` value
   * @returns this
   */
  public setComparator(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid DataRequirement.valueFilter.comparator; Provided value is not an instance of fhirCode.\`;
      this.comparator = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.searchComparatorEnum);
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`comparator\` property exists and has a value; \`false\` otherwise
   */
  public hasComparator(): boolean {
    return this.hasComparatorEnumType();
  }

  /**
   * @returns the \`value\` property value as a DataType object if defined; else undefined
   */
  public getValue(): DataType | undefined {
    return this.value;
  }

  /**
   * Assigns the provided DataType object value to the \`value\` property.
   *
   * @decorator \`@ChoiceDataTypes('DataRequirement.valueFilter.value[x]')\`
   *
   * @param value - the \`value\` object value
   * @returns this
   */
  @ChoiceDataTypes('DataRequirement.valueFilter.value[x]')
  public setValue(value: DataType | undefined): this {
    if (isDefined<DataType>(value)) {
      // assertFhirType<DataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.value = value;
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`value\` property exists and has a value; \`false\` otherwise
   */
  public hasValue(): boolean {
    return isDefined<DataType>(this.value) && !this.value.isEmpty();
  }

  // *** NOTE ***
  // Next "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the \`value\` property value as a DateTimeType object if defined; else undefined
   */
  public getValueDateTimeType(): DateTimeType | undefined {
    if (!isDefined<DataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof DateTimeType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for DataRequirement.valueFilter.value[x]: Expected DateTimeType but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a DateTimeType and has a value; \`false\` otherwise
   */
  public hasValueDateTimeType(): boolean {
    return this.hasValue() && this.value instanceof DateTimeType;
  }

  /**
   * @returns the \`value\` property value as a Period object if defined; else undefined
   */
  public getValuePeriod(): Period | undefined {
    if (!isDefined<DataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Period)) {
      throw new InvalidTypeError(
        \`DataType mismatch for DataRequirement.valueFilter.value[x]: Expected Period but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a Period and has a value; \`false\` otherwise
   */
  public hasValuePeriod(): boolean {
    return this.hasValue() && this.value instanceof Period;
  }

  /**
   * @returns the \`value\` property value as a Duration object if defined; else undefined
   */
  public getValueDuration(): Duration | undefined {
    if (!isDefined<DataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Duration)) {
      throw new InvalidTypeError(
        \`DataType mismatch for DataRequirement.valueFilter.value[x]: Expected Duration but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a Duration and has a value; \`false\` otherwise
   */
  public hasValueDuration(): boolean {
    return this.hasValue() && this.value instanceof Duration;
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'DataRequirement.valueFilter';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.path,
      this.searchParam,
      this.comparator,
      this.value,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): DataRequirementValueFilterComponent {
    const dest = new DataRequirementValueFilterComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: DataRequirementValueFilterComponent): void {
    super.copyValues(dest);
    dest.path = this.path?.copy();
    dest.searchParam = this.searchParam?.copy();
    dest.comparator = this.comparator?.copy();
    dest.value = this.value?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasPathElement()) {
      setFhirPrimitiveJson<fhirString>(this.getPathElement(), 'path', jsonObj);
    }

    if (this.hasSearchParamElement()) {
      setFhirPrimitiveJson<fhirString>(this.getSearchParamElement(), 'searchParam', jsonObj);
    }

    if (this.hasComparatorElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getComparatorElement()!, 'comparator', jsonObj);
    }

    if (this.hasValue()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getValue()!, 'value', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * DataRequirementSortComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Order of the results
 * - **Definition:** Specifies the order of the results to be returned.
 * - **Comment:** This element can be used in combination with the sort element to specify quota requirements such as "the most recent 5" or "the highest 5". When multiple sorts are specified, they are applied in the order they appear in the resource.
 * - **Requirements:** Enables the requirement "most recent 5 results" to be expressed.
 *
 * @category DataModel: ComplexType
 * @see [FHIR DataRequirement](http://hl7.org/fhir/StructureDefinition/DataRequirement)
 */
export class DataRequirementSortComponent extends Element {
  constructor(path: StringType | fhirString | null = null, direction: EnumCodeType | CodeType | null = null) {
    super();

    this.sortDirectionEnum = new SortDirectionEnum();

    this.path = null;
    if (isDefined<StringType | fhirString>(path)) {
      if (path instanceof PrimitiveType) {
        this.setPathElement(path);
      } else {
        this.setPath(path);
      }
    }

    this.direction = constructorCodeValueAsEnumCodeType<SortDirectionEnum>(
      direction,
      SortDirectionEnum,
      this.sortDirectionEnum,
      '.direction',
    );
  }

  /**
   * Parse the provided \`DataRequirementSortComponent\` JSON to instantiate the DataRequirementSortComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`DataRequirementSortComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to DataRequirementSortComponent
   * @returns DataRequirementSortComponent data model or undefined for \`DataRequirementSortComponent\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): DataRequirementSortComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'DataRequirementSortComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new DataRequirementSortComponent();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'path';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setPathElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'direction';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setDirectionElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * DataRequirement.sort.path Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The name of the attribute to perform the sort
   * - **Definition:** The attribute of the sort. The specified path must be resolvable from the type of the required data. The path is allowed to contain qualifiers (.) to traverse sub-elements, as well as indexers ([x]) to traverse multiple-cardinality sub-elements. Note that the index must be an integer constant.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private path: StringType | null;

  /**
   * FHIR CodeSystem: SortDirection
   *
   * @see {@link SortDirectionEnum }
   */
  private readonly sortDirectionEnum: SortDirectionEnum;

  /**
   * DataRequirement.sort.direction Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** ascending | descending
   * - **Definition:** The direction of the sort, ascending or descending.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private direction: EnumCodeType | null;


  /**
   * @returns the \`path\` property value as a StringType object if defined; else null
   */
  public getPathElement(): StringType | null {
    return this.path;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`path\` property.
   *
   * @param element - the \`path\` value
   * @returns this
   */
  public setPathElement(element: StringType): this {
    assertIsDefined<StringType>(element, \`DataRequirement.sort.path is required\`);
    const optErrMsg = \`Invalid DataRequirement.sort.path; Provided value is not an instance of StringType.\`;
    assertFhirType<StringType>(element, StringType, optErrMsg);
    this.path = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`path\` property exists and has a value; \`false\` otherwise
   */
  public hasPathElement(): boolean {
    return isDefined<StringType>(this.path) && !this.path.isEmpty();
  }

  /**
   * @returns the \`path\` property value as a fhirString if defined; else null
   */
  public getPath(): fhirString | null {
    if (this.path?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.path.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`path\` property.
   *
   * @param value - the \`path\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setPath(value: fhirString): this {
    assertIsDefined<fhirString>(value, \`DataRequirement.sort.path is required\`);
    const optErrMsg = \`Invalid DataRequirement.sort.path (\${String(value)})\`;
    this.path = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`path\` property exists and has a value; \`false\` otherwise
   */
  public hasPath(): boolean {
    return this.hasPathElement();
  }

  /**
   * @returns the \`direction\` property value as a EnumCodeType if defined; else null
   */
  public getDirectionEnumType(): EnumCodeType | null {
    return this.direction;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`direction\` property.
   *
   * @param enumType - the \`direction\` value
   * @returns this
   */
  public setDirectionEnumType(enumType: EnumCodeType): this {
    assertIsDefined<EnumCodeType>(enumType, \`DataRequirement.sort.direction is required\`);
    const errMsgPrefix = \`Invalid DataRequirement.sort.direction\`;
    assertEnumCodeType<SortDirectionEnum>(enumType, SortDirectionEnum, errMsgPrefix);
    this.direction = enumType;
    return this;
  }

  /**
   * @returns \`true\` if the \`direction\` property exists and has a value; \`false\` otherwise
   */
  public hasDirectionEnumType(): boolean {
    return isDefined<EnumCodeType>(this.direction) && !this.direction.isEmpty() && this.direction.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`direction\` property value as a CodeType if defined; else null
   */
  public getDirectionElement(): CodeType | null {
    if (this.direction === null) {
      return null;
    }
    return this.direction as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`direction\` property.
   *
   * @param element - the \`direction\` value
   * @returns this
   */
  public setDirectionElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, \`DataRequirement.sort.direction is required\`);
    const optErrMsg = \`Invalid DataRequirement.sort.direction; Provided value is not an instance of CodeType.\`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.direction = new EnumCodeType(element, this.sortDirectionEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`direction\` property exists and has a value; \`false\` otherwise
   */
  public hasDirectionElement(): boolean {
    return this.hasDirectionEnumType();
  }

  /**
   * @returns the \`direction\` property value as a fhirCode if defined; else null
   */
  public getDirection(): fhirCode | null {
    if (this.direction === null) {
      return null;
    }
    return this.direction.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`direction\` property.
   *
   * @param value - the \`direction\` value
   * @returns this
   */
  public setDirection(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, \`DataRequirement.sort.direction is required\`);
    const optErrMsg = \`Invalid DataRequirement.sort.direction (\${String(value)})\`;
    this.direction = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.sortDirectionEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`direction\` property exists and has a value; \`false\` otherwise
   */
  public hasDirection(): boolean {
    return this.hasDirectionEnumType();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'DataRequirement.sort';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.path,
      this.direction,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): DataRequirementSortComponent {
    const dest = new DataRequirementSortComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: DataRequirementSortComponent): void {
    super.copyValues(dest);
    dest.path = this.path ? this.path.copy() : null;
    dest.direction = this.direction ? this.direction.copy() : null;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasPathElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirString>(this.getPathElement()!, 'path', jsonObj);
    } else {
      missingReqdProperties.push(\`DataRequirement.sort.path\`);
    }

    if (this.hasDirectionElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getDirectionElement()!, 'direction', jsonObj);
    } else {
      missingReqdProperties.push(\`DataRequirement.sort.direction\`);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
",
  "fileExtension": "ts",
  "filename": "DataRequirement",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 37`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * Distance Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/Distance
 * StructureDefinition.name: Distance
 * StructureDefinition.description: Distance Type: A length - a value with a unit that is a physical distance.
 * StructureDefinition.fhirVersion: 5.0.0
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  CodeType,
  DataType,
  DecimalType,
  EnumCodeType,
  FhirDataTypeParser,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  StringType,
  UriType,
  assertEnumCodeType,
  assertFhirType,
  fhirCode,
  fhirCodeSchema,
  fhirDecimal,
  fhirDecimalSchema,
  fhirString,
  fhirStringSchema,
  fhirUri,
  fhirUriSchema,
  getPrimitiveTypeJson,
  isDefined,
  isElementEmpty,
  isEmpty,
  parseCodeType,
  parseDecimalType,
  parseFhirPrimitiveData,
  parseStringType,
  parseUriType,
  setFhirPrimitiveJson,
} from '@paq-ts-fhir/fhir-core';
import {
  PARSABLE_DATATYPE_MAP,
  QuantityComparatorEnum,
} from '../index';

/**
 * Distance Class
 *
 * @remarks
 * Distance Type: A length - a value with a unit that is a physical distance.
 *
 * **FHIR Specification**
 * - **Short:** A length - a value with a unit that is a physical distance
 * - **Definition:** A length - a value with a unit that is a physical distance.
 * - **Comment:** The context of use may frequently define what kind of quantity this is and therefore what kind of units can be used. The context of use may also restrict the values for the comparator.
 * - **FHIR Version:** 5.0.0
 *
 * @category DataModel: ComplexType
 * @see [FHIR Distance](http://hl7.org/fhir/StructureDefinition/Distance)
 */
export class Distance extends DataType implements IBase {
  constructor() {
    super();

    this.quantityComparatorEnum = new QuantityComparatorEnum();
  }

  /**
   * Parse the provided \`Distance\` JSON to instantiate the Distance data model.
   *
   * @param sourceJson - JSON representing FHIR \`Distance\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Distance
   * @returns Distance data model or undefined for \`Distance\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Distance | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Distance';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Distance();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'value';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = parseDecimalType(dtJson, dtSiblingJson);
      instance.setValueElement(datatype);
    }

    fieldName = 'comparator';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      instance.setComparatorElement(datatype);
    }

    fieldName = 'unit';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setUnitElement(datatype);
    }

    fieldName = 'system';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = parseUriType(dtJson, dtSiblingJson);
      instance.setSystemElement(datatype);
    }

    fieldName = 'code';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      instance.setCodeElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Distance.value Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Numerical value (with implicit precision)
   * - **Definition:** The value of the measured amount. The value includes an implicit precision in the presentation of the value.
   * - **Comment:** The implicit precision in the value should always be honored. Monetary values have their own rules for handling precision (refer to standard accounting text books).
   * - **Requirements:** Precision is handled implicitly in almost all cases of measurement.
   * - **FHIR Type:** \`decimal\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private value?: DecimalType | undefined;

  /**
   * FHIR CodeSystem: QuantityComparator
   *
   * @see {@link QuantityComparatorEnum }
   */
  private readonly quantityComparatorEnum: QuantityComparatorEnum;

  /**
   * Distance.comparator Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** < | <= | >= | > | ad - how to understand the value
   * - **Definition:** How the value should be understood and represented - whether the actual value is greater or less than the stated value due to measurement issues; e.g. if the comparator is "<" , then the real value is < stated value.
   * - **Requirements:** Need a framework for handling measures where the value is <5ug/L or >400mg/L due to the limitations of measuring methodology.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** true
   * - **isModifierReason:** This is labeled as &quot;Is Modifier&quot; because the comparator modifies the interpretation of the value significantly. If there is no comparator, then there is no modification of the value
   * - **isSummary:** true
   */
  private comparator?: EnumCodeType | undefined;

  /**
   * Distance.unit Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Unit representation
   * - **Definition:** A human-readable form of the unit.
   * - **Requirements:** There are many representations for units of measure and in many contexts, particular representations are fixed and required. I.e. mcg for micrograms.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private unit?: StringType | undefined;

  /**
   * Distance.system Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** System that defines coded unit form
   * - **Definition:** The identification of the system that provides the coded form of the unit.
   * - **Requirements:** Need to know the system that defines the coded form of the unit.
   * - **FHIR Type:** \`uri\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private system?: UriType | undefined;

  /**
   * Distance.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Coded form of the unit
   * - **Definition:** A computer processable form of the unit in some unit representation system.
   * - **Comment:** The preferred system is UCUM, but SNOMED CT can also be used (for customary units) or ISO 4217 for currency.  The context of use may additionally require a code from a particular system.
   * - **Requirements:** Need a computable form of the unit that is fixed across all forms. UCUM provides this for quantities, but SNOMED CT provides many units of interest.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code?: CodeType | undefined;


  /**
   * @returns the \`value\` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getValueElement(): DecimalType {
    return this.value ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`value\` property.
   *
   * @param element - the \`value\` value
   * @returns this
   */
  public setValueElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = \`Invalid Distance.value; Provided element is not an instance of DecimalType.\`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.value = element;
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`value\` property exists and has a value; \`false\` otherwise
   */
  public hasValueElement(): boolean {
    return isDefined<DecimalType>(this.value) && !this.value.isEmpty();
  }

  /**
   * @returns the \`value\` property value as a fhirDecimal if defined; else undefined
   */
  public getValue(): fhirDecimal | undefined {
    return this.value?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`value\` property.
   *
   * @param value - the \`value\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setValue(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = \`Invalid Distance.value (\${String(value)})\`;
      this.value = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`value\` property exists and has a value; \`false\` otherwise
   */
  public hasValue(): boolean {
    return this.hasValueElement();
  }

  /**
   * @returns the \`comparator\` property value as a EnumCodeType if defined; else undefined
   */
  public getComparatorEnumType(): EnumCodeType | undefined {
    return this.comparator;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`comparator\` property.
   *
   * @param enumType - the \`comparator\` value
   * @returns this
   */
  public setComparatorEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid Distance.comparator';
      assertEnumCodeType<QuantityComparatorEnum>(enumType, QuantityComparatorEnum, errMsgPrefix);
      this.comparator = enumType;
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`comparator\` property exists and has a value; \`false\` otherwise
   */
  public hasComparatorEnumType(): boolean {
    return isDefined<EnumCodeType>(this.comparator) && !this.comparator.isEmpty() && this.comparator.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`comparator\` property value as a CodeType if defined; else undefined
   */
  public getComparatorElement(): CodeType | undefined {
    if (this.comparator === undefined) {
      return undefined;
    }
    return this.comparator as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`comparator\` property.
   *
   * @param element - the \`comparator\` value
   * @returns this
   */
  public setComparatorElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Distance.comparator; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.comparator = new EnumCodeType(element, this.quantityComparatorEnum);
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`comparator\` property exists and has a value; \`false\` otherwise
   */
  public hasComparatorElement(): boolean {
    return this.hasComparatorEnumType();
  }

  /**
   * @returns the \`comparator\` property value as a fhirCode if defined; else undefined
   */
  public getComparator(): fhirCode | undefined {
    if (this.comparator === undefined) {
      return undefined;
    }
    return this.comparator.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`comparator\` property.
   *
   * @param value - the \`comparator\` value
   * @returns this
   */
  public setComparator(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Distance.comparator; Provided value is not an instance of fhirCode.\`;
      this.comparator = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.quantityComparatorEnum);
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`comparator\` property exists and has a value; \`false\` otherwise
   */
  public hasComparator(): boolean {
    return this.hasComparatorEnumType();
  }

  /**
   * @returns the \`unit\` property value as a StringType object if defined; else an empty StringType object
   */
  public getUnitElement(): StringType {
    return this.unit ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`unit\` property.
   *
   * @param element - the \`unit\` value
   * @returns this
   */
  public setUnitElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Distance.unit; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.unit = element;
    } else {
      this.unit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`unit\` property exists and has a value; \`false\` otherwise
   */
  public hasUnitElement(): boolean {
    return isDefined<StringType>(this.unit) && !this.unit.isEmpty();
  }

  /**
   * @returns the \`unit\` property value as a fhirString if defined; else undefined
   */
  public getUnit(): fhirString | undefined {
    return this.unit?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`unit\` property.
   *
   * @param value - the \`unit\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setUnit(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Distance.unit (\${String(value)})\`;
      this.unit = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.unit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`unit\` property exists and has a value; \`false\` otherwise
   */
  public hasUnit(): boolean {
    return this.hasUnitElement();
  }

  /**
   * @returns the \`system\` property value as a UriType object if defined; else an empty UriType object
   */
  public getSystemElement(): UriType {
    return this.system ?? new UriType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`system\` property.
   *
   * @param element - the \`system\` value
   * @returns this
   */
  public setSystemElement(element: UriType | undefined): this {
    if (isDefined<UriType>(element)) {
      const optErrMsg = \`Invalid Distance.system; Provided element is not an instance of UriType.\`;
      assertFhirType<UriType>(element, UriType, optErrMsg);
      this.system = element;
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`system\` property exists and has a value; \`false\` otherwise
   */
  public hasSystemElement(): boolean {
    return isDefined<UriType>(this.system) && !this.system.isEmpty();
  }

  /**
   * @returns the \`system\` property value as a fhirUri if defined; else undefined
   */
  public getSystem(): fhirUri | undefined {
    return this.system?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`system\` property.
   *
   * @param value - the \`system\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setSystem(value: fhirUri | undefined): this {
    if (isDefined<fhirUri>(value)) {
      const optErrMsg = \`Invalid Distance.system (\${String(value)})\`;
      this.system = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`system\` property exists and has a value; \`false\` otherwise
   */
  public hasSystem(): boolean {
    return this.hasSystemElement();
  }

  /**
   * @returns the \`code\` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getCodeElement(): CodeType {
    return this.code ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`code\` property.
   *
   * @param element - the \`code\` value
   * @returns this
   */
  public setCodeElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Distance.code; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.code = element;
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`code\` property exists and has a value; \`false\` otherwise
   */
  public hasCodeElement(): boolean {
    return isDefined<CodeType>(this.code) && !this.code.isEmpty();
  }

  /**
   * @returns the \`code\` property value as a fhirCode if defined; else undefined
   */
  public getCode(): fhirCode | undefined {
    return this.code?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`code\` property.
   *
   * @param value - the \`code\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setCode(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Distance.code (\${String(value)})\`;
      this.code = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`code\` property exists and has a value; \`false\` otherwise
   */
  public hasCode(): boolean {
    return this.hasCodeElement();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Distance';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.value,
      this.comparator,
      this.unit,
      this.system,
      this.code,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Distance {
    const dest = new Distance();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Distance): void {
    super.copyValues(dest);
    dest.value = this.value?.copy();
    dest.comparator = this.comparator?.copy();
    dest.unit = this.unit?.copy();
    dest.system = this.system?.copy();
    dest.code = this.code?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasValueElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getValueElement(), 'value', jsonObj);
    }

    if (this.hasComparatorElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getComparatorElement()!, 'comparator', jsonObj);
    }

    if (this.hasUnitElement()) {
      setFhirPrimitiveJson<fhirString>(this.getUnitElement(), 'unit', jsonObj);
    }

    if (this.hasSystemElement()) {
      setFhirPrimitiveJson<fhirUri>(this.getSystemElement(), 'system', jsonObj);
    }

    if (this.hasCodeElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getCodeElement(), 'code', jsonObj);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "Distance",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 38`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * Dosage Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/Dosage
 * StructureDefinition.name: Dosage
 * StructureDefinition.description: Base StructureDefinition for Dosage Type: Indicates how the medication is/was taken or should be taken by the patient.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  BackboneType,
  BooleanType,
  ChoiceDataTypes,
  ChoiceDataTypesMeta,
  DataType,
  Element,
  FhirDataTypeParser,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  IntegerType,
  InvalidTypeError,
  JSON,
  StringType,
  assertFhirType,
  assertFhirTypeList,
  assertIsDefined,
  copyListValues,
  fhirInteger,
  fhirIntegerSchema,
  fhirString,
  fhirStringSchema,
  getPrimitiveTypeJson,
  isDefined,
  isDefinedList,
  isElementEmpty,
  isEmpty,
  parseFhirPrimitiveData,
  parseIntegerType,
  parseStringType,
  setFhirComplexJson,
  setFhirComplexListJson,
  setFhirPrimitiveJson,
  setPolymorphicValueJson,
} from '@paq-ts-fhir/fhir-core';
import {
  CodeableConcept,
  PARSABLE_DATATYPE_MAP,
  Quantity,
  Range,
  Ratio,
  Timing,
} from '../index';

// eslint-disable-next-line @typescript-eslint/no-explicit-any -- Symbol.metadata polyfill secret sauce for decorator metadata
(Symbol.metadata as any) ??= Symbol('Symbol.metadata');

/**
 * Dosage Class
 *
 * @remarks
 * Base StructureDefinition for Dosage Type: Indicates how the medication is/was taken or should be taken by the patient.
 *
 * **FHIR Specification**
 * - **Short:** How the medication is/was taken or should be taken
 * - **Definition:** Indicates how the medication is/was taken or should be taken by the patient.
 * - **FHIR Version:** 4.0.1
 *
 * @category DataModel: ComplexType
 * @see [FHIR Dosage](http://hl7.org/fhir/StructureDefinition/Dosage)
 */
export class Dosage extends BackboneType implements IBase {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`Dosage\` JSON to instantiate the Dosage data model.
   *
   * @param sourceJson - JSON representing FHIR \`Dosage\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Dosage
   * @returns Dosage data model or undefined for \`Dosage\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Dosage | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Dosage';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Dosage();
    fhirDataTypeParser.processBackboneTypeJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const classMetadata: DecoratorMetadataObject | null = Dosage[Symbol.metadata];
    const errorMessage = \`DecoratorMetadataObject does not exist for Dosage\`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    fieldName = 'sequence';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: IntegerType | undefined = parseIntegerType(dtJson, dtSiblingJson);
      instance.setSequenceElement(datatype);
    }

    fieldName = 'text';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setTextElement(datatype);
    }

    fieldName = 'additionalInstruction';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: CodeableConcept | undefined = fhirDataTypeParser.parser<CodeableConcept>(CodeableConcept, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addAdditionalInstruction(datatype);
        }
      });
    }

    fieldName = 'patientInstruction';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setPatientInstructionElement(datatype);
    }

    fieldName = 'timing';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Timing | undefined = fhirDataTypeParser.parser<Timing>(Timing, classJsonObj[fieldName]!, sourceField);
      instance.setTiming(datatype);
    }

    fieldName = 'asNeeded[x]';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const asNeeded: DataType | undefined = fhirDataTypeParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setAsNeeded(asNeeded);

    fieldName = 'site';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = fhirDataTypeParser.parser<CodeableConcept>(CodeableConcept, classJsonObj[fieldName]!, sourceField);
      instance.setSite(datatype);
    }

    fieldName = 'route';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = fhirDataTypeParser.parser<CodeableConcept>(CodeableConcept, classJsonObj[fieldName]!, sourceField);
      instance.setRoute(datatype);
    }

    fieldName = 'method';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = fhirDataTypeParser.parser<CodeableConcept>(CodeableConcept, classJsonObj[fieldName]!, sourceField);
      instance.setMethod(datatype);
    }

    fieldName = 'doseAndRate';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: DosageDoseAndRateComponent | undefined = fhirDataTypeParser.parser<DosageDoseAndRateComponent>(DosageDoseAndRateComponent, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addDoseAndRate(datatype);
        }
      });
    }

    fieldName = 'maxDosePerPeriod';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Ratio | undefined = fhirDataTypeParser.parser<Ratio>(Ratio, classJsonObj[fieldName]!, sourceField);
      instance.setMaxDosePerPeriod(datatype);
    }

    fieldName = 'maxDosePerAdministration';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = fhirDataTypeParser.parser<Quantity>(Quantity, classJsonObj[fieldName]!, sourceField);
      instance.setMaxDosePerAdministration(datatype);
    }

    fieldName = 'maxDosePerLifetime';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = fhirDataTypeParser.parser<Quantity>(Quantity, classJsonObj[fieldName]!, sourceField);
      instance.setMaxDosePerLifetime(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Dosage.sequence Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The order of the dosage instructions
   * - **Definition:** Indicates the order in which the dosage instructions should be applied or interpreted.
   * - **Requirements:** If the sequence number of multiple Dosages is the same, then it is implied that the instructions are to be treated as concurrent.  If the sequence number is different, then the Dosages are intended to be sequential.
   * - **FHIR Type:** \`integer\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private sequence?: IntegerType | undefined;

  /**
   * Dosage.text Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Free text dosage instructions e.g. SIG
   * - **Definition:** Free text dosage instructions e.g. SIG.
   * - **Requirements:** Free text dosage instructions can be used for cases where the instructions are too complex to code.  The content of this attribute does not include the name or description of the medication. When coded instructions are present, the free text instructions may still be present for display to humans taking or administering the medication. It is expected that the text instructions will always be populated.  If the dosage.timing attribute is also populated, then the dosage.text should reflect the same information as the timing.  Additional information about administration or preparation of the medication should be included as text.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private text?: StringType | undefined;

  /**
   * Dosage.additionalInstruction Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Supplemental instruction or warnings to the patient - e.g. "with meals", "may cause drowsiness"
   * - **Definition:** Supplemental instructions to the patient on how to take the medication  (e.g. "with meals" or"take half to one hour before food") or warnings for the patient about the medication (e.g. "may cause drowsiness" or "avoid exposure of skin to direct sunlight or sunlamps").
   * - **Comment:** Information about administration or preparation of the medication (e.g. "infuse as rapidly as possibly via intraperitoneal port" or "immediately following drug x") should be populated in dosage.text.
   * - **Requirements:** Additional instruction is intended to be coded, but where no code exists, the element could include text.  For example, "Swallow with plenty of water" which might or might not be coded.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private additionalInstruction?: CodeableConcept[] | undefined;

  /**
   * Dosage.patientInstruction Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Patient or consumer oriented instructions
   * - **Definition:** Instructions in terms that are understood by the patient or consumer.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private patientInstruction?: StringType | undefined;

  /**
   * Dosage.timing Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** When medication should be administered
   * - **Definition:** When medication should be administered.
   * - **Comment:** This attribute might not always be populated while the Dosage.text is expected to be populated.  If both are populated, then the Dosage.text should reflect the content of the Dosage.timing.
   * - **Requirements:** The timing schedule for giving the medication to the patient. This  data type allows many different expressions. For example: "Every 8 hours"; "Three times a day"; "1/2 an hour before breakfast for 10 days from 23-Dec 2011:"; "15 Oct 2013, 17 Oct 2013 and 1 Nov 2013".  Sometimes, a rate can imply duration when expressed as total volume / duration (e.g.  500mL/2 hours implies a duration of 2 hours).  However, when rate doesn\\'t imply duration (e.g. 250mL/hour), then the timing.repeat.duration is needed to convey the infuse over time period.
   * - **FHIR Type:** \`Timing\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private timing?: Timing | undefined;

  /**
   * Dosage.asNeeded[x] Element
   *
   * @decorator \`@ChoiceDataTypesMeta('Dosage.asNeeded[x]', ['boolean','CodeableConcept',]\`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Take "as needed" (for x)
   * - **Definition:** Indicates whether the Medication is only taken when needed within a specific dosing schedule (Boolean option), or it indicates the precondition for taking the Medication (CodeableConcept).
   * - **Comment:** Can express "as needed" without a reason by setting the Boolean = True.  In this case the CodeableConcept is not populated.  Or you can express "as needed" with a reason by including the CodeableConcept.  In this case the Boolean is assumed to be True.  If you set the Boolean to False, then the dose is given according to the schedule and is not "prn" or "as needed".
   * - **FHIR Types:**
   *     'boolean',
   *     'CodeableConcept',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('Dosage.asNeeded[x]',[
    'boolean',
    'CodeableConcept',
  ])
  private asNeeded?: DataType | undefined;

  /**
   * Dosage.site Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Body site to administer to
   * - **Definition:** Body site to administer to.
   * - **Comment:** If the use case requires attributes from the BodySite resource (e.g. to identify and track separately) then use the standard extension [bodySite](https://hl7.org/fhir/extension-bodysite.html).  May be a summary code, or a reference to a very precise definition of the location, or both.
   * - **Requirements:** A coded specification of the anatomic site where the medication first enters the body.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private site?: CodeableConcept | undefined;

  /**
   * Dosage.route Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** How drug should enter body
   * - **Definition:** How drug should enter body.
   * - **Requirements:** A code specifying the route or physiological path of administration of a therapeutic agent into or onto a patient\\'s body.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private route?: CodeableConcept | undefined;

  /**
   * Dosage.method Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Technique for administering medication
   * - **Definition:** Technique for administering medication.
   * - **Comment:** Terminologies used often pre-coordinate this term with the route and or form of administration.
   * - **Requirements:** A coded value indicating the method by which the medication is introduced into or onto the body. Most commonly used for injections.  For examples, Slow Push; Deep IV.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private method?: CodeableConcept | undefined;

  /**
   * Dosage.doseAndRate Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Amount of medication administered
   * - **Definition:** The amount of medication administered.
   * - **FHIR Type:** \`Element\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private doseAndRate?: DosageDoseAndRateComponent[] | undefined;

  /**
   * Dosage.maxDosePerPeriod Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Upper limit on medication per unit of time
   * - **Definition:** Upper limit on medication per unit of time.
   * - **Comment:** This is intended for use as an adjunct to the dosage when there is an upper cap.  For example "2 tablets every 4 hours to a maximum of 8/day".
   * - **Requirements:** The maximum total quantity of a therapeutic substance that may be administered to a subject over the period of time.  For example, 1000mg in 24 hours.
   * - **FHIR Type:** \`Ratio\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private maxDosePerPeriod?: Ratio | undefined;

  /**
   * Dosage.maxDosePerAdministration Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Upper limit on medication per administration
   * - **Definition:** Upper limit on medication per administration.
   * - **Comment:** This is intended for use as an adjunct to the dosage when there is an upper cap.  For example, a body surface area related dose with a maximum amount, such as 1.5 mg/m2 (maximum 2 mg) IV over 5 - 10 minutes would have doseQuantity of 1.5 mg/m2 and maxDosePerAdministration of 2 mg.
   * - **Requirements:** The maximum total quantity of a therapeutic substance that may be administered to a subject per administration.
   * - **FHIR Type:** \`Quantity\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private maxDosePerAdministration?: Quantity | undefined;

  /**
   * Dosage.maxDosePerLifetime Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Upper limit on medication per lifetime of the patient
   * - **Definition:** Upper limit on medication per lifetime of the patient.
   * - **Requirements:** The maximum total quantity of a therapeutic substance that may be administered per lifetime of the subject.
   * - **FHIR Type:** \`Quantity\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private maxDosePerLifetime?: Quantity | undefined;


  /**
   * @returns the \`sequence\` property value as a IntegerType object if defined; else an empty IntegerType object
   */
  public getSequenceElement(): IntegerType {
    return this.sequence ?? new IntegerType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`sequence\` property.
   *
   * @param element - the \`sequence\` value
   * @returns this
   */
  public setSequenceElement(element: IntegerType | undefined): this {
    if (isDefined<IntegerType>(element)) {
      const optErrMsg = \`Invalid Dosage.sequence; Provided element is not an instance of IntegerType.\`;
      assertFhirType<IntegerType>(element, IntegerType, optErrMsg);
      this.sequence = element;
    } else {
      this.sequence = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`sequence\` property exists and has a value; \`false\` otherwise
   */
  public hasSequenceElement(): boolean {
    return isDefined<IntegerType>(this.sequence) && !this.sequence.isEmpty();
  }

  /**
   * @returns the \`sequence\` property value as a fhirInteger if defined; else undefined
   */
  public getSequence(): fhirInteger | undefined {
    return this.sequence?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`sequence\` property.
   *
   * @param value - the \`sequence\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setSequence(value: fhirInteger | undefined): this {
    if (isDefined<fhirInteger>(value)) {
      const optErrMsg = \`Invalid Dosage.sequence (\${String(value)})\`;
      this.sequence = new IntegerType(parseFhirPrimitiveData(value, fhirIntegerSchema, optErrMsg));
    } else {
      this.sequence = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`sequence\` property exists and has a value; \`false\` otherwise
   */
  public hasSequence(): boolean {
    return this.hasSequenceElement();
  }

  /**
   * @returns the \`text\` property value as a StringType object if defined; else an empty StringType object
   */
  public getTextElement(): StringType {
    return this.text ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`text\` property.
   *
   * @param element - the \`text\` value
   * @returns this
   */
  public setTextElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Dosage.text; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.text = element;
    } else {
      this.text = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`text\` property exists and has a value; \`false\` otherwise
   */
  public hasTextElement(): boolean {
    return isDefined<StringType>(this.text) && !this.text.isEmpty();
  }

  /**
   * @returns the \`text\` property value as a fhirString if defined; else undefined
   */
  public getText(): fhirString | undefined {
    return this.text?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`text\` property.
   *
   * @param value - the \`text\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setText(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Dosage.text (\${String(value)})\`;
      this.text = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.text = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`text\` property exists and has a value; \`false\` otherwise
   */
  public hasText(): boolean {
    return this.hasTextElement();
  }

  /**
   * @returns the \`additionalInstruction\` property value as a CodeableConcept array
   */
  public getAdditionalInstruction(): CodeableConcept[] {
    return this.additionalInstruction ?? ([] as CodeableConcept[]);
  }

  /**
   * Assigns the provided CodeableConcept array value to the \`additionalInstruction\` property.
   *
   * @param value - the \`additionalInstruction\` array value
   * @returns this
   */
  public setAdditionalInstruction(value: CodeableConcept[] | undefined): this {
    if (isDefinedList<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Dosage.additionalInstruction; Provided value array has an element that is not an instance of CodeableConcept.\`;
      assertFhirTypeList<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.additionalInstruction = value;
    } else {
      this.additionalInstruction = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeableConcept value to the \`additionalInstruction\` array property.
   *
   * @param value - the \`additionalInstruction\` value
   * @returns this
   */
  public addAdditionalInstruction(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Dosage.additionalInstruction; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.initAdditionalInstruction();
      this.additionalInstruction?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`additionalInstruction\` property exists and has a value; \`false\` otherwise
   */
  public hasAdditionalInstruction(): boolean {
    return isDefinedList<CodeableConcept>(this.additionalInstruction) && this.additionalInstruction.some((item: CodeableConcept) => !item.isEmpty());
  }

  /**
   * Initialize the \`additionalInstruction\` property
   */
  private initAdditionalInstruction(): void {
    if(!this.hasAdditionalInstruction()) {
      this.additionalInstruction = [] as CodeableConcept[];
    }
  }

  /**
   * @returns the \`patientInstruction\` property value as a StringType object if defined; else an empty StringType object
   */
  public getPatientInstructionElement(): StringType {
    return this.patientInstruction ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`patientInstruction\` property.
   *
   * @param element - the \`patientInstruction\` value
   * @returns this
   */
  public setPatientInstructionElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Dosage.patientInstruction; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.patientInstruction = element;
    } else {
      this.patientInstruction = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`patientInstruction\` property exists and has a value; \`false\` otherwise
   */
  public hasPatientInstructionElement(): boolean {
    return isDefined<StringType>(this.patientInstruction) && !this.patientInstruction.isEmpty();
  }

  /**
   * @returns the \`patientInstruction\` property value as a fhirString if defined; else undefined
   */
  public getPatientInstruction(): fhirString | undefined {
    return this.patientInstruction?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`patientInstruction\` property.
   *
   * @param value - the \`patientInstruction\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setPatientInstruction(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Dosage.patientInstruction (\${String(value)})\`;
      this.patientInstruction = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.patientInstruction = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`patientInstruction\` property exists and has a value; \`false\` otherwise
   */
  public hasPatientInstruction(): boolean {
    return this.hasPatientInstructionElement();
  }

  /**
   * @returns the \`timing\` property value as a Timing object if defined; else an empty Timing object
   */
  public getTiming(): Timing {
    return this.timing ?? new Timing();
  }

  /**
   * Assigns the provided Timing object value to the \`timing\` property.
   *
   * @param value - the \`timing\` object value
   * @returns this
   */
  public setTiming(value: Timing | undefined): this {
    if (isDefined<Timing>(value)) {
      const optErrMsg = \`Invalid Dosage.timing; Provided element is not an instance of Timing.\`;
      assertFhirType<Timing>(value, Timing, optErrMsg);
      this.timing = value;
    } else {
      this.timing = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`timing\` property exists and has a value; \`false\` otherwise
   */
  public hasTiming(): boolean {
    return isDefined<Timing>(this.timing) && !this.timing.isEmpty();
  }

  /**
   * @returns the \`asNeeded\` property value as a DataType object if defined; else undefined
   */
  public getAsNeeded(): DataType | undefined {
    return this.asNeeded;
  }

  /**
   * Assigns the provided DataType object value to the \`asNeeded\` property.
   *
   * @decorator \`@ChoiceDataTypes('Dosage.asNeeded[x]')\`
   *
   * @param value - the \`asNeeded\` object value
   * @returns this
   */
  @ChoiceDataTypes('Dosage.asNeeded[x]')
  public setAsNeeded(value: DataType | undefined): this {
    if (isDefined<DataType>(value)) {
      // assertFhirType<DataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.asNeeded = value;
    } else {
      this.asNeeded = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`asNeeded\` property exists and has a value; \`false\` otherwise
   */
  public hasAsNeeded(): boolean {
    return isDefined<DataType>(this.asNeeded) && !this.asNeeded.isEmpty();
  }

  // *** NOTE ***
  // Next "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the \`asNeeded\` property value as a BooleanType object if defined; else undefined
   */
  public getAsNeededBooleanType(): BooleanType | undefined {
    if (!isDefined<DataType | undefined>(this.asNeeded)) {
      return undefined;
    }
    if (!(this.asNeeded instanceof BooleanType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Dosage.asNeeded[x]: Expected BooleanType but encountered \${this.asNeeded.fhirType()}\`,
      );
    }
    return this.asNeeded;
  }

  /**
   * @returns \`true\` if the \`asNeeded\` property exists as a BooleanType and has a value; \`false\` otherwise
   */
  public hasAsNeededBooleanType(): boolean {
    return this.hasAsNeeded() && this.asNeeded instanceof BooleanType;
  }

  /**
   * @returns the \`asNeeded\` property value as a CodeableConcept object if defined; else undefined
   */
  public getAsNeededCodeableConcept(): CodeableConcept | undefined {
    if (!isDefined<DataType | undefined>(this.asNeeded)) {
      return undefined;
    }
    if (!(this.asNeeded instanceof CodeableConcept)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Dosage.asNeeded[x]: Expected CodeableConcept but encountered \${this.asNeeded.fhirType()}\`,
      );
    }
    return this.asNeeded;
  }

  /**
   * @returns \`true\` if the \`asNeeded\` property exists as a CodeableConcept and has a value; \`false\` otherwise
   */
  public hasAsNeededCodeableConcept(): boolean {
    return this.hasAsNeeded() && this.asNeeded instanceof CodeableConcept;
  }

  /**
   * @returns the \`site\` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getSite(): CodeableConcept {
    return this.site ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Site object value to the \`site\` property.
   *
   * @param value - the \`site\` object value
   * @returns this
   */
  public setSite(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Dosage.site; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.site = value;
    } else {
      this.site = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`site\` property exists and has a value; \`false\` otherwise
   */
  public hasSite(): boolean {
    return isDefined<CodeableConcept>(this.site) && !this.site.isEmpty();
  }

  /**
   * @returns the \`route\` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getRoute(): CodeableConcept {
    return this.route ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Route object value to the \`route\` property.
   *
   * @param value - the \`route\` object value
   * @returns this
   */
  public setRoute(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Dosage.route; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.route = value;
    } else {
      this.route = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`route\` property exists and has a value; \`false\` otherwise
   */
  public hasRoute(): boolean {
    return isDefined<CodeableConcept>(this.route) && !this.route.isEmpty();
  }

  /**
   * @returns the \`method\` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getMethod(): CodeableConcept {
    return this.method ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Method object value to the \`method\` property.
   *
   * @param value - the \`method\` object value
   * @returns this
   */
  public setMethod(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Dosage.method; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.method = value;
    } else {
      this.method = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`method\` property exists and has a value; \`false\` otherwise
   */
  public hasMethod(): boolean {
    return isDefined<CodeableConcept>(this.method) && !this.method.isEmpty();
  }

  /**
   * @returns the \`doseAndRate\` property value as a DosageDoseAndRateComponent array
   */
  public getDoseAndRate(): DosageDoseAndRateComponent[] {
    return this.doseAndRate ?? ([] as DosageDoseAndRateComponent[]);
  }

  /**
   * Assigns the provided DosageDoseAndRateComponent array value to the \`doseAndRate\` property.
   *
   * @param value - the \`doseAndRate\` array value
   * @returns this
   */
  public setDoseAndRate(value: DosageDoseAndRateComponent[] | undefined): this {
    if (isDefinedList<DosageDoseAndRateComponent>(value)) {
      const optErrMsg = \`Invalid Dosage.doseAndRate; Provided value array has an element that is not an instance of DosageDoseAndRateComponent.\`;
      assertFhirTypeList<DosageDoseAndRateComponent>(value, DosageDoseAndRateComponent, optErrMsg);
      this.doseAndRate = value;
    } else {
      this.doseAndRate = undefined;
    }
    return this;
  }

  /**
   * Add the provided DosageDoseAndRateComponent value to the \`doseAndRate\` array property.
   *
   * @param value - the \`doseAndRate\` value
   * @returns this
   */
  public addDoseAndRate(value: DosageDoseAndRateComponent | undefined): this {
    if (isDefined<DosageDoseAndRateComponent>(value)) {
      const optErrMsg = \`Invalid Dosage.doseAndRate; Provided element is not an instance of DosageDoseAndRateComponent.\`;
      assertFhirType<DosageDoseAndRateComponent>(value, DosageDoseAndRateComponent, optErrMsg);
      this.initDoseAndRate();
      this.doseAndRate?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`doseAndRate\` property exists and has a value; \`false\` otherwise
   */
  public hasDoseAndRate(): boolean {
    return isDefinedList<DosageDoseAndRateComponent>(this.doseAndRate) && this.doseAndRate.some((item: DosageDoseAndRateComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`doseAndRate\` property
   */
  private initDoseAndRate(): void {
    if(!this.hasDoseAndRate()) {
      this.doseAndRate = [] as DosageDoseAndRateComponent[];
    }
  }

  /**
   * @returns the \`maxDosePerPeriod\` property value as a Ratio object if defined; else an empty Ratio object
   */
  public getMaxDosePerPeriod(): Ratio {
    return this.maxDosePerPeriod ?? new Ratio();
  }

  /**
   * Assigns the provided MaxDosePerPeriod object value to the \`maxDosePerPeriod\` property.
   *
   * @param value - the \`maxDosePerPeriod\` object value
   * @returns this
   */
  public setMaxDosePerPeriod(value: Ratio | undefined): this {
    if (isDefined<Ratio>(value)) {
      const optErrMsg = \`Invalid Dosage.maxDosePerPeriod; Provided element is not an instance of Ratio.\`;
      assertFhirType<Ratio>(value, Ratio, optErrMsg);
      this.maxDosePerPeriod = value;
    } else {
      this.maxDosePerPeriod = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`maxDosePerPeriod\` property exists and has a value; \`false\` otherwise
   */
  public hasMaxDosePerPeriod(): boolean {
    return isDefined<Ratio>(this.maxDosePerPeriod) && !this.maxDosePerPeriod.isEmpty();
  }

  /**
   * @returns the \`maxDosePerAdministration\` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getMaxDosePerAdministration(): Quantity {
    return this.maxDosePerAdministration ?? new Quantity();
  }

  /**
   * Assigns the provided MaxDosePerAdministration object value to the \`maxDosePerAdministration\` property.
   *
   * @param value - the \`maxDosePerAdministration\` object value
   * @returns this
   */
  public setMaxDosePerAdministration(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = \`Invalid Dosage.maxDosePerAdministration; Provided element is not an instance of Quantity.\`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.maxDosePerAdministration = value;
    } else {
      this.maxDosePerAdministration = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`maxDosePerAdministration\` property exists and has a value; \`false\` otherwise
   */
  public hasMaxDosePerAdministration(): boolean {
    return isDefined<Quantity>(this.maxDosePerAdministration) && !this.maxDosePerAdministration.isEmpty();
  }

  /**
   * @returns the \`maxDosePerLifetime\` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getMaxDosePerLifetime(): Quantity {
    return this.maxDosePerLifetime ?? new Quantity();
  }

  /**
   * Assigns the provided MaxDosePerLifetime object value to the \`maxDosePerLifetime\` property.
   *
   * @param value - the \`maxDosePerLifetime\` object value
   * @returns this
   */
  public setMaxDosePerLifetime(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = \`Invalid Dosage.maxDosePerLifetime; Provided element is not an instance of Quantity.\`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.maxDosePerLifetime = value;
    } else {
      this.maxDosePerLifetime = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`maxDosePerLifetime\` property exists and has a value; \`false\` otherwise
   */
  public hasMaxDosePerLifetime(): boolean {
    return isDefined<Quantity>(this.maxDosePerLifetime) && !this.maxDosePerLifetime.isEmpty();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Dosage';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.sequence,
      this.text,
      this.additionalInstruction,
      this.patientInstruction,
      this.timing,
      this.asNeeded,
      this.site,
      this.route,
      this.method,
      this.doseAndRate,
      this.maxDosePerPeriod,
      this.maxDosePerAdministration,
      this.maxDosePerLifetime,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Dosage {
    const dest = new Dosage();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Dosage): void {
    super.copyValues(dest);
    dest.sequence = this.sequence?.copy();
    dest.text = this.text?.copy();
    const additionalInstructionList = copyListValues<CodeableConcept>(this.additionalInstruction);
    dest.additionalInstruction = additionalInstructionList.length === 0 ? undefined : additionalInstructionList;
    dest.patientInstruction = this.patientInstruction?.copy();
    dest.timing = this.timing?.copy();
    dest.asNeeded = this.asNeeded?.copy();
    dest.site = this.site?.copy();
    dest.route = this.route?.copy();
    dest.method = this.method?.copy();
    const doseAndRateList = copyListValues<DosageDoseAndRateComponent>(this.doseAndRate);
    dest.doseAndRate = doseAndRateList.length === 0 ? undefined : doseAndRateList;
    dest.maxDosePerPeriod = this.maxDosePerPeriod?.copy();
    dest.maxDosePerAdministration = this.maxDosePerAdministration?.copy();
    dest.maxDosePerLifetime = this.maxDosePerLifetime?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasSequenceElement()) {
      setFhirPrimitiveJson<fhirInteger>(this.getSequenceElement(), 'sequence', jsonObj);
    }

    if (this.hasTextElement()) {
      setFhirPrimitiveJson<fhirString>(this.getTextElement(), 'text', jsonObj);
    }

    if (this.hasAdditionalInstruction()) {
      setFhirComplexListJson(this.getAdditionalInstruction(), 'additionalInstruction', jsonObj);
    }

    if (this.hasPatientInstructionElement()) {
      setFhirPrimitiveJson<fhirString>(this.getPatientInstructionElement(), 'patientInstruction', jsonObj);
    }

    if (this.hasTiming()) {
      setFhirComplexJson(this.getTiming(), 'timing', jsonObj);
    }

    if (this.hasAsNeeded()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getAsNeeded()!, 'asNeeded', jsonObj);
    }

    if (this.hasSite()) {
      setFhirComplexJson(this.getSite(), 'site', jsonObj);
    }

    if (this.hasRoute()) {
      setFhirComplexJson(this.getRoute(), 'route', jsonObj);
    }

    if (this.hasMethod()) {
      setFhirComplexJson(this.getMethod(), 'method', jsonObj);
    }

    if (this.hasDoseAndRate()) {
      setFhirComplexListJson(this.getDoseAndRate(), 'doseAndRate', jsonObj);
    }

    if (this.hasMaxDosePerPeriod()) {
      setFhirComplexJson(this.getMaxDosePerPeriod(), 'maxDosePerPeriod', jsonObj);
    }

    if (this.hasMaxDosePerAdministration()) {
      setFhirComplexJson(this.getMaxDosePerAdministration(), 'maxDosePerAdministration', jsonObj);
    }

    if (this.hasMaxDosePerLifetime()) {
      setFhirComplexJson(this.getMaxDosePerLifetime(), 'maxDosePerLifetime', jsonObj);
    }

    return jsonObj;
  }
}


/**
 * DosageDoseAndRateComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Amount of medication administered
 * - **Definition:** The amount of medication administered.
 *
 * @category DataModel: ComplexType
 * @see [FHIR Dosage](http://hl7.org/fhir/StructureDefinition/Dosage)
 */
export class DosageDoseAndRateComponent extends Element {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`DosageDoseAndRateComponent\` JSON to instantiate the DosageDoseAndRateComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`DosageDoseAndRateComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to DosageDoseAndRateComponent
   * @returns DosageDoseAndRateComponent data model or undefined for \`DosageDoseAndRateComponent\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): DosageDoseAndRateComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'DosageDoseAndRateComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new DosageDoseAndRateComponent();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';

    const classMetadata: DecoratorMetadataObject | null = DosageDoseAndRateComponent[Symbol.metadata];
    const errorMessage = \`DecoratorMetadataObject does not exist for DosageDoseAndRateComponent\`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    fieldName = 'type';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = fhirDataTypeParser.parser<CodeableConcept>(CodeableConcept, classJsonObj[fieldName]!, sourceField);
      instance.setType(datatype);
    }

    fieldName = 'dose[x]';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const dose: DataType | undefined = fhirDataTypeParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setDose(dose);

    fieldName = 'rate[x]';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const rate: DataType | undefined = fhirDataTypeParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setRate(rate);

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Dosage.doseAndRate.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The kind of dose or rate specified
   * - **Definition:** The kind of dose or rate specified, for example, ordered or calculated.
   * - **Requirements:** If the type is not populated, assume to be "ordered".
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private type_?: CodeableConcept | undefined;

  /**
   * Dosage.doseAndRate.dose[x] Element
   *
   * @decorator \`@ChoiceDataTypesMeta('Dosage.doseAndRate.dose[x]', ['Range','Quantity',]\`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Amount of medication per dose
   * - **Definition:** Amount of medication per dose.
   * - **Comment:** Note that this specifies the quantity of the specified medication, not the quantity for each active ingredient(s). Each ingredient amount can be communicated in the Medication resource. For example, if one wants to communicate that a tablet was 375 mg, where the dose was one tablet, you can use the Medication resource to document that the tablet was comprised of 375 mg of drug XYZ. Alternatively if the dose was 375 mg, then you may only need to use the Medication resource to indicate this was a tablet. If the example were an IV such as dopamine and you wanted to communicate that 400mg of dopamine was mixed in 500 ml of some IV solution, then this would all be communicated in the Medication resource. If the administration is not intended to be instantaneous (rate is present or timing has a duration), this can be specified to convey the total amount to be administered over the period of time as indicated by the schedule e.g. 500 ml in dose, with timing used to convey that this should be done over 4 hours.
   * - **Requirements:** The amount of therapeutic or other substance given at one administration event.
   * - **FHIR Types:**
   *     'Range',
   *     'Quantity',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('Dosage.doseAndRate.dose[x]',[
    'Range',
    'Quantity',
  ])
  private dose?: DataType | undefined;

  /**
   * Dosage.doseAndRate.rate[x] Element
   *
   * @decorator \`@ChoiceDataTypesMeta('Dosage.doseAndRate.rate[x]', ['Ratio','Range','Quantity',]\`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Amount of medication per unit of time
   * - **Definition:** Amount of medication per unit of time.
   * - **Comment:** It is possible to supply both a rate and a doseQuantity to provide full details about how the medication is to be administered and supplied. If the rate is intended to change over time, depending on local rules/regulations, each change should be captured as a new version of the MedicationRequest with an updated rate, or captured with a new MedicationRequest with the new rate. It is possible to specify a rate over time (for example, 100 ml/hour) using either the rateRatio and rateQuantity.  The rateQuantity approach requires systems to have the capability to parse UCUM grammer where ml/hour is included rather than a specific ratio where the time is specified as the denominator.  Where a rate such as 500ml over 2 hours is specified, the use of rateRatio may be more semantically correct than specifying using a rateQuantity of 250 mg/hour.
   * - **Requirements:** Identifies the speed with which the medication was or will be introduced into the patient. Typically the rate for an infusion e.g. 100 ml per 1 hour or 100 ml/hr.  May also be expressed as a rate per unit of time e.g. 500 ml per 2 hours.   Other examples: 200 mcg/min or 200 mcg/1 minute; 1 liter/8 hours.  Sometimes, a rate can imply duration when expressed as total volume / duration (e.g.  500mL/2 hours implies a duration of 2 hours).  However, when rate doesn\\'t imply duration (e.g. 250mL/hour), then the timing.repeat.duration is needed to convey the infuse over time period.
   * - **FHIR Types:**
   *     'Ratio',
   *     'Range',
   *     'Quantity',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('Dosage.doseAndRate.rate[x]',[
    'Ratio',
    'Range',
    'Quantity',
  ])
  private rate?: DataType | undefined;


  /**
   * @returns the \`type_\` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getType(): CodeableConcept {
    return this.type_ ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Type object value to the \`type_\` property.
   *
   * @param value - the \`type_\` object value
   * @returns this
   */
  public setType(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Dosage.doseAndRate.type; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.type_ = value;
    } else {
      this.type_ = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasType(): boolean {
    return isDefined<CodeableConcept>(this.type_) && !this.type_.isEmpty();
  }

  /**
   * @returns the \`dose\` property value as a DataType object if defined; else undefined
   */
  public getDose(): DataType | undefined {
    return this.dose;
  }

  /**
   * Assigns the provided DataType object value to the \`dose\` property.
   *
   * @decorator \`@ChoiceDataTypes('Dosage.doseAndRate.dose[x]')\`
   *
   * @param value - the \`dose\` object value
   * @returns this
   */
  @ChoiceDataTypes('Dosage.doseAndRate.dose[x]')
  public setDose(value: DataType | undefined): this {
    if (isDefined<DataType>(value)) {
      // assertFhirType<DataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.dose = value;
    } else {
      this.dose = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`dose\` property exists and has a value; \`false\` otherwise
   */
  public hasDose(): boolean {
    return isDefined<DataType>(this.dose) && !this.dose.isEmpty();
  }

  // *** NOTE ***
  // Next "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the \`dose\` property value as a Range object if defined; else undefined
   */
  public getDoseRange(): Range | undefined {
    if (!isDefined<DataType | undefined>(this.dose)) {
      return undefined;
    }
    if (!(this.dose instanceof Range)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Dosage.doseAndRate.dose[x]: Expected Range but encountered \${this.dose.fhirType()}\`,
      );
    }
    return this.dose;
  }

  /**
   * @returns \`true\` if the \`dose\` property exists as a Range and has a value; \`false\` otherwise
   */
  public hasDoseRange(): boolean {
    return this.hasDose() && this.dose instanceof Range;
  }

  /**
   * @returns the \`dose\` property value as a Quantity object if defined; else undefined
   */
  public getDoseQuantity(): Quantity | undefined {
    if (!isDefined<DataType | undefined>(this.dose)) {
      return undefined;
    }
    if (!(this.dose instanceof Quantity)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Dosage.doseAndRate.dose[x]: Expected Quantity but encountered \${this.dose.fhirType()}\`,
      );
    }
    return this.dose;
  }

  /**
   * @returns \`true\` if the \`dose\` property exists as a Quantity and has a value; \`false\` otherwise
   */
  public hasDoseQuantity(): boolean {
    return this.hasDose() && this.dose instanceof Quantity;
  }

  /**
   * @returns the \`rate\` property value as a DataType object if defined; else undefined
   */
  public getRate(): DataType | undefined {
    return this.rate;
  }

  /**
   * Assigns the provided DataType object value to the \`rate\` property.
   *
   * @decorator \`@ChoiceDataTypes('Dosage.doseAndRate.rate[x]')\`
   *
   * @param value - the \`rate\` object value
   * @returns this
   */
  @ChoiceDataTypes('Dosage.doseAndRate.rate[x]')
  public setRate(value: DataType | undefined): this {
    if (isDefined<DataType>(value)) {
      // assertFhirType<DataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.rate = value;
    } else {
      this.rate = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`rate\` property exists and has a value; \`false\` otherwise
   */
  public hasRate(): boolean {
    return isDefined<DataType>(this.rate) && !this.rate.isEmpty();
  }

  // *** NOTE ***
  // Next "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the \`rate\` property value as a Ratio object if defined; else undefined
   */
  public getRateRatio(): Ratio | undefined {
    if (!isDefined<DataType | undefined>(this.rate)) {
      return undefined;
    }
    if (!(this.rate instanceof Ratio)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Dosage.doseAndRate.rate[x]: Expected Ratio but encountered \${this.rate.fhirType()}\`,
      );
    }
    return this.rate;
  }

  /**
   * @returns \`true\` if the \`rate\` property exists as a Ratio and has a value; \`false\` otherwise
   */
  public hasRateRatio(): boolean {
    return this.hasRate() && this.rate instanceof Ratio;
  }

  /**
   * @returns the \`rate\` property value as a Range object if defined; else undefined
   */
  public getRateRange(): Range | undefined {
    if (!isDefined<DataType | undefined>(this.rate)) {
      return undefined;
    }
    if (!(this.rate instanceof Range)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Dosage.doseAndRate.rate[x]: Expected Range but encountered \${this.rate.fhirType()}\`,
      );
    }
    return this.rate;
  }

  /**
   * @returns \`true\` if the \`rate\` property exists as a Range and has a value; \`false\` otherwise
   */
  public hasRateRange(): boolean {
    return this.hasRate() && this.rate instanceof Range;
  }

  /**
   * @returns the \`rate\` property value as a Quantity object if defined; else undefined
   */
  public getRateQuantity(): Quantity | undefined {
    if (!isDefined<DataType | undefined>(this.rate)) {
      return undefined;
    }
    if (!(this.rate instanceof Quantity)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Dosage.doseAndRate.rate[x]: Expected Quantity but encountered \${this.rate.fhirType()}\`,
      );
    }
    return this.rate;
  }

  /**
   * @returns \`true\` if the \`rate\` property exists as a Quantity and has a value; \`false\` otherwise
   */
  public hasRateQuantity(): boolean {
    return this.hasRate() && this.rate instanceof Quantity;
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Dosage.doseAndRate';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.type_,
      this.dose,
      this.rate,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): DosageDoseAndRateComponent {
    const dest = new DosageDoseAndRateComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: DosageDoseAndRateComponent): void {
    super.copyValues(dest);
    dest.type_ = this.type_?.copy();
    dest.dose = this.dose?.copy();
    dest.rate = this.rate?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasType()) {
      setFhirComplexJson(this.getType(), 'type', jsonObj);
    }

    if (this.hasDose()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getDose()!, 'dose', jsonObj);
    }

    if (this.hasRate()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getRate()!, 'rate', jsonObj);
    }

    return jsonObj;
  }
}
",
  "fileExtension": "ts",
  "filename": "Dosage",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 39`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * Duration Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/Duration
 * StructureDefinition.name: Duration
 * StructureDefinition.description: Base StructureDefinition for Duration Type: A length of time.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  CodeType,
  DataType,
  DecimalType,
  EnumCodeType,
  FhirDataTypeParser,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  StringType,
  UriType,
  assertEnumCodeType,
  assertFhirType,
  fhirCode,
  fhirCodeSchema,
  fhirDecimal,
  fhirDecimalSchema,
  fhirString,
  fhirStringSchema,
  fhirUri,
  fhirUriSchema,
  getPrimitiveTypeJson,
  isDefined,
  isElementEmpty,
  isEmpty,
  parseCodeType,
  parseDecimalType,
  parseFhirPrimitiveData,
  parseStringType,
  parseUriType,
  setFhirPrimitiveJson,
} from '@paq-ts-fhir/fhir-core';
import {
  PARSABLE_DATATYPE_MAP,
  QuantityComparatorEnum,
} from '../index';

/**
 * Duration Class
 *
 * @remarks
 * Base StructureDefinition for Duration Type: A length of time.
 *
 * **FHIR Specification**
 * - **Short:** A length of time
 * - **Definition:** A length of time.
 * - **Comment:** The context of use may frequently define what kind of quantity this is and therefore what kind of units can be used. The context of use may also restrict the values for the comparator.
 * - **FHIR Version:** 4.0.1
 *
 * @category DataModel: ComplexType
 * @see [FHIR Duration](http://hl7.org/fhir/StructureDefinition/Duration)
 */
export class Duration extends DataType implements IBase {
  constructor() {
    super();

    this.quantityComparatorEnum = new QuantityComparatorEnum();
  }

  /**
   * Parse the provided \`Duration\` JSON to instantiate the Duration data model.
   *
   * @param sourceJson - JSON representing FHIR \`Duration\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Duration
   * @returns Duration data model or undefined for \`Duration\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Duration | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Duration';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Duration();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'value';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = parseDecimalType(dtJson, dtSiblingJson);
      instance.setValueElement(datatype);
    }

    fieldName = 'comparator';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      instance.setComparatorElement(datatype);
    }

    fieldName = 'unit';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setUnitElement(datatype);
    }

    fieldName = 'system';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = parseUriType(dtJson, dtSiblingJson);
      instance.setSystemElement(datatype);
    }

    fieldName = 'code';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      instance.setCodeElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Duration.value Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Numerical value (with implicit precision)
   * - **Definition:** The value of the measured amount. The value includes an implicit precision in the presentation of the value.
   * - **Comment:** The implicit precision in the value should always be honored. Monetary values have their own rules for handling precision (refer to standard accounting text books).
   * - **Requirements:** Precision is handled implicitly in almost all cases of measurement.
   * - **FHIR Type:** \`decimal\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private value?: DecimalType | undefined;

  /**
   * FHIR CodeSystem: QuantityComparator
   *
   * @see {@link QuantityComparatorEnum }
   */
  private readonly quantityComparatorEnum: QuantityComparatorEnum;

  /**
   * Duration.comparator Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** < | <= | >= | > - how to understand the value
   * - **Definition:** How the value should be understood and represented - whether the actual value is greater or less than the stated value due to measurement issues; e.g. if the comparator is "<" , then the real value is < stated value.
   * - **Requirements:** Need a framework for handling measures where the value is <5ug/L or >400mg/L due to the limitations of measuring methodology.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** true
   * - **isModifierReason:** This is labeled as &quot;Is Modifier&quot; because the comparator modifies the interpretation of the value significantly. If there is no comparator, then there is no modification of the value
   * - **isSummary:** true
   */
  private comparator?: EnumCodeType | undefined;

  /**
   * Duration.unit Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Unit representation
   * - **Definition:** A human-readable form of the unit.
   * - **Requirements:** There are many representations for units of measure and in many contexts, particular representations are fixed and required. I.e. mcg for micrograms.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private unit?: StringType | undefined;

  /**
   * Duration.system Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** System that defines coded unit form
   * - **Definition:** The identification of the system that provides the coded form of the unit.
   * - **Requirements:** Need to know the system that defines the coded form of the unit.
   * - **FHIR Type:** \`uri\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private system?: UriType | undefined;

  /**
   * Duration.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Coded form of the unit
   * - **Definition:** A computer processable form of the unit in some unit representation system.
   * - **Comment:** The preferred system is UCUM, but SNOMED CT can also be used (for customary units) or ISO 4217 for currency.  The context of use may additionally require a code from a particular system.
   * - **Requirements:** Need a computable form of the unit that is fixed across all forms. UCUM provides this for quantities, but SNOMED CT provides many units of interest.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code?: CodeType | undefined;


  /**
   * @returns the \`value\` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getValueElement(): DecimalType {
    return this.value ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`value\` property.
   *
   * @param element - the \`value\` value
   * @returns this
   */
  public setValueElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = \`Invalid Duration.value; Provided element is not an instance of DecimalType.\`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.value = element;
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`value\` property exists and has a value; \`false\` otherwise
   */
  public hasValueElement(): boolean {
    return isDefined<DecimalType>(this.value) && !this.value.isEmpty();
  }

  /**
   * @returns the \`value\` property value as a fhirDecimal if defined; else undefined
   */
  public getValue(): fhirDecimal | undefined {
    return this.value?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`value\` property.
   *
   * @param value - the \`value\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setValue(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = \`Invalid Duration.value (\${String(value)})\`;
      this.value = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`value\` property exists and has a value; \`false\` otherwise
   */
  public hasValue(): boolean {
    return this.hasValueElement();
  }

  /**
   * @returns the \`comparator\` property value as a EnumCodeType if defined; else undefined
   */
  public getComparatorEnumType(): EnumCodeType | undefined {
    return this.comparator;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`comparator\` property.
   *
   * @param enumType - the \`comparator\` value
   * @returns this
   */
  public setComparatorEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid Duration.comparator';
      assertEnumCodeType<QuantityComparatorEnum>(enumType, QuantityComparatorEnum, errMsgPrefix);
      this.comparator = enumType;
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`comparator\` property exists and has a value; \`false\` otherwise
   */
  public hasComparatorEnumType(): boolean {
    return isDefined<EnumCodeType>(this.comparator) && !this.comparator.isEmpty() && this.comparator.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`comparator\` property value as a CodeType if defined; else undefined
   */
  public getComparatorElement(): CodeType | undefined {
    if (this.comparator === undefined) {
      return undefined;
    }
    return this.comparator as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`comparator\` property.
   *
   * @param element - the \`comparator\` value
   * @returns this
   */
  public setComparatorElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Duration.comparator; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.comparator = new EnumCodeType(element, this.quantityComparatorEnum);
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`comparator\` property exists and has a value; \`false\` otherwise
   */
  public hasComparatorElement(): boolean {
    return this.hasComparatorEnumType();
  }

  /**
   * @returns the \`comparator\` property value as a fhirCode if defined; else undefined
   */
  public getComparator(): fhirCode | undefined {
    if (this.comparator === undefined) {
      return undefined;
    }
    return this.comparator.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`comparator\` property.
   *
   * @param value - the \`comparator\` value
   * @returns this
   */
  public setComparator(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Duration.comparator; Provided value is not an instance of fhirCode.\`;
      this.comparator = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.quantityComparatorEnum);
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`comparator\` property exists and has a value; \`false\` otherwise
   */
  public hasComparator(): boolean {
    return this.hasComparatorEnumType();
  }

  /**
   * @returns the \`unit\` property value as a StringType object if defined; else an empty StringType object
   */
  public getUnitElement(): StringType {
    return this.unit ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`unit\` property.
   *
   * @param element - the \`unit\` value
   * @returns this
   */
  public setUnitElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Duration.unit; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.unit = element;
    } else {
      this.unit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`unit\` property exists and has a value; \`false\` otherwise
   */
  public hasUnitElement(): boolean {
    return isDefined<StringType>(this.unit) && !this.unit.isEmpty();
  }

  /**
   * @returns the \`unit\` property value as a fhirString if defined; else undefined
   */
  public getUnit(): fhirString | undefined {
    return this.unit?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`unit\` property.
   *
   * @param value - the \`unit\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setUnit(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Duration.unit (\${String(value)})\`;
      this.unit = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.unit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`unit\` property exists and has a value; \`false\` otherwise
   */
  public hasUnit(): boolean {
    return this.hasUnitElement();
  }

  /**
   * @returns the \`system\` property value as a UriType object if defined; else an empty UriType object
   */
  public getSystemElement(): UriType {
    return this.system ?? new UriType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`system\` property.
   *
   * @param element - the \`system\` value
   * @returns this
   */
  public setSystemElement(element: UriType | undefined): this {
    if (isDefined<UriType>(element)) {
      const optErrMsg = \`Invalid Duration.system; Provided element is not an instance of UriType.\`;
      assertFhirType<UriType>(element, UriType, optErrMsg);
      this.system = element;
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`system\` property exists and has a value; \`false\` otherwise
   */
  public hasSystemElement(): boolean {
    return isDefined<UriType>(this.system) && !this.system.isEmpty();
  }

  /**
   * @returns the \`system\` property value as a fhirUri if defined; else undefined
   */
  public getSystem(): fhirUri | undefined {
    return this.system?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`system\` property.
   *
   * @param value - the \`system\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setSystem(value: fhirUri | undefined): this {
    if (isDefined<fhirUri>(value)) {
      const optErrMsg = \`Invalid Duration.system (\${String(value)})\`;
      this.system = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`system\` property exists and has a value; \`false\` otherwise
   */
  public hasSystem(): boolean {
    return this.hasSystemElement();
  }

  /**
   * @returns the \`code\` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getCodeElement(): CodeType {
    return this.code ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`code\` property.
   *
   * @param element - the \`code\` value
   * @returns this
   */
  public setCodeElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Duration.code; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.code = element;
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`code\` property exists and has a value; \`false\` otherwise
   */
  public hasCodeElement(): boolean {
    return isDefined<CodeType>(this.code) && !this.code.isEmpty();
  }

  /**
   * @returns the \`code\` property value as a fhirCode if defined; else undefined
   */
  public getCode(): fhirCode | undefined {
    return this.code?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`code\` property.
   *
   * @param value - the \`code\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setCode(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Duration.code (\${String(value)})\`;
      this.code = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`code\` property exists and has a value; \`false\` otherwise
   */
  public hasCode(): boolean {
    return this.hasCodeElement();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Duration';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.value,
      this.comparator,
      this.unit,
      this.system,
      this.code,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Duration {
    const dest = new Duration();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Duration): void {
    super.copyValues(dest);
    dest.value = this.value?.copy();
    dest.comparator = this.comparator?.copy();
    dest.unit = this.unit?.copy();
    dest.system = this.system?.copy();
    dest.code = this.code?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasValueElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getValueElement(), 'value', jsonObj);
    }

    if (this.hasComparatorElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getComparatorElement()!, 'comparator', jsonObj);
    }

    if (this.hasUnitElement()) {
      setFhirPrimitiveJson<fhirString>(this.getUnitElement(), 'unit', jsonObj);
    }

    if (this.hasSystemElement()) {
      setFhirPrimitiveJson<fhirUri>(this.getSystemElement(), 'system', jsonObj);
    }

    if (this.hasCodeElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getCodeElement(), 'code', jsonObj);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "Duration",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 40`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * Expression Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/Expression
 * StructureDefinition.name: Expression
 * StructureDefinition.description: Expression Type: A expression that is evaluated in a specified context and returns a value. The context of use of the expression must specify the context in which the expression is evaluated, and how the result of the expression is used.
 * StructureDefinition.fhirVersion: 5.0.0
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  CodeType,
  DataType,
  FhirDataTypeParser,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  StringType,
  UriType,
  assertFhirType,
  fhirCode,
  fhirCodeSchema,
  fhirString,
  fhirStringSchema,
  fhirUri,
  fhirUriSchema,
  getPrimitiveTypeJson,
  isDefined,
  isElementEmpty,
  isEmpty,
  parseCodeType,
  parseFhirPrimitiveData,
  parseStringType,
  parseUriType,
  setFhirPrimitiveJson,
} from '@paq-ts-fhir/fhir-core';
import {
  PARSABLE_DATATYPE_MAP,
} from '../index';

/**
 * Expression Class
 *
 * @remarks
 * Expression Type: A expression that is evaluated in a specified context and returns a value. The context of use of the expression must specify the context in which the expression is evaluated, and how the result of the expression is used.
 *
 * **FHIR Specification**
 * - **Short:** An expression that can be used to generate a value
 * - **Definition:** A expression that is evaluated in a specified context and returns a value. The context of use of the expression must specify the context in which the expression is evaluated, and how the result of the expression is used.
 * - **FHIR Version:** 5.0.0
 *
 * @category DataModel: ComplexType
 * @see [FHIR Expression](http://hl7.org/fhir/StructureDefinition/Expression)
 */
export class Expression extends DataType implements IBase {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`Expression\` JSON to instantiate the Expression data model.
   *
   * @param sourceJson - JSON representing FHIR \`Expression\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Expression
   * @returns Expression data model or undefined for \`Expression\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Expression | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Expression';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Expression();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'description';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setDescriptionElement(datatype);
    }

    fieldName = 'name';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      instance.setNameElement(datatype);
    }

    fieldName = 'language';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      instance.setLanguageElement(datatype);
    }

    fieldName = 'expression';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setExpressionElement(datatype);
    }

    fieldName = 'reference';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = parseUriType(dtJson, dtSiblingJson);
      instance.setReferenceElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Expression.description Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Natural language description of the condition
   * - **Definition:** A brief, natural language description of the condition that effectively communicates the intended semantics.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private description?: StringType | undefined;

  /**
   * Expression.name Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Short name assigned to expression for reuse
   * - **Definition:** A short name assigned to the expression to allow for multiple reuse of the expression in the context where it is defined.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private name?: CodeType | undefined;

  /**
   * Expression.language Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** text/cql | text/fhirpath | application/x-fhir-query | etc.
   * - **Definition:** The media type of the language for the expression.
   * - **Requirements:** The cardinality of this element is optional to allow text only as part of the authoring process.  However, in order to be executable, the expression element must be specified.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private language?: CodeType | undefined;

  /**
   * Expression.expression Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Expression in specified language
   * - **Definition:** An expression in the specified language that returns a value.
   * - **Comment:** If Expression.expression and Expression.reference are both present, the Expression.expression might just be a name pointing something within the referenced content.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private expression?: StringType | undefined;

  /**
   * Expression.reference Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Where the expression is found
   * - **Definition:** A URI that defines where the expression is found.
   * - **Comment:** If both a reference and an expression is found, the reference SHALL point to the same expression.
   * - **FHIR Type:** \`uri\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private reference?: UriType | undefined;


  /**
   * @returns the \`description\` property value as a StringType object if defined; else an empty StringType object
   */
  public getDescriptionElement(): StringType {
    return this.description ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`description\` property.
   *
   * @param element - the \`description\` value
   * @returns this
   */
  public setDescriptionElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Expression.description; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.description = element;
    } else {
      this.description = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`description\` property exists and has a value; \`false\` otherwise
   */
  public hasDescriptionElement(): boolean {
    return isDefined<StringType>(this.description) && !this.description.isEmpty();
  }

  /**
   * @returns the \`description\` property value as a fhirString if defined; else undefined
   */
  public getDescription(): fhirString | undefined {
    return this.description?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`description\` property.
   *
   * @param value - the \`description\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setDescription(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Expression.description (\${String(value)})\`;
      this.description = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.description = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`description\` property exists and has a value; \`false\` otherwise
   */
  public hasDescription(): boolean {
    return this.hasDescriptionElement();
  }

  /**
   * @returns the \`name\` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getNameElement(): CodeType {
    return this.name ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`name\` property.
   *
   * @param element - the \`name\` value
   * @returns this
   */
  public setNameElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Expression.name; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.name = element;
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`name\` property exists and has a value; \`false\` otherwise
   */
  public hasNameElement(): boolean {
    return isDefined<CodeType>(this.name) && !this.name.isEmpty();
  }

  /**
   * @returns the \`name\` property value as a fhirCode if defined; else undefined
   */
  public getName(): fhirCode | undefined {
    return this.name?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`name\` property.
   *
   * @param value - the \`name\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setName(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Expression.name (\${String(value)})\`;
      this.name = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`name\` property exists and has a value; \`false\` otherwise
   */
  public hasName(): boolean {
    return this.hasNameElement();
  }

  /**
   * @returns the \`language\` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getLanguageElement(): CodeType {
    return this.language ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`language\` property.
   *
   * @param element - the \`language\` value
   * @returns this
   */
  public setLanguageElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Expression.language; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.language = element;
    } else {
      this.language = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`language\` property exists and has a value; \`false\` otherwise
   */
  public hasLanguageElement(): boolean {
    return isDefined<CodeType>(this.language) && !this.language.isEmpty();
  }

  /**
   * @returns the \`language\` property value as a fhirCode if defined; else undefined
   */
  public getLanguage(): fhirCode | undefined {
    return this.language?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`language\` property.
   *
   * @param value - the \`language\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setLanguage(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Expression.language (\${String(value)})\`;
      this.language = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.language = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`language\` property exists and has a value; \`false\` otherwise
   */
  public hasLanguage(): boolean {
    return this.hasLanguageElement();
  }

  /**
   * @returns the \`expression\` property value as a StringType object if defined; else an empty StringType object
   */
  public getExpressionElement(): StringType {
    return this.expression ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`expression\` property.
   *
   * @param element - the \`expression\` value
   * @returns this
   */
  public setExpressionElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Expression.expression; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.expression = element;
    } else {
      this.expression = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`expression\` property exists and has a value; \`false\` otherwise
   */
  public hasExpressionElement(): boolean {
    return isDefined<StringType>(this.expression) && !this.expression.isEmpty();
  }

  /**
   * @returns the \`expression\` property value as a fhirString if defined; else undefined
   */
  public getExpression(): fhirString | undefined {
    return this.expression?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`expression\` property.
   *
   * @param value - the \`expression\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setExpression(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Expression.expression (\${String(value)})\`;
      this.expression = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.expression = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`expression\` property exists and has a value; \`false\` otherwise
   */
  public hasExpression(): boolean {
    return this.hasExpressionElement();
  }

  /**
   * @returns the \`reference\` property value as a UriType object if defined; else an empty UriType object
   */
  public getReferenceElement(): UriType {
    return this.reference ?? new UriType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`reference\` property.
   *
   * @param element - the \`reference\` value
   * @returns this
   */
  public setReferenceElement(element: UriType | undefined): this {
    if (isDefined<UriType>(element)) {
      const optErrMsg = \`Invalid Expression.reference; Provided element is not an instance of UriType.\`;
      assertFhirType<UriType>(element, UriType, optErrMsg);
      this.reference = element;
    } else {
      this.reference = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`reference\` property exists and has a value; \`false\` otherwise
   */
  public hasReferenceElement(): boolean {
    return isDefined<UriType>(this.reference) && !this.reference.isEmpty();
  }

  /**
   * @returns the \`reference\` property value as a fhirUri if defined; else undefined
   */
  public getReference(): fhirUri | undefined {
    return this.reference?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`reference\` property.
   *
   * @param value - the \`reference\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setReference(value: fhirUri | undefined): this {
    if (isDefined<fhirUri>(value)) {
      const optErrMsg = \`Invalid Expression.reference (\${String(value)})\`;
      this.reference = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    } else {
      this.reference = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`reference\` property exists and has a value; \`false\` otherwise
   */
  public hasReference(): boolean {
    return this.hasReferenceElement();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Expression';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.description,
      this.name,
      this.language,
      this.expression,
      this.reference,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Expression {
    const dest = new Expression();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Expression): void {
    super.copyValues(dest);
    dest.description = this.description?.copy();
    dest.name = this.name?.copy();
    dest.language = this.language?.copy();
    dest.expression = this.expression?.copy();
    dest.reference = this.reference?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasDescriptionElement()) {
      setFhirPrimitiveJson<fhirString>(this.getDescriptionElement(), 'description', jsonObj);
    }

    if (this.hasNameElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getNameElement(), 'name', jsonObj);
    }

    if (this.hasLanguageElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getLanguageElement(), 'language', jsonObj);
    }

    if (this.hasExpressionElement()) {
      setFhirPrimitiveJson<fhirString>(this.getExpressionElement(), 'expression', jsonObj);
    }

    if (this.hasReferenceElement()) {
      setFhirPrimitiveJson<fhirUri>(this.getReferenceElement(), 'reference', jsonObj);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "Expression",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 41`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * ExtendedContactDetail Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/ExtendedContactDetail
 * StructureDefinition.name: ExtendedContactDetail
 * StructureDefinition.description: ExtendedContactDetail Type: Specifies contact information for a specific purpose over a period of time, might be handled/monitored by a specific named person or organization.
 * StructureDefinition.fhirVersion: 5.0.0
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  DataType,
  FhirDataTypeParser,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  assertFhirType,
  assertFhirTypeList,
  copyListValues,
  isDefined,
  isDefinedList,
  isElementEmpty,
  isEmpty,
  setFhirComplexJson,
  setFhirComplexListJson,
} from '@paq-ts-fhir/fhir-core';
import {
  Address,
  CodeableConcept,
  ContactPoint,
  HumanName,
  PARSABLE_DATATYPE_MAP,
  Period,
  Reference,
  ReferenceTargets,
} from '../index';

/**
 * ExtendedContactDetail Class
 *
 * @remarks
 * ExtendedContactDetail Type: Specifies contact information for a specific purpose over a period of time, might be handled/monitored by a specific named person or organization.
 *
 * Need to track contact and address information in the same way across multiple resources.
 *
 * **FHIR Specification**
 * - **Short:** Contact information
 * - **Definition:** Specifies contact information for a specific purpose over a period of time, might be handled/monitored by a specific named person or organization.
 * - **Comment:** This datatype may be sparsely populated, i.e. only contain a purpose and phone number or address, but other cases could be completed filled out.
 * - **FHIR Version:** 5.0.0
 *
 * @category DataModel: ComplexType
 * @see [FHIR ExtendedContactDetail](http://hl7.org/fhir/StructureDefinition/ExtendedContactDetail)
 */
export class ExtendedContactDetail extends DataType implements IBase {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`ExtendedContactDetail\` JSON to instantiate the ExtendedContactDetail data model.
   *
   * @param sourceJson - JSON representing FHIR \`ExtendedContactDetail\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to ExtendedContactDetail
   * @returns ExtendedContactDetail data model or undefined for \`ExtendedContactDetail\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): ExtendedContactDetail | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'ExtendedContactDetail';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new ExtendedContactDetail();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';

    fieldName = 'purpose';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = fhirDataTypeParser.parser<CodeableConcept>(CodeableConcept, classJsonObj[fieldName]!, sourceField);
      instance.setPurpose(datatype);
    }

    fieldName = 'name';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: HumanName | undefined = fhirDataTypeParser.parser<HumanName>(HumanName, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addName(datatype);
        }
      });
    }

    fieldName = 'telecom';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: ContactPoint | undefined = fhirDataTypeParser.parser<ContactPoint>(ContactPoint, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addTelecom(datatype);
        }
      });
    }

    fieldName = 'address';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Address | undefined = fhirDataTypeParser.parser<Address>(Address, classJsonObj[fieldName]!, sourceField);
      instance.setAddress(datatype);
    }

    fieldName = 'organization';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = fhirDataTypeParser.parser<Reference>(Reference, classJsonObj[fieldName]!, sourceField);
      instance.setOrganization(datatype);
    }

    fieldName = 'period';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Period | undefined = fhirDataTypeParser.parser<Period>(Period, classJsonObj[fieldName]!, sourceField);
      instance.setPeriod(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * ExtendedContactDetail.purpose Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The type of contact
   * - **Definition:** The purpose/type of contact.
   * - **Comment:** If no purpose is defined, then these contact details may be used for any purpose.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private purpose?: CodeableConcept | undefined;

  /**
   * ExtendedContactDetail.name Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Name of an individual to contact
   * - **Definition:** The name of an individual to contact, some types of contact detail are usually blank.
   * - **Comment:** If there is no named individual, the telecom/address information is not generally monitored by a specific individual.
   * - **FHIR Type:** \`HumanName\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private name?: HumanName[] | undefined;

  /**
   * ExtendedContactDetail.telecom Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Contact details (e.g.phone/fax/url)
   * - **Definition:** The contact details application for the purpose defined.
   * - **FHIR Type:** \`ContactPoint\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private telecom?: ContactPoint[] | undefined;

  /**
   * ExtendedContactDetail.address Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Address for the contact
   * - **Definition:** Address for the contact.
   * - **Comment:** More than 1 address would be for different purposes, and thus should be entered as a different entry,.
   * - **FHIR Type:** \`Address\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private address?: Address | undefined;

  /**
   * ExtendedContactDetail.organization Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** This contact detail is handled/monitored by a specific organization
   * - **Definition:** This contact detail is handled/monitored by a specific organization. If the name is provided in the contact, then it is referring to the named individual within this organization.
   * - **Requirements:** Some specific types of contact information can be an handled by an organization (eg legal council is via a specific firm).
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Organization',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private organization?: Reference | undefined;

  /**
   * ExtendedContactDetail.period Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Period that this contact was valid for usage
   * - **Definition:** Period that this contact was valid for usage.
   * - **Comment:** If the details have multiple periods, then enter in a new ExtendedContact with the new period.
   * - **FHIR Type:** \`Period\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private period?: Period | undefined;


  /**
   * @returns the \`purpose\` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getPurpose(): CodeableConcept {
    return this.purpose ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Purpose object value to the \`purpose\` property.
   *
   * @param value - the \`purpose\` object value
   * @returns this
   */
  public setPurpose(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid ExtendedContactDetail.purpose; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.purpose = value;
    } else {
      this.purpose = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`purpose\` property exists and has a value; \`false\` otherwise
   */
  public hasPurpose(): boolean {
    return isDefined<CodeableConcept>(this.purpose) && !this.purpose.isEmpty();
  }

  /**
   * @returns the \`name\` property value as a HumanName array
   */
  public getName(): HumanName[] {
    return this.name ?? ([] as HumanName[]);
  }

  /**
   * Assigns the provided HumanName array value to the \`name\` property.
   *
   * @param value - the \`name\` array value
   * @returns this
   */
  public setName(value: HumanName[] | undefined): this {
    if (isDefinedList<HumanName>(value)) {
      const optErrMsg = \`Invalid ExtendedContactDetail.name; Provided value array has an element that is not an instance of HumanName.\`;
      assertFhirTypeList<HumanName>(value, HumanName, optErrMsg);
      this.name = value;
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * Add the provided HumanName value to the \`name\` array property.
   *
   * @param value - the \`name\` value
   * @returns this
   */
  public addName(value: HumanName | undefined): this {
    if (isDefined<HumanName>(value)) {
      const optErrMsg = \`Invalid ExtendedContactDetail.name; Provided element is not an instance of HumanName.\`;
      assertFhirType<HumanName>(value, HumanName, optErrMsg);
      this.initName();
      this.name?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`name\` property exists and has a value; \`false\` otherwise
   */
  public hasName(): boolean {
    return isDefinedList<HumanName>(this.name) && this.name.some((item: HumanName) => !item.isEmpty());
  }

  /**
   * Initialize the \`name\` property
   */
  private initName(): void {
    if(!this.hasName()) {
      this.name = [] as HumanName[];
    }
  }

  /**
   * @returns the \`telecom\` property value as a ContactPoint array
   */
  public getTelecom(): ContactPoint[] {
    return this.telecom ?? ([] as ContactPoint[]);
  }

  /**
   * Assigns the provided ContactPoint array value to the \`telecom\` property.
   *
   * @param value - the \`telecom\` array value
   * @returns this
   */
  public setTelecom(value: ContactPoint[] | undefined): this {
    if (isDefinedList<ContactPoint>(value)) {
      const optErrMsg = \`Invalid ExtendedContactDetail.telecom; Provided value array has an element that is not an instance of ContactPoint.\`;
      assertFhirTypeList<ContactPoint>(value, ContactPoint, optErrMsg);
      this.telecom = value;
    } else {
      this.telecom = undefined;
    }
    return this;
  }

  /**
   * Add the provided ContactPoint value to the \`telecom\` array property.
   *
   * @param value - the \`telecom\` value
   * @returns this
   */
  public addTelecom(value: ContactPoint | undefined): this {
    if (isDefined<ContactPoint>(value)) {
      const optErrMsg = \`Invalid ExtendedContactDetail.telecom; Provided element is not an instance of ContactPoint.\`;
      assertFhirType<ContactPoint>(value, ContactPoint, optErrMsg);
      this.initTelecom();
      this.telecom?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`telecom\` property exists and has a value; \`false\` otherwise
   */
  public hasTelecom(): boolean {
    return isDefinedList<ContactPoint>(this.telecom) && this.telecom.some((item: ContactPoint) => !item.isEmpty());
  }

  /**
   * Initialize the \`telecom\` property
   */
  private initTelecom(): void {
    if(!this.hasTelecom()) {
      this.telecom = [] as ContactPoint[];
    }
  }

  /**
   * @returns the \`address\` property value as a Address object if defined; else an empty Address object
   */
  public getAddress(): Address {
    return this.address ?? new Address();
  }

  /**
   * Assigns the provided Address object value to the \`address\` property.
   *
   * @param value - the \`address\` object value
   * @returns this
   */
  public setAddress(value: Address | undefined): this {
    if (isDefined<Address>(value)) {
      const optErrMsg = \`Invalid ExtendedContactDetail.address; Provided element is not an instance of Address.\`;
      assertFhirType<Address>(value, Address, optErrMsg);
      this.address = value;
    } else {
      this.address = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`address\` property exists and has a value; \`false\` otherwise
   */
  public hasAddress(): boolean {
    return isDefined<Address>(this.address) && !this.address.isEmpty();
  }

  /**
   * @returns the \`organization\` property value as a Reference object; else an empty Reference object
   */
  public getOrganization(): Reference {
    return this.organization ?? new Reference();
  }

  /**
   * Assigns the provided Organization object value to the \`organization\` property.
   *
   * @decorator \`@ReferenceTargets('ExtendedContactDetail.organization', ['Organization',])\`
   *
   * @param value - the \`organization\` object value
   * @returns this
   */
  @ReferenceTargets('ExtendedContactDetail.organization', [
    'Organization',
  ])
  public setOrganization(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.organization = value;
    } else {
      this.organization = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`organization\` property exists and has a value; \`false\` otherwise
   */
  public hasOrganization(): boolean {
    return isDefined<Reference>(this.organization) && !this.organization.isEmpty();
  }

  /**
   * @returns the \`period\` property value as a Period object if defined; else an empty Period object
   */
  public getPeriod(): Period {
    return this.period ?? new Period();
  }

  /**
   * Assigns the provided Period object value to the \`period\` property.
   *
   * @param value - the \`period\` object value
   * @returns this
   */
  public setPeriod(value: Period | undefined): this {
    if (isDefined<Period>(value)) {
      const optErrMsg = \`Invalid ExtendedContactDetail.period; Provided element is not an instance of Period.\`;
      assertFhirType<Period>(value, Period, optErrMsg);
      this.period = value;
    } else {
      this.period = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`period\` property exists and has a value; \`false\` otherwise
   */
  public hasPeriod(): boolean {
    return isDefined<Period>(this.period) && !this.period.isEmpty();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'ExtendedContactDetail';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.purpose,
      this.name,
      this.telecom,
      this.address,
      this.organization,
      this.period,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): ExtendedContactDetail {
    const dest = new ExtendedContactDetail();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: ExtendedContactDetail): void {
    super.copyValues(dest);
    dest.purpose = this.purpose?.copy();
    const nameList = copyListValues<HumanName>(this.name);
    dest.name = nameList.length === 0 ? undefined : nameList;
    const telecomList = copyListValues<ContactPoint>(this.telecom);
    dest.telecom = telecomList.length === 0 ? undefined : telecomList;
    dest.address = this.address?.copy();
    dest.organization = this.organization?.copy();
    dest.period = this.period?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasPurpose()) {
      setFhirComplexJson(this.getPurpose(), 'purpose', jsonObj);
    }

    if (this.hasName()) {
      setFhirComplexListJson(this.getName(), 'name', jsonObj);
    }

    if (this.hasTelecom()) {
      setFhirComplexListJson(this.getTelecom(), 'telecom', jsonObj);
    }

    if (this.hasAddress()) {
      setFhirComplexJson(this.getAddress(), 'address', jsonObj);
    }

    if (this.hasOrganization()) {
      setFhirComplexJson(this.getOrganization(), 'organization', jsonObj);
    }

    if (this.hasPeriod()) {
      setFhirComplexJson(this.getPeriod(), 'period', jsonObj);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "ExtendedContactDetail",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 42`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * HumanName Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/HumanName
 * StructureDefinition.name: HumanName
 * StructureDefinition.description: Base StructureDefinition for HumanName Type: A human\\'s name with the ability to identify parts and usage.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  CodeType,
  DataType,
  EnumCodeType,
  FhirDataTypeParser,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  PrimitiveTypeJson,
  StringType,
  assertEnumCodeType,
  assertFhirType,
  assertFhirTypeList,
  copyListValues,
  fhirCode,
  fhirCodeSchema,
  fhirString,
  fhirStringSchema,
  getPrimitiveTypeJson,
  getPrimitiveTypeListJson,
  isDefined,
  isDefinedList,
  isElementEmpty,
  isEmpty,
  parseCodeType,
  parseFhirPrimitiveData,
  parseStringType,
  setFhirComplexJson,
  setFhirPrimitiveJson,
  setFhirPrimitiveListJson,
} from '@paq-ts-fhir/fhir-core';
import {
  NameUseEnum,
  PARSABLE_DATATYPE_MAP,
  Period,
} from '../index';

/**
 * HumanName Class
 *
 * @remarks
 * Base StructureDefinition for HumanName Type: A human\\'s name with the ability to identify parts and usage.
 *
 * Need to be able to record names, along with notes about their use.
 *
 * **FHIR Specification**
 * - **Short:** Name of a human - parts and usage
 * - **Definition:** A human\\'s name with the ability to identify parts and usage.
 * - **Comment:** Names may be changed, or repudiated, or people may have different names in different contexts. Names may be divided into parts of different type that have variable significance depending on context, though the division into parts does not always matter. With personal names, the different parts might or might not be imbued with some implicit meaning; various cultures associate different importance with the name parts and the degree to which systems must care about name parts around the world varies widely.
 * - **FHIR Version:** 4.0.1
 *
 * @category DataModel: ComplexType
 * @see [FHIR HumanName](http://hl7.org/fhir/StructureDefinition/HumanName)
 */
export class HumanName extends DataType implements IBase {
  constructor() {
    super();

    this.nameUseEnum = new NameUseEnum();
  }

  /**
   * Parse the provided \`HumanName\` JSON to instantiate the HumanName data model.
   *
   * @param sourceJson - JSON representing FHIR \`HumanName\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to HumanName
   * @returns HumanName data model or undefined for \`HumanName\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): HumanName | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'HumanName';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new HumanName();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'use';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      instance.setUseElement(datatype);
    }

    fieldName = 'text';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setTextElement(datatype);
    }

    fieldName = 'family';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setFamilyElement(datatype);
    }

    fieldName = 'given';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: StringType | undefined = parseStringType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addGivenElement(datatype);
        }
      });
    }

    fieldName = 'prefix';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: StringType | undefined = parseStringType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addPrefixElement(datatype);
        }
      });
    }

    fieldName = 'suffix';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: StringType | undefined = parseStringType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addSuffixElement(datatype);
        }
      });
    }

    fieldName = 'period';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Period | undefined = fhirDataTypeParser.parser<Period>(Period, classJsonObj[fieldName]!, sourceField);
      instance.setPeriod(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: NameUse
   *
   * @see {@link NameUseEnum }
   */
  private readonly nameUseEnum: NameUseEnum;

  /**
   * HumanName.use Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** usual | official | temp | nickname | anonymous | old | maiden
   * - **Definition:** Identifies the purpose for this name.
   * - **Comment:** Applications can assume that a name is current unless it explicitly says that it is temporary or old.
   * - **Requirements:** Allows the appropriate name for a particular context of use to be selected from among a set of names.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** true
   * - **isModifierReason:** This is labeled as &quot;Is Modifier&quot; because applications should not mistake a temporary or old name etc.for a current/permanent one
   * - **isSummary:** true
   */
  private use?: EnumCodeType | undefined;

  /**
   * HumanName.text Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Text representation of the full name
   * - **Definition:** Specifies the entire name as it should be displayed e.g. on an application UI. This may be provided instead of or as well as the specific parts.
   * - **Comment:** Can provide both a text representation and parts. Applications updating a name SHALL ensure that when both text and parts are present,  no content is included in the text that isn\\'t found in a part.
   * - **Requirements:** A renderable, unencoded form.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private text?: StringType | undefined;

  /**
   * HumanName.family Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Family name (often called \\'Surname\\')
   * - **Definition:** The part of a name that links to the genealogy. In some cultures (e.g. Eritrea) the family name of a son is the first name of his father.
   * - **Comment:** Family Name may be decomposed into specific parts using extensions (de, nl, es related cultures).
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private family?: StringType | undefined;

  /**
   * HumanName.given Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Given names (not always \\'first\\'). Includes middle names
   * - **Definition:** Given name.
   * - **Comment:** If only initials are recorded, they may be used in place of the full name parts. Initials may be separated into multiple given names but often aren\\'t due to paractical limitations.  This element is not called "first name" since given names do not always come first.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private given?: StringType[] | undefined;

  /**
   * HumanName.prefix Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Parts that come before the name
   * - **Definition:** Part of the name that is acquired as a title due to academic, legal, employment or nobility status, etc. and that appears at the start of the name.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private prefix?: StringType[] | undefined;

  /**
   * HumanName.suffix Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Parts that come after the name
   * - **Definition:** Part of the name that is acquired as a title due to academic, legal, employment or nobility status, etc. and that appears at the end of the name.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private suffix?: StringType[] | undefined;

  /**
   * HumanName.period Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Time period when name was/is in use
   * - **Definition:** Indicates the period of time when this name was valid for the named person.
   * - **Requirements:** Allows names to be placed in historical context.
   * - **FHIR Type:** \`Period\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private period?: Period | undefined;


  /**
   * @returns the \`use\` property value as a EnumCodeType if defined; else undefined
   */
  public getUseEnumType(): EnumCodeType | undefined {
    return this.use;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`use\` property.
   *
   * @param enumType - the \`use\` value
   * @returns this
   */
  public setUseEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid HumanName.use';
      assertEnumCodeType<NameUseEnum>(enumType, NameUseEnum, errMsgPrefix);
      this.use = enumType;
    } else {
      this.use = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`use\` property exists and has a value; \`false\` otherwise
   */
  public hasUseEnumType(): boolean {
    return isDefined<EnumCodeType>(this.use) && !this.use.isEmpty() && this.use.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`use\` property value as a CodeType if defined; else undefined
   */
  public getUseElement(): CodeType | undefined {
    if (this.use === undefined) {
      return undefined;
    }
    return this.use as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`use\` property.
   *
   * @param element - the \`use\` value
   * @returns this
   */
  public setUseElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid HumanName.use; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.use = new EnumCodeType(element, this.nameUseEnum);
    } else {
      this.use = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`use\` property exists and has a value; \`false\` otherwise
   */
  public hasUseElement(): boolean {
    return this.hasUseEnumType();
  }

  /**
   * @returns the \`use\` property value as a fhirCode if defined; else undefined
   */
  public getUse(): fhirCode | undefined {
    if (this.use === undefined) {
      return undefined;
    }
    return this.use.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`use\` property.
   *
   * @param value - the \`use\` value
   * @returns this
   */
  public setUse(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid HumanName.use; Provided value is not an instance of fhirCode.\`;
      this.use = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.nameUseEnum);
    } else {
      this.use = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`use\` property exists and has a value; \`false\` otherwise
   */
  public hasUse(): boolean {
    return this.hasUseEnumType();
  }

  /**
   * @returns the \`text\` property value as a StringType object if defined; else an empty StringType object
   */
  public getTextElement(): StringType {
    return this.text ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`text\` property.
   *
   * @param element - the \`text\` value
   * @returns this
   */
  public setTextElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid HumanName.text; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.text = element;
    } else {
      this.text = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`text\` property exists and has a value; \`false\` otherwise
   */
  public hasTextElement(): boolean {
    return isDefined<StringType>(this.text) && !this.text.isEmpty();
  }

  /**
   * @returns the \`text\` property value as a fhirString if defined; else undefined
   */
  public getText(): fhirString | undefined {
    return this.text?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`text\` property.
   *
   * @param value - the \`text\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setText(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid HumanName.text (\${String(value)})\`;
      this.text = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.text = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`text\` property exists and has a value; \`false\` otherwise
   */
  public hasText(): boolean {
    return this.hasTextElement();
  }

  /**
   * @returns the \`family\` property value as a StringType object if defined; else an empty StringType object
   */
  public getFamilyElement(): StringType {
    return this.family ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`family\` property.
   *
   * @param element - the \`family\` value
   * @returns this
   */
  public setFamilyElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid HumanName.family; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.family = element;
    } else {
      this.family = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`family\` property exists and has a value; \`false\` otherwise
   */
  public hasFamilyElement(): boolean {
    return isDefined<StringType>(this.family) && !this.family.isEmpty();
  }

  /**
   * @returns the \`family\` property value as a fhirString if defined; else undefined
   */
  public getFamily(): fhirString | undefined {
    return this.family?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`family\` property.
   *
   * @param value - the \`family\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setFamily(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid HumanName.family (\${String(value)})\`;
      this.family = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.family = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`family\` property exists and has a value; \`false\` otherwise
   */
  public hasFamily(): boolean {
    return this.hasFamilyElement();
  }

  /**
   * @returns the \`given\` property value as a StringType array
   */
  public getGivenElement(): StringType[] {
    return this.given ?? ([] as StringType[]);
  }

  /**
   * Assigns the provided StringType array value to the \`given\` property.
   *
   * @param element - the \`given\` array value
   * @returns this
   */
  public setGivenElement(element: StringType[] | undefined): this {
    if (isDefinedList<StringType>(element)) {
      const optErrMsg = \`Invalid HumanName.given; Provided value array has an element that is not an instance of StringType.\`;
      assertFhirTypeList<StringType>(element, StringType, optErrMsg);
      this.given = element;
    } else {
      this.given = undefined;
    }
    return this;
  }

  /**
   * Add the provided StringType value to the \`given\` array property.
   *
   * @param element - the \`given\` value
   * @returns this
   */
  public addGivenElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid HumanName.given; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.initGiven();
      this.given?.push(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`given\` property exists and has a value; \`false\` otherwise
   */
  public hasGivenElement(): boolean {
    return isDefinedList<StringType>(this.given) && this.given.some((item: StringType) => !item.isEmpty());
  }

  /**
   * @returns the \`given\` property value as a fhirString array
   */
  public getGiven(): fhirString[] {
    this.initGiven();
    const givenValues = [] as fhirString[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.given!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        givenValues.push(value);
      }
    }
    return givenValues;
  }

  /**
   * Assigns the provided primitive value array to the \`given\` property.
   *
   * @param value - the \`given\` value array
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setGiven(value: fhirString[] | undefined): this {
    if (isDefinedList<fhirString>(value)) {
      const givenElements = [] as StringType[];
      for (const givenValue of value) {
        const optErrMsg = \`Invalid HumanName.given array item (\${String(givenValue)})\`;
        const element = new StringType(parseFhirPrimitiveData(givenValue, fhirStringSchema, optErrMsg));
        givenElements.push(element);
      }
      this.given = givenElements;
    } else {
      this.given = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`given\` array property.
   *
   * @param value - the \`given\` value
   * @returns this
   */
  public addGiven(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid HumanName.given array item (\${String(value)})\`;
      const element = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
      this.initGiven();
      this.addGivenElement(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`given\` property exists and has a value; \`false\` otherwise
   */
  public hasGiven(): boolean {
    return this.hasGivenElement();
  }

  /**
   * Initialize the \`given\` property
   */
  private initGiven(): void {
    if (!this.hasGiven()) {
      this.given = [] as StringType[];
    }
  }

  /**
   * @returns the \`prefix\` property value as a StringType array
   */
  public getPrefixElement(): StringType[] {
    return this.prefix ?? ([] as StringType[]);
  }

  /**
   * Assigns the provided StringType array value to the \`prefix\` property.
   *
   * @param element - the \`prefix\` array value
   * @returns this
   */
  public setPrefixElement(element: StringType[] | undefined): this {
    if (isDefinedList<StringType>(element)) {
      const optErrMsg = \`Invalid HumanName.prefix; Provided value array has an element that is not an instance of StringType.\`;
      assertFhirTypeList<StringType>(element, StringType, optErrMsg);
      this.prefix = element;
    } else {
      this.prefix = undefined;
    }
    return this;
  }

  /**
   * Add the provided StringType value to the \`prefix\` array property.
   *
   * @param element - the \`prefix\` value
   * @returns this
   */
  public addPrefixElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid HumanName.prefix; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.initPrefix();
      this.prefix?.push(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`prefix\` property exists and has a value; \`false\` otherwise
   */
  public hasPrefixElement(): boolean {
    return isDefinedList<StringType>(this.prefix) && this.prefix.some((item: StringType) => !item.isEmpty());
  }

  /**
   * @returns the \`prefix\` property value as a fhirString array
   */
  public getPrefix(): fhirString[] {
    this.initPrefix();
    const prefixValues = [] as fhirString[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.prefix!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        prefixValues.push(value);
      }
    }
    return prefixValues;
  }

  /**
   * Assigns the provided primitive value array to the \`prefix\` property.
   *
   * @param value - the \`prefix\` value array
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setPrefix(value: fhirString[] | undefined): this {
    if (isDefinedList<fhirString>(value)) {
      const prefixElements = [] as StringType[];
      for (const prefixValue of value) {
        const optErrMsg = \`Invalid HumanName.prefix array item (\${String(prefixValue)})\`;
        const element = new StringType(parseFhirPrimitiveData(prefixValue, fhirStringSchema, optErrMsg));
        prefixElements.push(element);
      }
      this.prefix = prefixElements;
    } else {
      this.prefix = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`prefix\` array property.
   *
   * @param value - the \`prefix\` value
   * @returns this
   */
  public addPrefix(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid HumanName.prefix array item (\${String(value)})\`;
      const element = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
      this.initPrefix();
      this.addPrefixElement(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`prefix\` property exists and has a value; \`false\` otherwise
   */
  public hasPrefix(): boolean {
    return this.hasPrefixElement();
  }

  /**
   * Initialize the \`prefix\` property
   */
  private initPrefix(): void {
    if (!this.hasPrefix()) {
      this.prefix = [] as StringType[];
    }
  }

  /**
   * @returns the \`suffix\` property value as a StringType array
   */
  public getSuffixElement(): StringType[] {
    return this.suffix ?? ([] as StringType[]);
  }

  /**
   * Assigns the provided StringType array value to the \`suffix\` property.
   *
   * @param element - the \`suffix\` array value
   * @returns this
   */
  public setSuffixElement(element: StringType[] | undefined): this {
    if (isDefinedList<StringType>(element)) {
      const optErrMsg = \`Invalid HumanName.suffix; Provided value array has an element that is not an instance of StringType.\`;
      assertFhirTypeList<StringType>(element, StringType, optErrMsg);
      this.suffix = element;
    } else {
      this.suffix = undefined;
    }
    return this;
  }

  /**
   * Add the provided StringType value to the \`suffix\` array property.
   *
   * @param element - the \`suffix\` value
   * @returns this
   */
  public addSuffixElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid HumanName.suffix; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.initSuffix();
      this.suffix?.push(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`suffix\` property exists and has a value; \`false\` otherwise
   */
  public hasSuffixElement(): boolean {
    return isDefinedList<StringType>(this.suffix) && this.suffix.some((item: StringType) => !item.isEmpty());
  }

  /**
   * @returns the \`suffix\` property value as a fhirString array
   */
  public getSuffix(): fhirString[] {
    this.initSuffix();
    const suffixValues = [] as fhirString[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.suffix!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        suffixValues.push(value);
      }
    }
    return suffixValues;
  }

  /**
   * Assigns the provided primitive value array to the \`suffix\` property.
   *
   * @param value - the \`suffix\` value array
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setSuffix(value: fhirString[] | undefined): this {
    if (isDefinedList<fhirString>(value)) {
      const suffixElements = [] as StringType[];
      for (const suffixValue of value) {
        const optErrMsg = \`Invalid HumanName.suffix array item (\${String(suffixValue)})\`;
        const element = new StringType(parseFhirPrimitiveData(suffixValue, fhirStringSchema, optErrMsg));
        suffixElements.push(element);
      }
      this.suffix = suffixElements;
    } else {
      this.suffix = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`suffix\` array property.
   *
   * @param value - the \`suffix\` value
   * @returns this
   */
  public addSuffix(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid HumanName.suffix array item (\${String(value)})\`;
      const element = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
      this.initSuffix();
      this.addSuffixElement(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`suffix\` property exists and has a value; \`false\` otherwise
   */
  public hasSuffix(): boolean {
    return this.hasSuffixElement();
  }

  /**
   * Initialize the \`suffix\` property
   */
  private initSuffix(): void {
    if (!this.hasSuffix()) {
      this.suffix = [] as StringType[];
    }
  }

  /**
   * @returns the \`period\` property value as a Period object if defined; else an empty Period object
   */
  public getPeriod(): Period {
    return this.period ?? new Period();
  }

  /**
   * Assigns the provided Period object value to the \`period\` property.
   *
   * @param value - the \`period\` object value
   * @returns this
   */
  public setPeriod(value: Period | undefined): this {
    if (isDefined<Period>(value)) {
      const optErrMsg = \`Invalid HumanName.period; Provided element is not an instance of Period.\`;
      assertFhirType<Period>(value, Period, optErrMsg);
      this.period = value;
    } else {
      this.period = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`period\` property exists and has a value; \`false\` otherwise
   */
  public hasPeriod(): boolean {
    return isDefined<Period>(this.period) && !this.period.isEmpty();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'HumanName';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.use,
      this.text,
      this.family,
      this.given,
      this.prefix,
      this.suffix,
      this.period,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): HumanName {
    const dest = new HumanName();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: HumanName): void {
    super.copyValues(dest);
    dest.use = this.use?.copy();
    dest.text = this.text?.copy();
    dest.family = this.family?.copy();
    const givenList = copyListValues<StringType>(this.given);
    dest.given = givenList.length === 0 ? undefined : givenList;
    const prefixList = copyListValues<StringType>(this.prefix);
    dest.prefix = prefixList.length === 0 ? undefined : prefixList;
    const suffixList = copyListValues<StringType>(this.suffix);
    dest.suffix = suffixList.length === 0 ? undefined : suffixList;
    dest.period = this.period?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasUseElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getUseElement()!, 'use', jsonObj);
    }

    if (this.hasTextElement()) {
      setFhirPrimitiveJson<fhirString>(this.getTextElement(), 'text', jsonObj);
    }

    if (this.hasFamilyElement()) {
      setFhirPrimitiveJson<fhirString>(this.getFamilyElement(), 'family', jsonObj);
    }

    if (this.hasGiven()) {
      setFhirPrimitiveListJson(this.getGivenElement(), 'given', jsonObj);
    }

    if (this.hasPrefix()) {
      setFhirPrimitiveListJson(this.getPrefixElement(), 'prefix', jsonObj);
    }

    if (this.hasSuffix()) {
      setFhirPrimitiveListJson(this.getSuffixElement(), 'suffix', jsonObj);
    }

    if (this.hasPeriod()) {
      setFhirComplexJson(this.getPeriod(), 'period', jsonObj);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "HumanName",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 43`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * Identifier Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/Identifier
 * StructureDefinition.name: Identifier
 * StructureDefinition.description: Base StructureDefinition for Identifier Type: An identifier - identifies some entity uniquely and unambiguously. Typically this is used for business identifiers.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  CodeType,
  DataType,
  EnumCodeType,
  FhirDataTypeParser,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  StringType,
  UriType,
  assertEnumCodeType,
  assertFhirType,
  fhirCode,
  fhirCodeSchema,
  fhirString,
  fhirStringSchema,
  fhirUri,
  fhirUriSchema,
  getPrimitiveTypeJson,
  isDefined,
  isElementEmpty,
  isEmpty,
  parseCodeType,
  parseFhirPrimitiveData,
  parseStringType,
  parseUriType,
  setFhirComplexJson,
  setFhirPrimitiveJson,
} from '@paq-ts-fhir/fhir-core';
import {
  CodeableConcept,
  IdentifierUseEnum,
  PARSABLE_DATATYPE_MAP,
  Period,
  Reference,
  ReferenceTargets,
} from '../index';

/**
 * Identifier Class
 *
 * @remarks
 * Base StructureDefinition for Identifier Type: An identifier - identifies some entity uniquely and unambiguously. Typically this is used for business identifiers.
 *
 * Need to be able to identify things with confidence and be sure that the identification is not subject to misinterpretation.
 *
 * **FHIR Specification**
 * - **Short:** An identifier intended for computation
 * - **Definition:** An identifier - identifies some entity uniquely and unambiguously. Typically this is used for business identifiers.
 * - **FHIR Version:** 4.0.1
 *
 * @category DataModel: ComplexType
 * @see [FHIR Identifier](http://hl7.org/fhir/StructureDefinition/Identifier)
 */
export class Identifier extends DataType implements IBase {
  constructor() {
    super();

    this.identifierUseEnum = new IdentifierUseEnum();
  }

  /**
   * Parse the provided \`Identifier\` JSON to instantiate the Identifier data model.
   *
   * @param sourceJson - JSON representing FHIR \`Identifier\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Identifier
   * @returns Identifier data model or undefined for \`Identifier\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Identifier | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Identifier';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Identifier();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'use';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      instance.setUseElement(datatype);
    }

    fieldName = 'type';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = fhirDataTypeParser.parser<CodeableConcept>(CodeableConcept, classJsonObj[fieldName]!, sourceField);
      instance.setType(datatype);
    }

    fieldName = 'system';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = parseUriType(dtJson, dtSiblingJson);
      instance.setSystemElement(datatype);
    }

    fieldName = 'value';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setValueElement(datatype);
    }

    fieldName = 'period';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Period | undefined = fhirDataTypeParser.parser<Period>(Period, classJsonObj[fieldName]!, sourceField);
      instance.setPeriod(datatype);
    }

    fieldName = 'assigner';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = fhirDataTypeParser.parser<Reference>(Reference, classJsonObj[fieldName]!, sourceField);
      instance.setAssigner(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: IdentifierUse
   *
   * @see {@link IdentifierUseEnum }
   */
  private readonly identifierUseEnum: IdentifierUseEnum;

  /**
   * Identifier.use Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** usual | official | temp | secondary | old (If known)
   * - **Definition:** The purpose of this identifier.
   * - **Comment:** Applications can assume that an identifier is permanent unless it explicitly says that it is temporary.
   * - **Requirements:** Allows the appropriate identifier for a particular context of use to be selected from among a set of identifiers.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** true
   * - **isModifierReason:** This is labeled as &quot;Is Modifier&quot; because applications should not mistake a temporary id for a permanent one.
   * - **isSummary:** true
   */
  private use?: EnumCodeType | undefined;

  /**
   * Identifier.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Description of identifier
   * - **Definition:** A coded type for the identifier that can be used to determine which identifier to use for a specific purpose.
   * - **Comment:** This element deals only with general categories of identifiers.  It SHOULD not be used for codes that correspond 1..1 with the Identifier.system. Some identifiers may fall into multiple categories due to common usage.   Where the system is known, a type is unnecessary because the type is always part of the system definition. However systems often need to handle identifiers where the system is not known. There is not a 1:1 relationship between type and system, since many different systems have the same type.
   * - **Requirements:** Allows users to make use of identifiers when the identifier system is not known.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private type_?: CodeableConcept | undefined;

  /**
   * Identifier.system Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The namespace for the identifier value
   * - **Definition:** Establishes the namespace for the value - that is, a URL that describes a set values that are unique.
   * - **Comment:** Identifier.system is always case sensitive.
   * - **Requirements:** There are many sets  of identifiers.  To perform matching of two identifiers, we need to know what set we\\'re dealing with. The system identifies a particular set of unique identifiers.
   * - **FHIR Type:** \`uri\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private system?: UriType | undefined;

  /**
   * Identifier.value Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The value that is unique
   * - **Definition:** The portion of the identifier typically relevant to the user and which is unique within the context of the system.
   * - **Comment:** If the value is a full URI, then the system SHALL be urn:ietf:rfc:3986.  The value\\'s primary purpose is computational mapping.  As a result, it may be normalized for comparison purposes (e.g. removing non-significant whitespace, dashes, etc.)  A value formatted for human display can be conveyed using the [Rendered Value extension](https://hl7.org/fhir/extension-rendered-value.html). Identifier.value is to be treated as case sensitive unless knowledge of the Identifier.system allows the processer to be confident that non-case-sensitive processing is safe.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private value?: StringType | undefined;

  /**
   * Identifier.period Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Time period when id is/was valid for use
   * - **Definition:** Time period during which identifier is/was valid for use.
   * - **FHIR Type:** \`Period\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private period?: Period | undefined;

  /**
   * Identifier.assigner Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Organization that issued id (may be just text)
   * - **Definition:** Organization that issued/manages the identifier.
   * - **Comment:** The Identifier.assigner may omit the .reference element and only contain a .display element reflecting the name or other textual information about the assigning organization.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Organization',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private assigner?: Reference | undefined;


  /**
   * @returns the \`use\` property value as a EnumCodeType if defined; else undefined
   */
  public getUseEnumType(): EnumCodeType | undefined {
    return this.use;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`use\` property.
   *
   * @param enumType - the \`use\` value
   * @returns this
   */
  public setUseEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid Identifier.use';
      assertEnumCodeType<IdentifierUseEnum>(enumType, IdentifierUseEnum, errMsgPrefix);
      this.use = enumType;
    } else {
      this.use = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`use\` property exists and has a value; \`false\` otherwise
   */
  public hasUseEnumType(): boolean {
    return isDefined<EnumCodeType>(this.use) && !this.use.isEmpty() && this.use.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`use\` property value as a CodeType if defined; else undefined
   */
  public getUseElement(): CodeType | undefined {
    if (this.use === undefined) {
      return undefined;
    }
    return this.use as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`use\` property.
   *
   * @param element - the \`use\` value
   * @returns this
   */
  public setUseElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Identifier.use; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.use = new EnumCodeType(element, this.identifierUseEnum);
    } else {
      this.use = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`use\` property exists and has a value; \`false\` otherwise
   */
  public hasUseElement(): boolean {
    return this.hasUseEnumType();
  }

  /**
   * @returns the \`use\` property value as a fhirCode if defined; else undefined
   */
  public getUse(): fhirCode | undefined {
    if (this.use === undefined) {
      return undefined;
    }
    return this.use.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`use\` property.
   *
   * @param value - the \`use\` value
   * @returns this
   */
  public setUse(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Identifier.use; Provided value is not an instance of fhirCode.\`;
      this.use = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.identifierUseEnum);
    } else {
      this.use = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`use\` property exists and has a value; \`false\` otherwise
   */
  public hasUse(): boolean {
    return this.hasUseEnumType();
  }

  /**
   * @returns the \`type_\` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getType(): CodeableConcept {
    return this.type_ ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Type object value to the \`type_\` property.
   *
   * @param value - the \`type_\` object value
   * @returns this
   */
  public setType(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Identifier.type; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.type_ = value;
    } else {
      this.type_ = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasType(): boolean {
    return isDefined<CodeableConcept>(this.type_) && !this.type_.isEmpty();
  }

  /**
   * @returns the \`system\` property value as a UriType object if defined; else an empty UriType object
   */
  public getSystemElement(): UriType {
    return this.system ?? new UriType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`system\` property.
   *
   * @param element - the \`system\` value
   * @returns this
   */
  public setSystemElement(element: UriType | undefined): this {
    if (isDefined<UriType>(element)) {
      const optErrMsg = \`Invalid Identifier.system; Provided element is not an instance of UriType.\`;
      assertFhirType<UriType>(element, UriType, optErrMsg);
      this.system = element;
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`system\` property exists and has a value; \`false\` otherwise
   */
  public hasSystemElement(): boolean {
    return isDefined<UriType>(this.system) && !this.system.isEmpty();
  }

  /**
   * @returns the \`system\` property value as a fhirUri if defined; else undefined
   */
  public getSystem(): fhirUri | undefined {
    return this.system?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`system\` property.
   *
   * @param value - the \`system\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setSystem(value: fhirUri | undefined): this {
    if (isDefined<fhirUri>(value)) {
      const optErrMsg = \`Invalid Identifier.system (\${String(value)})\`;
      this.system = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`system\` property exists and has a value; \`false\` otherwise
   */
  public hasSystem(): boolean {
    return this.hasSystemElement();
  }

  /**
   * @returns the \`value\` property value as a StringType object if defined; else an empty StringType object
   */
  public getValueElement(): StringType {
    return this.value ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`value\` property.
   *
   * @param element - the \`value\` value
   * @returns this
   */
  public setValueElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Identifier.value; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.value = element;
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`value\` property exists and has a value; \`false\` otherwise
   */
  public hasValueElement(): boolean {
    return isDefined<StringType>(this.value) && !this.value.isEmpty();
  }

  /**
   * @returns the \`value\` property value as a fhirString if defined; else undefined
   */
  public getValue(): fhirString | undefined {
    return this.value?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`value\` property.
   *
   * @param value - the \`value\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setValue(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Identifier.value (\${String(value)})\`;
      this.value = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`value\` property exists and has a value; \`false\` otherwise
   */
  public hasValue(): boolean {
    return this.hasValueElement();
  }

  /**
   * @returns the \`period\` property value as a Period object if defined; else an empty Period object
   */
  public getPeriod(): Period {
    return this.period ?? new Period();
  }

  /**
   * Assigns the provided Period object value to the \`period\` property.
   *
   * @param value - the \`period\` object value
   * @returns this
   */
  public setPeriod(value: Period | undefined): this {
    if (isDefined<Period>(value)) {
      const optErrMsg = \`Invalid Identifier.period; Provided element is not an instance of Period.\`;
      assertFhirType<Period>(value, Period, optErrMsg);
      this.period = value;
    } else {
      this.period = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`period\` property exists and has a value; \`false\` otherwise
   */
  public hasPeriod(): boolean {
    return isDefined<Period>(this.period) && !this.period.isEmpty();
  }

  /**
   * @returns the \`assigner\` property value as a Reference object; else an empty Reference object
   */
  public getAssigner(): Reference {
    return this.assigner ?? new Reference();
  }

  /**
   * Assigns the provided Assigner object value to the \`assigner\` property.
   *
   * @decorator \`@ReferenceTargets('Identifier.assigner', ['Organization',])\`
   *
   * @param value - the \`assigner\` object value
   * @returns this
   */
  @ReferenceTargets('Identifier.assigner', [
    'Organization',
  ])
  public setAssigner(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.assigner = value;
    } else {
      this.assigner = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`assigner\` property exists and has a value; \`false\` otherwise
   */
  public hasAssigner(): boolean {
    return isDefined<Reference>(this.assigner) && !this.assigner.isEmpty();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Identifier';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.use,
      this.type_,
      this.system,
      this.value,
      this.period,
      this.assigner,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Identifier {
    const dest = new Identifier();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Identifier): void {
    super.copyValues(dest);
    dest.use = this.use?.copy();
    dest.type_ = this.type_?.copy();
    dest.system = this.system?.copy();
    dest.value = this.value?.copy();
    dest.period = this.period?.copy();
    dest.assigner = this.assigner?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasUseElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getUseElement()!, 'use', jsonObj);
    }

    if (this.hasType()) {
      setFhirComplexJson(this.getType(), 'type', jsonObj);
    }

    if (this.hasSystemElement()) {
      setFhirPrimitiveJson<fhirUri>(this.getSystemElement(), 'system', jsonObj);
    }

    if (this.hasValueElement()) {
      setFhirPrimitiveJson<fhirString>(this.getValueElement(), 'value', jsonObj);
    }

    if (this.hasPeriod()) {
      setFhirComplexJson(this.getPeriod(), 'period', jsonObj);
    }

    if (this.hasAssigner()) {
      setFhirComplexJson(this.getAssigner(), 'assigner', jsonObj);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "Identifier",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 44`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * MarketingStatus Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/MarketingStatus
 * StructureDefinition.name: MarketingStatus
 * StructureDefinition.description: MarketingStatus Type: The marketing status describes the date when a medicinal product is actually put on the market or the date as of which it is no longer available.
 * StructureDefinition.fhirVersion: 5.0.0
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  BackboneType,
  DateTimeType,
  FhirDataTypeParser,
  FhirError,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  REQUIRED_PROPERTIES_DO_NOT_EXIST,
  REQUIRED_PROPERTIES_REQD_IN_JSON,
  assertFhirType,
  assertIsDefined,
  fhirDateTime,
  fhirDateTimeSchema,
  getPrimitiveTypeJson,
  isDefined,
  isElementEmpty,
  isEmpty,
  parseDateTimeType,
  parseFhirPrimitiveData,
  setFhirComplexJson,
  setFhirPrimitiveJson,
} from '@paq-ts-fhir/fhir-core';
import {
  CodeableConcept,
  PARSABLE_DATATYPE_MAP,
  Period,
} from '../index';

/**
 * MarketingStatus Class
 *
 * @remarks
 * MarketingStatus Type: The marketing status describes the date when a medicinal product is actually put on the market or the date as of which it is no longer available.
 *
 * **FHIR Specification**
 * - **Short:** The marketing status describes the date when a medicinal product is actually put on the market or the date as of which it is no longer available
 * - **Definition:** The marketing status describes the date when a medicinal product is actually put on the market or the date as of which it is no longer available.
 * - **FHIR Version:** 5.0.0
 *
 * @category DataModel: ComplexType
 * @see [FHIR MarketingStatus](http://hl7.org/fhir/StructureDefinition/MarketingStatus)
 */
export class MarketingStatus extends BackboneType implements IBase {
  constructor(status: CodeableConcept | null = null) {
    super();

    this.status = null;
    if (isDefined<CodeableConcept>(status)) {
      this.setStatus(status);
    }
  }

  /**
   * Parse the provided \`MarketingStatus\` JSON to instantiate the MarketingStatus data model.
   *
   * @param sourceJson - JSON representing FHIR \`MarketingStatus\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to MarketingStatus
   * @returns MarketingStatus data model or undefined for \`MarketingStatus\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): MarketingStatus | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'MarketingStatus';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new MarketingStatus();
    fhirDataTypeParser.processBackboneTypeJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    

    const missingReqdProperties: string[] = [];

    fieldName = 'country';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = fhirDataTypeParser.parser<CodeableConcept>(CodeableConcept, classJsonObj[fieldName]!, sourceField);
      instance.setCountry(datatype);
    }

    fieldName = 'jurisdiction';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = fhirDataTypeParser.parser<CodeableConcept>(CodeableConcept, classJsonObj[fieldName]!, sourceField);
      instance.setJurisdiction(datatype);
    }

    fieldName = 'status';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = fhirDataTypeParser.parser<CodeableConcept>(CodeableConcept, classJsonObj[fieldName]!, sourceField);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setStatus(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'dateRange';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Period | undefined = fhirDataTypeParser.parser<Period>(Period, classJsonObj[fieldName]!, sourceField);
      instance.setDateRange(datatype);
    }

    fieldName = 'restoreDate';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DateTimeType | undefined = parseDateTimeType(dtJson, dtSiblingJson);
      instance.setRestoreDateElement(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * MarketingStatus.country Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The country in which the marketing authorization has been granted shall be specified It should be specified using the ISO 3166 - 1 alpha-2 code elements
   * - **Definition:** The country in which the marketing authorization has been granted shall be specified It should be specified using the ISO 3166 - 1 alpha-2 code elements.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private country?: CodeableConcept | undefined;

  /**
   * MarketingStatus.jurisdiction Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Where a Medicines Regulatory Agency has granted a marketing authorization for which specific provisions within a jurisdiction apply, the jurisdiction can be specified using an appropriate controlled terminology The controlled term and the controlled term identifier shall be specified
   * - **Definition:** Where a Medicines Regulatory Agency has granted a marketing authorization for which specific provisions within a jurisdiction apply, the jurisdiction can be specified using an appropriate controlled terminology The controlled term and the controlled term identifier shall be specified.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private jurisdiction?: CodeableConcept | undefined;

  /**
   * MarketingStatus.status Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** This attribute provides information on the status of the marketing of the medicinal product See ISO/TS 20443 for more information and examples
   * - **Definition:** This attribute provides information on the status of the marketing of the medicinal product See ISO/TS 20443 for more information and examples.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private status: CodeableConcept | null;

  /**
   * MarketingStatus.dateRange Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The date when the Medicinal Product is placed on the market by the Marketing Authorization Holder (or where applicable, the manufacturer/distributor) in a country and/or jurisdiction shall be provided A complete date consisting of day, month and year shall be specified using the ISO 8601 date format NOTE "Placed on the market" refers to the release of the Medicinal Product into the distribution chain
   * - **Definition:** The date when the Medicinal Product is placed on the market by the Marketing Authorization Holder (or where applicable, the manufacturer/distributor) in a country and/or jurisdiction shall be provided A complete date consisting of day, month and year shall be specified using the ISO 8601 date format NOTE "Placed on the market" refers to the release of the Medicinal Product into the distribution chain.
   * - **FHIR Type:** \`Period\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private dateRange?: Period | undefined;

  /**
   * MarketingStatus.restoreDate Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The date when the Medicinal Product is placed on the market by the Marketing Authorization Holder (or where applicable, the manufacturer/distributor) in a country and/or jurisdiction shall be provided A complete date consisting of day, month and year shall be specified using the ISO 8601 date format NOTE "Placed on the market" refers to the release of the Medicinal Product into the distribution chain
   * - **Definition:** The date when the Medicinal Product is placed on the market by the Marketing Authorization Holder (or where applicable, the manufacturer/distributor) in a country and/or jurisdiction shall be provided A complete date consisting of day, month and year shall be specified using the ISO 8601 date format NOTE "Placed on the market" refers to the release of the Medicinal Product into the distribution chain.
   * - **FHIR Type:** \`dateTime\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private restoreDate?: DateTimeType | undefined;


  /**
   * @returns the \`country\` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getCountry(): CodeableConcept {
    return this.country ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Country object value to the \`country\` property.
   *
   * @param value - the \`country\` object value
   * @returns this
   */
  public setCountry(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid MarketingStatus.country; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.country = value;
    } else {
      this.country = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`country\` property exists and has a value; \`false\` otherwise
   */
  public hasCountry(): boolean {
    return isDefined<CodeableConcept>(this.country) && !this.country.isEmpty();
  }

  /**
   * @returns the \`jurisdiction\` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getJurisdiction(): CodeableConcept {
    return this.jurisdiction ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Jurisdiction object value to the \`jurisdiction\` property.
   *
   * @param value - the \`jurisdiction\` object value
   * @returns this
   */
  public setJurisdiction(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid MarketingStatus.jurisdiction; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.jurisdiction = value;
    } else {
      this.jurisdiction = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`jurisdiction\` property exists and has a value; \`false\` otherwise
   */
  public hasJurisdiction(): boolean {
    return isDefined<CodeableConcept>(this.jurisdiction) && !this.jurisdiction.isEmpty();
  }

  /**
   * @returns the \`status\` property value as a CodeableConcept object if defined; else null
   */
  public getStatus(): CodeableConcept | null {
    return this.status;
  }

  /**
   * Assigns the provided CodeableConcept object value to the \`status\` property.
   *
   * @param value - the \`status\` object value
   * @returns this
   */
  public setStatus(value: CodeableConcept): this {
    assertIsDefined<CodeableConcept>(value, \`MarketingStatus.status is required\`);
    const optErrMsg = \`Invalid MarketingStatus.status; Provided element is not an instance of CodeableConcept.\`;
    assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
    this.status = value;
    return this;
  }

  /**
   * @returns \`true\` if the \`status\` property exists and has a value; \`false\` otherwise
   */
  public hasStatus(): boolean {
    return isDefined<CodeableConcept>(this.status) && !this.status.isEmpty();
  }

  /**
   * @returns the \`dateRange\` property value as a Period object if defined; else an empty Period object
   */
  public getDateRange(): Period {
    return this.dateRange ?? new Period();
  }

  /**
   * Assigns the provided DateRange object value to the \`dateRange\` property.
   *
   * @param value - the \`dateRange\` object value
   * @returns this
   */
  public setDateRange(value: Period | undefined): this {
    if (isDefined<Period>(value)) {
      const optErrMsg = \`Invalid MarketingStatus.dateRange; Provided element is not an instance of Period.\`;
      assertFhirType<Period>(value, Period, optErrMsg);
      this.dateRange = value;
    } else {
      this.dateRange = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`dateRange\` property exists and has a value; \`false\` otherwise
   */
  public hasDateRange(): boolean {
    return isDefined<Period>(this.dateRange) && !this.dateRange.isEmpty();
  }

  /**
   * @returns the \`restoreDate\` property value as a DateTimeType object if defined; else an empty DateTimeType object
   */
  public getRestoreDateElement(): DateTimeType {
    return this.restoreDate ?? new DateTimeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`restoreDate\` property.
   *
   * @param element - the \`restoreDate\` value
   * @returns this
   */
  public setRestoreDateElement(element: DateTimeType | undefined): this {
    if (isDefined<DateTimeType>(element)) {
      const optErrMsg = \`Invalid MarketingStatus.restoreDate; Provided element is not an instance of DateTimeType.\`;
      assertFhirType<DateTimeType>(element, DateTimeType, optErrMsg);
      this.restoreDate = element;
    } else {
      this.restoreDate = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`restoreDate\` property exists and has a value; \`false\` otherwise
   */
  public hasRestoreDateElement(): boolean {
    return isDefined<DateTimeType>(this.restoreDate) && !this.restoreDate.isEmpty();
  }

  /**
   * @returns the \`restoreDate\` property value as a fhirDateTime if defined; else undefined
   */
  public getRestoreDate(): fhirDateTime | undefined {
    return this.restoreDate?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`restoreDate\` property.
   *
   * @param value - the \`restoreDate\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setRestoreDate(value: fhirDateTime | undefined): this {
    if (isDefined<fhirDateTime>(value)) {
      const optErrMsg = \`Invalid MarketingStatus.restoreDate (\${String(value)})\`;
      this.restoreDate = new DateTimeType(parseFhirPrimitiveData(value, fhirDateTimeSchema, optErrMsg));
    } else {
      this.restoreDate = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`restoreDate\` property exists and has a value; \`false\` otherwise
   */
  public hasRestoreDate(): boolean {
    return this.hasRestoreDateElement();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'MarketingStatus';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.country,
      this.jurisdiction,
      this.status,
      this.dateRange,
      this.restoreDate,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): MarketingStatus {
    const dest = new MarketingStatus();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: MarketingStatus): void {
    super.copyValues(dest);
    dest.country = this.country?.copy();
    dest.jurisdiction = this.jurisdiction?.copy();
    dest.status = this.status ? this.status.copy() : null;
    dest.dateRange = this.dateRange?.copy();
    dest.restoreDate = this.restoreDate?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasCountry()) {
      setFhirComplexJson(this.getCountry(), 'country', jsonObj);
    }

    if (this.hasJurisdiction()) {
      setFhirComplexJson(this.getJurisdiction(), 'jurisdiction', jsonObj);
    }

    if (this.hasStatus()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirComplexJson(this.getStatus()!, 'status', jsonObj);
    } else {
      missingReqdProperties.push(\`MarketingStatus.status\`);
    }

    if (this.hasDateRange()) {
      setFhirComplexJson(this.getDateRange(), 'dateRange', jsonObj);
    }

    if (this.hasRestoreDateElement()) {
      setFhirPrimitiveJson<fhirDateTime>(this.getRestoreDateElement(), 'restoreDate', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "MarketingStatus",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 45`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * Meta Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/Meta
 * StructureDefinition.name: Meta
 * StructureDefinition.description: Base StructureDefinition for Meta Type: The metadata about a resource. This is content in the resource that is maintained by the infrastructure. Changes to the content might not always be associated with version changes to the resource.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  CanonicalType,
  DataType,
  FhirDataTypeParser,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  IdType,
  InstantType,
  JSON,
  PrimitiveTypeJson,
  UriType,
  assertFhirType,
  assertFhirTypeList,
  copyListValues,
  fhirCanonical,
  fhirCanonicalSchema,
  fhirId,
  fhirIdSchema,
  fhirInstant,
  fhirInstantSchema,
  fhirUri,
  fhirUriSchema,
  getPrimitiveTypeJson,
  getPrimitiveTypeListJson,
  isDefined,
  isDefinedList,
  isElementEmpty,
  isEmpty,
  parseCanonicalType,
  parseFhirPrimitiveData,
  parseIdType,
  parseInstantType,
  parseUriType,
  setFhirComplexListJson,
  setFhirPrimitiveJson,
  setFhirPrimitiveListJson,
} from '@paq-ts-fhir/fhir-core';
import {
  Coding,
  PARSABLE_DATATYPE_MAP,
} from '../index';

/**
 * Meta Class
 *
 * @remarks
 * Base StructureDefinition for Meta Type: The metadata about a resource. This is content in the resource that is maintained by the infrastructure. Changes to the content might not always be associated with version changes to the resource.
 *
 * **FHIR Specification**
 * - **Short:** Metadata about a resource
 * - **Definition:** The metadata about a resource. This is content in the resource that is maintained by the infrastructure. Changes to the content might not always be associated with version changes to the resource.
 * - **FHIR Version:** 4.0.1
 *
 * @category DataModel: ComplexType
 * @see [FHIR Meta](http://hl7.org/fhir/StructureDefinition/Meta)
 */
export class Meta extends DataType implements IBase {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`Meta\` JSON to instantiate the Meta data model.
   *
   * @param sourceJson - JSON representing FHIR \`Meta\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Meta
   * @returns Meta data model or undefined for \`Meta\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Meta | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Meta';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Meta();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'versionId';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: IdType | undefined = parseIdType(dtJson, dtSiblingJson);
      instance.setVersionIdElement(datatype);
    }

    fieldName = 'lastUpdated';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: InstantType | undefined = parseInstantType(dtJson, dtSiblingJson);
      instance.setLastUpdatedElement(datatype);
    }

    fieldName = 'source';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = parseUriType(dtJson, dtSiblingJson);
      instance.setSourceElement(datatype);
    }

    fieldName = 'profile';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: CanonicalType | undefined = parseCanonicalType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addProfileElement(datatype);
        }
      });
    }

    fieldName = 'security';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Coding | undefined = fhirDataTypeParser.parser<Coding>(Coding, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addSecurity(datatype);
        }
      });
    }

    fieldName = 'tag';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Coding | undefined = fhirDataTypeParser.parser<Coding>(Coding, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addTag(datatype);
        }
      });
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Meta.versionId Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Version specific identifier
   * - **Definition:** The version specific identifier, as it appears in the version portion of the URL. This value changes when the resource is created, updated, or deleted.
   * - **Comment:** The server assigns this value, and ignores what the client specifies, except in the case that the server is imposing version integrity on updates/deletes.
   * - **FHIR Type:** \`id\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private versionId?: IdType | undefined;

  /**
   * Meta.lastUpdated Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** When the resource version last changed
   * - **Definition:** When the resource last changed - e.g. when the version changed.
   * - **Comment:** This value is always populated except when the resource is first being created. The server / resource manager sets this value; what a client provides is irrelevant. This is equivalent to the HTTP Last-Modified and SHOULD have the same value on a [read](https://hl7.org/fhir/http.html#read) interaction.
   * - **FHIR Type:** \`instant\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private lastUpdated?: InstantType | undefined;

  /**
   * Meta.source Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Identifies where the resource comes from
   * - **Definition:** A uri that identifies the source system of the resource. This provides a minimal amount of [Provenance](https://hl7.org/fhir/provenance.html#) information that can be used to track or differentiate the source of information in the resource. The source may identify another FHIR server, document, message, database, etc.
   * - **Comment:** In the provenance resource, this corresponds to Provenance.entity.what[x]. The exact use of the source (and the implied Provenance.entity.role) is left to implementer discretion. Only one nominated source is allowed; for additional provenance details, a full Provenance resource should be used.  This element can be used to indicate where the current master source of a resource that has a canonical URL if the resource is no longer hosted at the canonical URL.
   * - **FHIR Type:** \`uri\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private source?: UriType | undefined;

  /**
   * Meta.profile Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Profiles this resource claims to conform to
   * - **Definition:** A list of profiles (references to [StructureDefinition](https://hl7.org/fhir/structuredefinition.html#) resources) that this resource claims to conform to. The URL is a reference to [StructureDefinition.url](https://hl7.org/fhir/structuredefinition-definitions.html#StructureDefinition.url).
   * - **Comment:** It is up to the server and/or other infrastructure of policy to determine whether/how these claims are verified and/or updated over time.  The list of profile URLs is a set.
   * - **FHIR Type:** \`canonical\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/StructureDefinition',
   *     ]
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private profile?: CanonicalType[] | undefined;

  /**
   * Meta.security Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Security Labels applied to this resource
   * - **Definition:** Security labels applied to this resource. These tags connect specific resources to the overall security policy and infrastructure.
   * - **Comment:** The security labels can be updated without changing the stated version of the resource. The list of security labels is a set. Uniqueness is based the system/code, and version and display are ignored.
   * - **FHIR Type:** \`Coding\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private security?: Coding[] | undefined;

  /**
   * Meta.tag Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Tags applied to this resource
   * - **Definition:** Tags applied to this resource. Tags are intended to be used to identify and relate resources to process and workflow, and applications are not required to consider the tags when interpreting the meaning of a resource.
   * - **Comment:** The tags can be updated without changing the stated version of the resource. The list of tags is a set. Uniqueness is based the system/code, and version and display are ignored.
   * - **FHIR Type:** \`Coding\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private tag?: Coding[] | undefined;


  /**
   * @returns the \`versionId\` property value as a IdType object if defined; else an empty IdType object
   */
  public getVersionIdElement(): IdType {
    return this.versionId ?? new IdType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`versionId\` property.
   *
   * @param element - the \`versionId\` value
   * @returns this
   */
  public setVersionIdElement(element: IdType | undefined): this {
    if (isDefined<IdType>(element)) {
      const optErrMsg = \`Invalid Meta.versionId; Provided element is not an instance of IdType.\`;
      assertFhirType<IdType>(element, IdType, optErrMsg);
      this.versionId = element;
    } else {
      this.versionId = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`versionId\` property exists and has a value; \`false\` otherwise
   */
  public hasVersionIdElement(): boolean {
    return isDefined<IdType>(this.versionId) && !this.versionId.isEmpty();
  }

  /**
   * @returns the \`versionId\` property value as a fhirId if defined; else undefined
   */
  public getVersionId(): fhirId | undefined {
    return this.versionId?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`versionId\` property.
   *
   * @param value - the \`versionId\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setVersionId(value: fhirId | undefined): this {
    if (isDefined<fhirId>(value)) {
      const optErrMsg = \`Invalid Meta.versionId (\${String(value)})\`;
      this.versionId = new IdType(parseFhirPrimitiveData(value, fhirIdSchema, optErrMsg));
    } else {
      this.versionId = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`versionId\` property exists and has a value; \`false\` otherwise
   */
  public hasVersionId(): boolean {
    return this.hasVersionIdElement();
  }

  /**
   * @returns the \`lastUpdated\` property value as a InstantType object if defined; else an empty InstantType object
   */
  public getLastUpdatedElement(): InstantType {
    return this.lastUpdated ?? new InstantType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`lastUpdated\` property.
   *
   * @param element - the \`lastUpdated\` value
   * @returns this
   */
  public setLastUpdatedElement(element: InstantType | undefined): this {
    if (isDefined<InstantType>(element)) {
      const optErrMsg = \`Invalid Meta.lastUpdated; Provided element is not an instance of InstantType.\`;
      assertFhirType<InstantType>(element, InstantType, optErrMsg);
      this.lastUpdated = element;
    } else {
      this.lastUpdated = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`lastUpdated\` property exists and has a value; \`false\` otherwise
   */
  public hasLastUpdatedElement(): boolean {
    return isDefined<InstantType>(this.lastUpdated) && !this.lastUpdated.isEmpty();
  }

  /**
   * @returns the \`lastUpdated\` property value as a fhirInstant if defined; else undefined
   */
  public getLastUpdated(): fhirInstant | undefined {
    return this.lastUpdated?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`lastUpdated\` property.
   *
   * @param value - the \`lastUpdated\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setLastUpdated(value: fhirInstant | undefined): this {
    if (isDefined<fhirInstant>(value)) {
      const optErrMsg = \`Invalid Meta.lastUpdated (\${String(value)})\`;
      this.lastUpdated = new InstantType(parseFhirPrimitiveData(value, fhirInstantSchema, optErrMsg));
    } else {
      this.lastUpdated = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`lastUpdated\` property exists and has a value; \`false\` otherwise
   */
  public hasLastUpdated(): boolean {
    return this.hasLastUpdatedElement();
  }

  /**
   * @returns the \`source\` property value as a UriType object if defined; else an empty UriType object
   */
  public getSourceElement(): UriType {
    return this.source ?? new UriType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`source\` property.
   *
   * @param element - the \`source\` value
   * @returns this
   */
  public setSourceElement(element: UriType | undefined): this {
    if (isDefined<UriType>(element)) {
      const optErrMsg = \`Invalid Meta.source; Provided element is not an instance of UriType.\`;
      assertFhirType<UriType>(element, UriType, optErrMsg);
      this.source = element;
    } else {
      this.source = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`source\` property exists and has a value; \`false\` otherwise
   */
  public hasSourceElement(): boolean {
    return isDefined<UriType>(this.source) && !this.source.isEmpty();
  }

  /**
   * @returns the \`source\` property value as a fhirUri if defined; else undefined
   */
  public getSource(): fhirUri | undefined {
    return this.source?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`source\` property.
   *
   * @param value - the \`source\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setSource(value: fhirUri | undefined): this {
    if (isDefined<fhirUri>(value)) {
      const optErrMsg = \`Invalid Meta.source (\${String(value)})\`;
      this.source = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    } else {
      this.source = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`source\` property exists and has a value; \`false\` otherwise
   */
  public hasSource(): boolean {
    return this.hasSourceElement();
  }

  /**
   * @returns the \`profile\` property value as a CanonicalType array
   */
  public getProfileElement(): CanonicalType[] {
    return this.profile ?? ([] as CanonicalType[]);
  }

  /**
   * Assigns the provided CanonicalType array value to the \`profile\` property.
   *
   * @param element - the \`profile\` array value
   * @returns this
   */
  public setProfileElement(element: CanonicalType[] | undefined): this {
    if (isDefinedList<CanonicalType>(element)) {
      const optErrMsg = \`Invalid Meta.profile; Provided value array has an element that is not an instance of CanonicalType.\`;
      assertFhirTypeList<CanonicalType>(element, CanonicalType, optErrMsg);
      this.profile = element;
    } else {
      this.profile = undefined;
    }
    return this;
  }

  /**
   * Add the provided CanonicalType value to the \`profile\` array property.
   *
   * @param element - the \`profile\` value
   * @returns this
   */
  public addProfileElement(element: CanonicalType | undefined): this {
    if (isDefined<CanonicalType>(element)) {
      const optErrMsg = \`Invalid Meta.profile; Provided element is not an instance of CanonicalType.\`;
      assertFhirType<CanonicalType>(element, CanonicalType, optErrMsg);
      this.initProfile();
      this.profile?.push(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`profile\` property exists and has a value; \`false\` otherwise
   */
  public hasProfileElement(): boolean {
    return isDefinedList<CanonicalType>(this.profile) && this.profile.some((item: CanonicalType) => !item.isEmpty());
  }

  /**
   * @returns the \`profile\` property value as a fhirCanonical array
   */
  public getProfile(): fhirCanonical[] {
    this.initProfile();
    const profileValues = [] as fhirCanonical[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.profile!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        profileValues.push(value);
      }
    }
    return profileValues;
  }

  /**
   * Assigns the provided primitive value array to the \`profile\` property.
   *
   * @param value - the \`profile\` value array
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setProfile(value: fhirCanonical[] | undefined): this {
    if (isDefinedList<fhirCanonical>(value)) {
      const profileElements = [] as CanonicalType[];
      for (const profileValue of value) {
        const optErrMsg = \`Invalid Meta.profile array item (\${String(profileValue)})\`;
        const element = new CanonicalType(parseFhirPrimitiveData(profileValue, fhirCanonicalSchema, optErrMsg));
        profileElements.push(element);
      }
      this.profile = profileElements;
    } else {
      this.profile = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`profile\` array property.
   *
   * @param value - the \`profile\` value
   * @returns this
   */
  public addProfile(value: fhirCanonical | undefined): this {
    if (isDefined<fhirCanonical>(value)) {
      const optErrMsg = \`Invalid Meta.profile array item (\${String(value)})\`;
      const element = new CanonicalType(parseFhirPrimitiveData(value, fhirCanonicalSchema, optErrMsg));
      this.initProfile();
      this.addProfileElement(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`profile\` property exists and has a value; \`false\` otherwise
   */
  public hasProfile(): boolean {
    return this.hasProfileElement();
  }

  /**
   * Initialize the \`profile\` property
   */
  private initProfile(): void {
    if (!this.hasProfile()) {
      this.profile = [] as CanonicalType[];
    }
  }

  /**
   * @returns the \`security\` property value as a Coding array
   */
  public getSecurity(): Coding[] {
    return this.security ?? ([] as Coding[]);
  }

  /**
   * Assigns the provided Coding array value to the \`security\` property.
   *
   * @param value - the \`security\` array value
   * @returns this
   */
  public setSecurity(value: Coding[] | undefined): this {
    if (isDefinedList<Coding>(value)) {
      const optErrMsg = \`Invalid Meta.security; Provided value array has an element that is not an instance of Coding.\`;
      assertFhirTypeList<Coding>(value, Coding, optErrMsg);
      this.security = value;
    } else {
      this.security = undefined;
    }
    return this;
  }

  /**
   * Add the provided Coding value to the \`security\` array property.
   *
   * @param value - the \`security\` value
   * @returns this
   */
  public addSecurity(value: Coding | undefined): this {
    if (isDefined<Coding>(value)) {
      const optErrMsg = \`Invalid Meta.security; Provided element is not an instance of Coding.\`;
      assertFhirType<Coding>(value, Coding, optErrMsg);
      this.initSecurity();
      this.security?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`security\` property exists and has a value; \`false\` otherwise
   */
  public hasSecurity(): boolean {
    return isDefinedList<Coding>(this.security) && this.security.some((item: Coding) => !item.isEmpty());
  }

  /**
   * Initialize the \`security\` property
   */
  private initSecurity(): void {
    if(!this.hasSecurity()) {
      this.security = [] as Coding[];
    }
  }

  /**
   * @returns the \`tag\` property value as a Coding array
   */
  public getTag(): Coding[] {
    return this.tag ?? ([] as Coding[]);
  }

  /**
   * Assigns the provided Coding array value to the \`tag\` property.
   *
   * @param value - the \`tag\` array value
   * @returns this
   */
  public setTag(value: Coding[] | undefined): this {
    if (isDefinedList<Coding>(value)) {
      const optErrMsg = \`Invalid Meta.tag; Provided value array has an element that is not an instance of Coding.\`;
      assertFhirTypeList<Coding>(value, Coding, optErrMsg);
      this.tag = value;
    } else {
      this.tag = undefined;
    }
    return this;
  }

  /**
   * Add the provided Coding value to the \`tag\` array property.
   *
   * @param value - the \`tag\` value
   * @returns this
   */
  public addTag(value: Coding | undefined): this {
    if (isDefined<Coding>(value)) {
      const optErrMsg = \`Invalid Meta.tag; Provided element is not an instance of Coding.\`;
      assertFhirType<Coding>(value, Coding, optErrMsg);
      this.initTag();
      this.tag?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`tag\` property exists and has a value; \`false\` otherwise
   */
  public hasTag(): boolean {
    return isDefinedList<Coding>(this.tag) && this.tag.some((item: Coding) => !item.isEmpty());
  }

  /**
   * Initialize the \`tag\` property
   */
  private initTag(): void {
    if(!this.hasTag()) {
      this.tag = [] as Coding[];
    }
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Meta';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.versionId,
      this.lastUpdated,
      this.source,
      this.profile,
      this.security,
      this.tag,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Meta {
    const dest = new Meta();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Meta): void {
    super.copyValues(dest);
    dest.versionId = this.versionId?.copy();
    dest.lastUpdated = this.lastUpdated?.copy();
    dest.source = this.source?.copy();
    const profileList = copyListValues<CanonicalType>(this.profile);
    dest.profile = profileList.length === 0 ? undefined : profileList;
    const securityList = copyListValues<Coding>(this.security);
    dest.security = securityList.length === 0 ? undefined : securityList;
    const tagList = copyListValues<Coding>(this.tag);
    dest.tag = tagList.length === 0 ? undefined : tagList;
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasVersionIdElement()) {
      setFhirPrimitiveJson<fhirId>(this.getVersionIdElement(), 'versionId', jsonObj);
    }

    if (this.hasLastUpdatedElement()) {
      setFhirPrimitiveJson<fhirInstant>(this.getLastUpdatedElement(), 'lastUpdated', jsonObj);
    }

    if (this.hasSourceElement()) {
      setFhirPrimitiveJson<fhirUri>(this.getSourceElement(), 'source', jsonObj);
    }

    if (this.hasProfile()) {
      setFhirPrimitiveListJson(this.getProfileElement(), 'profile', jsonObj);
    }

    if (this.hasSecurity()) {
      setFhirComplexListJson(this.getSecurity(), 'security', jsonObj);
    }

    if (this.hasTag()) {
      setFhirComplexListJson(this.getTag(), 'tag', jsonObj);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "Meta",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 46`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * MonetaryComponent Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/MonetaryComponent
 * StructureDefinition.name: MonetaryComponent
 * StructureDefinition.description: MonetaryComponent Type: Availability data for an {item}.
 * StructureDefinition.fhirVersion: 5.0.0
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  CodeType,
  DataType,
  DecimalType,
  EnumCodeType,
  FhirDataTypeParser,
  FhirError,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  REQUIRED_PROPERTIES_DO_NOT_EXIST,
  REQUIRED_PROPERTIES_REQD_IN_JSON,
  assertEnumCodeType,
  assertFhirType,
  assertIsDefined,
  constructorCodeValueAsEnumCodeType,
  fhirCode,
  fhirCodeSchema,
  fhirDecimal,
  fhirDecimalSchema,
  getPrimitiveTypeJson,
  isDefined,
  isElementEmpty,
  isEmpty,
  parseCodeType,
  parseDecimalType,
  parseFhirPrimitiveData,
  setFhirComplexJson,
  setFhirPrimitiveJson,
} from '@paq-ts-fhir/fhir-core';
import {
  CodeableConcept,
  Money,
  PARSABLE_DATATYPE_MAP,
  PriceComponentTypeEnum,
} from '../index';

/**
 * MonetaryComponent Class
 *
 * @remarks
 * MonetaryComponent Type: Availability data for an {item}.
 *
 * **FHIR Specification**
 * - **Short:** Availability data for an {item}
 * - **Definition:** Availability data for an {item}.
 * - **FHIR Version:** 5.0.0
 *
 * @category DataModel: ComplexType
 * @see [FHIR MonetaryComponent](http://hl7.org/fhir/StructureDefinition/MonetaryComponent)
 */
export class MonetaryComponent extends DataType implements IBase {
  constructor(type_: EnumCodeType | CodeType | null = null) {
    super();

    this.priceComponentTypeEnum = new PriceComponentTypeEnum();

    this.type_ = constructorCodeValueAsEnumCodeType<PriceComponentTypeEnum>(
      type_,
      PriceComponentTypeEnum,
      this.priceComponentTypeEnum,
      '.type',
    );
  }

  /**
   * Parse the provided \`MonetaryComponent\` JSON to instantiate the MonetaryComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`MonetaryComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to MonetaryComponent
   * @returns MonetaryComponent data model or undefined for \`MonetaryComponent\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): MonetaryComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'MonetaryComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new MonetaryComponent();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'type';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setTypeElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'code';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = fhirDataTypeParser.parser<CodeableConcept>(CodeableConcept, classJsonObj[fieldName]!, sourceField);
      instance.setCode(datatype);
    }

    fieldName = 'factor';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = parseDecimalType(dtJson, dtSiblingJson);
      instance.setFactorElement(datatype);
    }

    fieldName = 'amount';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Money | undefined = fhirDataTypeParser.parser<Money>(Money, classJsonObj[fieldName]!, sourceField);
      instance.setAmount(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: PriceComponentType
   *
   * @see {@link PriceComponentTypeEnum }
   */
  private readonly priceComponentTypeEnum: PriceComponentTypeEnum;

  /**
   * MonetaryComponent.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** base | surcharge | deduction | discount | tax | informational
   * - **Definition:** base | surcharge | deduction | discount | tax | informational.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private type_: EnumCodeType | null;

  /**
   * MonetaryComponent.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Codes may be used to differentiate between kinds of taxes, surcharges, discounts etc.
   * - **Definition:** Codes may be used to differentiate between kinds of taxes, surcharges, discounts etc.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code?: CodeableConcept | undefined;

  /**
   * MonetaryComponent.factor Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Factor used for calculating this component
   * - **Definition:** Factor used for calculating this component.
   * - **FHIR Type:** \`decimal\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private factor?: DecimalType | undefined;

  /**
   * MonetaryComponent.amount Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Explicit value amount to be used
   * - **Definition:** Explicit value amount to be used.
   * - **FHIR Type:** \`Money\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private amount?: Money | undefined;


  /**
   * @returns the \`type_\` property value as a EnumCodeType if defined; else null
   */
  public getTypeEnumType(): EnumCodeType | null {
    return this.type_;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`type_\` property.
   *
   * @param enumType - the \`type_\` value
   * @returns this
   */
  public setTypeEnumType(enumType: EnumCodeType): this {
    assertIsDefined<EnumCodeType>(enumType, \`MonetaryComponent.type is required\`);
    const errMsgPrefix = \`Invalid MonetaryComponent.type\`;
    assertEnumCodeType<PriceComponentTypeEnum>(enumType, PriceComponentTypeEnum, errMsgPrefix);
    this.type_ = enumType;
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasTypeEnumType(): boolean {
    return isDefined<EnumCodeType>(this.type_) && !this.type_.isEmpty() && this.type_.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`type_\` property value as a CodeType if defined; else null
   */
  public getTypeElement(): CodeType | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_ as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`type_\` property.
   *
   * @param element - the \`type_\` value
   * @returns this
   */
  public setTypeElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, \`MonetaryComponent.type is required\`);
    const optErrMsg = \`Invalid MonetaryComponent.type; Provided value is not an instance of CodeType.\`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.type_ = new EnumCodeType(element, this.priceComponentTypeEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasTypeElement(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the \`type_\` property value as a fhirCode if defined; else null
   */
  public getType(): fhirCode | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`type_\` property.
   *
   * @param value - the \`type_\` value
   * @returns this
   */
  public setType(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, \`MonetaryComponent.type is required\`);
    const optErrMsg = \`Invalid MonetaryComponent.type (\${String(value)})\`;
    this.type_ = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.priceComponentTypeEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasType(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the \`code\` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getCode(): CodeableConcept {
    return this.code ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Code object value to the \`code\` property.
   *
   * @param value - the \`code\` object value
   * @returns this
   */
  public setCode(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid MonetaryComponent.code; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.code = value;
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`code\` property exists and has a value; \`false\` otherwise
   */
  public hasCode(): boolean {
    return isDefined<CodeableConcept>(this.code) && !this.code.isEmpty();
  }

  /**
   * @returns the \`factor\` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getFactorElement(): DecimalType {
    return this.factor ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`factor\` property.
   *
   * @param element - the \`factor\` value
   * @returns this
   */
  public setFactorElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = \`Invalid MonetaryComponent.factor; Provided element is not an instance of DecimalType.\`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.factor = element;
    } else {
      this.factor = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`factor\` property exists and has a value; \`false\` otherwise
   */
  public hasFactorElement(): boolean {
    return isDefined<DecimalType>(this.factor) && !this.factor.isEmpty();
  }

  /**
   * @returns the \`factor\` property value as a fhirDecimal if defined; else undefined
   */
  public getFactor(): fhirDecimal | undefined {
    return this.factor?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`factor\` property.
   *
   * @param value - the \`factor\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setFactor(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = \`Invalid MonetaryComponent.factor (\${String(value)})\`;
      this.factor = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.factor = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`factor\` property exists and has a value; \`false\` otherwise
   */
  public hasFactor(): boolean {
    return this.hasFactorElement();
  }

  /**
   * @returns the \`amount\` property value as a Money object if defined; else an empty Money object
   */
  public getAmount(): Money {
    return this.amount ?? new Money();
  }

  /**
   * Assigns the provided Amount object value to the \`amount\` property.
   *
   * @param value - the \`amount\` object value
   * @returns this
   */
  public setAmount(value: Money | undefined): this {
    if (isDefined<Money>(value)) {
      const optErrMsg = \`Invalid MonetaryComponent.amount; Provided element is not an instance of Money.\`;
      assertFhirType<Money>(value, Money, optErrMsg);
      this.amount = value;
    } else {
      this.amount = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`amount\` property exists and has a value; \`false\` otherwise
   */
  public hasAmount(): boolean {
    return isDefined<Money>(this.amount) && !this.amount.isEmpty();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'MonetaryComponent';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.type_,
      this.code,
      this.factor,
      this.amount,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): MonetaryComponent {
    const dest = new MonetaryComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: MonetaryComponent): void {
    super.copyValues(dest);
    dest.type_ = this.type_ ? this.type_.copy() : null;
    dest.code = this.code?.copy();
    dest.factor = this.factor?.copy();
    dest.amount = this.amount?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasTypeElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getTypeElement()!, 'type', jsonObj);
    } else {
      missingReqdProperties.push(\`MonetaryComponent.type\`);
    }

    if (this.hasCode()) {
      setFhirComplexJson(this.getCode(), 'code', jsonObj);
    }

    if (this.hasFactorElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getFactorElement(), 'factor', jsonObj);
    }

    if (this.hasAmount()) {
      setFhirComplexJson(this.getAmount(), 'amount', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "MonetaryComponent",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 47`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * Money Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/Money
 * StructureDefinition.name: Money
 * StructureDefinition.description: Money Type: An amount of economic utility in some recognized currency.
 * StructureDefinition.fhirVersion: 5.0.0
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  CodeType,
  DataType,
  DecimalType,
  FhirDataTypeParser,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  assertFhirType,
  fhirCode,
  fhirCodeSchema,
  fhirDecimal,
  fhirDecimalSchema,
  getPrimitiveTypeJson,
  isDefined,
  isElementEmpty,
  isEmpty,
  parseCodeType,
  parseDecimalType,
  parseFhirPrimitiveData,
  setFhirPrimitiveJson,
} from '@paq-ts-fhir/fhir-core';
import {
  PARSABLE_DATATYPE_MAP,
} from '../index';

/**
 * Money Class
 *
 * @remarks
 * Money Type: An amount of economic utility in some recognized currency.
 *
 * **FHIR Specification**
 * - **Short:** An amount of economic utility in some recognized currency
 * - **Definition:** An amount of economic utility in some recognized currency.
 * - **FHIR Version:** 5.0.0
 *
 * @category DataModel: ComplexType
 * @see [FHIR Money](http://hl7.org/fhir/StructureDefinition/Money)
 */
export class Money extends DataType implements IBase {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`Money\` JSON to instantiate the Money data model.
   *
   * @param sourceJson - JSON representing FHIR \`Money\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Money
   * @returns Money data model or undefined for \`Money\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Money | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Money';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Money();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'value';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = parseDecimalType(dtJson, dtSiblingJson);
      instance.setValueElement(datatype);
    }

    fieldName = 'currency';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      instance.setCurrencyElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Money.value Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Numerical value (with implicit precision)
   * - **Definition:** Numerical value (with implicit precision).
   * - **Comment:** Monetary values have their own rules for handling precision (refer to standard accounting text books).
   * - **Requirements:** The amount of the currency. The value includes an implicit precision in the presentation of the value.
   * - **FHIR Type:** \`decimal\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private value?: DecimalType | undefined;

  /**
   * Money.currency Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** ISO 4217 Currency Code
   * - **Definition:** ISO 4217 Currency Code.
   * - **Requirements:** A code indicating the currency, taken from ISO 4217.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private currency?: CodeType | undefined;


  /**
   * @returns the \`value\` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getValueElement(): DecimalType {
    return this.value ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`value\` property.
   *
   * @param element - the \`value\` value
   * @returns this
   */
  public setValueElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = \`Invalid Money.value; Provided element is not an instance of DecimalType.\`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.value = element;
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`value\` property exists and has a value; \`false\` otherwise
   */
  public hasValueElement(): boolean {
    return isDefined<DecimalType>(this.value) && !this.value.isEmpty();
  }

  /**
   * @returns the \`value\` property value as a fhirDecimal if defined; else undefined
   */
  public getValue(): fhirDecimal | undefined {
    return this.value?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`value\` property.
   *
   * @param value - the \`value\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setValue(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = \`Invalid Money.value (\${String(value)})\`;
      this.value = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`value\` property exists and has a value; \`false\` otherwise
   */
  public hasValue(): boolean {
    return this.hasValueElement();
  }

  /**
   * @returns the \`currency\` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getCurrencyElement(): CodeType {
    return this.currency ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`currency\` property.
   *
   * @param element - the \`currency\` value
   * @returns this
   */
  public setCurrencyElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Money.currency; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.currency = element;
    } else {
      this.currency = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`currency\` property exists and has a value; \`false\` otherwise
   */
  public hasCurrencyElement(): boolean {
    return isDefined<CodeType>(this.currency) && !this.currency.isEmpty();
  }

  /**
   * @returns the \`currency\` property value as a fhirCode if defined; else undefined
   */
  public getCurrency(): fhirCode | undefined {
    return this.currency?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`currency\` property.
   *
   * @param value - the \`currency\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setCurrency(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Money.currency (\${String(value)})\`;
      this.currency = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.currency = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`currency\` property exists and has a value; \`false\` otherwise
   */
  public hasCurrency(): boolean {
    return this.hasCurrencyElement();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Money';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.value,
      this.currency,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Money {
    const dest = new Money();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Money): void {
    super.copyValues(dest);
    dest.value = this.value?.copy();
    dest.currency = this.currency?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasValueElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getValueElement(), 'value', jsonObj);
    }

    if (this.hasCurrencyElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getCurrencyElement(), 'currency', jsonObj);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "Money",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 48`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * Narrative Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/Narrative
 * StructureDefinition.name: Narrative
 * StructureDefinition.description: Base StructureDefinition for Narrative Type: A human-readable summary of the resource conveying the essential clinical and business information for the resource.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  CodeType,
  DataType,
  EnumCodeType,
  FhirDataTypeParser,
  FhirError,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  PrimitiveType,
  REQUIRED_PROPERTIES_DO_NOT_EXIST,
  REQUIRED_PROPERTIES_REQD_IN_JSON,
  XhtmlType,
  assertEnumCodeType,
  assertFhirType,
  assertIsDefined,
  constructorCodeValueAsEnumCodeType,
  fhirCode,
  fhirCodeSchema,
  fhirXhtml,
  fhirXhtmlSchema,
  getPrimitiveTypeJson,
  isDefined,
  isElementEmpty,
  isEmpty,
  parseCodeType,
  parseFhirPrimitiveData,
  parseXhtmlType,
  setFhirPrimitiveJson,
} from '@paq-ts-fhir/fhir-core';
import {
  NarrativeStatusEnum,
  PARSABLE_DATATYPE_MAP,
} from '../index';

/**
 * Narrative Class
 *
 * @remarks
 * Base StructureDefinition for Narrative Type: A human-readable summary of the resource conveying the essential clinical and business information for the resource.
 *
 * **FHIR Specification**
 * - **Short:** Human-readable summary of the resource (essential clinical and business information)
 * - **Definition:** A human-readable summary of the resource conveying the essential clinical and business information for the resource.
 * - **FHIR Version:** 4.0.1
 *
 * @category DataModel: ComplexType
 * @see [FHIR Narrative](http://hl7.org/fhir/StructureDefinition/Narrative)
 */
export class Narrative extends DataType implements IBase {
  constructor(status: EnumCodeType | CodeType | null = null, div: XhtmlType | fhirXhtml | null = null) {
    super();

    this.narrativeStatusEnum = new NarrativeStatusEnum();

    this.status = constructorCodeValueAsEnumCodeType<NarrativeStatusEnum>(
      status,
      NarrativeStatusEnum,
      this.narrativeStatusEnum,
      '.status',
    );

    this.div = null;
    if (isDefined<XhtmlType | fhirXhtml>(div)) {
      if (div instanceof PrimitiveType) {
        this.setDivElement(div);
      } else {
        this.setDiv(div);
      }
    }
  }

  /**
   * Parse the provided \`Narrative\` JSON to instantiate the Narrative data model.
   *
   * @param sourceJson - JSON representing FHIR \`Narrative\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Narrative
   * @returns Narrative data model or undefined for \`Narrative\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Narrative | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Narrative';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Narrative();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'status';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setStatusElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'div';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: XhtmlType | undefined = parseXhtmlType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setDivElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: NarrativeStatus
   *
   * @see {@link NarrativeStatusEnum }
   */
  private readonly narrativeStatusEnum: NarrativeStatusEnum;

  /**
   * Narrative.status Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** generated | extensions | additional | empty
   * - **Definition:** The status of the narrative - whether it\\'s entirely generated (from just the defined data or the extensions too), or whether a human authored it and it may contain additional data.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private status: EnumCodeType | null;

  /**
   * Narrative.div Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Limited xhtml content
   * - **Definition:** The actual narrative content, a stripped down version of XHTML.
   * - **Comment:** The contents of the html element are an XHTML fragment containing only the basic html formatting elements described in chapters 7-11 and 15 of the HTML 4.0 standard, <a> elements (either name or href), images and internally contained stylesheets. The XHTML content SHALL NOT contain a head, a body, external stylesheet references, scripts, forms, base/link/xlink, frames, iframes and objects.
   * - **FHIR Type:** \`xhtml\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private div: XhtmlType | null;


  /**
   * @returns the \`status\` property value as a EnumCodeType if defined; else null
   */
  public getStatusEnumType(): EnumCodeType | null {
    return this.status;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`status\` property.
   *
   * @param enumType - the \`status\` value
   * @returns this
   */
  public setStatusEnumType(enumType: EnumCodeType): this {
    assertIsDefined<EnumCodeType>(enumType, \`Narrative.status is required\`);
    const errMsgPrefix = \`Invalid Narrative.status\`;
    assertEnumCodeType<NarrativeStatusEnum>(enumType, NarrativeStatusEnum, errMsgPrefix);
    this.status = enumType;
    return this;
  }

  /**
   * @returns \`true\` if the \`status\` property exists and has a value; \`false\` otherwise
   */
  public hasStatusEnumType(): boolean {
    return isDefined<EnumCodeType>(this.status) && !this.status.isEmpty() && this.status.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`status\` property value as a CodeType if defined; else null
   */
  public getStatusElement(): CodeType | null {
    if (this.status === null) {
      return null;
    }
    return this.status as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`status\` property.
   *
   * @param element - the \`status\` value
   * @returns this
   */
  public setStatusElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, \`Narrative.status is required\`);
    const optErrMsg = \`Invalid Narrative.status; Provided value is not an instance of CodeType.\`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.status = new EnumCodeType(element, this.narrativeStatusEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`status\` property exists and has a value; \`false\` otherwise
   */
  public hasStatusElement(): boolean {
    return this.hasStatusEnumType();
  }

  /**
   * @returns the \`status\` property value as a fhirCode if defined; else null
   */
  public getStatus(): fhirCode | null {
    if (this.status === null) {
      return null;
    }
    return this.status.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`status\` property.
   *
   * @param value - the \`status\` value
   * @returns this
   */
  public setStatus(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, \`Narrative.status is required\`);
    const optErrMsg = \`Invalid Narrative.status (\${String(value)})\`;
    this.status = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.narrativeStatusEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`status\` property exists and has a value; \`false\` otherwise
   */
  public hasStatus(): boolean {
    return this.hasStatusEnumType();
  }

  /**
   * @returns the \`div\` property value as a XhtmlType object if defined; else null
   */
  public getDivElement(): XhtmlType | null {
    return this.div;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`div\` property.
   *
   * @param element - the \`div\` value
   * @returns this
   */
  public setDivElement(element: XhtmlType): this {
    assertIsDefined<XhtmlType>(element, \`Narrative.div is required\`);
    const optErrMsg = \`Invalid Narrative.div; Provided value is not an instance of XhtmlType.\`;
    assertFhirType<XhtmlType>(element, XhtmlType, optErrMsg);
    this.div = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`div\` property exists and has a value; \`false\` otherwise
   */
  public hasDivElement(): boolean {
    return isDefined<XhtmlType>(this.div) && !this.div.isEmpty();
  }

  /**
   * @returns the \`div\` property value as a fhirXhtml if defined; else null
   */
  public getDiv(): fhirXhtml | null {
    if (this.div?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.div.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`div\` property.
   *
   * @param value - the \`div\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setDiv(value: fhirXhtml): this {
    assertIsDefined<fhirXhtml>(value, \`Narrative.div is required\`);
    const optErrMsg = \`Invalid Narrative.div (\${String(value)})\`;
    this.div = new XhtmlType(parseFhirPrimitiveData(value, fhirXhtmlSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`div\` property exists and has a value; \`false\` otherwise
   */
  public hasDiv(): boolean {
    return this.hasDivElement();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Narrative';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.status,
      this.div,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Narrative {
    const dest = new Narrative();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Narrative): void {
    super.copyValues(dest);
    dest.status = this.status ? this.status.copy() : null;
    dest.div = this.div ? this.div.copy() : null;
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasStatusElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getStatusElement()!, 'status', jsonObj);
    } else {
      missingReqdProperties.push(\`Narrative.status\`);
    }

    if (this.hasDivElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirXhtml>(this.getDivElement()!, 'div', jsonObj);
    } else {
      missingReqdProperties.push(\`Narrative.div\`);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "Narrative",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 49`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * ParameterDefinition Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/ParameterDefinition
 * StructureDefinition.name: ParameterDefinition
 * StructureDefinition.description: ParameterDefinition Type: The parameters to the module. This collection specifies both the input and output parameters. Input parameters are provided by the caller as part of the $evaluate operation. Output parameters are included in the GuidanceResponse.
 * StructureDefinition.fhirVersion: 5.0.0
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  CanonicalType,
  CodeType,
  DataType,
  EnumCodeType,
  FhirDataTypeParser,
  FhirError,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  IntegerType,
  JSON,
  PrimitiveType,
  REQUIRED_PROPERTIES_DO_NOT_EXIST,
  REQUIRED_PROPERTIES_REQD_IN_JSON,
  StringType,
  assertEnumCodeType,
  assertFhirType,
  assertIsDefined,
  constructorCodeValueAsEnumCodeType,
  fhirCanonical,
  fhirCanonicalSchema,
  fhirCode,
  fhirCodeSchema,
  fhirInteger,
  fhirIntegerSchema,
  fhirString,
  fhirStringSchema,
  getPrimitiveTypeJson,
  isDefined,
  isElementEmpty,
  isEmpty,
  parseCanonicalType,
  parseCodeType,
  parseFhirPrimitiveData,
  parseIntegerType,
  parseStringType,
  setFhirPrimitiveJson,
} from '@paq-ts-fhir/fhir-core';
import {
  OperationParameterUseEnum,
  PARSABLE_DATATYPE_MAP,
} from '../index';

/**
 * ParameterDefinition Class
 *
 * @remarks
 * ParameterDefinition Type: The parameters to the module. This collection specifies both the input and output parameters. Input parameters are provided by the caller as part of the $evaluate operation. Output parameters are included in the GuidanceResponse.
 *
 * **FHIR Specification**
 * - **Short:** Definition of a parameter to a module
 * - **Definition:** The parameters to the module. This collection specifies both the input and output parameters. Input parameters are provided by the caller as part of the $evaluate operation. Output parameters are included in the GuidanceResponse.
 * - **FHIR Version:** 5.0.0
 *
 * @category DataModel: ComplexType
 * @see [FHIR ParameterDefinition](http://hl7.org/fhir/StructureDefinition/ParameterDefinition)
 */
export class ParameterDefinition extends DataType implements IBase {
  constructor(use: EnumCodeType | CodeType | null = null, type_: CodeType | fhirCode | null = null) {
    super();

    this.operationParameterUseEnum = new OperationParameterUseEnum();

    this.use = constructorCodeValueAsEnumCodeType<OperationParameterUseEnum>(
      use,
      OperationParameterUseEnum,
      this.operationParameterUseEnum,
      '.use',
    );

    this.type_ = null;
    if (isDefined<CodeType | fhirCode>(type_)) {
      if (type_ instanceof PrimitiveType) {
        this.setTypeElement(type_);
      } else {
        this.setType(type_);
      }
    }
  }

  /**
   * Parse the provided \`ParameterDefinition\` JSON to instantiate the ParameterDefinition data model.
   *
   * @param sourceJson - JSON representing FHIR \`ParameterDefinition\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to ParameterDefinition
   * @returns ParameterDefinition data model or undefined for \`ParameterDefinition\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): ParameterDefinition | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'ParameterDefinition';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new ParameterDefinition();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'name';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      instance.setNameElement(datatype);
    }

    fieldName = 'use';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setUseElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'min';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: IntegerType | undefined = parseIntegerType(dtJson, dtSiblingJson);
      instance.setMinElement(datatype);
    }

    fieldName = 'max';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setMaxElement(datatype);
    }

    fieldName = 'documentation';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setDocumentationElement(datatype);
    }

    fieldName = 'type';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setTypeElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'profile';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CanonicalType | undefined = parseCanonicalType(dtJson, dtSiblingJson);
      instance.setProfileElement(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * ParameterDefinition.name Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Name used to access the parameter value
   * - **Definition:** The name of the parameter used to allow access to the value of the parameter in evaluation contexts.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private name?: CodeType | undefined;

  /**
   * FHIR CodeSystem: OperationParameterUse
   *
   * @see {@link OperationParameterUseEnum }
   */
  private readonly operationParameterUseEnum: OperationParameterUseEnum;

  /**
   * ParameterDefinition.use Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** in | out
   * - **Definition:** Whether the parameter is input or output for the module.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private use: EnumCodeType | null;

  /**
   * ParameterDefinition.min Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Minimum cardinality
   * - **Definition:** The minimum number of times this parameter SHALL appear in the request or response.
   * - **FHIR Type:** \`integer\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private min?: IntegerType | undefined;

  /**
   * ParameterDefinition.max Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Maximum cardinality (a number of *)
   * - **Definition:** The maximum number of times this element is permitted to appear in the request or response.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private max?: StringType | undefined;

  /**
   * ParameterDefinition.documentation Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A brief description of the parameter
   * - **Definition:** A brief discussion of what the parameter is for and how it is used by the module.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private documentation?: StringType | undefined;

  /**
   * ParameterDefinition.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** What type of value
   * - **Definition:** The type of the parameter.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private type_: CodeType | null;

  /**
   * ParameterDefinition.profile Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** What profile the value is expected to be
   * - **Definition:** If specified, this indicates a profile that the input data must conform to, or that the output data will conform to.
   * - **FHIR Type:** \`canonical\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/StructureDefinition',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private profile?: CanonicalType | undefined;


  /**
   * @returns the \`name\` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getNameElement(): CodeType {
    return this.name ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`name\` property.
   *
   * @param element - the \`name\` value
   * @returns this
   */
  public setNameElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid ParameterDefinition.name; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.name = element;
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`name\` property exists and has a value; \`false\` otherwise
   */
  public hasNameElement(): boolean {
    return isDefined<CodeType>(this.name) && !this.name.isEmpty();
  }

  /**
   * @returns the \`name\` property value as a fhirCode if defined; else undefined
   */
  public getName(): fhirCode | undefined {
    return this.name?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`name\` property.
   *
   * @param value - the \`name\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setName(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid ParameterDefinition.name (\${String(value)})\`;
      this.name = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`name\` property exists and has a value; \`false\` otherwise
   */
  public hasName(): boolean {
    return this.hasNameElement();
  }

  /**
   * @returns the \`use\` property value as a EnumCodeType if defined; else null
   */
  public getUseEnumType(): EnumCodeType | null {
    return this.use;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`use\` property.
   *
   * @param enumType - the \`use\` value
   * @returns this
   */
  public setUseEnumType(enumType: EnumCodeType): this {
    assertIsDefined<EnumCodeType>(enumType, \`ParameterDefinition.use is required\`);
    const errMsgPrefix = \`Invalid ParameterDefinition.use\`;
    assertEnumCodeType<OperationParameterUseEnum>(enumType, OperationParameterUseEnum, errMsgPrefix);
    this.use = enumType;
    return this;
  }

  /**
   * @returns \`true\` if the \`use\` property exists and has a value; \`false\` otherwise
   */
  public hasUseEnumType(): boolean {
    return isDefined<EnumCodeType>(this.use) && !this.use.isEmpty() && this.use.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`use\` property value as a CodeType if defined; else null
   */
  public getUseElement(): CodeType | null {
    if (this.use === null) {
      return null;
    }
    return this.use as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`use\` property.
   *
   * @param element - the \`use\` value
   * @returns this
   */
  public setUseElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, \`ParameterDefinition.use is required\`);
    const optErrMsg = \`Invalid ParameterDefinition.use; Provided value is not an instance of CodeType.\`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.use = new EnumCodeType(element, this.operationParameterUseEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`use\` property exists and has a value; \`false\` otherwise
   */
  public hasUseElement(): boolean {
    return this.hasUseEnumType();
  }

  /**
   * @returns the \`use\` property value as a fhirCode if defined; else null
   */
  public getUse(): fhirCode | null {
    if (this.use === null) {
      return null;
    }
    return this.use.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`use\` property.
   *
   * @param value - the \`use\` value
   * @returns this
   */
  public setUse(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, \`ParameterDefinition.use is required\`);
    const optErrMsg = \`Invalid ParameterDefinition.use (\${String(value)})\`;
    this.use = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.operationParameterUseEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`use\` property exists and has a value; \`false\` otherwise
   */
  public hasUse(): boolean {
    return this.hasUseEnumType();
  }

  /**
   * @returns the \`min\` property value as a IntegerType object if defined; else an empty IntegerType object
   */
  public getMinElement(): IntegerType {
    return this.min ?? new IntegerType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`min\` property.
   *
   * @param element - the \`min\` value
   * @returns this
   */
  public setMinElement(element: IntegerType | undefined): this {
    if (isDefined<IntegerType>(element)) {
      const optErrMsg = \`Invalid ParameterDefinition.min; Provided element is not an instance of IntegerType.\`;
      assertFhirType<IntegerType>(element, IntegerType, optErrMsg);
      this.min = element;
    } else {
      this.min = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`min\` property exists and has a value; \`false\` otherwise
   */
  public hasMinElement(): boolean {
    return isDefined<IntegerType>(this.min) && !this.min.isEmpty();
  }

  /**
   * @returns the \`min\` property value as a fhirInteger if defined; else undefined
   */
  public getMin(): fhirInteger | undefined {
    return this.min?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`min\` property.
   *
   * @param value - the \`min\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setMin(value: fhirInteger | undefined): this {
    if (isDefined<fhirInteger>(value)) {
      const optErrMsg = \`Invalid ParameterDefinition.min (\${String(value)})\`;
      this.min = new IntegerType(parseFhirPrimitiveData(value, fhirIntegerSchema, optErrMsg));
    } else {
      this.min = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`min\` property exists and has a value; \`false\` otherwise
   */
  public hasMin(): boolean {
    return this.hasMinElement();
  }

  /**
   * @returns the \`max\` property value as a StringType object if defined; else an empty StringType object
   */
  public getMaxElement(): StringType {
    return this.max ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`max\` property.
   *
   * @param element - the \`max\` value
   * @returns this
   */
  public setMaxElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid ParameterDefinition.max; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.max = element;
    } else {
      this.max = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`max\` property exists and has a value; \`false\` otherwise
   */
  public hasMaxElement(): boolean {
    return isDefined<StringType>(this.max) && !this.max.isEmpty();
  }

  /**
   * @returns the \`max\` property value as a fhirString if defined; else undefined
   */
  public getMax(): fhirString | undefined {
    return this.max?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`max\` property.
   *
   * @param value - the \`max\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setMax(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid ParameterDefinition.max (\${String(value)})\`;
      this.max = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.max = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`max\` property exists and has a value; \`false\` otherwise
   */
  public hasMax(): boolean {
    return this.hasMaxElement();
  }

  /**
   * @returns the \`documentation\` property value as a StringType object if defined; else an empty StringType object
   */
  public getDocumentationElement(): StringType {
    return this.documentation ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`documentation\` property.
   *
   * @param element - the \`documentation\` value
   * @returns this
   */
  public setDocumentationElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid ParameterDefinition.documentation; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.documentation = element;
    } else {
      this.documentation = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`documentation\` property exists and has a value; \`false\` otherwise
   */
  public hasDocumentationElement(): boolean {
    return isDefined<StringType>(this.documentation) && !this.documentation.isEmpty();
  }

  /**
   * @returns the \`documentation\` property value as a fhirString if defined; else undefined
   */
  public getDocumentation(): fhirString | undefined {
    return this.documentation?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`documentation\` property.
   *
   * @param value - the \`documentation\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setDocumentation(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid ParameterDefinition.documentation (\${String(value)})\`;
      this.documentation = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.documentation = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`documentation\` property exists and has a value; \`false\` otherwise
   */
  public hasDocumentation(): boolean {
    return this.hasDocumentationElement();
  }

  /**
   * @returns the \`type_\` property value as a CodeType object if defined; else null
   */
  public getTypeElement(): CodeType | null {
    return this.type_;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`type_\` property.
   *
   * @param element - the \`type_\` value
   * @returns this
   */
  public setTypeElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, \`ParameterDefinition.type is required\`);
    const optErrMsg = \`Invalid ParameterDefinition.type; Provided value is not an instance of CodeType.\`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.type_ = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasTypeElement(): boolean {
    return isDefined<CodeType>(this.type_) && !this.type_.isEmpty();
  }

  /**
   * @returns the \`type_\` property value as a fhirCode if defined; else null
   */
  public getType(): fhirCode | null {
    if (this.type_?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.type_.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`type_\` property.
   *
   * @param value - the \`type_\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setType(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, \`ParameterDefinition.type is required\`);
    const optErrMsg = \`Invalid ParameterDefinition.type (\${String(value)})\`;
    this.type_ = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasType(): boolean {
    return this.hasTypeElement();
  }

  /**
   * @returns the \`profile\` property value as a CanonicalType object if defined; else an empty CanonicalType object
   */
  public getProfileElement(): CanonicalType {
    return this.profile ?? new CanonicalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`profile\` property.
   *
   * @param element - the \`profile\` value
   * @returns this
   */
  public setProfileElement(element: CanonicalType | undefined): this {
    if (isDefined<CanonicalType>(element)) {
      const optErrMsg = \`Invalid ParameterDefinition.profile; Provided element is not an instance of CanonicalType.\`;
      assertFhirType<CanonicalType>(element, CanonicalType, optErrMsg);
      this.profile = element;
    } else {
      this.profile = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`profile\` property exists and has a value; \`false\` otherwise
   */
  public hasProfileElement(): boolean {
    return isDefined<CanonicalType>(this.profile) && !this.profile.isEmpty();
  }

  /**
   * @returns the \`profile\` property value as a fhirCanonical if defined; else undefined
   */
  public getProfile(): fhirCanonical | undefined {
    return this.profile?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`profile\` property.
   *
   * @param value - the \`profile\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setProfile(value: fhirCanonical | undefined): this {
    if (isDefined<fhirCanonical>(value)) {
      const optErrMsg = \`Invalid ParameterDefinition.profile (\${String(value)})\`;
      this.profile = new CanonicalType(parseFhirPrimitiveData(value, fhirCanonicalSchema, optErrMsg));
    } else {
      this.profile = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`profile\` property exists and has a value; \`false\` otherwise
   */
  public hasProfile(): boolean {
    return this.hasProfileElement();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'ParameterDefinition';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.name,
      this.use,
      this.min,
      this.max,
      this.documentation,
      this.type_,
      this.profile,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): ParameterDefinition {
    const dest = new ParameterDefinition();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: ParameterDefinition): void {
    super.copyValues(dest);
    dest.name = this.name?.copy();
    dest.use = this.use ? this.use.copy() : null;
    dest.min = this.min?.copy();
    dest.max = this.max?.copy();
    dest.documentation = this.documentation?.copy();
    dest.type_ = this.type_ ? this.type_.copy() : null;
    dest.profile = this.profile?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasNameElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getNameElement(), 'name', jsonObj);
    }

    if (this.hasUseElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getUseElement()!, 'use', jsonObj);
    } else {
      missingReqdProperties.push(\`ParameterDefinition.use\`);
    }

    if (this.hasMinElement()) {
      setFhirPrimitiveJson<fhirInteger>(this.getMinElement(), 'min', jsonObj);
    }

    if (this.hasMaxElement()) {
      setFhirPrimitiveJson<fhirString>(this.getMaxElement(), 'max', jsonObj);
    }

    if (this.hasDocumentationElement()) {
      setFhirPrimitiveJson<fhirString>(this.getDocumentationElement(), 'documentation', jsonObj);
    }

    if (this.hasTypeElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getTypeElement()!, 'type', jsonObj);
    } else {
      missingReqdProperties.push(\`ParameterDefinition.type\`);
    }

    if (this.hasProfileElement()) {
      setFhirPrimitiveJson<fhirCanonical>(this.getProfileElement(), 'profile', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "ParameterDefinition",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 50`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * Period Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/Period
 * StructureDefinition.name: Period
 * StructureDefinition.description: Base StructureDefinition for Period Type: A time period defined by a start and end date and optionally time.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  DataType,
  DateTimeType,
  FhirDataTypeParser,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  assertFhirType,
  fhirDateTime,
  fhirDateTimeSchema,
  getPrimitiveTypeJson,
  isDefined,
  isElementEmpty,
  isEmpty,
  parseDateTimeType,
  parseFhirPrimitiveData,
  setFhirPrimitiveJson,
} from '@paq-ts-fhir/fhir-core';
import {
  PARSABLE_DATATYPE_MAP,
} from '../index';

/**
 * Period Class
 *
 * @remarks
 * Base StructureDefinition for Period Type: A time period defined by a start and end date and optionally time.
 *
 * **FHIR Specification**
 * - **Short:** Time range defined by start and end date/time
 * - **Definition:** A time period defined by a start and end date and optionally time.
 * - **Comment:** A Period specifies a range of time; the context of use will specify whether the entire range applies (e.g. "the patient was an inpatient of the hospital for this time range") or one value from the range applies (e.g. "give to the patient between these two times"). Period is not used for a duration (a measure of elapsed time). See [Duration](https://hl7.org/fhir/datatypes.html#Duration).
 * - **FHIR Version:** 4.0.1
 *
 * @category DataModel: ComplexType
 * @see [FHIR Period](http://hl7.org/fhir/StructureDefinition/Period)
 */
export class Period extends DataType implements IBase {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`Period\` JSON to instantiate the Period data model.
   *
   * @param sourceJson - JSON representing FHIR \`Period\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Period
   * @returns Period data model or undefined for \`Period\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Period | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Period';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Period();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'start';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DateTimeType | undefined = parseDateTimeType(dtJson, dtSiblingJson);
      instance.setStartElement(datatype);
    }

    fieldName = 'end';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DateTimeType | undefined = parseDateTimeType(dtJson, dtSiblingJson);
      instance.setEndElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Period.start Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Starting time with inclusive boundary
   * - **Definition:** The start of the period. The boundary is inclusive.
   * - **Comment:** If the low element is missing, the meaning is that the low boundary is not known.
   * - **FHIR Type:** \`dateTime\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private start?: DateTimeType | undefined;

  /**
   * Period.end Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** End time with inclusive boundary, if not ongoing
   * - **Definition:** The end of the period. If the end of the period is missing, it means no end was known or planned at the time the instance was created. The start may be in the past, and the end date in the future, which means that period is expected/planned to end at that time.
   * - **Comment:** The high value includes any matching date/time. i.e. 2012-02-03T10:00:00 is in a period that has an end value of 2012-02-03.
   * - **FHIR Type:** \`dateTime\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private end?: DateTimeType | undefined;


  /**
   * @returns the \`start\` property value as a DateTimeType object if defined; else an empty DateTimeType object
   */
  public getStartElement(): DateTimeType {
    return this.start ?? new DateTimeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`start\` property.
   *
   * @param element - the \`start\` value
   * @returns this
   */
  public setStartElement(element: DateTimeType | undefined): this {
    if (isDefined<DateTimeType>(element)) {
      const optErrMsg = \`Invalid Period.start; Provided element is not an instance of DateTimeType.\`;
      assertFhirType<DateTimeType>(element, DateTimeType, optErrMsg);
      this.start = element;
    } else {
      this.start = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`start\` property exists and has a value; \`false\` otherwise
   */
  public hasStartElement(): boolean {
    return isDefined<DateTimeType>(this.start) && !this.start.isEmpty();
  }

  /**
   * @returns the \`start\` property value as a fhirDateTime if defined; else undefined
   */
  public getStart(): fhirDateTime | undefined {
    return this.start?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`start\` property.
   *
   * @param value - the \`start\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setStart(value: fhirDateTime | undefined): this {
    if (isDefined<fhirDateTime>(value)) {
      const optErrMsg = \`Invalid Period.start (\${String(value)})\`;
      this.start = new DateTimeType(parseFhirPrimitiveData(value, fhirDateTimeSchema, optErrMsg));
    } else {
      this.start = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`start\` property exists and has a value; \`false\` otherwise
   */
  public hasStart(): boolean {
    return this.hasStartElement();
  }

  /**
   * @returns the \`end\` property value as a DateTimeType object if defined; else an empty DateTimeType object
   */
  public getEndElement(): DateTimeType {
    return this.end ?? new DateTimeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`end\` property.
   *
   * @param element - the \`end\` value
   * @returns this
   */
  public setEndElement(element: DateTimeType | undefined): this {
    if (isDefined<DateTimeType>(element)) {
      const optErrMsg = \`Invalid Period.end; Provided element is not an instance of DateTimeType.\`;
      assertFhirType<DateTimeType>(element, DateTimeType, optErrMsg);
      this.end = element;
    } else {
      this.end = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`end\` property exists and has a value; \`false\` otherwise
   */
  public hasEndElement(): boolean {
    return isDefined<DateTimeType>(this.end) && !this.end.isEmpty();
  }

  /**
   * @returns the \`end\` property value as a fhirDateTime if defined; else undefined
   */
  public getEnd(): fhirDateTime | undefined {
    return this.end?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`end\` property.
   *
   * @param value - the \`end\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setEnd(value: fhirDateTime | undefined): this {
    if (isDefined<fhirDateTime>(value)) {
      const optErrMsg = \`Invalid Period.end (\${String(value)})\`;
      this.end = new DateTimeType(parseFhirPrimitiveData(value, fhirDateTimeSchema, optErrMsg));
    } else {
      this.end = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`end\` property exists and has a value; \`false\` otherwise
   */
  public hasEnd(): boolean {
    return this.hasEndElement();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Period';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.start,
      this.end,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Period {
    const dest = new Period();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Period): void {
    super.copyValues(dest);
    dest.start = this.start?.copy();
    dest.end = this.end?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasStartElement()) {
      setFhirPrimitiveJson<fhirDateTime>(this.getStartElement(), 'start', jsonObj);
    }

    if (this.hasEndElement()) {
      setFhirPrimitiveJson<fhirDateTime>(this.getEndElement(), 'end', jsonObj);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "Period",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 51`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * Population Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/Population
 * StructureDefinition.name: Population
 * StructureDefinition.description: Base StructureDefinition for Population Type: A populatioof people with some set of grouping criteria.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  BackboneType,
  ChoiceDataTypes,
  ChoiceDataTypesMeta,
  DataType,
  FhirDataTypeParser,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  InvalidTypeError,
  JSON,
  assertFhirType,
  assertIsDefined,
  isDefined,
  isElementEmpty,
  isEmpty,
  setFhirComplexJson,
  setPolymorphicValueJson,
} from '@paq-ts-fhir/fhir-core';
import {
  CodeableConcept,
  PARSABLE_DATATYPE_MAP,
  Range,
} from '../index';

// eslint-disable-next-line @typescript-eslint/no-explicit-any -- Symbol.metadata polyfill secret sauce for decorator metadata
(Symbol.metadata as any) ??= Symbol('Symbol.metadata');

/**
 * Population Class
 *
 * @remarks
 * Base StructureDefinition for Population Type: A populatioof people with some set of grouping criteria.
 *
 * **FHIR Specification**
 * - **Short:** A definition of a set of people that apply to some clinically related context, for example people contraindicated for a certain medication
 * - **Definition:** A populatioof people with some set of grouping criteria.
 * - **FHIR Version:** 4.0.1
 *
 * @category DataModel: ComplexType
 * @see [FHIR Population](http://hl7.org/fhir/StructureDefinition/Population)
 */
export class Population extends BackboneType implements IBase {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`Population\` JSON to instantiate the Population data model.
   *
   * @param sourceJson - JSON representing FHIR \`Population\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Population
   * @returns Population data model or undefined for \`Population\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Population | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Population';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Population();
    fhirDataTypeParser.processBackboneTypeJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';

    const classMetadata: DecoratorMetadataObject | null = Population[Symbol.metadata];
    const errorMessage = \`DecoratorMetadataObject does not exist for Population\`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    fieldName = 'age[x]';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const age: DataType | undefined = fhirDataTypeParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setAge(age);

    fieldName = 'gender';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = fhirDataTypeParser.parser<CodeableConcept>(CodeableConcept, classJsonObj[fieldName]!, sourceField);
      instance.setGender(datatype);
    }

    fieldName = 'race';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = fhirDataTypeParser.parser<CodeableConcept>(CodeableConcept, classJsonObj[fieldName]!, sourceField);
      instance.setRace(datatype);
    }

    fieldName = 'physiologicalCondition';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = fhirDataTypeParser.parser<CodeableConcept>(CodeableConcept, classJsonObj[fieldName]!, sourceField);
      instance.setPhysiologicalCondition(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Population.age[x] Element
   *
   * @decorator \`@ChoiceDataTypesMeta('Population.age[x]', ['Range','CodeableConcept',]\`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The age of the specific population
   * - **Definition:** The age of the specific population.
   * - **FHIR Types:**
   *     'Range',
   *     'CodeableConcept',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('Population.age[x]',[
    'Range',
    'CodeableConcept',
  ])
  private age?: DataType | undefined;

  /**
   * Population.gender Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The gender of the specific population
   * - **Definition:** The gender of the specific population.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private gender?: CodeableConcept | undefined;

  /**
   * Population.race Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Race of the specific population
   * - **Definition:** Race of the specific population.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private race?: CodeableConcept | undefined;

  /**
   * Population.physiologicalCondition Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The existing physiological conditions of the specific population to which this applies
   * - **Definition:** The existing physiological conditions of the specific population to which this applies.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private physiologicalCondition?: CodeableConcept | undefined;


  /**
   * @returns the \`age\` property value as a DataType object if defined; else undefined
   */
  public getAge(): DataType | undefined {
    return this.age;
  }

  /**
   * Assigns the provided DataType object value to the \`age\` property.
   *
   * @decorator \`@ChoiceDataTypes('Population.age[x]')\`
   *
   * @param value - the \`age\` object value
   * @returns this
   */
  @ChoiceDataTypes('Population.age[x]')
  public setAge(value: DataType | undefined): this {
    if (isDefined<DataType>(value)) {
      // assertFhirType<DataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.age = value;
    } else {
      this.age = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`age\` property exists and has a value; \`false\` otherwise
   */
  public hasAge(): boolean {
    return isDefined<DataType>(this.age) && !this.age.isEmpty();
  }

  // *** NOTE ***
  // Next "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the \`age\` property value as a Range object if defined; else undefined
   */
  public getAgeRange(): Range | undefined {
    if (!isDefined<DataType | undefined>(this.age)) {
      return undefined;
    }
    if (!(this.age instanceof Range)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Population.age[x]: Expected Range but encountered \${this.age.fhirType()}\`,
      );
    }
    return this.age;
  }

  /**
   * @returns \`true\` if the \`age\` property exists as a Range and has a value; \`false\` otherwise
   */
  public hasAgeRange(): boolean {
    return this.hasAge() && this.age instanceof Range;
  }

  /**
   * @returns the \`age\` property value as a CodeableConcept object if defined; else undefined
   */
  public getAgeCodeableConcept(): CodeableConcept | undefined {
    if (!isDefined<DataType | undefined>(this.age)) {
      return undefined;
    }
    if (!(this.age instanceof CodeableConcept)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Population.age[x]: Expected CodeableConcept but encountered \${this.age.fhirType()}\`,
      );
    }
    return this.age;
  }

  /**
   * @returns \`true\` if the \`age\` property exists as a CodeableConcept and has a value; \`false\` otherwise
   */
  public hasAgeCodeableConcept(): boolean {
    return this.hasAge() && this.age instanceof CodeableConcept;
  }

  /**
   * @returns the \`gender\` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getGender(): CodeableConcept {
    return this.gender ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Gender object value to the \`gender\` property.
   *
   * @param value - the \`gender\` object value
   * @returns this
   */
  public setGender(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Population.gender; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.gender = value;
    } else {
      this.gender = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`gender\` property exists and has a value; \`false\` otherwise
   */
  public hasGender(): boolean {
    return isDefined<CodeableConcept>(this.gender) && !this.gender.isEmpty();
  }

  /**
   * @returns the \`race\` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getRace(): CodeableConcept {
    return this.race ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Race object value to the \`race\` property.
   *
   * @param value - the \`race\` object value
   * @returns this
   */
  public setRace(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Population.race; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.race = value;
    } else {
      this.race = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`race\` property exists and has a value; \`false\` otherwise
   */
  public hasRace(): boolean {
    return isDefined<CodeableConcept>(this.race) && !this.race.isEmpty();
  }

  /**
   * @returns the \`physiologicalCondition\` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getPhysiologicalCondition(): CodeableConcept {
    return this.physiologicalCondition ?? new CodeableConcept();
  }

  /**
   * Assigns the provided PhysiologicalCondition object value to the \`physiologicalCondition\` property.
   *
   * @param value - the \`physiologicalCondition\` object value
   * @returns this
   */
  public setPhysiologicalCondition(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Population.physiologicalCondition; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.physiologicalCondition = value;
    } else {
      this.physiologicalCondition = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`physiologicalCondition\` property exists and has a value; \`false\` otherwise
   */
  public hasPhysiologicalCondition(): boolean {
    return isDefined<CodeableConcept>(this.physiologicalCondition) && !this.physiologicalCondition.isEmpty();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Population';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.age,
      this.gender,
      this.race,
      this.physiologicalCondition,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Population {
    const dest = new Population();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Population): void {
    super.copyValues(dest);
    dest.age = this.age?.copy();
    dest.gender = this.gender?.copy();
    dest.race = this.race?.copy();
    dest.physiologicalCondition = this.physiologicalCondition?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasAge()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getAge()!, 'age', jsonObj);
    }

    if (this.hasGender()) {
      setFhirComplexJson(this.getGender(), 'gender', jsonObj);
    }

    if (this.hasRace()) {
      setFhirComplexJson(this.getRace(), 'race', jsonObj);
    }

    if (this.hasPhysiologicalCondition()) {
      setFhirComplexJson(this.getPhysiologicalCondition(), 'physiologicalCondition', jsonObj);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "Population",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 52`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * ProdCharacteristic Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/ProdCharacteristic
 * StructureDefinition.name: ProdCharacteristic
 * StructureDefinition.description: Base StructureDefinition for ProdCharacteristic Type: The marketing status describes the date when a medicinal product is actually put on the market or the date as of which it is no longer available.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  BackboneType,
  FhirDataTypeParser,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  PrimitiveTypeJson,
  StringType,
  assertFhirType,
  assertFhirTypeList,
  copyListValues,
  fhirString,
  fhirStringSchema,
  getPrimitiveTypeJson,
  getPrimitiveTypeListJson,
  isDefined,
  isDefinedList,
  isElementEmpty,
  isEmpty,
  parseFhirPrimitiveData,
  parseStringType,
  setFhirComplexJson,
  setFhirComplexListJson,
  setFhirPrimitiveJson,
  setFhirPrimitiveListJson,
} from '@paq-ts-fhir/fhir-core';
import {
  Attachment,
  CodeableConcept,
  PARSABLE_DATATYPE_MAP,
  Quantity,
} from '../index';

/**
 * ProdCharacteristic Class
 *
 * @remarks
 * Base StructureDefinition for ProdCharacteristic Type: The marketing status describes the date when a medicinal product is actually put on the market or the date as of which it is no longer available.
 *
 * **FHIR Specification**
 * - **Short:** The marketing status describes the date when a medicinal product is actually put on the market or the date as of which it is no longer available
 * - **Definition:** The marketing status describes the date when a medicinal product is actually put on the market or the date as of which it is no longer available.
 * - **FHIR Version:** 4.0.1
 *
 * @category DataModel: ComplexType
 * @see [FHIR ProdCharacteristic](http://hl7.org/fhir/StructureDefinition/ProdCharacteristic)
 */
export class ProdCharacteristic extends BackboneType implements IBase {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`ProdCharacteristic\` JSON to instantiate the ProdCharacteristic data model.
   *
   * @param sourceJson - JSON representing FHIR \`ProdCharacteristic\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to ProdCharacteristic
   * @returns ProdCharacteristic data model or undefined for \`ProdCharacteristic\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): ProdCharacteristic | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'ProdCharacteristic';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new ProdCharacteristic();
    fhirDataTypeParser.processBackboneTypeJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'height';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = fhirDataTypeParser.parser<Quantity>(Quantity, classJsonObj[fieldName]!, sourceField);
      instance.setHeight(datatype);
    }

    fieldName = 'width';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = fhirDataTypeParser.parser<Quantity>(Quantity, classJsonObj[fieldName]!, sourceField);
      instance.setWidth(datatype);
    }

    fieldName = 'depth';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = fhirDataTypeParser.parser<Quantity>(Quantity, classJsonObj[fieldName]!, sourceField);
      instance.setDepth(datatype);
    }

    fieldName = 'weight';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = fhirDataTypeParser.parser<Quantity>(Quantity, classJsonObj[fieldName]!, sourceField);
      instance.setWeight(datatype);
    }

    fieldName = 'nominalVolume';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = fhirDataTypeParser.parser<Quantity>(Quantity, classJsonObj[fieldName]!, sourceField);
      instance.setNominalVolume(datatype);
    }

    fieldName = 'externalDiameter';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = fhirDataTypeParser.parser<Quantity>(Quantity, classJsonObj[fieldName]!, sourceField);
      instance.setExternalDiameter(datatype);
    }

    fieldName = 'shape';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setShapeElement(datatype);
    }

    fieldName = 'color';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: StringType | undefined = parseStringType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addColorElement(datatype);
        }
      });
    }

    fieldName = 'imprint';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: StringType | undefined = parseStringType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addImprintElement(datatype);
        }
      });
    }

    fieldName = 'image';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Attachment | undefined = fhirDataTypeParser.parser<Attachment>(Attachment, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addImage(datatype);
        }
      });
    }

    fieldName = 'scoring';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = fhirDataTypeParser.parser<CodeableConcept>(CodeableConcept, classJsonObj[fieldName]!, sourceField);
      instance.setScoring(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * ProdCharacteristic.height Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Where applicable, the height can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used
   * - **Definition:** Where applicable, the height can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used.
   * - **FHIR Type:** \`Quantity\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private height?: Quantity | undefined;

  /**
   * ProdCharacteristic.width Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Where applicable, the width can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used
   * - **Definition:** Where applicable, the width can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used.
   * - **FHIR Type:** \`Quantity\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private width?: Quantity | undefined;

  /**
   * ProdCharacteristic.depth Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Where applicable, the depth can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used
   * - **Definition:** Where applicable, the depth can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used.
   * - **FHIR Type:** \`Quantity\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private depth?: Quantity | undefined;

  /**
   * ProdCharacteristic.weight Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Where applicable, the weight can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used
   * - **Definition:** Where applicable, the weight can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used.
   * - **FHIR Type:** \`Quantity\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private weight?: Quantity | undefined;

  /**
   * ProdCharacteristic.nominalVolume Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Where applicable, the nominal volume can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used
   * - **Definition:** Where applicable, the nominal volume can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used.
   * - **FHIR Type:** \`Quantity\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private nominalVolume?: Quantity | undefined;

  /**
   * ProdCharacteristic.externalDiameter Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Where applicable, the external diameter can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used
   * - **Definition:** Where applicable, the external diameter can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used.
   * - **FHIR Type:** \`Quantity\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private externalDiameter?: Quantity | undefined;

  /**
   * ProdCharacteristic.shape Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Where applicable, the shape can be specified An appropriate controlled vocabulary shall be used The term and the term identifier shall be used
   * - **Definition:** Where applicable, the shape can be specified An appropriate controlled vocabulary shall be used The term and the term identifier shall be used.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private shape?: StringType | undefined;

  /**
   * ProdCharacteristic.color Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Where applicable, the color can be specified An appropriate controlled vocabulary shall be used The term and the term identifier shall be used
   * - **Definition:** Where applicable, the color can be specified An appropriate controlled vocabulary shall be used The term and the term identifier shall be used.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private color?: StringType[] | undefined;

  /**
   * ProdCharacteristic.imprint Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Where applicable, the imprint can be specified as text
   * - **Definition:** Where applicable, the imprint can be specified as text.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private imprint?: StringType[] | undefined;

  /**
   * ProdCharacteristic.image Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Where applicable, the image can be provided The format of the image attachment shall be specified by regional implementations
   * - **Definition:** Where applicable, the image can be provided The format of the image attachment shall be specified by regional implementations.
   * - **FHIR Type:** \`Attachment\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private image?: Attachment[] | undefined;

  /**
   * ProdCharacteristic.scoring Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Where applicable, the scoring can be specified An appropriate controlled vocabulary shall be used The term and the term identifier shall be used
   * - **Definition:** Where applicable, the scoring can be specified An appropriate controlled vocabulary shall be used The term and the term identifier shall be used.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private scoring?: CodeableConcept | undefined;


  /**
   * @returns the \`height\` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getHeight(): Quantity {
    return this.height ?? new Quantity();
  }

  /**
   * Assigns the provided Height object value to the \`height\` property.
   *
   * @param value - the \`height\` object value
   * @returns this
   */
  public setHeight(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = \`Invalid ProdCharacteristic.height; Provided element is not an instance of Quantity.\`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.height = value;
    } else {
      this.height = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`height\` property exists and has a value; \`false\` otherwise
   */
  public hasHeight(): boolean {
    return isDefined<Quantity>(this.height) && !this.height.isEmpty();
  }

  /**
   * @returns the \`width\` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getWidth(): Quantity {
    return this.width ?? new Quantity();
  }

  /**
   * Assigns the provided Width object value to the \`width\` property.
   *
   * @param value - the \`width\` object value
   * @returns this
   */
  public setWidth(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = \`Invalid ProdCharacteristic.width; Provided element is not an instance of Quantity.\`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.width = value;
    } else {
      this.width = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`width\` property exists and has a value; \`false\` otherwise
   */
  public hasWidth(): boolean {
    return isDefined<Quantity>(this.width) && !this.width.isEmpty();
  }

  /**
   * @returns the \`depth\` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getDepth(): Quantity {
    return this.depth ?? new Quantity();
  }

  /**
   * Assigns the provided Depth object value to the \`depth\` property.
   *
   * @param value - the \`depth\` object value
   * @returns this
   */
  public setDepth(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = \`Invalid ProdCharacteristic.depth; Provided element is not an instance of Quantity.\`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.depth = value;
    } else {
      this.depth = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`depth\` property exists and has a value; \`false\` otherwise
   */
  public hasDepth(): boolean {
    return isDefined<Quantity>(this.depth) && !this.depth.isEmpty();
  }

  /**
   * @returns the \`weight\` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getWeight(): Quantity {
    return this.weight ?? new Quantity();
  }

  /**
   * Assigns the provided Weight object value to the \`weight\` property.
   *
   * @param value - the \`weight\` object value
   * @returns this
   */
  public setWeight(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = \`Invalid ProdCharacteristic.weight; Provided element is not an instance of Quantity.\`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.weight = value;
    } else {
      this.weight = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`weight\` property exists and has a value; \`false\` otherwise
   */
  public hasWeight(): boolean {
    return isDefined<Quantity>(this.weight) && !this.weight.isEmpty();
  }

  /**
   * @returns the \`nominalVolume\` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getNominalVolume(): Quantity {
    return this.nominalVolume ?? new Quantity();
  }

  /**
   * Assigns the provided NominalVolume object value to the \`nominalVolume\` property.
   *
   * @param value - the \`nominalVolume\` object value
   * @returns this
   */
  public setNominalVolume(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = \`Invalid ProdCharacteristic.nominalVolume; Provided element is not an instance of Quantity.\`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.nominalVolume = value;
    } else {
      this.nominalVolume = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`nominalVolume\` property exists and has a value; \`false\` otherwise
   */
  public hasNominalVolume(): boolean {
    return isDefined<Quantity>(this.nominalVolume) && !this.nominalVolume.isEmpty();
  }

  /**
   * @returns the \`externalDiameter\` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getExternalDiameter(): Quantity {
    return this.externalDiameter ?? new Quantity();
  }

  /**
   * Assigns the provided ExternalDiameter object value to the \`externalDiameter\` property.
   *
   * @param value - the \`externalDiameter\` object value
   * @returns this
   */
  public setExternalDiameter(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = \`Invalid ProdCharacteristic.externalDiameter; Provided element is not an instance of Quantity.\`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.externalDiameter = value;
    } else {
      this.externalDiameter = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`externalDiameter\` property exists and has a value; \`false\` otherwise
   */
  public hasExternalDiameter(): boolean {
    return isDefined<Quantity>(this.externalDiameter) && !this.externalDiameter.isEmpty();
  }

  /**
   * @returns the \`shape\` property value as a StringType object if defined; else an empty StringType object
   */
  public getShapeElement(): StringType {
    return this.shape ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`shape\` property.
   *
   * @param element - the \`shape\` value
   * @returns this
   */
  public setShapeElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid ProdCharacteristic.shape; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.shape = element;
    } else {
      this.shape = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`shape\` property exists and has a value; \`false\` otherwise
   */
  public hasShapeElement(): boolean {
    return isDefined<StringType>(this.shape) && !this.shape.isEmpty();
  }

  /**
   * @returns the \`shape\` property value as a fhirString if defined; else undefined
   */
  public getShape(): fhirString | undefined {
    return this.shape?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`shape\` property.
   *
   * @param value - the \`shape\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setShape(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid ProdCharacteristic.shape (\${String(value)})\`;
      this.shape = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.shape = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`shape\` property exists and has a value; \`false\` otherwise
   */
  public hasShape(): boolean {
    return this.hasShapeElement();
  }

  /**
   * @returns the \`color\` property value as a StringType array
   */
  public getColorElement(): StringType[] {
    return this.color ?? ([] as StringType[]);
  }

  /**
   * Assigns the provided StringType array value to the \`color\` property.
   *
   * @param element - the \`color\` array value
   * @returns this
   */
  public setColorElement(element: StringType[] | undefined): this {
    if (isDefinedList<StringType>(element)) {
      const optErrMsg = \`Invalid ProdCharacteristic.color; Provided value array has an element that is not an instance of StringType.\`;
      assertFhirTypeList<StringType>(element, StringType, optErrMsg);
      this.color = element;
    } else {
      this.color = undefined;
    }
    return this;
  }

  /**
   * Add the provided StringType value to the \`color\` array property.
   *
   * @param element - the \`color\` value
   * @returns this
   */
  public addColorElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid ProdCharacteristic.color; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.initColor();
      this.color?.push(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`color\` property exists and has a value; \`false\` otherwise
   */
  public hasColorElement(): boolean {
    return isDefinedList<StringType>(this.color) && this.color.some((item: StringType) => !item.isEmpty());
  }

  /**
   * @returns the \`color\` property value as a fhirString array
   */
  public getColor(): fhirString[] {
    this.initColor();
    const colorValues = [] as fhirString[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.color!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        colorValues.push(value);
      }
    }
    return colorValues;
  }

  /**
   * Assigns the provided primitive value array to the \`color\` property.
   *
   * @param value - the \`color\` value array
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setColor(value: fhirString[] | undefined): this {
    if (isDefinedList<fhirString>(value)) {
      const colorElements = [] as StringType[];
      for (const colorValue of value) {
        const optErrMsg = \`Invalid ProdCharacteristic.color array item (\${String(colorValue)})\`;
        const element = new StringType(parseFhirPrimitiveData(colorValue, fhirStringSchema, optErrMsg));
        colorElements.push(element);
      }
      this.color = colorElements;
    } else {
      this.color = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`color\` array property.
   *
   * @param value - the \`color\` value
   * @returns this
   */
  public addColor(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid ProdCharacteristic.color array item (\${String(value)})\`;
      const element = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
      this.initColor();
      this.addColorElement(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`color\` property exists and has a value; \`false\` otherwise
   */
  public hasColor(): boolean {
    return this.hasColorElement();
  }

  /**
   * Initialize the \`color\` property
   */
  private initColor(): void {
    if (!this.hasColor()) {
      this.color = [] as StringType[];
    }
  }

  /**
   * @returns the \`imprint\` property value as a StringType array
   */
  public getImprintElement(): StringType[] {
    return this.imprint ?? ([] as StringType[]);
  }

  /**
   * Assigns the provided StringType array value to the \`imprint\` property.
   *
   * @param element - the \`imprint\` array value
   * @returns this
   */
  public setImprintElement(element: StringType[] | undefined): this {
    if (isDefinedList<StringType>(element)) {
      const optErrMsg = \`Invalid ProdCharacteristic.imprint; Provided value array has an element that is not an instance of StringType.\`;
      assertFhirTypeList<StringType>(element, StringType, optErrMsg);
      this.imprint = element;
    } else {
      this.imprint = undefined;
    }
    return this;
  }

  /**
   * Add the provided StringType value to the \`imprint\` array property.
   *
   * @param element - the \`imprint\` value
   * @returns this
   */
  public addImprintElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid ProdCharacteristic.imprint; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.initImprint();
      this.imprint?.push(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`imprint\` property exists and has a value; \`false\` otherwise
   */
  public hasImprintElement(): boolean {
    return isDefinedList<StringType>(this.imprint) && this.imprint.some((item: StringType) => !item.isEmpty());
  }

  /**
   * @returns the \`imprint\` property value as a fhirString array
   */
  public getImprint(): fhirString[] {
    this.initImprint();
    const imprintValues = [] as fhirString[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.imprint!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        imprintValues.push(value);
      }
    }
    return imprintValues;
  }

  /**
   * Assigns the provided primitive value array to the \`imprint\` property.
   *
   * @param value - the \`imprint\` value array
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setImprint(value: fhirString[] | undefined): this {
    if (isDefinedList<fhirString>(value)) {
      const imprintElements = [] as StringType[];
      for (const imprintValue of value) {
        const optErrMsg = \`Invalid ProdCharacteristic.imprint array item (\${String(imprintValue)})\`;
        const element = new StringType(parseFhirPrimitiveData(imprintValue, fhirStringSchema, optErrMsg));
        imprintElements.push(element);
      }
      this.imprint = imprintElements;
    } else {
      this.imprint = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`imprint\` array property.
   *
   * @param value - the \`imprint\` value
   * @returns this
   */
  public addImprint(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid ProdCharacteristic.imprint array item (\${String(value)})\`;
      const element = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
      this.initImprint();
      this.addImprintElement(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`imprint\` property exists and has a value; \`false\` otherwise
   */
  public hasImprint(): boolean {
    return this.hasImprintElement();
  }

  /**
   * Initialize the \`imprint\` property
   */
  private initImprint(): void {
    if (!this.hasImprint()) {
      this.imprint = [] as StringType[];
    }
  }

  /**
   * @returns the \`image\` property value as a Attachment array
   */
  public getImage(): Attachment[] {
    return this.image ?? ([] as Attachment[]);
  }

  /**
   * Assigns the provided Attachment array value to the \`image\` property.
   *
   * @param value - the \`image\` array value
   * @returns this
   */
  public setImage(value: Attachment[] | undefined): this {
    if (isDefinedList<Attachment>(value)) {
      const optErrMsg = \`Invalid ProdCharacteristic.image; Provided value array has an element that is not an instance of Attachment.\`;
      assertFhirTypeList<Attachment>(value, Attachment, optErrMsg);
      this.image = value;
    } else {
      this.image = undefined;
    }
    return this;
  }

  /**
   * Add the provided Attachment value to the \`image\` array property.
   *
   * @param value - the \`image\` value
   * @returns this
   */
  public addImage(value: Attachment | undefined): this {
    if (isDefined<Attachment>(value)) {
      const optErrMsg = \`Invalid ProdCharacteristic.image; Provided element is not an instance of Attachment.\`;
      assertFhirType<Attachment>(value, Attachment, optErrMsg);
      this.initImage();
      this.image?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`image\` property exists and has a value; \`false\` otherwise
   */
  public hasImage(): boolean {
    return isDefinedList<Attachment>(this.image) && this.image.some((item: Attachment) => !item.isEmpty());
  }

  /**
   * Initialize the \`image\` property
   */
  private initImage(): void {
    if(!this.hasImage()) {
      this.image = [] as Attachment[];
    }
  }

  /**
   * @returns the \`scoring\` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getScoring(): CodeableConcept {
    return this.scoring ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Scoring object value to the \`scoring\` property.
   *
   * @param value - the \`scoring\` object value
   * @returns this
   */
  public setScoring(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid ProdCharacteristic.scoring; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.scoring = value;
    } else {
      this.scoring = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`scoring\` property exists and has a value; \`false\` otherwise
   */
  public hasScoring(): boolean {
    return isDefined<CodeableConcept>(this.scoring) && !this.scoring.isEmpty();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'ProdCharacteristic';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.height,
      this.width,
      this.depth,
      this.weight,
      this.nominalVolume,
      this.externalDiameter,
      this.shape,
      this.color,
      this.imprint,
      this.image,
      this.scoring,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): ProdCharacteristic {
    const dest = new ProdCharacteristic();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: ProdCharacteristic): void {
    super.copyValues(dest);
    dest.height = this.height?.copy();
    dest.width = this.width?.copy();
    dest.depth = this.depth?.copy();
    dest.weight = this.weight?.copy();
    dest.nominalVolume = this.nominalVolume?.copy();
    dest.externalDiameter = this.externalDiameter?.copy();
    dest.shape = this.shape?.copy();
    const colorList = copyListValues<StringType>(this.color);
    dest.color = colorList.length === 0 ? undefined : colorList;
    const imprintList = copyListValues<StringType>(this.imprint);
    dest.imprint = imprintList.length === 0 ? undefined : imprintList;
    const imageList = copyListValues<Attachment>(this.image);
    dest.image = imageList.length === 0 ? undefined : imageList;
    dest.scoring = this.scoring?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasHeight()) {
      setFhirComplexJson(this.getHeight(), 'height', jsonObj);
    }

    if (this.hasWidth()) {
      setFhirComplexJson(this.getWidth(), 'width', jsonObj);
    }

    if (this.hasDepth()) {
      setFhirComplexJson(this.getDepth(), 'depth', jsonObj);
    }

    if (this.hasWeight()) {
      setFhirComplexJson(this.getWeight(), 'weight', jsonObj);
    }

    if (this.hasNominalVolume()) {
      setFhirComplexJson(this.getNominalVolume(), 'nominalVolume', jsonObj);
    }

    if (this.hasExternalDiameter()) {
      setFhirComplexJson(this.getExternalDiameter(), 'externalDiameter', jsonObj);
    }

    if (this.hasShapeElement()) {
      setFhirPrimitiveJson<fhirString>(this.getShapeElement(), 'shape', jsonObj);
    }

    if (this.hasColor()) {
      setFhirPrimitiveListJson(this.getColorElement(), 'color', jsonObj);
    }

    if (this.hasImprint()) {
      setFhirPrimitiveListJson(this.getImprintElement(), 'imprint', jsonObj);
    }

    if (this.hasImage()) {
      setFhirComplexListJson(this.getImage(), 'image', jsonObj);
    }

    if (this.hasScoring()) {
      setFhirComplexJson(this.getScoring(), 'scoring', jsonObj);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "ProdCharacteristic",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 53`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * ProductShelfLife Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/ProductShelfLife
 * StructureDefinition.name: ProductShelfLife
 * StructureDefinition.description: ProductShelfLife Type: The shelf-life and storage information for a medicinal product item or container can be described using this class.
 * StructureDefinition.fhirVersion: 5.0.0
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  BackboneType,
  ChoiceDataTypes,
  ChoiceDataTypesMeta,
  DataType,
  FhirDataTypeParser,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  InvalidTypeError,
  JSON,
  StringType,
  assertFhirType,
  assertFhirTypeList,
  assertIsDefined,
  copyListValues,
  isDefined,
  isDefinedList,
  isElementEmpty,
  isEmpty,
  setFhirComplexJson,
  setFhirComplexListJson,
  setPolymorphicValueJson,
} from '@paq-ts-fhir/fhir-core';
import {
  CodeableConcept,
  Duration,
  PARSABLE_DATATYPE_MAP,
} from '../index';

// eslint-disable-next-line @typescript-eslint/no-explicit-any -- Symbol.metadata polyfill secret sauce for decorator metadata
(Symbol.metadata as any) ??= Symbol('Symbol.metadata');

/**
 * ProductShelfLife Class
 *
 * @remarks
 * ProductShelfLife Type: The shelf-life and storage information for a medicinal product item or container can be described using this class.
 *
 * **FHIR Specification**
 * - **Short:** The shelf-life and storage information for a medicinal product item or container can be described using this class
 * - **Definition:** The shelf-life and storage information for a medicinal product item or container can be described using this class.
 * - **FHIR Version:** 5.0.0
 *
 * @category DataModel: ComplexType
 * @see [FHIR ProductShelfLife](http://hl7.org/fhir/StructureDefinition/ProductShelfLife)
 */
export class ProductShelfLife extends BackboneType implements IBase {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`ProductShelfLife\` JSON to instantiate the ProductShelfLife data model.
   *
   * @param sourceJson - JSON representing FHIR \`ProductShelfLife\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to ProductShelfLife
   * @returns ProductShelfLife data model or undefined for \`ProductShelfLife\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): ProductShelfLife | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'ProductShelfLife';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new ProductShelfLife();
    fhirDataTypeParser.processBackboneTypeJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';

    const classMetadata: DecoratorMetadataObject | null = ProductShelfLife[Symbol.metadata];
    const errorMessage = \`DecoratorMetadataObject does not exist for ProductShelfLife\`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    fieldName = 'type';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = fhirDataTypeParser.parser<CodeableConcept>(CodeableConcept, classJsonObj[fieldName]!, sourceField);
      instance.setType(datatype);
    }

    fieldName = 'period[x]';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const period: DataType | undefined = fhirDataTypeParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setPeriod(period);

    fieldName = 'specialPrecautionsForStorage';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: CodeableConcept | undefined = fhirDataTypeParser.parser<CodeableConcept>(CodeableConcept, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addSpecialPrecautionsForStorage(datatype);
        }
      });
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * ProductShelfLife.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** This describes the shelf life, taking into account various scenarios such as shelf life of the packaged Medicinal Product itself, shelf life after transformation where necessary and shelf life after the first opening of a bottle, etc. The shelf life type shall be specified using an appropriate controlled vocabulary The controlled term and the controlled term identifier shall be specified
   * - **Definition:** This describes the shelf life, taking into account various scenarios such as shelf life of the packaged Medicinal Product itself, shelf life after transformation where necessary and shelf life after the first opening of a bottle, etc. The shelf life type shall be specified using an appropriate controlled vocabulary The controlled term and the controlled term identifier shall be specified.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private type_?: CodeableConcept | undefined;

  /**
   * ProductShelfLife.period[x] Element
   *
   * @decorator \`@ChoiceDataTypesMeta('ProductShelfLife.period[x]', ['Duration','string',]\`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The shelf life time period can be specified using a numerical value for the period of time and its unit of time measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used
   * - **Definition:** The shelf life time period can be specified using a numerical value for the period of time and its unit of time measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used.
   * - **FHIR Types:**
   *     'Duration',
   *     'string',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('ProductShelfLife.period[x]',[
    'Duration',
    'string',
  ])
  private period?: DataType | undefined;

  /**
   * ProductShelfLife.specialPrecautionsForStorage Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Special precautions for storage, if any, can be specified using an appropriate controlled vocabulary The controlled term and the controlled term identifier shall be specified
   * - **Definition:** Special precautions for storage, if any, can be specified using an appropriate controlled vocabulary The controlled term and the controlled term identifier shall be specified.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private specialPrecautionsForStorage?: CodeableConcept[] | undefined;


  /**
   * @returns the \`type_\` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getType(): CodeableConcept {
    return this.type_ ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Type object value to the \`type_\` property.
   *
   * @param value - the \`type_\` object value
   * @returns this
   */
  public setType(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid ProductShelfLife.type; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.type_ = value;
    } else {
      this.type_ = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasType(): boolean {
    return isDefined<CodeableConcept>(this.type_) && !this.type_.isEmpty();
  }

  /**
   * @returns the \`period\` property value as a DataType object if defined; else undefined
   */
  public getPeriod(): DataType | undefined {
    return this.period;
  }

  /**
   * Assigns the provided DataType object value to the \`period\` property.
   *
   * @decorator \`@ChoiceDataTypes('ProductShelfLife.period[x]')\`
   *
   * @param value - the \`period\` object value
   * @returns this
   */
  @ChoiceDataTypes('ProductShelfLife.period[x]')
  public setPeriod(value: DataType | undefined): this {
    if (isDefined<DataType>(value)) {
      // assertFhirType<DataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.period = value;
    } else {
      this.period = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`period\` property exists and has a value; \`false\` otherwise
   */
  public hasPeriod(): boolean {
    return isDefined<DataType>(this.period) && !this.period.isEmpty();
  }

  // *** NOTE ***
  // Next "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the \`period\` property value as a Duration object if defined; else undefined
   */
  public getPeriodDuration(): Duration | undefined {
    if (!isDefined<DataType | undefined>(this.period)) {
      return undefined;
    }
    if (!(this.period instanceof Duration)) {
      throw new InvalidTypeError(
        \`DataType mismatch for ProductShelfLife.period[x]: Expected Duration but encountered \${this.period.fhirType()}\`,
      );
    }
    return this.period;
  }

  /**
   * @returns \`true\` if the \`period\` property exists as a Duration and has a value; \`false\` otherwise
   */
  public hasPeriodDuration(): boolean {
    return this.hasPeriod() && this.period instanceof Duration;
  }

  /**
   * @returns the \`period\` property value as a StringType object if defined; else undefined
   */
  public getPeriodStringType(): StringType | undefined {
    if (!isDefined<DataType | undefined>(this.period)) {
      return undefined;
    }
    if (!(this.period instanceof StringType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for ProductShelfLife.period[x]: Expected StringType but encountered \${this.period.fhirType()}\`,
      );
    }
    return this.period;
  }

  /**
   * @returns \`true\` if the \`period\` property exists as a StringType and has a value; \`false\` otherwise
   */
  public hasPeriodStringType(): boolean {
    return this.hasPeriod() && this.period instanceof StringType;
  }

  /**
   * @returns the \`specialPrecautionsForStorage\` property value as a CodeableConcept array
   */
  public getSpecialPrecautionsForStorage(): CodeableConcept[] {
    return this.specialPrecautionsForStorage ?? ([] as CodeableConcept[]);
  }

  /**
   * Assigns the provided CodeableConcept array value to the \`specialPrecautionsForStorage\` property.
   *
   * @param value - the \`specialPrecautionsForStorage\` array value
   * @returns this
   */
  public setSpecialPrecautionsForStorage(value: CodeableConcept[] | undefined): this {
    if (isDefinedList<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid ProductShelfLife.specialPrecautionsForStorage; Provided value array has an element that is not an instance of CodeableConcept.\`;
      assertFhirTypeList<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.specialPrecautionsForStorage = value;
    } else {
      this.specialPrecautionsForStorage = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeableConcept value to the \`specialPrecautionsForStorage\` array property.
   *
   * @param value - the \`specialPrecautionsForStorage\` value
   * @returns this
   */
  public addSpecialPrecautionsForStorage(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid ProductShelfLife.specialPrecautionsForStorage; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.initSpecialPrecautionsForStorage();
      this.specialPrecautionsForStorage?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`specialPrecautionsForStorage\` property exists and has a value; \`false\` otherwise
   */
  public hasSpecialPrecautionsForStorage(): boolean {
    return isDefinedList<CodeableConcept>(this.specialPrecautionsForStorage) && this.specialPrecautionsForStorage.some((item: CodeableConcept) => !item.isEmpty());
  }

  /**
   * Initialize the \`specialPrecautionsForStorage\` property
   */
  private initSpecialPrecautionsForStorage(): void {
    if(!this.hasSpecialPrecautionsForStorage()) {
      this.specialPrecautionsForStorage = [] as CodeableConcept[];
    }
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'ProductShelfLife';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.type_,
      this.period,
      this.specialPrecautionsForStorage,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): ProductShelfLife {
    const dest = new ProductShelfLife();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: ProductShelfLife): void {
    super.copyValues(dest);
    dest.type_ = this.type_?.copy();
    dest.period = this.period?.copy();
    const specialPrecautionsForStorageList = copyListValues<CodeableConcept>(this.specialPrecautionsForStorage);
    dest.specialPrecautionsForStorage = specialPrecautionsForStorageList.length === 0 ? undefined : specialPrecautionsForStorageList;
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasType()) {
      setFhirComplexJson(this.getType(), 'type', jsonObj);
    }

    if (this.hasPeriod()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getPeriod()!, 'period', jsonObj);
    }

    if (this.hasSpecialPrecautionsForStorage()) {
      setFhirComplexListJson(this.getSpecialPrecautionsForStorage(), 'specialPrecautionsForStorage', jsonObj);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "ProductShelfLife",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 54`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * Quantity Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/Quantity
 * StructureDefinition.name: Quantity
 * StructureDefinition.description: Base StructureDefinition for Quantity Type: A measured amount (or an amount that can potentially be measured). Note that measured amounts include amounts that are not precisely quantified, including amounts involving arbitrary units and floating currencies.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  CodeType,
  DataType,
  DecimalType,
  EnumCodeType,
  FhirDataTypeParser,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  StringType,
  UriType,
  assertEnumCodeType,
  assertFhirType,
  fhirCode,
  fhirCodeSchema,
  fhirDecimal,
  fhirDecimalSchema,
  fhirString,
  fhirStringSchema,
  fhirUri,
  fhirUriSchema,
  getPrimitiveTypeJson,
  isDefined,
  isElementEmpty,
  isEmpty,
  parseCodeType,
  parseDecimalType,
  parseFhirPrimitiveData,
  parseStringType,
  parseUriType,
  setFhirPrimitiveJson,
} from '@paq-ts-fhir/fhir-core';
import {
  PARSABLE_DATATYPE_MAP,
  QuantityComparatorEnum,
} from '../index';

/**
 * Quantity Class
 *
 * @remarks
 * Base StructureDefinition for Quantity Type: A measured amount (or an amount that can potentially be measured). Note that measured amounts include amounts that are not precisely quantified, including amounts involving arbitrary units and floating currencies.
 *
 * Need to able to capture all sorts of measured values, even if the measured value are not precisely quantified. Values include exact measures such as 3.51g, customary units such as 3 tablets, and currencies such as $100.32USD.
 *
 * **FHIR Specification**
 * - **Short:** A measured or measurable amount
 * - **Definition:** A measured amount (or an amount that can potentially be measured). Note that measured amounts include amounts that are not precisely quantified, including amounts involving arbitrary units and floating currencies.
 * - **Comment:** The context of use may frequently define what kind of quantity this is and therefore what kind of units can be used. The context of use may also restrict the values for the comparator.
 * - **FHIR Version:** 4.0.1
 *
 * @category DataModel: ComplexType
 * @see [FHIR Quantity](http://hl7.org/fhir/StructureDefinition/Quantity)
 */
export class Quantity extends DataType implements IBase {
  constructor() {
    super();

    this.quantityComparatorEnum = new QuantityComparatorEnum();
  }

  /**
   * Parse the provided \`Quantity\` JSON to instantiate the Quantity data model.
   *
   * @param sourceJson - JSON representing FHIR \`Quantity\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Quantity
   * @returns Quantity data model or undefined for \`Quantity\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Quantity | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Quantity';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Quantity();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'value';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = parseDecimalType(dtJson, dtSiblingJson);
      instance.setValueElement(datatype);
    }

    fieldName = 'comparator';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      instance.setComparatorElement(datatype);
    }

    fieldName = 'unit';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setUnitElement(datatype);
    }

    fieldName = 'system';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = parseUriType(dtJson, dtSiblingJson);
      instance.setSystemElement(datatype);
    }

    fieldName = 'code';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      instance.setCodeElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Quantity.value Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Numerical value (with implicit precision)
   * - **Definition:** The value of the measured amount. The value includes an implicit precision in the presentation of the value.
   * - **Comment:** The implicit precision in the value should always be honored. Monetary values have their own rules for handling precision (refer to standard accounting text books).
   * - **Requirements:** Precision is handled implicitly in almost all cases of measurement.
   * - **FHIR Type:** \`decimal\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private value?: DecimalType | undefined;

  /**
   * FHIR CodeSystem: QuantityComparator
   *
   * @see {@link QuantityComparatorEnum }
   */
  private readonly quantityComparatorEnum: QuantityComparatorEnum;

  /**
   * Quantity.comparator Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** < | <= | >= | > - how to understand the value
   * - **Definition:** How the value should be understood and represented - whether the actual value is greater or less than the stated value due to measurement issues; e.g. if the comparator is "<" , then the real value is < stated value.
   * - **Requirements:** Need a framework for handling measures where the value is <5ug/L or >400mg/L due to the limitations of measuring methodology.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** true
   * - **isModifierReason:** This is labeled as &quot;Is Modifier&quot; because the comparator modifies the interpretation of the value significantly. If there is no comparator, then there is no modification of the value
   * - **isSummary:** true
   */
  private comparator?: EnumCodeType | undefined;

  /**
   * Quantity.unit Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Unit representation
   * - **Definition:** A human-readable form of the unit.
   * - **Requirements:** There are many representations for units of measure and in many contexts, particular representations are fixed and required. I.e. mcg for micrograms.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private unit?: StringType | undefined;

  /**
   * Quantity.system Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** System that defines coded unit form
   * - **Definition:** The identification of the system that provides the coded form of the unit.
   * - **Requirements:** Need to know the system that defines the coded form of the unit.
   * - **FHIR Type:** \`uri\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private system?: UriType | undefined;

  /**
   * Quantity.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Coded form of the unit
   * - **Definition:** A computer processable form of the unit in some unit representation system.
   * - **Comment:** The preferred system is UCUM, but SNOMED CT can also be used (for customary units) or ISO 4217 for currency.  The context of use may additionally require a code from a particular system.
   * - **Requirements:** Need a computable form of the unit that is fixed across all forms. UCUM provides this for quantities, but SNOMED CT provides many units of interest.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code?: CodeType | undefined;


  /**
   * @returns the \`value\` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getValueElement(): DecimalType {
    return this.value ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`value\` property.
   *
   * @param element - the \`value\` value
   * @returns this
   */
  public setValueElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = \`Invalid Quantity.value; Provided element is not an instance of DecimalType.\`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.value = element;
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`value\` property exists and has a value; \`false\` otherwise
   */
  public hasValueElement(): boolean {
    return isDefined<DecimalType>(this.value) && !this.value.isEmpty();
  }

  /**
   * @returns the \`value\` property value as a fhirDecimal if defined; else undefined
   */
  public getValue(): fhirDecimal | undefined {
    return this.value?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`value\` property.
   *
   * @param value - the \`value\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setValue(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = \`Invalid Quantity.value (\${String(value)})\`;
      this.value = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`value\` property exists and has a value; \`false\` otherwise
   */
  public hasValue(): boolean {
    return this.hasValueElement();
  }

  /**
   * @returns the \`comparator\` property value as a EnumCodeType if defined; else undefined
   */
  public getComparatorEnumType(): EnumCodeType | undefined {
    return this.comparator;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`comparator\` property.
   *
   * @param enumType - the \`comparator\` value
   * @returns this
   */
  public setComparatorEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid Quantity.comparator';
      assertEnumCodeType<QuantityComparatorEnum>(enumType, QuantityComparatorEnum, errMsgPrefix);
      this.comparator = enumType;
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`comparator\` property exists and has a value; \`false\` otherwise
   */
  public hasComparatorEnumType(): boolean {
    return isDefined<EnumCodeType>(this.comparator) && !this.comparator.isEmpty() && this.comparator.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`comparator\` property value as a CodeType if defined; else undefined
   */
  public getComparatorElement(): CodeType | undefined {
    if (this.comparator === undefined) {
      return undefined;
    }
    return this.comparator as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`comparator\` property.
   *
   * @param element - the \`comparator\` value
   * @returns this
   */
  public setComparatorElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Quantity.comparator; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.comparator = new EnumCodeType(element, this.quantityComparatorEnum);
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`comparator\` property exists and has a value; \`false\` otherwise
   */
  public hasComparatorElement(): boolean {
    return this.hasComparatorEnumType();
  }

  /**
   * @returns the \`comparator\` property value as a fhirCode if defined; else undefined
   */
  public getComparator(): fhirCode | undefined {
    if (this.comparator === undefined) {
      return undefined;
    }
    return this.comparator.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`comparator\` property.
   *
   * @param value - the \`comparator\` value
   * @returns this
   */
  public setComparator(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Quantity.comparator; Provided value is not an instance of fhirCode.\`;
      this.comparator = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.quantityComparatorEnum);
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`comparator\` property exists and has a value; \`false\` otherwise
   */
  public hasComparator(): boolean {
    return this.hasComparatorEnumType();
  }

  /**
   * @returns the \`unit\` property value as a StringType object if defined; else an empty StringType object
   */
  public getUnitElement(): StringType {
    return this.unit ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`unit\` property.
   *
   * @param element - the \`unit\` value
   * @returns this
   */
  public setUnitElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Quantity.unit; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.unit = element;
    } else {
      this.unit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`unit\` property exists and has a value; \`false\` otherwise
   */
  public hasUnitElement(): boolean {
    return isDefined<StringType>(this.unit) && !this.unit.isEmpty();
  }

  /**
   * @returns the \`unit\` property value as a fhirString if defined; else undefined
   */
  public getUnit(): fhirString | undefined {
    return this.unit?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`unit\` property.
   *
   * @param value - the \`unit\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setUnit(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Quantity.unit (\${String(value)})\`;
      this.unit = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.unit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`unit\` property exists and has a value; \`false\` otherwise
   */
  public hasUnit(): boolean {
    return this.hasUnitElement();
  }

  /**
   * @returns the \`system\` property value as a UriType object if defined; else an empty UriType object
   */
  public getSystemElement(): UriType {
    return this.system ?? new UriType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`system\` property.
   *
   * @param element - the \`system\` value
   * @returns this
   */
  public setSystemElement(element: UriType | undefined): this {
    if (isDefined<UriType>(element)) {
      const optErrMsg = \`Invalid Quantity.system; Provided element is not an instance of UriType.\`;
      assertFhirType<UriType>(element, UriType, optErrMsg);
      this.system = element;
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`system\` property exists and has a value; \`false\` otherwise
   */
  public hasSystemElement(): boolean {
    return isDefined<UriType>(this.system) && !this.system.isEmpty();
  }

  /**
   * @returns the \`system\` property value as a fhirUri if defined; else undefined
   */
  public getSystem(): fhirUri | undefined {
    return this.system?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`system\` property.
   *
   * @param value - the \`system\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setSystem(value: fhirUri | undefined): this {
    if (isDefined<fhirUri>(value)) {
      const optErrMsg = \`Invalid Quantity.system (\${String(value)})\`;
      this.system = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`system\` property exists and has a value; \`false\` otherwise
   */
  public hasSystem(): boolean {
    return this.hasSystemElement();
  }

  /**
   * @returns the \`code\` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getCodeElement(): CodeType {
    return this.code ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`code\` property.
   *
   * @param element - the \`code\` value
   * @returns this
   */
  public setCodeElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Quantity.code; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.code = element;
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`code\` property exists and has a value; \`false\` otherwise
   */
  public hasCodeElement(): boolean {
    return isDefined<CodeType>(this.code) && !this.code.isEmpty();
  }

  /**
   * @returns the \`code\` property value as a fhirCode if defined; else undefined
   */
  public getCode(): fhirCode | undefined {
    return this.code?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`code\` property.
   *
   * @param value - the \`code\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setCode(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Quantity.code (\${String(value)})\`;
      this.code = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`code\` property exists and has a value; \`false\` otherwise
   */
  public hasCode(): boolean {
    return this.hasCodeElement();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Quantity';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.value,
      this.comparator,
      this.unit,
      this.system,
      this.code,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Quantity {
    const dest = new Quantity();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Quantity): void {
    super.copyValues(dest);
    dest.value = this.value?.copy();
    dest.comparator = this.comparator?.copy();
    dest.unit = this.unit?.copy();
    dest.system = this.system?.copy();
    dest.code = this.code?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasValueElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getValueElement(), 'value', jsonObj);
    }

    if (this.hasComparatorElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getComparatorElement()!, 'comparator', jsonObj);
    }

    if (this.hasUnitElement()) {
      setFhirPrimitiveJson<fhirString>(this.getUnitElement(), 'unit', jsonObj);
    }

    if (this.hasSystemElement()) {
      setFhirPrimitiveJson<fhirUri>(this.getSystemElement(), 'system', jsonObj);
    }

    if (this.hasCodeElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getCodeElement(), 'code', jsonObj);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "Quantity",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 55`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * Range Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/Range
 * StructureDefinition.name: Range
 * StructureDefinition.description: Base StructureDefinition for Range Type: A set of ordered Quantities defined by a low and high limit.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  DataType,
  FhirDataTypeParser,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  assertFhirType,
  isDefined,
  isElementEmpty,
  isEmpty,
  setFhirComplexJson,
} from '@paq-ts-fhir/fhir-core';
import {
  PARSABLE_DATATYPE_MAP,
  Quantity,
} from '../index';

/**
 * Range Class
 *
 * @remarks
 * Base StructureDefinition for Range Type: A set of ordered Quantities defined by a low and high limit.
 *
 * Need to be able to specify ranges of values.
 *
 * **FHIR Specification**
 * - **Short:** Set of values bounded by low and high
 * - **Definition:** A set of ordered Quantities defined by a low and high limit.
 * - **Comment:** The stated low and high value are assumed to have arbitrarily high precision when it comes to determining which values are in the range. I.e. 1.99 is not in the range 2 -> 3.
 * - **FHIR Version:** 4.0.1
 *
 * @category DataModel: ComplexType
 * @see [FHIR Range](http://hl7.org/fhir/StructureDefinition/Range)
 */
export class Range extends DataType implements IBase {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`Range\` JSON to instantiate the Range data model.
   *
   * @param sourceJson - JSON representing FHIR \`Range\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Range
   * @returns Range data model or undefined for \`Range\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Range | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Range';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Range();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';

    fieldName = 'low';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = fhirDataTypeParser.parser<Quantity>(Quantity, classJsonObj[fieldName]!, sourceField);
      instance.setLow(datatype);
    }

    fieldName = 'high';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = fhirDataTypeParser.parser<Quantity>(Quantity, classJsonObj[fieldName]!, sourceField);
      instance.setHigh(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Range.low Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Low limit
   * - **Definition:** The low limit. The boundary is inclusive.
   * - **Comment:** If the low element is missing, the low boundary is not known.
   * - **FHIR Type:** \`Quantity\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private low?: Quantity | undefined;

  /**
   * Range.high Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** High limit
   * - **Definition:** The high limit. The boundary is inclusive.
   * - **Comment:** If the high element is missing, the high boundary is not known.
   * - **FHIR Type:** \`Quantity\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private high?: Quantity | undefined;


  /**
   * @returns the \`low\` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getLow(): Quantity {
    return this.low ?? new Quantity();
  }

  /**
   * Assigns the provided Low object value to the \`low\` property.
   *
   * @param value - the \`low\` object value
   * @returns this
   */
  public setLow(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = \`Invalid Range.low; Provided element is not an instance of Quantity.\`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.low = value;
    } else {
      this.low = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`low\` property exists and has a value; \`false\` otherwise
   */
  public hasLow(): boolean {
    return isDefined<Quantity>(this.low) && !this.low.isEmpty();
  }

  /**
   * @returns the \`high\` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getHigh(): Quantity {
    return this.high ?? new Quantity();
  }

  /**
   * Assigns the provided High object value to the \`high\` property.
   *
   * @param value - the \`high\` object value
   * @returns this
   */
  public setHigh(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = \`Invalid Range.high; Provided element is not an instance of Quantity.\`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.high = value;
    } else {
      this.high = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`high\` property exists and has a value; \`false\` otherwise
   */
  public hasHigh(): boolean {
    return isDefined<Quantity>(this.high) && !this.high.isEmpty();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Range';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.low,
      this.high,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Range {
    const dest = new Range();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Range): void {
    super.copyValues(dest);
    dest.low = this.low?.copy();
    dest.high = this.high?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasLow()) {
      setFhirComplexJson(this.getLow(), 'low', jsonObj);
    }

    if (this.hasHigh()) {
      setFhirComplexJson(this.getHigh(), 'high', jsonObj);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "Range",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 56`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * Ratio Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/Ratio
 * StructureDefinition.name: Ratio
 * StructureDefinition.description: Base StructureDefinition for Ratio Type: A relationship of two Quantity values - expressed as a numerator and a denominator.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  DataType,
  FhirDataTypeParser,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  assertFhirType,
  isDefined,
  isElementEmpty,
  isEmpty,
  setFhirComplexJson,
} from '@paq-ts-fhir/fhir-core';
import {
  PARSABLE_DATATYPE_MAP,
  Quantity,
} from '../index';

/**
 * Ratio Class
 *
 * @remarks
 * Base StructureDefinition for Ratio Type: A relationship of two Quantity values - expressed as a numerator and a denominator.
 *
 * Need to able to capture ratios for some measurements (titers) and some rates (costs).
 *
 * **FHIR Specification**
 * - **Short:** A ratio of two Quantity values - a numerator and a denominator
 * - **Definition:** A relationship of two Quantity values - expressed as a numerator and a denominator.
 * - **Comment:** The Ratio datatype should only be used to express a relationship of two numbers if the relationship cannot be suitably expressed using a Quantity and a common unit.  Where the denominator value is known to be fixed to "1", Quantity should be used instead of Ratio.
 * - **FHIR Version:** 4.0.1
 *
 * @category DataModel: ComplexType
 * @see [FHIR Ratio](http://hl7.org/fhir/StructureDefinition/Ratio)
 */
export class Ratio extends DataType implements IBase {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`Ratio\` JSON to instantiate the Ratio data model.
   *
   * @param sourceJson - JSON representing FHIR \`Ratio\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Ratio
   * @returns Ratio data model or undefined for \`Ratio\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Ratio | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Ratio';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Ratio();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';

    fieldName = 'numerator';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = fhirDataTypeParser.parser<Quantity>(Quantity, classJsonObj[fieldName]!, sourceField);
      instance.setNumerator(datatype);
    }

    fieldName = 'denominator';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = fhirDataTypeParser.parser<Quantity>(Quantity, classJsonObj[fieldName]!, sourceField);
      instance.setDenominator(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Ratio.numerator Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Numerator value
   * - **Definition:** The value of the numerator.
   * - **FHIR Type:** \`Quantity\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private numerator?: Quantity | undefined;

  /**
   * Ratio.denominator Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Denominator value
   * - **Definition:** The value of the denominator.
   * - **FHIR Type:** \`Quantity\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private denominator?: Quantity | undefined;


  /**
   * @returns the \`numerator\` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getNumerator(): Quantity {
    return this.numerator ?? new Quantity();
  }

  /**
   * Assigns the provided Numerator object value to the \`numerator\` property.
   *
   * @param value - the \`numerator\` object value
   * @returns this
   */
  public setNumerator(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = \`Invalid Ratio.numerator; Provided element is not an instance of Quantity.\`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.numerator = value;
    } else {
      this.numerator = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`numerator\` property exists and has a value; \`false\` otherwise
   */
  public hasNumerator(): boolean {
    return isDefined<Quantity>(this.numerator) && !this.numerator.isEmpty();
  }

  /**
   * @returns the \`denominator\` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getDenominator(): Quantity {
    return this.denominator ?? new Quantity();
  }

  /**
   * Assigns the provided Denominator object value to the \`denominator\` property.
   *
   * @param value - the \`denominator\` object value
   * @returns this
   */
  public setDenominator(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = \`Invalid Ratio.denominator; Provided element is not an instance of Quantity.\`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.denominator = value;
    } else {
      this.denominator = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`denominator\` property exists and has a value; \`false\` otherwise
   */
  public hasDenominator(): boolean {
    return isDefined<Quantity>(this.denominator) && !this.denominator.isEmpty();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Ratio';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.numerator,
      this.denominator,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Ratio {
    const dest = new Ratio();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Ratio): void {
    super.copyValues(dest);
    dest.numerator = this.numerator?.copy();
    dest.denominator = this.denominator?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasNumerator()) {
      setFhirComplexJson(this.getNumerator(), 'numerator', jsonObj);
    }

    if (this.hasDenominator()) {
      setFhirComplexJson(this.getDenominator(), 'denominator', jsonObj);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "Ratio",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 57`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * RatioRange Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/RatioRange
 * StructureDefinition.name: RatioRange
 * StructureDefinition.description: RatioRange Type: A range of ratios expressed as a low and high numerator and a denominator.
 * StructureDefinition.fhirVersion: 5.0.0
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  DataType,
  FhirDataTypeParser,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  assertFhirType,
  isDefined,
  isElementEmpty,
  isEmpty,
  setFhirComplexJson,
} from '@paq-ts-fhir/fhir-core';
import {
  PARSABLE_DATATYPE_MAP,
  Quantity,
} from '../index';

/**
 * RatioRange Class
 *
 * @remarks
 * RatioRange Type: A range of ratios expressed as a low and high numerator and a denominator.
 *
 * Need to be able to specify ranges of ratios.
 *
 * **FHIR Specification**
 * - **Short:** Range of ratio values
 * - **Definition:** A range of ratios expressed as a low and high numerator and a denominator.
 * - **Comment:** The stated low and high value are assumed to have arbitrarily high precision when it comes to determining which values are in the range. I.e. 1.99 is not in the range 2 -> 3.
 * - **FHIR Version:** 5.0.0
 *
 * @category DataModel: ComplexType
 * @see [FHIR RatioRange](http://hl7.org/fhir/StructureDefinition/RatioRange)
 */
export class RatioRange extends DataType implements IBase {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`RatioRange\` JSON to instantiate the RatioRange data model.
   *
   * @param sourceJson - JSON representing FHIR \`RatioRange\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to RatioRange
   * @returns RatioRange data model or undefined for \`RatioRange\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): RatioRange | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'RatioRange';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new RatioRange();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';

    fieldName = 'lowNumerator';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = fhirDataTypeParser.parser<Quantity>(Quantity, classJsonObj[fieldName]!, sourceField);
      instance.setLowNumerator(datatype);
    }

    fieldName = 'highNumerator';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = fhirDataTypeParser.parser<Quantity>(Quantity, classJsonObj[fieldName]!, sourceField);
      instance.setHighNumerator(datatype);
    }

    fieldName = 'denominator';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = fhirDataTypeParser.parser<Quantity>(Quantity, classJsonObj[fieldName]!, sourceField);
      instance.setDenominator(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * RatioRange.lowNumerator Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Low Numerator limit
   * - **Definition:** The value of the low limit numerator.
   * - **Comment:** If the low element is missing, the low boundary is not known.
   * - **FHIR Type:** \`Quantity\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private lowNumerator?: Quantity | undefined;

  /**
   * RatioRange.highNumerator Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** High Numerator limit
   * - **Definition:** The value of the high limit numerator.
   * - **Comment:** If the high element is missing, the high boundary is not known.
   * - **FHIR Type:** \`Quantity\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private highNumerator?: Quantity | undefined;

  /**
   * RatioRange.denominator Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Denominator value
   * - **Definition:** The value of the denominator.
   * - **FHIR Type:** \`Quantity\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private denominator?: Quantity | undefined;


  /**
   * @returns the \`lowNumerator\` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getLowNumerator(): Quantity {
    return this.lowNumerator ?? new Quantity();
  }

  /**
   * Assigns the provided LowNumerator object value to the \`lowNumerator\` property.
   *
   * @param value - the \`lowNumerator\` object value
   * @returns this
   */
  public setLowNumerator(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = \`Invalid RatioRange.lowNumerator; Provided element is not an instance of Quantity.\`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.lowNumerator = value;
    } else {
      this.lowNumerator = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`lowNumerator\` property exists and has a value; \`false\` otherwise
   */
  public hasLowNumerator(): boolean {
    return isDefined<Quantity>(this.lowNumerator) && !this.lowNumerator.isEmpty();
  }

  /**
   * @returns the \`highNumerator\` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getHighNumerator(): Quantity {
    return this.highNumerator ?? new Quantity();
  }

  /**
   * Assigns the provided HighNumerator object value to the \`highNumerator\` property.
   *
   * @param value - the \`highNumerator\` object value
   * @returns this
   */
  public setHighNumerator(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = \`Invalid RatioRange.highNumerator; Provided element is not an instance of Quantity.\`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.highNumerator = value;
    } else {
      this.highNumerator = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`highNumerator\` property exists and has a value; \`false\` otherwise
   */
  public hasHighNumerator(): boolean {
    return isDefined<Quantity>(this.highNumerator) && !this.highNumerator.isEmpty();
  }

  /**
   * @returns the \`denominator\` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getDenominator(): Quantity {
    return this.denominator ?? new Quantity();
  }

  /**
   * Assigns the provided Denominator object value to the \`denominator\` property.
   *
   * @param value - the \`denominator\` object value
   * @returns this
   */
  public setDenominator(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = \`Invalid RatioRange.denominator; Provided element is not an instance of Quantity.\`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.denominator = value;
    } else {
      this.denominator = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`denominator\` property exists and has a value; \`false\` otherwise
   */
  public hasDenominator(): boolean {
    return isDefined<Quantity>(this.denominator) && !this.denominator.isEmpty();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'RatioRange';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.lowNumerator,
      this.highNumerator,
      this.denominator,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): RatioRange {
    const dest = new RatioRange();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: RatioRange): void {
    super.copyValues(dest);
    dest.lowNumerator = this.lowNumerator?.copy();
    dest.highNumerator = this.highNumerator?.copy();
    dest.denominator = this.denominator?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasLowNumerator()) {
      setFhirComplexJson(this.getLowNumerator(), 'lowNumerator', jsonObj);
    }

    if (this.hasHighNumerator()) {
      setFhirComplexJson(this.getHighNumerator(), 'highNumerator', jsonObj);
    }

    if (this.hasDenominator()) {
      setFhirComplexJson(this.getDenominator(), 'denominator', jsonObj);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "RatioRange",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 58`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * Reference Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/Reference
 * StructureDefinition.name: Reference
 * StructureDefinition.description: Base StructureDefinition for Reference Type: A reference from one resource to another.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  DataType,
  FhirDataTypeParser,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  StringType,
  UriType,
  assertFhirType,
  fhirString,
  fhirStringSchema,
  fhirUri,
  fhirUriSchema,
  getPrimitiveTypeJson,
  isDefined,
  isElementEmpty,
  isEmpty,
  parseFhirPrimitiveData,
  parseStringType,
  parseUriType,
  setFhirComplexJson,
  setFhirPrimitiveJson,
} from '@paq-ts-fhir/fhir-core';
import {
  Identifier,
  PARSABLE_DATATYPE_MAP,
} from '../index';

/**
 * Reference Class
 *
 * @remarks
 * Base StructureDefinition for Reference Type: A reference from one resource to another.
 *
 * **FHIR Specification**
 * - **Short:** A reference from one resource to another
 * - **Definition:** A reference from one resource to another.
 * - **Comment:** References SHALL be a reference to an actual FHIR resource, and SHALL be resolveable (allowing for access control, temporary unavailability, etc.). Resolution can be either by retrieval from the URL, or, where applicable by resource type, by treating an absolute reference as a canonical URL and looking it up in a local registry/repository.
 * - **FHIR Version:** 4.0.1
 *
 * @category DataModel: ComplexType
 * @see [FHIR Reference](http://hl7.org/fhir/StructureDefinition/Reference)
 */
export class Reference extends DataType implements IBase {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`Reference\` JSON to instantiate the Reference data model.
   *
   * @param sourceJson - JSON representing FHIR \`Reference\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Reference
   * @returns Reference data model or undefined for \`Reference\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Reference | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Reference';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Reference();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'reference';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setReferenceElement(datatype);
    }

    fieldName = 'type';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = parseUriType(dtJson, dtSiblingJson);
      instance.setTypeElement(datatype);
    }

    fieldName = 'identifier';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Identifier | undefined = fhirDataTypeParser.parser<Identifier>(Identifier, classJsonObj[fieldName]!, sourceField);
      instance.setIdentifier(datatype);
    }

    fieldName = 'display';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setDisplayElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Reference.reference Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Literal reference, Relative, internal or absolute URL
   * - **Definition:** A reference to a location at which the other resource is found. The reference may be a relative reference, in which case it is relative to the service base URL, or an absolute URL that resolves to the location where the resource is found. The reference may be version specific or not. If the reference is not to a FHIR RESTful server, then it should be assumed to be version specific. Internal fragment references (start with \\'#\\') refer to contained resources.
   * - **Comment:** Using absolute URLs provides a stable scalable approach suitable for a cloud/web context, while using relative/logical references provides a flexible approach suitable for use when trading across closed eco-system boundaries.   Absolute URLs do not need to point to a FHIR RESTful server, though this is the preferred approach. If the URL conforms to the structure "/[type]/[id]" then it should be assumed that the reference is to a FHIR RESTful server.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private reference?: StringType | undefined;

  /**
   * Reference.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Type the reference refers to (e.g. "Patient")
   * - **Definition:** The expected type of the target of the reference. If both Reference.type and Reference.reference are populated and Reference.reference is a FHIR URL, both SHALL be consistent. The type is the Canonical URL of Resource Definition that is the type this reference refers to. References are URLs that are relative to http://hl7.org/fhir/StructureDefinition/ e.g. "Patient" is a reference to http://hl7.org/fhir/StructureDefinition/Patient. Absolute URLs are only allowed for logical models (and can only be used in references in logical models, not resources).
   * - **Comment:** This element is used to indicate the type of  the target of the reference. This may be used which ever of the other elements are populated (or not). In some cases, the type of the target may be determined by inspection of the reference (e.g. a RESTful URL) or by resolving the target of the reference; if both the type and a reference is provided, the reference SHALL resolve to a resource of the same type as that specified.
   * - **FHIR Type:** \`uri\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private type_?: UriType | undefined;

  /**
   * Reference.identifier Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Logical reference, when literal reference is not known
   * - **Definition:** An identifier for the target resource. This is used when there is no way to reference the other resource directly, either because the entity it represents is not available through a FHIR server, or because there is no way for the author of the resource to convert a known identifier to an actual location. There is no requirement that a Reference.identifier point to something that is actually exposed as a FHIR instance, but it SHALL point to a business concept that would be expected to be exposed as a FHIR instance, and that instance would need to be of a FHIR resource type allowed by the reference.
   * - **Comment:** When an identifier is provided in place of a reference, any system processing the reference will only be able to resolve the identifier to a reference if it understands the business context in which the identifier is used. Sometimes this is global (e.g. a national identifier) but often it is not. For this reason, none of the useful mechanisms described for working with references (e.g. chaining, includes) are possible, nor should servers be expected to be able resolve the reference. Servers may accept an identifier based reference untouched, resolve it, and/or reject it - see CapabilityStatement.rest.resource.referencePolicy.  When both an identifier and a literal reference are provided, the literal reference is preferred. Applications processing the resource are allowed - but not required - to check that the identifier matches the literal reference Applications converting a logical reference to a literal reference may choose to leave the logical reference present, or remove it. Reference is intended to point to a structure that can potentially be expressed as a FHIR resource, though there is no need for it to exist as an actual FHIR resource instance - except in as much as an application wishes to actual find the target of the reference. The content referred to be the identifier must meet the logical constraints implied by any limitations on what resource types are permitted for the reference.  For example, it would not be legitimate to send the identifier for a drug prescription if the type were Reference(Observation|DiagnosticReport).  One of the use-cases for Reference.identifier is the situation where no FHIR representation exists (where the type is Reference (Any).
   * - **FHIR Type:** \`Identifier\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private identifier?: Identifier | undefined;

  /**
   * Reference.display Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Text alternative for the resource
   * - **Definition:** Plain text narrative that identifies the resource in addition to the resource reference.
   * - **Comment:** This is generally not the same as the Resource.text of the referenced resource.  The purpose is to identify what\\'s being referenced, not to fully describe it.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private display?: StringType | undefined;


  /**
   * @returns the \`reference\` property value as a StringType object if defined; else an empty StringType object
   */
  public getReferenceElement(): StringType {
    return this.reference ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`reference\` property.
   *
   * @param element - the \`reference\` value
   * @returns this
   */
  public setReferenceElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Reference.reference; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.reference = element;
    } else {
      this.reference = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`reference\` property exists and has a value; \`false\` otherwise
   */
  public hasReferenceElement(): boolean {
    return isDefined<StringType>(this.reference) && !this.reference.isEmpty();
  }

  /**
   * @returns the \`reference\` property value as a fhirString if defined; else undefined
   */
  public getReference(): fhirString | undefined {
    return this.reference?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`reference\` property.
   *
   * @param value - the \`reference\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setReference(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Reference.reference (\${String(value)})\`;
      this.reference = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.reference = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`reference\` property exists and has a value; \`false\` otherwise
   */
  public hasReference(): boolean {
    return this.hasReferenceElement();
  }

  /**
   * @returns the \`type_\` property value as a UriType object if defined; else an empty UriType object
   */
  public getTypeElement(): UriType {
    return this.type_ ?? new UriType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`type_\` property.
   *
   * @param element - the \`type_\` value
   * @returns this
   */
  public setTypeElement(element: UriType | undefined): this {
    if (isDefined<UriType>(element)) {
      const optErrMsg = \`Invalid Reference.type; Provided element is not an instance of UriType.\`;
      assertFhirType<UriType>(element, UriType, optErrMsg);
      this.type_ = element;
    } else {
      this.type_ = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasTypeElement(): boolean {
    return isDefined<UriType>(this.type_) && !this.type_.isEmpty();
  }

  /**
   * @returns the \`type_\` property value as a fhirUri if defined; else undefined
   */
  public getType(): fhirUri | undefined {
    return this.type_?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`type_\` property.
   *
   * @param value - the \`type_\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setType(value: fhirUri | undefined): this {
    if (isDefined<fhirUri>(value)) {
      const optErrMsg = \`Invalid Reference.type (\${String(value)})\`;
      this.type_ = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    } else {
      this.type_ = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasType(): boolean {
    return this.hasTypeElement();
  }

  /**
   * @returns the \`identifier\` property value as a Identifier object if defined; else an empty Identifier object
   */
  public getIdentifier(): Identifier {
    return this.identifier ?? new Identifier();
  }

  /**
   * Assigns the provided Identifier object value to the \`identifier\` property.
   *
   * @param value - the \`identifier\` object value
   * @returns this
   */
  public setIdentifier(value: Identifier | undefined): this {
    if (isDefined<Identifier>(value)) {
      const optErrMsg = \`Invalid Reference.identifier; Provided element is not an instance of Identifier.\`;
      assertFhirType<Identifier>(value, Identifier, optErrMsg);
      this.identifier = value;
    } else {
      this.identifier = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`identifier\` property exists and has a value; \`false\` otherwise
   */
  public hasIdentifier(): boolean {
    return isDefined<Identifier>(this.identifier) && !this.identifier.isEmpty();
  }

  /**
   * @returns the \`display\` property value as a StringType object if defined; else an empty StringType object
   */
  public getDisplayElement(): StringType {
    return this.display ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`display\` property.
   *
   * @param element - the \`display\` value
   * @returns this
   */
  public setDisplayElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Reference.display; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.display = element;
    } else {
      this.display = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`display\` property exists and has a value; \`false\` otherwise
   */
  public hasDisplayElement(): boolean {
    return isDefined<StringType>(this.display) && !this.display.isEmpty();
  }

  /**
   * @returns the \`display\` property value as a fhirString if defined; else undefined
   */
  public getDisplay(): fhirString | undefined {
    return this.display?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`display\` property.
   *
   * @param value - the \`display\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setDisplay(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Reference.display (\${String(value)})\`;
      this.display = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.display = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`display\` property exists and has a value; \`false\` otherwise
   */
  public hasDisplay(): boolean {
    return this.hasDisplayElement();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Reference';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.reference,
      this.type_,
      this.identifier,
      this.display,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Reference {
    const dest = new Reference();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Reference): void {
    super.copyValues(dest);
    dest.reference = this.reference?.copy();
    dest.type_ = this.type_?.copy();
    dest.identifier = this.identifier?.copy();
    dest.display = this.display?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasReferenceElement()) {
      setFhirPrimitiveJson<fhirString>(this.getReferenceElement(), 'reference', jsonObj);
    }

    if (this.hasTypeElement()) {
      setFhirPrimitiveJson<fhirUri>(this.getTypeElement(), 'type', jsonObj);
    }

    if (this.hasIdentifier()) {
      setFhirComplexJson(this.getIdentifier(), 'identifier', jsonObj);
    }

    if (this.hasDisplayElement()) {
      setFhirPrimitiveJson<fhirString>(this.getDisplayElement(), 'display', jsonObj);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "Reference",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 59`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * RelatedArtifact Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/RelatedArtifact
 * StructureDefinition.name: RelatedArtifact
 * StructureDefinition.description: RelatedArtifact Type: Related artifacts such as additional documentation, justification, or bibliographic references.
 * StructureDefinition.fhirVersion: 5.0.0
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  CanonicalType,
  CodeType,
  DataType,
  DateType,
  EnumCodeType,
  FhirDataTypeParser,
  FhirError,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  MarkdownType,
  REQUIRED_PROPERTIES_DO_NOT_EXIST,
  REQUIRED_PROPERTIES_REQD_IN_JSON,
  StringType,
  assertEnumCodeType,
  assertFhirType,
  assertFhirTypeList,
  assertIsDefined,
  constructorCodeValueAsEnumCodeType,
  copyListValues,
  fhirCanonical,
  fhirCanonicalSchema,
  fhirCode,
  fhirCodeSchema,
  fhirDate,
  fhirDateSchema,
  fhirMarkdown,
  fhirMarkdownSchema,
  fhirString,
  fhirStringSchema,
  getPrimitiveTypeJson,
  isDefined,
  isDefinedList,
  isElementEmpty,
  isEmpty,
  parseCanonicalType,
  parseCodeType,
  parseDateType,
  parseFhirPrimitiveData,
  parseMarkdownType,
  parseStringType,
  setFhirComplexJson,
  setFhirComplexListJson,
  setFhirPrimitiveJson,
} from '@paq-ts-fhir/fhir-core';
import {
  Attachment,
  CodeableConcept,
  PARSABLE_DATATYPE_MAP,
  PublicationStatusEnum,
  Reference,
  ReferenceTargets,
  RelatedArtifactTypeEnum,
} from '../index';

/**
 * RelatedArtifact Class
 *
 * @remarks
 * RelatedArtifact Type: Related artifacts such as additional documentation, justification, or bibliographic references.
 *
 * Knowledge resources must be able to provide enough information for consumers of the content (and/or interventions or results produced by the content) to be able to determine and understand the justification for and evidence in support of the content.
 *
 * **FHIR Specification**
 * - **Short:** Related artifacts for a knowledge resource
 * - **Definition:** Related artifacts such as additional documentation, justification, or bibliographic references.
 * - **Comment:** Each related artifact is either an attachment, or a reference to another knowledge resource, but not both.
 * - **FHIR Version:** 5.0.0
 *
 * @category DataModel: ComplexType
 * @see [FHIR RelatedArtifact](http://hl7.org/fhir/StructureDefinition/RelatedArtifact)
 */
export class RelatedArtifact extends DataType implements IBase {
  constructor(type_: EnumCodeType | CodeType | null = null) {
    super();

    this.relatedArtifactTypeEnum = new RelatedArtifactTypeEnum();
    this.publicationStatusEnum = new PublicationStatusEnum();

    this.type_ = constructorCodeValueAsEnumCodeType<RelatedArtifactTypeEnum>(
      type_,
      RelatedArtifactTypeEnum,
      this.relatedArtifactTypeEnum,
      '.type',
    );
  }

  /**
   * Parse the provided \`RelatedArtifact\` JSON to instantiate the RelatedArtifact data model.
   *
   * @param sourceJson - JSON representing FHIR \`RelatedArtifact\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to RelatedArtifact
   * @returns RelatedArtifact data model or undefined for \`RelatedArtifact\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): RelatedArtifact | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'RelatedArtifact';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new RelatedArtifact();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'type';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setTypeElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'classifier';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: CodeableConcept | undefined = fhirDataTypeParser.parser<CodeableConcept>(CodeableConcept, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addClassifier(datatype);
        }
      });
    }

    fieldName = 'label';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setLabelElement(datatype);
    }

    fieldName = 'display';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setDisplayElement(datatype);
    }

    fieldName = 'citation';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: MarkdownType | undefined = parseMarkdownType(dtJson, dtSiblingJson);
      instance.setCitationElement(datatype);
    }

    fieldName = 'document';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Attachment | undefined = fhirDataTypeParser.parser<Attachment>(Attachment, classJsonObj[fieldName]!, sourceField);
      instance.setDocument(datatype);
    }

    fieldName = 'resource';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CanonicalType | undefined = parseCanonicalType(dtJson, dtSiblingJson);
      instance.setResourceElement(datatype);
    }

    fieldName = 'resourceReference';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = fhirDataTypeParser.parser<Reference>(Reference, classJsonObj[fieldName]!, sourceField);
      instance.setResourceReference(datatype);
    }

    fieldName = 'publicationStatus';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      instance.setPublicationStatusElement(datatype);
    }

    fieldName = 'publicationDate';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DateType | undefined = parseDateType(dtJson, dtSiblingJson);
      instance.setPublicationDateElement(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: RelatedArtifactType
   *
   * @see {@link RelatedArtifactTypeEnum }
   */
  private readonly relatedArtifactTypeEnum: RelatedArtifactTypeEnum;

  /**
   * RelatedArtifact.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** documentation | justification | citation | predecessor | successor | derived-from | depends-on | composed-of | part-of | amends | amended-with | appends | appended-with | cites | cited-by | comments-on | comment-in | contains | contained-in | corrects | correction-in | replaces | replaced-with | retracts | retracted-by | signs | similar-to | supports | supported-with | transforms | transformed-into | transformed-with | documents | specification-of | created-with | cite-as
   * - **Definition:** The type of relationship to the related artifact.
   * - **Comment:** The presence of both sides of a relationship type (e.g. successor and predecessor) is required to support use cases where one side of a relationship is not represented in FHIR. However, this feature SHALL NOT be used to create bi-directional resource links in FHIR instances. Specifically, following the methodology of "new points to old" and "many points to one", when using related artifact elements to describe and reference FHIR resources, the type element SHALL be drawn from the fhir-related-artifact-type ValueSet.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private type_: EnumCodeType | null;

  /**
   * RelatedArtifact.classifier Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Additional classifiers
   * - **Definition:** Provides additional classifiers of the related artifact.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private classifier?: CodeableConcept[] | undefined;

  /**
   * RelatedArtifact.label Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Short label
   * - **Definition:** A short label that can be used to reference the citation from elsewhere in the containing artifact, such as a footnote index.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private label?: StringType | undefined;

  /**
   * RelatedArtifact.display Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Brief description of the related artifact
   * - **Definition:** A brief description of the document or knowledge resource being referenced, suitable for display to a consumer.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private display?: StringType | undefined;

  /**
   * RelatedArtifact.citation Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Bibliographic citation for the artifact
   * - **Definition:** A bibliographic citation for the related artifact. This text SHOULD be formatted according to an accepted citation format.
   * - **Comment:** Additional structured information about citations should be captured as extensions.
   * - **FHIR Type:** \`markdown\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private citation?: MarkdownType | undefined;

  /**
   * RelatedArtifact.document Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** What document is being referenced
   * - **Definition:** The document being referenced, represented as an attachment. This is exclusive with the resource element.
   * - **FHIR Type:** \`Attachment\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private document?: Attachment | undefined;

  /**
   * RelatedArtifact.resource Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** What artifact is being referenced
   * - **Definition:** The related artifact, such as a library, value set, profile, or other knowledge resource.
   * - **Comment:** If the type is predecessor, this is a reference to the succeeding knowledge resource. If the type is successor, this is a reference to the prior knowledge resource.
   * - **FHIR Type:** \`canonical\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Resource',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private resource?: CanonicalType | undefined;

  /**
   * RelatedArtifact.resourceReference Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** What artifact, if not a conformance resource
   * - **Definition:** The related artifact, if the artifact is not a canonical resource, or a resource reference to a canonical resource.
   * - **Comment:** If both resource and resourceReference are present, they SHOULD be consistent and reference the same resource. Although relatedArtifact is intended to support references to definitional resources, there are cases where non-definitional resources can be definitional (such as Location where the kind is mode). Related artifacts SHOULD be used to reference definitional resources, and profiles SHOULD be used to make that explicit for particular use cases.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Resource',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private resourceReference?: Reference | undefined;

  /**
   * FHIR CodeSystem: PublicationStatus
   *
   * @see {@link PublicationStatusEnum }
   */
  private readonly publicationStatusEnum: PublicationStatusEnum;

  /**
   * RelatedArtifact.publicationStatus Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** draft | active | retired | unknown
   * - **Definition:** The publication status of the artifact being referred to.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private publicationStatus?: EnumCodeType | undefined;

  /**
   * RelatedArtifact.publicationDate Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Date of publication of the artifact being referred to
   * - **Definition:** The date of publication of the artifact being referred to.
   * - **FHIR Type:** \`date\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private publicationDate?: DateType | undefined;


  /**
   * @returns the \`type_\` property value as a EnumCodeType if defined; else null
   */
  public getTypeEnumType(): EnumCodeType | null {
    return this.type_;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`type_\` property.
   *
   * @param enumType - the \`type_\` value
   * @returns this
   */
  public setTypeEnumType(enumType: EnumCodeType): this {
    assertIsDefined<EnumCodeType>(enumType, \`RelatedArtifact.type is required\`);
    const errMsgPrefix = \`Invalid RelatedArtifact.type\`;
    assertEnumCodeType<RelatedArtifactTypeEnum>(enumType, RelatedArtifactTypeEnum, errMsgPrefix);
    this.type_ = enumType;
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasTypeEnumType(): boolean {
    return isDefined<EnumCodeType>(this.type_) && !this.type_.isEmpty() && this.type_.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`type_\` property value as a CodeType if defined; else null
   */
  public getTypeElement(): CodeType | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_ as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`type_\` property.
   *
   * @param element - the \`type_\` value
   * @returns this
   */
  public setTypeElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, \`RelatedArtifact.type is required\`);
    const optErrMsg = \`Invalid RelatedArtifact.type; Provided value is not an instance of CodeType.\`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.type_ = new EnumCodeType(element, this.relatedArtifactTypeEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasTypeElement(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the \`type_\` property value as a fhirCode if defined; else null
   */
  public getType(): fhirCode | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`type_\` property.
   *
   * @param value - the \`type_\` value
   * @returns this
   */
  public setType(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, \`RelatedArtifact.type is required\`);
    const optErrMsg = \`Invalid RelatedArtifact.type (\${String(value)})\`;
    this.type_ = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.relatedArtifactTypeEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasType(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the \`classifier\` property value as a CodeableConcept array
   */
  public getClassifier(): CodeableConcept[] {
    return this.classifier ?? ([] as CodeableConcept[]);
  }

  /**
   * Assigns the provided CodeableConcept array value to the \`classifier\` property.
   *
   * @param value - the \`classifier\` array value
   * @returns this
   */
  public setClassifier(value: CodeableConcept[] | undefined): this {
    if (isDefinedList<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid RelatedArtifact.classifier; Provided value array has an element that is not an instance of CodeableConcept.\`;
      assertFhirTypeList<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.classifier = value;
    } else {
      this.classifier = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeableConcept value to the \`classifier\` array property.
   *
   * @param value - the \`classifier\` value
   * @returns this
   */
  public addClassifier(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid RelatedArtifact.classifier; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.initClassifier();
      this.classifier?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`classifier\` property exists and has a value; \`false\` otherwise
   */
  public hasClassifier(): boolean {
    return isDefinedList<CodeableConcept>(this.classifier) && this.classifier.some((item: CodeableConcept) => !item.isEmpty());
  }

  /**
   * Initialize the \`classifier\` property
   */
  private initClassifier(): void {
    if(!this.hasClassifier()) {
      this.classifier = [] as CodeableConcept[];
    }
  }

  /**
   * @returns the \`label\` property value as a StringType object if defined; else an empty StringType object
   */
  public getLabelElement(): StringType {
    return this.label ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`label\` property.
   *
   * @param element - the \`label\` value
   * @returns this
   */
  public setLabelElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid RelatedArtifact.label; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.label = element;
    } else {
      this.label = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`label\` property exists and has a value; \`false\` otherwise
   */
  public hasLabelElement(): boolean {
    return isDefined<StringType>(this.label) && !this.label.isEmpty();
  }

  /**
   * @returns the \`label\` property value as a fhirString if defined; else undefined
   */
  public getLabel(): fhirString | undefined {
    return this.label?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`label\` property.
   *
   * @param value - the \`label\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setLabel(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid RelatedArtifact.label (\${String(value)})\`;
      this.label = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.label = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`label\` property exists and has a value; \`false\` otherwise
   */
  public hasLabel(): boolean {
    return this.hasLabelElement();
  }

  /**
   * @returns the \`display\` property value as a StringType object if defined; else an empty StringType object
   */
  public getDisplayElement(): StringType {
    return this.display ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`display\` property.
   *
   * @param element - the \`display\` value
   * @returns this
   */
  public setDisplayElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid RelatedArtifact.display; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.display = element;
    } else {
      this.display = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`display\` property exists and has a value; \`false\` otherwise
   */
  public hasDisplayElement(): boolean {
    return isDefined<StringType>(this.display) && !this.display.isEmpty();
  }

  /**
   * @returns the \`display\` property value as a fhirString if defined; else undefined
   */
  public getDisplay(): fhirString | undefined {
    return this.display?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`display\` property.
   *
   * @param value - the \`display\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setDisplay(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid RelatedArtifact.display (\${String(value)})\`;
      this.display = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.display = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`display\` property exists and has a value; \`false\` otherwise
   */
  public hasDisplay(): boolean {
    return this.hasDisplayElement();
  }

  /**
   * @returns the \`citation\` property value as a MarkdownType object if defined; else an empty MarkdownType object
   */
  public getCitationElement(): MarkdownType {
    return this.citation ?? new MarkdownType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`citation\` property.
   *
   * @param element - the \`citation\` value
   * @returns this
   */
  public setCitationElement(element: MarkdownType | undefined): this {
    if (isDefined<MarkdownType>(element)) {
      const optErrMsg = \`Invalid RelatedArtifact.citation; Provided element is not an instance of MarkdownType.\`;
      assertFhirType<MarkdownType>(element, MarkdownType, optErrMsg);
      this.citation = element;
    } else {
      this.citation = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`citation\` property exists and has a value; \`false\` otherwise
   */
  public hasCitationElement(): boolean {
    return isDefined<MarkdownType>(this.citation) && !this.citation.isEmpty();
  }

  /**
   * @returns the \`citation\` property value as a fhirMarkdown if defined; else undefined
   */
  public getCitation(): fhirMarkdown | undefined {
    return this.citation?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`citation\` property.
   *
   * @param value - the \`citation\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setCitation(value: fhirMarkdown | undefined): this {
    if (isDefined<fhirMarkdown>(value)) {
      const optErrMsg = \`Invalid RelatedArtifact.citation (\${String(value)})\`;
      this.citation = new MarkdownType(parseFhirPrimitiveData(value, fhirMarkdownSchema, optErrMsg));
    } else {
      this.citation = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`citation\` property exists and has a value; \`false\` otherwise
   */
  public hasCitation(): boolean {
    return this.hasCitationElement();
  }

  /**
   * @returns the \`document\` property value as a Attachment object if defined; else an empty Attachment object
   */
  public getDocument(): Attachment {
    return this.document ?? new Attachment();
  }

  /**
   * Assigns the provided Document object value to the \`document\` property.
   *
   * @param value - the \`document\` object value
   * @returns this
   */
  public setDocument(value: Attachment | undefined): this {
    if (isDefined<Attachment>(value)) {
      const optErrMsg = \`Invalid RelatedArtifact.document; Provided element is not an instance of Attachment.\`;
      assertFhirType<Attachment>(value, Attachment, optErrMsg);
      this.document = value;
    } else {
      this.document = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`document\` property exists and has a value; \`false\` otherwise
   */
  public hasDocument(): boolean {
    return isDefined<Attachment>(this.document) && !this.document.isEmpty();
  }

  /**
   * @returns the \`resource\` property value as a CanonicalType object if defined; else an empty CanonicalType object
   */
  public getResourceElement(): CanonicalType {
    return this.resource ?? new CanonicalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`resource\` property.
   *
   * @param element - the \`resource\` value
   * @returns this
   */
  public setResourceElement(element: CanonicalType | undefined): this {
    if (isDefined<CanonicalType>(element)) {
      const optErrMsg = \`Invalid RelatedArtifact.resource; Provided element is not an instance of CanonicalType.\`;
      assertFhirType<CanonicalType>(element, CanonicalType, optErrMsg);
      this.resource = element;
    } else {
      this.resource = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`resource\` property exists and has a value; \`false\` otherwise
   */
  public hasResourceElement(): boolean {
    return isDefined<CanonicalType>(this.resource) && !this.resource.isEmpty();
  }

  /**
   * @returns the \`resource\` property value as a fhirCanonical if defined; else undefined
   */
  public getResource(): fhirCanonical | undefined {
    return this.resource?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`resource\` property.
   *
   * @param value - the \`resource\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setResource(value: fhirCanonical | undefined): this {
    if (isDefined<fhirCanonical>(value)) {
      const optErrMsg = \`Invalid RelatedArtifact.resource (\${String(value)})\`;
      this.resource = new CanonicalType(parseFhirPrimitiveData(value, fhirCanonicalSchema, optErrMsg));
    } else {
      this.resource = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`resource\` property exists and has a value; \`false\` otherwise
   */
  public hasResource(): boolean {
    return this.hasResourceElement();
  }

  /**
   * @returns the \`resourceReference\` property value as a Reference object; else an empty Reference object
   */
  public getResourceReference(): Reference {
    return this.resourceReference ?? new Reference();
  }

  /**
   * Assigns the provided ResourceReference object value to the \`resourceReference\` property.
   *
   * @decorator \`@ReferenceTargets('RelatedArtifact.resourceReference', ['Resource',])\`
   *
   * @param value - the \`resourceReference\` object value
   * @returns this
   */
  @ReferenceTargets('RelatedArtifact.resourceReference', [
    'Resource',
  ])
  public setResourceReference(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.resourceReference = value;
    } else {
      this.resourceReference = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`resourceReference\` property exists and has a value; \`false\` otherwise
   */
  public hasResourceReference(): boolean {
    return isDefined<Reference>(this.resourceReference) && !this.resourceReference.isEmpty();
  }

  /**
   * @returns the \`publicationStatus\` property value as a EnumCodeType if defined; else undefined
   */
  public getPublicationStatusEnumType(): EnumCodeType | undefined {
    return this.publicationStatus;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`publicationStatus\` property.
   *
   * @param enumType - the \`publicationStatus\` value
   * @returns this
   */
  public setPublicationStatusEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid RelatedArtifact.publicationStatus';
      assertEnumCodeType<PublicationStatusEnum>(enumType, PublicationStatusEnum, errMsgPrefix);
      this.publicationStatus = enumType;
    } else {
      this.publicationStatus = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`publicationStatus\` property exists and has a value; \`false\` otherwise
   */
  public hasPublicationStatusEnumType(): boolean {
    return isDefined<EnumCodeType>(this.publicationStatus) && !this.publicationStatus.isEmpty() && this.publicationStatus.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`publicationStatus\` property value as a CodeType if defined; else undefined
   */
  public getPublicationStatusElement(): CodeType | undefined {
    if (this.publicationStatus === undefined) {
      return undefined;
    }
    return this.publicationStatus as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`publicationStatus\` property.
   *
   * @param element - the \`publicationStatus\` value
   * @returns this
   */
  public setPublicationStatusElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid RelatedArtifact.publicationStatus; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.publicationStatus = new EnumCodeType(element, this.publicationStatusEnum);
    } else {
      this.publicationStatus = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`publicationStatus\` property exists and has a value; \`false\` otherwise
   */
  public hasPublicationStatusElement(): boolean {
    return this.hasPublicationStatusEnumType();
  }

  /**
   * @returns the \`publicationStatus\` property value as a fhirCode if defined; else undefined
   */
  public getPublicationStatus(): fhirCode | undefined {
    if (this.publicationStatus === undefined) {
      return undefined;
    }
    return this.publicationStatus.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`publicationStatus\` property.
   *
   * @param value - the \`publicationStatus\` value
   * @returns this
   */
  public setPublicationStatus(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid RelatedArtifact.publicationStatus; Provided value is not an instance of fhirCode.\`;
      this.publicationStatus = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.publicationStatusEnum);
    } else {
      this.publicationStatus = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`publicationStatus\` property exists and has a value; \`false\` otherwise
   */
  public hasPublicationStatus(): boolean {
    return this.hasPublicationStatusEnumType();
  }

  /**
   * @returns the \`publicationDate\` property value as a DateType object if defined; else an empty DateType object
   */
  public getPublicationDateElement(): DateType {
    return this.publicationDate ?? new DateType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`publicationDate\` property.
   *
   * @param element - the \`publicationDate\` value
   * @returns this
   */
  public setPublicationDateElement(element: DateType | undefined): this {
    if (isDefined<DateType>(element)) {
      const optErrMsg = \`Invalid RelatedArtifact.publicationDate; Provided element is not an instance of DateType.\`;
      assertFhirType<DateType>(element, DateType, optErrMsg);
      this.publicationDate = element;
    } else {
      this.publicationDate = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`publicationDate\` property exists and has a value; \`false\` otherwise
   */
  public hasPublicationDateElement(): boolean {
    return isDefined<DateType>(this.publicationDate) && !this.publicationDate.isEmpty();
  }

  /**
   * @returns the \`publicationDate\` property value as a fhirDate if defined; else undefined
   */
  public getPublicationDate(): fhirDate | undefined {
    return this.publicationDate?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`publicationDate\` property.
   *
   * @param value - the \`publicationDate\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setPublicationDate(value: fhirDate | undefined): this {
    if (isDefined<fhirDate>(value)) {
      const optErrMsg = \`Invalid RelatedArtifact.publicationDate (\${String(value)})\`;
      this.publicationDate = new DateType(parseFhirPrimitiveData(value, fhirDateSchema, optErrMsg));
    } else {
      this.publicationDate = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`publicationDate\` property exists and has a value; \`false\` otherwise
   */
  public hasPublicationDate(): boolean {
    return this.hasPublicationDateElement();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'RelatedArtifact';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.type_,
      this.classifier,
      this.label,
      this.display,
      this.citation,
      this.document,
      this.resource,
      this.resourceReference,
      this.publicationStatus,
      this.publicationDate,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): RelatedArtifact {
    const dest = new RelatedArtifact();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: RelatedArtifact): void {
    super.copyValues(dest);
    dest.type_ = this.type_ ? this.type_.copy() : null;
    const classifierList = copyListValues<CodeableConcept>(this.classifier);
    dest.classifier = classifierList.length === 0 ? undefined : classifierList;
    dest.label = this.label?.copy();
    dest.display = this.display?.copy();
    dest.citation = this.citation?.copy();
    dest.document = this.document?.copy();
    dest.resource = this.resource?.copy();
    dest.resourceReference = this.resourceReference?.copy();
    dest.publicationStatus = this.publicationStatus?.copy();
    dest.publicationDate = this.publicationDate?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasTypeElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getTypeElement()!, 'type', jsonObj);
    } else {
      missingReqdProperties.push(\`RelatedArtifact.type\`);
    }

    if (this.hasClassifier()) {
      setFhirComplexListJson(this.getClassifier(), 'classifier', jsonObj);
    }

    if (this.hasLabelElement()) {
      setFhirPrimitiveJson<fhirString>(this.getLabelElement(), 'label', jsonObj);
    }

    if (this.hasDisplayElement()) {
      setFhirPrimitiveJson<fhirString>(this.getDisplayElement(), 'display', jsonObj);
    }

    if (this.hasCitationElement()) {
      setFhirPrimitiveJson<fhirMarkdown>(this.getCitationElement(), 'citation', jsonObj);
    }

    if (this.hasDocument()) {
      setFhirComplexJson(this.getDocument(), 'document', jsonObj);
    }

    if (this.hasResourceElement()) {
      setFhirPrimitiveJson<fhirCanonical>(this.getResourceElement(), 'resource', jsonObj);
    }

    if (this.hasResourceReference()) {
      setFhirComplexJson(this.getResourceReference(), 'resourceReference', jsonObj);
    }

    if (this.hasPublicationStatusElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getPublicationStatusElement()!, 'publicationStatus', jsonObj);
    }

    if (this.hasPublicationDateElement()) {
      setFhirPrimitiveJson<fhirDate>(this.getPublicationDateElement(), 'publicationDate', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "RelatedArtifact",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 60`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * RelativeTime Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/RelativeTime
 * StructureDefinition.name: RelativeTime
 * StructureDefinition.description: RelativeTime Type: RelativeTime is used to express a point in time or an interval of time relative to an event defined in data types other than dateTime.
 * StructureDefinition.fhirVersion: 6.0.0-ballot3
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  BackboneType,
  CanonicalType,
  ChoiceDataTypes,
  ChoiceDataTypesMeta,
  DataType,
  FhirDataTypeParser,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  InvalidTypeError,
  JSON,
  StringType,
  assertFhirType,
  assertIsDefined,
  fhirCanonical,
  fhirCanonicalSchema,
  fhirString,
  fhirStringSchema,
  getPrimitiveTypeJson,
  isDefined,
  isElementEmpty,
  isEmpty,
  parseCanonicalType,
  parseFhirPrimitiveData,
  parseStringType,
  setFhirComplexJson,
  setFhirPrimitiveJson,
  setPolymorphicValueJson,
} from '@paq-ts-fhir/fhir-core';
import {
  CodeableConcept,
  Duration,
  PARSABLE_DATATYPE_MAP,
  Range,
  Reference,
  ReferenceTargets,
} from '../index';

// eslint-disable-next-line @typescript-eslint/no-explicit-any -- Symbol.metadata polyfill secret sauce for decorator metadata
(Symbol.metadata as any) ??= Symbol('Symbol.metadata');

/**
 * RelativeTime Class
 *
 * @remarks
 * RelativeTime Type: RelativeTime is used to express a point in time or an interval of time relative to an event defined in data types other than dateTime.
 *
 * **FHIR Specification**
 * - **Short:** A point in time or an interval of time relative to an event
 * - **Definition:** RelativeTime is used to express a point in time or an interval of time relative to an event defined in data types other than dateTime.
 * - **FHIR Version:** 6.0.0-ballot3
 *
 * @category DataModel: ComplexType
 * @see [FHIR RelativeTime](http://hl7.org/fhir/StructureDefinition/RelativeTime)
 */
export class RelativeTime extends BackboneType implements IBase {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`RelativeTime\` JSON to instantiate the RelativeTime data model.
   *
   * @param sourceJson - JSON representing FHIR \`RelativeTime\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to RelativeTime
   * @returns RelativeTime data model or undefined for \`RelativeTime\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): RelativeTime | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'RelativeTime';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new RelativeTime();
    fhirDataTypeParser.processBackboneTypeJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const classMetadata: DecoratorMetadataObject | null = RelativeTime[Symbol.metadata];
    const errorMessage = \`DecoratorMetadataObject does not exist for RelativeTime\`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    fieldName = 'contextReference';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = fhirDataTypeParser.parser<Reference>(Reference, classJsonObj[fieldName]!, sourceField);
      instance.setContextReference(datatype);
    }

    fieldName = 'contextDefinition';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CanonicalType | undefined = parseCanonicalType(dtJson, dtSiblingJson);
      instance.setContextDefinitionElement(datatype);
    }

    fieldName = 'contextPath';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setContextPathElement(datatype);
    }

    fieldName = 'contextCode';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = fhirDataTypeParser.parser<CodeableConcept>(CodeableConcept, classJsonObj[fieldName]!, sourceField);
      instance.setContextCode(datatype);
    }

    fieldName = 'offset[x]';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const offset: DataType | undefined = fhirDataTypeParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setOffset(offset);

    fieldName = 'text';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setTextElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * RelativeTime.contextReference Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The specific event occurrence or resource context used as a base point (reference point) in time
   * - **Definition:** The specific event occurrence or resource context used as a base point (reference point) in time.  This establishes the context in which the \\'path\\' is evaluated.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Resource',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private contextReference?: Reference | undefined;

  /**
   * RelativeTime.contextDefinition Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The type of event used as a base point
   * - **Definition:** The type of event used as a base point.  Instances of this definition will establish the context for evaluating the path to determine the base time for the offset.
   * - **FHIR Type:** \`canonical\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/ActivityDefinition',
   *       'http://hl7.org/fhir/StructureDefinition/PlanDefinition',
   *       'http://hl7.org/fhir/StructureDefinition/ObservationDefinition',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private contextDefinition?: CanonicalType | undefined;

  /**
   * RelativeTime.contextPath Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Path to the element defining the point in time
   * - **Definition:** Path to the element defining the point in time. Any valid FHIRPath expression.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private contextPath?: StringType | undefined;

  /**
   * RelativeTime.contextCode Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Coded representation of the event used as a base point (reference point) in time
   * - **Definition:** Coded representation of the event used as a base point (reference point) in time.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private contextCode?: CodeableConcept | undefined;

  /**
   * RelativeTime.offset[x] Element
   *
   * @decorator \`@ChoiceDataTypesMeta('RelativeTime.offset[x]', ['Duration','Range',]\`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** An offset or offset range before (negative values) or after (positive values) the event
   * - **Definition:** An offset or offset range before (negative values) or after (positive values) the event. Range is limited to time-valued quantities (Durations).
   * - **FHIR Types:**
   *     'Duration',
   *     'Range',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  @ChoiceDataTypesMeta('RelativeTime.offset[x]',[
    'Duration',
    'Range',
  ])
  private offset?: DataType | undefined;

  /**
   * RelativeTime.text Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Free-text description
   * - **Definition:** Free-text (human-readable) description.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private text?: StringType | undefined;


  /**
   * @returns the \`contextReference\` property value as a Reference object; else an empty Reference object
   */
  public getContextReference(): Reference {
    return this.contextReference ?? new Reference();
  }

  /**
   * Assigns the provided ContextReference object value to the \`contextReference\` property.
   *
   * @decorator \`@ReferenceTargets('RelativeTime.contextReference', ['Resource',])\`
   *
   * @param value - the \`contextReference\` object value
   * @returns this
   */
  @ReferenceTargets('RelativeTime.contextReference', [
    'Resource',
  ])
  public setContextReference(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.contextReference = value;
    } else {
      this.contextReference = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`contextReference\` property exists and has a value; \`false\` otherwise
   */
  public hasContextReference(): boolean {
    return isDefined<Reference>(this.contextReference) && !this.contextReference.isEmpty();
  }

  /**
   * @returns the \`contextDefinition\` property value as a CanonicalType object if defined; else an empty CanonicalType object
   */
  public getContextDefinitionElement(): CanonicalType {
    return this.contextDefinition ?? new CanonicalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`contextDefinition\` property.
   *
   * @param element - the \`contextDefinition\` value
   * @returns this
   */
  public setContextDefinitionElement(element: CanonicalType | undefined): this {
    if (isDefined<CanonicalType>(element)) {
      const optErrMsg = \`Invalid RelativeTime.contextDefinition; Provided element is not an instance of CanonicalType.\`;
      assertFhirType<CanonicalType>(element, CanonicalType, optErrMsg);
      this.contextDefinition = element;
    } else {
      this.contextDefinition = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`contextDefinition\` property exists and has a value; \`false\` otherwise
   */
  public hasContextDefinitionElement(): boolean {
    return isDefined<CanonicalType>(this.contextDefinition) && !this.contextDefinition.isEmpty();
  }

  /**
   * @returns the \`contextDefinition\` property value as a fhirCanonical if defined; else undefined
   */
  public getContextDefinition(): fhirCanonical | undefined {
    return this.contextDefinition?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`contextDefinition\` property.
   *
   * @param value - the \`contextDefinition\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setContextDefinition(value: fhirCanonical | undefined): this {
    if (isDefined<fhirCanonical>(value)) {
      const optErrMsg = \`Invalid RelativeTime.contextDefinition (\${String(value)})\`;
      this.contextDefinition = new CanonicalType(parseFhirPrimitiveData(value, fhirCanonicalSchema, optErrMsg));
    } else {
      this.contextDefinition = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`contextDefinition\` property exists and has a value; \`false\` otherwise
   */
  public hasContextDefinition(): boolean {
    return this.hasContextDefinitionElement();
  }

  /**
   * @returns the \`contextPath\` property value as a StringType object if defined; else an empty StringType object
   */
  public getContextPathElement(): StringType {
    return this.contextPath ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`contextPath\` property.
   *
   * @param element - the \`contextPath\` value
   * @returns this
   */
  public setContextPathElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid RelativeTime.contextPath; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.contextPath = element;
    } else {
      this.contextPath = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`contextPath\` property exists and has a value; \`false\` otherwise
   */
  public hasContextPathElement(): boolean {
    return isDefined<StringType>(this.contextPath) && !this.contextPath.isEmpty();
  }

  /**
   * @returns the \`contextPath\` property value as a fhirString if defined; else undefined
   */
  public getContextPath(): fhirString | undefined {
    return this.contextPath?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`contextPath\` property.
   *
   * @param value - the \`contextPath\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setContextPath(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid RelativeTime.contextPath (\${String(value)})\`;
      this.contextPath = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.contextPath = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`contextPath\` property exists and has a value; \`false\` otherwise
   */
  public hasContextPath(): boolean {
    return this.hasContextPathElement();
  }

  /**
   * @returns the \`contextCode\` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getContextCode(): CodeableConcept {
    return this.contextCode ?? new CodeableConcept();
  }

  /**
   * Assigns the provided ContextCode object value to the \`contextCode\` property.
   *
   * @param value - the \`contextCode\` object value
   * @returns this
   */
  public setContextCode(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid RelativeTime.contextCode; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.contextCode = value;
    } else {
      this.contextCode = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`contextCode\` property exists and has a value; \`false\` otherwise
   */
  public hasContextCode(): boolean {
    return isDefined<CodeableConcept>(this.contextCode) && !this.contextCode.isEmpty();
  }

  /**
   * @returns the \`offset\` property value as a DataType object if defined; else undefined
   */
  public getOffset(): DataType | undefined {
    return this.offset;
  }

  /**
   * Assigns the provided DataType object value to the \`offset\` property.
   *
   * @decorator \`@ChoiceDataTypes('RelativeTime.offset[x]')\`
   *
   * @param value - the \`offset\` object value
   * @returns this
   */
  @ChoiceDataTypes('RelativeTime.offset[x]')
  public setOffset(value: DataType | undefined): this {
    if (isDefined<DataType>(value)) {
      // assertFhirType<DataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.offset = value;
    } else {
      this.offset = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`offset\` property exists and has a value; \`false\` otherwise
   */
  public hasOffset(): boolean {
    return isDefined<DataType>(this.offset) && !this.offset.isEmpty();
  }

  // *** NOTE ***
  // Next "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the \`offset\` property value as a Duration object if defined; else undefined
   */
  public getOffsetDuration(): Duration | undefined {
    if (!isDefined<DataType | undefined>(this.offset)) {
      return undefined;
    }
    if (!(this.offset instanceof Duration)) {
      throw new InvalidTypeError(
        \`DataType mismatch for RelativeTime.offset[x]: Expected Duration but encountered \${this.offset.fhirType()}\`,
      );
    }
    return this.offset;
  }

  /**
   * @returns \`true\` if the \`offset\` property exists as a Duration and has a value; \`false\` otherwise
   */
  public hasOffsetDuration(): boolean {
    return this.hasOffset() && this.offset instanceof Duration;
  }

  /**
   * @returns the \`offset\` property value as a Range object if defined; else undefined
   */
  public getOffsetRange(): Range | undefined {
    if (!isDefined<DataType | undefined>(this.offset)) {
      return undefined;
    }
    if (!(this.offset instanceof Range)) {
      throw new InvalidTypeError(
        \`DataType mismatch for RelativeTime.offset[x]: Expected Range but encountered \${this.offset.fhirType()}\`,
      );
    }
    return this.offset;
  }

  /**
   * @returns \`true\` if the \`offset\` property exists as a Range and has a value; \`false\` otherwise
   */
  public hasOffsetRange(): boolean {
    return this.hasOffset() && this.offset instanceof Range;
  }

  /**
   * @returns the \`text\` property value as a StringType object if defined; else an empty StringType object
   */
  public getTextElement(): StringType {
    return this.text ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`text\` property.
   *
   * @param element - the \`text\` value
   * @returns this
   */
  public setTextElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid RelativeTime.text; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.text = element;
    } else {
      this.text = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`text\` property exists and has a value; \`false\` otherwise
   */
  public hasTextElement(): boolean {
    return isDefined<StringType>(this.text) && !this.text.isEmpty();
  }

  /**
   * @returns the \`text\` property value as a fhirString if defined; else undefined
   */
  public getText(): fhirString | undefined {
    return this.text?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`text\` property.
   *
   * @param value - the \`text\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setText(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid RelativeTime.text (\${String(value)})\`;
      this.text = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.text = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`text\` property exists and has a value; \`false\` otherwise
   */
  public hasText(): boolean {
    return this.hasTextElement();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'RelativeTime';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.contextReference,
      this.contextDefinition,
      this.contextPath,
      this.contextCode,
      this.offset,
      this.text,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): RelativeTime {
    const dest = new RelativeTime();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: RelativeTime): void {
    super.copyValues(dest);
    dest.contextReference = this.contextReference?.copy();
    dest.contextDefinition = this.contextDefinition?.copy();
    dest.contextPath = this.contextPath?.copy();
    dest.contextCode = this.contextCode?.copy();
    dest.offset = this.offset?.copy();
    dest.text = this.text?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasContextReference()) {
      setFhirComplexJson(this.getContextReference(), 'contextReference', jsonObj);
    }

    if (this.hasContextDefinitionElement()) {
      setFhirPrimitiveJson<fhirCanonical>(this.getContextDefinitionElement(), 'contextDefinition', jsonObj);
    }

    if (this.hasContextPathElement()) {
      setFhirPrimitiveJson<fhirString>(this.getContextPathElement(), 'contextPath', jsonObj);
    }

    if (this.hasContextCode()) {
      setFhirComplexJson(this.getContextCode(), 'contextCode', jsonObj);
    }

    if (this.hasOffset()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getOffset()!, 'offset', jsonObj);
    }

    if (this.hasTextElement()) {
      setFhirPrimitiveJson<fhirString>(this.getTextElement(), 'text', jsonObj);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "RelativeTime",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 61`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * SampledData Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/SampledData
 * StructureDefinition.name: SampledData
 * StructureDefinition.description: SampledData Type: A series of measurements taken by a device, with upper and lower limits. There may be more than one dimension in the data.
 * StructureDefinition.fhirVersion: 5.0.0
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  CanonicalType,
  CodeType,
  DataType,
  DecimalType,
  FhirDataTypeParser,
  FhirError,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  PositiveIntType,
  PrimitiveType,
  REQUIRED_PROPERTIES_DO_NOT_EXIST,
  REQUIRED_PROPERTIES_REQD_IN_JSON,
  StringType,
  assertFhirType,
  assertIsDefined,
  fhirCanonical,
  fhirCanonicalSchema,
  fhirCode,
  fhirCodeSchema,
  fhirDecimal,
  fhirDecimalSchema,
  fhirPositiveInt,
  fhirPositiveIntSchema,
  fhirString,
  fhirStringSchema,
  getPrimitiveTypeJson,
  isDefined,
  isElementEmpty,
  isEmpty,
  parseCanonicalType,
  parseCodeType,
  parseDecimalType,
  parseFhirPrimitiveData,
  parsePositiveIntType,
  parseStringType,
  setFhirComplexJson,
  setFhirPrimitiveJson,
} from '@paq-ts-fhir/fhir-core';
import {
  PARSABLE_DATATYPE_MAP,
  Quantity,
} from '../index';

/**
 * SampledData Class
 *
 * @remarks
 * SampledData Type: A series of measurements taken by a device, with upper and lower limits. There may be more than one dimension in the data.
 *
 * There is a need for a concise way to handle the data produced by devices that sample a physical state at a high frequency.
 *
 * **FHIR Specification**
 * - **Short:** A series of measurements taken by a device
 * - **Definition:** A series of measurements taken by a device, with upper and lower limits. There may be more than one dimension in the data.
 * - **Comment:** The data is not interpretable without at least origin, period, and dimensions, but these are optional to allow a separation between the template of measurement and the actual measurement, such as between DeviceCapabilities and DeviceLog.  When providing a summary view (for example with Observation.value[x]) SampledData should be represented with a brief display text such as "Sampled Data".
 * - **FHIR Version:** 5.0.0
 *
 * @category DataModel: ComplexType
 * @see [FHIR SampledData](http://hl7.org/fhir/StructureDefinition/SampledData)
 */
export class SampledData extends DataType implements IBase {
  constructor(origin: Quantity | null = null, intervalUnit: CodeType | fhirCode | null = null, dimensions: PositiveIntType | fhirPositiveInt | null = null) {
    super();

    this.origin = null;
    if (isDefined<Quantity>(origin)) {
      this.setOrigin(origin);
    }

    this.intervalUnit = null;
    if (isDefined<CodeType | fhirCode>(intervalUnit)) {
      if (intervalUnit instanceof PrimitiveType) {
        this.setIntervalUnitElement(intervalUnit);
      } else {
        this.setIntervalUnit(intervalUnit);
      }
    }

    this.dimensions = null;
    if (isDefined<PositiveIntType | fhirPositiveInt>(dimensions)) {
      if (dimensions instanceof PrimitiveType) {
        this.setDimensionsElement(dimensions);
      } else {
        this.setDimensions(dimensions);
      }
    }
  }

  /**
   * Parse the provided \`SampledData\` JSON to instantiate the SampledData data model.
   *
   * @param sourceJson - JSON representing FHIR \`SampledData\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to SampledData
   * @returns SampledData data model or undefined for \`SampledData\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): SampledData | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'SampledData';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new SampledData();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'origin';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = fhirDataTypeParser.parser<Quantity>(Quantity, classJsonObj[fieldName]!, sourceField);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setOrigin(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'interval';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = parseDecimalType(dtJson, dtSiblingJson);
      instance.setIntervalElement(datatype);
    }

    fieldName = 'intervalUnit';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setIntervalUnitElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'factor';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = parseDecimalType(dtJson, dtSiblingJson);
      instance.setFactorElement(datatype);
    }

    fieldName = 'lowerLimit';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = parseDecimalType(dtJson, dtSiblingJson);
      instance.setLowerLimitElement(datatype);
    }

    fieldName = 'upperLimit';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = parseDecimalType(dtJson, dtSiblingJson);
      instance.setUpperLimitElement(datatype);
    }

    fieldName = 'dimensions';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = parsePositiveIntType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setDimensionsElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'codeMap';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CanonicalType | undefined = parseCanonicalType(dtJson, dtSiblingJson);
      instance.setCodeMapElement(datatype);
    }

    fieldName = 'offsets';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setOffsetsElement(datatype);
    }

    fieldName = 'data';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setDataElement(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * SampledData.origin Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Zero value and units
   * - **Definition:** The base quantity that a measured value of zero represents. In addition, this provides the units of the entire measurement series.
   * - **FHIR Type:** \`Quantity\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private origin: Quantity | null;

  /**
   * SampledData.interval Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Number of intervalUnits between samples
   * - **Definition:** Amount of intervalUnits between samples, e.g. milliseconds for time-based sampling.
   * - **Comment:** This is usually a whole number.
   * - **FHIR Type:** \`decimal\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private interval?: DecimalType | undefined;

  /**
   * SampledData.intervalUnit Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The measurement unit of the interval between samples
   * - **Definition:** The measurement unit in which the sample interval is expressed.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private intervalUnit: CodeType | null;

  /**
   * SampledData.factor Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Multiply data by this before adding to origin
   * - **Definition:** A correction factor that is applied to the sampled data points before they are added to the origin.
   * - **FHIR Type:** \`decimal\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private factor?: DecimalType | undefined;

  /**
   * SampledData.lowerLimit Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Lower limit of detection
   * - **Definition:** The lower limit of detection of the measured points. This is needed if any of the data points have the value "L" (lower than detection limit).
   * - **FHIR Type:** \`decimal\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private lowerLimit?: DecimalType | undefined;

  /**
   * SampledData.upperLimit Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Upper limit of detection
   * - **Definition:** The upper limit of detection of the measured points. This is needed if any of the data points have the value "U" (higher than detection limit).
   * - **FHIR Type:** \`decimal\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private upperLimit?: DecimalType | undefined;

  /**
   * SampledData.dimensions Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Number of sample points at each time point
   * - **Definition:** The number of sample points at each time point. If this value is greater than one, then the dimensions will be interlaced - all the sample points for a point in time will be recorded at once.
   * - **Comment:** If there is more than one dimension, the code for the type of data will define the meaning of the dimensions (typically ECG data).
   * - **FHIR Type:** \`positiveInt\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private dimensions: PositiveIntType | null;

  /**
   * SampledData.codeMap Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Defines the codes used in the data
   * - **Definition:** Reference to ConceptMap that defines the codes used in the data.
   * - **Comment:** The ConceptMap cannot define meanings for the codes \\'E\\', \\'U\\', or \\'L\\' (nor \\'e\\', \\'u\\', or \\'l\\').
   * - **FHIR Type:** \`canonical\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/ConceptMap',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private codeMap?: CanonicalType | undefined;

  /**
   * SampledData.offsets Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Offsets, typically in time, at which data values were taken
   * - **Definition:** A series of data points which are decimal values separated by a single space (character u20).  The units in which the offsets are expressed are found in intervalUnit.  The absolute point at which the measurements begin SHALL be conveyed outside the scope of this datatype, e.g. Observation.effectiveDateTime for a timing offset.
   * - **Comment:** If offsets is present, the number of data points must be equal to the number of offsets mlutipled by the dimensions.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private offsets?: StringType | undefined;

  /**
   * SampledData.data Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Decimal values with spaces, or "E" | "U" | "L", or another code
   * - **Definition:** A series of data points which are decimal values or codes separated by a single space (character u20). The special codes "E" (error), "L" (below detection limit) and "U" (above detection limit) are also defined for used in place of decimal values.
   * - **Comment:** The data may be missing if it is omitted for summarization purposes. In general, data is required for any actual use of a SampledData.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private data?: StringType | undefined;


  /**
   * @returns the \`origin\` property value as a Quantity object if defined; else null
   */
  public getOrigin(): Quantity | null {
    return this.origin;
  }

  /**
   * Assigns the provided Quantity object value to the \`origin\` property.
   *
   * @param value - the \`origin\` object value
   * @returns this
   */
  public setOrigin(value: Quantity): this {
    assertIsDefined<Quantity>(value, \`SampledData.origin is required\`);
    const optErrMsg = \`Invalid SampledData.origin; Provided element is not an instance of Quantity.\`;
    assertFhirType<Quantity>(value, Quantity, optErrMsg);
    this.origin = value;
    return this;
  }

  /**
   * @returns \`true\` if the \`origin\` property exists and has a value; \`false\` otherwise
   */
  public hasOrigin(): boolean {
    return isDefined<Quantity>(this.origin) && !this.origin.isEmpty();
  }

  /**
   * @returns the \`interval\` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getIntervalElement(): DecimalType {
    return this.interval ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`interval\` property.
   *
   * @param element - the \`interval\` value
   * @returns this
   */
  public setIntervalElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = \`Invalid SampledData.interval; Provided element is not an instance of DecimalType.\`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.interval = element;
    } else {
      this.interval = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`interval\` property exists and has a value; \`false\` otherwise
   */
  public hasIntervalElement(): boolean {
    return isDefined<DecimalType>(this.interval) && !this.interval.isEmpty();
  }

  /**
   * @returns the \`interval\` property value as a fhirDecimal if defined; else undefined
   */
  public getInterval(): fhirDecimal | undefined {
    return this.interval?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`interval\` property.
   *
   * @param value - the \`interval\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setInterval(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = \`Invalid SampledData.interval (\${String(value)})\`;
      this.interval = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.interval = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`interval\` property exists and has a value; \`false\` otherwise
   */
  public hasInterval(): boolean {
    return this.hasIntervalElement();
  }

  /**
   * @returns the \`intervalUnit\` property value as a CodeType object if defined; else null
   */
  public getIntervalUnitElement(): CodeType | null {
    return this.intervalUnit;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`intervalUnit\` property.
   *
   * @param element - the \`intervalUnit\` value
   * @returns this
   */
  public setIntervalUnitElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, \`SampledData.intervalUnit is required\`);
    const optErrMsg = \`Invalid SampledData.intervalUnit; Provided value is not an instance of CodeType.\`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.intervalUnit = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`intervalUnit\` property exists and has a value; \`false\` otherwise
   */
  public hasIntervalUnitElement(): boolean {
    return isDefined<CodeType>(this.intervalUnit) && !this.intervalUnit.isEmpty();
  }

  /**
   * @returns the \`intervalUnit\` property value as a fhirCode if defined; else null
   */
  public getIntervalUnit(): fhirCode | null {
    if (this.intervalUnit?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.intervalUnit.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`intervalUnit\` property.
   *
   * @param value - the \`intervalUnit\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setIntervalUnit(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, \`SampledData.intervalUnit is required\`);
    const optErrMsg = \`Invalid SampledData.intervalUnit (\${String(value)})\`;
    this.intervalUnit = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`intervalUnit\` property exists and has a value; \`false\` otherwise
   */
  public hasIntervalUnit(): boolean {
    return this.hasIntervalUnitElement();
  }

  /**
   * @returns the \`factor\` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getFactorElement(): DecimalType {
    return this.factor ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`factor\` property.
   *
   * @param element - the \`factor\` value
   * @returns this
   */
  public setFactorElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = \`Invalid SampledData.factor; Provided element is not an instance of DecimalType.\`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.factor = element;
    } else {
      this.factor = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`factor\` property exists and has a value; \`false\` otherwise
   */
  public hasFactorElement(): boolean {
    return isDefined<DecimalType>(this.factor) && !this.factor.isEmpty();
  }

  /**
   * @returns the \`factor\` property value as a fhirDecimal if defined; else undefined
   */
  public getFactor(): fhirDecimal | undefined {
    return this.factor?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`factor\` property.
   *
   * @param value - the \`factor\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setFactor(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = \`Invalid SampledData.factor (\${String(value)})\`;
      this.factor = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.factor = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`factor\` property exists and has a value; \`false\` otherwise
   */
  public hasFactor(): boolean {
    return this.hasFactorElement();
  }

  /**
   * @returns the \`lowerLimit\` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getLowerLimitElement(): DecimalType {
    return this.lowerLimit ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`lowerLimit\` property.
   *
   * @param element - the \`lowerLimit\` value
   * @returns this
   */
  public setLowerLimitElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = \`Invalid SampledData.lowerLimit; Provided element is not an instance of DecimalType.\`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.lowerLimit = element;
    } else {
      this.lowerLimit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`lowerLimit\` property exists and has a value; \`false\` otherwise
   */
  public hasLowerLimitElement(): boolean {
    return isDefined<DecimalType>(this.lowerLimit) && !this.lowerLimit.isEmpty();
  }

  /**
   * @returns the \`lowerLimit\` property value as a fhirDecimal if defined; else undefined
   */
  public getLowerLimit(): fhirDecimal | undefined {
    return this.lowerLimit?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`lowerLimit\` property.
   *
   * @param value - the \`lowerLimit\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setLowerLimit(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = \`Invalid SampledData.lowerLimit (\${String(value)})\`;
      this.lowerLimit = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.lowerLimit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`lowerLimit\` property exists and has a value; \`false\` otherwise
   */
  public hasLowerLimit(): boolean {
    return this.hasLowerLimitElement();
  }

  /**
   * @returns the \`upperLimit\` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getUpperLimitElement(): DecimalType {
    return this.upperLimit ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`upperLimit\` property.
   *
   * @param element - the \`upperLimit\` value
   * @returns this
   */
  public setUpperLimitElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = \`Invalid SampledData.upperLimit; Provided element is not an instance of DecimalType.\`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.upperLimit = element;
    } else {
      this.upperLimit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`upperLimit\` property exists and has a value; \`false\` otherwise
   */
  public hasUpperLimitElement(): boolean {
    return isDefined<DecimalType>(this.upperLimit) && !this.upperLimit.isEmpty();
  }

  /**
   * @returns the \`upperLimit\` property value as a fhirDecimal if defined; else undefined
   */
  public getUpperLimit(): fhirDecimal | undefined {
    return this.upperLimit?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`upperLimit\` property.
   *
   * @param value - the \`upperLimit\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setUpperLimit(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = \`Invalid SampledData.upperLimit (\${String(value)})\`;
      this.upperLimit = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.upperLimit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`upperLimit\` property exists and has a value; \`false\` otherwise
   */
  public hasUpperLimit(): boolean {
    return this.hasUpperLimitElement();
  }

  /**
   * @returns the \`dimensions\` property value as a PositiveIntType object if defined; else null
   */
  public getDimensionsElement(): PositiveIntType | null {
    return this.dimensions;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`dimensions\` property.
   *
   * @param element - the \`dimensions\` value
   * @returns this
   */
  public setDimensionsElement(element: PositiveIntType): this {
    assertIsDefined<PositiveIntType>(element, \`SampledData.dimensions is required\`);
    const optErrMsg = \`Invalid SampledData.dimensions; Provided value is not an instance of PositiveIntType.\`;
    assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
    this.dimensions = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`dimensions\` property exists and has a value; \`false\` otherwise
   */
  public hasDimensionsElement(): boolean {
    return isDefined<PositiveIntType>(this.dimensions) && !this.dimensions.isEmpty();
  }

  /**
   * @returns the \`dimensions\` property value as a fhirPositiveInt if defined; else null
   */
  public getDimensions(): fhirPositiveInt | null {
    if (this.dimensions?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.dimensions.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`dimensions\` property.
   *
   * @param value - the \`dimensions\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setDimensions(value: fhirPositiveInt): this {
    assertIsDefined<fhirPositiveInt>(value, \`SampledData.dimensions is required\`);
    const optErrMsg = \`Invalid SampledData.dimensions (\${String(value)})\`;
    this.dimensions = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`dimensions\` property exists and has a value; \`false\` otherwise
   */
  public hasDimensions(): boolean {
    return this.hasDimensionsElement();
  }

  /**
   * @returns the \`codeMap\` property value as a CanonicalType object if defined; else an empty CanonicalType object
   */
  public getCodeMapElement(): CanonicalType {
    return this.codeMap ?? new CanonicalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`codeMap\` property.
   *
   * @param element - the \`codeMap\` value
   * @returns this
   */
  public setCodeMapElement(element: CanonicalType | undefined): this {
    if (isDefined<CanonicalType>(element)) {
      const optErrMsg = \`Invalid SampledData.codeMap; Provided element is not an instance of CanonicalType.\`;
      assertFhirType<CanonicalType>(element, CanonicalType, optErrMsg);
      this.codeMap = element;
    } else {
      this.codeMap = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`codeMap\` property exists and has a value; \`false\` otherwise
   */
  public hasCodeMapElement(): boolean {
    return isDefined<CanonicalType>(this.codeMap) && !this.codeMap.isEmpty();
  }

  /**
   * @returns the \`codeMap\` property value as a fhirCanonical if defined; else undefined
   */
  public getCodeMap(): fhirCanonical | undefined {
    return this.codeMap?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`codeMap\` property.
   *
   * @param value - the \`codeMap\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setCodeMap(value: fhirCanonical | undefined): this {
    if (isDefined<fhirCanonical>(value)) {
      const optErrMsg = \`Invalid SampledData.codeMap (\${String(value)})\`;
      this.codeMap = new CanonicalType(parseFhirPrimitiveData(value, fhirCanonicalSchema, optErrMsg));
    } else {
      this.codeMap = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`codeMap\` property exists and has a value; \`false\` otherwise
   */
  public hasCodeMap(): boolean {
    return this.hasCodeMapElement();
  }

  /**
   * @returns the \`offsets\` property value as a StringType object if defined; else an empty StringType object
   */
  public getOffsetsElement(): StringType {
    return this.offsets ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`offsets\` property.
   *
   * @param element - the \`offsets\` value
   * @returns this
   */
  public setOffsetsElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid SampledData.offsets; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.offsets = element;
    } else {
      this.offsets = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`offsets\` property exists and has a value; \`false\` otherwise
   */
  public hasOffsetsElement(): boolean {
    return isDefined<StringType>(this.offsets) && !this.offsets.isEmpty();
  }

  /**
   * @returns the \`offsets\` property value as a fhirString if defined; else undefined
   */
  public getOffsets(): fhirString | undefined {
    return this.offsets?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`offsets\` property.
   *
   * @param value - the \`offsets\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setOffsets(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid SampledData.offsets (\${String(value)})\`;
      this.offsets = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.offsets = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`offsets\` property exists and has a value; \`false\` otherwise
   */
  public hasOffsets(): boolean {
    return this.hasOffsetsElement();
  }

  /**
   * @returns the \`data\` property value as a StringType object if defined; else an empty StringType object
   */
  public getDataElement(): StringType {
    return this.data ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`data\` property.
   *
   * @param element - the \`data\` value
   * @returns this
   */
  public setDataElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid SampledData.data; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.data = element;
    } else {
      this.data = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`data\` property exists and has a value; \`false\` otherwise
   */
  public hasDataElement(): boolean {
    return isDefined<StringType>(this.data) && !this.data.isEmpty();
  }

  /**
   * @returns the \`data\` property value as a fhirString if defined; else undefined
   */
  public getData(): fhirString | undefined {
    return this.data?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`data\` property.
   *
   * @param value - the \`data\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setData(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid SampledData.data (\${String(value)})\`;
      this.data = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.data = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`data\` property exists and has a value; \`false\` otherwise
   */
  public hasData(): boolean {
    return this.hasDataElement();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'SampledData';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.origin,
      this.interval,
      this.intervalUnit,
      this.factor,
      this.lowerLimit,
      this.upperLimit,
      this.dimensions,
      this.codeMap,
      this.offsets,
      this.data,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): SampledData {
    const dest = new SampledData();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: SampledData): void {
    super.copyValues(dest);
    dest.origin = this.origin ? this.origin.copy() : null;
    dest.interval = this.interval?.copy();
    dest.intervalUnit = this.intervalUnit ? this.intervalUnit.copy() : null;
    dest.factor = this.factor?.copy();
    dest.lowerLimit = this.lowerLimit?.copy();
    dest.upperLimit = this.upperLimit?.copy();
    dest.dimensions = this.dimensions ? this.dimensions.copy() : null;
    dest.codeMap = this.codeMap?.copy();
    dest.offsets = this.offsets?.copy();
    dest.data = this.data?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasOrigin()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirComplexJson(this.getOrigin()!, 'origin', jsonObj);
    } else {
      missingReqdProperties.push(\`SampledData.origin\`);
    }

    if (this.hasIntervalElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getIntervalElement(), 'interval', jsonObj);
    }

    if (this.hasIntervalUnitElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getIntervalUnitElement()!, 'intervalUnit', jsonObj);
    } else {
      missingReqdProperties.push(\`SampledData.intervalUnit\`);
    }

    if (this.hasFactorElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getFactorElement(), 'factor', jsonObj);
    }

    if (this.hasLowerLimitElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getLowerLimitElement(), 'lowerLimit', jsonObj);
    }

    if (this.hasUpperLimitElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getUpperLimitElement(), 'upperLimit', jsonObj);
    }

    if (this.hasDimensionsElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirPositiveInt>(this.getDimensionsElement()!, 'dimensions', jsonObj);
    } else {
      missingReqdProperties.push(\`SampledData.dimensions\`);
    }

    if (this.hasCodeMapElement()) {
      setFhirPrimitiveJson<fhirCanonical>(this.getCodeMapElement(), 'codeMap', jsonObj);
    }

    if (this.hasOffsetsElement()) {
      setFhirPrimitiveJson<fhirString>(this.getOffsetsElement(), 'offsets', jsonObj);
    }

    if (this.hasDataElement()) {
      setFhirPrimitiveJson<fhirString>(this.getDataElement(), 'data', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "SampledData",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 62`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * Signature Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/Signature
 * StructureDefinition.name: Signature
 * StructureDefinition.description: Signature Type: A signature along with supporting context. The signature may be a digital signature that is cryptographic in nature, or some other signature acceptable to the domain. This other signature may be as simple as a graphical image representing a hand-written signature, or a signature ceremony Different signature approaches have different utilities.
 * StructureDefinition.fhirVersion: 5.0.0
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  Base64BinaryType,
  CodeType,
  DataType,
  FhirDataTypeParser,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  InstantType,
  JSON,
  assertFhirType,
  assertFhirTypeList,
  copyListValues,
  fhirBase64Binary,
  fhirBase64BinarySchema,
  fhirCode,
  fhirCodeSchema,
  fhirInstant,
  fhirInstantSchema,
  getPrimitiveTypeJson,
  isDefined,
  isDefinedList,
  isElementEmpty,
  isEmpty,
  parseBase64BinaryType,
  parseCodeType,
  parseFhirPrimitiveData,
  parseInstantType,
  setFhirComplexJson,
  setFhirComplexListJson,
  setFhirPrimitiveJson,
} from '@paq-ts-fhir/fhir-core';
import {
  Coding,
  PARSABLE_DATATYPE_MAP,
  Reference,
  ReferenceTargets,
} from '../index';

/**
 * Signature Class
 *
 * @remarks
 * Signature Type: A signature along with supporting context. The signature may be a digital signature that is cryptographic in nature, or some other signature acceptable to the domain. This other signature may be as simple as a graphical image representing a hand-written signature, or a signature ceremony Different signature approaches have different utilities.
 *
 * There are a number of places where content must be signed in healthcare.
 *
 * **FHIR Specification**
 * - **Short:** A Signature - XML DigSig, JWS, Graphical image of signature, etc.
 * - **Definition:** A signature along with supporting context. The signature may be a digital signature that is cryptographic in nature, or some other signature acceptable to the domain. This other signature may be as simple as a graphical image representing a hand-written signature, or a signature ceremony Different signature approaches have different utilities.
 * - **Comment:** The elements of the Signature Resource are for ease of access of these elements. For digital signatures (Xml DigSig, JWS), the non-repudiation proof comes from the Signature  validation, which includes validation of the referenced objects (e.g. Resources) (a.k.a., Content) in the XML-Signature Detached form.
 * - **FHIR Version:** 5.0.0
 *
 * @category DataModel: ComplexType
 * @see [FHIR Signature](http://hl7.org/fhir/StructureDefinition/Signature)
 */
export class Signature extends DataType implements IBase {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`Signature\` JSON to instantiate the Signature data model.
   *
   * @param sourceJson - JSON representing FHIR \`Signature\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Signature
   * @returns Signature data model or undefined for \`Signature\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Signature | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Signature';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Signature();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'type';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Coding | undefined = fhirDataTypeParser.parser<Coding>(Coding, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addType(datatype);
        }
      });
    }

    fieldName = 'when';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: InstantType | undefined = parseInstantType(dtJson, dtSiblingJson);
      instance.setWhenElement(datatype);
    }

    fieldName = 'who';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = fhirDataTypeParser.parser<Reference>(Reference, classJsonObj[fieldName]!, sourceField);
      instance.setWho(datatype);
    }

    fieldName = 'onBehalfOf';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = fhirDataTypeParser.parser<Reference>(Reference, classJsonObj[fieldName]!, sourceField);
      instance.setOnBehalfOf(datatype);
    }

    fieldName = 'targetFormat';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      instance.setTargetFormatElement(datatype);
    }

    fieldName = 'sigFormat';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      instance.setSigFormatElement(datatype);
    }

    fieldName = 'data';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: Base64BinaryType | undefined = parseBase64BinaryType(dtJson, dtSiblingJson);
      instance.setDataElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Signature.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Indication of the reason the entity signed the object(s)
   * - **Definition:** An indication of the reason that the entity signed this document. This may be explicitly included as part of the signature information and can be used when determining accountability for various actions concerning the document.
   * - **Comment:** Examples include attesting to: authorship, correct transcription, and witness of specific event. Also known as a &quot;Commitment Type Indication&quot;.
   * - **FHIR Type:** \`Coding\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private type_?: Coding[] | undefined;

  /**
   * Signature.when Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** When the signature was created
   * - **Definition:** When the digital signature was signed.
   * - **Comment:** This should agree with the information in the signature.
   * - **FHIR Type:** \`instant\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private when?: InstantType | undefined;

  /**
   * Signature.who Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Who signed
   * - **Definition:** A reference to an application-usable description of the identity that signed  (e.g. the signature used their private key).
   * - **Comment:** This should agree with the information in the signature.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Practitioner',
   *       'http://hl7.org/fhir/StructureDefinition/PractitionerRole',
   *       'http://hl7.org/fhir/StructureDefinition/RelatedPerson',
   *       'http://hl7.org/fhir/StructureDefinition/Patient',
   *       'http://hl7.org/fhir/StructureDefinition/Device',
   *       'http://hl7.org/fhir/StructureDefinition/Organization',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private who?: Reference | undefined;

  /**
   * Signature.onBehalfOf Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The party represented
   * - **Definition:** A reference to an application-usable description of the identity that is represented by the signature.
   * - **Comment:** The party that can\\'t sign. For example a child.
   * - **Requirements:** used when the signature is on behalf of a non-signer.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Practitioner',
   *       'http://hl7.org/fhir/StructureDefinition/PractitionerRole',
   *       'http://hl7.org/fhir/StructureDefinition/RelatedPerson',
   *       'http://hl7.org/fhir/StructureDefinition/Patient',
   *       'http://hl7.org/fhir/StructureDefinition/Device',
   *       'http://hl7.org/fhir/StructureDefinition/Organization',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private onBehalfOf?: Reference | undefined;

  /**
   * Signature.targetFormat Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The technical format of the signed resources
   * - **Definition:** A mime type that indicates the technical format of the target resources signed by the signature.
   * - **Comment:** "xml", "json" and "ttl" are allowed, which describe the simple encodings described in the specification (and imply appropriate bundle support). Otherwise, mime types are legal here.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private targetFormat?: CodeType | undefined;

  /**
   * Signature.sigFormat Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The technical format of the signature
   * - **Definition:** A mime type that indicates the technical format of the signature. Important mime types are application/signature+xml for X ML DigSig, application/jose for JWS, and image/* for a graphical image of a signature, etc.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private sigFormat?: CodeType | undefined;

  /**
   * Signature.data Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The actual signature content (XML DigSig. JWS, picture, etc.)
   * - **Definition:** The base64 encoding of the Signature content. When signature is not recorded electronically this element would be empty.
   * - **Comment:** Where the signature type is an XML DigSig, the signed content is a FHIR Resource(s), the signature is of the XML form of the Resource(s) using  XML-Signature (XMLDIG) "Detached Signature" form.
   * - **FHIR Type:** \`base64Binary\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private data?: Base64BinaryType | undefined;


  /**
   * @returns the \`type_\` property value as a Coding array
   */
  public getType(): Coding[] {
    return this.type_ ?? ([] as Coding[]);
  }

  /**
   * Assigns the provided Coding array value to the \`type_\` property.
   *
   * @param value - the \`type_\` array value
   * @returns this
   */
  public setType(value: Coding[] | undefined): this {
    if (isDefinedList<Coding>(value)) {
      const optErrMsg = \`Invalid Signature.type; Provided value array has an element that is not an instance of Coding.\`;
      assertFhirTypeList<Coding>(value, Coding, optErrMsg);
      this.type_ = value;
    } else {
      this.type_ = undefined;
    }
    return this;
  }

  /**
   * Add the provided Coding value to the \`type_\` array property.
   *
   * @param value - the \`type_\` value
   * @returns this
   */
  public addType(value: Coding | undefined): this {
    if (isDefined<Coding>(value)) {
      const optErrMsg = \`Invalid Signature.type; Provided element is not an instance of Coding.\`;
      assertFhirType<Coding>(value, Coding, optErrMsg);
      this.initType();
      this.type_?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasType(): boolean {
    return isDefinedList<Coding>(this.type_) && this.type_.some((item: Coding) => !item.isEmpty());
  }

  /**
   * Initialize the \`type_\` property
   */
  private initType(): void {
    if(!this.hasType()) {
      this.type_ = [] as Coding[];
    }
  }

  /**
   * @returns the \`when\` property value as a InstantType object if defined; else an empty InstantType object
   */
  public getWhenElement(): InstantType {
    return this.when ?? new InstantType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`when\` property.
   *
   * @param element - the \`when\` value
   * @returns this
   */
  public setWhenElement(element: InstantType | undefined): this {
    if (isDefined<InstantType>(element)) {
      const optErrMsg = \`Invalid Signature.when; Provided element is not an instance of InstantType.\`;
      assertFhirType<InstantType>(element, InstantType, optErrMsg);
      this.when = element;
    } else {
      this.when = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`when\` property exists and has a value; \`false\` otherwise
   */
  public hasWhenElement(): boolean {
    return isDefined<InstantType>(this.when) && !this.when.isEmpty();
  }

  /**
   * @returns the \`when\` property value as a fhirInstant if defined; else undefined
   */
  public getWhen(): fhirInstant | undefined {
    return this.when?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`when\` property.
   *
   * @param value - the \`when\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setWhen(value: fhirInstant | undefined): this {
    if (isDefined<fhirInstant>(value)) {
      const optErrMsg = \`Invalid Signature.when (\${String(value)})\`;
      this.when = new InstantType(parseFhirPrimitiveData(value, fhirInstantSchema, optErrMsg));
    } else {
      this.when = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`when\` property exists and has a value; \`false\` otherwise
   */
  public hasWhen(): boolean {
    return this.hasWhenElement();
  }

  /**
   * @returns the \`who\` property value as a Reference object; else an empty Reference object
   */
  public getWho(): Reference {
    return this.who ?? new Reference();
  }

  /**
   * Assigns the provided Who object value to the \`who\` property.
   *
   * @decorator \`@ReferenceTargets('Signature.who', ['Practitioner','PractitionerRole','RelatedPerson','Patient','Device','Organization',])\`
   *
   * @param value - the \`who\` object value
   * @returns this
   */
  @ReferenceTargets('Signature.who', [
    'Practitioner',
  
    'PractitionerRole',
  
    'RelatedPerson',
  
    'Patient',
  
    'Device',
  
    'Organization',
  ])
  public setWho(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.who = value;
    } else {
      this.who = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`who\` property exists and has a value; \`false\` otherwise
   */
  public hasWho(): boolean {
    return isDefined<Reference>(this.who) && !this.who.isEmpty();
  }

  /**
   * @returns the \`onBehalfOf\` property value as a Reference object; else an empty Reference object
   */
  public getOnBehalfOf(): Reference {
    return this.onBehalfOf ?? new Reference();
  }

  /**
   * Assigns the provided OnBehalfOf object value to the \`onBehalfOf\` property.
   *
   * @decorator \`@ReferenceTargets('Signature.onBehalfOf', ['Practitioner','PractitionerRole','RelatedPerson','Patient','Device','Organization',])\`
   *
   * @param value - the \`onBehalfOf\` object value
   * @returns this
   */
  @ReferenceTargets('Signature.onBehalfOf', [
    'Practitioner',
  
    'PractitionerRole',
  
    'RelatedPerson',
  
    'Patient',
  
    'Device',
  
    'Organization',
  ])
  public setOnBehalfOf(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.onBehalfOf = value;
    } else {
      this.onBehalfOf = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`onBehalfOf\` property exists and has a value; \`false\` otherwise
   */
  public hasOnBehalfOf(): boolean {
    return isDefined<Reference>(this.onBehalfOf) && !this.onBehalfOf.isEmpty();
  }

  /**
   * @returns the \`targetFormat\` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getTargetFormatElement(): CodeType {
    return this.targetFormat ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`targetFormat\` property.
   *
   * @param element - the \`targetFormat\` value
   * @returns this
   */
  public setTargetFormatElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Signature.targetFormat; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.targetFormat = element;
    } else {
      this.targetFormat = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`targetFormat\` property exists and has a value; \`false\` otherwise
   */
  public hasTargetFormatElement(): boolean {
    return isDefined<CodeType>(this.targetFormat) && !this.targetFormat.isEmpty();
  }

  /**
   * @returns the \`targetFormat\` property value as a fhirCode if defined; else undefined
   */
  public getTargetFormat(): fhirCode | undefined {
    return this.targetFormat?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`targetFormat\` property.
   *
   * @param value - the \`targetFormat\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setTargetFormat(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Signature.targetFormat (\${String(value)})\`;
      this.targetFormat = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.targetFormat = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`targetFormat\` property exists and has a value; \`false\` otherwise
   */
  public hasTargetFormat(): boolean {
    return this.hasTargetFormatElement();
  }

  /**
   * @returns the \`sigFormat\` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getSigFormatElement(): CodeType {
    return this.sigFormat ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`sigFormat\` property.
   *
   * @param element - the \`sigFormat\` value
   * @returns this
   */
  public setSigFormatElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Signature.sigFormat; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.sigFormat = element;
    } else {
      this.sigFormat = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`sigFormat\` property exists and has a value; \`false\` otherwise
   */
  public hasSigFormatElement(): boolean {
    return isDefined<CodeType>(this.sigFormat) && !this.sigFormat.isEmpty();
  }

  /**
   * @returns the \`sigFormat\` property value as a fhirCode if defined; else undefined
   */
  public getSigFormat(): fhirCode | undefined {
    return this.sigFormat?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`sigFormat\` property.
   *
   * @param value - the \`sigFormat\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setSigFormat(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Signature.sigFormat (\${String(value)})\`;
      this.sigFormat = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.sigFormat = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`sigFormat\` property exists and has a value; \`false\` otherwise
   */
  public hasSigFormat(): boolean {
    return this.hasSigFormatElement();
  }

  /**
   * @returns the \`data\` property value as a Base64BinaryType object if defined; else an empty Base64BinaryType object
   */
  public getDataElement(): Base64BinaryType {
    return this.data ?? new Base64BinaryType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`data\` property.
   *
   * @param element - the \`data\` value
   * @returns this
   */
  public setDataElement(element: Base64BinaryType | undefined): this {
    if (isDefined<Base64BinaryType>(element)) {
      const optErrMsg = \`Invalid Signature.data; Provided element is not an instance of Base64BinaryType.\`;
      assertFhirType<Base64BinaryType>(element, Base64BinaryType, optErrMsg);
      this.data = element;
    } else {
      this.data = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`data\` property exists and has a value; \`false\` otherwise
   */
  public hasDataElement(): boolean {
    return isDefined<Base64BinaryType>(this.data) && !this.data.isEmpty();
  }

  /**
   * @returns the \`data\` property value as a fhirBase64Binary if defined; else undefined
   */
  public getData(): fhirBase64Binary | undefined {
    return this.data?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`data\` property.
   *
   * @param value - the \`data\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setData(value: fhirBase64Binary | undefined): this {
    if (isDefined<fhirBase64Binary>(value)) {
      const optErrMsg = \`Invalid Signature.data (\${String(value)})\`;
      this.data = new Base64BinaryType(parseFhirPrimitiveData(value, fhirBase64BinarySchema, optErrMsg));
    } else {
      this.data = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`data\` property exists and has a value; \`false\` otherwise
   */
  public hasData(): boolean {
    return this.hasDataElement();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Signature';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.type_,
      this.when,
      this.who,
      this.onBehalfOf,
      this.targetFormat,
      this.sigFormat,
      this.data,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Signature {
    const dest = new Signature();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Signature): void {
    super.copyValues(dest);
    const typeList = copyListValues<Coding>(this.type_);
    dest.type_ = typeList.length === 0 ? undefined : typeList;
    dest.when = this.when?.copy();
    dest.who = this.who?.copy();
    dest.onBehalfOf = this.onBehalfOf?.copy();
    dest.targetFormat = this.targetFormat?.copy();
    dest.sigFormat = this.sigFormat?.copy();
    dest.data = this.data?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasType()) {
      setFhirComplexListJson(this.getType(), 'type', jsonObj);
    }

    if (this.hasWhenElement()) {
      setFhirPrimitiveJson<fhirInstant>(this.getWhenElement(), 'when', jsonObj);
    }

    if (this.hasWho()) {
      setFhirComplexJson(this.getWho(), 'who', jsonObj);
    }

    if (this.hasOnBehalfOf()) {
      setFhirComplexJson(this.getOnBehalfOf(), 'onBehalfOf', jsonObj);
    }

    if (this.hasTargetFormatElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getTargetFormatElement(), 'targetFormat', jsonObj);
    }

    if (this.hasSigFormatElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getSigFormatElement(), 'sigFormat', jsonObj);
    }

    if (this.hasDataElement()) {
      setFhirPrimitiveJson<fhirBase64Binary>(this.getDataElement(), 'data', jsonObj);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "Signature",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 63`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * SubstanceAmount Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/SubstanceAmount
 * StructureDefinition.name: SubstanceAmount
 * StructureDefinition.description: Base StructureDefinition for SubstanceAmount Type: Chemical substances are a single substance type whose primary defining element is the molecular structure. Chemical substances shall be defined on the basis of their complete covalent molecular structure; the presence of a salt (counter-ion) and/or solvates (water, alcohols) is also captured. Purity, grade, physical form or particle size are not taken into account in the definition of a chemical substance or in the assignment of a Substance ID.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  BackboneType,
  ChoiceDataTypes,
  ChoiceDataTypesMeta,
  DataType,
  Element,
  FhirDataTypeParser,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  InvalidTypeError,
  JSON,
  StringType,
  assertFhirType,
  assertIsDefined,
  fhirString,
  fhirStringSchema,
  getPrimitiveTypeJson,
  isDefined,
  isElementEmpty,
  isEmpty,
  parseFhirPrimitiveData,
  parseStringType,
  setFhirComplexJson,
  setFhirPrimitiveJson,
  setPolymorphicValueJson,
} from '@paq-ts-fhir/fhir-core';
import {
  CodeableConcept,
  PARSABLE_DATATYPE_MAP,
  Quantity,
  Range,
} from '../index';

// eslint-disable-next-line @typescript-eslint/no-explicit-any -- Symbol.metadata polyfill secret sauce for decorator metadata
(Symbol.metadata as any) ??= Symbol('Symbol.metadata');

/**
 * SubstanceAmount Class
 *
 * @remarks
 * Base StructureDefinition for SubstanceAmount Type: Chemical substances are a single substance type whose primary defining element is the molecular structure. Chemical substances shall be defined on the basis of their complete covalent molecular structure; the presence of a salt (counter-ion) and/or solvates (water, alcohols) is also captured. Purity, grade, physical form or particle size are not taken into account in the definition of a chemical substance or in the assignment of a Substance ID.
 *
 * **FHIR Specification**
 * - **Short:** Chemical substances are a single substance type whose primary defining element is the molecular structure. Chemical substances shall be defined on the basis of their complete covalent molecular structure; the presence of a salt (counter-ion) and/or solvates (water, alcohols) is also captured. Purity, grade, physical form or particle size are not taken into account in the definition of a chemical substance or in the assignment of a Substance ID
 * - **Definition:** Chemical substances are a single substance type whose primary defining element is the molecular structure. Chemical substances shall be defined on the basis of their complete covalent molecular structure; the presence of a salt (counter-ion) and/or solvates (water, alcohols) is also captured. Purity, grade, physical form or particle size are not taken into account in the definition of a chemical substance or in the assignment of a Substance ID.
 * - **FHIR Version:** 4.0.1
 *
 * @category DataModel: ComplexType
 * @see [FHIR SubstanceAmount](http://hl7.org/fhir/StructureDefinition/SubstanceAmount)
 */
export class SubstanceAmount extends BackboneType implements IBase {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`SubstanceAmount\` JSON to instantiate the SubstanceAmount data model.
   *
   * @param sourceJson - JSON representing FHIR \`SubstanceAmount\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to SubstanceAmount
   * @returns SubstanceAmount data model or undefined for \`SubstanceAmount\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): SubstanceAmount | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'SubstanceAmount';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new SubstanceAmount();
    fhirDataTypeParser.processBackboneTypeJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    

    const classMetadata: DecoratorMetadataObject | null = SubstanceAmount[Symbol.metadata];
    const errorMessage = \`DecoratorMetadataObject does not exist for SubstanceAmount\`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    fieldName = 'amount[x]';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const amount: DataType | undefined = fhirDataTypeParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setAmount(amount);

    fieldName = 'amountType';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = fhirDataTypeParser.parser<CodeableConcept>(CodeableConcept, classJsonObj[fieldName]!, sourceField);
      instance.setAmountType(datatype);
    }

    fieldName = 'amountText';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setAmountTextElement(datatype);
    }

    fieldName = 'referenceRange';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: SubstanceAmountReferenceRangeComponent | undefined = fhirDataTypeParser.parser<SubstanceAmountReferenceRangeComponent>(SubstanceAmountReferenceRangeComponent, classJsonObj[fieldName]!, sourceField);
      instance.setReferenceRange(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * SubstanceAmount.amount[x] Element
   *
   * @decorator \`@ChoiceDataTypesMeta('SubstanceAmount.amount[x]', ['Quantity','Range','string',]\`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Used to capture quantitative values for a variety of elements. If only limits are given, the arithmetic mean would be the average. If only a single definite value for a given element is given, it would be captured in this field
   * - **Definition:** Used to capture quantitative values for a variety of elements. If only limits are given, the arithmetic mean would be the average. If only a single definite value for a given element is given, it would be captured in this field.
   * - **FHIR Types:**
   *     'Quantity',
   *     'Range',
   *     'string',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('SubstanceAmount.amount[x]',[
    'Quantity',
    'Range',
    'string',
  ])
  private amount?: DataType | undefined;

  /**
   * SubstanceAmount.amountType Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Most elements that require a quantitative value will also have a field called amount type. Amount type should always be specified because the actual value of the amount is often dependent on it. EXAMPLE: In capturing the actual relative amounts of substances or molecular fragments it is essential to indicate whether the amount refers to a mole ratio or weight ratio. For any given element an effort should be made to use same the amount type for all related definitional elements
   * - **Definition:** Most elements that require a quantitative value will also have a field called amount type. Amount type should always be specified because the actual value of the amount is often dependent on it. EXAMPLE: In capturing the actual relative amounts of substances or molecular fragments it is essential to indicate whether the amount refers to a mole ratio or weight ratio. For any given element an effort should be made to use same the amount type for all related definitional elements.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private amountType?: CodeableConcept | undefined;

  /**
   * SubstanceAmount.amountText Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A textual comment on a numeric value
   * - **Definition:** A textual comment on a numeric value.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private amountText?: StringType | undefined;

  /**
   * SubstanceAmount.referenceRange Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Reference range of possible or expected values
   * - **Definition:** Reference range of possible or expected values.
   * - **FHIR Type:** \`Element\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private referenceRange?: SubstanceAmountReferenceRangeComponent | undefined;


  /**
   * @returns the \`amount\` property value as a DataType object if defined; else undefined
   */
  public getAmount(): DataType | undefined {
    return this.amount;
  }

  /**
   * Assigns the provided DataType object value to the \`amount\` property.
   *
   * @decorator \`@ChoiceDataTypes('SubstanceAmount.amount[x]')\`
   *
   * @param value - the \`amount\` object value
   * @returns this
   */
  @ChoiceDataTypes('SubstanceAmount.amount[x]')
  public setAmount(value: DataType | undefined): this {
    if (isDefined<DataType>(value)) {
      // assertFhirType<DataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.amount = value;
    } else {
      this.amount = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`amount\` property exists and has a value; \`false\` otherwise
   */
  public hasAmount(): boolean {
    return isDefined<DataType>(this.amount) && !this.amount.isEmpty();
  }

  // *** NOTE ***
  // Next "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the \`amount\` property value as a Quantity object if defined; else undefined
   */
  public getAmountQuantity(): Quantity | undefined {
    if (!isDefined<DataType | undefined>(this.amount)) {
      return undefined;
    }
    if (!(this.amount instanceof Quantity)) {
      throw new InvalidTypeError(
        \`DataType mismatch for SubstanceAmount.amount[x]: Expected Quantity but encountered \${this.amount.fhirType()}\`,
      );
    }
    return this.amount;
  }

  /**
   * @returns \`true\` if the \`amount\` property exists as a Quantity and has a value; \`false\` otherwise
   */
  public hasAmountQuantity(): boolean {
    return this.hasAmount() && this.amount instanceof Quantity;
  }

  /**
   * @returns the \`amount\` property value as a Range object if defined; else undefined
   */
  public getAmountRange(): Range | undefined {
    if (!isDefined<DataType | undefined>(this.amount)) {
      return undefined;
    }
    if (!(this.amount instanceof Range)) {
      throw new InvalidTypeError(
        \`DataType mismatch for SubstanceAmount.amount[x]: Expected Range but encountered \${this.amount.fhirType()}\`,
      );
    }
    return this.amount;
  }

  /**
   * @returns \`true\` if the \`amount\` property exists as a Range and has a value; \`false\` otherwise
   */
  public hasAmountRange(): boolean {
    return this.hasAmount() && this.amount instanceof Range;
  }

  /**
   * @returns the \`amount\` property value as a StringType object if defined; else undefined
   */
  public getAmountStringType(): StringType | undefined {
    if (!isDefined<DataType | undefined>(this.amount)) {
      return undefined;
    }
    if (!(this.amount instanceof StringType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for SubstanceAmount.amount[x]: Expected StringType but encountered \${this.amount.fhirType()}\`,
      );
    }
    return this.amount;
  }

  /**
   * @returns \`true\` if the \`amount\` property exists as a StringType and has a value; \`false\` otherwise
   */
  public hasAmountStringType(): boolean {
    return this.hasAmount() && this.amount instanceof StringType;
  }

  /**
   * @returns the \`amountType\` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getAmountType(): CodeableConcept {
    return this.amountType ?? new CodeableConcept();
  }

  /**
   * Assigns the provided AmountType object value to the \`amountType\` property.
   *
   * @param value - the \`amountType\` object value
   * @returns this
   */
  public setAmountType(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid SubstanceAmount.amountType; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.amountType = value;
    } else {
      this.amountType = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`amountType\` property exists and has a value; \`false\` otherwise
   */
  public hasAmountType(): boolean {
    return isDefined<CodeableConcept>(this.amountType) && !this.amountType.isEmpty();
  }

  /**
   * @returns the \`amountText\` property value as a StringType object if defined; else an empty StringType object
   */
  public getAmountTextElement(): StringType {
    return this.amountText ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`amountText\` property.
   *
   * @param element - the \`amountText\` value
   * @returns this
   */
  public setAmountTextElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid SubstanceAmount.amountText; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.amountText = element;
    } else {
      this.amountText = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`amountText\` property exists and has a value; \`false\` otherwise
   */
  public hasAmountTextElement(): boolean {
    return isDefined<StringType>(this.amountText) && !this.amountText.isEmpty();
  }

  /**
   * @returns the \`amountText\` property value as a fhirString if defined; else undefined
   */
  public getAmountText(): fhirString | undefined {
    return this.amountText?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`amountText\` property.
   *
   * @param value - the \`amountText\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setAmountText(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid SubstanceAmount.amountText (\${String(value)})\`;
      this.amountText = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.amountText = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`amountText\` property exists and has a value; \`false\` otherwise
   */
  public hasAmountText(): boolean {
    return this.hasAmountTextElement();
  }

  /**
   * @returns the \`referenceRange\` property value as a SubstanceAmountReferenceRangeComponent object if defined; else an empty SubstanceAmountReferenceRangeComponent object
   */
  public getReferenceRange(): SubstanceAmountReferenceRangeComponent {
    return this.referenceRange ?? new SubstanceAmountReferenceRangeComponent();
  }

  /**
   * Assigns the provided ReferenceRange object value to the \`referenceRange\` property.
   *
   * @param value - the \`referenceRange\` object value
   * @returns this
   */
  public setReferenceRange(value: SubstanceAmountReferenceRangeComponent | undefined): this {
    if (isDefined<SubstanceAmountReferenceRangeComponent>(value)) {
      const optErrMsg = \`Invalid SubstanceAmount.referenceRange; Provided element is not an instance of SubstanceAmountReferenceRangeComponent.\`;
      assertFhirType<SubstanceAmountReferenceRangeComponent>(value, SubstanceAmountReferenceRangeComponent, optErrMsg);
      this.referenceRange = value;
    } else {
      this.referenceRange = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`referenceRange\` property exists and has a value; \`false\` otherwise
   */
  public hasReferenceRange(): boolean {
    return isDefined<SubstanceAmountReferenceRangeComponent>(this.referenceRange) && !this.referenceRange.isEmpty();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'SubstanceAmount';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.amount,
      this.amountType,
      this.amountText,
      this.referenceRange,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): SubstanceAmount {
    const dest = new SubstanceAmount();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: SubstanceAmount): void {
    super.copyValues(dest);
    dest.amount = this.amount?.copy();
    dest.amountType = this.amountType?.copy();
    dest.amountText = this.amountText?.copy();
    dest.referenceRange = this.referenceRange?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasAmount()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getAmount()!, 'amount', jsonObj);
    }

    if (this.hasAmountType()) {
      setFhirComplexJson(this.getAmountType(), 'amountType', jsonObj);
    }

    if (this.hasAmountTextElement()) {
      setFhirPrimitiveJson<fhirString>(this.getAmountTextElement(), 'amountText', jsonObj);
    }

    if (this.hasReferenceRange()) {
      setFhirComplexJson(this.getReferenceRange(), 'referenceRange', jsonObj);
    }

    return jsonObj;
  }
}


/**
 * SubstanceAmountReferenceRangeComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Reference range of possible or expected values
 * - **Definition:** Reference range of possible or expected values.
 *
 * @category DataModel: ComplexType
 * @see [FHIR SubstanceAmount](http://hl7.org/fhir/StructureDefinition/SubstanceAmount)
 */
export class SubstanceAmountReferenceRangeComponent extends Element {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`SubstanceAmountReferenceRangeComponent\` JSON to instantiate the SubstanceAmountReferenceRangeComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`SubstanceAmountReferenceRangeComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to SubstanceAmountReferenceRangeComponent
   * @returns SubstanceAmountReferenceRangeComponent data model or undefined for \`SubstanceAmountReferenceRangeComponent\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): SubstanceAmountReferenceRangeComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'SubstanceAmountReferenceRangeComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new SubstanceAmountReferenceRangeComponent();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';

    fieldName = 'lowLimit';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = fhirDataTypeParser.parser<Quantity>(Quantity, classJsonObj[fieldName]!, sourceField);
      instance.setLowLimit(datatype);
    }

    fieldName = 'highLimit';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = fhirDataTypeParser.parser<Quantity>(Quantity, classJsonObj[fieldName]!, sourceField);
      instance.setHighLimit(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * SubstanceAmount.referenceRange.lowLimit Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Lower limit possible or expected
   * - **Definition:** Lower limit possible or expected.
   * - **FHIR Type:** \`Quantity\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private lowLimit?: Quantity | undefined;

  /**
   * SubstanceAmount.referenceRange.highLimit Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Upper limit possible or expected
   * - **Definition:** Upper limit possible or expected.
   * - **FHIR Type:** \`Quantity\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private highLimit?: Quantity | undefined;


  /**
   * @returns the \`lowLimit\` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getLowLimit(): Quantity {
    return this.lowLimit ?? new Quantity();
  }

  /**
   * Assigns the provided LowLimit object value to the \`lowLimit\` property.
   *
   * @param value - the \`lowLimit\` object value
   * @returns this
   */
  public setLowLimit(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = \`Invalid SubstanceAmount.referenceRange.lowLimit; Provided element is not an instance of Quantity.\`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.lowLimit = value;
    } else {
      this.lowLimit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`lowLimit\` property exists and has a value; \`false\` otherwise
   */
  public hasLowLimit(): boolean {
    return isDefined<Quantity>(this.lowLimit) && !this.lowLimit.isEmpty();
  }

  /**
   * @returns the \`highLimit\` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getHighLimit(): Quantity {
    return this.highLimit ?? new Quantity();
  }

  /**
   * Assigns the provided HighLimit object value to the \`highLimit\` property.
   *
   * @param value - the \`highLimit\` object value
   * @returns this
   */
  public setHighLimit(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = \`Invalid SubstanceAmount.referenceRange.highLimit; Provided element is not an instance of Quantity.\`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.highLimit = value;
    } else {
      this.highLimit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`highLimit\` property exists and has a value; \`false\` otherwise
   */
  public hasHighLimit(): boolean {
    return isDefined<Quantity>(this.highLimit) && !this.highLimit.isEmpty();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'SubstanceAmount.referenceRange';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.lowLimit,
      this.highLimit,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): SubstanceAmountReferenceRangeComponent {
    const dest = new SubstanceAmountReferenceRangeComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: SubstanceAmountReferenceRangeComponent): void {
    super.copyValues(dest);
    dest.lowLimit = this.lowLimit?.copy();
    dest.highLimit = this.highLimit?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasLowLimit()) {
      setFhirComplexJson(this.getLowLimit(), 'lowLimit', jsonObj);
    }

    if (this.hasHighLimit()) {
      setFhirComplexJson(this.getHighLimit(), 'highLimit', jsonObj);
    }

    return jsonObj;
  }
}
",
  "fileExtension": "ts",
  "filename": "SubstanceAmount",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 64`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * Timing Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/Timing
 * StructureDefinition.name: Timing
 * StructureDefinition.description: Base StructureDefinition for Timing Type: Specifies an event that may occur multiple times. Timing schedules are used to record when things are planned, expected or requested to occur. The most common usage is in dosage instructions for medications. They are also used when planning care of various kinds, and may be used for reporting the schedule to which past regular activities were carried out.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  BackboneType,
  ChoiceDataTypes,
  ChoiceDataTypesMeta,
  CodeType,
  DataType,
  DateTimeType,
  DecimalType,
  Element,
  EnumCodeType,
  FhirDataTypeParser,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  InvalidTypeError,
  JSON,
  PositiveIntType,
  PrimitiveTypeJson,
  TimeType,
  UnsignedIntType,
  assertEnumCodeType,
  assertEnumCodeTypeList,
  assertFhirType,
  assertFhirTypeList,
  assertIsDefined,
  copyListValues,
  fhirCode,
  fhirCodeSchema,
  fhirDateTime,
  fhirDateTimeSchema,
  fhirDecimal,
  fhirDecimalSchema,
  fhirPositiveInt,
  fhirPositiveIntSchema,
  fhirTime,
  fhirTimeSchema,
  fhirUnsignedInt,
  fhirUnsignedIntSchema,
  getPrimitiveTypeJson,
  getPrimitiveTypeListJson,
  isDefined,
  isDefinedList,
  isElementEmpty,
  isEmpty,
  parseCodeType,
  parseDateTimeType,
  parseDecimalType,
  parseFhirPrimitiveData,
  parsePositiveIntType,
  parseTimeType,
  parseUnsignedIntType,
  setFhirComplexJson,
  setFhirPrimitiveJson,
  setFhirPrimitiveListJson,
  setPolymorphicValueJson,
} from '@paq-ts-fhir/fhir-core';
import {
  CodeableConcept,
  DaysOfWeekEnum,
  Duration,
  PARSABLE_DATATYPE_MAP,
  Period,
  Range,
} from '../index';

// eslint-disable-next-line @typescript-eslint/no-explicit-any -- Symbol.metadata polyfill secret sauce for decorator metadata
(Symbol.metadata as any) ??= Symbol('Symbol.metadata');

/**
 * Timing Class
 *
 * @remarks
 * Base StructureDefinition for Timing Type: Specifies an event that may occur multiple times. Timing schedules are used to record when things are planned, expected or requested to occur. The most common usage is in dosage instructions for medications. They are also used when planning care of various kinds, and may be used for reporting the schedule to which past regular activities were carried out.
 *
 * Need to able to track proposed timing schedules. There are several different ways to do this: one or more specified times, a simple rules like three times a day, or  before/after meals.
 *
 * **FHIR Specification**
 * - **Short:** A timing schedule that specifies an event that may occur multiple times
 * - **Definition:** Specifies an event that may occur multiple times. Timing schedules are used to record when things are planned, expected or requested to occur. The most common usage is in dosage instructions for medications. They are also used when planning care of various kinds, and may be used for reporting the schedule to which past regular activities were carried out.
 * - **Comment:** Describes the occurrence of an event that may occur multiple times. Timing schedules are used for specifying when events are expected or requested to occur, and may also be used to represent the summary of a past or ongoing event.  For simplicity, the definitions of Timing components are expressed as \\'future\\' events, but such components can also be used to describe historic or ongoing events. A Timing schedule can be a list of events and/or criteria for when the event happens, which can be expressed in a structured form and/or as a code. When both event and a repeating specification are provided, the list of events should be understood as an interpretation of the information in the repeat structure.
 * - **FHIR Version:** 4.0.1
 *
 * @category DataModel: ComplexType
 * @see [FHIR Timing](http://hl7.org/fhir/StructureDefinition/Timing)
 */
export class Timing extends BackboneType implements IBase {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`Timing\` JSON to instantiate the Timing data model.
   *
   * @param sourceJson - JSON representing FHIR \`Timing\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Timing
   * @returns Timing data model or undefined for \`Timing\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Timing | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Timing';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Timing();
    fhirDataTypeParser.processBackboneTypeJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    

    fieldName = 'event';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: DateTimeType | undefined = parseDateTimeType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addEventElement(datatype);
        }
      });
    }

    fieldName = 'repeat';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: TimingRepeatComponent | undefined = fhirDataTypeParser.parser<TimingRepeatComponent>(TimingRepeatComponent, classJsonObj[fieldName]!, sourceField);
      instance.setRepeat(datatype);
    }

    fieldName = 'code';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = fhirDataTypeParser.parser<CodeableConcept>(CodeableConcept, classJsonObj[fieldName]!, sourceField);
      instance.setCode(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Timing.event Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** When the event occurs
   * - **Definition:** Identifies specific times when the event occurs.
   * - **Requirements:** In a Medication Administration Record, for instance, you need to take a general specification, and turn it into a precise specification.
   * - **FHIR Type:** \`dateTime\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private event?: DateTimeType[] | undefined;

  /**
   * Timing.repeat Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** When the event is to occur
   * - **Definition:** A set of rules that describe when the event is scheduled.
   * - **Requirements:** Many timing schedules are determined by regular repetitions.
   * - **FHIR Type:** \`Element\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private repeat?: TimingRepeatComponent | undefined;

  /**
   * Timing.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** BID | TID | QID | AM | PM | QD | QOD | +
   * - **Definition:** A code for the timing schedule (or just text in code.text). Some codes such as BID are ubiquitous, but many institutions define their own additional codes. If a code is provided, the code is understood to be a complete statement of whatever is specified in the structured timing data, and either the code or the data may be used to interpret the Timing, with the exception that .repeat.bounds still applies over the code (and is not contained in the code).
   * - **Comment:** BID etc. are defined as \\'at institutionally specified times\\'. For example, an institution may choose that BID is "always at 7am and 6pm".  If it is inappropriate for this choice to be made, the code BID should not be used. Instead, a distinct organization-specific code should be used in place of the HL7-defined BID code and/or a structured representation should be used (in this case, specifying the two event times).
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code?: CodeableConcept | undefined;


  /**
   * @returns the \`event\` property value as a DateTimeType array
   */
  public getEventElement(): DateTimeType[] {
    return this.event ?? ([] as DateTimeType[]);
  }

  /**
   * Assigns the provided DateTimeType array value to the \`event\` property.
   *
   * @param element - the \`event\` array value
   * @returns this
   */
  public setEventElement(element: DateTimeType[] | undefined): this {
    if (isDefinedList<DateTimeType>(element)) {
      const optErrMsg = \`Invalid Timing.event; Provided value array has an element that is not an instance of DateTimeType.\`;
      assertFhirTypeList<DateTimeType>(element, DateTimeType, optErrMsg);
      this.event = element;
    } else {
      this.event = undefined;
    }
    return this;
  }

  /**
   * Add the provided DateTimeType value to the \`event\` array property.
   *
   * @param element - the \`event\` value
   * @returns this
   */
  public addEventElement(element: DateTimeType | undefined): this {
    if (isDefined<DateTimeType>(element)) {
      const optErrMsg = \`Invalid Timing.event; Provided element is not an instance of DateTimeType.\`;
      assertFhirType<DateTimeType>(element, DateTimeType, optErrMsg);
      this.initEvent();
      this.event?.push(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`event\` property exists and has a value; \`false\` otherwise
   */
  public hasEventElement(): boolean {
    return isDefinedList<DateTimeType>(this.event) && this.event.some((item: DateTimeType) => !item.isEmpty());
  }

  /**
   * @returns the \`event\` property value as a fhirDateTime array
   */
  public getEvent(): fhirDateTime[] {
    this.initEvent();
    const eventValues = [] as fhirDateTime[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.event!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        eventValues.push(value);
      }
    }
    return eventValues;
  }

  /**
   * Assigns the provided primitive value array to the \`event\` property.
   *
   * @param value - the \`event\` value array
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setEvent(value: fhirDateTime[] | undefined): this {
    if (isDefinedList<fhirDateTime>(value)) {
      const eventElements = [] as DateTimeType[];
      for (const eventValue of value) {
        const optErrMsg = \`Invalid Timing.event array item (\${String(eventValue)})\`;
        const element = new DateTimeType(parseFhirPrimitiveData(eventValue, fhirDateTimeSchema, optErrMsg));
        eventElements.push(element);
      }
      this.event = eventElements;
    } else {
      this.event = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`event\` array property.
   *
   * @param value - the \`event\` value
   * @returns this
   */
  public addEvent(value: fhirDateTime | undefined): this {
    if (isDefined<fhirDateTime>(value)) {
      const optErrMsg = \`Invalid Timing.event array item (\${String(value)})\`;
      const element = new DateTimeType(parseFhirPrimitiveData(value, fhirDateTimeSchema, optErrMsg));
      this.initEvent();
      this.addEventElement(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`event\` property exists and has a value; \`false\` otherwise
   */
  public hasEvent(): boolean {
    return this.hasEventElement();
  }

  /**
   * Initialize the \`event\` property
   */
  private initEvent(): void {
    if (!this.hasEvent()) {
      this.event = [] as DateTimeType[];
    }
  }

  /**
   * @returns the \`repeat\` property value as a TimingRepeatComponent object if defined; else an empty TimingRepeatComponent object
   */
  public getRepeat(): TimingRepeatComponent {
    return this.repeat ?? new TimingRepeatComponent();
  }

  /**
   * Assigns the provided Repeat object value to the \`repeat\` property.
   *
   * @param value - the \`repeat\` object value
   * @returns this
   */
  public setRepeat(value: TimingRepeatComponent | undefined): this {
    if (isDefined<TimingRepeatComponent>(value)) {
      const optErrMsg = \`Invalid Timing.repeat; Provided element is not an instance of TimingRepeatComponent.\`;
      assertFhirType<TimingRepeatComponent>(value, TimingRepeatComponent, optErrMsg);
      this.repeat = value;
    } else {
      this.repeat = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`repeat\` property exists and has a value; \`false\` otherwise
   */
  public hasRepeat(): boolean {
    return isDefined<TimingRepeatComponent>(this.repeat) && !this.repeat.isEmpty();
  }

  /**
   * @returns the \`code\` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getCode(): CodeableConcept {
    return this.code ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Code object value to the \`code\` property.
   *
   * @param value - the \`code\` object value
   * @returns this
   */
  public setCode(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Timing.code; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.code = value;
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`code\` property exists and has a value; \`false\` otherwise
   */
  public hasCode(): boolean {
    return isDefined<CodeableConcept>(this.code) && !this.code.isEmpty();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Timing';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.event,
      this.repeat,
      this.code,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Timing {
    const dest = new Timing();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Timing): void {
    super.copyValues(dest);
    const eventList = copyListValues<DateTimeType>(this.event);
    dest.event = eventList.length === 0 ? undefined : eventList;
    dest.repeat = this.repeat?.copy();
    dest.code = this.code?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasEvent()) {
      setFhirPrimitiveListJson(this.getEventElement(), 'event', jsonObj);
    }

    if (this.hasRepeat()) {
      setFhirComplexJson(this.getRepeat(), 'repeat', jsonObj);
    }

    if (this.hasCode()) {
      setFhirComplexJson(this.getCode(), 'code', jsonObj);
    }

    return jsonObj;
  }
}


/**
 * TimingRepeatComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** When the event is to occur
 * - **Definition:** A set of rules that describe when the event is scheduled.
 * - **Requirements:** Many timing schedules are determined by regular repetitions.
 *
 * @category DataModel: ComplexType
 * @see [FHIR Timing](http://hl7.org/fhir/StructureDefinition/Timing)
 */
export class TimingRepeatComponent extends Element {
  constructor() {
    super();

    this.daysOfWeekEnum = new DaysOfWeekEnum();
  }

  /**
   * Parse the provided \`TimingRepeatComponent\` JSON to instantiate the TimingRepeatComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`TimingRepeatComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to TimingRepeatComponent
   * @returns TimingRepeatComponent data model or undefined for \`TimingRepeatComponent\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): TimingRepeatComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'TimingRepeatComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new TimingRepeatComponent();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const classMetadata: DecoratorMetadataObject | null = TimingRepeatComponent[Symbol.metadata];
    const errorMessage = \`DecoratorMetadataObject does not exist for TimingRepeatComponent\`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    fieldName = 'bounds[x]';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const bounds: DataType | undefined = fhirDataTypeParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setBounds(bounds);

    fieldName = 'count';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = parsePositiveIntType(dtJson, dtSiblingJson);
      instance.setCountElement(datatype);
    }

    fieldName = 'countMax';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = parsePositiveIntType(dtJson, dtSiblingJson);
      instance.setCountMaxElement(datatype);
    }

    fieldName = 'duration';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = parseDecimalType(dtJson, dtSiblingJson);
      instance.setDurationElement(datatype);
    }

    fieldName = 'durationMax';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = parseDecimalType(dtJson, dtSiblingJson);
      instance.setDurationMaxElement(datatype);
    }

    fieldName = 'durationUnit';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      instance.setDurationUnitElement(datatype);
    }

    fieldName = 'frequency';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = parsePositiveIntType(dtJson, dtSiblingJson);
      instance.setFrequencyElement(datatype);
    }

    fieldName = 'frequencyMax';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = parsePositiveIntType(dtJson, dtSiblingJson);
      instance.setFrequencyMaxElement(datatype);
    }

    fieldName = 'period';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = parseDecimalType(dtJson, dtSiblingJson);
      instance.setPeriodElement(datatype);
    }

    fieldName = 'periodMax';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = parseDecimalType(dtJson, dtSiblingJson);
      instance.setPeriodMaxElement(datatype);
    }

    fieldName = 'periodUnit';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      instance.setPeriodUnitElement(datatype);
    }

    fieldName = 'dayOfWeek';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: CodeType | undefined = parseCodeType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addDayOfWeekElement(datatype);
        }
      });
    }

    fieldName = 'timeOfDay';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: TimeType | undefined = parseTimeType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addTimeOfDayElement(datatype);
        }
      });
    }

    fieldName = 'when';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: CodeType | undefined = parseCodeType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addWhenElement(datatype);
        }
      });
    }

    fieldName = 'offset';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UnsignedIntType | undefined = parseUnsignedIntType(dtJson, dtSiblingJson);
      instance.setOffsetElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Timing.repeat.bounds[x] Element
   *
   * @decorator \`@ChoiceDataTypesMeta('Timing.repeat.bounds[x]', ['Duration','Range','Period',]\`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Length/Range of lengths, or (Start and/or end) limits
   * - **Definition:** Either a duration for the length of the timing schedule, a range of possible length, or outer bounds for start and/or end limits of the timing schedule.
   * - **FHIR Types:**
   *     'Duration',
   *     'Range',
   *     'Period',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('Timing.repeat.bounds[x]',[
    'Duration',
    'Range',
    'Period',
  ])
  private bounds?: DataType | undefined;

  /**
   * Timing.repeat.count Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Number of times to repeat
   * - **Definition:** A total count of the desired number of repetitions across the duration of the entire timing specification. If countMax is present, this element indicates the lower bound of the allowed range of count values.
   * - **Comment:** If you have both bounds and count, then this should be understood as within the bounds period, until count times happens.
   * - **Requirements:** Repetitions may be limited by end time or total occurrences.
   * - **FHIR Type:** \`positiveInt\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private count?: PositiveIntType | undefined;

  /**
   * Timing.repeat.countMax Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Maximum number of times to repeat
   * - **Definition:** If present, indicates that the count is a range - so to perform the action between [count] and [countMax] times.
   * - **FHIR Type:** \`positiveInt\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private countMax?: PositiveIntType | undefined;

  /**
   * Timing.repeat.duration Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** How long when it happens
   * - **Definition:** How long this thing happens for when it happens. If durationMax is present, this element indicates the lower bound of the allowed range of the duration.
   * - **Comment:** For some events the duration is part of the definition of the event (e.g. IV infusions, where the duration is implicit in the specified quantity and rate). For others, it\\'s part of the timing specification (e.g. exercise).
   * - **Requirements:** Some activities are not instantaneous and need to be maintained for a period of time.
   * - **FHIR Type:** \`decimal\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private duration?: DecimalType | undefined;

  /**
   * Timing.repeat.durationMax Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** How long when it happens (Max)
   * - **Definition:** If present, indicates that the duration is a range - so to perform the action between [duration] and [durationMax] time length.
   * - **Comment:** For some events the duration is part of the definition of the event (e.g. IV infusions, where the duration is implicit in the specified quantity and rate). For others, it\\'s part of the timing specification (e.g. exercise).
   * - **Requirements:** Some activities are not instantaneous and need to be maintained for a period of time.
   * - **FHIR Type:** \`decimal\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private durationMax?: DecimalType | undefined;

  /**
   * Timing.repeat.durationUnit Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** s | min | h | d | wk | mo | a - unit of time (UCUM)
   * - **Definition:** The units of time for the duration, in UCUM units.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private durationUnit?: CodeType | undefined;

  /**
   * Timing.repeat.frequency Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Event occurs frequency times per period
   * - **Definition:** The number of times to repeat the action within the specified period. If frequencyMax is present, this element indicates the lower bound of the allowed range of the frequency.
   * - **FHIR Type:** \`positiveInt\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private frequency?: PositiveIntType | undefined;

  /**
   * Timing.repeat.frequencyMax Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Event occurs up to frequencyMax times per period
   * - **Definition:** If present, indicates that the frequency is a range - so to repeat between [frequency] and [frequencyMax] times within the period or period range.
   * - **FHIR Type:** \`positiveInt\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private frequencyMax?: PositiveIntType | undefined;

  /**
   * Timing.repeat.period Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Event occurs frequency times per period
   * - **Definition:** Indicates the duration of time over which repetitions are to occur; e.g. to express "3 times per day", 3 would be the frequency and "1 day" would be the period. If periodMax is present, this element indicates the lower bound of the allowed range of the period length.
   * - **FHIR Type:** \`decimal\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private period?: DecimalType | undefined;

  /**
   * Timing.repeat.periodMax Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Upper limit of period (3-4 hours)
   * - **Definition:** If present, indicates that the period is a range from [period] to [periodMax], allowing expressing concepts such as "do this once every 3-5 days.
   * - **FHIR Type:** \`decimal\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private periodMax?: DecimalType | undefined;

  /**
   * Timing.repeat.periodUnit Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** s | min | h | d | wk | mo | a - unit of time (UCUM)
   * - **Definition:** The units of time for the period in UCUM units.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private periodUnit?: CodeType | undefined;

  /**
   * FHIR CodeSystem: DaysOfWeek
   *
   * @see {@link DaysOfWeekEnum }
   */
  private readonly daysOfWeekEnum: DaysOfWeekEnum;

  /**
   * Timing.repeat.dayOfWeek Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** mon | tue | wed | thu | fri | sat | sun
   * - **Definition:** If one or more days of week is provided, then the action happens only on the specified day(s).
   * - **Comment:** If no days are specified, the action is assumed to happen every day as otherwise specified. The elements frequency and period cannot be used as well as dayOfWeek.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private dayOfWeek?: EnumCodeType[] | undefined;

  /**
   * Timing.repeat.timeOfDay Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Time of day for action
   * - **Definition:** Specified time of day for action to take place.
   * - **Comment:** When time of day is specified, it is inferred that the action happens every day (as filtered by dayofWeek) on the specified times. The elements when, frequency and period cannot be used as well as timeOfDay.
   * - **FHIR Type:** \`time\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private timeOfDay?: TimeType[] | undefined;

  /**
   * Timing.repeat.when Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Code for time period of occurrence
   * - **Definition:** An approximate time period during the day, potentially linked to an event of daily living that indicates when the action should occur.
   * - **Comment:** When more than one event is listed, the event is tied to the union of the specified events.
   * - **Requirements:** Timings are frequently determined by occurrences such as waking, eating and sleep.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private when?: CodeType[] | undefined;

  /**
   * Timing.repeat.offset Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Minutes from event (before or after)
   * - **Definition:** The number of minutes from the event. If the event code does not indicate whether the minutes is before or after the event, then the offset is assumed to be after the event.
   * - **FHIR Type:** \`unsignedInt\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private offset?: UnsignedIntType | undefined;


  /**
   * @returns the \`bounds\` property value as a DataType object if defined; else undefined
   */
  public getBounds(): DataType | undefined {
    return this.bounds;
  }

  /**
   * Assigns the provided DataType object value to the \`bounds\` property.
   *
   * @decorator \`@ChoiceDataTypes('Timing.repeat.bounds[x]')\`
   *
   * @param value - the \`bounds\` object value
   * @returns this
   */
  @ChoiceDataTypes('Timing.repeat.bounds[x]')
  public setBounds(value: DataType | undefined): this {
    if (isDefined<DataType>(value)) {
      // assertFhirType<DataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.bounds = value;
    } else {
      this.bounds = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`bounds\` property exists and has a value; \`false\` otherwise
   */
  public hasBounds(): boolean {
    return isDefined<DataType>(this.bounds) && !this.bounds.isEmpty();
  }

  // *** NOTE ***
  // Next "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the \`bounds\` property value as a Duration object if defined; else undefined
   */
  public getBoundsDuration(): Duration | undefined {
    if (!isDefined<DataType | undefined>(this.bounds)) {
      return undefined;
    }
    if (!(this.bounds instanceof Duration)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Timing.repeat.bounds[x]: Expected Duration but encountered \${this.bounds.fhirType()}\`,
      );
    }
    return this.bounds;
  }

  /**
   * @returns \`true\` if the \`bounds\` property exists as a Duration and has a value; \`false\` otherwise
   */
  public hasBoundsDuration(): boolean {
    return this.hasBounds() && this.bounds instanceof Duration;
  }

  /**
   * @returns the \`bounds\` property value as a Range object if defined; else undefined
   */
  public getBoundsRange(): Range | undefined {
    if (!isDefined<DataType | undefined>(this.bounds)) {
      return undefined;
    }
    if (!(this.bounds instanceof Range)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Timing.repeat.bounds[x]: Expected Range but encountered \${this.bounds.fhirType()}\`,
      );
    }
    return this.bounds;
  }

  /**
   * @returns \`true\` if the \`bounds\` property exists as a Range and has a value; \`false\` otherwise
   */
  public hasBoundsRange(): boolean {
    return this.hasBounds() && this.bounds instanceof Range;
  }

  /**
   * @returns the \`bounds\` property value as a Period object if defined; else undefined
   */
  public getBoundsPeriod(): Period | undefined {
    if (!isDefined<DataType | undefined>(this.bounds)) {
      return undefined;
    }
    if (!(this.bounds instanceof Period)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Timing.repeat.bounds[x]: Expected Period but encountered \${this.bounds.fhirType()}\`,
      );
    }
    return this.bounds;
  }

  /**
   * @returns \`true\` if the \`bounds\` property exists as a Period and has a value; \`false\` otherwise
   */
  public hasBoundsPeriod(): boolean {
    return this.hasBounds() && this.bounds instanceof Period;
  }

  /**
   * @returns the \`count\` property value as a PositiveIntType object if defined; else an empty PositiveIntType object
   */
  public getCountElement(): PositiveIntType {
    return this.count ?? new PositiveIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`count\` property.
   *
   * @param element - the \`count\` value
   * @returns this
   */
  public setCountElement(element: PositiveIntType | undefined): this {
    if (isDefined<PositiveIntType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.count; Provided element is not an instance of PositiveIntType.\`;
      assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
      this.count = element;
    } else {
      this.count = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`count\` property exists and has a value; \`false\` otherwise
   */
  public hasCountElement(): boolean {
    return isDefined<PositiveIntType>(this.count) && !this.count.isEmpty();
  }

  /**
   * @returns the \`count\` property value as a fhirPositiveInt if defined; else undefined
   */
  public getCount(): fhirPositiveInt | undefined {
    return this.count?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`count\` property.
   *
   * @param value - the \`count\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setCount(value: fhirPositiveInt | undefined): this {
    if (isDefined<fhirPositiveInt>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.count (\${String(value)})\`;
      this.count = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    } else {
      this.count = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`count\` property exists and has a value; \`false\` otherwise
   */
  public hasCount(): boolean {
    return this.hasCountElement();
  }

  /**
   * @returns the \`countMax\` property value as a PositiveIntType object if defined; else an empty PositiveIntType object
   */
  public getCountMaxElement(): PositiveIntType {
    return this.countMax ?? new PositiveIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`countMax\` property.
   *
   * @param element - the \`countMax\` value
   * @returns this
   */
  public setCountMaxElement(element: PositiveIntType | undefined): this {
    if (isDefined<PositiveIntType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.countMax; Provided element is not an instance of PositiveIntType.\`;
      assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
      this.countMax = element;
    } else {
      this.countMax = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`countMax\` property exists and has a value; \`false\` otherwise
   */
  public hasCountMaxElement(): boolean {
    return isDefined<PositiveIntType>(this.countMax) && !this.countMax.isEmpty();
  }

  /**
   * @returns the \`countMax\` property value as a fhirPositiveInt if defined; else undefined
   */
  public getCountMax(): fhirPositiveInt | undefined {
    return this.countMax?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`countMax\` property.
   *
   * @param value - the \`countMax\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setCountMax(value: fhirPositiveInt | undefined): this {
    if (isDefined<fhirPositiveInt>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.countMax (\${String(value)})\`;
      this.countMax = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    } else {
      this.countMax = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`countMax\` property exists and has a value; \`false\` otherwise
   */
  public hasCountMax(): boolean {
    return this.hasCountMaxElement();
  }

  /**
   * @returns the \`duration\` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getDurationElement(): DecimalType {
    return this.duration ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`duration\` property.
   *
   * @param element - the \`duration\` value
   * @returns this
   */
  public setDurationElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.duration; Provided element is not an instance of DecimalType.\`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.duration = element;
    } else {
      this.duration = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`duration\` property exists and has a value; \`false\` otherwise
   */
  public hasDurationElement(): boolean {
    return isDefined<DecimalType>(this.duration) && !this.duration.isEmpty();
  }

  /**
   * @returns the \`duration\` property value as a fhirDecimal if defined; else undefined
   */
  public getDuration(): fhirDecimal | undefined {
    return this.duration?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`duration\` property.
   *
   * @param value - the \`duration\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setDuration(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.duration (\${String(value)})\`;
      this.duration = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.duration = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`duration\` property exists and has a value; \`false\` otherwise
   */
  public hasDuration(): boolean {
    return this.hasDurationElement();
  }

  /**
   * @returns the \`durationMax\` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getDurationMaxElement(): DecimalType {
    return this.durationMax ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`durationMax\` property.
   *
   * @param element - the \`durationMax\` value
   * @returns this
   */
  public setDurationMaxElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.durationMax; Provided element is not an instance of DecimalType.\`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.durationMax = element;
    } else {
      this.durationMax = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`durationMax\` property exists and has a value; \`false\` otherwise
   */
  public hasDurationMaxElement(): boolean {
    return isDefined<DecimalType>(this.durationMax) && !this.durationMax.isEmpty();
  }

  /**
   * @returns the \`durationMax\` property value as a fhirDecimal if defined; else undefined
   */
  public getDurationMax(): fhirDecimal | undefined {
    return this.durationMax?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`durationMax\` property.
   *
   * @param value - the \`durationMax\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setDurationMax(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.durationMax (\${String(value)})\`;
      this.durationMax = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.durationMax = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`durationMax\` property exists and has a value; \`false\` otherwise
   */
  public hasDurationMax(): boolean {
    return this.hasDurationMaxElement();
  }

  /**
   * @returns the \`durationUnit\` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getDurationUnitElement(): CodeType {
    return this.durationUnit ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`durationUnit\` property.
   *
   * @param element - the \`durationUnit\` value
   * @returns this
   */
  public setDurationUnitElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.durationUnit; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.durationUnit = element;
    } else {
      this.durationUnit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`durationUnit\` property exists and has a value; \`false\` otherwise
   */
  public hasDurationUnitElement(): boolean {
    return isDefined<CodeType>(this.durationUnit) && !this.durationUnit.isEmpty();
  }

  /**
   * @returns the \`durationUnit\` property value as a fhirCode if defined; else undefined
   */
  public getDurationUnit(): fhirCode | undefined {
    return this.durationUnit?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`durationUnit\` property.
   *
   * @param value - the \`durationUnit\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setDurationUnit(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.durationUnit (\${String(value)})\`;
      this.durationUnit = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.durationUnit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`durationUnit\` property exists and has a value; \`false\` otherwise
   */
  public hasDurationUnit(): boolean {
    return this.hasDurationUnitElement();
  }

  /**
   * @returns the \`frequency\` property value as a PositiveIntType object if defined; else an empty PositiveIntType object
   */
  public getFrequencyElement(): PositiveIntType {
    return this.frequency ?? new PositiveIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`frequency\` property.
   *
   * @param element - the \`frequency\` value
   * @returns this
   */
  public setFrequencyElement(element: PositiveIntType | undefined): this {
    if (isDefined<PositiveIntType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.frequency; Provided element is not an instance of PositiveIntType.\`;
      assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
      this.frequency = element;
    } else {
      this.frequency = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`frequency\` property exists and has a value; \`false\` otherwise
   */
  public hasFrequencyElement(): boolean {
    return isDefined<PositiveIntType>(this.frequency) && !this.frequency.isEmpty();
  }

  /**
   * @returns the \`frequency\` property value as a fhirPositiveInt if defined; else undefined
   */
  public getFrequency(): fhirPositiveInt | undefined {
    return this.frequency?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`frequency\` property.
   *
   * @param value - the \`frequency\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setFrequency(value: fhirPositiveInt | undefined): this {
    if (isDefined<fhirPositiveInt>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.frequency (\${String(value)})\`;
      this.frequency = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    } else {
      this.frequency = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`frequency\` property exists and has a value; \`false\` otherwise
   */
  public hasFrequency(): boolean {
    return this.hasFrequencyElement();
  }

  /**
   * @returns the \`frequencyMax\` property value as a PositiveIntType object if defined; else an empty PositiveIntType object
   */
  public getFrequencyMaxElement(): PositiveIntType {
    return this.frequencyMax ?? new PositiveIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`frequencyMax\` property.
   *
   * @param element - the \`frequencyMax\` value
   * @returns this
   */
  public setFrequencyMaxElement(element: PositiveIntType | undefined): this {
    if (isDefined<PositiveIntType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.frequencyMax; Provided element is not an instance of PositiveIntType.\`;
      assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
      this.frequencyMax = element;
    } else {
      this.frequencyMax = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`frequencyMax\` property exists and has a value; \`false\` otherwise
   */
  public hasFrequencyMaxElement(): boolean {
    return isDefined<PositiveIntType>(this.frequencyMax) && !this.frequencyMax.isEmpty();
  }

  /**
   * @returns the \`frequencyMax\` property value as a fhirPositiveInt if defined; else undefined
   */
  public getFrequencyMax(): fhirPositiveInt | undefined {
    return this.frequencyMax?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`frequencyMax\` property.
   *
   * @param value - the \`frequencyMax\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setFrequencyMax(value: fhirPositiveInt | undefined): this {
    if (isDefined<fhirPositiveInt>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.frequencyMax (\${String(value)})\`;
      this.frequencyMax = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    } else {
      this.frequencyMax = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`frequencyMax\` property exists and has a value; \`false\` otherwise
   */
  public hasFrequencyMax(): boolean {
    return this.hasFrequencyMaxElement();
  }

  /**
   * @returns the \`period\` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getPeriodElement(): DecimalType {
    return this.period ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`period\` property.
   *
   * @param element - the \`period\` value
   * @returns this
   */
  public setPeriodElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.period; Provided element is not an instance of DecimalType.\`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.period = element;
    } else {
      this.period = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`period\` property exists and has a value; \`false\` otherwise
   */
  public hasPeriodElement(): boolean {
    return isDefined<DecimalType>(this.period) && !this.period.isEmpty();
  }

  /**
   * @returns the \`period\` property value as a fhirDecimal if defined; else undefined
   */
  public getPeriod(): fhirDecimal | undefined {
    return this.period?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`period\` property.
   *
   * @param value - the \`period\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setPeriod(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.period (\${String(value)})\`;
      this.period = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.period = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`period\` property exists and has a value; \`false\` otherwise
   */
  public hasPeriod(): boolean {
    return this.hasPeriodElement();
  }

  /**
   * @returns the \`periodMax\` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getPeriodMaxElement(): DecimalType {
    return this.periodMax ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`periodMax\` property.
   *
   * @param element - the \`periodMax\` value
   * @returns this
   */
  public setPeriodMaxElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.periodMax; Provided element is not an instance of DecimalType.\`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.periodMax = element;
    } else {
      this.periodMax = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`periodMax\` property exists and has a value; \`false\` otherwise
   */
  public hasPeriodMaxElement(): boolean {
    return isDefined<DecimalType>(this.periodMax) && !this.periodMax.isEmpty();
  }

  /**
   * @returns the \`periodMax\` property value as a fhirDecimal if defined; else undefined
   */
  public getPeriodMax(): fhirDecimal | undefined {
    return this.periodMax?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`periodMax\` property.
   *
   * @param value - the \`periodMax\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setPeriodMax(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.periodMax (\${String(value)})\`;
      this.periodMax = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.periodMax = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`periodMax\` property exists and has a value; \`false\` otherwise
   */
  public hasPeriodMax(): boolean {
    return this.hasPeriodMaxElement();
  }

  /**
   * @returns the \`periodUnit\` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getPeriodUnitElement(): CodeType {
    return this.periodUnit ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`periodUnit\` property.
   *
   * @param element - the \`periodUnit\` value
   * @returns this
   */
  public setPeriodUnitElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.periodUnit; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.periodUnit = element;
    } else {
      this.periodUnit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`periodUnit\` property exists and has a value; \`false\` otherwise
   */
  public hasPeriodUnitElement(): boolean {
    return isDefined<CodeType>(this.periodUnit) && !this.periodUnit.isEmpty();
  }

  /**
   * @returns the \`periodUnit\` property value as a fhirCode if defined; else undefined
   */
  public getPeriodUnit(): fhirCode | undefined {
    return this.periodUnit?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`periodUnit\` property.
   *
   * @param value - the \`periodUnit\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setPeriodUnit(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.periodUnit (\${String(value)})\`;
      this.periodUnit = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.periodUnit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`periodUnit\` property exists and has a value; \`false\` otherwise
   */
  public hasPeriodUnit(): boolean {
    return this.hasPeriodUnitElement();
  }

  /**
   * @returns the \`dayOfWeek\` property value as a EnumCodeType array
   */
  public getDayOfWeekEnumType(): EnumCodeType[] {
    return this.dayOfWeek ?? ([] as EnumCodeType[]);
  }

  /**
   * Assigns the provided EnumCodeType array value to the \`dayOfWeek\` property.
   *
   * @param enumType - the \`dayOfWeek\` array value
   * @returns this
   */
  public setDayOfWeekEnumType(enumType: EnumCodeType[] | undefined): this {
    if (isDefinedList<EnumCodeType>(enumType)) {
      const errMsgPrefix = \`Invalid Timing.repeat.dayOfWeek\`;
      assertEnumCodeTypeList<DaysOfWeekEnum>(enumType, DaysOfWeekEnum, errMsgPrefix);
      this.dayOfWeek = enumType;
    } else {
      this.dayOfWeek = undefined;
    }
    return this;
  }

  /**
   * Add the provided EnumCodeType value to the \`dayOfWeek\` array property.
   *
   * @param enumType - the \`dayOfWeek\` value
   * @returns this
   */
  public addDayOfWeekEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = \`Invalid Timing.repeat.dayOfWeek)\`;
      assertEnumCodeType<DaysOfWeekEnum>(enumType, DaysOfWeekEnum, errMsgPrefix);
      this.initDayOfWeek();
      this.dayOfWeek?.push(enumType);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`dayOfWeek\` property exists and has a value; \`false\` otherwise
   */
  public hasDayOfWeekEnumType(): boolean {
    return isDefinedList<EnumCodeType>(this.dayOfWeek) && this.dayOfWeek.some((item: EnumCodeType) => !item.isEmpty()) && this.dayOfWeek.every((item: EnumCodeType) => item.fhirCodeEnumeration.length > 0);
  }

  /**
   * @returns the \`dayOfWeek\` property value as a CodeType array
   */
  public getDayOfWeekElement(): CodeType[] {
    if (this.dayOfWeek === undefined) {
      return [] as CodeType[];
    }
    return this.dayOfWeek as CodeType[];
  }

  /**
   * Assigns the provided PrimitiveType array value to the \`dayOfWeek\` property.
   *
   * @param element - the \`dayOfWeek\` array value
   * @returns this
   */
  public setDayOfWeekElement(element: CodeType[] | undefined): this {
    if (isDefinedList<CodeType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.dayOfWeek; Provided element array has an element that is not an instance of CodeType.\`;
      assertFhirTypeList<CodeType>(element, CodeType, optErrMsg);
      const enumCodeTypes = [] as EnumCodeType[];
      element.forEach((type: CodeType) => {
        enumCodeTypes.push(new EnumCodeType(type, this.daysOfWeekEnum));
      });
      this.dayOfWeek = enumCodeTypes;
    } else {
      this.dayOfWeek = undefined;
    }
    return this;
  }

  /**
   * Add the provided PrimitiveType value to the \`dayOfWeek\` array property.
   *
   * @param element - the \`dayOfWeek\` value
   * @returns this
   */
  public addDayOfWeekElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.dayOfWeek; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.initDayOfWeek();
      this.dayOfWeek?.push(new EnumCodeType(element, this.daysOfWeekEnum));
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`dayOfWeek\` property exists and has a value; \`false\` otherwise
   */
  public hasDayOfWeekElement(): boolean {
    return this.hasDayOfWeekEnumType();
  }

  /**
   * @returns the \`dayOfWeek\` property value as a fhirCode array
   */
  public getDayOfWeek(): fhirCode[] {
    if (this.dayOfWeek === undefined) {
      return [] as fhirCode[];
    }
    const values = [] as fhirCode[];
    for (const item of this.dayOfWeek) {
      values.push(item.fhirCode.code);
    }
    return values;
  }

  /**
   * Assigns the provided primitive value array to the \`dayOfWeek\` property.
   *
   * @param value - the \`dayOfWeek\` value array
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setDayOfWeek(value: fhirCode[] | undefined): this {
    if (isDefinedList<fhirCode>(value)) {
      const enumCodeTypes = [] as EnumCodeType[];
      const optErrMsg = \`Invalid Timing.repeat.dayOfWeek; Provided value is not an instance of fhirCode.\`;
      value.forEach((val: fhirCode) => {
        enumCodeTypes.push(new EnumCodeType(parseFhirPrimitiveData(val, fhirCodeSchema, optErrMsg), this.daysOfWeekEnum));
      });
      this.dayOfWeek = enumCodeTypes;
    } else {
      this.dayOfWeek = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`dayOfWeek\` array property.
   *
   * @param value - the \`dayOfWeek\` value
   * @returns this
   */
  public addDayOfWeek(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      this.initDayOfWeek();
      const optErrMsg = \`Invalid Timing.repeat.dayOfWeek; Provided value is not an instance of fhirCode.\`;
      this.dayOfWeek?.push(new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.daysOfWeekEnum));
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`dayOfWeek\` property exists and has a value; \`false\` otherwise
   */
  public hasDayOfWeek(): boolean {
    return this.hasDayOfWeekEnumType();
  }

  /**
   * Initialize the dayOfWeek property
   */
  private initDayOfWeek(): void {
    if(!this.hasDayOfWeekEnumType()) {
      this.dayOfWeek = [] as EnumCodeType[];
    }
  }

  /**
   * @returns the \`timeOfDay\` property value as a TimeType array
   */
  public getTimeOfDayElement(): TimeType[] {
    return this.timeOfDay ?? ([] as TimeType[]);
  }

  /**
   * Assigns the provided TimeType array value to the \`timeOfDay\` property.
   *
   * @param element - the \`timeOfDay\` array value
   * @returns this
   */
  public setTimeOfDayElement(element: TimeType[] | undefined): this {
    if (isDefinedList<TimeType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.timeOfDay; Provided value array has an element that is not an instance of TimeType.\`;
      assertFhirTypeList<TimeType>(element, TimeType, optErrMsg);
      this.timeOfDay = element;
    } else {
      this.timeOfDay = undefined;
    }
    return this;
  }

  /**
   * Add the provided TimeType value to the \`timeOfDay\` array property.
   *
   * @param element - the \`timeOfDay\` value
   * @returns this
   */
  public addTimeOfDayElement(element: TimeType | undefined): this {
    if (isDefined<TimeType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.timeOfDay; Provided element is not an instance of TimeType.\`;
      assertFhirType<TimeType>(element, TimeType, optErrMsg);
      this.initTimeOfDay();
      this.timeOfDay?.push(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`timeOfDay\` property exists and has a value; \`false\` otherwise
   */
  public hasTimeOfDayElement(): boolean {
    return isDefinedList<TimeType>(this.timeOfDay) && this.timeOfDay.some((item: TimeType) => !item.isEmpty());
  }

  /**
   * @returns the \`timeOfDay\` property value as a fhirTime array
   */
  public getTimeOfDay(): fhirTime[] {
    this.initTimeOfDay();
    const timeOfDayValues = [] as fhirTime[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.timeOfDay!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        timeOfDayValues.push(value);
      }
    }
    return timeOfDayValues;
  }

  /**
   * Assigns the provided primitive value array to the \`timeOfDay\` property.
   *
   * @param value - the \`timeOfDay\` value array
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setTimeOfDay(value: fhirTime[] | undefined): this {
    if (isDefinedList<fhirTime>(value)) {
      const timeOfDayElements = [] as TimeType[];
      for (const timeOfDayValue of value) {
        const optErrMsg = \`Invalid Timing.repeat.timeOfDay array item (\${String(timeOfDayValue)})\`;
        const element = new TimeType(parseFhirPrimitiveData(timeOfDayValue, fhirTimeSchema, optErrMsg));
        timeOfDayElements.push(element);
      }
      this.timeOfDay = timeOfDayElements;
    } else {
      this.timeOfDay = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`timeOfDay\` array property.
   *
   * @param value - the \`timeOfDay\` value
   * @returns this
   */
  public addTimeOfDay(value: fhirTime | undefined): this {
    if (isDefined<fhirTime>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.timeOfDay array item (\${String(value)})\`;
      const element = new TimeType(parseFhirPrimitiveData(value, fhirTimeSchema, optErrMsg));
      this.initTimeOfDay();
      this.addTimeOfDayElement(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`timeOfDay\` property exists and has a value; \`false\` otherwise
   */
  public hasTimeOfDay(): boolean {
    return this.hasTimeOfDayElement();
  }

  /**
   * Initialize the \`timeOfDay\` property
   */
  private initTimeOfDay(): void {
    if (!this.hasTimeOfDay()) {
      this.timeOfDay = [] as TimeType[];
    }
  }

  /**
   * @returns the \`when\` property value as a CodeType array
   */
  public getWhenElement(): CodeType[] {
    return this.when ?? ([] as CodeType[]);
  }

  /**
   * Assigns the provided CodeType array value to the \`when\` property.
   *
   * @param element - the \`when\` array value
   * @returns this
   */
  public setWhenElement(element: CodeType[] | undefined): this {
    if (isDefinedList<CodeType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.when; Provided value array has an element that is not an instance of CodeType.\`;
      assertFhirTypeList<CodeType>(element, CodeType, optErrMsg);
      this.when = element;
    } else {
      this.when = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeType value to the \`when\` array property.
   *
   * @param element - the \`when\` value
   * @returns this
   */
  public addWhenElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.when; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.initWhen();
      this.when?.push(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`when\` property exists and has a value; \`false\` otherwise
   */
  public hasWhenElement(): boolean {
    return isDefinedList<CodeType>(this.when) && this.when.some((item: CodeType) => !item.isEmpty());
  }

  /**
   * @returns the \`when\` property value as a fhirCode array
   */
  public getWhen(): fhirCode[] {
    this.initWhen();
    const whenValues = [] as fhirCode[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.when!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        whenValues.push(value);
      }
    }
    return whenValues;
  }

  /**
   * Assigns the provided primitive value array to the \`when\` property.
   *
   * @param value - the \`when\` value array
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setWhen(value: fhirCode[] | undefined): this {
    if (isDefinedList<fhirCode>(value)) {
      const whenElements = [] as CodeType[];
      for (const whenValue of value) {
        const optErrMsg = \`Invalid Timing.repeat.when array item (\${String(whenValue)})\`;
        const element = new CodeType(parseFhirPrimitiveData(whenValue, fhirCodeSchema, optErrMsg));
        whenElements.push(element);
      }
      this.when = whenElements;
    } else {
      this.when = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`when\` array property.
   *
   * @param value - the \`when\` value
   * @returns this
   */
  public addWhen(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.when array item (\${String(value)})\`;
      const element = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
      this.initWhen();
      this.addWhenElement(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`when\` property exists and has a value; \`false\` otherwise
   */
  public hasWhen(): boolean {
    return this.hasWhenElement();
  }

  /**
   * Initialize the \`when\` property
   */
  private initWhen(): void {
    if (!this.hasWhen()) {
      this.when = [] as CodeType[];
    }
  }

  /**
   * @returns the \`offset\` property value as a UnsignedIntType object if defined; else an empty UnsignedIntType object
   */
  public getOffsetElement(): UnsignedIntType {
    return this.offset ?? new UnsignedIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`offset\` property.
   *
   * @param element - the \`offset\` value
   * @returns this
   */
  public setOffsetElement(element: UnsignedIntType | undefined): this {
    if (isDefined<UnsignedIntType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.offset; Provided element is not an instance of UnsignedIntType.\`;
      assertFhirType<UnsignedIntType>(element, UnsignedIntType, optErrMsg);
      this.offset = element;
    } else {
      this.offset = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`offset\` property exists and has a value; \`false\` otherwise
   */
  public hasOffsetElement(): boolean {
    return isDefined<UnsignedIntType>(this.offset) && !this.offset.isEmpty();
  }

  /**
   * @returns the \`offset\` property value as a fhirUnsignedInt if defined; else undefined
   */
  public getOffset(): fhirUnsignedInt | undefined {
    return this.offset?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`offset\` property.
   *
   * @param value - the \`offset\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setOffset(value: fhirUnsignedInt | undefined): this {
    if (isDefined<fhirUnsignedInt>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.offset (\${String(value)})\`;
      this.offset = new UnsignedIntType(parseFhirPrimitiveData(value, fhirUnsignedIntSchema, optErrMsg));
    } else {
      this.offset = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`offset\` property exists and has a value; \`false\` otherwise
   */
  public hasOffset(): boolean {
    return this.hasOffsetElement();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Timing.repeat';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.bounds,
      this.count,
      this.countMax,
      this.duration,
      this.durationMax,
      this.durationUnit,
      this.frequency,
      this.frequencyMax,
      this.period,
      this.periodMax,
      this.periodUnit,
      this.dayOfWeek,
      this.timeOfDay,
      this.when,
      this.offset,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): TimingRepeatComponent {
    const dest = new TimingRepeatComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: TimingRepeatComponent): void {
    super.copyValues(dest);
    dest.bounds = this.bounds?.copy();
    dest.count = this.count?.copy();
    dest.countMax = this.countMax?.copy();
    dest.duration = this.duration?.copy();
    dest.durationMax = this.durationMax?.copy();
    dest.durationUnit = this.durationUnit?.copy();
    dest.frequency = this.frequency?.copy();
    dest.frequencyMax = this.frequencyMax?.copy();
    dest.period = this.period?.copy();
    dest.periodMax = this.periodMax?.copy();
    dest.periodUnit = this.periodUnit?.copy();
    const dayOfWeekList = copyListValues<EnumCodeType>(this.dayOfWeek);
    dest.dayOfWeek = dayOfWeekList.length === 0 ? undefined : dayOfWeekList;
    const timeOfDayList = copyListValues<TimeType>(this.timeOfDay);
    dest.timeOfDay = timeOfDayList.length === 0 ? undefined : timeOfDayList;
    const whenList = copyListValues<CodeType>(this.when);
    dest.when = whenList.length === 0 ? undefined : whenList;
    dest.offset = this.offset?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasBounds()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getBounds()!, 'bounds', jsonObj);
    }

    if (this.hasCountElement()) {
      setFhirPrimitiveJson<fhirPositiveInt>(this.getCountElement(), 'count', jsonObj);
    }

    if (this.hasCountMaxElement()) {
      setFhirPrimitiveJson<fhirPositiveInt>(this.getCountMaxElement(), 'countMax', jsonObj);
    }

    if (this.hasDurationElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getDurationElement(), 'duration', jsonObj);
    }

    if (this.hasDurationMaxElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getDurationMaxElement(), 'durationMax', jsonObj);
    }

    if (this.hasDurationUnitElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getDurationUnitElement(), 'durationUnit', jsonObj);
    }

    if (this.hasFrequencyElement()) {
      setFhirPrimitiveJson<fhirPositiveInt>(this.getFrequencyElement(), 'frequency', jsonObj);
    }

    if (this.hasFrequencyMaxElement()) {
      setFhirPrimitiveJson<fhirPositiveInt>(this.getFrequencyMaxElement(), 'frequencyMax', jsonObj);
    }

    if (this.hasPeriodElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getPeriodElement(), 'period', jsonObj);
    }

    if (this.hasPeriodMaxElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getPeriodMaxElement(), 'periodMax', jsonObj);
    }

    if (this.hasPeriodUnitElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getPeriodUnitElement(), 'periodUnit', jsonObj);
    }

    if (this.hasDayOfWeekElement()) {
      setFhirPrimitiveListJson<fhirCode>(this.getDayOfWeekElement(), 'dayOfWeek', jsonObj);
    }

    if (this.hasTimeOfDay()) {
      setFhirPrimitiveListJson(this.getTimeOfDayElement(), 'timeOfDay', jsonObj);
    }

    if (this.hasWhen()) {
      setFhirPrimitiveListJson(this.getWhenElement(), 'when', jsonObj);
    }

    if (this.hasOffsetElement()) {
      setFhirPrimitiveJson<fhirUnsignedInt>(this.getOffsetElement(), 'offset', jsonObj);
    }

    return jsonObj;
  }
}
",
  "fileExtension": "ts",
  "filename": "Timing",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 65`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * TriggerDefinition Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/TriggerDefinition
 * StructureDefinition.name: TriggerDefinition
 * StructureDefinition.description: TriggerDefinition Type: A description of a triggering event. Triggering events can be named events, data events, or periodic, as determined by the type element.
 * StructureDefinition.fhirVersion: 5.0.0
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  CanonicalType,
  ChoiceDataTypes,
  ChoiceDataTypesMeta,
  CodeType,
  DataType,
  DateTimeType,
  DateType,
  EnumCodeType,
  FhirDataTypeParser,
  FhirError,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  InvalidTypeError,
  JSON,
  REQUIRED_PROPERTIES_DO_NOT_EXIST,
  REQUIRED_PROPERTIES_REQD_IN_JSON,
  StringType,
  assertEnumCodeType,
  assertFhirType,
  assertFhirTypeList,
  assertIsDefined,
  constructorCodeValueAsEnumCodeType,
  copyListValues,
  fhirCanonical,
  fhirCanonicalSchema,
  fhirCode,
  fhirCodeSchema,
  fhirString,
  fhirStringSchema,
  getPrimitiveTypeJson,
  isDefined,
  isDefinedList,
  isElementEmpty,
  isEmpty,
  parseCanonicalType,
  parseCodeType,
  parseFhirPrimitiveData,
  parseStringType,
  setFhirComplexJson,
  setFhirComplexListJson,
  setFhirPrimitiveJson,
  setPolymorphicValueJson,
} from '@paq-ts-fhir/fhir-core';
import {
  CodeableConcept,
  DataRequirement,
  Expression,
  PARSABLE_DATATYPE_MAP,
  Reference,
  Timing,
  TriggerTypeEnum,
} from '../index';

// eslint-disable-next-line @typescript-eslint/no-explicit-any -- Symbol.metadata polyfill secret sauce for decorator metadata
(Symbol.metadata as any) ??= Symbol('Symbol.metadata');

/**
 * TriggerDefinition Class
 *
 * @remarks
 * TriggerDefinition Type: A description of a triggering event. Triggering events can be named events, data events, or periodic, as determined by the type element.
 *
 * **FHIR Specification**
 * - **Short:** Defines an expected trigger for a module
 * - **Definition:** A description of a triggering event. Triggering events can be named events, data events, or periodic, as determined by the type element.
 * - **Comment:** If an event is a named-event, it means the event is completely pre-coordinated, and no other information can be specified for the event. If the event is one of the data- events, the data and condition elements specify the triggering criteria. The data element specifies the structured component, and the condition element provides additional optional refinement of that structured component. If the event is periodic, the timing element defines when the event is triggered. For both data- and periodic events, a name can be provided as a shorthand for the formal semantics provided by the other elements.
 * - **FHIR Version:** 5.0.0
 *
 * @category DataModel: ComplexType
 * @see [FHIR TriggerDefinition](http://hl7.org/fhir/StructureDefinition/TriggerDefinition)
 */
export class TriggerDefinition extends DataType implements IBase {
  constructor(type_: EnumCodeType | CodeType | null = null) {
    super();

    this.triggerTypeEnum = new TriggerTypeEnum();

    this.type_ = constructorCodeValueAsEnumCodeType<TriggerTypeEnum>(
      type_,
      TriggerTypeEnum,
      this.triggerTypeEnum,
      '.type',
    );
  }

  /**
   * Parse the provided \`TriggerDefinition\` JSON to instantiate the TriggerDefinition data model.
   *
   * @param sourceJson - JSON representing FHIR \`TriggerDefinition\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to TriggerDefinition
   * @returns TriggerDefinition data model or undefined for \`TriggerDefinition\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): TriggerDefinition | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'TriggerDefinition';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new TriggerDefinition();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const classMetadata: DecoratorMetadataObject | null = TriggerDefinition[Symbol.metadata];
    const errorMessage = \`DecoratorMetadataObject does not exist for TriggerDefinition\`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    const missingReqdProperties: string[] = [];

    fieldName = 'type';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setTypeElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'name';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setNameElement(datatype);
    }

    fieldName = 'code';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = fhirDataTypeParser.parser<CodeableConcept>(CodeableConcept, classJsonObj[fieldName]!, sourceField);
      instance.setCode(datatype);
    }

    fieldName = 'subscriptionTopic';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CanonicalType | undefined = parseCanonicalType(dtJson, dtSiblingJson);
      instance.setSubscriptionTopicElement(datatype);
    }

    fieldName = 'timing[x]';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const timing: DataType | undefined = fhirDataTypeParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setTiming(timing);

    fieldName = 'data';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: DataRequirement | undefined = fhirDataTypeParser.parser<DataRequirement>(DataRequirement, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addData(datatype);
        }
      });
    }

    fieldName = 'condition';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Expression | undefined = fhirDataTypeParser.parser<Expression>(Expression, classJsonObj[fieldName]!, sourceField);
      instance.setCondition(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: TriggerType
   *
   * @see {@link TriggerTypeEnum }
   */
  private readonly triggerTypeEnum: TriggerTypeEnum;

  /**
   * TriggerDefinition.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** named-event | periodic | data-changed | data-added | data-modified | data-removed | data-accessed | data-access-ended
   * - **Definition:** The type of triggering event.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private type_: EnumCodeType | null;

  /**
   * TriggerDefinition.name Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Name or URI that identifies the event
   * - **Definition:** A formal name for the event. This may be an absolute URI that identifies the event formally (e.g. from a trigger registry), or a simple relative URI that identifies the event in a local context.
   * - **Comment:** An event name can be provided for all event types, but is required for named events. If a name is provided for a type other than named events, it is considered to be a shorthand for the semantics described by the formal description of the event.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private name?: StringType | undefined;

  /**
   * TriggerDefinition.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Coded definition of the event
   * - **Definition:** A code that identifies the event.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code?: CodeableConcept | undefined;

  /**
   * TriggerDefinition.subscriptionTopic Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** What event
   * - **Definition:** A reference to a SubscriptionTopic resource that defines the event. If this element is provided, no other information about the trigger definition may be supplied.
   * - **FHIR Type:** \`canonical\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/SubscriptionTopic',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private subscriptionTopic?: CanonicalType | undefined;

  /**
   * TriggerDefinition.timing[x] Element
   *
   * @decorator \`@ChoiceDataTypesMeta('TriggerDefinition.timing[x]', ['Timing','Reference','date','dateTime',]\`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Timing of the event
   * - **Definition:** The timing of the event (if this is a periodic trigger).
   * - **FHIR Types:**
   *     'Timing',
   *     'Reference',
   *     'date',
   *     'dateTime',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('TriggerDefinition.timing[x]',[
    'Timing',
    'Reference',
    'date',
    'dateTime',
  ])
  private timing?: DataType | undefined;

  /**
   * TriggerDefinition.data Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Triggering data of the event (multiple = \\'and\\')
   * - **Definition:** The triggering data of the event (if this is a data trigger). If more than one data is requirement is specified, then all the data requirements must be true.
   * - **Comment:** This element shall be present for any data type trigger.
   * - **FHIR Type:** \`DataRequirement\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private data?: DataRequirement[] | undefined;

  /**
   * TriggerDefinition.condition Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Whether the event triggers (boolean expression)
   * - **Definition:** A boolean-valued expression that is evaluated in the context of the container of the trigger definition and returns whether or not the trigger fires.
   * - **Comment:** This element can be only be specified for data type triggers and provides additional semantics for the trigger. The context available within the condition is based on the type of data event. For all events, the current resource will be available as context. In addition, for modification events, the previous resource will also be available. The expression may be inlined, or may be a simple absolute URI, which is a reference to a named expression within a logic library referenced by a library element or extension within the containing resource. If the expression is a FHIR Path expression, it evaluates in the context of a resource of one of the type identified in the data requirement, and may also refer to the variable %previous for delta comparisons on events of type data-changed, data-modified, and data-deleted which will always have the same type.
   * - **Requirements:** Need to be able to formally describe the triggering criteria.
   * - **FHIR Type:** \`Expression\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private condition?: Expression | undefined;


  /**
   * @returns the \`type_\` property value as a EnumCodeType if defined; else null
   */
  public getTypeEnumType(): EnumCodeType | null {
    return this.type_;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`type_\` property.
   *
   * @param enumType - the \`type_\` value
   * @returns this
   */
  public setTypeEnumType(enumType: EnumCodeType): this {
    assertIsDefined<EnumCodeType>(enumType, \`TriggerDefinition.type is required\`);
    const errMsgPrefix = \`Invalid TriggerDefinition.type\`;
    assertEnumCodeType<TriggerTypeEnum>(enumType, TriggerTypeEnum, errMsgPrefix);
    this.type_ = enumType;
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasTypeEnumType(): boolean {
    return isDefined<EnumCodeType>(this.type_) && !this.type_.isEmpty() && this.type_.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`type_\` property value as a CodeType if defined; else null
   */
  public getTypeElement(): CodeType | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_ as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`type_\` property.
   *
   * @param element - the \`type_\` value
   * @returns this
   */
  public setTypeElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, \`TriggerDefinition.type is required\`);
    const optErrMsg = \`Invalid TriggerDefinition.type; Provided value is not an instance of CodeType.\`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.type_ = new EnumCodeType(element, this.triggerTypeEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasTypeElement(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the \`type_\` property value as a fhirCode if defined; else null
   */
  public getType(): fhirCode | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`type_\` property.
   *
   * @param value - the \`type_\` value
   * @returns this
   */
  public setType(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, \`TriggerDefinition.type is required\`);
    const optErrMsg = \`Invalid TriggerDefinition.type (\${String(value)})\`;
    this.type_ = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.triggerTypeEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasType(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the \`name\` property value as a StringType object if defined; else an empty StringType object
   */
  public getNameElement(): StringType {
    return this.name ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`name\` property.
   *
   * @param element - the \`name\` value
   * @returns this
   */
  public setNameElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid TriggerDefinition.name; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.name = element;
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`name\` property exists and has a value; \`false\` otherwise
   */
  public hasNameElement(): boolean {
    return isDefined<StringType>(this.name) && !this.name.isEmpty();
  }

  /**
   * @returns the \`name\` property value as a fhirString if defined; else undefined
   */
  public getName(): fhirString | undefined {
    return this.name?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`name\` property.
   *
   * @param value - the \`name\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setName(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid TriggerDefinition.name (\${String(value)})\`;
      this.name = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`name\` property exists and has a value; \`false\` otherwise
   */
  public hasName(): boolean {
    return this.hasNameElement();
  }

  /**
   * @returns the \`code\` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getCode(): CodeableConcept {
    return this.code ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Code object value to the \`code\` property.
   *
   * @param value - the \`code\` object value
   * @returns this
   */
  public setCode(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid TriggerDefinition.code; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.code = value;
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`code\` property exists and has a value; \`false\` otherwise
   */
  public hasCode(): boolean {
    return isDefined<CodeableConcept>(this.code) && !this.code.isEmpty();
  }

  /**
   * @returns the \`subscriptionTopic\` property value as a CanonicalType object if defined; else an empty CanonicalType object
   */
  public getSubscriptionTopicElement(): CanonicalType {
    return this.subscriptionTopic ?? new CanonicalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`subscriptionTopic\` property.
   *
   * @param element - the \`subscriptionTopic\` value
   * @returns this
   */
  public setSubscriptionTopicElement(element: CanonicalType | undefined): this {
    if (isDefined<CanonicalType>(element)) {
      const optErrMsg = \`Invalid TriggerDefinition.subscriptionTopic; Provided element is not an instance of CanonicalType.\`;
      assertFhirType<CanonicalType>(element, CanonicalType, optErrMsg);
      this.subscriptionTopic = element;
    } else {
      this.subscriptionTopic = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`subscriptionTopic\` property exists and has a value; \`false\` otherwise
   */
  public hasSubscriptionTopicElement(): boolean {
    return isDefined<CanonicalType>(this.subscriptionTopic) && !this.subscriptionTopic.isEmpty();
  }

  /**
   * @returns the \`subscriptionTopic\` property value as a fhirCanonical if defined; else undefined
   */
  public getSubscriptionTopic(): fhirCanonical | undefined {
    return this.subscriptionTopic?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`subscriptionTopic\` property.
   *
   * @param value - the \`subscriptionTopic\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setSubscriptionTopic(value: fhirCanonical | undefined): this {
    if (isDefined<fhirCanonical>(value)) {
      const optErrMsg = \`Invalid TriggerDefinition.subscriptionTopic (\${String(value)})\`;
      this.subscriptionTopic = new CanonicalType(parseFhirPrimitiveData(value, fhirCanonicalSchema, optErrMsg));
    } else {
      this.subscriptionTopic = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`subscriptionTopic\` property exists and has a value; \`false\` otherwise
   */
  public hasSubscriptionTopic(): boolean {
    return this.hasSubscriptionTopicElement();
  }

  /**
   * @returns the \`timing\` property value as a DataType object if defined; else undefined
   */
  public getTiming(): DataType | undefined {
    return this.timing;
  }

  /**
   * Assigns the provided DataType object value to the \`timing\` property.
   *
   * @decorator \`@ChoiceDataTypes('TriggerDefinition.timing[x]')\`
   *
   * @param value - the \`timing\` object value
   * @returns this
   */
  @ChoiceDataTypes('TriggerDefinition.timing[x]')
  public setTiming(value: DataType | undefined): this {
    if (isDefined<DataType>(value)) {
      // assertFhirType<DataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.timing = value;
    } else {
      this.timing = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`timing\` property exists and has a value; \`false\` otherwise
   */
  public hasTiming(): boolean {
    return isDefined<DataType>(this.timing) && !this.timing.isEmpty();
  }

  // *** NOTE ***
  // Next "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the \`timing\` property value as a Timing object if defined; else undefined
   */
  public getTimingTiming(): Timing | undefined {
    if (!isDefined<DataType | undefined>(this.timing)) {
      return undefined;
    }
    if (!(this.timing instanceof Timing)) {
      throw new InvalidTypeError(
        \`DataType mismatch for TriggerDefinition.timing[x]: Expected Timing but encountered \${this.timing.fhirType()}\`,
      );
    }
    return this.timing;
  }

  /**
   * @returns \`true\` if the \`timing\` property exists as a Timing and has a value; \`false\` otherwise
   */
  public hasTimingTiming(): boolean {
    return this.hasTiming() && this.timing instanceof Timing;
  }

  /**
   * @returns the \`timing\` property value as a Reference object if defined; else undefined
   */
  public getTimingReference(): Reference | undefined {
    if (!isDefined<DataType | undefined>(this.timing)) {
      return undefined;
    }
    if (!(this.timing instanceof Reference)) {
      throw new InvalidTypeError(
        \`DataType mismatch for TriggerDefinition.timing[x]: Expected Reference but encountered \${this.timing.fhirType()}\`,
      );
    }
    return this.timing;
  }

  /**
   * @returns \`true\` if the \`timing\` property exists as a Reference and has a value; \`false\` otherwise
   */
  public hasTimingReference(): boolean {
    return this.hasTiming() && this.timing instanceof Reference;
  }

  /**
   * @returns the \`timing\` property value as a DateType object if defined; else undefined
   */
  public getTimingDateType(): DateType | undefined {
    if (!isDefined<DataType | undefined>(this.timing)) {
      return undefined;
    }
    if (!(this.timing instanceof DateType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for TriggerDefinition.timing[x]: Expected DateType but encountered \${this.timing.fhirType()}\`,
      );
    }
    return this.timing;
  }

  /**
   * @returns \`true\` if the \`timing\` property exists as a DateType and has a value; \`false\` otherwise
   */
  public hasTimingDateType(): boolean {
    return this.hasTiming() && this.timing instanceof DateType;
  }

  /**
   * @returns the \`timing\` property value as a DateTimeType object if defined; else undefined
   */
  public getTimingDateTimeType(): DateTimeType | undefined {
    if (!isDefined<DataType | undefined>(this.timing)) {
      return undefined;
    }
    if (!(this.timing instanceof DateTimeType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for TriggerDefinition.timing[x]: Expected DateTimeType but encountered \${this.timing.fhirType()}\`,
      );
    }
    return this.timing;
  }

  /**
   * @returns \`true\` if the \`timing\` property exists as a DateTimeType and has a value; \`false\` otherwise
   */
  public hasTimingDateTimeType(): boolean {
    return this.hasTiming() && this.timing instanceof DateTimeType;
  }

  /**
   * @returns the \`data\` property value as a DataRequirement array
   */
  public getData(): DataRequirement[] {
    return this.data ?? ([] as DataRequirement[]);
  }

  /**
   * Assigns the provided DataRequirement array value to the \`data\` property.
   *
   * @param value - the \`data\` array value
   * @returns this
   */
  public setData(value: DataRequirement[] | undefined): this {
    if (isDefinedList<DataRequirement>(value)) {
      const optErrMsg = \`Invalid TriggerDefinition.data; Provided value array has an element that is not an instance of DataRequirement.\`;
      assertFhirTypeList<DataRequirement>(value, DataRequirement, optErrMsg);
      this.data = value;
    } else {
      this.data = undefined;
    }
    return this;
  }

  /**
   * Add the provided DataRequirement value to the \`data\` array property.
   *
   * @param value - the \`data\` value
   * @returns this
   */
  public addData(value: DataRequirement | undefined): this {
    if (isDefined<DataRequirement>(value)) {
      const optErrMsg = \`Invalid TriggerDefinition.data; Provided element is not an instance of DataRequirement.\`;
      assertFhirType<DataRequirement>(value, DataRequirement, optErrMsg);
      this.initData();
      this.data?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`data\` property exists and has a value; \`false\` otherwise
   */
  public hasData(): boolean {
    return isDefinedList<DataRequirement>(this.data) && this.data.some((item: DataRequirement) => !item.isEmpty());
  }

  /**
   * Initialize the \`data\` property
   */
  private initData(): void {
    if(!this.hasData()) {
      this.data = [] as DataRequirement[];
    }
  }

  /**
   * @returns the \`condition\` property value as a Expression object if defined; else an empty Expression object
   */
  public getCondition(): Expression {
    return this.condition ?? new Expression();
  }

  /**
   * Assigns the provided Condition object value to the \`condition\` property.
   *
   * @param value - the \`condition\` object value
   * @returns this
   */
  public setCondition(value: Expression | undefined): this {
    if (isDefined<Expression>(value)) {
      const optErrMsg = \`Invalid TriggerDefinition.condition; Provided element is not an instance of Expression.\`;
      assertFhirType<Expression>(value, Expression, optErrMsg);
      this.condition = value;
    } else {
      this.condition = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`condition\` property exists and has a value; \`false\` otherwise
   */
  public hasCondition(): boolean {
    return isDefined<Expression>(this.condition) && !this.condition.isEmpty();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'TriggerDefinition';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.type_,
      this.name,
      this.code,
      this.subscriptionTopic,
      this.timing,
      this.data,
      this.condition,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): TriggerDefinition {
    const dest = new TriggerDefinition();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: TriggerDefinition): void {
    super.copyValues(dest);
    dest.type_ = this.type_ ? this.type_.copy() : null;
    dest.name = this.name?.copy();
    dest.code = this.code?.copy();
    dest.subscriptionTopic = this.subscriptionTopic?.copy();
    dest.timing = this.timing?.copy();
    const dataList = copyListValues<DataRequirement>(this.data);
    dest.data = dataList.length === 0 ? undefined : dataList;
    dest.condition = this.condition?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasTypeElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getTypeElement()!, 'type', jsonObj);
    } else {
      missingReqdProperties.push(\`TriggerDefinition.type\`);
    }

    if (this.hasNameElement()) {
      setFhirPrimitiveJson<fhirString>(this.getNameElement(), 'name', jsonObj);
    }

    if (this.hasCode()) {
      setFhirComplexJson(this.getCode(), 'code', jsonObj);
    }

    if (this.hasSubscriptionTopicElement()) {
      setFhirPrimitiveJson<fhirCanonical>(this.getSubscriptionTopicElement(), 'subscriptionTopic', jsonObj);
    }

    if (this.hasTiming()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getTiming()!, 'timing', jsonObj);
    }

    if (this.hasData()) {
      setFhirComplexListJson(this.getData(), 'data', jsonObj);
    }

    if (this.hasCondition()) {
      setFhirComplexJson(this.getCondition(), 'condition', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "TriggerDefinition",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 66`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * UsageContext Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/UsageContext
 * StructureDefinition.name: UsageContext
 * StructureDefinition.description: UsageContext Type: Specifies clinical/business/etc. metadata that can be used to retrieve, index and/or categorize an artifact. This metadata can either be specific to the applicable population (e.g., age category, DRG) or the specific context of care (e.g., venue, care setting, provider of care).
 * StructureDefinition.fhirVersion: 5.0.0
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  ChoiceDataTypes,
  ChoiceDataTypesMeta,
  DataType,
  FhirDataTypeParser,
  FhirError,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  InvalidTypeError,
  JSON,
  REQUIRED_PROPERTIES_DO_NOT_EXIST,
  REQUIRED_PROPERTIES_REQD_IN_JSON,
  assertFhirType,
  assertIsDefined,
  isDefined,
  isElementEmpty,
  isEmpty,
  setFhirComplexJson,
  setPolymorphicValueJson,
} from '@paq-ts-fhir/fhir-core';
import {
  CodeableConcept,
  Coding,
  PARSABLE_DATATYPE_MAP,
  Quantity,
  Range,
  Reference,
} from '../index';

// eslint-disable-next-line @typescript-eslint/no-explicit-any -- Symbol.metadata polyfill secret sauce for decorator metadata
(Symbol.metadata as any) ??= Symbol('Symbol.metadata');

/**
 * UsageContext Class
 *
 * @remarks
 * UsageContext Type: Specifies clinical/business/etc. metadata that can be used to retrieve, index and/or categorize an artifact. This metadata can either be specific to the applicable population (e.g., age category, DRG) or the specific context of care (e.g., venue, care setting, provider of care).
 *
 * Consumers of the resource must be able to determine the intended applicability for the resource. Ideally, this information would be used programmatically to determine when and how it should be incorporated or exposed.
 *
 * **FHIR Specification**
 * - **Short:** Describes the context of use for a conformance or knowledge resource
 * - **Definition:** Specifies clinical/business/etc. metadata that can be used to retrieve, index and/or categorize an artifact. This metadata can either be specific to the applicable population (e.g., age category, DRG) or the specific context of care (e.g., venue, care setting, provider of care).
 * - **FHIR Version:** 5.0.0
 *
 * @category DataModel: ComplexType
 * @see [FHIR UsageContext](http://hl7.org/fhir/StructureDefinition/UsageContext)
 */
export class UsageContext extends DataType implements IBase {
  constructor(code: Coding | null = null, value: DataType | null = null) {
    super();

    this.code = null;
    if (isDefined<Coding>(code)) {
      this.setCode(code);
    }

    this.value = null;
    if (isDefined<DataType>(value)) {
      this.setValue(value);
    }
  }

  /**
   * Parse the provided \`UsageContext\` JSON to instantiate the UsageContext data model.
   *
   * @param sourceJson - JSON representing FHIR \`UsageContext\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to UsageContext
   * @returns UsageContext data model or undefined for \`UsageContext\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): UsageContext | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'UsageContext';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new UsageContext();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';

    const classMetadata: DecoratorMetadataObject | null = UsageContext[Symbol.metadata];
    const errorMessage = \`DecoratorMetadataObject does not exist for UsageContext\`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    const missingReqdProperties: string[] = [];

    fieldName = 'code';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Coding | undefined = fhirDataTypeParser.parser<Coding>(Coding, classJsonObj[fieldName]!, sourceField);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setCode(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'value[x]';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const value: DataType | undefined = fhirDataTypeParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    if (value === undefined) {
      missingReqdProperties.push(sourceField);
    } else {
      instance.setValue(value);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * UsageContext.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Type of context being specified
   * - **Definition:** A code that identifies the type of context being specified by this usage context.
   * - **FHIR Type:** \`Coding\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code: Coding | null;

  /**
   * UsageContext.value[x] Element
   *
   * @decorator \`@ChoiceDataTypesMeta('UsageContext.value[x]', ['CodeableConcept','Quantity','Range','Reference',]\`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Value that defines the context
   * - **Definition:** A value that defines the context specified in this context of use. The interpretation of the value is defined by the code.
   * - **FHIR Types:**
   *     'CodeableConcept',
   *     'Quantity',
   *     'Range',
   *     'Reference',
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('UsageContext.value[x]',[
    'CodeableConcept',
    'Quantity',
    'Range',
    'Reference',
  ])
  private value: DataType | null;


  /**
   * @returns the \`code\` property value as a Coding object if defined; else null
   */
  public getCode(): Coding | null {
    return this.code;
  }

  /**
   * Assigns the provided Coding object value to the \`code\` property.
   *
   * @param value - the \`code\` object value
   * @returns this
   */
  public setCode(value: Coding): this {
    assertIsDefined<Coding>(value, \`UsageContext.code is required\`);
    const optErrMsg = \`Invalid UsageContext.code; Provided element is not an instance of Coding.\`;
    assertFhirType<Coding>(value, Coding, optErrMsg);
    this.code = value;
    return this;
  }

  /**
   * @returns \`true\` if the \`code\` property exists and has a value; \`false\` otherwise
   */
  public hasCode(): boolean {
    return isDefined<Coding>(this.code) && !this.code.isEmpty();
  }

  /**
   * @returns the \`value\` property value as a DataType object; else null
   */
  public getValue(): DataType | null {
    return this.value;
  }

  /**
   * Assigns the provided DataType object value to the \`value\` property.
   *
   * @decorator \`@ChoiceDataTypes('UsageContext.value[x]')\`
   *
   * @param value - the \`value\` object value
   * @returns this
   */
  @ChoiceDataTypes('UsageContext.value[x]')
  public setValue(value: DataType): this {
    assertIsDefined<DataType>(value, \`UsageContext.value[x] is required\`);
    // assertFhirType<DataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
    this.value = value;
    return this;
  }

  /**
   * @returns \`true\` if the \`value\` property exists and has a value; \`false\` otherwise
   */
  public hasValue(): boolean {
    return isDefined<DataType>(this.value) && !this.value.isEmpty();
  }

  // *** NOTE ***
  // Next "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the \`value\` property value as a CodeableConcept object if defined; else null
   */
  public getValueCodeableConcept(): CodeableConcept | null {
    if (!isDefined<DataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof CodeableConcept)) {
      throw new InvalidTypeError(
        \`DataType mismatch for UsageContext.value[x]: Expected CodeableConcept but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`\` property exists as a CodeableConcept and has a value; \`false\` otherwise
   */
  public hasValueCodeableConcept(): boolean {
    return this.hasValue() && this.value instanceof CodeableConcept;
  }

  /**
   * @returns the \`value\` property value as a Quantity object if defined; else null
   */
  public getValueQuantity(): Quantity | null {
    if (!isDefined<DataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Quantity)) {
      throw new InvalidTypeError(
        \`DataType mismatch for UsageContext.value[x]: Expected Quantity but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`\` property exists as a Quantity and has a value; \`false\` otherwise
   */
  public hasValueQuantity(): boolean {
    return this.hasValue() && this.value instanceof Quantity;
  }

  /**
   * @returns the \`value\` property value as a Range object if defined; else null
   */
  public getValueRange(): Range | null {
    if (!isDefined<DataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Range)) {
      throw new InvalidTypeError(
        \`DataType mismatch for UsageContext.value[x]: Expected Range but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`\` property exists as a Range and has a value; \`false\` otherwise
   */
  public hasValueRange(): boolean {
    return this.hasValue() && this.value instanceof Range;
  }

  /**
   * @returns the \`value\` property value as a Reference object if defined; else null
   */
  public getValueReference(): Reference | null {
    if (!isDefined<DataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Reference)) {
      throw new InvalidTypeError(
        \`DataType mismatch for UsageContext.value[x]: Expected Reference but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`\` property exists as a Reference and has a value; \`false\` otherwise
   */
  public hasValueReference(): boolean {
    return this.hasValue() && this.value instanceof Reference;
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'UsageContext';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.code,
      this.value,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): UsageContext {
    const dest = new UsageContext();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: UsageContext): void {
    super.copyValues(dest);
    dest.code = this.code ? this.code.copy() : null;
    dest.value = this.value ? this.value.copy() : null;
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasCode()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirComplexJson(this.getCode()!, 'code', jsonObj);
    } else {
      missingReqdProperties.push(\`UsageContext.code\`);
    }

    if (this.hasValue()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getValue()!, 'value', jsonObj);
    } else {
      missingReqdProperties.push(\`UsageContext.value[x][x]\`);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "UsageContext",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 67`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * VirtualServiceDetail Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/VirtualServiceDetail
 * StructureDefinition.name: VirtualServiceDetail
 * StructureDefinition.description: VirtualServiceDetail Type: Virtual Service Contact Details.
 * StructureDefinition.fhirVersion: 5.0.0
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  ChoiceDataTypes,
  ChoiceDataTypesMeta,
  DataType,
  FhirDataTypeParser,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  InvalidTypeError,
  JSON,
  PositiveIntType,
  PrimitiveTypeJson,
  StringType,
  UrlType,
  assertFhirType,
  assertFhirTypeList,
  assertIsDefined,
  copyListValues,
  fhirPositiveInt,
  fhirPositiveIntSchema,
  fhirString,
  fhirStringSchema,
  fhirUrl,
  fhirUrlSchema,
  getPrimitiveTypeJson,
  getPrimitiveTypeListJson,
  isDefined,
  isDefinedList,
  isElementEmpty,
  isEmpty,
  parseFhirPrimitiveData,
  parsePositiveIntType,
  parseStringType,
  parseUrlType,
  setFhirComplexJson,
  setFhirPrimitiveJson,
  setFhirPrimitiveListJson,
  setPolymorphicValueJson,
} from '@paq-ts-fhir/fhir-core';
import {
  Coding,
  ContactPoint,
  ExtendedContactDetail,
  PARSABLE_DATATYPE_MAP,
} from '../index';

// eslint-disable-next-line @typescript-eslint/no-explicit-any -- Symbol.metadata polyfill secret sauce for decorator metadata
(Symbol.metadata as any) ??= Symbol('Symbol.metadata');

/**
 * VirtualServiceDetail Class
 *
 * @remarks
 * VirtualServiceDetail Type: Virtual Service Contact Details.
 *
 * **FHIR Specification**
 * - **Short:** Virtual Service Contact Details
 * - **Definition:** Virtual Service Contact Details.
 * - **FHIR Version:** 5.0.0
 *
 * @category DataModel: ComplexType
 * @see [FHIR VirtualServiceDetail](http://hl7.org/fhir/StructureDefinition/VirtualServiceDetail)
 */
export class VirtualServiceDetail extends DataType implements IBase {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`VirtualServiceDetail\` JSON to instantiate the VirtualServiceDetail data model.
   *
   * @param sourceJson - JSON representing FHIR \`VirtualServiceDetail\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to VirtualServiceDetail
   * @returns VirtualServiceDetail data model or undefined for \`VirtualServiceDetail\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): VirtualServiceDetail | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'VirtualServiceDetail';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new VirtualServiceDetail();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const classMetadata: DecoratorMetadataObject | null = VirtualServiceDetail[Symbol.metadata];
    const errorMessage = \`DecoratorMetadataObject does not exist for VirtualServiceDetail\`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    fieldName = 'channelType';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Coding | undefined = fhirDataTypeParser.parser<Coding>(Coding, classJsonObj[fieldName]!, sourceField);
      instance.setChannelType(datatype);
    }

    fieldName = 'address[x]';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const address: DataType | undefined = fhirDataTypeParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setAddress(address);

    fieldName = 'additionalInfo';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: UrlType | undefined = parseUrlType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addAdditionalInfoElement(datatype);
        }
      });
    }

    fieldName = 'maxParticipants';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = parsePositiveIntType(dtJson, dtSiblingJson);
      instance.setMaxParticipantsElement(datatype);
    }

    fieldName = 'sessionKey';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setSessionKeyElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * VirtualServiceDetail.channelType Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Channel Type
   * - **Definition:** The type of virtual service to connect to (i.e. Teams, Zoom, Specific VMR technology, WhatsApp).
   * - **Comment:** As this type defines what the virtual service is, it then defines what address and additional information might be relevant. Some profiles could be used for specific types to define what the other values could/should be.
   * - **FHIR Type:** \`Coding\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private channelType?: Coding | undefined;

  /**
   * VirtualServiceDetail.address[x] Element
   *
   * @decorator \`@ChoiceDataTypesMeta('VirtualServiceDetail.address[x]', ['url','string','ContactPoint','ExtendedContactDetail',]\`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Contact address/number
   * - **Definition:** What address or number needs to be used for a user to connect to the virtual service to join. The channelType informs as to which datatype is appropriate to use (requires knowledge of the specific type).
   * - **FHIR Types:**
   *     'url',
   *     'string',
   *     'ContactPoint',
   *     'ExtendedContactDetail',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('VirtualServiceDetail.address[x]',[
    'url',
    'string',
    'ContactPoint',
    'ExtendedContactDetail',
  ])
  private address?: DataType | undefined;

  /**
   * VirtualServiceDetail.additionalInfo Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Address to see alternative connection details
   * - **Definition:** Address to see alternative connection details.
   * - **Comment:** This web address can be used to provide additional details on the call, such as alternative/regional call in numbers, or other associated services.
   * - **FHIR Type:** \`url\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private additionalInfo?: UrlType[] | undefined;

  /**
   * VirtualServiceDetail.maxParticipants Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Maximum number of participants supported by the virtual service
   * - **Definition:** Maximum number of participants supported by the virtual service.
   * - **Comment:** Some services have only a limitted number of participants permitted to connect at a time, this is typically used in "shared" virtual services that you might find on location resources. Typically on-demand services might not have these restrictions.
   * - **FHIR Type:** \`positiveInt\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private maxParticipants?: PositiveIntType | undefined;

  /**
   * VirtualServiceDetail.sessionKey Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Session Key required by the virtual service
   * - **Definition:** Session Key required by the virtual service.
   * - **Comment:** Some services require a session key to be able to access the service once connected. This could be in cases where a shared number is used, and a session key is added to put into a private line, or to identify the participant in a call.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private sessionKey?: StringType | undefined;


  /**
   * @returns the \`channelType\` property value as a Coding object if defined; else an empty Coding object
   */
  public getChannelType(): Coding {
    return this.channelType ?? new Coding();
  }

  /**
   * Assigns the provided ChannelType object value to the \`channelType\` property.
   *
   * @param value - the \`channelType\` object value
   * @returns this
   */
  public setChannelType(value: Coding | undefined): this {
    if (isDefined<Coding>(value)) {
      const optErrMsg = \`Invalid VirtualServiceDetail.channelType; Provided element is not an instance of Coding.\`;
      assertFhirType<Coding>(value, Coding, optErrMsg);
      this.channelType = value;
    } else {
      this.channelType = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`channelType\` property exists and has a value; \`false\` otherwise
   */
  public hasChannelType(): boolean {
    return isDefined<Coding>(this.channelType) && !this.channelType.isEmpty();
  }

  /**
   * @returns the \`address\` property value as a DataType object if defined; else undefined
   */
  public getAddress(): DataType | undefined {
    return this.address;
  }

  /**
   * Assigns the provided DataType object value to the \`address\` property.
   *
   * @decorator \`@ChoiceDataTypes('VirtualServiceDetail.address[x]')\`
   *
   * @param value - the \`address\` object value
   * @returns this
   */
  @ChoiceDataTypes('VirtualServiceDetail.address[x]')
  public setAddress(value: DataType | undefined): this {
    if (isDefined<DataType>(value)) {
      // assertFhirType<DataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.address = value;
    } else {
      this.address = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`address\` property exists and has a value; \`false\` otherwise
   */
  public hasAddress(): boolean {
    return isDefined<DataType>(this.address) && !this.address.isEmpty();
  }

  // *** NOTE ***
  // Next "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the \`address\` property value as a UrlType object if defined; else undefined
   */
  public getAddressUrlType(): UrlType | undefined {
    if (!isDefined<DataType | undefined>(this.address)) {
      return undefined;
    }
    if (!(this.address instanceof UrlType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for VirtualServiceDetail.address[x]: Expected UrlType but encountered \${this.address.fhirType()}\`,
      );
    }
    return this.address;
  }

  /**
   * @returns \`true\` if the \`address\` property exists as a UrlType and has a value; \`false\` otherwise
   */
  public hasAddressUrlType(): boolean {
    return this.hasAddress() && this.address instanceof UrlType;
  }

  /**
   * @returns the \`address\` property value as a StringType object if defined; else undefined
   */
  public getAddressStringType(): StringType | undefined {
    if (!isDefined<DataType | undefined>(this.address)) {
      return undefined;
    }
    if (!(this.address instanceof StringType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for VirtualServiceDetail.address[x]: Expected StringType but encountered \${this.address.fhirType()}\`,
      );
    }
    return this.address;
  }

  /**
   * @returns \`true\` if the \`address\` property exists as a StringType and has a value; \`false\` otherwise
   */
  public hasAddressStringType(): boolean {
    return this.hasAddress() && this.address instanceof StringType;
  }

  /**
   * @returns the \`address\` property value as a ContactPoint object if defined; else undefined
   */
  public getAddressContactPoint(): ContactPoint | undefined {
    if (!isDefined<DataType | undefined>(this.address)) {
      return undefined;
    }
    if (!(this.address instanceof ContactPoint)) {
      throw new InvalidTypeError(
        \`DataType mismatch for VirtualServiceDetail.address[x]: Expected ContactPoint but encountered \${this.address.fhirType()}\`,
      );
    }
    return this.address;
  }

  /**
   * @returns \`true\` if the \`address\` property exists as a ContactPoint and has a value; \`false\` otherwise
   */
  public hasAddressContactPoint(): boolean {
    return this.hasAddress() && this.address instanceof ContactPoint;
  }

  /**
   * @returns the \`address\` property value as a ExtendedContactDetail object if defined; else undefined
   */
  public getAddressExtendedContactDetail(): ExtendedContactDetail | undefined {
    if (!isDefined<DataType | undefined>(this.address)) {
      return undefined;
    }
    if (!(this.address instanceof ExtendedContactDetail)) {
      throw new InvalidTypeError(
        \`DataType mismatch for VirtualServiceDetail.address[x]: Expected ExtendedContactDetail but encountered \${this.address.fhirType()}\`,
      );
    }
    return this.address;
  }

  /**
   * @returns \`true\` if the \`address\` property exists as a ExtendedContactDetail and has a value; \`false\` otherwise
   */
  public hasAddressExtendedContactDetail(): boolean {
    return this.hasAddress() && this.address instanceof ExtendedContactDetail;
  }

  /**
   * @returns the \`additionalInfo\` property value as a UrlType array
   */
  public getAdditionalInfoElement(): UrlType[] {
    return this.additionalInfo ?? ([] as UrlType[]);
  }

  /**
   * Assigns the provided UrlType array value to the \`additionalInfo\` property.
   *
   * @param element - the \`additionalInfo\` array value
   * @returns this
   */
  public setAdditionalInfoElement(element: UrlType[] | undefined): this {
    if (isDefinedList<UrlType>(element)) {
      const optErrMsg = \`Invalid VirtualServiceDetail.additionalInfo; Provided value array has an element that is not an instance of UrlType.\`;
      assertFhirTypeList<UrlType>(element, UrlType, optErrMsg);
      this.additionalInfo = element;
    } else {
      this.additionalInfo = undefined;
    }
    return this;
  }

  /**
   * Add the provided UrlType value to the \`additionalInfo\` array property.
   *
   * @param element - the \`additionalInfo\` value
   * @returns this
   */
  public addAdditionalInfoElement(element: UrlType | undefined): this {
    if (isDefined<UrlType>(element)) {
      const optErrMsg = \`Invalid VirtualServiceDetail.additionalInfo; Provided element is not an instance of UrlType.\`;
      assertFhirType<UrlType>(element, UrlType, optErrMsg);
      this.initAdditionalInfo();
      this.additionalInfo?.push(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`additionalInfo\` property exists and has a value; \`false\` otherwise
   */
  public hasAdditionalInfoElement(): boolean {
    return isDefinedList<UrlType>(this.additionalInfo) && this.additionalInfo.some((item: UrlType) => !item.isEmpty());
  }

  /**
   * @returns the \`additionalInfo\` property value as a fhirUrl array
   */
  public getAdditionalInfo(): fhirUrl[] {
    this.initAdditionalInfo();
    const additionalInfoValues = [] as fhirUrl[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.additionalInfo!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        additionalInfoValues.push(value);
      }
    }
    return additionalInfoValues;
  }

  /**
   * Assigns the provided primitive value array to the \`additionalInfo\` property.
   *
   * @param value - the \`additionalInfo\` value array
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setAdditionalInfo(value: fhirUrl[] | undefined): this {
    if (isDefinedList<fhirUrl>(value)) {
      const additionalInfoElements = [] as UrlType[];
      for (const additionalInfoValue of value) {
        const optErrMsg = \`Invalid VirtualServiceDetail.additionalInfo array item (\${String(additionalInfoValue)})\`;
        const element = new UrlType(parseFhirPrimitiveData(additionalInfoValue, fhirUrlSchema, optErrMsg));
        additionalInfoElements.push(element);
      }
      this.additionalInfo = additionalInfoElements;
    } else {
      this.additionalInfo = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`additionalInfo\` array property.
   *
   * @param value - the \`additionalInfo\` value
   * @returns this
   */
  public addAdditionalInfo(value: fhirUrl | undefined): this {
    if (isDefined<fhirUrl>(value)) {
      const optErrMsg = \`Invalid VirtualServiceDetail.additionalInfo array item (\${String(value)})\`;
      const element = new UrlType(parseFhirPrimitiveData(value, fhirUrlSchema, optErrMsg));
      this.initAdditionalInfo();
      this.addAdditionalInfoElement(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`additionalInfo\` property exists and has a value; \`false\` otherwise
   */
  public hasAdditionalInfo(): boolean {
    return this.hasAdditionalInfoElement();
  }

  /**
   * Initialize the \`additionalInfo\` property
   */
  private initAdditionalInfo(): void {
    if (!this.hasAdditionalInfo()) {
      this.additionalInfo = [] as UrlType[];
    }
  }

  /**
   * @returns the \`maxParticipants\` property value as a PositiveIntType object if defined; else an empty PositiveIntType object
   */
  public getMaxParticipantsElement(): PositiveIntType {
    return this.maxParticipants ?? new PositiveIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`maxParticipants\` property.
   *
   * @param element - the \`maxParticipants\` value
   * @returns this
   */
  public setMaxParticipantsElement(element: PositiveIntType | undefined): this {
    if (isDefined<PositiveIntType>(element)) {
      const optErrMsg = \`Invalid VirtualServiceDetail.maxParticipants; Provided element is not an instance of PositiveIntType.\`;
      assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
      this.maxParticipants = element;
    } else {
      this.maxParticipants = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`maxParticipants\` property exists and has a value; \`false\` otherwise
   */
  public hasMaxParticipantsElement(): boolean {
    return isDefined<PositiveIntType>(this.maxParticipants) && !this.maxParticipants.isEmpty();
  }

  /**
   * @returns the \`maxParticipants\` property value as a fhirPositiveInt if defined; else undefined
   */
  public getMaxParticipants(): fhirPositiveInt | undefined {
    return this.maxParticipants?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`maxParticipants\` property.
   *
   * @param value - the \`maxParticipants\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setMaxParticipants(value: fhirPositiveInt | undefined): this {
    if (isDefined<fhirPositiveInt>(value)) {
      const optErrMsg = \`Invalid VirtualServiceDetail.maxParticipants (\${String(value)})\`;
      this.maxParticipants = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    } else {
      this.maxParticipants = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`maxParticipants\` property exists and has a value; \`false\` otherwise
   */
  public hasMaxParticipants(): boolean {
    return this.hasMaxParticipantsElement();
  }

  /**
   * @returns the \`sessionKey\` property value as a StringType object if defined; else an empty StringType object
   */
  public getSessionKeyElement(): StringType {
    return this.sessionKey ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`sessionKey\` property.
   *
   * @param element - the \`sessionKey\` value
   * @returns this
   */
  public setSessionKeyElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid VirtualServiceDetail.sessionKey; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.sessionKey = element;
    } else {
      this.sessionKey = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`sessionKey\` property exists and has a value; \`false\` otherwise
   */
  public hasSessionKeyElement(): boolean {
    return isDefined<StringType>(this.sessionKey) && !this.sessionKey.isEmpty();
  }

  /**
   * @returns the \`sessionKey\` property value as a fhirString if defined; else undefined
   */
  public getSessionKey(): fhirString | undefined {
    return this.sessionKey?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`sessionKey\` property.
   *
   * @param value - the \`sessionKey\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setSessionKey(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid VirtualServiceDetail.sessionKey (\${String(value)})\`;
      this.sessionKey = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.sessionKey = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`sessionKey\` property exists and has a value; \`false\` otherwise
   */
  public hasSessionKey(): boolean {
    return this.hasSessionKeyElement();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'VirtualServiceDetail';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.channelType,
      this.address,
      this.additionalInfo,
      this.maxParticipants,
      this.sessionKey,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): VirtualServiceDetail {
    const dest = new VirtualServiceDetail();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: VirtualServiceDetail): void {
    super.copyValues(dest);
    dest.channelType = this.channelType?.copy();
    dest.address = this.address?.copy();
    const additionalInfoList = copyListValues<UrlType>(this.additionalInfo);
    dest.additionalInfo = additionalInfoList.length === 0 ? undefined : additionalInfoList;
    dest.maxParticipants = this.maxParticipants?.copy();
    dest.sessionKey = this.sessionKey?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasChannelType()) {
      setFhirComplexJson(this.getChannelType(), 'channelType', jsonObj);
    }

    if (this.hasAddress()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getAddress()!, 'address', jsonObj);
    }

    if (this.hasAdditionalInfo()) {
      setFhirPrimitiveListJson(this.getAdditionalInfoElement(), 'additionalInfo', jsonObj);
    }

    if (this.hasMaxParticipantsElement()) {
      setFhirPrimitiveJson<fhirPositiveInt>(this.getMaxParticipantsElement(), 'maxParticipants', jsonObj);
    }

    if (this.hasSessionKeyElement()) {
      setFhirPrimitiveJson<fhirString>(this.getSessionKeyElement(), 'sessionKey', jsonObj);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "VirtualServiceDetail",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 68`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from by the FHIR Package Generator.
 * DO NOT make any modifications!
 * 
 * parsable-datatype-map.ts Module
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { DataType, ParsableDataType } from '@paq-ts-fhir/fhir-core';
import { Address } from './Address';
import { Age } from './Age';
import { Annotation } from './Annotation';
import { Attachment } from './Attachment';
import { Availability } from './Availability';
import { CodeableConcept } from './CodeableConcept';
import { CodeableReference } from './CodeableReference';
import { Coding } from './Coding';
import { ContactDetail } from './ContactDetail';
import { ContactPoint } from './ContactPoint';
import { Contributor } from './Contributor';
import { Count } from './Count';
import { DataRequirement } from './DataRequirement';
import { Distance } from './Distance';
import { Dosage } from './Dosage';
import { Duration } from './Duration';
import { Expression } from './Expression';
import { ExtendedContactDetail } from './ExtendedContactDetail';
import { HumanName } from './HumanName';
import { Identifier } from './Identifier';
import { MarketingStatus } from './MarketingStatus';
import { Meta } from './Meta';
import { MonetaryComponent } from './MonetaryComponent';
import { Money } from './Money';
import { Narrative } from './Narrative';
import { ParameterDefinition } from './ParameterDefinition';
import { Period } from './Period';
import { Population } from './Population';
import { ProdCharacteristic } from './ProdCharacteristic';
import { ProductShelfLife } from './ProductShelfLife';
import { Quantity } from './Quantity';
import { Range } from './Range';
import { Ratio } from './Ratio';
import { RatioRange } from './RatioRange';
import { Reference } from './Reference';
import { RelatedArtifact } from './RelatedArtifact';
import { RelativeTime } from './RelativeTime';
import { SampledData } from './SampledData';
import { Signature } from './Signature';
import { SubstanceAmount } from './SubstanceAmount';
import { Timing } from './Timing';
import { TriggerDefinition } from './TriggerDefinition';
import { UsageContext } from './UsageContext';
import { VirtualServiceDetail } from './VirtualServiceDetail';

/**
 * PARSABLE_DATATYPE_MAP
 *
 * @remarks
 * Map of all parsable DataTypes where the key is the name of the DataType and the value is its ParsableDataType<DataType> class.
 *
 * @category Utilities: FHIR Parsers
 */
export const PARSABLE_DATATYPE_MAP = new Map<string, ParsableDataType<DataType>>();
PARSABLE_DATATYPE_MAP.set('Address', Address);
PARSABLE_DATATYPE_MAP.set('Age', Age);
PARSABLE_DATATYPE_MAP.set('Annotation', Annotation);
PARSABLE_DATATYPE_MAP.set('Attachment', Attachment);
PARSABLE_DATATYPE_MAP.set('Availability', Availability);
PARSABLE_DATATYPE_MAP.set('CodeableConcept', CodeableConcept);
PARSABLE_DATATYPE_MAP.set('CodeableReference', CodeableReference);
PARSABLE_DATATYPE_MAP.set('Coding', Coding);
PARSABLE_DATATYPE_MAP.set('ContactDetail', ContactDetail);
PARSABLE_DATATYPE_MAP.set('ContactPoint', ContactPoint);
PARSABLE_DATATYPE_MAP.set('Contributor', Contributor);
PARSABLE_DATATYPE_MAP.set('Count', Count);
PARSABLE_DATATYPE_MAP.set('DataRequirement', DataRequirement);
PARSABLE_DATATYPE_MAP.set('Distance', Distance);
PARSABLE_DATATYPE_MAP.set('Dosage', Dosage);
PARSABLE_DATATYPE_MAP.set('Duration', Duration);
PARSABLE_DATATYPE_MAP.set('Expression', Expression);
PARSABLE_DATATYPE_MAP.set('ExtendedContactDetail', ExtendedContactDetail);
PARSABLE_DATATYPE_MAP.set('HumanName', HumanName);
PARSABLE_DATATYPE_MAP.set('Identifier', Identifier);
PARSABLE_DATATYPE_MAP.set('MarketingStatus', MarketingStatus);
PARSABLE_DATATYPE_MAP.set('Meta', Meta);
PARSABLE_DATATYPE_MAP.set('MonetaryComponent', MonetaryComponent);
PARSABLE_DATATYPE_MAP.set('Money', Money);
PARSABLE_DATATYPE_MAP.set('Narrative', Narrative);
PARSABLE_DATATYPE_MAP.set('ParameterDefinition', ParameterDefinition);
PARSABLE_DATATYPE_MAP.set('Period', Period);
PARSABLE_DATATYPE_MAP.set('Population', Population);
PARSABLE_DATATYPE_MAP.set('ProdCharacteristic', ProdCharacteristic);
PARSABLE_DATATYPE_MAP.set('ProductShelfLife', ProductShelfLife);
PARSABLE_DATATYPE_MAP.set('Quantity', Quantity);
PARSABLE_DATATYPE_MAP.set('Range', Range);
PARSABLE_DATATYPE_MAP.set('Ratio', Ratio);
PARSABLE_DATATYPE_MAP.set('RatioRange', RatioRange);
PARSABLE_DATATYPE_MAP.set('Reference', Reference);
PARSABLE_DATATYPE_MAP.set('RelatedArtifact', RelatedArtifact);
PARSABLE_DATATYPE_MAP.set('RelativeTime', RelativeTime);
PARSABLE_DATATYPE_MAP.set('SampledData', SampledData);
PARSABLE_DATATYPE_MAP.set('Signature', Signature);
PARSABLE_DATATYPE_MAP.set('SubstanceAmount', SubstanceAmount);
PARSABLE_DATATYPE_MAP.set('Timing', Timing);
PARSABLE_DATATYPE_MAP.set('TriggerDefinition', TriggerDefinition);
PARSABLE_DATATYPE_MAP.set('UsageContext', UsageContext);
PARSABLE_DATATYPE_MAP.set('VirtualServiceDetail', VirtualServiceDetail);
",
  "fileExtension": "ts",
  "filename": "parsable-datatype-map",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 69`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from by the FHIR Package Generator.
 * DO NOT make any modifications!
 * 
 * index.ts Module
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

export * from './Address';
export * from './Age';
export * from './Annotation';
export * from './Attachment';
export * from './Availability';
export * from './CodeableConcept';
export * from './CodeableReference';
export * from './Coding';
export * from './ContactDetail';
export * from './ContactPoint';
export * from './Contributor';
export * from './Count';
export * from './DataRequirement';
export * from './Distance';
export * from './Dosage';
export * from './Duration';
export * from './Expression';
export * from './ExtendedContactDetail';
export * from './HumanName';
export * from './Identifier';
export * from './MarketingStatus';
export * from './Meta';
export * from './MonetaryComponent';
export * from './Money';
export * from './Narrative';
export * from './ParameterDefinition';
export * from './Period';
export * from './Population';
export * from './ProdCharacteristic';
export * from './ProductShelfLife';
export * from './Quantity';
export * from './Range';
export * from './Ratio';
export * from './RatioRange';
export * from './Reference';
export * from './RelatedArtifact';
export * from './RelativeTime';
export * from './SampledData';
export * from './Signature';
export * from './SubstanceAmount';
export * from './Timing';
export * from './TriggerDefinition';
export * from './UsageContext';
export * from './VirtualServiceDetail';
export * from './parsable-datatype-map';
",
  "fileExtension": "ts",
  "filename": "index",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 70`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "Resource",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * Condition Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/Condition
 * StructureDefinition.name: Condition
 * StructureDefinition.description: A clinical condition, problem, diagnosis, or other event, situation, issue, or clinical concept that has risen to a level of concern.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  BackboneElement,
  ChoiceDataTypes,
  ChoiceDataTypesMeta,
  DataType,
  DateTimeType,
  FhirDataTypeParser,
  FhirError,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  InvalidTypeError,
  JSON,
  REQUIRED_PROPERTIES_DO_NOT_EXIST,
  REQUIRED_PROPERTIES_REQD_IN_JSON,
  StringType,
  assertFhirType,
  assertFhirTypeList,
  assertIsDefined,
  copyListValues,
  fhirDateTime,
  fhirDateTimeSchema,
  getPrimitiveTypeJson,
  isDefined,
  isDefinedList,
  isElementEmpty,
  isEmpty,
  parseDateTimeType,
  parseFhirPrimitiveData,
  setFhirBackboneElementListJson,
  setFhirComplexJson,
  setFhirComplexListJson,
  setFhirPrimitiveJson,
  setPolymorphicValueJson,
} from '@paq-ts-fhir/fhir-core';
import {
  Age,
  Annotation,
  CodeableConcept,
  DomainResource,
  FhirResourceParser,
  FhirResourceType,
  Identifier,
  PARSABLE_DATATYPE_MAP,
  Period,
  Range,
  Reference,
  ReferenceTargets,
} from '../index';

// eslint-disable-next-line @typescript-eslint/no-explicit-any -- Symbol.metadata polyfill secret sauce for decorator metadata
(Symbol.metadata as any) ??= Symbol('Symbol.metadata');

/**
 * Condition Class
 *
 * @remarks
 * A clinical condition, problem, diagnosis, or other event, situation, issue, or clinical concept that has risen to a level of concern.
 *
 * **FHIR Specification**
 * - **Short:** Detailed information about conditions, problems or diagnoses
 * - **Definition:** A clinical condition, problem, diagnosis, or other event, situation, issue, or clinical concept that has risen to a level of concern.
 * - **FHIR Version:** 4.0.1
 *
 * @category DataModel: Resource
 * @see [FHIR Condition](http://hl7.org/fhir/StructureDefinition/Condition)
 */
export class Condition extends DomainResource implements IBase {
  constructor(subject: Reference | null = null) {
    super();

    this.subject = null;
    if (isDefined<Reference>(subject)) {
      this.setSubject(subject);
    }
  }

  /**
   * Parse the provided \`Condition\` JSON to instantiate the Condition data model.
   *
   * @param sourceJson - JSON representing FHIR \`Condition\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Condition
   * @returns Condition data model or undefined for \`Condition\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Condition | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirResourceParser = new FhirResourceParser(PARSABLE_DATATYPE_MAP);
    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Condition';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Condition();
    fhirResourceParser.processDomainResourceJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    

    const classMetadata: DecoratorMetadataObject | null = Condition[Symbol.metadata];
    const errorMessage = \`DecoratorMetadataObject does not exist for Condition\`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    const missingReqdProperties: string[] = [];

    fieldName = 'identifier';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Identifier | undefined = fhirDataTypeParser.parser<Identifier>(Identifier, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addIdentifier(datatype);
        }
      });
    }

    fieldName = 'clinicalStatus';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = fhirDataTypeParser.parser<CodeableConcept>(CodeableConcept, classJsonObj[fieldName]!, sourceField);
      instance.setClinicalStatus(datatype);
    }

    fieldName = 'verificationStatus';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = fhirDataTypeParser.parser<CodeableConcept>(CodeableConcept, classJsonObj[fieldName]!, sourceField);
      instance.setVerificationStatus(datatype);
    }

    fieldName = 'category';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: CodeableConcept | undefined = fhirDataTypeParser.parser<CodeableConcept>(CodeableConcept, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addCategory(datatype);
        }
      });
    }

    fieldName = 'severity';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = fhirDataTypeParser.parser<CodeableConcept>(CodeableConcept, classJsonObj[fieldName]!, sourceField);
      instance.setSeverity(datatype);
    }

    fieldName = 'code';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = fhirDataTypeParser.parser<CodeableConcept>(CodeableConcept, classJsonObj[fieldName]!, sourceField);
      instance.setCode(datatype);
    }

    fieldName = 'bodySite';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: CodeableConcept | undefined = fhirDataTypeParser.parser<CodeableConcept>(CodeableConcept, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addBodySite(datatype);
        }
      });
    }

    fieldName = 'subject';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = fhirDataTypeParser.parser<Reference>(Reference, classJsonObj[fieldName]!, sourceField);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setSubject(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'encounter';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = fhirDataTypeParser.parser<Reference>(Reference, classJsonObj[fieldName]!, sourceField);
      instance.setEncounter(datatype);
    }

    fieldName = 'onset[x]';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const onset: DataType | undefined = fhirDataTypeParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setOnset(onset);

    fieldName = 'abatement[x]';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const abatement: DataType | undefined = fhirDataTypeParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setAbatement(abatement);

    fieldName = 'recordedDate';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DateTimeType | undefined = parseDateTimeType(dtJson, dtSiblingJson);
      instance.setRecordedDateElement(datatype);
    }

    fieldName = 'recorder';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = fhirDataTypeParser.parser<Reference>(Reference, classJsonObj[fieldName]!, sourceField);
      instance.setRecorder(datatype);
    }

    fieldName = 'asserter';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = fhirDataTypeParser.parser<Reference>(Reference, classJsonObj[fieldName]!, sourceField);
      instance.setAsserter(datatype);
    }

    fieldName = 'stage';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const componentJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      componentJsonArray.forEach((componentJson: JSON.Value, idx) => {
        const component: ConditionStageComponent | undefined = ConditionStageComponent.parse(componentJson, \`\${sourceField}[\${String(idx)}]\`);
        if (component !== undefined) {
          instance.addStage(component);
        }
      });
    }

    fieldName = 'evidence';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const componentJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      componentJsonArray.forEach((componentJson: JSON.Value, idx) => {
        const component: ConditionEvidenceComponent | undefined = ConditionEvidenceComponent.parse(componentJson, \`\${sourceField}[\${String(idx)}]\`);
        if (component !== undefined) {
          instance.addEvidence(component);
        }
      });
    }

    fieldName = 'note';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Annotation | undefined = fhirDataTypeParser.parser<Annotation>(Annotation, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addNote(datatype);
        }
      });
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Condition.identifier Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** External Ids for this condition
   * - **Definition:** Business identifiers assigned to this condition by the performer or other systems which remain constant as the resource is updated and propagates from server to server.
   * - **Comment:** This is a business identifier, not a resource identifier (see [discussion](https://hl7.org/fhir/resource.html#identifiers)).  It is best practice for the identifier to only appear on a single resource instance, however business practices may occasionally dictate that multiple resource instances with the same identifier can exist - possibly even with different resource types.  For example, multiple Patient and a Person resource instance might share the same social insurance number.
   * - **Requirements:** Allows identification of the condition as it is known by various participating systems and in a way that remains consistent across servers.
   * - **FHIR Type:** \`Identifier\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private identifier?: Identifier[] | undefined;

  /**
   * Condition.clinicalStatus Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** active | recurrence | relapse | inactive | remission | resolved
   * - **Definition:** The clinical status of the condition.
   * - **Comment:** The data type is CodeableConcept because clinicalStatus has some clinical judgment involved, such that there might need to be more specificity than the required FHIR value set allows. For example, a SNOMED coding might allow for additional specificity.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..1
   * - **isModifier:** true
   * - **isModifierReason:** This element is labeled as a modifier because the status contains codes that mark the condition as no longer active.
   * - **isSummary:** true
   */
  private clinicalStatus?: CodeableConcept | undefined;

  /**
   * Condition.verificationStatus Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** unconfirmed | provisional | differential | confirmed | refuted | entered-in-error
   * - **Definition:** The verification status to support the clinical status of the condition.
   * - **Comment:** verificationStatus is not required.  For example, when a patient has abdominal pain in the ED, there is not likely going to be a verification status. The data type is CodeableConcept because verificationStatus has some clinical judgment involved, such that there might need to be more specificity than the required FHIR value set allows. For example, a SNOMED coding might allow for additional specificity.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..1
   * - **isModifier:** true
   * - **isModifierReason:** This element is labeled as a modifier because the status contains the code refuted and entered-in-error that mark the Condition as not currently valid.
   * - **isSummary:** true
   */
  private verificationStatus?: CodeableConcept | undefined;

  /**
   * Condition.category Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** problem-list-item | encounter-diagnosis
   * - **Definition:** A category assigned to the condition.
   * - **Comment:** The categorization is often highly contextual and may appear poorly differentiated or not very useful in other contexts.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private category?: CodeableConcept[] | undefined;

  /**
   * Condition.severity Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Subjective severity of condition
   * - **Definition:** A subjective assessment of the severity of the condition as evaluated by the clinician.
   * - **Comment:** Coding of the severity with a terminology is preferred, where possible.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private severity?: CodeableConcept | undefined;

  /**
   * Condition.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Identification of the condition, problem or diagnosis
   * - **Definition:** Identification of the condition, problem or diagnosis.
   * - **Requirements:** 0..1 to account for primarily narrative only resources.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code?: CodeableConcept | undefined;

  /**
   * Condition.bodySite Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Anatomical location, if relevant
   * - **Definition:** The anatomical location where this condition manifests itself.
   * - **Comment:** Only used if not implicit in code found in Condition.code. If the use case requires attributes from the BodySite resource (e.g. to identify and track separately) then use the standard extension [bodySite](https://hl7.org/fhir/extension-bodysite.html).  May be a summary code, or a reference to a very precise definition of the location, or both.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private bodySite?: CodeableConcept[] | undefined;

  /**
   * Condition.subject Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Who has the condition?
   * - **Definition:** Indicates the patient or group who the condition record is associated with.
   * - **Requirements:** Group is typically used for veterinary or public health use cases.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Patient',
   *       'http://hl7.org/fhir/StructureDefinition/Group',
   *     ]
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private subject: Reference | null;

  /**
   * Condition.encounter Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Encounter created as part of
   * - **Definition:** The Encounter during which this Condition was created or to which the creation of this record is tightly associated.
   * - **Comment:** This will typically be the encounter the event occurred within, but some activities may be initiated prior to or after the official completion of an encounter but still be tied to the context of the encounter. This record indicates the encounter this particular record is associated with.  In the case of a "new" diagnosis reflecting ongoing/revised information about the condition, this might be distinct from the first encounter in which the underlying condition was first "known".
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Encounter',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private encounter?: Reference | undefined;

  /**
   * Condition.onset[x] Element
   *
   * @decorator \`@ChoiceDataTypesMeta('Condition.onset[x]', ['dateTime','Age','Period','Range','string',]\`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Estimated or actual date,  date-time, or age
   * - **Definition:** Estimated or actual date or date-time  the condition began, in the opinion of the clinician.
   * - **Comment:** Age is generally used when the patient reports an age at which the Condition began to occur.
   * - **FHIR Types:**
   *     'dateTime',
   *     'Age',
   *     'Period',
   *     'Range',
   *     'string',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('Condition.onset[x]',[
    'dateTime',
    'Age',
    'Period',
    'Range',
    'string',
  ])
  private onset?: DataType | undefined;

  /**
   * Condition.abatement[x] Element
   *
   * @decorator \`@ChoiceDataTypesMeta('Condition.abatement[x]', ['dateTime','Age','Period','Range','string',]\`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** When in resolution/remission
   * - **Definition:** The date or estimated date that the condition resolved or went into remission. This is called "abatement" because of the many overloaded connotations associated with "remission" or "resolution" - Conditions are never really resolved, but they can abate.
   * - **Comment:** There is no explicit distinction between resolution and remission because in many cases the distinction is not clear. Age is generally used when the patient reports an age at which the Condition abated.  If there is no abatement element, it is unknown whether the condition has resolved or entered remission; applications and users should generally assume that the condition is still valid.  When abatementString exists, it implies the condition is abated.
   * - **FHIR Types:**
   *     'dateTime',
   *     'Age',
   *     'Period',
   *     'Range',
   *     'string',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  @ChoiceDataTypesMeta('Condition.abatement[x]',[
    'dateTime',
    'Age',
    'Period',
    'Range',
    'string',
  ])
  private abatement?: DataType | undefined;

  /**
   * Condition.recordedDate Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Date record was first recorded
   * - **Definition:** The recordedDate represents when this particular Condition record was created in the system, which is often a system-generated date.
   * - **FHIR Type:** \`dateTime\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private recordedDate?: DateTimeType | undefined;

  /**
   * Condition.recorder Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Who recorded the condition
   * - **Definition:** Individual who recorded the record and takes responsibility for its content.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Practitioner',
   *       'http://hl7.org/fhir/StructureDefinition/PractitionerRole',
   *       'http://hl7.org/fhir/StructureDefinition/Patient',
   *       'http://hl7.org/fhir/StructureDefinition/RelatedPerson',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private recorder?: Reference | undefined;

  /**
   * Condition.asserter Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Person who asserts this condition
   * - **Definition:** Individual who is making the condition statement.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Practitioner',
   *       'http://hl7.org/fhir/StructureDefinition/PractitionerRole',
   *       'http://hl7.org/fhir/StructureDefinition/Patient',
   *       'http://hl7.org/fhir/StructureDefinition/RelatedPerson',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private asserter?: Reference | undefined;

  /**
   * Condition.stage Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Stage/grade, usually assessed formally
   * - **Definition:** Clinical stage or grade of a condition. May include formal severity assessments.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private stage?: ConditionStageComponent[] | undefined;

  /**
   * Condition.evidence Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Supporting evidence
   * - **Definition:** Supporting evidence / manifestations that are the basis of the Condition\\'s verification status, such as evidence that confirmed or refuted the condition.
   * - **Comment:** The evidence may be a simple list of coded symptoms/manifestations, or references to observations or formal assessments, or both.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private evidence?: ConditionEvidenceComponent[] | undefined;

  /**
   * Condition.note Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Additional information about the Condition
   * - **Definition:** Additional information about the Condition. This is a general notes/comments entry  for description of the Condition, its diagnosis and prognosis.
   * - **FHIR Type:** \`Annotation\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private note?: Annotation[] | undefined;


  /**
   * @returns the FHIR resource type as defined by the FHIR specification
   */
  public override resourceType(): FhirResourceType {
    return this.fhirType() as FhirResourceType;
  }

  /**
   * @returns the \`identifier\` property value as a Identifier array
   */
  public getIdentifier(): Identifier[] {
    return this.identifier ?? ([] as Identifier[]);
  }

  /**
   * Assigns the provided Identifier array value to the \`identifier\` property.
   *
   * @param value - the \`identifier\` array value
   * @returns this
   */
  public setIdentifier(value: Identifier[] | undefined): this {
    if (isDefinedList<Identifier>(value)) {
      const optErrMsg = \`Invalid Condition.identifier; Provided value array has an element that is not an instance of Identifier.\`;
      assertFhirTypeList<Identifier>(value, Identifier, optErrMsg);
      this.identifier = value;
    } else {
      this.identifier = undefined;
    }
    return this;
  }

  /**
   * Add the provided Identifier value to the \`identifier\` array property.
   *
   * @param value - the \`identifier\` value
   * @returns this
   */
  public addIdentifier(value: Identifier | undefined): this {
    if (isDefined<Identifier>(value)) {
      const optErrMsg = \`Invalid Condition.identifier; Provided element is not an instance of Identifier.\`;
      assertFhirType<Identifier>(value, Identifier, optErrMsg);
      this.initIdentifier();
      this.identifier?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`identifier\` property exists and has a value; \`false\` otherwise
   */
  public hasIdentifier(): boolean {
    return isDefinedList<Identifier>(this.identifier) && this.identifier.some((item: Identifier) => !item.isEmpty());
  }

  /**
   * Initialize the \`identifier\` property
   */
  private initIdentifier(): void {
    if(!this.hasIdentifier()) {
      this.identifier = [] as Identifier[];
    }
  }

  /**
   * @returns the \`clinicalStatus\` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getClinicalStatus(): CodeableConcept {
    return this.clinicalStatus ?? new CodeableConcept();
  }

  /**
   * Assigns the provided ClinicalStatus object value to the \`clinicalStatus\` property.
   *
   * @param value - the \`clinicalStatus\` object value
   * @returns this
   */
  public setClinicalStatus(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Condition.clinicalStatus; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.clinicalStatus = value;
    } else {
      this.clinicalStatus = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`clinicalStatus\` property exists and has a value; \`false\` otherwise
   */
  public hasClinicalStatus(): boolean {
    return isDefined<CodeableConcept>(this.clinicalStatus) && !this.clinicalStatus.isEmpty();
  }

  /**
   * @returns the \`verificationStatus\` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getVerificationStatus(): CodeableConcept {
    return this.verificationStatus ?? new CodeableConcept();
  }

  /**
   * Assigns the provided VerificationStatus object value to the \`verificationStatus\` property.
   *
   * @param value - the \`verificationStatus\` object value
   * @returns this
   */
  public setVerificationStatus(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Condition.verificationStatus; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.verificationStatus = value;
    } else {
      this.verificationStatus = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`verificationStatus\` property exists and has a value; \`false\` otherwise
   */
  public hasVerificationStatus(): boolean {
    return isDefined<CodeableConcept>(this.verificationStatus) && !this.verificationStatus.isEmpty();
  }

  /**
   * @returns the \`category\` property value as a CodeableConcept array
   */
  public getCategory(): CodeableConcept[] {
    return this.category ?? ([] as CodeableConcept[]);
  }

  /**
   * Assigns the provided CodeableConcept array value to the \`category\` property.
   *
   * @param value - the \`category\` array value
   * @returns this
   */
  public setCategory(value: CodeableConcept[] | undefined): this {
    if (isDefinedList<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Condition.category; Provided value array has an element that is not an instance of CodeableConcept.\`;
      assertFhirTypeList<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.category = value;
    } else {
      this.category = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeableConcept value to the \`category\` array property.
   *
   * @param value - the \`category\` value
   * @returns this
   */
  public addCategory(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Condition.category; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.initCategory();
      this.category?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`category\` property exists and has a value; \`false\` otherwise
   */
  public hasCategory(): boolean {
    return isDefinedList<CodeableConcept>(this.category) && this.category.some((item: CodeableConcept) => !item.isEmpty());
  }

  /**
   * Initialize the \`category\` property
   */
  private initCategory(): void {
    if(!this.hasCategory()) {
      this.category = [] as CodeableConcept[];
    }
  }

  /**
   * @returns the \`severity\` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getSeverity(): CodeableConcept {
    return this.severity ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Severity object value to the \`severity\` property.
   *
   * @param value - the \`severity\` object value
   * @returns this
   */
  public setSeverity(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Condition.severity; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.severity = value;
    } else {
      this.severity = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`severity\` property exists and has a value; \`false\` otherwise
   */
  public hasSeverity(): boolean {
    return isDefined<CodeableConcept>(this.severity) && !this.severity.isEmpty();
  }

  /**
   * @returns the \`code\` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getCode(): CodeableConcept {
    return this.code ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Code object value to the \`code\` property.
   *
   * @param value - the \`code\` object value
   * @returns this
   */
  public setCode(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Condition.code; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.code = value;
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`code\` property exists and has a value; \`false\` otherwise
   */
  public hasCode(): boolean {
    return isDefined<CodeableConcept>(this.code) && !this.code.isEmpty();
  }

  /**
   * @returns the \`bodySite\` property value as a CodeableConcept array
   */
  public getBodySite(): CodeableConcept[] {
    return this.bodySite ?? ([] as CodeableConcept[]);
  }

  /**
   * Assigns the provided CodeableConcept array value to the \`bodySite\` property.
   *
   * @param value - the \`bodySite\` array value
   * @returns this
   */
  public setBodySite(value: CodeableConcept[] | undefined): this {
    if (isDefinedList<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Condition.bodySite; Provided value array has an element that is not an instance of CodeableConcept.\`;
      assertFhirTypeList<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.bodySite = value;
    } else {
      this.bodySite = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeableConcept value to the \`bodySite\` array property.
   *
   * @param value - the \`bodySite\` value
   * @returns this
   */
  public addBodySite(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Condition.bodySite; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.initBodySite();
      this.bodySite?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`bodySite\` property exists and has a value; \`false\` otherwise
   */
  public hasBodySite(): boolean {
    return isDefinedList<CodeableConcept>(this.bodySite) && this.bodySite.some((item: CodeableConcept) => !item.isEmpty());
  }

  /**
   * Initialize the \`bodySite\` property
   */
  private initBodySite(): void {
    if(!this.hasBodySite()) {
      this.bodySite = [] as CodeableConcept[];
    }
  }

  /**
   * @returns the \`subject\` property value as a Reference object if defined; else null
   */
  public getSubject(): Reference | null {
    return this.subject;
  }

  /**
   * Assigns the provided Subject object value to the \`subject\` property.
   *
   * @decorator \`@ReferenceTargets('Condition.subject', ['Patient','Group',])\`
   *
   * @param value - the \`subject\` object value
   * @returns this
   */
  @ReferenceTargets('Condition.subject', [
    'Patient',
  
    'Group',
  ])
  public setSubject(value: Reference): this {
    assertIsDefined<Reference>(value, \`Condition.subject is required\`);
    // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
    this.subject = value;
    return this;
  }

  /**
   * @returns \`true\` if the \`subject\` property exists and has a value; \`false\` otherwise
   */
  public hasSubject(): boolean {
    return isDefined<Reference>(this.subject) && !this.subject.isEmpty();
  }

  /**
   * @returns the \`encounter\` property value as a Reference object; else an empty Reference object
   */
  public getEncounter(): Reference {
    return this.encounter ?? new Reference();
  }

  /**
   * Assigns the provided Encounter object value to the \`encounter\` property.
   *
   * @decorator \`@ReferenceTargets('Condition.encounter', ['Encounter',])\`
   *
   * @param value - the \`encounter\` object value
   * @returns this
   */
  @ReferenceTargets('Condition.encounter', [
    'Encounter',
  ])
  public setEncounter(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.encounter = value;
    } else {
      this.encounter = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`encounter\` property exists and has a value; \`false\` otherwise
   */
  public hasEncounter(): boolean {
    return isDefined<Reference>(this.encounter) && !this.encounter.isEmpty();
  }

  /**
   * @returns the \`onset\` property value as a DataType object if defined; else undefined
   */
  public getOnset(): DataType | undefined {
    return this.onset;
  }

  /**
   * Assigns the provided DataType object value to the \`onset\` property.
   *
   * @decorator \`@ChoiceDataTypes('Condition.onset[x]')\`
   *
   * @param value - the \`onset\` object value
   * @returns this
   */
  @ChoiceDataTypes('Condition.onset[x]')
  public setOnset(value: DataType | undefined): this {
    if (isDefined<DataType>(value)) {
      // assertFhirType<DataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.onset = value;
    } else {
      this.onset = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`onset\` property exists and has a value; \`false\` otherwise
   */
  public hasOnset(): boolean {
    return isDefined<DataType>(this.onset) && !this.onset.isEmpty();
  }

  // *** NOTE ***
  // Next "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the \`onset\` property value as a DateTimeType object if defined; else undefined
   */
  public getOnsetDateTimeType(): DateTimeType | undefined {
    if (!isDefined<DataType | undefined>(this.onset)) {
      return undefined;
    }
    if (!(this.onset instanceof DateTimeType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Condition.onset[x]: Expected DateTimeType but encountered \${this.onset.fhirType()}\`,
      );
    }
    return this.onset;
  }

  /**
   * @returns \`true\` if the \`onset\` property exists as a DateTimeType and has a value; \`false\` otherwise
   */
  public hasOnsetDateTimeType(): boolean {
    return this.hasOnset() && this.onset instanceof DateTimeType;
  }

  /**
   * @returns the \`onset\` property value as a Age object if defined; else undefined
   */
  public getOnsetAge(): Age | undefined {
    if (!isDefined<DataType | undefined>(this.onset)) {
      return undefined;
    }
    if (!(this.onset instanceof Age)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Condition.onset[x]: Expected Age but encountered \${this.onset.fhirType()}\`,
      );
    }
    return this.onset;
  }

  /**
   * @returns \`true\` if the \`onset\` property exists as a Age and has a value; \`false\` otherwise
   */
  public hasOnsetAge(): boolean {
    return this.hasOnset() && this.onset instanceof Age;
  }

  /**
   * @returns the \`onset\` property value as a Period object if defined; else undefined
   */
  public getOnsetPeriod(): Period | undefined {
    if (!isDefined<DataType | undefined>(this.onset)) {
      return undefined;
    }
    if (!(this.onset instanceof Period)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Condition.onset[x]: Expected Period but encountered \${this.onset.fhirType()}\`,
      );
    }
    return this.onset;
  }

  /**
   * @returns \`true\` if the \`onset\` property exists as a Period and has a value; \`false\` otherwise
   */
  public hasOnsetPeriod(): boolean {
    return this.hasOnset() && this.onset instanceof Period;
  }

  /**
   * @returns the \`onset\` property value as a Range object if defined; else undefined
   */
  public getOnsetRange(): Range | undefined {
    if (!isDefined<DataType | undefined>(this.onset)) {
      return undefined;
    }
    if (!(this.onset instanceof Range)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Condition.onset[x]: Expected Range but encountered \${this.onset.fhirType()}\`,
      );
    }
    return this.onset;
  }

  /**
   * @returns \`true\` if the \`onset\` property exists as a Range and has a value; \`false\` otherwise
   */
  public hasOnsetRange(): boolean {
    return this.hasOnset() && this.onset instanceof Range;
  }

  /**
   * @returns the \`onset\` property value as a StringType object if defined; else undefined
   */
  public getOnsetStringType(): StringType | undefined {
    if (!isDefined<DataType | undefined>(this.onset)) {
      return undefined;
    }
    if (!(this.onset instanceof StringType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Condition.onset[x]: Expected StringType but encountered \${this.onset.fhirType()}\`,
      );
    }
    return this.onset;
  }

  /**
   * @returns \`true\` if the \`onset\` property exists as a StringType and has a value; \`false\` otherwise
   */
  public hasOnsetStringType(): boolean {
    return this.hasOnset() && this.onset instanceof StringType;
  }

  /**
   * @returns the \`abatement\` property value as a DataType object if defined; else undefined
   */
  public getAbatement(): DataType | undefined {
    return this.abatement;
  }

  /**
   * Assigns the provided DataType object value to the \`abatement\` property.
   *
   * @decorator \`@ChoiceDataTypes('Condition.abatement[x]')\`
   *
   * @param value - the \`abatement\` object value
   * @returns this
   */
  @ChoiceDataTypes('Condition.abatement[x]')
  public setAbatement(value: DataType | undefined): this {
    if (isDefined<DataType>(value)) {
      // assertFhirType<DataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.abatement = value;
    } else {
      this.abatement = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`abatement\` property exists and has a value; \`false\` otherwise
   */
  public hasAbatement(): boolean {
    return isDefined<DataType>(this.abatement) && !this.abatement.isEmpty();
  }

  // *** NOTE ***
  // Next "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the \`abatement\` property value as a DateTimeType object if defined; else undefined
   */
  public getAbatementDateTimeType(): DateTimeType | undefined {
    if (!isDefined<DataType | undefined>(this.abatement)) {
      return undefined;
    }
    if (!(this.abatement instanceof DateTimeType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Condition.abatement[x]: Expected DateTimeType but encountered \${this.abatement.fhirType()}\`,
      );
    }
    return this.abatement;
  }

  /**
   * @returns \`true\` if the \`abatement\` property exists as a DateTimeType and has a value; \`false\` otherwise
   */
  public hasAbatementDateTimeType(): boolean {
    return this.hasAbatement() && this.abatement instanceof DateTimeType;
  }

  /**
   * @returns the \`abatement\` property value as a Age object if defined; else undefined
   */
  public getAbatementAge(): Age | undefined {
    if (!isDefined<DataType | undefined>(this.abatement)) {
      return undefined;
    }
    if (!(this.abatement instanceof Age)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Condition.abatement[x]: Expected Age but encountered \${this.abatement.fhirType()}\`,
      );
    }
    return this.abatement;
  }

  /**
   * @returns \`true\` if the \`abatement\` property exists as a Age and has a value; \`false\` otherwise
   */
  public hasAbatementAge(): boolean {
    return this.hasAbatement() && this.abatement instanceof Age;
  }

  /**
   * @returns the \`abatement\` property value as a Period object if defined; else undefined
   */
  public getAbatementPeriod(): Period | undefined {
    if (!isDefined<DataType | undefined>(this.abatement)) {
      return undefined;
    }
    if (!(this.abatement instanceof Period)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Condition.abatement[x]: Expected Period but encountered \${this.abatement.fhirType()}\`,
      );
    }
    return this.abatement;
  }

  /**
   * @returns \`true\` if the \`abatement\` property exists as a Period and has a value; \`false\` otherwise
   */
  public hasAbatementPeriod(): boolean {
    return this.hasAbatement() && this.abatement instanceof Period;
  }

  /**
   * @returns the \`abatement\` property value as a Range object if defined; else undefined
   */
  public getAbatementRange(): Range | undefined {
    if (!isDefined<DataType | undefined>(this.abatement)) {
      return undefined;
    }
    if (!(this.abatement instanceof Range)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Condition.abatement[x]: Expected Range but encountered \${this.abatement.fhirType()}\`,
      );
    }
    return this.abatement;
  }

  /**
   * @returns \`true\` if the \`abatement\` property exists as a Range and has a value; \`false\` otherwise
   */
  public hasAbatementRange(): boolean {
    return this.hasAbatement() && this.abatement instanceof Range;
  }

  /**
   * @returns the \`abatement\` property value as a StringType object if defined; else undefined
   */
  public getAbatementStringType(): StringType | undefined {
    if (!isDefined<DataType | undefined>(this.abatement)) {
      return undefined;
    }
    if (!(this.abatement instanceof StringType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Condition.abatement[x]: Expected StringType but encountered \${this.abatement.fhirType()}\`,
      );
    }
    return this.abatement;
  }

  /**
   * @returns \`true\` if the \`abatement\` property exists as a StringType and has a value; \`false\` otherwise
   */
  public hasAbatementStringType(): boolean {
    return this.hasAbatement() && this.abatement instanceof StringType;
  }

  /**
   * @returns the \`recordedDate\` property value as a DateTimeType object if defined; else an empty DateTimeType object
   */
  public getRecordedDateElement(): DateTimeType {
    return this.recordedDate ?? new DateTimeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`recordedDate\` property.
   *
   * @param element - the \`recordedDate\` value
   * @returns this
   */
  public setRecordedDateElement(element: DateTimeType | undefined): this {
    if (isDefined<DateTimeType>(element)) {
      const optErrMsg = \`Invalid Condition.recordedDate; Provided element is not an instance of DateTimeType.\`;
      assertFhirType<DateTimeType>(element, DateTimeType, optErrMsg);
      this.recordedDate = element;
    } else {
      this.recordedDate = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`recordedDate\` property exists and has a value; \`false\` otherwise
   */
  public hasRecordedDateElement(): boolean {
    return isDefined<DateTimeType>(this.recordedDate) && !this.recordedDate.isEmpty();
  }

  /**
   * @returns the \`recordedDate\` property value as a fhirDateTime if defined; else undefined
   */
  public getRecordedDate(): fhirDateTime | undefined {
    return this.recordedDate?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`recordedDate\` property.
   *
   * @param value - the \`recordedDate\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setRecordedDate(value: fhirDateTime | undefined): this {
    if (isDefined<fhirDateTime>(value)) {
      const optErrMsg = \`Invalid Condition.recordedDate (\${String(value)})\`;
      this.recordedDate = new DateTimeType(parseFhirPrimitiveData(value, fhirDateTimeSchema, optErrMsg));
    } else {
      this.recordedDate = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`recordedDate\` property exists and has a value; \`false\` otherwise
   */
  public hasRecordedDate(): boolean {
    return this.hasRecordedDateElement();
  }

  /**
   * @returns the \`recorder\` property value as a Reference object; else an empty Reference object
   */
  public getRecorder(): Reference {
    return this.recorder ?? new Reference();
  }

  /**
   * Assigns the provided Recorder object value to the \`recorder\` property.
   *
   * @decorator \`@ReferenceTargets('Condition.recorder', ['Practitioner','PractitionerRole','Patient','RelatedPerson',])\`
   *
   * @param value - the \`recorder\` object value
   * @returns this
   */
  @ReferenceTargets('Condition.recorder', [
    'Practitioner',
  
    'PractitionerRole',
  
    'Patient',
  
    'RelatedPerson',
  ])
  public setRecorder(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.recorder = value;
    } else {
      this.recorder = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`recorder\` property exists and has a value; \`false\` otherwise
   */
  public hasRecorder(): boolean {
    return isDefined<Reference>(this.recorder) && !this.recorder.isEmpty();
  }

  /**
   * @returns the \`asserter\` property value as a Reference object; else an empty Reference object
   */
  public getAsserter(): Reference {
    return this.asserter ?? new Reference();
  }

  /**
   * Assigns the provided Asserter object value to the \`asserter\` property.
   *
   * @decorator \`@ReferenceTargets('Condition.asserter', ['Practitioner','PractitionerRole','Patient','RelatedPerson',])\`
   *
   * @param value - the \`asserter\` object value
   * @returns this
   */
  @ReferenceTargets('Condition.asserter', [
    'Practitioner',
  
    'PractitionerRole',
  
    'Patient',
  
    'RelatedPerson',
  ])
  public setAsserter(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.asserter = value;
    } else {
      this.asserter = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`asserter\` property exists and has a value; \`false\` otherwise
   */
  public hasAsserter(): boolean {
    return isDefined<Reference>(this.asserter) && !this.asserter.isEmpty();
  }

  /**
   * @returns the \`stage\` property value as a ConditionStageComponent array
   */
  public getStage(): ConditionStageComponent[] {
    return this.stage ?? ([] as ConditionStageComponent[]);
  }

  /**
   * Assigns the provided ConditionStageComponent array value to the \`stage\` property.
   *
   * @param value - the \`stage\` array value
   * @returns this
   */
  public setStage(value: ConditionStageComponent[] | undefined): this {
    if (isDefinedList<ConditionStageComponent>(value)) {
      const optErrMsg = \`Invalid Condition.stage; Provided value array has an element that is not an instance of ConditionStageComponent.\`;
      assertFhirTypeList<ConditionStageComponent>(value, ConditionStageComponent, optErrMsg);
      this.stage = value;
    } else {
      this.stage = undefined;
    }
    return this;
  }

  /**
   * Add the provided ConditionStageComponent value to the \`stage\` array property.
   *
   * @param value - the \`stage\` value
   * @returns this
   */
  public addStage(value: ConditionStageComponent | undefined): this {
    if (isDefined<ConditionStageComponent>(value)) {
      const optErrMsg = \`Invalid Condition.stage; Provided element is not an instance of ConditionStageComponent.\`;
      assertFhirType<ConditionStageComponent>(value, ConditionStageComponent, optErrMsg);
      this.initStage();
      this.stage?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`stage\` property exists and has a value; \`false\` otherwise
   */
  public hasStage(): boolean {
    return isDefinedList<ConditionStageComponent>(this.stage) && this.stage.some((item: ConditionStageComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`stage\` property
   */
  private initStage(): void {
    if(!this.hasStage()) {
      this.stage = [] as ConditionStageComponent[];
    }
  }

  /**
   * @returns the \`evidence\` property value as a ConditionEvidenceComponent array
   */
  public getEvidence(): ConditionEvidenceComponent[] {
    return this.evidence ?? ([] as ConditionEvidenceComponent[]);
  }

  /**
   * Assigns the provided ConditionEvidenceComponent array value to the \`evidence\` property.
   *
   * @param value - the \`evidence\` array value
   * @returns this
   */
  public setEvidence(value: ConditionEvidenceComponent[] | undefined): this {
    if (isDefinedList<ConditionEvidenceComponent>(value)) {
      const optErrMsg = \`Invalid Condition.evidence; Provided value array has an element that is not an instance of ConditionEvidenceComponent.\`;
      assertFhirTypeList<ConditionEvidenceComponent>(value, ConditionEvidenceComponent, optErrMsg);
      this.evidence = value;
    } else {
      this.evidence = undefined;
    }
    return this;
  }

  /**
   * Add the provided ConditionEvidenceComponent value to the \`evidence\` array property.
   *
   * @param value - the \`evidence\` value
   * @returns this
   */
  public addEvidence(value: ConditionEvidenceComponent | undefined): this {
    if (isDefined<ConditionEvidenceComponent>(value)) {
      const optErrMsg = \`Invalid Condition.evidence; Provided element is not an instance of ConditionEvidenceComponent.\`;
      assertFhirType<ConditionEvidenceComponent>(value, ConditionEvidenceComponent, optErrMsg);
      this.initEvidence();
      this.evidence?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`evidence\` property exists and has a value; \`false\` otherwise
   */
  public hasEvidence(): boolean {
    return isDefinedList<ConditionEvidenceComponent>(this.evidence) && this.evidence.some((item: ConditionEvidenceComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`evidence\` property
   */
  private initEvidence(): void {
    if(!this.hasEvidence()) {
      this.evidence = [] as ConditionEvidenceComponent[];
    }
  }

  /**
   * @returns the \`note\` property value as a Annotation array
   */
  public getNote(): Annotation[] {
    return this.note ?? ([] as Annotation[]);
  }

  /**
   * Assigns the provided Annotation array value to the \`note\` property.
   *
   * @param value - the \`note\` array value
   * @returns this
   */
  public setNote(value: Annotation[] | undefined): this {
    if (isDefinedList<Annotation>(value)) {
      const optErrMsg = \`Invalid Condition.note; Provided value array has an element that is not an instance of Annotation.\`;
      assertFhirTypeList<Annotation>(value, Annotation, optErrMsg);
      this.note = value;
    } else {
      this.note = undefined;
    }
    return this;
  }

  /**
   * Add the provided Annotation value to the \`note\` array property.
   *
   * @param value - the \`note\` value
   * @returns this
   */
  public addNote(value: Annotation | undefined): this {
    if (isDefined<Annotation>(value)) {
      const optErrMsg = \`Invalid Condition.note; Provided element is not an instance of Annotation.\`;
      assertFhirType<Annotation>(value, Annotation, optErrMsg);
      this.initNote();
      this.note?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`note\` property exists and has a value; \`false\` otherwise
   */
  public hasNote(): boolean {
    return isDefinedList<Annotation>(this.note) && this.note.some((item: Annotation) => !item.isEmpty());
  }

  /**
   * Initialize the \`note\` property
   */
  private initNote(): void {
    if(!this.hasNote()) {
      this.note = [] as Annotation[];
    }
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Condition';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.identifier,
      this.clinicalStatus,
      this.verificationStatus,
      this.category,
      this.severity,
      this.code,
      this.bodySite,
      this.subject,
      this.encounter,
      this.onset,
      this.abatement,
      this.recordedDate,
      this.recorder,
      this.asserter,
      this.stage,
      this.evidence,
      this.note,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Condition {
    const dest = new Condition();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Condition): void {
    super.copyValues(dest);
    const identifierList = copyListValues<Identifier>(this.identifier);
    dest.identifier = identifierList.length === 0 ? undefined : identifierList;
    dest.clinicalStatus = this.clinicalStatus?.copy();
    dest.verificationStatus = this.verificationStatus?.copy();
    const categoryList = copyListValues<CodeableConcept>(this.category);
    dest.category = categoryList.length === 0 ? undefined : categoryList;
    dest.severity = this.severity?.copy();
    dest.code = this.code?.copy();
    const bodySiteList = copyListValues<CodeableConcept>(this.bodySite);
    dest.bodySite = bodySiteList.length === 0 ? undefined : bodySiteList;
    dest.subject = this.subject ? this.subject.copy() : null;
    dest.encounter = this.encounter?.copy();
    dest.onset = this.onset?.copy();
    dest.abatement = this.abatement?.copy();
    dest.recordedDate = this.recordedDate?.copy();
    dest.recorder = this.recorder?.copy();
    dest.asserter = this.asserter?.copy();
    const stageList = copyListValues<ConditionStageComponent>(this.stage);
    dest.stage = stageList.length === 0 ? undefined : stageList;
    const evidenceList = copyListValues<ConditionEvidenceComponent>(this.evidence);
    dest.evidence = evidenceList.length === 0 ? undefined : evidenceList;
    const noteList = copyListValues<Annotation>(this.note);
    dest.note = noteList.length === 0 ? undefined : noteList;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasIdentifier()) {
      setFhirComplexListJson(this.getIdentifier(), 'identifier', jsonObj);
    }

    if (this.hasClinicalStatus()) {
      setFhirComplexJson(this.getClinicalStatus(), 'clinicalStatus', jsonObj);
    }

    if (this.hasVerificationStatus()) {
      setFhirComplexJson(this.getVerificationStatus(), 'verificationStatus', jsonObj);
    }

    if (this.hasCategory()) {
      setFhirComplexListJson(this.getCategory(), 'category', jsonObj);
    }

    if (this.hasSeverity()) {
      setFhirComplexJson(this.getSeverity(), 'severity', jsonObj);
    }

    if (this.hasCode()) {
      setFhirComplexJson(this.getCode(), 'code', jsonObj);
    }

    if (this.hasBodySite()) {
      setFhirComplexListJson(this.getBodySite(), 'bodySite', jsonObj);
    }

    if (this.hasSubject()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirComplexJson(this.getSubject()!, 'subject', jsonObj);
    } else {
      missingReqdProperties.push(\`Condition.subject\`);
    }

    if (this.hasEncounter()) {
      setFhirComplexJson(this.getEncounter(), 'encounter', jsonObj);
    }

    if (this.hasOnset()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getOnset()!, 'onset', jsonObj);
    }

    if (this.hasAbatement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getAbatement()!, 'abatement', jsonObj);
    }

    if (this.hasRecordedDateElement()) {
      setFhirPrimitiveJson<fhirDateTime>(this.getRecordedDateElement(), 'recordedDate', jsonObj);
    }

    if (this.hasRecorder()) {
      setFhirComplexJson(this.getRecorder(), 'recorder', jsonObj);
    }

    if (this.hasAsserter()) {
      setFhirComplexJson(this.getAsserter(), 'asserter', jsonObj);
    }

    if (this.hasStage()) {
      setFhirBackboneElementListJson(this.getStage(), 'stage', jsonObj);
    }

    if (this.hasEvidence()) {
      setFhirBackboneElementListJson(this.getEvidence(), 'evidence', jsonObj);
    }

    if (this.hasNote()) {
      setFhirComplexListJson(this.getNote(), 'note', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}


/**
 * ConditionStageComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Stage/grade, usually assessed formally
 * - **Definition:** Clinical stage or grade of a condition. May include formal severity assessments.
 *
 * @category DataModel: Resource
 * @see [FHIR Condition](http://hl7.org/fhir/StructureDefinition/Condition)
 */
export class ConditionStageComponent extends BackboneElement {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`ConditionStageComponent\` JSON to instantiate the ConditionStageComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`ConditionStageComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to ConditionStageComponent
   * @returns ConditionStageComponent data model or undefined for \`ConditionStageComponent\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): ConditionStageComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'ConditionStageComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new ConditionStageComponent();
    fhirDataTypeParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';

    fieldName = 'summary';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = fhirDataTypeParser.parser<CodeableConcept>(CodeableConcept, classJsonObj[fieldName]!, sourceField);
      instance.setSummary(datatype);
    }

    fieldName = 'assessment';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Reference | undefined = fhirDataTypeParser.parser<Reference>(Reference, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addAssessment(datatype);
        }
      });
  }

    fieldName = 'type';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = fhirDataTypeParser.parser<CodeableConcept>(CodeableConcept, classJsonObj[fieldName]!, sourceField);
      instance.setType(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Condition.stage.summary Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Simple summary (disease specific)
   * - **Definition:** A simple summary of the stage such as "Stage 3". The determination of the stage is disease-specific.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private summary?: CodeableConcept | undefined;

  /**
   * Condition.stage.assessment Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Formal record of assessment
   * - **Definition:** Reference to a formal record of the evidence on which the staging assessment is based.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/ClinicalImpression',
   *       'http://hl7.org/fhir/StructureDefinition/DiagnosticReport',
   *       'http://hl7.org/fhir/StructureDefinition/Observation',
   *     ]
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private assessment?: Reference[] | undefined;

  /**
   * Condition.stage.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Kind of staging
   * - **Definition:** The kind of staging, such as pathological or clinical staging.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private type_?: CodeableConcept | undefined;


  /**
   * @returns the \`summary\` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getSummary(): CodeableConcept {
    return this.summary ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Summary object value to the \`summary\` property.
   *
   * @param value - the \`summary\` object value
   * @returns this
   */
  public setSummary(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Condition.stage.summary; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.summary = value;
    } else {
      this.summary = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`summary\` property exists and has a value; \`false\` otherwise
   */
  public hasSummary(): boolean {
    return isDefined<CodeableConcept>(this.summary) && !this.summary.isEmpty();
  }

  /**
   * @returns the \`assessment\` property value as a Reference array
   */
  public getAssessment(): Reference[] {
    return this.assessment ?? ([] as Reference[]);
  }

  /**
   * Assigns the provided Reference array value to the \`assessment\` property.
   *
   * @decorator \`@ReferenceTargets('Condition.stage.assessment', ['ClinicalImpression','DiagnosticReport','Observation',])\`
   *
   * @param value - the \`assessment\` array value
   * @returns this
   */
  @ReferenceTargets('Condition.stage.assessment', [
    'ClinicalImpression',
  
    'DiagnosticReport',
  
    'Observation',
  ])
  public setAssessment(value: Reference[] | undefined): this {
    if (isDefinedList<Reference>(value)) {
      // assertFhirTypeList<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.assessment = value;
    } else {
      this.assessment = undefined;
    }
    return this;
  }

  /**
   * Add the provided Reference value to the \`assessment\` array property.
   *
   * @decorator \`@ReferenceTargets('Condition.stage.assessment', ['ClinicalImpression','DiagnosticReport','Observation',])\`
   *
   * @param value - the \`assessment\` value
   * @returns this
   */
  @ReferenceTargets('Condition.stage.assessment', [
    'ClinicalImpression',
  
    'DiagnosticReport',
  
    'Observation',
  ])
  public addAssessment(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.initAssessment();
      this.assessment?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`assessment\` property exists and has a value; \`false\` otherwise
   */
  public hasAssessment(): boolean {
    return isDefinedList<Reference>(this.assessment) && this.assessment.some((item: Reference) => !item.isEmpty());
  }

  /**
   * Initialize the \`assessment\` property
   */
  private initAssessment(): void {
    if (!this.hasAssessment()) {
      this.assessment = [] as Reference[];
    }
  }

  /**
   * @returns the \`type_\` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getType(): CodeableConcept {
    return this.type_ ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Type object value to the \`type_\` property.
   *
   * @param value - the \`type_\` object value
   * @returns this
   */
  public setType(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Condition.stage.type; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.type_ = value;
    } else {
      this.type_ = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasType(): boolean {
    return isDefined<CodeableConcept>(this.type_) && !this.type_.isEmpty();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Condition.stage';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.summary,
      this.assessment,
      this.type_,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): ConditionStageComponent {
    const dest = new ConditionStageComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: ConditionStageComponent): void {
    super.copyValues(dest);
    dest.summary = this.summary?.copy();
    const assessmentList = copyListValues<Reference>(this.assessment);
    dest.assessment = assessmentList.length === 0 ? undefined : assessmentList;
    dest.type_ = this.type_?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasSummary()) {
      setFhirComplexJson(this.getSummary(), 'summary', jsonObj);
    }

    if (this.hasAssessment()) {
      setFhirComplexListJson(this.getAssessment(), 'assessment', jsonObj);
    }

    if (this.hasType()) {
      setFhirComplexJson(this.getType(), 'type', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * ConditionEvidenceComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Supporting evidence
 * - **Definition:** Supporting evidence / manifestations that are the basis of the Condition\\'s verification status, such as evidence that confirmed or refuted the condition.
 * - **Comment:** The evidence may be a simple list of coded symptoms/manifestations, or references to observations or formal assessments, or both.
 *
 * @category DataModel: Resource
 * @see [FHIR Condition](http://hl7.org/fhir/StructureDefinition/Condition)
 */
export class ConditionEvidenceComponent extends BackboneElement {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`ConditionEvidenceComponent\` JSON to instantiate the ConditionEvidenceComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`ConditionEvidenceComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to ConditionEvidenceComponent
   * @returns ConditionEvidenceComponent data model or undefined for \`ConditionEvidenceComponent\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): ConditionEvidenceComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'ConditionEvidenceComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new ConditionEvidenceComponent();
    fhirDataTypeParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';

    fieldName = 'code';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: CodeableConcept | undefined = fhirDataTypeParser.parser<CodeableConcept>(CodeableConcept, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addCode(datatype);
        }
      });
    }

    fieldName = 'detail';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Reference | undefined = fhirDataTypeParser.parser<Reference>(Reference, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addDetail(datatype);
        }
      });
  }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Condition.evidence.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Manifestation/symptom
   * - **Definition:** A manifestation or symptom that led to the recording of this condition.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code?: CodeableConcept[] | undefined;

  /**
   * Condition.evidence.detail Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Supporting information found elsewhere
   * - **Definition:** Links to other relevant information, including pathology reports.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Resource',
   *     ]
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private detail?: Reference[] | undefined;


  /**
   * @returns the \`code\` property value as a CodeableConcept array
   */
  public getCode(): CodeableConcept[] {
    return this.code ?? ([] as CodeableConcept[]);
  }

  /**
   * Assigns the provided CodeableConcept array value to the \`code\` property.
   *
   * @param value - the \`code\` array value
   * @returns this
   */
  public setCode(value: CodeableConcept[] | undefined): this {
    if (isDefinedList<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Condition.evidence.code; Provided value array has an element that is not an instance of CodeableConcept.\`;
      assertFhirTypeList<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.code = value;
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeableConcept value to the \`code\` array property.
   *
   * @param value - the \`code\` value
   * @returns this
   */
  public addCode(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Condition.evidence.code; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.initCode();
      this.code?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`code\` property exists and has a value; \`false\` otherwise
   */
  public hasCode(): boolean {
    return isDefinedList<CodeableConcept>(this.code) && this.code.some((item: CodeableConcept) => !item.isEmpty());
  }

  /**
   * Initialize the \`code\` property
   */
  private initCode(): void {
    if(!this.hasCode()) {
      this.code = [] as CodeableConcept[];
    }
  }

  /**
   * @returns the \`detail\` property value as a Reference array
   */
  public getDetail(): Reference[] {
    return this.detail ?? ([] as Reference[]);
  }

  /**
   * Assigns the provided Reference array value to the \`detail\` property.
   *
   * @decorator \`@ReferenceTargets('Condition.evidence.detail', ['Resource',])\`
   *
   * @param value - the \`detail\` array value
   * @returns this
   */
  @ReferenceTargets('Condition.evidence.detail', [
    'Resource',
  ])
  public setDetail(value: Reference[] | undefined): this {
    if (isDefinedList<Reference>(value)) {
      // assertFhirTypeList<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.detail = value;
    } else {
      this.detail = undefined;
    }
    return this;
  }

  /**
   * Add the provided Reference value to the \`detail\` array property.
   *
   * @decorator \`@ReferenceTargets('Condition.evidence.detail', ['Resource',])\`
   *
   * @param value - the \`detail\` value
   * @returns this
   */
  @ReferenceTargets('Condition.evidence.detail', [
    'Resource',
  ])
  public addDetail(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.initDetail();
      this.detail?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`detail\` property exists and has a value; \`false\` otherwise
   */
  public hasDetail(): boolean {
    return isDefinedList<Reference>(this.detail) && this.detail.some((item: Reference) => !item.isEmpty());
  }

  /**
   * Initialize the \`detail\` property
   */
  private initDetail(): void {
    if (!this.hasDetail()) {
      this.detail = [] as Reference[];
    }
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Condition.evidence';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.code,
      this.detail,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): ConditionEvidenceComponent {
    const dest = new ConditionEvidenceComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: ConditionEvidenceComponent): void {
    super.copyValues(dest);
    const codeList = copyListValues<CodeableConcept>(this.code);
    dest.code = codeList.length === 0 ? undefined : codeList;
    const detailList = copyListValues<Reference>(this.detail);
    dest.detail = detailList.length === 0 ? undefined : detailList;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasCode()) {
      setFhirComplexListJson(this.getCode(), 'code', jsonObj);
    }

    if (this.hasDetail()) {
      setFhirComplexListJson(this.getDetail(), 'detail', jsonObj);
    }

    return jsonObj;
  }
}
",
  "fileExtension": "ts",
  "filename": "Condition",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 71`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "Resource",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * Organization Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/Organization
 * StructureDefinition.name: Organization
 * StructureDefinition.description: A formally or informally recognized grouping of people or organizations formed for the purpose of achieving some form of collective action.  Includes companies, institutions, corporations, departments, community groups, healthcare practice groups, payer/insurer, etc.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  BackboneElement,
  BooleanType,
  FhirDataTypeParser,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  PrimitiveTypeJson,
  StringType,
  assertFhirType,
  assertFhirTypeList,
  copyListValues,
  fhirBoolean,
  fhirBooleanSchema,
  fhirString,
  fhirStringSchema,
  getPrimitiveTypeJson,
  getPrimitiveTypeListJson,
  isDefined,
  isDefinedList,
  isElementEmpty,
  isEmpty,
  parseBooleanType,
  parseFhirPrimitiveData,
  parseStringType,
  setFhirBackboneElementListJson,
  setFhirComplexJson,
  setFhirComplexListJson,
  setFhirPrimitiveJson,
  setFhirPrimitiveListJson,
} from '@paq-ts-fhir/fhir-core';
import {
  Address,
  CodeableConcept,
  ContactPoint,
  DomainResource,
  FhirResourceParser,
  FhirResourceType,
  HumanName,
  Identifier,
  PARSABLE_DATATYPE_MAP,
  Reference,
  ReferenceTargets,
} from '../index';

/**
 * Organization Class
 *
 * @remarks
 * A formally or informally recognized grouping of people or organizations formed for the purpose of achieving some form of collective action.  Includes companies, institutions, corporations, departments, community groups, healthcare practice groups, payer/insurer, etc.
 *
 * **FHIR Specification**
 * - **Short:** A grouping of people or organizations with a common purpose
 * - **Definition:** A formally or informally recognized grouping of people or organizations formed for the purpose of achieving some form of collective action.  Includes companies, institutions, corporations, departments, community groups, healthcare practice groups, payer/insurer, etc.
 * - **FHIR Version:** 4.0.1
 *
 * @category DataModel: Resource
 * @see [FHIR Organization](http://hl7.org/fhir/StructureDefinition/Organization)
 */
export class Organization extends DomainResource implements IBase {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`Organization\` JSON to instantiate the Organization data model.
   *
   * @param sourceJson - JSON representing FHIR \`Organization\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Organization
   * @returns Organization data model or undefined for \`Organization\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Organization | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirResourceParser = new FhirResourceParser(PARSABLE_DATATYPE_MAP);
    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Organization';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Organization();
    fhirResourceParser.processDomainResourceJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'identifier';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Identifier | undefined = fhirDataTypeParser.parser<Identifier>(Identifier, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addIdentifier(datatype);
        }
      });
    }

    fieldName = 'active';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'boolean';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: BooleanType | undefined = parseBooleanType(dtJson, dtSiblingJson);
      instance.setActiveElement(datatype);
    }

    fieldName = 'type';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: CodeableConcept | undefined = fhirDataTypeParser.parser<CodeableConcept>(CodeableConcept, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addType(datatype);
        }
      });
    }

    fieldName = 'name';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setNameElement(datatype);
    }

    fieldName = 'alias';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: StringType | undefined = parseStringType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addAliasElement(datatype);
        }
      });
    }

    fieldName = 'telecom';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: ContactPoint | undefined = fhirDataTypeParser.parser<ContactPoint>(ContactPoint, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addTelecom(datatype);
        }
      });
    }

    fieldName = 'address';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Address | undefined = fhirDataTypeParser.parser<Address>(Address, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addAddress(datatype);
        }
      });
    }

    fieldName = 'partOf';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = fhirDataTypeParser.parser<Reference>(Reference, classJsonObj[fieldName]!, sourceField);
      instance.setPartOf(datatype);
    }

    fieldName = 'contact';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const componentJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      componentJsonArray.forEach((componentJson: JSON.Value, idx) => {
        const component: OrganizationContactComponent | undefined = OrganizationContactComponent.parse(componentJson, \`\${sourceField}[\${String(idx)}]\`);
        if (component !== undefined) {
          instance.addContact(component);
        }
      });
    }

    fieldName = 'endpoint';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Reference | undefined = fhirDataTypeParser.parser<Reference>(Reference, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addEndpoint(datatype);
        }
      });
  }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Organization.identifier Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Identifies this organization  across multiple systems
   * - **Definition:** Identifier for the organization that is used to identify the organization across multiple disparate systems.
   * - **Requirements:** Organizations are known by a variety of ids. Some institutions maintain several, and most collect identifiers for exchange with other organizations concerning the organization.
   * - **FHIR Type:** \`Identifier\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private identifier?: Identifier[] | undefined;

  /**
   * Organization.active Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Whether the organization\\'s record is still in active use
   * - **Definition:** Whether the organization\\'s record is still in active use.
   * - **Comment:** This active flag is not intended to be used to mark an organization as temporarily closed or under construction. Instead the Location(s) within the Organization should have the suspended status. If further details of the reason for the suspension are required, then an extension on this element should be used. This element is labeled as a modifier because it may be used to mark that the resource was created in error.
   * - **Requirements:** Need a flag to indicate a record is no longer to be used and should generally be hidden for the user in the UI.
   * - **FHIR Type:** \`boolean\`
   * - **Cardinality:** 0..1
   * - **isModifier:** true
   * - **isModifierReason:** This element is labelled as a modifier because it is a status element that can indicate that a record should not be treated as valid
   * - **isSummary:** true
   */
  private active?: BooleanType | undefined;

  /**
   * Organization.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Kind of organization
   * - **Definition:** The kind(s) of organization that this is.
   * - **Comment:** Organizations can be corporations, wards, sections, clinical teams, government departments, etc. Note that code is generally a classifier of the type of organization; in many applications, codes are used to identity a particular organization (say, ward) as opposed to another of the same type - these are identifiers, not codes When considering if multiple types are appropriate, you should evaluate if child organizations would be a more appropriate use of the concept, as different types likely are in different sub-areas of the organization. This is most likely to be used where type values have orthogonal values, such as a religious, academic and medical center. We expect that some jurisdictions will profile this optionality to be a single cardinality.
   * - **Requirements:** Need to be able to track the kind of organization that this is - different organization types have different uses.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private type_?: CodeableConcept[] | undefined;

  /**
   * Organization.name Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Name used for the organization
   * - **Definition:** A name associated with the organization.
   * - **Comment:** If the name of an organization changes, consider putting the old name in the alias column so that it can still be located through searches.
   * - **Requirements:** Need to use the name as the label of the organization.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private name?: StringType | undefined;

  /**
   * Organization.alias Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A list of alternate names that the organization is known as, or was known as in the past
   * - **Definition:** A list of alternate names that the organization is known as, or was known as in the past.
   * - **Comment:** There are no dates associated with the alias/historic names, as this is not intended to track when names were used, but to assist in searching so that older names can still result in identifying the organization.
   * - **Requirements:** Over time locations and organizations go through many changes and can be known by different names. For searching knowing previous names that the organization was known by can be very useful.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private alias?: StringType[] | undefined;

  /**
   * Organization.telecom Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A contact detail for the organization
   * - **Definition:** A contact detail for the organization.
   * - **Comment:** The use code \\'home\\' is not to be used. Note that these contacts are not the contact details of people who are employed by or represent the organization, but official contacts for the organization itself.
   * - **Requirements:** Human contact for the organization.
   * - **FHIR Type:** \`ContactPoint\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private telecom?: ContactPoint[] | undefined;

  /**
   * Organization.address Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** An address for the organization
   * - **Definition:** An address for the organization.
   * - **Comment:** Organization may have multiple addresses with different uses or applicable periods. The use code \\'home\\' is not to be used.
   * - **Requirements:** May need to keep track of the organization\\'s addresses for contacting, billing or reporting requirements.
   * - **FHIR Type:** \`Address\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private address?: Address[] | undefined;

  /**
   * Organization.partOf Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The organization of which this organization forms a part
   * - **Definition:** The organization of which this organization forms a part.
   * - **Requirements:** Need to be able to track the hierarchy of organizations within an organization.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Organization',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private partOf?: Reference | undefined;

  /**
   * Organization.contact Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Contact for the organization for a certain purpose
   * - **Definition:** Contact for the organization for a certain purpose.
   * - **Comment:** Where multiple contacts for the same purpose are provided there is a standard extension that can be used to determine which one is the preferred contact to use.
   * - **Requirements:** Need to keep track of assigned contact points within bigger organization.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private contact?: OrganizationContactComponent[] | undefined;

  /**
   * Organization.endpoint Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Technical endpoints providing access to services operated for the organization
   * - **Definition:** Technical endpoints providing access to services operated for the organization.
   * - **Requirements:** Organizations have multiple systems that provide various services and need to be able to define the technical connection details for how to connect to them, and for what purpose.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Endpoint',
   *     ]
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private endpoint?: Reference[] | undefined;


  /**
   * @returns the FHIR resource type as defined by the FHIR specification
   */
  public override resourceType(): FhirResourceType {
    return this.fhirType() as FhirResourceType;
  }

  /**
   * @returns the \`identifier\` property value as a Identifier array
   */
  public getIdentifier(): Identifier[] {
    return this.identifier ?? ([] as Identifier[]);
  }

  /**
   * Assigns the provided Identifier array value to the \`identifier\` property.
   *
   * @param value - the \`identifier\` array value
   * @returns this
   */
  public setIdentifier(value: Identifier[] | undefined): this {
    if (isDefinedList<Identifier>(value)) {
      const optErrMsg = \`Invalid Organization.identifier; Provided value array has an element that is not an instance of Identifier.\`;
      assertFhirTypeList<Identifier>(value, Identifier, optErrMsg);
      this.identifier = value;
    } else {
      this.identifier = undefined;
    }
    return this;
  }

  /**
   * Add the provided Identifier value to the \`identifier\` array property.
   *
   * @param value - the \`identifier\` value
   * @returns this
   */
  public addIdentifier(value: Identifier | undefined): this {
    if (isDefined<Identifier>(value)) {
      const optErrMsg = \`Invalid Organization.identifier; Provided element is not an instance of Identifier.\`;
      assertFhirType<Identifier>(value, Identifier, optErrMsg);
      this.initIdentifier();
      this.identifier?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`identifier\` property exists and has a value; \`false\` otherwise
   */
  public hasIdentifier(): boolean {
    return isDefinedList<Identifier>(this.identifier) && this.identifier.some((item: Identifier) => !item.isEmpty());
  }

  /**
   * Initialize the \`identifier\` property
   */
  private initIdentifier(): void {
    if(!this.hasIdentifier()) {
      this.identifier = [] as Identifier[];
    }
  }

  /**
   * @returns the \`active\` property value as a BooleanType object if defined; else an empty BooleanType object
   */
  public getActiveElement(): BooleanType {
    return this.active ?? new BooleanType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`active\` property.
   *
   * @param element - the \`active\` value
   * @returns this
   */
  public setActiveElement(element: BooleanType | undefined): this {
    if (isDefined<BooleanType>(element)) {
      const optErrMsg = \`Invalid Organization.active; Provided element is not an instance of BooleanType.\`;
      assertFhirType<BooleanType>(element, BooleanType, optErrMsg);
      this.active = element;
    } else {
      this.active = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`active\` property exists and has a value; \`false\` otherwise
   */
  public hasActiveElement(): boolean {
    return isDefined<BooleanType>(this.active) && !this.active.isEmpty();
  }

  /**
   * @returns the \`active\` property value as a fhirBoolean if defined; else undefined
   */
  public getActive(): fhirBoolean | undefined {
    return this.active?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`active\` property.
   *
   * @param value - the \`active\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setActive(value: fhirBoolean | undefined): this {
    if (isDefined<fhirBoolean>(value)) {
      const optErrMsg = \`Invalid Organization.active (\${String(value)})\`;
      this.active = new BooleanType(parseFhirPrimitiveData(value, fhirBooleanSchema, optErrMsg));
    } else {
      this.active = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`active\` property exists and has a value; \`false\` otherwise
   */
  public hasActive(): boolean {
    return this.hasActiveElement();
  }

  /**
   * @returns the \`type_\` property value as a CodeableConcept array
   */
  public getType(): CodeableConcept[] {
    return this.type_ ?? ([] as CodeableConcept[]);
  }

  /**
   * Assigns the provided CodeableConcept array value to the \`type_\` property.
   *
   * @param value - the \`type_\` array value
   * @returns this
   */
  public setType(value: CodeableConcept[] | undefined): this {
    if (isDefinedList<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Organization.type; Provided value array has an element that is not an instance of CodeableConcept.\`;
      assertFhirTypeList<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.type_ = value;
    } else {
      this.type_ = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeableConcept value to the \`type_\` array property.
   *
   * @param value - the \`type_\` value
   * @returns this
   */
  public addType(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Organization.type; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.initType();
      this.type_?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasType(): boolean {
    return isDefinedList<CodeableConcept>(this.type_) && this.type_.some((item: CodeableConcept) => !item.isEmpty());
  }

  /**
   * Initialize the \`type_\` property
   */
  private initType(): void {
    if(!this.hasType()) {
      this.type_ = [] as CodeableConcept[];
    }
  }

  /**
   * @returns the \`name\` property value as a StringType object if defined; else an empty StringType object
   */
  public getNameElement(): StringType {
    return this.name ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`name\` property.
   *
   * @param element - the \`name\` value
   * @returns this
   */
  public setNameElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Organization.name; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.name = element;
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`name\` property exists and has a value; \`false\` otherwise
   */
  public hasNameElement(): boolean {
    return isDefined<StringType>(this.name) && !this.name.isEmpty();
  }

  /**
   * @returns the \`name\` property value as a fhirString if defined; else undefined
   */
  public getName(): fhirString | undefined {
    return this.name?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`name\` property.
   *
   * @param value - the \`name\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setName(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Organization.name (\${String(value)})\`;
      this.name = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`name\` property exists and has a value; \`false\` otherwise
   */
  public hasName(): boolean {
    return this.hasNameElement();
  }

  /**
   * @returns the \`alias\` property value as a StringType array
   */
  public getAliasElement(): StringType[] {
    return this.alias ?? ([] as StringType[]);
  }

  /**
   * Assigns the provided StringType array value to the \`alias\` property.
   *
   * @param element - the \`alias\` array value
   * @returns this
   */
  public setAliasElement(element: StringType[] | undefined): this {
    if (isDefinedList<StringType>(element)) {
      const optErrMsg = \`Invalid Organization.alias; Provided value array has an element that is not an instance of StringType.\`;
      assertFhirTypeList<StringType>(element, StringType, optErrMsg);
      this.alias = element;
    } else {
      this.alias = undefined;
    }
    return this;
  }

  /**
   * Add the provided StringType value to the \`alias\` array property.
   *
   * @param element - the \`alias\` value
   * @returns this
   */
  public addAliasElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Organization.alias; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.initAlias();
      this.alias?.push(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`alias\` property exists and has a value; \`false\` otherwise
   */
  public hasAliasElement(): boolean {
    return isDefinedList<StringType>(this.alias) && this.alias.some((item: StringType) => !item.isEmpty());
  }

  /**
   * @returns the \`alias\` property value as a fhirString array
   */
  public getAlias(): fhirString[] {
    this.initAlias();
    const aliasValues = [] as fhirString[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.alias!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        aliasValues.push(value);
      }
    }
    return aliasValues;
  }

  /**
   * Assigns the provided primitive value array to the \`alias\` property.
   *
   * @param value - the \`alias\` value array
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setAlias(value: fhirString[] | undefined): this {
    if (isDefinedList<fhirString>(value)) {
      const aliasElements = [] as StringType[];
      for (const aliasValue of value) {
        const optErrMsg = \`Invalid Organization.alias array item (\${String(aliasValue)})\`;
        const element = new StringType(parseFhirPrimitiveData(aliasValue, fhirStringSchema, optErrMsg));
        aliasElements.push(element);
      }
      this.alias = aliasElements;
    } else {
      this.alias = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`alias\` array property.
   *
   * @param value - the \`alias\` value
   * @returns this
   */
  public addAlias(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Organization.alias array item (\${String(value)})\`;
      const element = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
      this.initAlias();
      this.addAliasElement(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`alias\` property exists and has a value; \`false\` otherwise
   */
  public hasAlias(): boolean {
    return this.hasAliasElement();
  }

  /**
   * Initialize the \`alias\` property
   */
  private initAlias(): void {
    if (!this.hasAlias()) {
      this.alias = [] as StringType[];
    }
  }

  /**
   * @returns the \`telecom\` property value as a ContactPoint array
   */
  public getTelecom(): ContactPoint[] {
    return this.telecom ?? ([] as ContactPoint[]);
  }

  /**
   * Assigns the provided ContactPoint array value to the \`telecom\` property.
   *
   * @param value - the \`telecom\` array value
   * @returns this
   */
  public setTelecom(value: ContactPoint[] | undefined): this {
    if (isDefinedList<ContactPoint>(value)) {
      const optErrMsg = \`Invalid Organization.telecom; Provided value array has an element that is not an instance of ContactPoint.\`;
      assertFhirTypeList<ContactPoint>(value, ContactPoint, optErrMsg);
      this.telecom = value;
    } else {
      this.telecom = undefined;
    }
    return this;
  }

  /**
   * Add the provided ContactPoint value to the \`telecom\` array property.
   *
   * @param value - the \`telecom\` value
   * @returns this
   */
  public addTelecom(value: ContactPoint | undefined): this {
    if (isDefined<ContactPoint>(value)) {
      const optErrMsg = \`Invalid Organization.telecom; Provided element is not an instance of ContactPoint.\`;
      assertFhirType<ContactPoint>(value, ContactPoint, optErrMsg);
      this.initTelecom();
      this.telecom?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`telecom\` property exists and has a value; \`false\` otherwise
   */
  public hasTelecom(): boolean {
    return isDefinedList<ContactPoint>(this.telecom) && this.telecom.some((item: ContactPoint) => !item.isEmpty());
  }

  /**
   * Initialize the \`telecom\` property
   */
  private initTelecom(): void {
    if(!this.hasTelecom()) {
      this.telecom = [] as ContactPoint[];
    }
  }

  /**
   * @returns the \`address\` property value as a Address array
   */
  public getAddress(): Address[] {
    return this.address ?? ([] as Address[]);
  }

  /**
   * Assigns the provided Address array value to the \`address\` property.
   *
   * @param value - the \`address\` array value
   * @returns this
   */
  public setAddress(value: Address[] | undefined): this {
    if (isDefinedList<Address>(value)) {
      const optErrMsg = \`Invalid Organization.address; Provided value array has an element that is not an instance of Address.\`;
      assertFhirTypeList<Address>(value, Address, optErrMsg);
      this.address = value;
    } else {
      this.address = undefined;
    }
    return this;
  }

  /**
   * Add the provided Address value to the \`address\` array property.
   *
   * @param value - the \`address\` value
   * @returns this
   */
  public addAddress(value: Address | undefined): this {
    if (isDefined<Address>(value)) {
      const optErrMsg = \`Invalid Organization.address; Provided element is not an instance of Address.\`;
      assertFhirType<Address>(value, Address, optErrMsg);
      this.initAddress();
      this.address?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`address\` property exists and has a value; \`false\` otherwise
   */
  public hasAddress(): boolean {
    return isDefinedList<Address>(this.address) && this.address.some((item: Address) => !item.isEmpty());
  }

  /**
   * Initialize the \`address\` property
   */
  private initAddress(): void {
    if(!this.hasAddress()) {
      this.address = [] as Address[];
    }
  }

  /**
   * @returns the \`partOf\` property value as a Reference object; else an empty Reference object
   */
  public getPartOf(): Reference {
    return this.partOf ?? new Reference();
  }

  /**
   * Assigns the provided PartOf object value to the \`partOf\` property.
   *
   * @decorator \`@ReferenceTargets('Organization.partOf', ['Organization',])\`
   *
   * @param value - the \`partOf\` object value
   * @returns this
   */
  @ReferenceTargets('Organization.partOf', [
    'Organization',
  ])
  public setPartOf(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.partOf = value;
    } else {
      this.partOf = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`partOf\` property exists and has a value; \`false\` otherwise
   */
  public hasPartOf(): boolean {
    return isDefined<Reference>(this.partOf) && !this.partOf.isEmpty();
  }

  /**
   * @returns the \`contact\` property value as a OrganizationContactComponent array
   */
  public getContact(): OrganizationContactComponent[] {
    return this.contact ?? ([] as OrganizationContactComponent[]);
  }

  /**
   * Assigns the provided OrganizationContactComponent array value to the \`contact\` property.
   *
   * @param value - the \`contact\` array value
   * @returns this
   */
  public setContact(value: OrganizationContactComponent[] | undefined): this {
    if (isDefinedList<OrganizationContactComponent>(value)) {
      const optErrMsg = \`Invalid Organization.contact; Provided value array has an element that is not an instance of OrganizationContactComponent.\`;
      assertFhirTypeList<OrganizationContactComponent>(value, OrganizationContactComponent, optErrMsg);
      this.contact = value;
    } else {
      this.contact = undefined;
    }
    return this;
  }

  /**
   * Add the provided OrganizationContactComponent value to the \`contact\` array property.
   *
   * @param value - the \`contact\` value
   * @returns this
   */
  public addContact(value: OrganizationContactComponent | undefined): this {
    if (isDefined<OrganizationContactComponent>(value)) {
      const optErrMsg = \`Invalid Organization.contact; Provided element is not an instance of OrganizationContactComponent.\`;
      assertFhirType<OrganizationContactComponent>(value, OrganizationContactComponent, optErrMsg);
      this.initContact();
      this.contact?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`contact\` property exists and has a value; \`false\` otherwise
   */
  public hasContact(): boolean {
    return isDefinedList<OrganizationContactComponent>(this.contact) && this.contact.some((item: OrganizationContactComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`contact\` property
   */
  private initContact(): void {
    if(!this.hasContact()) {
      this.contact = [] as OrganizationContactComponent[];
    }
  }

  /**
   * @returns the \`endpoint\` property value as a Reference array
   */
  public getEndpoint(): Reference[] {
    return this.endpoint ?? ([] as Reference[]);
  }

  /**
   * Assigns the provided Reference array value to the \`endpoint\` property.
   *
   * @decorator \`@ReferenceTargets('Organization.endpoint', ['Endpoint',])\`
   *
   * @param value - the \`endpoint\` array value
   * @returns this
   */
  @ReferenceTargets('Organization.endpoint', [
    'Endpoint',
  ])
  public setEndpoint(value: Reference[] | undefined): this {
    if (isDefinedList<Reference>(value)) {
      // assertFhirTypeList<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.endpoint = value;
    } else {
      this.endpoint = undefined;
    }
    return this;
  }

  /**
   * Add the provided Reference value to the \`endpoint\` array property.
   *
   * @decorator \`@ReferenceTargets('Organization.endpoint', ['Endpoint',])\`
   *
   * @param value - the \`endpoint\` value
   * @returns this
   */
  @ReferenceTargets('Organization.endpoint', [
    'Endpoint',
  ])
  public addEndpoint(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.initEndpoint();
      this.endpoint?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`endpoint\` property exists and has a value; \`false\` otherwise
   */
  public hasEndpoint(): boolean {
    return isDefinedList<Reference>(this.endpoint) && this.endpoint.some((item: Reference) => !item.isEmpty());
  }

  /**
   * Initialize the \`endpoint\` property
   */
  private initEndpoint(): void {
    if (!this.hasEndpoint()) {
      this.endpoint = [] as Reference[];
    }
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Organization';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.identifier,
      this.active,
      this.type_,
      this.name,
      this.alias,
      this.telecom,
      this.address,
      this.partOf,
      this.contact,
      this.endpoint,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Organization {
    const dest = new Organization();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Organization): void {
    super.copyValues(dest);
    const identifierList = copyListValues<Identifier>(this.identifier);
    dest.identifier = identifierList.length === 0 ? undefined : identifierList;
    dest.active = this.active?.copy();
    const typeList = copyListValues<CodeableConcept>(this.type_);
    dest.type_ = typeList.length === 0 ? undefined : typeList;
    dest.name = this.name?.copy();
    const aliasList = copyListValues<StringType>(this.alias);
    dest.alias = aliasList.length === 0 ? undefined : aliasList;
    const telecomList = copyListValues<ContactPoint>(this.telecom);
    dest.telecom = telecomList.length === 0 ? undefined : telecomList;
    const addressList = copyListValues<Address>(this.address);
    dest.address = addressList.length === 0 ? undefined : addressList;
    dest.partOf = this.partOf?.copy();
    const contactList = copyListValues<OrganizationContactComponent>(this.contact);
    dest.contact = contactList.length === 0 ? undefined : contactList;
    const endpointList = copyListValues<Reference>(this.endpoint);
    dest.endpoint = endpointList.length === 0 ? undefined : endpointList;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasIdentifier()) {
      setFhirComplexListJson(this.getIdentifier(), 'identifier', jsonObj);
    }

    if (this.hasActiveElement()) {
      setFhirPrimitiveJson<fhirBoolean>(this.getActiveElement(), 'active', jsonObj);
    }

    if (this.hasType()) {
      setFhirComplexListJson(this.getType(), 'type', jsonObj);
    }

    if (this.hasNameElement()) {
      setFhirPrimitiveJson<fhirString>(this.getNameElement(), 'name', jsonObj);
    }

    if (this.hasAlias()) {
      setFhirPrimitiveListJson(this.getAliasElement(), 'alias', jsonObj);
    }

    if (this.hasTelecom()) {
      setFhirComplexListJson(this.getTelecom(), 'telecom', jsonObj);
    }

    if (this.hasAddress()) {
      setFhirComplexListJson(this.getAddress(), 'address', jsonObj);
    }

    if (this.hasPartOf()) {
      setFhirComplexJson(this.getPartOf(), 'partOf', jsonObj);
    }

    if (this.hasContact()) {
      setFhirBackboneElementListJson(this.getContact(), 'contact', jsonObj);
    }

    if (this.hasEndpoint()) {
      setFhirComplexListJson(this.getEndpoint(), 'endpoint', jsonObj);
    }

    return jsonObj;
  }
}


/**
 * OrganizationContactComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Contact for the organization for a certain purpose
 * - **Definition:** Contact for the organization for a certain purpose.
 * - **Comment:** Where multiple contacts for the same purpose are provided there is a standard extension that can be used to determine which one is the preferred contact to use.
 * - **Requirements:** Need to keep track of assigned contact points within bigger organization.
 *
 * @category DataModel: Resource
 * @see [FHIR Organization](http://hl7.org/fhir/StructureDefinition/Organization)
 */
export class OrganizationContactComponent extends BackboneElement {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`OrganizationContactComponent\` JSON to instantiate the OrganizationContactComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`OrganizationContactComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to OrganizationContactComponent
   * @returns OrganizationContactComponent data model or undefined for \`OrganizationContactComponent\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): OrganizationContactComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'OrganizationContactComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new OrganizationContactComponent();
    fhirDataTypeParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';

    fieldName = 'purpose';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = fhirDataTypeParser.parser<CodeableConcept>(CodeableConcept, classJsonObj[fieldName]!, sourceField);
      instance.setPurpose(datatype);
    }

    fieldName = 'name';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: HumanName | undefined = fhirDataTypeParser.parser<HumanName>(HumanName, classJsonObj[fieldName]!, sourceField);
      instance.setName(datatype);
    }

    fieldName = 'telecom';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: ContactPoint | undefined = fhirDataTypeParser.parser<ContactPoint>(ContactPoint, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addTelecom(datatype);
        }
      });
    }

    fieldName = 'address';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Address | undefined = fhirDataTypeParser.parser<Address>(Address, classJsonObj[fieldName]!, sourceField);
      instance.setAddress(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Organization.contact.purpose Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The type of contact
   * - **Definition:** Indicates a purpose for which the contact can be reached.
   * - **Requirements:** Need to distinguish between multiple contact persons.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private purpose?: CodeableConcept | undefined;

  /**
   * Organization.contact.name Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A name associated with the contact
   * - **Definition:** A name associated with the contact.
   * - **Requirements:** Need to be able to track the person by name.
   * - **FHIR Type:** \`HumanName\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private name?: HumanName | undefined;

  /**
   * Organization.contact.telecom Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Contact details (telephone, email, etc.)  for a contact
   * - **Definition:** A contact detail (e.g. a telephone number or an email address) by which the party may be contacted.
   * - **Requirements:** People have (primary) ways to contact them in some way such as phone, email.
   * - **FHIR Type:** \`ContactPoint\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private telecom?: ContactPoint[] | undefined;

  /**
   * Organization.contact.address Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Visiting or postal addresses for the contact
   * - **Definition:** Visiting or postal addresses for the contact.
   * - **Requirements:** May need to keep track of a contact party\\'s address for contacting, billing or reporting requirements.
   * - **FHIR Type:** \`Address\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private address?: Address | undefined;


  /**
   * @returns the \`purpose\` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getPurpose(): CodeableConcept {
    return this.purpose ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Purpose object value to the \`purpose\` property.
   *
   * @param value - the \`purpose\` object value
   * @returns this
   */
  public setPurpose(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Organization.contact.purpose; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.purpose = value;
    } else {
      this.purpose = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`purpose\` property exists and has a value; \`false\` otherwise
   */
  public hasPurpose(): boolean {
    return isDefined<CodeableConcept>(this.purpose) && !this.purpose.isEmpty();
  }

  /**
   * @returns the \`name\` property value as a HumanName object if defined; else an empty HumanName object
   */
  public getName(): HumanName {
    return this.name ?? new HumanName();
  }

  /**
   * Assigns the provided Name object value to the \`name\` property.
   *
   * @param value - the \`name\` object value
   * @returns this
   */
  public setName(value: HumanName | undefined): this {
    if (isDefined<HumanName>(value)) {
      const optErrMsg = \`Invalid Organization.contact.name; Provided element is not an instance of HumanName.\`;
      assertFhirType<HumanName>(value, HumanName, optErrMsg);
      this.name = value;
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`name\` property exists and has a value; \`false\` otherwise
   */
  public hasName(): boolean {
    return isDefined<HumanName>(this.name) && !this.name.isEmpty();
  }

  /**
   * @returns the \`telecom\` property value as a ContactPoint array
   */
  public getTelecom(): ContactPoint[] {
    return this.telecom ?? ([] as ContactPoint[]);
  }

  /**
   * Assigns the provided ContactPoint array value to the \`telecom\` property.
   *
   * @param value - the \`telecom\` array value
   * @returns this
   */
  public setTelecom(value: ContactPoint[] | undefined): this {
    if (isDefinedList<ContactPoint>(value)) {
      const optErrMsg = \`Invalid Organization.contact.telecom; Provided value array has an element that is not an instance of ContactPoint.\`;
      assertFhirTypeList<ContactPoint>(value, ContactPoint, optErrMsg);
      this.telecom = value;
    } else {
      this.telecom = undefined;
    }
    return this;
  }

  /**
   * Add the provided ContactPoint value to the \`telecom\` array property.
   *
   * @param value - the \`telecom\` value
   * @returns this
   */
  public addTelecom(value: ContactPoint | undefined): this {
    if (isDefined<ContactPoint>(value)) {
      const optErrMsg = \`Invalid Organization.contact.telecom; Provided element is not an instance of ContactPoint.\`;
      assertFhirType<ContactPoint>(value, ContactPoint, optErrMsg);
      this.initTelecom();
      this.telecom?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`telecom\` property exists and has a value; \`false\` otherwise
   */
  public hasTelecom(): boolean {
    return isDefinedList<ContactPoint>(this.telecom) && this.telecom.some((item: ContactPoint) => !item.isEmpty());
  }

  /**
   * Initialize the \`telecom\` property
   */
  private initTelecom(): void {
    if(!this.hasTelecom()) {
      this.telecom = [] as ContactPoint[];
    }
  }

  /**
   * @returns the \`address\` property value as a Address object if defined; else an empty Address object
   */
  public getAddress(): Address {
    return this.address ?? new Address();
  }

  /**
   * Assigns the provided Address object value to the \`address\` property.
   *
   * @param value - the \`address\` object value
   * @returns this
   */
  public setAddress(value: Address | undefined): this {
    if (isDefined<Address>(value)) {
      const optErrMsg = \`Invalid Organization.contact.address; Provided element is not an instance of Address.\`;
      assertFhirType<Address>(value, Address, optErrMsg);
      this.address = value;
    } else {
      this.address = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`address\` property exists and has a value; \`false\` otherwise
   */
  public hasAddress(): boolean {
    return isDefined<Address>(this.address) && !this.address.isEmpty();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Organization.contact';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.purpose,
      this.name,
      this.telecom,
      this.address,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): OrganizationContactComponent {
    const dest = new OrganizationContactComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: OrganizationContactComponent): void {
    super.copyValues(dest);
    dest.purpose = this.purpose?.copy();
    dest.name = this.name?.copy();
    const telecomList = copyListValues<ContactPoint>(this.telecom);
    dest.telecom = telecomList.length === 0 ? undefined : telecomList;
    dest.address = this.address?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasPurpose()) {
      setFhirComplexJson(this.getPurpose(), 'purpose', jsonObj);
    }

    if (this.hasName()) {
      setFhirComplexJson(this.getName(), 'name', jsonObj);
    }

    if (this.hasTelecom()) {
      setFhirComplexListJson(this.getTelecom(), 'telecom', jsonObj);
    }

    if (this.hasAddress()) {
      setFhirComplexJson(this.getAddress(), 'address', jsonObj);
    }

    return jsonObj;
  }
}
",
  "fileExtension": "ts",
  "filename": "Organization",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 72`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "Resource",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * Patient Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/Patient
 * StructureDefinition.name: Patient
 * StructureDefinition.description: Demographics and other administrative information about an individual or animal receiving care or other health-related services.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  BackboneElement,
  BooleanType,
  ChoiceDataTypes,
  ChoiceDataTypesMeta,
  CodeType,
  DataType,
  DateTimeType,
  DateType,
  EnumCodeType,
  FhirDataTypeParser,
  FhirError,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  IntegerType,
  InvalidTypeError,
  JSON,
  REQUIRED_PROPERTIES_DO_NOT_EXIST,
  REQUIRED_PROPERTIES_REQD_IN_JSON,
  assertEnumCodeType,
  assertFhirType,
  assertFhirTypeList,
  assertIsDefined,
  constructorCodeValueAsEnumCodeType,
  copyListValues,
  fhirBoolean,
  fhirBooleanSchema,
  fhirCode,
  fhirCodeSchema,
  fhirDate,
  fhirDateSchema,
  getPrimitiveTypeJson,
  isDefined,
  isDefinedList,
  isElementEmpty,
  isEmpty,
  parseBooleanType,
  parseCodeType,
  parseDateType,
  parseFhirPrimitiveData,
  setFhirBackboneElementListJson,
  setFhirComplexJson,
  setFhirComplexListJson,
  setFhirPrimitiveJson,
  setPolymorphicValueJson,
} from '@paq-ts-fhir/fhir-core';
import {
  Address,
  AdministrativeGenderEnum,
  Attachment,
  CodeableConcept,
  ContactPoint,
  DomainResource,
  FhirResourceParser,
  FhirResourceType,
  HumanName,
  Identifier,
  LinkTypeEnum,
  PARSABLE_DATATYPE_MAP,
  Period,
  Reference,
  ReferenceTargets,
} from '../index';

// eslint-disable-next-line @typescript-eslint/no-explicit-any -- Symbol.metadata polyfill secret sauce for decorator metadata
(Symbol.metadata as any) ??= Symbol('Symbol.metadata');

/**
 * Patient Class
 *
 * @remarks
 * Demographics and other administrative information about an individual or animal receiving care or other health-related services.
 *
 * Tracking patient is the center of the healthcare process.
 *
 * **FHIR Specification**
 * - **Short:** Information about an individual or animal receiving health care services
 * - **Definition:** Demographics and other administrative information about an individual or animal receiving care or other health-related services.
 * - **FHIR Version:** 4.0.1
 *
 * @category DataModel: Resource
 * @see [FHIR Patient](http://hl7.org/fhir/StructureDefinition/Patient)
 */
export class Patient extends DomainResource implements IBase {
  constructor() {
    super();

    this.administrativeGenderEnum = new AdministrativeGenderEnum();
  }

  /**
   * Parse the provided \`Patient\` JSON to instantiate the Patient data model.
   *
   * @param sourceJson - JSON representing FHIR \`Patient\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Patient
   * @returns Patient data model or undefined for \`Patient\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Patient | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirResourceParser = new FhirResourceParser(PARSABLE_DATATYPE_MAP);
    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Patient';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Patient();
    fhirResourceParser.processDomainResourceJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const classMetadata: DecoratorMetadataObject | null = Patient[Symbol.metadata];
    const errorMessage = \`DecoratorMetadataObject does not exist for Patient\`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    fieldName = 'identifier';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Identifier | undefined = fhirDataTypeParser.parser<Identifier>(Identifier, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addIdentifier(datatype);
        }
      });
    }

    fieldName = 'active';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'boolean';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: BooleanType | undefined = parseBooleanType(dtJson, dtSiblingJson);
      instance.setActiveElement(datatype);
    }

    fieldName = 'name';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: HumanName | undefined = fhirDataTypeParser.parser<HumanName>(HumanName, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addName(datatype);
        }
      });
    }

    fieldName = 'telecom';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: ContactPoint | undefined = fhirDataTypeParser.parser<ContactPoint>(ContactPoint, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addTelecom(datatype);
        }
      });
    }

    fieldName = 'gender';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      instance.setGenderElement(datatype);
    }

    fieldName = 'birthDate';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DateType | undefined = parseDateType(dtJson, dtSiblingJson);
      instance.setBirthDateElement(datatype);
    }

    fieldName = 'deceased[x]';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const deceased: DataType | undefined = fhirDataTypeParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setDeceased(deceased);

    fieldName = 'address';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Address | undefined = fhirDataTypeParser.parser<Address>(Address, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addAddress(datatype);
        }
      });
    }

    fieldName = 'maritalStatus';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = fhirDataTypeParser.parser<CodeableConcept>(CodeableConcept, classJsonObj[fieldName]!, sourceField);
      instance.setMaritalStatus(datatype);
    }

    fieldName = 'multipleBirth[x]';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const multipleBirth: DataType | undefined = fhirDataTypeParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setMultipleBirth(multipleBirth);

    fieldName = 'photo';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Attachment | undefined = fhirDataTypeParser.parser<Attachment>(Attachment, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addPhoto(datatype);
        }
      });
    }

    fieldName = 'contact';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const componentJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      componentJsonArray.forEach((componentJson: JSON.Value, idx) => {
        const component: PatientContactComponent | undefined = PatientContactComponent.parse(componentJson, \`\${sourceField}[\${String(idx)}]\`);
        if (component !== undefined) {
          instance.addContact(component);
        }
      });
    }

    fieldName = 'communication';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const componentJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      componentJsonArray.forEach((componentJson: JSON.Value, idx) => {
        const component: PatientCommunicationComponent | undefined = PatientCommunicationComponent.parse(componentJson, \`\${sourceField}[\${String(idx)}]\`);
        if (component !== undefined) {
          instance.addCommunication(component);
        }
      });
    }

    fieldName = 'generalPractitioner';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Reference | undefined = fhirDataTypeParser.parser<Reference>(Reference, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addGeneralPractitioner(datatype);
        }
      });
  }

    fieldName = 'managingOrganization';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = fhirDataTypeParser.parser<Reference>(Reference, classJsonObj[fieldName]!, sourceField);
      instance.setManagingOrganization(datatype);
    }

    fieldName = 'link';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const componentJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      componentJsonArray.forEach((componentJson: JSON.Value, idx) => {
        const component: PatientLinkComponent | undefined = PatientLinkComponent.parse(componentJson, \`\${sourceField}[\${String(idx)}]\`);
        if (component !== undefined) {
          instance.addLink(component);
        }
      });
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Patient.identifier Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** An identifier for this patient
   * - **Definition:** An identifier for this patient.
   * - **Requirements:** Patients are almost always assigned specific numerical identifiers.
   * - **FHIR Type:** \`Identifier\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private identifier?: Identifier[] | undefined;

  /**
   * Patient.active Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Whether this patient\\'s record is in active use
   * - **Definition:** Whether this patient record is in active use.  Many systems use this property to mark as non-current patients, such as those that have not been seen for a period of time based on an organization\\'s business rules. It is often used to filter patient lists to exclude inactive patients Deceased patients may also be marked as inactive for the same reasons, but may be active for some time after death.
   * - **Comment:** If a record is inactive, and linked to an active record, then future patient/record updates should occur on the other patient.
   * - **Requirements:** Need to be able to mark a patient record as not to be used because it was created in error.
   * - **FHIR Type:** \`boolean\`
   * - **Cardinality:** 0..1
   * - **isModifier:** true
   * - **isModifierReason:** This element is labelled as a modifier because it is a status element that can indicate that a record should not be treated as valid
   * - **isSummary:** true
   */
  private active?: BooleanType | undefined;

  /**
   * Patient.name Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A name associated with the patient
   * - **Definition:** A name associated with the individual.
   * - **Comment:** A patient may have multiple names with different uses or applicable periods. For animals, the name is a "HumanName" in the sense that is assigned and used by humans and has the same patterns.
   * - **Requirements:** Need to be able to track the patient by multiple names. Examples are your official name and a partner name.
   * - **FHIR Type:** \`HumanName\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private name?: HumanName[] | undefined;

  /**
   * Patient.telecom Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A contact detail for the individual
   * - **Definition:** A contact detail (e.g. a telephone number or an email address) by which the individual may be contacted.
   * - **Comment:** A Patient may have multiple ways to be contacted with different uses or applicable periods.  May need to have options for contacting the person urgently and also to help with identification. The address might not go directly to the individual, but may reach another party that is able to proxy for the patient (i.e. home phone, or pet owner\\'s phone).
   * - **Requirements:** People have (primary) ways to contact them in some way such as phone, email.
   * - **FHIR Type:** \`ContactPoint\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private telecom?: ContactPoint[] | undefined;

  /**
   * FHIR CodeSystem: AdministrativeGender
   *
   * @see {@link AdministrativeGenderEnum }
   */
  private readonly administrativeGenderEnum: AdministrativeGenderEnum;

  /**
   * Patient.gender Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** male | female | other | unknown
   * - **Definition:** Administrative Gender - the gender that the patient is considered to have for administration and record keeping purposes.
   * - **Comment:** The gender might not match the biological sex as determined by genetics or the individual\\'s preferred identification. Note that for both humans and particularly animals, there are other legitimate possibilities than male and female, though the vast majority of systems and contexts only support male and female.  Systems providing decision support or enforcing business rules should ideally do this on the basis of Observations dealing with the specific sex or gender aspect of interest (anatomical, chromosomal, social, etc.)  However, because these observations are infrequently recorded, defaulting to the administrative gender is common practice.  Where such defaulting occurs, rule enforcement should allow for the variation between administrative and biological, chromosomal and other gender aspects.  For example, an alert about a hysterectomy on a male should be handled as a warning or overridable error, not a "hard" error.  See the Patient Gender and Sex section for additional information about communicating patient gender and sex.
   * - **Requirements:** Needed for identification of the individual, in combination with (at least) name and birth date.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private gender?: EnumCodeType | undefined;

  /**
   * Patient.birthDate Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The date of birth for the individual
   * - **Definition:** The date of birth for the individual.
   * - **Comment:** At least an estimated year should be provided as a guess if the real DOB is unknown  There is a standard extension "patient-birthTime" available that should be used where Time is required (such as in maternity/infant care systems).
   * - **Requirements:** Age of the individual drives many clinical processes.
   * - **FHIR Type:** \`date\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private birthDate?: DateType | undefined;

  /**
   * Patient.deceased[x] Element
   *
   * @decorator \`@ChoiceDataTypesMeta('Patient.deceased[x]', ['boolean','dateTime',]\`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Indicates if the individual is deceased or not
   * - **Definition:** Indicates if the individual is deceased or not.
   * - **Comment:** If there\\'s no value in the instance, it means there is no statement on whether or not the individual is deceased. Most systems will interpret the absence of a value as a sign of the person being alive.
   * - **Requirements:** The fact that a patient is deceased influences the clinical process. Also, in human communication and relation management it is necessary to know whether the person is alive.
   * - **FHIR Types:**
   *     'boolean',
   *     'dateTime',
   * - **Cardinality:** 0..1
   * - **isModifier:** true
   * - **isModifierReason:** This element is labeled as a modifier because once a patient is marked as deceased, the actions that are appropriate to perform on the patient may be significantly different.
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('Patient.deceased[x]',[
    'boolean',
    'dateTime',
  ])
  private deceased?: DataType | undefined;

  /**
   * Patient.address Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** An address for the individual
   * - **Definition:** An address for the individual.
   * - **Comment:** Patient may have multiple addresses with different uses or applicable periods.
   * - **Requirements:** May need to keep track of patient addresses for contacting, billing or reporting requirements and also to help with identification.
   * - **FHIR Type:** \`Address\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private address?: Address[] | undefined;

  /**
   * Patient.maritalStatus Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Marital (civil) status of a patient
   * - **Definition:** This field contains a patient\\'s most recent marital (civil) status.
   * - **Requirements:** Most, if not all systems capture it.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private maritalStatus?: CodeableConcept | undefined;

  /**
   * Patient.multipleBirth[x] Element
   *
   * @decorator \`@ChoiceDataTypesMeta('Patient.multipleBirth[x]', ['boolean','integer',]\`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Whether patient is part of a multiple birth
   * - **Definition:** Indicates whether the patient is part of a multiple (boolean) or indicates the actual birth order (integer).
   * - **Comment:** Where the valueInteger is provided, the number is the birth number in the sequence. E.g. The middle birth in triplets would be valueInteger=2 and the third born would have valueInteger=3 If a boolean value was provided for this triplets example, then all 3 patient records would have valueBoolean=true (the ordering is not indicated).
   * - **Requirements:** For disambiguation of multiple-birth children, especially relevant where the care provider doesn\\'t meet the patient, such as labs.
   * - **FHIR Types:**
   *     'boolean',
   *     'integer',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  @ChoiceDataTypesMeta('Patient.multipleBirth[x]',[
    'boolean',
    'integer',
  ])
  private multipleBirth?: DataType | undefined;

  /**
   * Patient.photo Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Image of the patient
   * - **Definition:** Image of the patient.
   * - **Comment:** Guidelines: * Use id photos, not clinical photos. * Limit dimensions to thumbnail. * Keep byte count low to ease resource updates.
   * - **Requirements:** Many EHR systems have the capability to capture an image of the patient. Fits with newer social media usage too.
   * - **FHIR Type:** \`Attachment\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private photo?: Attachment[] | undefined;

  /**
   * Patient.contact Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A contact party (e.g. guardian, partner, friend) for the patient
   * - **Definition:** A contact party (e.g. guardian, partner, friend) for the patient.
   * - **Comment:** Contact covers all kinds of contact parties: family members, business contacts, guardians, caregivers. Not applicable to register pedigree and family ties beyond use of having contact.
   * - **Requirements:** Need to track people you can contact about the patient.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private contact?: PatientContactComponent[] | undefined;

  /**
   * Patient.communication Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A language which may be used to communicate with the patient about his or her health
   * - **Definition:** A language which may be used to communicate with the patient about his or her health.
   * - **Comment:** If no language is specified, this *implies* that the default local language is spoken.  If you need to convey proficiency for multiple modes, then you need multiple Patient.Communication associations.   For animals, language is not a relevant field, and should be absent from the instance. If the Patient does not speak the default local language, then the Interpreter Required Standard can be used to explicitly declare that an interpreter is required.
   * - **Requirements:** If a patient does not speak the local language, interpreters may be required, so languages spoken and proficiency are important things to keep track of both for patient and other persons of interest.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private communication?: PatientCommunicationComponent[] | undefined;

  /**
   * Patient.generalPractitioner Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Patient\\'s nominated primary care provider
   * - **Definition:** Patient\\'s nominated care provider.
   * - **Comment:** This may be the primary care provider (in a GP context), or it may be a patient nominated care manager in a community/disability setting, or even organization that will provide people to perform the care provider roles.  It is not to be used to record Care Teams, these should be in a CareTeam resource that may be linked to the CarePlan or EpisodeOfCare resources. Multiple GPs may be recorded against the patient for various reasons, such as a student that has his home GP listed along with the GP at university during the school semesters, or a "fly-in/fly-out" worker that has the onsite GP also included with his home GP to remain aware of medical issues. Jurisdictions may decide that they can profile this down to 1 if desired, or 1 per type.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Organization',
   *       'http://hl7.org/fhir/StructureDefinition/Practitioner',
   *       'http://hl7.org/fhir/StructureDefinition/PractitionerRole',
   *     ]
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private generalPractitioner?: Reference[] | undefined;

  /**
   * Patient.managingOrganization Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Organization that is the custodian of the patient record
   * - **Definition:** Organization that is the custodian of the patient record.
   * - **Comment:** There is only one managing organization for a specific patient record. Other organizations will have their own Patient record, and may use the Link property to join the records together (or a Person resource which can include confidence ratings for the association).
   * - **Requirements:** Need to know who recognizes this patient record, manages and updates it.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Organization',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private managingOrganization?: Reference | undefined;

  /**
   * Patient.link Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Link to another patient resource that concerns the same actual person
   * - **Definition:** Link to another patient resource that concerns the same actual patient.
   * - **Comment:** There is no assumption that linked patient records have mutual links.
   * - **Requirements:** There are multiple use cases:    * Duplicate patient records due to the clerical errors associated with the difficulties of identifying humans consistently, and  * Distribution of patient information across multiple servers.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..*
   * - **isModifier:** true
   * - **isModifierReason:** This element is labeled as a modifier because it might not be the main Patient resource, and the referenced patient should be used instead of this Patient record. This is when the link.type value is \\&#x27;replaced-by\\&#x27;
   * - **isSummary:** true
   */
  private link?: PatientLinkComponent[] | undefined;


  /**
   * @returns the FHIR resource type as defined by the FHIR specification
   */
  public override resourceType(): FhirResourceType {
    return this.fhirType() as FhirResourceType;
  }

  /**
   * @returns the \`identifier\` property value as a Identifier array
   */
  public getIdentifier(): Identifier[] {
    return this.identifier ?? ([] as Identifier[]);
  }

  /**
   * Assigns the provided Identifier array value to the \`identifier\` property.
   *
   * @param value - the \`identifier\` array value
   * @returns this
   */
  public setIdentifier(value: Identifier[] | undefined): this {
    if (isDefinedList<Identifier>(value)) {
      const optErrMsg = \`Invalid Patient.identifier; Provided value array has an element that is not an instance of Identifier.\`;
      assertFhirTypeList<Identifier>(value, Identifier, optErrMsg);
      this.identifier = value;
    } else {
      this.identifier = undefined;
    }
    return this;
  }

  /**
   * Add the provided Identifier value to the \`identifier\` array property.
   *
   * @param value - the \`identifier\` value
   * @returns this
   */
  public addIdentifier(value: Identifier | undefined): this {
    if (isDefined<Identifier>(value)) {
      const optErrMsg = \`Invalid Patient.identifier; Provided element is not an instance of Identifier.\`;
      assertFhirType<Identifier>(value, Identifier, optErrMsg);
      this.initIdentifier();
      this.identifier?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`identifier\` property exists and has a value; \`false\` otherwise
   */
  public hasIdentifier(): boolean {
    return isDefinedList<Identifier>(this.identifier) && this.identifier.some((item: Identifier) => !item.isEmpty());
  }

  /**
   * Initialize the \`identifier\` property
   */
  private initIdentifier(): void {
    if(!this.hasIdentifier()) {
      this.identifier = [] as Identifier[];
    }
  }

  /**
   * @returns the \`active\` property value as a BooleanType object if defined; else an empty BooleanType object
   */
  public getActiveElement(): BooleanType {
    return this.active ?? new BooleanType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`active\` property.
   *
   * @param element - the \`active\` value
   * @returns this
   */
  public setActiveElement(element: BooleanType | undefined): this {
    if (isDefined<BooleanType>(element)) {
      const optErrMsg = \`Invalid Patient.active; Provided element is not an instance of BooleanType.\`;
      assertFhirType<BooleanType>(element, BooleanType, optErrMsg);
      this.active = element;
    } else {
      this.active = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`active\` property exists and has a value; \`false\` otherwise
   */
  public hasActiveElement(): boolean {
    return isDefined<BooleanType>(this.active) && !this.active.isEmpty();
  }

  /**
   * @returns the \`active\` property value as a fhirBoolean if defined; else undefined
   */
  public getActive(): fhirBoolean | undefined {
    return this.active?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`active\` property.
   *
   * @param value - the \`active\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setActive(value: fhirBoolean | undefined): this {
    if (isDefined<fhirBoolean>(value)) {
      const optErrMsg = \`Invalid Patient.active (\${String(value)})\`;
      this.active = new BooleanType(parseFhirPrimitiveData(value, fhirBooleanSchema, optErrMsg));
    } else {
      this.active = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`active\` property exists and has a value; \`false\` otherwise
   */
  public hasActive(): boolean {
    return this.hasActiveElement();
  }

  /**
   * @returns the \`name\` property value as a HumanName array
   */
  public getName(): HumanName[] {
    return this.name ?? ([] as HumanName[]);
  }

  /**
   * Assigns the provided HumanName array value to the \`name\` property.
   *
   * @param value - the \`name\` array value
   * @returns this
   */
  public setName(value: HumanName[] | undefined): this {
    if (isDefinedList<HumanName>(value)) {
      const optErrMsg = \`Invalid Patient.name; Provided value array has an element that is not an instance of HumanName.\`;
      assertFhirTypeList<HumanName>(value, HumanName, optErrMsg);
      this.name = value;
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * Add the provided HumanName value to the \`name\` array property.
   *
   * @param value - the \`name\` value
   * @returns this
   */
  public addName(value: HumanName | undefined): this {
    if (isDefined<HumanName>(value)) {
      const optErrMsg = \`Invalid Patient.name; Provided element is not an instance of HumanName.\`;
      assertFhirType<HumanName>(value, HumanName, optErrMsg);
      this.initName();
      this.name?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`name\` property exists and has a value; \`false\` otherwise
   */
  public hasName(): boolean {
    return isDefinedList<HumanName>(this.name) && this.name.some((item: HumanName) => !item.isEmpty());
  }

  /**
   * Initialize the \`name\` property
   */
  private initName(): void {
    if(!this.hasName()) {
      this.name = [] as HumanName[];
    }
  }

  /**
   * @returns the \`telecom\` property value as a ContactPoint array
   */
  public getTelecom(): ContactPoint[] {
    return this.telecom ?? ([] as ContactPoint[]);
  }

  /**
   * Assigns the provided ContactPoint array value to the \`telecom\` property.
   *
   * @param value - the \`telecom\` array value
   * @returns this
   */
  public setTelecom(value: ContactPoint[] | undefined): this {
    if (isDefinedList<ContactPoint>(value)) {
      const optErrMsg = \`Invalid Patient.telecom; Provided value array has an element that is not an instance of ContactPoint.\`;
      assertFhirTypeList<ContactPoint>(value, ContactPoint, optErrMsg);
      this.telecom = value;
    } else {
      this.telecom = undefined;
    }
    return this;
  }

  /**
   * Add the provided ContactPoint value to the \`telecom\` array property.
   *
   * @param value - the \`telecom\` value
   * @returns this
   */
  public addTelecom(value: ContactPoint | undefined): this {
    if (isDefined<ContactPoint>(value)) {
      const optErrMsg = \`Invalid Patient.telecom; Provided element is not an instance of ContactPoint.\`;
      assertFhirType<ContactPoint>(value, ContactPoint, optErrMsg);
      this.initTelecom();
      this.telecom?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`telecom\` property exists and has a value; \`false\` otherwise
   */
  public hasTelecom(): boolean {
    return isDefinedList<ContactPoint>(this.telecom) && this.telecom.some((item: ContactPoint) => !item.isEmpty());
  }

  /**
   * Initialize the \`telecom\` property
   */
  private initTelecom(): void {
    if(!this.hasTelecom()) {
      this.telecom = [] as ContactPoint[];
    }
  }

  /**
   * @returns the \`gender\` property value as a EnumCodeType if defined; else undefined
   */
  public getGenderEnumType(): EnumCodeType | undefined {
    return this.gender;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`gender\` property.
   *
   * @param enumType - the \`gender\` value
   * @returns this
   */
  public setGenderEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid Patient.gender';
      assertEnumCodeType<AdministrativeGenderEnum>(enumType, AdministrativeGenderEnum, errMsgPrefix);
      this.gender = enumType;
    } else {
      this.gender = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`gender\` property exists and has a value; \`false\` otherwise
   */
  public hasGenderEnumType(): boolean {
    return isDefined<EnumCodeType>(this.gender) && !this.gender.isEmpty() && this.gender.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`gender\` property value as a CodeType if defined; else undefined
   */
  public getGenderElement(): CodeType | undefined {
    if (this.gender === undefined) {
      return undefined;
    }
    return this.gender as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`gender\` property.
   *
   * @param element - the \`gender\` value
   * @returns this
   */
  public setGenderElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Patient.gender; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.gender = new EnumCodeType(element, this.administrativeGenderEnum);
    } else {
      this.gender = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`gender\` property exists and has a value; \`false\` otherwise
   */
  public hasGenderElement(): boolean {
    return this.hasGenderEnumType();
  }

  /**
   * @returns the \`gender\` property value as a fhirCode if defined; else undefined
   */
  public getGender(): fhirCode | undefined {
    if (this.gender === undefined) {
      return undefined;
    }
    return this.gender.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`gender\` property.
   *
   * @param value - the \`gender\` value
   * @returns this
   */
  public setGender(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Patient.gender; Provided value is not an instance of fhirCode.\`;
      this.gender = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.administrativeGenderEnum);
    } else {
      this.gender = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`gender\` property exists and has a value; \`false\` otherwise
   */
  public hasGender(): boolean {
    return this.hasGenderEnumType();
  }

  /**
   * @returns the \`birthDate\` property value as a DateType object if defined; else an empty DateType object
   */
  public getBirthDateElement(): DateType {
    return this.birthDate ?? new DateType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`birthDate\` property.
   *
   * @param element - the \`birthDate\` value
   * @returns this
   */
  public setBirthDateElement(element: DateType | undefined): this {
    if (isDefined<DateType>(element)) {
      const optErrMsg = \`Invalid Patient.birthDate; Provided element is not an instance of DateType.\`;
      assertFhirType<DateType>(element, DateType, optErrMsg);
      this.birthDate = element;
    } else {
      this.birthDate = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`birthDate\` property exists and has a value; \`false\` otherwise
   */
  public hasBirthDateElement(): boolean {
    return isDefined<DateType>(this.birthDate) && !this.birthDate.isEmpty();
  }

  /**
   * @returns the \`birthDate\` property value as a fhirDate if defined; else undefined
   */
  public getBirthDate(): fhirDate | undefined {
    return this.birthDate?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`birthDate\` property.
   *
   * @param value - the \`birthDate\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setBirthDate(value: fhirDate | undefined): this {
    if (isDefined<fhirDate>(value)) {
      const optErrMsg = \`Invalid Patient.birthDate (\${String(value)})\`;
      this.birthDate = new DateType(parseFhirPrimitiveData(value, fhirDateSchema, optErrMsg));
    } else {
      this.birthDate = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`birthDate\` property exists and has a value; \`false\` otherwise
   */
  public hasBirthDate(): boolean {
    return this.hasBirthDateElement();
  }

  /**
   * @returns the \`deceased\` property value as a DataType object if defined; else undefined
   */
  public getDeceased(): DataType | undefined {
    return this.deceased;
  }

  /**
   * Assigns the provided DataType object value to the \`deceased\` property.
   *
   * @decorator \`@ChoiceDataTypes('Patient.deceased[x]')\`
   *
   * @param value - the \`deceased\` object value
   * @returns this
   */
  @ChoiceDataTypes('Patient.deceased[x]')
  public setDeceased(value: DataType | undefined): this {
    if (isDefined<DataType>(value)) {
      // assertFhirType<DataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.deceased = value;
    } else {
      this.deceased = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`deceased\` property exists and has a value; \`false\` otherwise
   */
  public hasDeceased(): boolean {
    return isDefined<DataType>(this.deceased) && !this.deceased.isEmpty();
  }

  // *** NOTE ***
  // Next "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the \`deceased\` property value as a BooleanType object if defined; else undefined
   */
  public getDeceasedBooleanType(): BooleanType | undefined {
    if (!isDefined<DataType | undefined>(this.deceased)) {
      return undefined;
    }
    if (!(this.deceased instanceof BooleanType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Patient.deceased[x]: Expected BooleanType but encountered \${this.deceased.fhirType()}\`,
      );
    }
    return this.deceased;
  }

  /**
   * @returns \`true\` if the \`deceased\` property exists as a BooleanType and has a value; \`false\` otherwise
   */
  public hasDeceasedBooleanType(): boolean {
    return this.hasDeceased() && this.deceased instanceof BooleanType;
  }

  /**
   * @returns the \`deceased\` property value as a DateTimeType object if defined; else undefined
   */
  public getDeceasedDateTimeType(): DateTimeType | undefined {
    if (!isDefined<DataType | undefined>(this.deceased)) {
      return undefined;
    }
    if (!(this.deceased instanceof DateTimeType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Patient.deceased[x]: Expected DateTimeType but encountered \${this.deceased.fhirType()}\`,
      );
    }
    return this.deceased;
  }

  /**
   * @returns \`true\` if the \`deceased\` property exists as a DateTimeType and has a value; \`false\` otherwise
   */
  public hasDeceasedDateTimeType(): boolean {
    return this.hasDeceased() && this.deceased instanceof DateTimeType;
  }

  /**
   * @returns the \`address\` property value as a Address array
   */
  public getAddress(): Address[] {
    return this.address ?? ([] as Address[]);
  }

  /**
   * Assigns the provided Address array value to the \`address\` property.
   *
   * @param value - the \`address\` array value
   * @returns this
   */
  public setAddress(value: Address[] | undefined): this {
    if (isDefinedList<Address>(value)) {
      const optErrMsg = \`Invalid Patient.address; Provided value array has an element that is not an instance of Address.\`;
      assertFhirTypeList<Address>(value, Address, optErrMsg);
      this.address = value;
    } else {
      this.address = undefined;
    }
    return this;
  }

  /**
   * Add the provided Address value to the \`address\` array property.
   *
   * @param value - the \`address\` value
   * @returns this
   */
  public addAddress(value: Address | undefined): this {
    if (isDefined<Address>(value)) {
      const optErrMsg = \`Invalid Patient.address; Provided element is not an instance of Address.\`;
      assertFhirType<Address>(value, Address, optErrMsg);
      this.initAddress();
      this.address?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`address\` property exists and has a value; \`false\` otherwise
   */
  public hasAddress(): boolean {
    return isDefinedList<Address>(this.address) && this.address.some((item: Address) => !item.isEmpty());
  }

  /**
   * Initialize the \`address\` property
   */
  private initAddress(): void {
    if(!this.hasAddress()) {
      this.address = [] as Address[];
    }
  }

  /**
   * @returns the \`maritalStatus\` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getMaritalStatus(): CodeableConcept {
    return this.maritalStatus ?? new CodeableConcept();
  }

  /**
   * Assigns the provided MaritalStatus object value to the \`maritalStatus\` property.
   *
   * @param value - the \`maritalStatus\` object value
   * @returns this
   */
  public setMaritalStatus(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Patient.maritalStatus; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.maritalStatus = value;
    } else {
      this.maritalStatus = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`maritalStatus\` property exists and has a value; \`false\` otherwise
   */
  public hasMaritalStatus(): boolean {
    return isDefined<CodeableConcept>(this.maritalStatus) && !this.maritalStatus.isEmpty();
  }

  /**
   * @returns the \`multipleBirth\` property value as a DataType object if defined; else undefined
   */
  public getMultipleBirth(): DataType | undefined {
    return this.multipleBirth;
  }

  /**
   * Assigns the provided DataType object value to the \`multipleBirth\` property.
   *
   * @decorator \`@ChoiceDataTypes('Patient.multipleBirth[x]')\`
   *
   * @param value - the \`multipleBirth\` object value
   * @returns this
   */
  @ChoiceDataTypes('Patient.multipleBirth[x]')
  public setMultipleBirth(value: DataType | undefined): this {
    if (isDefined<DataType>(value)) {
      // assertFhirType<DataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.multipleBirth = value;
    } else {
      this.multipleBirth = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`multipleBirth\` property exists and has a value; \`false\` otherwise
   */
  public hasMultipleBirth(): boolean {
    return isDefined<DataType>(this.multipleBirth) && !this.multipleBirth.isEmpty();
  }

  // *** NOTE ***
  // Next "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the \`multipleBirth\` property value as a BooleanType object if defined; else undefined
   */
  public getMultipleBirthBooleanType(): BooleanType | undefined {
    if (!isDefined<DataType | undefined>(this.multipleBirth)) {
      return undefined;
    }
    if (!(this.multipleBirth instanceof BooleanType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Patient.multipleBirth[x]: Expected BooleanType but encountered \${this.multipleBirth.fhirType()}\`,
      );
    }
    return this.multipleBirth;
  }

  /**
   * @returns \`true\` if the \`multipleBirth\` property exists as a BooleanType and has a value; \`false\` otherwise
   */
  public hasMultipleBirthBooleanType(): boolean {
    return this.hasMultipleBirth() && this.multipleBirth instanceof BooleanType;
  }

  /**
   * @returns the \`multipleBirth\` property value as a IntegerType object if defined; else undefined
   */
  public getMultipleBirthIntegerType(): IntegerType | undefined {
    if (!isDefined<DataType | undefined>(this.multipleBirth)) {
      return undefined;
    }
    if (!(this.multipleBirth instanceof IntegerType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Patient.multipleBirth[x]: Expected IntegerType but encountered \${this.multipleBirth.fhirType()}\`,
      );
    }
    return this.multipleBirth;
  }

  /**
   * @returns \`true\` if the \`multipleBirth\` property exists as a IntegerType and has a value; \`false\` otherwise
   */
  public hasMultipleBirthIntegerType(): boolean {
    return this.hasMultipleBirth() && this.multipleBirth instanceof IntegerType;
  }

  /**
   * @returns the \`photo\` property value as a Attachment array
   */
  public getPhoto(): Attachment[] {
    return this.photo ?? ([] as Attachment[]);
  }

  /**
   * Assigns the provided Attachment array value to the \`photo\` property.
   *
   * @param value - the \`photo\` array value
   * @returns this
   */
  public setPhoto(value: Attachment[] | undefined): this {
    if (isDefinedList<Attachment>(value)) {
      const optErrMsg = \`Invalid Patient.photo; Provided value array has an element that is not an instance of Attachment.\`;
      assertFhirTypeList<Attachment>(value, Attachment, optErrMsg);
      this.photo = value;
    } else {
      this.photo = undefined;
    }
    return this;
  }

  /**
   * Add the provided Attachment value to the \`photo\` array property.
   *
   * @param value - the \`photo\` value
   * @returns this
   */
  public addPhoto(value: Attachment | undefined): this {
    if (isDefined<Attachment>(value)) {
      const optErrMsg = \`Invalid Patient.photo; Provided element is not an instance of Attachment.\`;
      assertFhirType<Attachment>(value, Attachment, optErrMsg);
      this.initPhoto();
      this.photo?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`photo\` property exists and has a value; \`false\` otherwise
   */
  public hasPhoto(): boolean {
    return isDefinedList<Attachment>(this.photo) && this.photo.some((item: Attachment) => !item.isEmpty());
  }

  /**
   * Initialize the \`photo\` property
   */
  private initPhoto(): void {
    if(!this.hasPhoto()) {
      this.photo = [] as Attachment[];
    }
  }

  /**
   * @returns the \`contact\` property value as a PatientContactComponent array
   */
  public getContact(): PatientContactComponent[] {
    return this.contact ?? ([] as PatientContactComponent[]);
  }

  /**
   * Assigns the provided PatientContactComponent array value to the \`contact\` property.
   *
   * @param value - the \`contact\` array value
   * @returns this
   */
  public setContact(value: PatientContactComponent[] | undefined): this {
    if (isDefinedList<PatientContactComponent>(value)) {
      const optErrMsg = \`Invalid Patient.contact; Provided value array has an element that is not an instance of PatientContactComponent.\`;
      assertFhirTypeList<PatientContactComponent>(value, PatientContactComponent, optErrMsg);
      this.contact = value;
    } else {
      this.contact = undefined;
    }
    return this;
  }

  /**
   * Add the provided PatientContactComponent value to the \`contact\` array property.
   *
   * @param value - the \`contact\` value
   * @returns this
   */
  public addContact(value: PatientContactComponent | undefined): this {
    if (isDefined<PatientContactComponent>(value)) {
      const optErrMsg = \`Invalid Patient.contact; Provided element is not an instance of PatientContactComponent.\`;
      assertFhirType<PatientContactComponent>(value, PatientContactComponent, optErrMsg);
      this.initContact();
      this.contact?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`contact\` property exists and has a value; \`false\` otherwise
   */
  public hasContact(): boolean {
    return isDefinedList<PatientContactComponent>(this.contact) && this.contact.some((item: PatientContactComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`contact\` property
   */
  private initContact(): void {
    if(!this.hasContact()) {
      this.contact = [] as PatientContactComponent[];
    }
  }

  /**
   * @returns the \`communication\` property value as a PatientCommunicationComponent array
   */
  public getCommunication(): PatientCommunicationComponent[] {
    return this.communication ?? ([] as PatientCommunicationComponent[]);
  }

  /**
   * Assigns the provided PatientCommunicationComponent array value to the \`communication\` property.
   *
   * @param value - the \`communication\` array value
   * @returns this
   */
  public setCommunication(value: PatientCommunicationComponent[] | undefined): this {
    if (isDefinedList<PatientCommunicationComponent>(value)) {
      const optErrMsg = \`Invalid Patient.communication; Provided value array has an element that is not an instance of PatientCommunicationComponent.\`;
      assertFhirTypeList<PatientCommunicationComponent>(value, PatientCommunicationComponent, optErrMsg);
      this.communication = value;
    } else {
      this.communication = undefined;
    }
    return this;
  }

  /**
   * Add the provided PatientCommunicationComponent value to the \`communication\` array property.
   *
   * @param value - the \`communication\` value
   * @returns this
   */
  public addCommunication(value: PatientCommunicationComponent | undefined): this {
    if (isDefined<PatientCommunicationComponent>(value)) {
      const optErrMsg = \`Invalid Patient.communication; Provided element is not an instance of PatientCommunicationComponent.\`;
      assertFhirType<PatientCommunicationComponent>(value, PatientCommunicationComponent, optErrMsg);
      this.initCommunication();
      this.communication?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`communication\` property exists and has a value; \`false\` otherwise
   */
  public hasCommunication(): boolean {
    return isDefinedList<PatientCommunicationComponent>(this.communication) && this.communication.some((item: PatientCommunicationComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`communication\` property
   */
  private initCommunication(): void {
    if(!this.hasCommunication()) {
      this.communication = [] as PatientCommunicationComponent[];
    }
  }

  /**
   * @returns the \`generalPractitioner\` property value as a Reference array
   */
  public getGeneralPractitioner(): Reference[] {
    return this.generalPractitioner ?? ([] as Reference[]);
  }

  /**
   * Assigns the provided Reference array value to the \`generalPractitioner\` property.
   *
   * @decorator \`@ReferenceTargets('Patient.generalPractitioner', ['Organization','Practitioner','PractitionerRole',])\`
   *
   * @param value - the \`generalPractitioner\` array value
   * @returns this
   */
  @ReferenceTargets('Patient.generalPractitioner', [
    'Organization',
  
    'Practitioner',
  
    'PractitionerRole',
  ])
  public setGeneralPractitioner(value: Reference[] | undefined): this {
    if (isDefinedList<Reference>(value)) {
      // assertFhirTypeList<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.generalPractitioner = value;
    } else {
      this.generalPractitioner = undefined;
    }
    return this;
  }

  /**
   * Add the provided Reference value to the \`generalPractitioner\` array property.
   *
   * @decorator \`@ReferenceTargets('Patient.generalPractitioner', ['Organization','Practitioner','PractitionerRole',])\`
   *
   * @param value - the \`generalPractitioner\` value
   * @returns this
   */
  @ReferenceTargets('Patient.generalPractitioner', [
    'Organization',
  
    'Practitioner',
  
    'PractitionerRole',
  ])
  public addGeneralPractitioner(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.initGeneralPractitioner();
      this.generalPractitioner?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`generalPractitioner\` property exists and has a value; \`false\` otherwise
   */
  public hasGeneralPractitioner(): boolean {
    return isDefinedList<Reference>(this.generalPractitioner) && this.generalPractitioner.some((item: Reference) => !item.isEmpty());
  }

  /**
   * Initialize the \`generalPractitioner\` property
   */
  private initGeneralPractitioner(): void {
    if (!this.hasGeneralPractitioner()) {
      this.generalPractitioner = [] as Reference[];
    }
  }

  /**
   * @returns the \`managingOrganization\` property value as a Reference object; else an empty Reference object
   */
  public getManagingOrganization(): Reference {
    return this.managingOrganization ?? new Reference();
  }

  /**
   * Assigns the provided ManagingOrganization object value to the \`managingOrganization\` property.
   *
   * @decorator \`@ReferenceTargets('Patient.managingOrganization', ['Organization',])\`
   *
   * @param value - the \`managingOrganization\` object value
   * @returns this
   */
  @ReferenceTargets('Patient.managingOrganization', [
    'Organization',
  ])
  public setManagingOrganization(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.managingOrganization = value;
    } else {
      this.managingOrganization = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`managingOrganization\` property exists and has a value; \`false\` otherwise
   */
  public hasManagingOrganization(): boolean {
    return isDefined<Reference>(this.managingOrganization) && !this.managingOrganization.isEmpty();
  }

  /**
   * @returns the \`link\` property value as a PatientLinkComponent array
   */
  public getLink(): PatientLinkComponent[] {
    return this.link ?? ([] as PatientLinkComponent[]);
  }

  /**
   * Assigns the provided PatientLinkComponent array value to the \`link\` property.
   *
   * @param value - the \`link\` array value
   * @returns this
   */
  public setLink(value: PatientLinkComponent[] | undefined): this {
    if (isDefinedList<PatientLinkComponent>(value)) {
      const optErrMsg = \`Invalid Patient.link; Provided value array has an element that is not an instance of PatientLinkComponent.\`;
      assertFhirTypeList<PatientLinkComponent>(value, PatientLinkComponent, optErrMsg);
      this.link = value;
    } else {
      this.link = undefined;
    }
    return this;
  }

  /**
   * Add the provided PatientLinkComponent value to the \`link\` array property.
   *
   * @param value - the \`link\` value
   * @returns this
   */
  public addLink(value: PatientLinkComponent | undefined): this {
    if (isDefined<PatientLinkComponent>(value)) {
      const optErrMsg = \`Invalid Patient.link; Provided element is not an instance of PatientLinkComponent.\`;
      assertFhirType<PatientLinkComponent>(value, PatientLinkComponent, optErrMsg);
      this.initLink();
      this.link?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`link\` property exists and has a value; \`false\` otherwise
   */
  public hasLink(): boolean {
    return isDefinedList<PatientLinkComponent>(this.link) && this.link.some((item: PatientLinkComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`link\` property
   */
  private initLink(): void {
    if(!this.hasLink()) {
      this.link = [] as PatientLinkComponent[];
    }
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Patient';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.identifier,
      this.active,
      this.name,
      this.telecom,
      this.gender,
      this.birthDate,
      this.deceased,
      this.address,
      this.maritalStatus,
      this.multipleBirth,
      this.photo,
      this.contact,
      this.communication,
      this.generalPractitioner,
      this.managingOrganization,
      this.link,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Patient {
    const dest = new Patient();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Patient): void {
    super.copyValues(dest);
    const identifierList = copyListValues<Identifier>(this.identifier);
    dest.identifier = identifierList.length === 0 ? undefined : identifierList;
    dest.active = this.active?.copy();
    const nameList = copyListValues<HumanName>(this.name);
    dest.name = nameList.length === 0 ? undefined : nameList;
    const telecomList = copyListValues<ContactPoint>(this.telecom);
    dest.telecom = telecomList.length === 0 ? undefined : telecomList;
    dest.gender = this.gender?.copy();
    dest.birthDate = this.birthDate?.copy();
    dest.deceased = this.deceased?.copy();
    const addressList = copyListValues<Address>(this.address);
    dest.address = addressList.length === 0 ? undefined : addressList;
    dest.maritalStatus = this.maritalStatus?.copy();
    dest.multipleBirth = this.multipleBirth?.copy();
    const photoList = copyListValues<Attachment>(this.photo);
    dest.photo = photoList.length === 0 ? undefined : photoList;
    const contactList = copyListValues<PatientContactComponent>(this.contact);
    dest.contact = contactList.length === 0 ? undefined : contactList;
    const communicationList = copyListValues<PatientCommunicationComponent>(this.communication);
    dest.communication = communicationList.length === 0 ? undefined : communicationList;
    const generalPractitionerList = copyListValues<Reference>(this.generalPractitioner);
    dest.generalPractitioner = generalPractitionerList.length === 0 ? undefined : generalPractitionerList;
    dest.managingOrganization = this.managingOrganization?.copy();
    const linkList = copyListValues<PatientLinkComponent>(this.link);
    dest.link = linkList.length === 0 ? undefined : linkList;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasIdentifier()) {
      setFhirComplexListJson(this.getIdentifier(), 'identifier', jsonObj);
    }

    if (this.hasActiveElement()) {
      setFhirPrimitiveJson<fhirBoolean>(this.getActiveElement(), 'active', jsonObj);
    }

    if (this.hasName()) {
      setFhirComplexListJson(this.getName(), 'name', jsonObj);
    }

    if (this.hasTelecom()) {
      setFhirComplexListJson(this.getTelecom(), 'telecom', jsonObj);
    }

    if (this.hasGenderElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getGenderElement()!, 'gender', jsonObj);
    }

    if (this.hasBirthDateElement()) {
      setFhirPrimitiveJson<fhirDate>(this.getBirthDateElement(), 'birthDate', jsonObj);
    }

    if (this.hasDeceased()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getDeceased()!, 'deceased', jsonObj);
    }

    if (this.hasAddress()) {
      setFhirComplexListJson(this.getAddress(), 'address', jsonObj);
    }

    if (this.hasMaritalStatus()) {
      setFhirComplexJson(this.getMaritalStatus(), 'maritalStatus', jsonObj);
    }

    if (this.hasMultipleBirth()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getMultipleBirth()!, 'multipleBirth', jsonObj);
    }

    if (this.hasPhoto()) {
      setFhirComplexListJson(this.getPhoto(), 'photo', jsonObj);
    }

    if (this.hasContact()) {
      setFhirBackboneElementListJson(this.getContact(), 'contact', jsonObj);
    }

    if (this.hasCommunication()) {
      setFhirBackboneElementListJson(this.getCommunication(), 'communication', jsonObj);
    }

    if (this.hasGeneralPractitioner()) {
      setFhirComplexListJson(this.getGeneralPractitioner(), 'generalPractitioner', jsonObj);
    }

    if (this.hasManagingOrganization()) {
      setFhirComplexJson(this.getManagingOrganization(), 'managingOrganization', jsonObj);
    }

    if (this.hasLink()) {
      setFhirBackboneElementListJson(this.getLink(), 'link', jsonObj);
    }

    return jsonObj;
  }
}


/**
 * PatientContactComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** A contact party (e.g. guardian, partner, friend) for the patient
 * - **Definition:** A contact party (e.g. guardian, partner, friend) for the patient.
 * - **Comment:** Contact covers all kinds of contact parties: family members, business contacts, guardians, caregivers. Not applicable to register pedigree and family ties beyond use of having contact.
 * - **Requirements:** Need to track people you can contact about the patient.
 *
 * @category DataModel: Resource
 * @see [FHIR Patient](http://hl7.org/fhir/StructureDefinition/Patient)
 */
export class PatientContactComponent extends BackboneElement {
  constructor() {
    super();

    this.administrativeGenderEnum = new AdministrativeGenderEnum();
  }

  /**
   * Parse the provided \`PatientContactComponent\` JSON to instantiate the PatientContactComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`PatientContactComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to PatientContactComponent
   * @returns PatientContactComponent data model or undefined for \`PatientContactComponent\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): PatientContactComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'PatientContactComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new PatientContactComponent();
    fhirDataTypeParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    

    fieldName = 'relationship';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: CodeableConcept | undefined = fhirDataTypeParser.parser<CodeableConcept>(CodeableConcept, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addRelationship(datatype);
        }
      });
    }

    fieldName = 'name';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: HumanName | undefined = fhirDataTypeParser.parser<HumanName>(HumanName, classJsonObj[fieldName]!, sourceField);
      instance.setName(datatype);
    }

    fieldName = 'telecom';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: ContactPoint | undefined = fhirDataTypeParser.parser<ContactPoint>(ContactPoint, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addTelecom(datatype);
        }
      });
    }

    fieldName = 'address';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Address | undefined = fhirDataTypeParser.parser<Address>(Address, classJsonObj[fieldName]!, sourceField);
      instance.setAddress(datatype);
    }

    fieldName = 'gender';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      instance.setGenderElement(datatype);
    }

    fieldName = 'organization';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = fhirDataTypeParser.parser<Reference>(Reference, classJsonObj[fieldName]!, sourceField);
      instance.setOrganization(datatype);
    }

    fieldName = 'period';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Period | undefined = fhirDataTypeParser.parser<Period>(Period, classJsonObj[fieldName]!, sourceField);
      instance.setPeriod(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Patient.contact.relationship Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The kind of relationship
   * - **Definition:** The nature of the relationship between the patient and the contact person.
   * - **Requirements:** Used to determine which contact person is the most relevant to approach, depending on circumstances.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private relationship?: CodeableConcept[] | undefined;

  /**
   * Patient.contact.name Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A name associated with the contact person
   * - **Definition:** A name associated with the contact person.
   * - **Requirements:** Contact persons need to be identified by name, but it is uncommon to need details about multiple other names for that contact person.
   * - **FHIR Type:** \`HumanName\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private name?: HumanName | undefined;

  /**
   * Patient.contact.telecom Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A contact detail for the person
   * - **Definition:** A contact detail for the person, e.g. a telephone number or an email address.
   * - **Comment:** Contact may have multiple ways to be contacted with different uses or applicable periods.  May need to have options for contacting the person urgently, and also to help with identification.
   * - **Requirements:** People have (primary) ways to contact them in some way such as phone, email.
   * - **FHIR Type:** \`ContactPoint\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private telecom?: ContactPoint[] | undefined;

  /**
   * Patient.contact.address Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Address for the contact person
   * - **Definition:** Address for the contact person.
   * - **Requirements:** Need to keep track where the contact person can be contacted per postal mail or visited.
   * - **FHIR Type:** \`Address\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private address?: Address | undefined;

  /**
   * FHIR CodeSystem: AdministrativeGender
   *
   * @see {@link AdministrativeGenderEnum }
   */
  private readonly administrativeGenderEnum: AdministrativeGenderEnum;

  /**
   * Patient.contact.gender Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** male | female | other | unknown
   * - **Definition:** Administrative Gender - the gender that the contact person is considered to have for administration and record keeping purposes.
   * - **Requirements:** Needed to address the person correctly.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private gender?: EnumCodeType | undefined;

  /**
   * Patient.contact.organization Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Organization that is associated with the contact
   * - **Definition:** Organization on behalf of which the contact is acting or for which the contact is working.
   * - **Requirements:** For guardians or business related contacts, the organization is relevant.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Organization',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private organization?: Reference | undefined;

  /**
   * Patient.contact.period Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The period during which this contact person or organization is valid to be contacted relating to this patient
   * - **Definition:** The period during which this contact person or organization is valid to be contacted relating to this patient.
   * - **FHIR Type:** \`Period\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private period?: Period | undefined;


  /**
   * @returns the \`relationship\` property value as a CodeableConcept array
   */
  public getRelationship(): CodeableConcept[] {
    return this.relationship ?? ([] as CodeableConcept[]);
  }

  /**
   * Assigns the provided CodeableConcept array value to the \`relationship\` property.
   *
   * @param value - the \`relationship\` array value
   * @returns this
   */
  public setRelationship(value: CodeableConcept[] | undefined): this {
    if (isDefinedList<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Patient.contact.relationship; Provided value array has an element that is not an instance of CodeableConcept.\`;
      assertFhirTypeList<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.relationship = value;
    } else {
      this.relationship = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeableConcept value to the \`relationship\` array property.
   *
   * @param value - the \`relationship\` value
   * @returns this
   */
  public addRelationship(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Patient.contact.relationship; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.initRelationship();
      this.relationship?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`relationship\` property exists and has a value; \`false\` otherwise
   */
  public hasRelationship(): boolean {
    return isDefinedList<CodeableConcept>(this.relationship) && this.relationship.some((item: CodeableConcept) => !item.isEmpty());
  }

  /**
   * Initialize the \`relationship\` property
   */
  private initRelationship(): void {
    if(!this.hasRelationship()) {
      this.relationship = [] as CodeableConcept[];
    }
  }

  /**
   * @returns the \`name\` property value as a HumanName object if defined; else an empty HumanName object
   */
  public getName(): HumanName {
    return this.name ?? new HumanName();
  }

  /**
   * Assigns the provided Name object value to the \`name\` property.
   *
   * @param value - the \`name\` object value
   * @returns this
   */
  public setName(value: HumanName | undefined): this {
    if (isDefined<HumanName>(value)) {
      const optErrMsg = \`Invalid Patient.contact.name; Provided element is not an instance of HumanName.\`;
      assertFhirType<HumanName>(value, HumanName, optErrMsg);
      this.name = value;
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`name\` property exists and has a value; \`false\` otherwise
   */
  public hasName(): boolean {
    return isDefined<HumanName>(this.name) && !this.name.isEmpty();
  }

  /**
   * @returns the \`telecom\` property value as a ContactPoint array
   */
  public getTelecom(): ContactPoint[] {
    return this.telecom ?? ([] as ContactPoint[]);
  }

  /**
   * Assigns the provided ContactPoint array value to the \`telecom\` property.
   *
   * @param value - the \`telecom\` array value
   * @returns this
   */
  public setTelecom(value: ContactPoint[] | undefined): this {
    if (isDefinedList<ContactPoint>(value)) {
      const optErrMsg = \`Invalid Patient.contact.telecom; Provided value array has an element that is not an instance of ContactPoint.\`;
      assertFhirTypeList<ContactPoint>(value, ContactPoint, optErrMsg);
      this.telecom = value;
    } else {
      this.telecom = undefined;
    }
    return this;
  }

  /**
   * Add the provided ContactPoint value to the \`telecom\` array property.
   *
   * @param value - the \`telecom\` value
   * @returns this
   */
  public addTelecom(value: ContactPoint | undefined): this {
    if (isDefined<ContactPoint>(value)) {
      const optErrMsg = \`Invalid Patient.contact.telecom; Provided element is not an instance of ContactPoint.\`;
      assertFhirType<ContactPoint>(value, ContactPoint, optErrMsg);
      this.initTelecom();
      this.telecom?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`telecom\` property exists and has a value; \`false\` otherwise
   */
  public hasTelecom(): boolean {
    return isDefinedList<ContactPoint>(this.telecom) && this.telecom.some((item: ContactPoint) => !item.isEmpty());
  }

  /**
   * Initialize the \`telecom\` property
   */
  private initTelecom(): void {
    if(!this.hasTelecom()) {
      this.telecom = [] as ContactPoint[];
    }
  }

  /**
   * @returns the \`address\` property value as a Address object if defined; else an empty Address object
   */
  public getAddress(): Address {
    return this.address ?? new Address();
  }

  /**
   * Assigns the provided Address object value to the \`address\` property.
   *
   * @param value - the \`address\` object value
   * @returns this
   */
  public setAddress(value: Address | undefined): this {
    if (isDefined<Address>(value)) {
      const optErrMsg = \`Invalid Patient.contact.address; Provided element is not an instance of Address.\`;
      assertFhirType<Address>(value, Address, optErrMsg);
      this.address = value;
    } else {
      this.address = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`address\` property exists and has a value; \`false\` otherwise
   */
  public hasAddress(): boolean {
    return isDefined<Address>(this.address) && !this.address.isEmpty();
  }

  /**
   * @returns the \`gender\` property value as a EnumCodeType if defined; else undefined
   */
  public getGenderEnumType(): EnumCodeType | undefined {
    return this.gender;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`gender\` property.
   *
   * @param enumType - the \`gender\` value
   * @returns this
   */
  public setGenderEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid Patient.contact.gender';
      assertEnumCodeType<AdministrativeGenderEnum>(enumType, AdministrativeGenderEnum, errMsgPrefix);
      this.gender = enumType;
    } else {
      this.gender = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`gender\` property exists and has a value; \`false\` otherwise
   */
  public hasGenderEnumType(): boolean {
    return isDefined<EnumCodeType>(this.gender) && !this.gender.isEmpty() && this.gender.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`gender\` property value as a CodeType if defined; else undefined
   */
  public getGenderElement(): CodeType | undefined {
    if (this.gender === undefined) {
      return undefined;
    }
    return this.gender as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`gender\` property.
   *
   * @param element - the \`gender\` value
   * @returns this
   */
  public setGenderElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Patient.contact.gender; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.gender = new EnumCodeType(element, this.administrativeGenderEnum);
    } else {
      this.gender = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`gender\` property exists and has a value; \`false\` otherwise
   */
  public hasGenderElement(): boolean {
    return this.hasGenderEnumType();
  }

  /**
   * @returns the \`gender\` property value as a fhirCode if defined; else undefined
   */
  public getGender(): fhirCode | undefined {
    if (this.gender === undefined) {
      return undefined;
    }
    return this.gender.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`gender\` property.
   *
   * @param value - the \`gender\` value
   * @returns this
   */
  public setGender(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Patient.contact.gender; Provided value is not an instance of fhirCode.\`;
      this.gender = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.administrativeGenderEnum);
    } else {
      this.gender = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`gender\` property exists and has a value; \`false\` otherwise
   */
  public hasGender(): boolean {
    return this.hasGenderEnumType();
  }

  /**
   * @returns the \`organization\` property value as a Reference object; else an empty Reference object
   */
  public getOrganization(): Reference {
    return this.organization ?? new Reference();
  }

  /**
   * Assigns the provided Organization object value to the \`organization\` property.
   *
   * @decorator \`@ReferenceTargets('Patient.contact.organization', ['Organization',])\`
   *
   * @param value - the \`organization\` object value
   * @returns this
   */
  @ReferenceTargets('Patient.contact.organization', [
    'Organization',
  ])
  public setOrganization(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.organization = value;
    } else {
      this.organization = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`organization\` property exists and has a value; \`false\` otherwise
   */
  public hasOrganization(): boolean {
    return isDefined<Reference>(this.organization) && !this.organization.isEmpty();
  }

  /**
   * @returns the \`period\` property value as a Period object if defined; else an empty Period object
   */
  public getPeriod(): Period {
    return this.period ?? new Period();
  }

  /**
   * Assigns the provided Period object value to the \`period\` property.
   *
   * @param value - the \`period\` object value
   * @returns this
   */
  public setPeriod(value: Period | undefined): this {
    if (isDefined<Period>(value)) {
      const optErrMsg = \`Invalid Patient.contact.period; Provided element is not an instance of Period.\`;
      assertFhirType<Period>(value, Period, optErrMsg);
      this.period = value;
    } else {
      this.period = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`period\` property exists and has a value; \`false\` otherwise
   */
  public hasPeriod(): boolean {
    return isDefined<Period>(this.period) && !this.period.isEmpty();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Patient.contact';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.relationship,
      this.name,
      this.telecom,
      this.address,
      this.gender,
      this.organization,
      this.period,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): PatientContactComponent {
    const dest = new PatientContactComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: PatientContactComponent): void {
    super.copyValues(dest);
    const relationshipList = copyListValues<CodeableConcept>(this.relationship);
    dest.relationship = relationshipList.length === 0 ? undefined : relationshipList;
    dest.name = this.name?.copy();
    const telecomList = copyListValues<ContactPoint>(this.telecom);
    dest.telecom = telecomList.length === 0 ? undefined : telecomList;
    dest.address = this.address?.copy();
    dest.gender = this.gender?.copy();
    dest.organization = this.organization?.copy();
    dest.period = this.period?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasRelationship()) {
      setFhirComplexListJson(this.getRelationship(), 'relationship', jsonObj);
    }

    if (this.hasName()) {
      setFhirComplexJson(this.getName(), 'name', jsonObj);
    }

    if (this.hasTelecom()) {
      setFhirComplexListJson(this.getTelecom(), 'telecom', jsonObj);
    }

    if (this.hasAddress()) {
      setFhirComplexJson(this.getAddress(), 'address', jsonObj);
    }

    if (this.hasGenderElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getGenderElement()!, 'gender', jsonObj);
    }

    if (this.hasOrganization()) {
      setFhirComplexJson(this.getOrganization(), 'organization', jsonObj);
    }

    if (this.hasPeriod()) {
      setFhirComplexJson(this.getPeriod(), 'period', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * PatientCommunicationComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** A language which may be used to communicate with the patient about his or her health
 * - **Definition:** A language which may be used to communicate with the patient about his or her health.
 * - **Comment:** If no language is specified, this *implies* that the default local language is spoken.  If you need to convey proficiency for multiple modes, then you need multiple Patient.Communication associations.   For animals, language is not a relevant field, and should be absent from the instance. If the Patient does not speak the default local language, then the Interpreter Required Standard can be used to explicitly declare that an interpreter is required.
 * - **Requirements:** If a patient does not speak the local language, interpreters may be required, so languages spoken and proficiency are important things to keep track of both for patient and other persons of interest.
 *
 * @category DataModel: Resource
 * @see [FHIR Patient](http://hl7.org/fhir/StructureDefinition/Patient)
 */
export class PatientCommunicationComponent extends BackboneElement {
  constructor(language: CodeableConcept | null = null) {
    super();

    this.language = null;
    if (isDefined<CodeableConcept>(language)) {
      this.setLanguage(language);
    }
  }

  /**
   * Parse the provided \`PatientCommunicationComponent\` JSON to instantiate the PatientCommunicationComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`PatientCommunicationComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to PatientCommunicationComponent
   * @returns PatientCommunicationComponent data model or undefined for \`PatientCommunicationComponent\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): PatientCommunicationComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'PatientCommunicationComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new PatientCommunicationComponent();
    fhirDataTypeParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    

    const missingReqdProperties: string[] = [];

    fieldName = 'language';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = fhirDataTypeParser.parser<CodeableConcept>(CodeableConcept, classJsonObj[fieldName]!, sourceField);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setLanguage(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'preferred';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const primitiveJsonType = 'boolean';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: BooleanType | undefined = parseBooleanType(dtJson, dtSiblingJson);
      instance.setPreferredElement(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Patient.communication.language Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The language which can be used to communicate with the patient about his or her health
   * - **Definition:** The ISO-639-1 alpha 2 code in lower case for the language, optionally followed by a hyphen and the ISO-3166-1 alpha 2 code for the region in upper case; e.g. "en" for English, or "en-US" for American English versus "en-EN" for England English.
   * - **Comment:** The structure aa-BB with this exact casing is one the most widely used notations for locale. However not all systems actually code this but instead have it as free text. Hence CodeableConcept instead of code as the data type.
   * - **Requirements:** Most systems in multilingual countries will want to convey language. Not all systems actually need the regional dialect.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private language: CodeableConcept | null;

  /**
   * Patient.communication.preferred Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Language preference indicator
   * - **Definition:** Indicates whether or not the patient prefers this language (over other languages he masters up a certain level).
   * - **Comment:** This language is specifically identified for communicating healthcare information.
   * - **Requirements:** People that master multiple languages up to certain level may prefer one or more, i.e. feel more confident in communicating in a particular language making other languages sort of a fall back method.
   * - **FHIR Type:** \`boolean\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private preferred?: BooleanType | undefined;


  /**
   * @returns the \`language\` property value as a CodeableConcept object if defined; else null
   */
  public getLanguage(): CodeableConcept | null {
    return this.language;
  }

  /**
   * Assigns the provided CodeableConcept object value to the \`language\` property.
   *
   * @param value - the \`language\` object value
   * @returns this
   */
  public setLanguage(value: CodeableConcept): this {
    assertIsDefined<CodeableConcept>(value, \`Patient.communication.language is required\`);
    const optErrMsg = \`Invalid Patient.communication.language; Provided element is not an instance of CodeableConcept.\`;
    assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
    this.language = value;
    return this;
  }

  /**
   * @returns \`true\` if the \`language\` property exists and has a value; \`false\` otherwise
   */
  public hasLanguage(): boolean {
    return isDefined<CodeableConcept>(this.language) && !this.language.isEmpty();
  }

  /**
   * @returns the \`preferred\` property value as a BooleanType object if defined; else an empty BooleanType object
   */
  public getPreferredElement(): BooleanType {
    return this.preferred ?? new BooleanType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`preferred\` property.
   *
   * @param element - the \`preferred\` value
   * @returns this
   */
  public setPreferredElement(element: BooleanType | undefined): this {
    if (isDefined<BooleanType>(element)) {
      const optErrMsg = \`Invalid Patient.communication.preferred; Provided element is not an instance of BooleanType.\`;
      assertFhirType<BooleanType>(element, BooleanType, optErrMsg);
      this.preferred = element;
    } else {
      this.preferred = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`preferred\` property exists and has a value; \`false\` otherwise
   */
  public hasPreferredElement(): boolean {
    return isDefined<BooleanType>(this.preferred) && !this.preferred.isEmpty();
  }

  /**
   * @returns the \`preferred\` property value as a fhirBoolean if defined; else undefined
   */
  public getPreferred(): fhirBoolean | undefined {
    return this.preferred?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`preferred\` property.
   *
   * @param value - the \`preferred\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setPreferred(value: fhirBoolean | undefined): this {
    if (isDefined<fhirBoolean>(value)) {
      const optErrMsg = \`Invalid Patient.communication.preferred (\${String(value)})\`;
      this.preferred = new BooleanType(parseFhirPrimitiveData(value, fhirBooleanSchema, optErrMsg));
    } else {
      this.preferred = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`preferred\` property exists and has a value; \`false\` otherwise
   */
  public hasPreferred(): boolean {
    return this.hasPreferredElement();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Patient.communication';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.language,
      this.preferred,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): PatientCommunicationComponent {
    const dest = new PatientCommunicationComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: PatientCommunicationComponent): void {
    super.copyValues(dest);
    dest.language = this.language ? this.language.copy() : null;
    dest.preferred = this.preferred?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasLanguage()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirComplexJson(this.getLanguage()!, 'language', jsonObj);
    } else {
      missingReqdProperties.push(\`Patient.communication.language\`);
    }

    if (this.hasPreferredElement()) {
      setFhirPrimitiveJson<fhirBoolean>(this.getPreferredElement(), 'preferred', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

/**
 * PatientLinkComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Link to another patient resource that concerns the same actual person
 * - **Definition:** Link to another patient resource that concerns the same actual patient.
 * - **Comment:** There is no assumption that linked patient records have mutual links.
 * - **Requirements:** There are multiple use cases:    * Duplicate patient records due to the clerical errors associated with the difficulties of identifying humans consistently, and  * Distribution of patient information across multiple servers.
 *
 * @category DataModel: Resource
 * @see [FHIR Patient](http://hl7.org/fhir/StructureDefinition/Patient)
 */
export class PatientLinkComponent extends BackboneElement {
  constructor(other: Reference | null = null, type_: EnumCodeType | CodeType | null = null) {
    super();

    this.linkTypeEnum = new LinkTypeEnum();

    this.other = null;
    if (isDefined<Reference>(other)) {
      this.setOther(other);
    }

    this.type_ = constructorCodeValueAsEnumCodeType<LinkTypeEnum>(
      type_,
      LinkTypeEnum,
      this.linkTypeEnum,
      '.type',
    );
  }

  /**
   * Parse the provided \`PatientLinkComponent\` JSON to instantiate the PatientLinkComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`PatientLinkComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to PatientLinkComponent
   * @returns PatientLinkComponent data model or undefined for \`PatientLinkComponent\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): PatientLinkComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'PatientLinkComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new PatientLinkComponent();
    fhirDataTypeParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    

    const missingReqdProperties: string[] = [];

    fieldName = 'other';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = fhirDataTypeParser.parser<Reference>(Reference, classJsonObj[fieldName]!, sourceField);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setOther(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'type';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setTypeElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Patient.link.other Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The other patient or related person resource that the link refers to
   * - **Definition:** The other patient resource that the link refers to.
   * - **Comment:** Referencing a RelatedPerson here removes the need to use a Person record to associate a Patient and RelatedPerson as the same individual.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Patient',
   *       'http://hl7.org/fhir/StructureDefinition/RelatedPerson',
   *     ]
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private other: Reference | null;

  /**
   * FHIR CodeSystem: LinkType
   *
   * @see {@link LinkTypeEnum }
   */
  private readonly linkTypeEnum: LinkTypeEnum;

  /**
   * Patient.link.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** replaced-by | replaces | refer | seealso
   * - **Definition:** The type of link between this patient resource and another patient resource.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private type_: EnumCodeType | null;


  /**
   * @returns the \`other\` property value as a Reference object if defined; else null
   */
  public getOther(): Reference | null {
    return this.other;
  }

  /**
   * Assigns the provided Other object value to the \`other\` property.
   *
   * @decorator \`@ReferenceTargets('Patient.link.other', ['Patient','RelatedPerson',])\`
   *
   * @param value - the \`other\` object value
   * @returns this
   */
  @ReferenceTargets('Patient.link.other', [
    'Patient',
  
    'RelatedPerson',
  ])
  public setOther(value: Reference): this {
    assertIsDefined<Reference>(value, \`Patient.link.other is required\`);
    // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
    this.other = value;
    return this;
  }

  /**
   * @returns \`true\` if the \`other\` property exists and has a value; \`false\` otherwise
   */
  public hasOther(): boolean {
    return isDefined<Reference>(this.other) && !this.other.isEmpty();
  }

  /**
   * @returns the \`type_\` property value as a EnumCodeType if defined; else null
   */
  public getTypeEnumType(): EnumCodeType | null {
    return this.type_;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`type_\` property.
   *
   * @param enumType - the \`type_\` value
   * @returns this
   */
  public setTypeEnumType(enumType: EnumCodeType): this {
    assertIsDefined<EnumCodeType>(enumType, \`Patient.link.type is required\`);
    const errMsgPrefix = \`Invalid Patient.link.type\`;
    assertEnumCodeType<LinkTypeEnum>(enumType, LinkTypeEnum, errMsgPrefix);
    this.type_ = enumType;
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasTypeEnumType(): boolean {
    return isDefined<EnumCodeType>(this.type_) && !this.type_.isEmpty() && this.type_.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`type_\` property value as a CodeType if defined; else null
   */
  public getTypeElement(): CodeType | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_ as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`type_\` property.
   *
   * @param element - the \`type_\` value
   * @returns this
   */
  public setTypeElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, \`Patient.link.type is required\`);
    const optErrMsg = \`Invalid Patient.link.type; Provided value is not an instance of CodeType.\`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.type_ = new EnumCodeType(element, this.linkTypeEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasTypeElement(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the \`type_\` property value as a fhirCode if defined; else null
   */
  public getType(): fhirCode | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`type_\` property.
   *
   * @param value - the \`type_\` value
   * @returns this
   */
  public setType(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, \`Patient.link.type is required\`);
    const optErrMsg = \`Invalid Patient.link.type (\${String(value)})\`;
    this.type_ = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.linkTypeEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasType(): boolean {
    return this.hasTypeEnumType();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Patient.link';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.other,
      this.type_,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): PatientLinkComponent {
    const dest = new PatientLinkComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: PatientLinkComponent): void {
    super.copyValues(dest);
    dest.other = this.other ? this.other.copy() : null;
    dest.type_ = this.type_ ? this.type_.copy() : null;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasOther()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirComplexJson(this.getOther()!, 'other', jsonObj);
    } else {
      missingReqdProperties.push(\`Patient.link.other\`);
    }

    if (this.hasTypeElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getTypeElement()!, 'type', jsonObj);
    } else {
      missingReqdProperties.push(\`Patient.link.type\`);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
",
  "fileExtension": "ts",
  "filename": "Patient",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 73`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "Resource",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * Practitioner Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/Practitioner
 * StructureDefinition.name: Practitioner
 * StructureDefinition.description: A person who is directly or indirectly involved in the provisioning of healthcare.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  BackboneElement,
  BooleanType,
  CodeType,
  DateType,
  EnumCodeType,
  FhirDataTypeParser,
  FhirError,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  REQUIRED_PROPERTIES_DO_NOT_EXIST,
  REQUIRED_PROPERTIES_REQD_IN_JSON,
  assertEnumCodeType,
  assertFhirType,
  assertFhirTypeList,
  assertIsDefined,
  copyListValues,
  fhirBoolean,
  fhirBooleanSchema,
  fhirCode,
  fhirCodeSchema,
  fhirDate,
  fhirDateSchema,
  getPrimitiveTypeJson,
  isDefined,
  isDefinedList,
  isElementEmpty,
  isEmpty,
  parseBooleanType,
  parseCodeType,
  parseDateType,
  parseFhirPrimitiveData,
  setFhirBackboneElementListJson,
  setFhirComplexJson,
  setFhirComplexListJson,
  setFhirPrimitiveJson,
} from '@paq-ts-fhir/fhir-core';
import {
  Address,
  AdministrativeGenderEnum,
  Attachment,
  CodeableConcept,
  ContactPoint,
  DomainResource,
  FhirResourceParser,
  FhirResourceType,
  HumanName,
  Identifier,
  PARSABLE_DATATYPE_MAP,
  Period,
  Reference,
  ReferenceTargets,
} from '../index';

/**
 * Practitioner Class
 *
 * @remarks
 * A person who is directly or indirectly involved in the provisioning of healthcare.
 *
 * Need to track doctors, staff, locums etc. for both healthcare practitioners, funders, etc.
 *
 * **FHIR Specification**
 * - **Short:** A person with a  formal responsibility in the provisioning of healthcare or related services
 * - **Definition:** A person who is directly or indirectly involved in the provisioning of healthcare.
 * - **FHIR Version:** 4.0.1
 *
 * @category DataModel: Resource
 * @see [FHIR Practitioner](http://hl7.org/fhir/StructureDefinition/Practitioner)
 */
export class Practitioner extends DomainResource implements IBase {
  constructor() {
    super();

    this.administrativeGenderEnum = new AdministrativeGenderEnum();
  }

  /**
   * Parse the provided \`Practitioner\` JSON to instantiate the Practitioner data model.
   *
   * @param sourceJson - JSON representing FHIR \`Practitioner\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Practitioner
   * @returns Practitioner data model or undefined for \`Practitioner\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Practitioner | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirResourceParser = new FhirResourceParser(PARSABLE_DATATYPE_MAP);
    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Practitioner';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Practitioner();
    fhirResourceParser.processDomainResourceJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'identifier';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Identifier | undefined = fhirDataTypeParser.parser<Identifier>(Identifier, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addIdentifier(datatype);
        }
      });
    }

    fieldName = 'active';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'boolean';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: BooleanType | undefined = parseBooleanType(dtJson, dtSiblingJson);
      instance.setActiveElement(datatype);
    }

    fieldName = 'name';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: HumanName | undefined = fhirDataTypeParser.parser<HumanName>(HumanName, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addName(datatype);
        }
      });
    }

    fieldName = 'telecom';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: ContactPoint | undefined = fhirDataTypeParser.parser<ContactPoint>(ContactPoint, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addTelecom(datatype);
        }
      });
    }

    fieldName = 'address';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Address | undefined = fhirDataTypeParser.parser<Address>(Address, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addAddress(datatype);
        }
      });
    }

    fieldName = 'gender';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      instance.setGenderElement(datatype);
    }

    fieldName = 'birthDate';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DateType | undefined = parseDateType(dtJson, dtSiblingJson);
      instance.setBirthDateElement(datatype);
    }

    fieldName = 'photo';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Attachment | undefined = fhirDataTypeParser.parser<Attachment>(Attachment, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addPhoto(datatype);
        }
      });
    }

    fieldName = 'qualification';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const componentJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      componentJsonArray.forEach((componentJson: JSON.Value, idx) => {
        const component: PractitionerQualificationComponent | undefined = PractitionerQualificationComponent.parse(componentJson, \`\${sourceField}[\${String(idx)}]\`);
        if (component !== undefined) {
          instance.addQualification(component);
        }
      });
    }

    fieldName = 'communication';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: CodeableConcept | undefined = fhirDataTypeParser.parser<CodeableConcept>(CodeableConcept, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addCommunication(datatype);
        }
      });
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Practitioner.identifier Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** An identifier for the person as this agent
   * - **Definition:** An identifier that applies to this person in this role.
   * - **Requirements:** Often, specific identities are assigned for the agent.
   * - **FHIR Type:** \`Identifier\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private identifier?: Identifier[] | undefined;

  /**
   * Practitioner.active Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Whether this practitioner\\'s record is in active use
   * - **Definition:** Whether this practitioner\\'s record is in active use.
   * - **Comment:** If the practitioner is not in use by one organization, then it should mark the period on the PractitonerRole with an end date (even if they are active) as they may be active in another role.
   * - **Requirements:** Need to be able to mark a practitioner record as not to be used because it was created in error.
   * - **FHIR Type:** \`boolean\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private active?: BooleanType | undefined;

  /**
   * Practitioner.name Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The name(s) associated with the practitioner
   * - **Definition:** The name(s) associated with the practitioner.
   * - **Comment:** The selection of the use property should ensure that there is a single usual name specified, and others use the nickname (alias), old, or other values as appropriate.   In general, select the value to be used in the ResourceReference.display based on this: 1. There is more than 1 name 2. Use = usual 3. Period is current to the date of the usage 4. Use = official 5. Other order as decided by internal business rules.
   * - **Requirements:** The name(s) that a Practitioner is known by. Where there are multiple, the name that the practitioner is usually known as should be used in the display.
   * - **FHIR Type:** \`HumanName\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private name?: HumanName[] | undefined;

  /**
   * Practitioner.telecom Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A contact detail for the practitioner (that apply to all roles)
   * - **Definition:** A contact detail for the practitioner, e.g. a telephone number or an email address.
   * - **Comment:** Person may have multiple ways to be contacted with different uses or applicable periods.  May need to have options for contacting the person urgently and to help with identification.  These typically will have home numbers, or mobile numbers that are not role specific.
   * - **Requirements:** Need to know how to reach a practitioner independent to any roles the practitioner may have.
   * - **FHIR Type:** \`ContactPoint\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private telecom?: ContactPoint[] | undefined;

  /**
   * Practitioner.address Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Address(es) of the practitioner that are not role specific (typically home address)
   * - **Definition:** Address(es) of the practitioner that are not role specific (typically home address).  Work addresses are not typically entered in this property as they are usually role dependent.
   * - **Comment:** The PractitionerRole does not have an address value on it, as it is expected that the location property be used for this purpose (which has an address).
   * - **Requirements:** The home/mailing address of the practitioner is often required for employee administration purposes, and also for some rostering services where the start point (practitioners home) can be used in calculations.
   * - **FHIR Type:** \`Address\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private address?: Address[] | undefined;

  /**
   * FHIR CodeSystem: AdministrativeGender
   *
   * @see {@link AdministrativeGenderEnum }
   */
  private readonly administrativeGenderEnum: AdministrativeGenderEnum;

  /**
   * Practitioner.gender Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** male | female | other | unknown
   * - **Definition:** Administrative Gender - the gender that the person is considered to have for administration and record keeping purposes.
   * - **Requirements:** Needed to address the person correctly.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private gender?: EnumCodeType | undefined;

  /**
   * Practitioner.birthDate Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The date  on which the practitioner was born
   * - **Definition:** The date of birth for the practitioner.
   * - **Requirements:** Needed for identification.
   * - **FHIR Type:** \`date\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private birthDate?: DateType | undefined;

  /**
   * Practitioner.photo Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Image of the person
   * - **Definition:** Image of the person.
   * - **Requirements:** Many EHR systems have the capability to capture an image of patients and personnel. Fits with newer social media usage too.
   * - **FHIR Type:** \`Attachment\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private photo?: Attachment[] | undefined;

  /**
   * Practitioner.qualification Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Certification, licenses, or training pertaining to the provision of care
   * - **Definition:** The official certifications, training, and licenses that authorize or otherwise pertain to the provision of care by the practitioner.  For example, a medical license issued by a medical board authorizing the practitioner to practice medicine within a certian locality.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private qualification?: PractitionerQualificationComponent[] | undefined;

  /**
   * Practitioner.communication Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A language the practitioner can use in patient communication
   * - **Definition:** A language the practitioner can use in patient communication.
   * - **Comment:** The structure aa-BB with this exact casing is one the most widely used notations for locale. However not all systems code this but instead have it as free text. Hence CodeableConcept instead of code as the data type.
   * - **Requirements:** Knowing which language a practitioner speaks can help in facilitating communication with patients.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private communication?: CodeableConcept[] | undefined;


  /**
   * @returns the FHIR resource type as defined by the FHIR specification
   */
  public override resourceType(): FhirResourceType {
    return this.fhirType() as FhirResourceType;
  }

  /**
   * @returns the \`identifier\` property value as a Identifier array
   */
  public getIdentifier(): Identifier[] {
    return this.identifier ?? ([] as Identifier[]);
  }

  /**
   * Assigns the provided Identifier array value to the \`identifier\` property.
   *
   * @param value - the \`identifier\` array value
   * @returns this
   */
  public setIdentifier(value: Identifier[] | undefined): this {
    if (isDefinedList<Identifier>(value)) {
      const optErrMsg = \`Invalid Practitioner.identifier; Provided value array has an element that is not an instance of Identifier.\`;
      assertFhirTypeList<Identifier>(value, Identifier, optErrMsg);
      this.identifier = value;
    } else {
      this.identifier = undefined;
    }
    return this;
  }

  /**
   * Add the provided Identifier value to the \`identifier\` array property.
   *
   * @param value - the \`identifier\` value
   * @returns this
   */
  public addIdentifier(value: Identifier | undefined): this {
    if (isDefined<Identifier>(value)) {
      const optErrMsg = \`Invalid Practitioner.identifier; Provided element is not an instance of Identifier.\`;
      assertFhirType<Identifier>(value, Identifier, optErrMsg);
      this.initIdentifier();
      this.identifier?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`identifier\` property exists and has a value; \`false\` otherwise
   */
  public hasIdentifier(): boolean {
    return isDefinedList<Identifier>(this.identifier) && this.identifier.some((item: Identifier) => !item.isEmpty());
  }

  /**
   * Initialize the \`identifier\` property
   */
  private initIdentifier(): void {
    if(!this.hasIdentifier()) {
      this.identifier = [] as Identifier[];
    }
  }

  /**
   * @returns the \`active\` property value as a BooleanType object if defined; else an empty BooleanType object
   */
  public getActiveElement(): BooleanType {
    return this.active ?? new BooleanType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`active\` property.
   *
   * @param element - the \`active\` value
   * @returns this
   */
  public setActiveElement(element: BooleanType | undefined): this {
    if (isDefined<BooleanType>(element)) {
      const optErrMsg = \`Invalid Practitioner.active; Provided element is not an instance of BooleanType.\`;
      assertFhirType<BooleanType>(element, BooleanType, optErrMsg);
      this.active = element;
    } else {
      this.active = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`active\` property exists and has a value; \`false\` otherwise
   */
  public hasActiveElement(): boolean {
    return isDefined<BooleanType>(this.active) && !this.active.isEmpty();
  }

  /**
   * @returns the \`active\` property value as a fhirBoolean if defined; else undefined
   */
  public getActive(): fhirBoolean | undefined {
    return this.active?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`active\` property.
   *
   * @param value - the \`active\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setActive(value: fhirBoolean | undefined): this {
    if (isDefined<fhirBoolean>(value)) {
      const optErrMsg = \`Invalid Practitioner.active (\${String(value)})\`;
      this.active = new BooleanType(parseFhirPrimitiveData(value, fhirBooleanSchema, optErrMsg));
    } else {
      this.active = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`active\` property exists and has a value; \`false\` otherwise
   */
  public hasActive(): boolean {
    return this.hasActiveElement();
  }

  /**
   * @returns the \`name\` property value as a HumanName array
   */
  public getName(): HumanName[] {
    return this.name ?? ([] as HumanName[]);
  }

  /**
   * Assigns the provided HumanName array value to the \`name\` property.
   *
   * @param value - the \`name\` array value
   * @returns this
   */
  public setName(value: HumanName[] | undefined): this {
    if (isDefinedList<HumanName>(value)) {
      const optErrMsg = \`Invalid Practitioner.name; Provided value array has an element that is not an instance of HumanName.\`;
      assertFhirTypeList<HumanName>(value, HumanName, optErrMsg);
      this.name = value;
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * Add the provided HumanName value to the \`name\` array property.
   *
   * @param value - the \`name\` value
   * @returns this
   */
  public addName(value: HumanName | undefined): this {
    if (isDefined<HumanName>(value)) {
      const optErrMsg = \`Invalid Practitioner.name; Provided element is not an instance of HumanName.\`;
      assertFhirType<HumanName>(value, HumanName, optErrMsg);
      this.initName();
      this.name?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`name\` property exists and has a value; \`false\` otherwise
   */
  public hasName(): boolean {
    return isDefinedList<HumanName>(this.name) && this.name.some((item: HumanName) => !item.isEmpty());
  }

  /**
   * Initialize the \`name\` property
   */
  private initName(): void {
    if(!this.hasName()) {
      this.name = [] as HumanName[];
    }
  }

  /**
   * @returns the \`telecom\` property value as a ContactPoint array
   */
  public getTelecom(): ContactPoint[] {
    return this.telecom ?? ([] as ContactPoint[]);
  }

  /**
   * Assigns the provided ContactPoint array value to the \`telecom\` property.
   *
   * @param value - the \`telecom\` array value
   * @returns this
   */
  public setTelecom(value: ContactPoint[] | undefined): this {
    if (isDefinedList<ContactPoint>(value)) {
      const optErrMsg = \`Invalid Practitioner.telecom; Provided value array has an element that is not an instance of ContactPoint.\`;
      assertFhirTypeList<ContactPoint>(value, ContactPoint, optErrMsg);
      this.telecom = value;
    } else {
      this.telecom = undefined;
    }
    return this;
  }

  /**
   * Add the provided ContactPoint value to the \`telecom\` array property.
   *
   * @param value - the \`telecom\` value
   * @returns this
   */
  public addTelecom(value: ContactPoint | undefined): this {
    if (isDefined<ContactPoint>(value)) {
      const optErrMsg = \`Invalid Practitioner.telecom; Provided element is not an instance of ContactPoint.\`;
      assertFhirType<ContactPoint>(value, ContactPoint, optErrMsg);
      this.initTelecom();
      this.telecom?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`telecom\` property exists and has a value; \`false\` otherwise
   */
  public hasTelecom(): boolean {
    return isDefinedList<ContactPoint>(this.telecom) && this.telecom.some((item: ContactPoint) => !item.isEmpty());
  }

  /**
   * Initialize the \`telecom\` property
   */
  private initTelecom(): void {
    if(!this.hasTelecom()) {
      this.telecom = [] as ContactPoint[];
    }
  }

  /**
   * @returns the \`address\` property value as a Address array
   */
  public getAddress(): Address[] {
    return this.address ?? ([] as Address[]);
  }

  /**
   * Assigns the provided Address array value to the \`address\` property.
   *
   * @param value - the \`address\` array value
   * @returns this
   */
  public setAddress(value: Address[] | undefined): this {
    if (isDefinedList<Address>(value)) {
      const optErrMsg = \`Invalid Practitioner.address; Provided value array has an element that is not an instance of Address.\`;
      assertFhirTypeList<Address>(value, Address, optErrMsg);
      this.address = value;
    } else {
      this.address = undefined;
    }
    return this;
  }

  /**
   * Add the provided Address value to the \`address\` array property.
   *
   * @param value - the \`address\` value
   * @returns this
   */
  public addAddress(value: Address | undefined): this {
    if (isDefined<Address>(value)) {
      const optErrMsg = \`Invalid Practitioner.address; Provided element is not an instance of Address.\`;
      assertFhirType<Address>(value, Address, optErrMsg);
      this.initAddress();
      this.address?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`address\` property exists and has a value; \`false\` otherwise
   */
  public hasAddress(): boolean {
    return isDefinedList<Address>(this.address) && this.address.some((item: Address) => !item.isEmpty());
  }

  /**
   * Initialize the \`address\` property
   */
  private initAddress(): void {
    if(!this.hasAddress()) {
      this.address = [] as Address[];
    }
  }

  /**
   * @returns the \`gender\` property value as a EnumCodeType if defined; else undefined
   */
  public getGenderEnumType(): EnumCodeType | undefined {
    return this.gender;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`gender\` property.
   *
   * @param enumType - the \`gender\` value
   * @returns this
   */
  public setGenderEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid Practitioner.gender';
      assertEnumCodeType<AdministrativeGenderEnum>(enumType, AdministrativeGenderEnum, errMsgPrefix);
      this.gender = enumType;
    } else {
      this.gender = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`gender\` property exists and has a value; \`false\` otherwise
   */
  public hasGenderEnumType(): boolean {
    return isDefined<EnumCodeType>(this.gender) && !this.gender.isEmpty() && this.gender.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`gender\` property value as a CodeType if defined; else undefined
   */
  public getGenderElement(): CodeType | undefined {
    if (this.gender === undefined) {
      return undefined;
    }
    return this.gender as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`gender\` property.
   *
   * @param element - the \`gender\` value
   * @returns this
   */
  public setGenderElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Practitioner.gender; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.gender = new EnumCodeType(element, this.administrativeGenderEnum);
    } else {
      this.gender = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`gender\` property exists and has a value; \`false\` otherwise
   */
  public hasGenderElement(): boolean {
    return this.hasGenderEnumType();
  }

  /**
   * @returns the \`gender\` property value as a fhirCode if defined; else undefined
   */
  public getGender(): fhirCode | undefined {
    if (this.gender === undefined) {
      return undefined;
    }
    return this.gender.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`gender\` property.
   *
   * @param value - the \`gender\` value
   * @returns this
   */
  public setGender(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Practitioner.gender; Provided value is not an instance of fhirCode.\`;
      this.gender = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.administrativeGenderEnum);
    } else {
      this.gender = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`gender\` property exists and has a value; \`false\` otherwise
   */
  public hasGender(): boolean {
    return this.hasGenderEnumType();
  }

  /**
   * @returns the \`birthDate\` property value as a DateType object if defined; else an empty DateType object
   */
  public getBirthDateElement(): DateType {
    return this.birthDate ?? new DateType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`birthDate\` property.
   *
   * @param element - the \`birthDate\` value
   * @returns this
   */
  public setBirthDateElement(element: DateType | undefined): this {
    if (isDefined<DateType>(element)) {
      const optErrMsg = \`Invalid Practitioner.birthDate; Provided element is not an instance of DateType.\`;
      assertFhirType<DateType>(element, DateType, optErrMsg);
      this.birthDate = element;
    } else {
      this.birthDate = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`birthDate\` property exists and has a value; \`false\` otherwise
   */
  public hasBirthDateElement(): boolean {
    return isDefined<DateType>(this.birthDate) && !this.birthDate.isEmpty();
  }

  /**
   * @returns the \`birthDate\` property value as a fhirDate if defined; else undefined
   */
  public getBirthDate(): fhirDate | undefined {
    return this.birthDate?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`birthDate\` property.
   *
   * @param value - the \`birthDate\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setBirthDate(value: fhirDate | undefined): this {
    if (isDefined<fhirDate>(value)) {
      const optErrMsg = \`Invalid Practitioner.birthDate (\${String(value)})\`;
      this.birthDate = new DateType(parseFhirPrimitiveData(value, fhirDateSchema, optErrMsg));
    } else {
      this.birthDate = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`birthDate\` property exists and has a value; \`false\` otherwise
   */
  public hasBirthDate(): boolean {
    return this.hasBirthDateElement();
  }

  /**
   * @returns the \`photo\` property value as a Attachment array
   */
  public getPhoto(): Attachment[] {
    return this.photo ?? ([] as Attachment[]);
  }

  /**
   * Assigns the provided Attachment array value to the \`photo\` property.
   *
   * @param value - the \`photo\` array value
   * @returns this
   */
  public setPhoto(value: Attachment[] | undefined): this {
    if (isDefinedList<Attachment>(value)) {
      const optErrMsg = \`Invalid Practitioner.photo; Provided value array has an element that is not an instance of Attachment.\`;
      assertFhirTypeList<Attachment>(value, Attachment, optErrMsg);
      this.photo = value;
    } else {
      this.photo = undefined;
    }
    return this;
  }

  /**
   * Add the provided Attachment value to the \`photo\` array property.
   *
   * @param value - the \`photo\` value
   * @returns this
   */
  public addPhoto(value: Attachment | undefined): this {
    if (isDefined<Attachment>(value)) {
      const optErrMsg = \`Invalid Practitioner.photo; Provided element is not an instance of Attachment.\`;
      assertFhirType<Attachment>(value, Attachment, optErrMsg);
      this.initPhoto();
      this.photo?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`photo\` property exists and has a value; \`false\` otherwise
   */
  public hasPhoto(): boolean {
    return isDefinedList<Attachment>(this.photo) && this.photo.some((item: Attachment) => !item.isEmpty());
  }

  /**
   * Initialize the \`photo\` property
   */
  private initPhoto(): void {
    if(!this.hasPhoto()) {
      this.photo = [] as Attachment[];
    }
  }

  /**
   * @returns the \`qualification\` property value as a PractitionerQualificationComponent array
   */
  public getQualification(): PractitionerQualificationComponent[] {
    return this.qualification ?? ([] as PractitionerQualificationComponent[]);
  }

  /**
   * Assigns the provided PractitionerQualificationComponent array value to the \`qualification\` property.
   *
   * @param value - the \`qualification\` array value
   * @returns this
   */
  public setQualification(value: PractitionerQualificationComponent[] | undefined): this {
    if (isDefinedList<PractitionerQualificationComponent>(value)) {
      const optErrMsg = \`Invalid Practitioner.qualification; Provided value array has an element that is not an instance of PractitionerQualificationComponent.\`;
      assertFhirTypeList<PractitionerQualificationComponent>(value, PractitionerQualificationComponent, optErrMsg);
      this.qualification = value;
    } else {
      this.qualification = undefined;
    }
    return this;
  }

  /**
   * Add the provided PractitionerQualificationComponent value to the \`qualification\` array property.
   *
   * @param value - the \`qualification\` value
   * @returns this
   */
  public addQualification(value: PractitionerQualificationComponent | undefined): this {
    if (isDefined<PractitionerQualificationComponent>(value)) {
      const optErrMsg = \`Invalid Practitioner.qualification; Provided element is not an instance of PractitionerQualificationComponent.\`;
      assertFhirType<PractitionerQualificationComponent>(value, PractitionerQualificationComponent, optErrMsg);
      this.initQualification();
      this.qualification?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`qualification\` property exists and has a value; \`false\` otherwise
   */
  public hasQualification(): boolean {
    return isDefinedList<PractitionerQualificationComponent>(this.qualification) && this.qualification.some((item: PractitionerQualificationComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`qualification\` property
   */
  private initQualification(): void {
    if(!this.hasQualification()) {
      this.qualification = [] as PractitionerQualificationComponent[];
    }
  }

  /**
   * @returns the \`communication\` property value as a CodeableConcept array
   */
  public getCommunication(): CodeableConcept[] {
    return this.communication ?? ([] as CodeableConcept[]);
  }

  /**
   * Assigns the provided CodeableConcept array value to the \`communication\` property.
   *
   * @param value - the \`communication\` array value
   * @returns this
   */
  public setCommunication(value: CodeableConcept[] | undefined): this {
    if (isDefinedList<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Practitioner.communication; Provided value array has an element that is not an instance of CodeableConcept.\`;
      assertFhirTypeList<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.communication = value;
    } else {
      this.communication = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeableConcept value to the \`communication\` array property.
   *
   * @param value - the \`communication\` value
   * @returns this
   */
  public addCommunication(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Practitioner.communication; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.initCommunication();
      this.communication?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`communication\` property exists and has a value; \`false\` otherwise
   */
  public hasCommunication(): boolean {
    return isDefinedList<CodeableConcept>(this.communication) && this.communication.some((item: CodeableConcept) => !item.isEmpty());
  }

  /**
   * Initialize the \`communication\` property
   */
  private initCommunication(): void {
    if(!this.hasCommunication()) {
      this.communication = [] as CodeableConcept[];
    }
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Practitioner';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.identifier,
      this.active,
      this.name,
      this.telecom,
      this.address,
      this.gender,
      this.birthDate,
      this.photo,
      this.qualification,
      this.communication,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Practitioner {
    const dest = new Practitioner();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Practitioner): void {
    super.copyValues(dest);
    const identifierList = copyListValues<Identifier>(this.identifier);
    dest.identifier = identifierList.length === 0 ? undefined : identifierList;
    dest.active = this.active?.copy();
    const nameList = copyListValues<HumanName>(this.name);
    dest.name = nameList.length === 0 ? undefined : nameList;
    const telecomList = copyListValues<ContactPoint>(this.telecom);
    dest.telecom = telecomList.length === 0 ? undefined : telecomList;
    const addressList = copyListValues<Address>(this.address);
    dest.address = addressList.length === 0 ? undefined : addressList;
    dest.gender = this.gender?.copy();
    dest.birthDate = this.birthDate?.copy();
    const photoList = copyListValues<Attachment>(this.photo);
    dest.photo = photoList.length === 0 ? undefined : photoList;
    const qualificationList = copyListValues<PractitionerQualificationComponent>(this.qualification);
    dest.qualification = qualificationList.length === 0 ? undefined : qualificationList;
    const communicationList = copyListValues<CodeableConcept>(this.communication);
    dest.communication = communicationList.length === 0 ? undefined : communicationList;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasIdentifier()) {
      setFhirComplexListJson(this.getIdentifier(), 'identifier', jsonObj);
    }

    if (this.hasActiveElement()) {
      setFhirPrimitiveJson<fhirBoolean>(this.getActiveElement(), 'active', jsonObj);
    }

    if (this.hasName()) {
      setFhirComplexListJson(this.getName(), 'name', jsonObj);
    }

    if (this.hasTelecom()) {
      setFhirComplexListJson(this.getTelecom(), 'telecom', jsonObj);
    }

    if (this.hasAddress()) {
      setFhirComplexListJson(this.getAddress(), 'address', jsonObj);
    }

    if (this.hasGenderElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getGenderElement()!, 'gender', jsonObj);
    }

    if (this.hasBirthDateElement()) {
      setFhirPrimitiveJson<fhirDate>(this.getBirthDateElement(), 'birthDate', jsonObj);
    }

    if (this.hasPhoto()) {
      setFhirComplexListJson(this.getPhoto(), 'photo', jsonObj);
    }

    if (this.hasQualification()) {
      setFhirBackboneElementListJson(this.getQualification(), 'qualification', jsonObj);
    }

    if (this.hasCommunication()) {
      setFhirComplexListJson(this.getCommunication(), 'communication', jsonObj);
    }

    return jsonObj;
  }
}


/**
 * PractitionerQualificationComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Certification, licenses, or training pertaining to the provision of care
 * - **Definition:** The official certifications, training, and licenses that authorize or otherwise pertain to the provision of care by the practitioner.  For example, a medical license issued by a medical board authorizing the practitioner to practice medicine within a certian locality.
 *
 * @category DataModel: Resource
 * @see [FHIR Practitioner](http://hl7.org/fhir/StructureDefinition/Practitioner)
 */
export class PractitionerQualificationComponent extends BackboneElement {
  constructor(code: CodeableConcept | null = null) {
    super();

    this.code = null;
    if (isDefined<CodeableConcept>(code)) {
      this.setCode(code);
    }
  }

  /**
   * Parse the provided \`PractitionerQualificationComponent\` JSON to instantiate the PractitionerQualificationComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`PractitionerQualificationComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to PractitionerQualificationComponent
   * @returns PractitionerQualificationComponent data model or undefined for \`PractitionerQualificationComponent\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): PractitionerQualificationComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'PractitionerQualificationComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new PractitionerQualificationComponent();
    fhirDataTypeParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';

    const missingReqdProperties: string[] = [];

    fieldName = 'identifier';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Identifier | undefined = fhirDataTypeParser.parser<Identifier>(Identifier, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addIdentifier(datatype);
        }
      });
    }

    fieldName = 'code';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = fhirDataTypeParser.parser<CodeableConcept>(CodeableConcept, classJsonObj[fieldName]!, sourceField);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setCode(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'period';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Period | undefined = fhirDataTypeParser.parser<Period>(Period, classJsonObj[fieldName]!, sourceField);
      instance.setPeriod(datatype);
    }

    fieldName = 'issuer';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = fhirDataTypeParser.parser<Reference>(Reference, classJsonObj[fieldName]!, sourceField);
      instance.setIssuer(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Practitioner.qualification.identifier Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** An identifier for this qualification for the practitioner
   * - **Definition:** An identifier that applies to this person\\'s qualification in this role.
   * - **Requirements:** Often, specific identities are assigned for the qualification.
   * - **FHIR Type:** \`Identifier\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private identifier?: Identifier[] | undefined;

  /**
   * Practitioner.qualification.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Coded representation of the qualification
   * - **Definition:** Coded representation of the qualification.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private code: CodeableConcept | null;

  /**
   * Practitioner.qualification.period Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Period during which the qualification is valid
   * - **Definition:** Period during which the qualification is valid.
   * - **Requirements:** Qualifications are often for a limited period of time, and can be revoked.
   * - **FHIR Type:** \`Period\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private period?: Period | undefined;

  /**
   * Practitioner.qualification.issuer Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Organization that regulates and issues the qualification
   * - **Definition:** Organization that regulates and issues the qualification.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Organization',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private issuer?: Reference | undefined;


  /**
   * @returns the \`identifier\` property value as a Identifier array
   */
  public getIdentifier(): Identifier[] {
    return this.identifier ?? ([] as Identifier[]);
  }

  /**
   * Assigns the provided Identifier array value to the \`identifier\` property.
   *
   * @param value - the \`identifier\` array value
   * @returns this
   */
  public setIdentifier(value: Identifier[] | undefined): this {
    if (isDefinedList<Identifier>(value)) {
      const optErrMsg = \`Invalid Practitioner.qualification.identifier; Provided value array has an element that is not an instance of Identifier.\`;
      assertFhirTypeList<Identifier>(value, Identifier, optErrMsg);
      this.identifier = value;
    } else {
      this.identifier = undefined;
    }
    return this;
  }

  /**
   * Add the provided Identifier value to the \`identifier\` array property.
   *
   * @param value - the \`identifier\` value
   * @returns this
   */
  public addIdentifier(value: Identifier | undefined): this {
    if (isDefined<Identifier>(value)) {
      const optErrMsg = \`Invalid Practitioner.qualification.identifier; Provided element is not an instance of Identifier.\`;
      assertFhirType<Identifier>(value, Identifier, optErrMsg);
      this.initIdentifier();
      this.identifier?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`identifier\` property exists and has a value; \`false\` otherwise
   */
  public hasIdentifier(): boolean {
    return isDefinedList<Identifier>(this.identifier) && this.identifier.some((item: Identifier) => !item.isEmpty());
  }

  /**
   * Initialize the \`identifier\` property
   */
  private initIdentifier(): void {
    if(!this.hasIdentifier()) {
      this.identifier = [] as Identifier[];
    }
  }

  /**
   * @returns the \`code\` property value as a CodeableConcept object if defined; else null
   */
  public getCode(): CodeableConcept | null {
    return this.code;
  }

  /**
   * Assigns the provided CodeableConcept object value to the \`code\` property.
   *
   * @param value - the \`code\` object value
   * @returns this
   */
  public setCode(value: CodeableConcept): this {
    assertIsDefined<CodeableConcept>(value, \`Practitioner.qualification.code is required\`);
    const optErrMsg = \`Invalid Practitioner.qualification.code; Provided element is not an instance of CodeableConcept.\`;
    assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
    this.code = value;
    return this;
  }

  /**
   * @returns \`true\` if the \`code\` property exists and has a value; \`false\` otherwise
   */
  public hasCode(): boolean {
    return isDefined<CodeableConcept>(this.code) && !this.code.isEmpty();
  }

  /**
   * @returns the \`period\` property value as a Period object if defined; else an empty Period object
   */
  public getPeriod(): Period {
    return this.period ?? new Period();
  }

  /**
   * Assigns the provided Period object value to the \`period\` property.
   *
   * @param value - the \`period\` object value
   * @returns this
   */
  public setPeriod(value: Period | undefined): this {
    if (isDefined<Period>(value)) {
      const optErrMsg = \`Invalid Practitioner.qualification.period; Provided element is not an instance of Period.\`;
      assertFhirType<Period>(value, Period, optErrMsg);
      this.period = value;
    } else {
      this.period = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`period\` property exists and has a value; \`false\` otherwise
   */
  public hasPeriod(): boolean {
    return isDefined<Period>(this.period) && !this.period.isEmpty();
  }

  /**
   * @returns the \`issuer\` property value as a Reference object; else an empty Reference object
   */
  public getIssuer(): Reference {
    return this.issuer ?? new Reference();
  }

  /**
   * Assigns the provided Issuer object value to the \`issuer\` property.
   *
   * @decorator \`@ReferenceTargets('Practitioner.qualification.issuer', ['Organization',])\`
   *
   * @param value - the \`issuer\` object value
   * @returns this
   */
  @ReferenceTargets('Practitioner.qualification.issuer', [
    'Organization',
  ])
  public setIssuer(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.issuer = value;
    } else {
      this.issuer = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`issuer\` property exists and has a value; \`false\` otherwise
   */
  public hasIssuer(): boolean {
    return isDefined<Reference>(this.issuer) && !this.issuer.isEmpty();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Practitioner.qualification';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.identifier,
      this.code,
      this.period,
      this.issuer,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): PractitionerQualificationComponent {
    const dest = new PractitionerQualificationComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: PractitionerQualificationComponent): void {
    super.copyValues(dest);
    const identifierList = copyListValues<Identifier>(this.identifier);
    dest.identifier = identifierList.length === 0 ? undefined : identifierList;
    dest.code = this.code ? this.code.copy() : null;
    dest.period = this.period?.copy();
    dest.issuer = this.issuer?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasIdentifier()) {
      setFhirComplexListJson(this.getIdentifier(), 'identifier', jsonObj);
    }

    if (this.hasCode()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirComplexJson(this.getCode()!, 'code', jsonObj);
    } else {
      missingReqdProperties.push(\`Practitioner.qualification.code\`);
    }

    if (this.hasPeriod()) {
      setFhirComplexJson(this.getPeriod(), 'period', jsonObj);
    }

    if (this.hasIssuer()) {
      setFhirComplexJson(this.getIssuer(), 'issuer', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
",
  "fileExtension": "ts",
  "filename": "Practitioner",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 74`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "Resource",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * PractitionerRole Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/PractitionerRole
 * StructureDefinition.name: PractitionerRole
 * StructureDefinition.description: A specific set of Roles/Locations/specialties/services that a practitioner may perform at an organization for a period of time.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  BackboneElement,
  BooleanType,
  CodeType,
  EnumCodeType,
  FhirDataTypeParser,
  FhirError,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  PrimitiveType,
  PrimitiveTypeJson,
  REQUIRED_PROPERTIES_DO_NOT_EXIST,
  REQUIRED_PROPERTIES_REQD_IN_JSON,
  StringType,
  TimeType,
  assertEnumCodeType,
  assertEnumCodeTypeList,
  assertFhirType,
  assertFhirTypeList,
  assertIsDefined,
  copyListValues,
  fhirBoolean,
  fhirBooleanSchema,
  fhirCode,
  fhirCodeSchema,
  fhirString,
  fhirStringSchema,
  fhirTime,
  fhirTimeSchema,
  getPrimitiveTypeJson,
  getPrimitiveTypeListJson,
  isDefined,
  isDefinedList,
  isElementEmpty,
  isEmpty,
  parseBooleanType,
  parseCodeType,
  parseFhirPrimitiveData,
  parseStringType,
  parseTimeType,
  setFhirBackboneElementListJson,
  setFhirComplexJson,
  setFhirComplexListJson,
  setFhirPrimitiveJson,
  setFhirPrimitiveListJson,
} from '@paq-ts-fhir/fhir-core';
import {
  CodeableConcept,
  ContactPoint,
  DaysOfWeekEnum,
  DomainResource,
  FhirResourceParser,
  FhirResourceType,
  Identifier,
  PARSABLE_DATATYPE_MAP,
  Period,
  Reference,
  ReferenceTargets,
} from '../index';

/**
 * PractitionerRole Class
 *
 * @remarks
 * A specific set of Roles/Locations/specialties/services that a practitioner may perform at an organization for a period of time.
 *
 * Need to track services that a healthcare provider is able to provide at an organization\\'s location, and the services that they can perform there.
 *
 * **FHIR Specification**
 * - **Short:** Roles/organizations the practitioner is associated with
 * - **Definition:** A specific set of Roles/Locations/specialties/services that a practitioner may perform at an organization for a period of time.
 * - **FHIR Version:** 4.0.1
 *
 * @category DataModel: Resource
 * @see [FHIR PractitionerRole](http://hl7.org/fhir/StructureDefinition/PractitionerRole)
 */
export class PractitionerRole extends DomainResource implements IBase {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`PractitionerRole\` JSON to instantiate the PractitionerRole data model.
   *
   * @param sourceJson - JSON representing FHIR \`PractitionerRole\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to PractitionerRole
   * @returns PractitionerRole data model or undefined for \`PractitionerRole\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): PractitionerRole | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirResourceParser = new FhirResourceParser(PARSABLE_DATATYPE_MAP);
    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'PractitionerRole';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new PractitionerRole();
    fhirResourceParser.processDomainResourceJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'identifier';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Identifier | undefined = fhirDataTypeParser.parser<Identifier>(Identifier, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addIdentifier(datatype);
        }
      });
    }

    fieldName = 'active';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'boolean';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: BooleanType | undefined = parseBooleanType(dtJson, dtSiblingJson);
      instance.setActiveElement(datatype);
    }

    fieldName = 'period';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Period | undefined = fhirDataTypeParser.parser<Period>(Period, classJsonObj[fieldName]!, sourceField);
      instance.setPeriod(datatype);
    }

    fieldName = 'practitioner';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = fhirDataTypeParser.parser<Reference>(Reference, classJsonObj[fieldName]!, sourceField);
      instance.setPractitioner(datatype);
    }

    fieldName = 'organization';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = fhirDataTypeParser.parser<Reference>(Reference, classJsonObj[fieldName]!, sourceField);
      instance.setOrganization(datatype);
    }

    fieldName = 'code';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: CodeableConcept | undefined = fhirDataTypeParser.parser<CodeableConcept>(CodeableConcept, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addCode(datatype);
        }
      });
    }

    fieldName = 'specialty';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: CodeableConcept | undefined = fhirDataTypeParser.parser<CodeableConcept>(CodeableConcept, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addSpecialty(datatype);
        }
      });
    }

    fieldName = 'location';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Reference | undefined = fhirDataTypeParser.parser<Reference>(Reference, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addLocation(datatype);
        }
      });
  }

    fieldName = 'healthcareService';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Reference | undefined = fhirDataTypeParser.parser<Reference>(Reference, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addHealthcareService(datatype);
        }
      });
  }

    fieldName = 'telecom';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: ContactPoint | undefined = fhirDataTypeParser.parser<ContactPoint>(ContactPoint, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addTelecom(datatype);
        }
      });
    }

    fieldName = 'availableTime';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const componentJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      componentJsonArray.forEach((componentJson: JSON.Value, idx) => {
        const component: PractitionerRoleAvailableTimeComponent | undefined = PractitionerRoleAvailableTimeComponent.parse(componentJson, \`\${sourceField}[\${String(idx)}]\`);
        if (component !== undefined) {
          instance.addAvailableTime(component);
        }
      });
    }

    fieldName = 'notAvailable';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const componentJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      componentJsonArray.forEach((componentJson: JSON.Value, idx) => {
        const component: PractitionerRoleNotAvailableComponent | undefined = PractitionerRoleNotAvailableComponent.parse(componentJson, \`\${sourceField}[\${String(idx)}]\`);
        if (component !== undefined) {
          instance.addNotAvailable(component);
        }
      });
    }

    fieldName = 'availabilityExceptions';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setAvailabilityExceptionsElement(datatype);
    }

    fieldName = 'endpoint';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Reference | undefined = fhirDataTypeParser.parser<Reference>(Reference, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addEndpoint(datatype);
        }
      });
  }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * PractitionerRole.identifier Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Business Identifiers that are specific to a role/location
   * - **Definition:** Business Identifiers that are specific to a role/location.
   * - **Requirements:** Often, specific identities are assigned for the agent.
   * - **FHIR Type:** \`Identifier\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private identifier?: Identifier[] | undefined;

  /**
   * PractitionerRole.active Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Whether this practitioner role record is in active use
   * - **Definition:** Whether this practitioner role record is in active use.
   * - **Comment:** If this value is false, you may refer to the period to see when the role was in active use. If there is no period specified, no inference can be made about when it was active.
   * - **Requirements:** Need to be able to mark a practitioner role record as not to be used because it was created in error, or otherwise no longer in active use.
   * - **FHIR Type:** \`boolean\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private active?: BooleanType | undefined;

  /**
   * PractitionerRole.period Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The period during which the practitioner is authorized to perform in these role(s)
   * - **Definition:** The period during which the person is authorized to act as a practitioner in these role(s) for the organization.
   * - **Requirements:** Even after the agencies is revoked, the fact that it existed must still be recorded.
   * - **FHIR Type:** \`Period\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private period?: Period | undefined;

  /**
   * PractitionerRole.practitioner Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Practitioner that is able to provide the defined services for the organization
   * - **Definition:** Practitioner that is able to provide the defined services for the organization.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Practitioner',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private practitioner?: Reference | undefined;

  /**
   * PractitionerRole.organization Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Organization where the roles are available
   * - **Definition:** The organization where the Practitioner performs the roles associated.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Organization',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private organization?: Reference | undefined;

  /**
   * PractitionerRole.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Roles which this practitioner may perform
   * - **Definition:** Roles which this practitioner is authorized to perform for the organization.
   * - **Comment:** A person may have more than one role.
   * - **Requirements:** Need to know what authority the practitioner has - what can they do?
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code?: CodeableConcept[] | undefined;

  /**
   * PractitionerRole.specialty Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Specific specialty of the practitioner
   * - **Definition:** Specific specialty of the practitioner.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private specialty?: CodeableConcept[] | undefined;

  /**
   * PractitionerRole.location Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The location(s) at which this practitioner provides care
   * - **Definition:** The location(s) at which this practitioner provides care.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Location',
   *     ]
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private location?: Reference[] | undefined;

  /**
   * PractitionerRole.healthcareService Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The list of healthcare services that this worker provides for this role\\'s Organization/Location(s)
   * - **Definition:** The list of healthcare services that this worker provides for this role\\'s Organization/Location(s).
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/HealthcareService',
   *     ]
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private healthcareService?: Reference[] | undefined;

  /**
   * PractitionerRole.telecom Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Contact details that are specific to the role/location/service
   * - **Definition:** Contact details that are specific to the role/location/service.
   * - **Requirements:** Often practitioners have a dedicated line for each location (or service) that they work at, and need to be able to define separate contact details for each of these.
   * - **FHIR Type:** \`ContactPoint\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private telecom?: ContactPoint[] | undefined;

  /**
   * PractitionerRole.availableTime Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Times the Service Site is available
   * - **Definition:** A collection of times the practitioner is available or performing this role at the location and/or healthcareservice.
   * - **Comment:** More detailed availability information may be provided in associated Schedule/Slot resources.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private availableTime?: PractitionerRoleAvailableTimeComponent[] | undefined;

  /**
   * PractitionerRole.notAvailable Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Not available during this time due to provided reason
   * - **Definition:** The practitioner is not available or performing this role during this period of time due to the provided reason.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private notAvailable?: PractitionerRoleNotAvailableComponent[] | undefined;

  /**
   * PractitionerRole.availabilityExceptions Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Description of availability exceptions
   * - **Definition:** A description of site availability exceptions, e.g. public holiday availability. Succinctly describing all possible exceptions to normal site availability as details in the available Times and not available Times.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private availabilityExceptions?: StringType | undefined;

  /**
   * PractitionerRole.endpoint Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Technical endpoints providing access to services operated for the practitioner with this role
   * - **Definition:** Technical endpoints providing access to services operated for the practitioner with this role.
   * - **Requirements:** Organizations have multiple systems that provide various services and ,ay also be different for practitioners too. So the endpoint satisfies the need to be able to define the technical connection details for how to connect to them, and for what purpose.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Endpoint',
   *     ]
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private endpoint?: Reference[] | undefined;


  /**
   * @returns the FHIR resource type as defined by the FHIR specification
   */
  public override resourceType(): FhirResourceType {
    return this.fhirType() as FhirResourceType;
  }

  /**
   * @returns the \`identifier\` property value as a Identifier array
   */
  public getIdentifier(): Identifier[] {
    return this.identifier ?? ([] as Identifier[]);
  }

  /**
   * Assigns the provided Identifier array value to the \`identifier\` property.
   *
   * @param value - the \`identifier\` array value
   * @returns this
   */
  public setIdentifier(value: Identifier[] | undefined): this {
    if (isDefinedList<Identifier>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.identifier; Provided value array has an element that is not an instance of Identifier.\`;
      assertFhirTypeList<Identifier>(value, Identifier, optErrMsg);
      this.identifier = value;
    } else {
      this.identifier = undefined;
    }
    return this;
  }

  /**
   * Add the provided Identifier value to the \`identifier\` array property.
   *
   * @param value - the \`identifier\` value
   * @returns this
   */
  public addIdentifier(value: Identifier | undefined): this {
    if (isDefined<Identifier>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.identifier; Provided element is not an instance of Identifier.\`;
      assertFhirType<Identifier>(value, Identifier, optErrMsg);
      this.initIdentifier();
      this.identifier?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`identifier\` property exists and has a value; \`false\` otherwise
   */
  public hasIdentifier(): boolean {
    return isDefinedList<Identifier>(this.identifier) && this.identifier.some((item: Identifier) => !item.isEmpty());
  }

  /**
   * Initialize the \`identifier\` property
   */
  private initIdentifier(): void {
    if(!this.hasIdentifier()) {
      this.identifier = [] as Identifier[];
    }
  }

  /**
   * @returns the \`active\` property value as a BooleanType object if defined; else an empty BooleanType object
   */
  public getActiveElement(): BooleanType {
    return this.active ?? new BooleanType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`active\` property.
   *
   * @param element - the \`active\` value
   * @returns this
   */
  public setActiveElement(element: BooleanType | undefined): this {
    if (isDefined<BooleanType>(element)) {
      const optErrMsg = \`Invalid PractitionerRole.active; Provided element is not an instance of BooleanType.\`;
      assertFhirType<BooleanType>(element, BooleanType, optErrMsg);
      this.active = element;
    } else {
      this.active = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`active\` property exists and has a value; \`false\` otherwise
   */
  public hasActiveElement(): boolean {
    return isDefined<BooleanType>(this.active) && !this.active.isEmpty();
  }

  /**
   * @returns the \`active\` property value as a fhirBoolean if defined; else undefined
   */
  public getActive(): fhirBoolean | undefined {
    return this.active?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`active\` property.
   *
   * @param value - the \`active\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setActive(value: fhirBoolean | undefined): this {
    if (isDefined<fhirBoolean>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.active (\${String(value)})\`;
      this.active = new BooleanType(parseFhirPrimitiveData(value, fhirBooleanSchema, optErrMsg));
    } else {
      this.active = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`active\` property exists and has a value; \`false\` otherwise
   */
  public hasActive(): boolean {
    return this.hasActiveElement();
  }

  /**
   * @returns the \`period\` property value as a Period object if defined; else an empty Period object
   */
  public getPeriod(): Period {
    return this.period ?? new Period();
  }

  /**
   * Assigns the provided Period object value to the \`period\` property.
   *
   * @param value - the \`period\` object value
   * @returns this
   */
  public setPeriod(value: Period | undefined): this {
    if (isDefined<Period>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.period; Provided element is not an instance of Period.\`;
      assertFhirType<Period>(value, Period, optErrMsg);
      this.period = value;
    } else {
      this.period = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`period\` property exists and has a value; \`false\` otherwise
   */
  public hasPeriod(): boolean {
    return isDefined<Period>(this.period) && !this.period.isEmpty();
  }

  /**
   * @returns the \`practitioner\` property value as a Reference object; else an empty Reference object
   */
  public getPractitioner(): Reference {
    return this.practitioner ?? new Reference();
  }

  /**
   * Assigns the provided Practitioner object value to the \`practitioner\` property.
   *
   * @decorator \`@ReferenceTargets('PractitionerRole.practitioner', ['Practitioner',])\`
   *
   * @param value - the \`practitioner\` object value
   * @returns this
   */
  @ReferenceTargets('PractitionerRole.practitioner', [
    'Practitioner',
  ])
  public setPractitioner(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.practitioner = value;
    } else {
      this.practitioner = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`practitioner\` property exists and has a value; \`false\` otherwise
   */
  public hasPractitioner(): boolean {
    return isDefined<Reference>(this.practitioner) && !this.practitioner.isEmpty();
  }

  /**
   * @returns the \`organization\` property value as a Reference object; else an empty Reference object
   */
  public getOrganization(): Reference {
    return this.organization ?? new Reference();
  }

  /**
   * Assigns the provided Organization object value to the \`organization\` property.
   *
   * @decorator \`@ReferenceTargets('PractitionerRole.organization', ['Organization',])\`
   *
   * @param value - the \`organization\` object value
   * @returns this
   */
  @ReferenceTargets('PractitionerRole.organization', [
    'Organization',
  ])
  public setOrganization(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.organization = value;
    } else {
      this.organization = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`organization\` property exists and has a value; \`false\` otherwise
   */
  public hasOrganization(): boolean {
    return isDefined<Reference>(this.organization) && !this.organization.isEmpty();
  }

  /**
   * @returns the \`code\` property value as a CodeableConcept array
   */
  public getCode(): CodeableConcept[] {
    return this.code ?? ([] as CodeableConcept[]);
  }

  /**
   * Assigns the provided CodeableConcept array value to the \`code\` property.
   *
   * @param value - the \`code\` array value
   * @returns this
   */
  public setCode(value: CodeableConcept[] | undefined): this {
    if (isDefinedList<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.code; Provided value array has an element that is not an instance of CodeableConcept.\`;
      assertFhirTypeList<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.code = value;
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeableConcept value to the \`code\` array property.
   *
   * @param value - the \`code\` value
   * @returns this
   */
  public addCode(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.code; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.initCode();
      this.code?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`code\` property exists and has a value; \`false\` otherwise
   */
  public hasCode(): boolean {
    return isDefinedList<CodeableConcept>(this.code) && this.code.some((item: CodeableConcept) => !item.isEmpty());
  }

  /**
   * Initialize the \`code\` property
   */
  private initCode(): void {
    if(!this.hasCode()) {
      this.code = [] as CodeableConcept[];
    }
  }

  /**
   * @returns the \`specialty\` property value as a CodeableConcept array
   */
  public getSpecialty(): CodeableConcept[] {
    return this.specialty ?? ([] as CodeableConcept[]);
  }

  /**
   * Assigns the provided CodeableConcept array value to the \`specialty\` property.
   *
   * @param value - the \`specialty\` array value
   * @returns this
   */
  public setSpecialty(value: CodeableConcept[] | undefined): this {
    if (isDefinedList<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.specialty; Provided value array has an element that is not an instance of CodeableConcept.\`;
      assertFhirTypeList<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.specialty = value;
    } else {
      this.specialty = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeableConcept value to the \`specialty\` array property.
   *
   * @param value - the \`specialty\` value
   * @returns this
   */
  public addSpecialty(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.specialty; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.initSpecialty();
      this.specialty?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`specialty\` property exists and has a value; \`false\` otherwise
   */
  public hasSpecialty(): boolean {
    return isDefinedList<CodeableConcept>(this.specialty) && this.specialty.some((item: CodeableConcept) => !item.isEmpty());
  }

  /**
   * Initialize the \`specialty\` property
   */
  private initSpecialty(): void {
    if(!this.hasSpecialty()) {
      this.specialty = [] as CodeableConcept[];
    }
  }

  /**
   * @returns the \`location\` property value as a Reference array
   */
  public getLocation(): Reference[] {
    return this.location ?? ([] as Reference[]);
  }

  /**
   * Assigns the provided Reference array value to the \`location\` property.
   *
   * @decorator \`@ReferenceTargets('PractitionerRole.location', ['Location',])\`
   *
   * @param value - the \`location\` array value
   * @returns this
   */
  @ReferenceTargets('PractitionerRole.location', [
    'Location',
  ])
  public setLocation(value: Reference[] | undefined): this {
    if (isDefinedList<Reference>(value)) {
      // assertFhirTypeList<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.location = value;
    } else {
      this.location = undefined;
    }
    return this;
  }

  /**
   * Add the provided Reference value to the \`location\` array property.
   *
   * @decorator \`@ReferenceTargets('PractitionerRole.location', ['Location',])\`
   *
   * @param value - the \`location\` value
   * @returns this
   */
  @ReferenceTargets('PractitionerRole.location', [
    'Location',
  ])
  public addLocation(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.initLocation();
      this.location?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`location\` property exists and has a value; \`false\` otherwise
   */
  public hasLocation(): boolean {
    return isDefinedList<Reference>(this.location) && this.location.some((item: Reference) => !item.isEmpty());
  }

  /**
   * Initialize the \`location\` property
   */
  private initLocation(): void {
    if (!this.hasLocation()) {
      this.location = [] as Reference[];
    }
  }

  /**
   * @returns the \`healthcareService\` property value as a Reference array
   */
  public getHealthcareService(): Reference[] {
    return this.healthcareService ?? ([] as Reference[]);
  }

  /**
   * Assigns the provided Reference array value to the \`healthcareService\` property.
   *
   * @decorator \`@ReferenceTargets('PractitionerRole.healthcareService', ['HealthcareService',])\`
   *
   * @param value - the \`healthcareService\` array value
   * @returns this
   */
  @ReferenceTargets('PractitionerRole.healthcareService', [
    'HealthcareService',
  ])
  public setHealthcareService(value: Reference[] | undefined): this {
    if (isDefinedList<Reference>(value)) {
      // assertFhirTypeList<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.healthcareService = value;
    } else {
      this.healthcareService = undefined;
    }
    return this;
  }

  /**
   * Add the provided Reference value to the \`healthcareService\` array property.
   *
   * @decorator \`@ReferenceTargets('PractitionerRole.healthcareService', ['HealthcareService',])\`
   *
   * @param value - the \`healthcareService\` value
   * @returns this
   */
  @ReferenceTargets('PractitionerRole.healthcareService', [
    'HealthcareService',
  ])
  public addHealthcareService(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.initHealthcareService();
      this.healthcareService?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`healthcareService\` property exists and has a value; \`false\` otherwise
   */
  public hasHealthcareService(): boolean {
    return isDefinedList<Reference>(this.healthcareService) && this.healthcareService.some((item: Reference) => !item.isEmpty());
  }

  /**
   * Initialize the \`healthcareService\` property
   */
  private initHealthcareService(): void {
    if (!this.hasHealthcareService()) {
      this.healthcareService = [] as Reference[];
    }
  }

  /**
   * @returns the \`telecom\` property value as a ContactPoint array
   */
  public getTelecom(): ContactPoint[] {
    return this.telecom ?? ([] as ContactPoint[]);
  }

  /**
   * Assigns the provided ContactPoint array value to the \`telecom\` property.
   *
   * @param value - the \`telecom\` array value
   * @returns this
   */
  public setTelecom(value: ContactPoint[] | undefined): this {
    if (isDefinedList<ContactPoint>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.telecom; Provided value array has an element that is not an instance of ContactPoint.\`;
      assertFhirTypeList<ContactPoint>(value, ContactPoint, optErrMsg);
      this.telecom = value;
    } else {
      this.telecom = undefined;
    }
    return this;
  }

  /**
   * Add the provided ContactPoint value to the \`telecom\` array property.
   *
   * @param value - the \`telecom\` value
   * @returns this
   */
  public addTelecom(value: ContactPoint | undefined): this {
    if (isDefined<ContactPoint>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.telecom; Provided element is not an instance of ContactPoint.\`;
      assertFhirType<ContactPoint>(value, ContactPoint, optErrMsg);
      this.initTelecom();
      this.telecom?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`telecom\` property exists and has a value; \`false\` otherwise
   */
  public hasTelecom(): boolean {
    return isDefinedList<ContactPoint>(this.telecom) && this.telecom.some((item: ContactPoint) => !item.isEmpty());
  }

  /**
   * Initialize the \`telecom\` property
   */
  private initTelecom(): void {
    if(!this.hasTelecom()) {
      this.telecom = [] as ContactPoint[];
    }
  }

  /**
   * @returns the \`availableTime\` property value as a PractitionerRoleAvailableTimeComponent array
   */
  public getAvailableTime(): PractitionerRoleAvailableTimeComponent[] {
    return this.availableTime ?? ([] as PractitionerRoleAvailableTimeComponent[]);
  }

  /**
   * Assigns the provided PractitionerRoleAvailableTimeComponent array value to the \`availableTime\` property.
   *
   * @param value - the \`availableTime\` array value
   * @returns this
   */
  public setAvailableTime(value: PractitionerRoleAvailableTimeComponent[] | undefined): this {
    if (isDefinedList<PractitionerRoleAvailableTimeComponent>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.availableTime; Provided value array has an element that is not an instance of PractitionerRoleAvailableTimeComponent.\`;
      assertFhirTypeList<PractitionerRoleAvailableTimeComponent>(value, PractitionerRoleAvailableTimeComponent, optErrMsg);
      this.availableTime = value;
    } else {
      this.availableTime = undefined;
    }
    return this;
  }

  /**
   * Add the provided PractitionerRoleAvailableTimeComponent value to the \`availableTime\` array property.
   *
   * @param value - the \`availableTime\` value
   * @returns this
   */
  public addAvailableTime(value: PractitionerRoleAvailableTimeComponent | undefined): this {
    if (isDefined<PractitionerRoleAvailableTimeComponent>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.availableTime; Provided element is not an instance of PractitionerRoleAvailableTimeComponent.\`;
      assertFhirType<PractitionerRoleAvailableTimeComponent>(value, PractitionerRoleAvailableTimeComponent, optErrMsg);
      this.initAvailableTime();
      this.availableTime?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`availableTime\` property exists and has a value; \`false\` otherwise
   */
  public hasAvailableTime(): boolean {
    return isDefinedList<PractitionerRoleAvailableTimeComponent>(this.availableTime) && this.availableTime.some((item: PractitionerRoleAvailableTimeComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`availableTime\` property
   */
  private initAvailableTime(): void {
    if(!this.hasAvailableTime()) {
      this.availableTime = [] as PractitionerRoleAvailableTimeComponent[];
    }
  }

  /**
   * @returns the \`notAvailable\` property value as a PractitionerRoleNotAvailableComponent array
   */
  public getNotAvailable(): PractitionerRoleNotAvailableComponent[] {
    return this.notAvailable ?? ([] as PractitionerRoleNotAvailableComponent[]);
  }

  /**
   * Assigns the provided PractitionerRoleNotAvailableComponent array value to the \`notAvailable\` property.
   *
   * @param value - the \`notAvailable\` array value
   * @returns this
   */
  public setNotAvailable(value: PractitionerRoleNotAvailableComponent[] | undefined): this {
    if (isDefinedList<PractitionerRoleNotAvailableComponent>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.notAvailable; Provided value array has an element that is not an instance of PractitionerRoleNotAvailableComponent.\`;
      assertFhirTypeList<PractitionerRoleNotAvailableComponent>(value, PractitionerRoleNotAvailableComponent, optErrMsg);
      this.notAvailable = value;
    } else {
      this.notAvailable = undefined;
    }
    return this;
  }

  /**
   * Add the provided PractitionerRoleNotAvailableComponent value to the \`notAvailable\` array property.
   *
   * @param value - the \`notAvailable\` value
   * @returns this
   */
  public addNotAvailable(value: PractitionerRoleNotAvailableComponent | undefined): this {
    if (isDefined<PractitionerRoleNotAvailableComponent>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.notAvailable; Provided element is not an instance of PractitionerRoleNotAvailableComponent.\`;
      assertFhirType<PractitionerRoleNotAvailableComponent>(value, PractitionerRoleNotAvailableComponent, optErrMsg);
      this.initNotAvailable();
      this.notAvailable?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`notAvailable\` property exists and has a value; \`false\` otherwise
   */
  public hasNotAvailable(): boolean {
    return isDefinedList<PractitionerRoleNotAvailableComponent>(this.notAvailable) && this.notAvailable.some((item: PractitionerRoleNotAvailableComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`notAvailable\` property
   */
  private initNotAvailable(): void {
    if(!this.hasNotAvailable()) {
      this.notAvailable = [] as PractitionerRoleNotAvailableComponent[];
    }
  }

  /**
   * @returns the \`availabilityExceptions\` property value as a StringType object if defined; else an empty StringType object
   */
  public getAvailabilityExceptionsElement(): StringType {
    return this.availabilityExceptions ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`availabilityExceptions\` property.
   *
   * @param element - the \`availabilityExceptions\` value
   * @returns this
   */
  public setAvailabilityExceptionsElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid PractitionerRole.availabilityExceptions; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.availabilityExceptions = element;
    } else {
      this.availabilityExceptions = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`availabilityExceptions\` property exists and has a value; \`false\` otherwise
   */
  public hasAvailabilityExceptionsElement(): boolean {
    return isDefined<StringType>(this.availabilityExceptions) && !this.availabilityExceptions.isEmpty();
  }

  /**
   * @returns the \`availabilityExceptions\` property value as a fhirString if defined; else undefined
   */
  public getAvailabilityExceptions(): fhirString | undefined {
    return this.availabilityExceptions?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`availabilityExceptions\` property.
   *
   * @param value - the \`availabilityExceptions\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setAvailabilityExceptions(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.availabilityExceptions (\${String(value)})\`;
      this.availabilityExceptions = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.availabilityExceptions = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`availabilityExceptions\` property exists and has a value; \`false\` otherwise
   */
  public hasAvailabilityExceptions(): boolean {
    return this.hasAvailabilityExceptionsElement();
  }

  /**
   * @returns the \`endpoint\` property value as a Reference array
   */
  public getEndpoint(): Reference[] {
    return this.endpoint ?? ([] as Reference[]);
  }

  /**
   * Assigns the provided Reference array value to the \`endpoint\` property.
   *
   * @decorator \`@ReferenceTargets('PractitionerRole.endpoint', ['Endpoint',])\`
   *
   * @param value - the \`endpoint\` array value
   * @returns this
   */
  @ReferenceTargets('PractitionerRole.endpoint', [
    'Endpoint',
  ])
  public setEndpoint(value: Reference[] | undefined): this {
    if (isDefinedList<Reference>(value)) {
      // assertFhirTypeList<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.endpoint = value;
    } else {
      this.endpoint = undefined;
    }
    return this;
  }

  /**
   * Add the provided Reference value to the \`endpoint\` array property.
   *
   * @decorator \`@ReferenceTargets('PractitionerRole.endpoint', ['Endpoint',])\`
   *
   * @param value - the \`endpoint\` value
   * @returns this
   */
  @ReferenceTargets('PractitionerRole.endpoint', [
    'Endpoint',
  ])
  public addEndpoint(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.initEndpoint();
      this.endpoint?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`endpoint\` property exists and has a value; \`false\` otherwise
   */
  public hasEndpoint(): boolean {
    return isDefinedList<Reference>(this.endpoint) && this.endpoint.some((item: Reference) => !item.isEmpty());
  }

  /**
   * Initialize the \`endpoint\` property
   */
  private initEndpoint(): void {
    if (!this.hasEndpoint()) {
      this.endpoint = [] as Reference[];
    }
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'PractitionerRole';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.identifier,
      this.active,
      this.period,
      this.practitioner,
      this.organization,
      this.code,
      this.specialty,
      this.location,
      this.healthcareService,
      this.telecom,
      this.availableTime,
      this.notAvailable,
      this.availabilityExceptions,
      this.endpoint,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): PractitionerRole {
    const dest = new PractitionerRole();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: PractitionerRole): void {
    super.copyValues(dest);
    const identifierList = copyListValues<Identifier>(this.identifier);
    dest.identifier = identifierList.length === 0 ? undefined : identifierList;
    dest.active = this.active?.copy();
    dest.period = this.period?.copy();
    dest.practitioner = this.practitioner?.copy();
    dest.organization = this.organization?.copy();
    const codeList = copyListValues<CodeableConcept>(this.code);
    dest.code = codeList.length === 0 ? undefined : codeList;
    const specialtyList = copyListValues<CodeableConcept>(this.specialty);
    dest.specialty = specialtyList.length === 0 ? undefined : specialtyList;
    const locationList = copyListValues<Reference>(this.location);
    dest.location = locationList.length === 0 ? undefined : locationList;
    const healthcareServiceList = copyListValues<Reference>(this.healthcareService);
    dest.healthcareService = healthcareServiceList.length === 0 ? undefined : healthcareServiceList;
    const telecomList = copyListValues<ContactPoint>(this.telecom);
    dest.telecom = telecomList.length === 0 ? undefined : telecomList;
    const availableTimeList = copyListValues<PractitionerRoleAvailableTimeComponent>(this.availableTime);
    dest.availableTime = availableTimeList.length === 0 ? undefined : availableTimeList;
    const notAvailableList = copyListValues<PractitionerRoleNotAvailableComponent>(this.notAvailable);
    dest.notAvailable = notAvailableList.length === 0 ? undefined : notAvailableList;
    dest.availabilityExceptions = this.availabilityExceptions?.copy();
    const endpointList = copyListValues<Reference>(this.endpoint);
    dest.endpoint = endpointList.length === 0 ? undefined : endpointList;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasIdentifier()) {
      setFhirComplexListJson(this.getIdentifier(), 'identifier', jsonObj);
    }

    if (this.hasActiveElement()) {
      setFhirPrimitiveJson<fhirBoolean>(this.getActiveElement(), 'active', jsonObj);
    }

    if (this.hasPeriod()) {
      setFhirComplexJson(this.getPeriod(), 'period', jsonObj);
    }

    if (this.hasPractitioner()) {
      setFhirComplexJson(this.getPractitioner(), 'practitioner', jsonObj);
    }

    if (this.hasOrganization()) {
      setFhirComplexJson(this.getOrganization(), 'organization', jsonObj);
    }

    if (this.hasCode()) {
      setFhirComplexListJson(this.getCode(), 'code', jsonObj);
    }

    if (this.hasSpecialty()) {
      setFhirComplexListJson(this.getSpecialty(), 'specialty', jsonObj);
    }

    if (this.hasLocation()) {
      setFhirComplexListJson(this.getLocation(), 'location', jsonObj);
    }

    if (this.hasHealthcareService()) {
      setFhirComplexListJson(this.getHealthcareService(), 'healthcareService', jsonObj);
    }

    if (this.hasTelecom()) {
      setFhirComplexListJson(this.getTelecom(), 'telecom', jsonObj);
    }

    if (this.hasAvailableTime()) {
      setFhirBackboneElementListJson(this.getAvailableTime(), 'availableTime', jsonObj);
    }

    if (this.hasNotAvailable()) {
      setFhirBackboneElementListJson(this.getNotAvailable(), 'notAvailable', jsonObj);
    }

    if (this.hasAvailabilityExceptionsElement()) {
      setFhirPrimitiveJson<fhirString>(this.getAvailabilityExceptionsElement(), 'availabilityExceptions', jsonObj);
    }

    if (this.hasEndpoint()) {
      setFhirComplexListJson(this.getEndpoint(), 'endpoint', jsonObj);
    }

    return jsonObj;
  }
}


/**
 * PractitionerRoleAvailableTimeComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Times the Service Site is available
 * - **Definition:** A collection of times the practitioner is available or performing this role at the location and/or healthcareservice.
 * - **Comment:** More detailed availability information may be provided in associated Schedule/Slot resources.
 *
 * @category DataModel: Resource
 * @see [FHIR PractitionerRole](http://hl7.org/fhir/StructureDefinition/PractitionerRole)
 */
export class PractitionerRoleAvailableTimeComponent extends BackboneElement {
  constructor() {
    super();

    this.daysOfWeekEnum = new DaysOfWeekEnum();
  }

  /**
   * Parse the provided \`PractitionerRoleAvailableTimeComponent\` JSON to instantiate the PractitionerRoleAvailableTimeComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`PractitionerRoleAvailableTimeComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to PractitionerRoleAvailableTimeComponent
   * @returns PractitionerRoleAvailableTimeComponent data model or undefined for \`PractitionerRoleAvailableTimeComponent\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): PractitionerRoleAvailableTimeComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'PractitionerRoleAvailableTimeComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new PractitionerRoleAvailableTimeComponent();
    fhirDataTypeParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'daysOfWeek';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: CodeType | undefined = parseCodeType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addDaysOfWeekElement(datatype);
        }
      });
    }

    fieldName = 'allDay';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'boolean';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: BooleanType | undefined = parseBooleanType(dtJson, dtSiblingJson);
      instance.setAllDayElement(datatype);
    }

    fieldName = 'availableStartTime';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: TimeType | undefined = parseTimeType(dtJson, dtSiblingJson);
      instance.setAvailableStartTimeElement(datatype);
    }

    fieldName = 'availableEndTime';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: TimeType | undefined = parseTimeType(dtJson, dtSiblingJson);
      instance.setAvailableEndTimeElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: DaysOfWeek
   *
   * @see {@link DaysOfWeekEnum }
   */
  private readonly daysOfWeekEnum: DaysOfWeekEnum;

  /**
   * PractitionerRole.availableTime.daysOfWeek Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** mon | tue | wed | thu | fri | sat | sun
   * - **Definition:** Indicates which days of the week are available between the start and end Times.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private daysOfWeek?: EnumCodeType[] | undefined;

  /**
   * PractitionerRole.availableTime.allDay Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Always available? e.g. 24 hour service
   * - **Definition:** Is this always available? (hence times are irrelevant) e.g. 24 hour service.
   * - **FHIR Type:** \`boolean\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private allDay?: BooleanType | undefined;

  /**
   * PractitionerRole.availableTime.availableStartTime Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Opening time of day (ignored if allDay = true)
   * - **Definition:** The opening time of day. Note: If the AllDay flag is set, then this time is ignored.
   * - **Comment:** The timezone is expected to be for where this HealthcareService is provided at.
   * - **FHIR Type:** \`time\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private availableStartTime?: TimeType | undefined;

  /**
   * PractitionerRole.availableTime.availableEndTime Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Closing time of day (ignored if allDay = true)
   * - **Definition:** The closing time of day. Note: If the AllDay flag is set, then this time is ignored.
   * - **Comment:** The timezone is expected to be for where this HealthcareService is provided at.
   * - **FHIR Type:** \`time\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private availableEndTime?: TimeType | undefined;


  /**
   * @returns the \`daysOfWeek\` property value as a EnumCodeType array
   */
  public getDaysOfWeekEnumType(): EnumCodeType[] {
    return this.daysOfWeek ?? ([] as EnumCodeType[]);
  }

  /**
   * Assigns the provided EnumCodeType array value to the \`daysOfWeek\` property.
   *
   * @param enumType - the \`daysOfWeek\` array value
   * @returns this
   */
  public setDaysOfWeekEnumType(enumType: EnumCodeType[] | undefined): this {
    if (isDefinedList<EnumCodeType>(enumType)) {
      const errMsgPrefix = \`Invalid PractitionerRole.availableTime.daysOfWeek\`;
      assertEnumCodeTypeList<DaysOfWeekEnum>(enumType, DaysOfWeekEnum, errMsgPrefix);
      this.daysOfWeek = enumType;
    } else {
      this.daysOfWeek = undefined;
    }
    return this;
  }

  /**
   * Add the provided EnumCodeType value to the \`daysOfWeek\` array property.
   *
   * @param enumType - the \`daysOfWeek\` value
   * @returns this
   */
  public addDaysOfWeekEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = \`Invalid PractitionerRole.availableTime.daysOfWeek)\`;
      assertEnumCodeType<DaysOfWeekEnum>(enumType, DaysOfWeekEnum, errMsgPrefix);
      this.initDaysOfWeek();
      this.daysOfWeek?.push(enumType);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`daysOfWeek\` property exists and has a value; \`false\` otherwise
   */
  public hasDaysOfWeekEnumType(): boolean {
    return isDefinedList<EnumCodeType>(this.daysOfWeek) && this.daysOfWeek.some((item: EnumCodeType) => !item.isEmpty()) && this.daysOfWeek.every((item: EnumCodeType) => item.fhirCodeEnumeration.length > 0);
  }

  /**
   * @returns the \`daysOfWeek\` property value as a CodeType array
   */
  public getDaysOfWeekElement(): CodeType[] {
    if (this.daysOfWeek === undefined) {
      return [] as CodeType[];
    }
    return this.daysOfWeek as CodeType[];
  }

  /**
   * Assigns the provided PrimitiveType array value to the \`daysOfWeek\` property.
   *
   * @param element - the \`daysOfWeek\` array value
   * @returns this
   */
  public setDaysOfWeekElement(element: CodeType[] | undefined): this {
    if (isDefinedList<CodeType>(element)) {
      const optErrMsg = \`Invalid PractitionerRole.availableTime.daysOfWeek; Provided element array has an element that is not an instance of CodeType.\`;
      assertFhirTypeList<CodeType>(element, CodeType, optErrMsg);
      const enumCodeTypes = [] as EnumCodeType[];
      element.forEach((type: CodeType) => {
        enumCodeTypes.push(new EnumCodeType(type, this.daysOfWeekEnum));
      });
      this.daysOfWeek = enumCodeTypes;
    } else {
      this.daysOfWeek = undefined;
    }
    return this;
  }

  /**
   * Add the provided PrimitiveType value to the \`daysOfWeek\` array property.
   *
   * @param element - the \`daysOfWeek\` value
   * @returns this
   */
  public addDaysOfWeekElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid PractitionerRole.availableTime.daysOfWeek; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.initDaysOfWeek();
      this.daysOfWeek?.push(new EnumCodeType(element, this.daysOfWeekEnum));
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`daysOfWeek\` property exists and has a value; \`false\` otherwise
   */
  public hasDaysOfWeekElement(): boolean {
    return this.hasDaysOfWeekEnumType();
  }

  /**
   * @returns the \`daysOfWeek\` property value as a fhirCode array
   */
  public getDaysOfWeek(): fhirCode[] {
    if (this.daysOfWeek === undefined) {
      return [] as fhirCode[];
    }
    const values = [] as fhirCode[];
    for (const item of this.daysOfWeek) {
      values.push(item.fhirCode.code);
    }
    return values;
  }

  /**
   * Assigns the provided primitive value array to the \`daysOfWeek\` property.
   *
   * @param value - the \`daysOfWeek\` value array
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setDaysOfWeek(value: fhirCode[] | undefined): this {
    if (isDefinedList<fhirCode>(value)) {
      const enumCodeTypes = [] as EnumCodeType[];
      const optErrMsg = \`Invalid PractitionerRole.availableTime.daysOfWeek; Provided value is not an instance of fhirCode.\`;
      value.forEach((val: fhirCode) => {
        enumCodeTypes.push(new EnumCodeType(parseFhirPrimitiveData(val, fhirCodeSchema, optErrMsg), this.daysOfWeekEnum));
      });
      this.daysOfWeek = enumCodeTypes;
    } else {
      this.daysOfWeek = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`daysOfWeek\` array property.
   *
   * @param value - the \`daysOfWeek\` value
   * @returns this
   */
  public addDaysOfWeek(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      this.initDaysOfWeek();
      const optErrMsg = \`Invalid PractitionerRole.availableTime.daysOfWeek; Provided value is not an instance of fhirCode.\`;
      this.daysOfWeek?.push(new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.daysOfWeekEnum));
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`daysOfWeek\` property exists and has a value; \`false\` otherwise
   */
  public hasDaysOfWeek(): boolean {
    return this.hasDaysOfWeekEnumType();
  }

  /**
   * Initialize the daysOfWeek property
   */
  private initDaysOfWeek(): void {
    if(!this.hasDaysOfWeekEnumType()) {
      this.daysOfWeek = [] as EnumCodeType[];
    }
  }

  /**
   * @returns the \`allDay\` property value as a BooleanType object if defined; else an empty BooleanType object
   */
  public getAllDayElement(): BooleanType {
    return this.allDay ?? new BooleanType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`allDay\` property.
   *
   * @param element - the \`allDay\` value
   * @returns this
   */
  public setAllDayElement(element: BooleanType | undefined): this {
    if (isDefined<BooleanType>(element)) {
      const optErrMsg = \`Invalid PractitionerRole.availableTime.allDay; Provided element is not an instance of BooleanType.\`;
      assertFhirType<BooleanType>(element, BooleanType, optErrMsg);
      this.allDay = element;
    } else {
      this.allDay = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`allDay\` property exists and has a value; \`false\` otherwise
   */
  public hasAllDayElement(): boolean {
    return isDefined<BooleanType>(this.allDay) && !this.allDay.isEmpty();
  }

  /**
   * @returns the \`allDay\` property value as a fhirBoolean if defined; else undefined
   */
  public getAllDay(): fhirBoolean | undefined {
    return this.allDay?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`allDay\` property.
   *
   * @param value - the \`allDay\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setAllDay(value: fhirBoolean | undefined): this {
    if (isDefined<fhirBoolean>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.availableTime.allDay (\${String(value)})\`;
      this.allDay = new BooleanType(parseFhirPrimitiveData(value, fhirBooleanSchema, optErrMsg));
    } else {
      this.allDay = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`allDay\` property exists and has a value; \`false\` otherwise
   */
  public hasAllDay(): boolean {
    return this.hasAllDayElement();
  }

  /**
   * @returns the \`availableStartTime\` property value as a TimeType object if defined; else an empty TimeType object
   */
  public getAvailableStartTimeElement(): TimeType {
    return this.availableStartTime ?? new TimeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`availableStartTime\` property.
   *
   * @param element - the \`availableStartTime\` value
   * @returns this
   */
  public setAvailableStartTimeElement(element: TimeType | undefined): this {
    if (isDefined<TimeType>(element)) {
      const optErrMsg = \`Invalid PractitionerRole.availableTime.availableStartTime; Provided element is not an instance of TimeType.\`;
      assertFhirType<TimeType>(element, TimeType, optErrMsg);
      this.availableStartTime = element;
    } else {
      this.availableStartTime = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`availableStartTime\` property exists and has a value; \`false\` otherwise
   */
  public hasAvailableStartTimeElement(): boolean {
    return isDefined<TimeType>(this.availableStartTime) && !this.availableStartTime.isEmpty();
  }

  /**
   * @returns the \`availableStartTime\` property value as a fhirTime if defined; else undefined
   */
  public getAvailableStartTime(): fhirTime | undefined {
    return this.availableStartTime?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`availableStartTime\` property.
   *
   * @param value - the \`availableStartTime\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setAvailableStartTime(value: fhirTime | undefined): this {
    if (isDefined<fhirTime>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.availableTime.availableStartTime (\${String(value)})\`;
      this.availableStartTime = new TimeType(parseFhirPrimitiveData(value, fhirTimeSchema, optErrMsg));
    } else {
      this.availableStartTime = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`availableStartTime\` property exists and has a value; \`false\` otherwise
   */
  public hasAvailableStartTime(): boolean {
    return this.hasAvailableStartTimeElement();
  }

  /**
   * @returns the \`availableEndTime\` property value as a TimeType object if defined; else an empty TimeType object
   */
  public getAvailableEndTimeElement(): TimeType {
    return this.availableEndTime ?? new TimeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`availableEndTime\` property.
   *
   * @param element - the \`availableEndTime\` value
   * @returns this
   */
  public setAvailableEndTimeElement(element: TimeType | undefined): this {
    if (isDefined<TimeType>(element)) {
      const optErrMsg = \`Invalid PractitionerRole.availableTime.availableEndTime; Provided element is not an instance of TimeType.\`;
      assertFhirType<TimeType>(element, TimeType, optErrMsg);
      this.availableEndTime = element;
    } else {
      this.availableEndTime = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`availableEndTime\` property exists and has a value; \`false\` otherwise
   */
  public hasAvailableEndTimeElement(): boolean {
    return isDefined<TimeType>(this.availableEndTime) && !this.availableEndTime.isEmpty();
  }

  /**
   * @returns the \`availableEndTime\` property value as a fhirTime if defined; else undefined
   */
  public getAvailableEndTime(): fhirTime | undefined {
    return this.availableEndTime?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`availableEndTime\` property.
   *
   * @param value - the \`availableEndTime\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setAvailableEndTime(value: fhirTime | undefined): this {
    if (isDefined<fhirTime>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.availableTime.availableEndTime (\${String(value)})\`;
      this.availableEndTime = new TimeType(parseFhirPrimitiveData(value, fhirTimeSchema, optErrMsg));
    } else {
      this.availableEndTime = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`availableEndTime\` property exists and has a value; \`false\` otherwise
   */
  public hasAvailableEndTime(): boolean {
    return this.hasAvailableEndTimeElement();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'PractitionerRole.availableTime';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.daysOfWeek,
      this.allDay,
      this.availableStartTime,
      this.availableEndTime,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): PractitionerRoleAvailableTimeComponent {
    const dest = new PractitionerRoleAvailableTimeComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: PractitionerRoleAvailableTimeComponent): void {
    super.copyValues(dest);
    const daysOfWeekList = copyListValues<EnumCodeType>(this.daysOfWeek);
    dest.daysOfWeek = daysOfWeekList.length === 0 ? undefined : daysOfWeekList;
    dest.allDay = this.allDay?.copy();
    dest.availableStartTime = this.availableStartTime?.copy();
    dest.availableEndTime = this.availableEndTime?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasDaysOfWeekElement()) {
      setFhirPrimitiveListJson<fhirCode>(this.getDaysOfWeekElement(), 'daysOfWeek', jsonObj);
    }

    if (this.hasAllDayElement()) {
      setFhirPrimitiveJson<fhirBoolean>(this.getAllDayElement(), 'allDay', jsonObj);
    }

    if (this.hasAvailableStartTimeElement()) {
      setFhirPrimitiveJson<fhirTime>(this.getAvailableStartTimeElement(), 'availableStartTime', jsonObj);
    }

    if (this.hasAvailableEndTimeElement()) {
      setFhirPrimitiveJson<fhirTime>(this.getAvailableEndTimeElement(), 'availableEndTime', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * PractitionerRoleNotAvailableComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Not available during this time due to provided reason
 * - **Definition:** The practitioner is not available or performing this role during this period of time due to the provided reason.
 *
 * @category DataModel: Resource
 * @see [FHIR PractitionerRole](http://hl7.org/fhir/StructureDefinition/PractitionerRole)
 */
export class PractitionerRoleNotAvailableComponent extends BackboneElement {
  constructor(description: StringType | fhirString | null = null) {
    super();

    this.description = null;
    if (isDefined<StringType | fhirString>(description)) {
      if (description instanceof PrimitiveType) {
        this.setDescriptionElement(description);
      } else {
        this.setDescription(description);
      }
    }
  }

  /**
   * Parse the provided \`PractitionerRoleNotAvailableComponent\` JSON to instantiate the PractitionerRoleNotAvailableComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`PractitionerRoleNotAvailableComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to PractitionerRoleNotAvailableComponent
   * @returns PractitionerRoleNotAvailableComponent data model or undefined for \`PractitionerRoleNotAvailableComponent\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): PractitionerRoleNotAvailableComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'PractitionerRoleNotAvailableComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new PractitionerRoleNotAvailableComponent();
    fhirDataTypeParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    

    const missingReqdProperties: string[] = [];

    fieldName = 'description';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setDescriptionElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'during';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Period | undefined = fhirDataTypeParser.parser<Period>(Period, classJsonObj[fieldName]!, sourceField);
      instance.setDuring(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * PractitionerRole.notAvailable.description Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Reason presented to the user explaining why time not available
   * - **Definition:** The reason that can be presented to the user as to why this time is not available.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private description: StringType | null;

  /**
   * PractitionerRole.notAvailable.during Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Service not available from this date
   * - **Definition:** Service is not available (seasonally or for a public holiday) from this date.
   * - **FHIR Type:** \`Period\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private during?: Period | undefined;


  /**
   * @returns the \`description\` property value as a StringType object if defined; else null
   */
  public getDescriptionElement(): StringType | null {
    return this.description;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`description\` property.
   *
   * @param element - the \`description\` value
   * @returns this
   */
  public setDescriptionElement(element: StringType): this {
    assertIsDefined<StringType>(element, \`PractitionerRole.notAvailable.description is required\`);
    const optErrMsg = \`Invalid PractitionerRole.notAvailable.description; Provided value is not an instance of StringType.\`;
    assertFhirType<StringType>(element, StringType, optErrMsg);
    this.description = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`description\` property exists and has a value; \`false\` otherwise
   */
  public hasDescriptionElement(): boolean {
    return isDefined<StringType>(this.description) && !this.description.isEmpty();
  }

  /**
   * @returns the \`description\` property value as a fhirString if defined; else null
   */
  public getDescription(): fhirString | null {
    if (this.description?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.description.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`description\` property.
   *
   * @param value - the \`description\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setDescription(value: fhirString): this {
    assertIsDefined<fhirString>(value, \`PractitionerRole.notAvailable.description is required\`);
    const optErrMsg = \`Invalid PractitionerRole.notAvailable.description (\${String(value)})\`;
    this.description = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`description\` property exists and has a value; \`false\` otherwise
   */
  public hasDescription(): boolean {
    return this.hasDescriptionElement();
  }

  /**
   * @returns the \`during\` property value as a Period object if defined; else an empty Period object
   */
  public getDuring(): Period {
    return this.during ?? new Period();
  }

  /**
   * Assigns the provided During object value to the \`during\` property.
   *
   * @param value - the \`during\` object value
   * @returns this
   */
  public setDuring(value: Period | undefined): this {
    if (isDefined<Period>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.notAvailable.during; Provided element is not an instance of Period.\`;
      assertFhirType<Period>(value, Period, optErrMsg);
      this.during = value;
    } else {
      this.during = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`during\` property exists and has a value; \`false\` otherwise
   */
  public hasDuring(): boolean {
    return isDefined<Period>(this.during) && !this.during.isEmpty();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'PractitionerRole.notAvailable';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.description,
      this.during,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): PractitionerRoleNotAvailableComponent {
    const dest = new PractitionerRoleNotAvailableComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: PractitionerRoleNotAvailableComponent): void {
    super.copyValues(dest);
    dest.description = this.description ? this.description.copy() : null;
    dest.during = this.during?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasDescriptionElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirString>(this.getDescriptionElement()!, 'description', jsonObj);
    } else {
      missingReqdProperties.push(\`PractitionerRole.notAvailable.description\`);
    }

    if (this.hasDuring()) {
      setFhirComplexJson(this.getDuring(), 'during', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
",
  "fileExtension": "ts",
  "filename": "PractitionerRole",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 75`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "Resource",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * SimplePersonModel Module
 *
 * StructureDefinition.url: https://test.ts-fhir-datamodels.com/StructureDefinition/SimplePersonModel
 * StructureDefinition.name: SimplePersonModel
 * StructureDefinition.description: Represents a very simple FHIR data model for a custom FHIR StructureDefinition.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  FhirDataTypeParser,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  StringType,
  assertFhirType,
  assertFhirTypeList,
  copyListValues,
  fhirString,
  fhirStringSchema,
  getPrimitiveTypeJson,
  isDefined,
  isDefinedList,
  isElementEmpty,
  isEmpty,
  parseFhirPrimitiveData,
  parseStringType,
  setFhirComplexJson,
  setFhirComplexListJson,
  setFhirPrimitiveJson,
} from '@paq-ts-fhir/fhir-core';
import {
  Address,
  DomainResource,
  FhirResourceParser,
  FhirResourceType,
  HumanName,
  Identifier,
  PARSABLE_DATATYPE_MAP,
} from '../index';

/**
 * SimplePersonModel Class
 *
 * @remarks
 * Represents a very simple FHIR data model for a custom FHIR StructureDefinition.
 *
 * Provide a test (mock) data model to be used in testing the TestDataModel\\'s \`DomainResource.contained\` feature.
 *
 * **FHIR Specification**
 * - **Short:** Simple Person Model
 * - **Definition:** Represents a very simple FHIR data model for a custom FHIR StructureDefinition.
 * - **FHIR Version:** 4.0.1
 *
 * @category DataModel: Resource
 * @see [FHIR SimplePersonModel](https://test.ts-fhir-datamodels.com/StructureDefinition/SimplePersonModel)
 */
export class SimplePersonModel extends DomainResource implements IBase {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`SimplePersonModel\` JSON to instantiate the SimplePersonModel data model.
   *
   * @param sourceJson - JSON representing FHIR \`SimplePersonModel\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to SimplePersonModel
   * @returns SimplePersonModel data model or undefined for \`SimplePersonModel\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): SimplePersonModel | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirResourceParser = new FhirResourceParser(PARSABLE_DATATYPE_MAP);
    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'SimplePersonModel';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new SimplePersonModel();
    fhirResourceParser.processDomainResourceJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    

    fieldName = 'identifier';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Identifier | undefined = fhirDataTypeParser.parser<Identifier>(Identifier, classJsonObj[fieldName]!, sourceField);
      instance.setIdentifier(datatype);
    }

    fieldName = 'name';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: HumanName | undefined = fhirDataTypeParser.parser<HumanName>(HumanName, classJsonObj[fieldName]!, sourceField);
      instance.setName(datatype);
    }

    fieldName = 'address';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Address | undefined = fhirDataTypeParser.parser<Address>(Address, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addAddress(datatype);
        }
      });
    }

    fieldName = 'phone';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setPhoneElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * SimplePersonModel.identifier Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A human identifier for this person
   * - **Definition:** Identifier for a person within a particular scope.
   * - **Requirements:** People are known by a variety of ids. Some institutions maintain several, and most collect identifiers for exchange with other organizations concerning the person. Examples are national person identifier and local identifier.
   * - **FHIR Type:** \`Identifier\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private identifier?: Identifier | undefined;

  /**
   * SimplePersonModel.name Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A name associated with the person
   * - **Definition:** A name associated with the person.
   * - **FHIR Type:** \`HumanName\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private name?: HumanName | undefined;

  /**
   * SimplePersonModel.address Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** An addresses for the person
   * - **Definition:** One or more addresses for the person.
   * - **Requirements:** May need to keep track of person\\'s addresses for contacting, billing or reporting requirements and also to help with identification.
   * - **FHIR Type:** \`Address\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private address?: Address[] | undefined;

  /**
   * SimplePersonModel.phone Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A phone number for this person
   * - **Definition:** A phone number for this person.
   * - **Comment:** Represents the person\\'s primary phone number.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private phone?: StringType | undefined;


  /**
   * @returns the FHIR resource type as defined by the FHIR specification
   */
  public override resourceType(): FhirResourceType {
    return this.fhirType() as FhirResourceType;
  }

  /**
   * @returns the \`identifier\` property value as a Identifier object if defined; else an empty Identifier object
   */
  public getIdentifier(): Identifier {
    return this.identifier ?? new Identifier();
  }

  /**
   * Assigns the provided Identifier object value to the \`identifier\` property.
   *
   * @param value - the \`identifier\` object value
   * @returns this
   */
  public setIdentifier(value: Identifier | undefined): this {
    if (isDefined<Identifier>(value)) {
      const optErrMsg = \`Invalid SimplePersonModel.identifier; Provided element is not an instance of Identifier.\`;
      assertFhirType<Identifier>(value, Identifier, optErrMsg);
      this.identifier = value;
    } else {
      this.identifier = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`identifier\` property exists and has a value; \`false\` otherwise
   */
  public hasIdentifier(): boolean {
    return isDefined<Identifier>(this.identifier) && !this.identifier.isEmpty();
  }

  /**
   * @returns the \`name\` property value as a HumanName object if defined; else an empty HumanName object
   */
  public getName(): HumanName {
    return this.name ?? new HumanName();
  }

  /**
   * Assigns the provided Name object value to the \`name\` property.
   *
   * @param value - the \`name\` object value
   * @returns this
   */
  public setName(value: HumanName | undefined): this {
    if (isDefined<HumanName>(value)) {
      const optErrMsg = \`Invalid SimplePersonModel.name; Provided element is not an instance of HumanName.\`;
      assertFhirType<HumanName>(value, HumanName, optErrMsg);
      this.name = value;
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`name\` property exists and has a value; \`false\` otherwise
   */
  public hasName(): boolean {
    return isDefined<HumanName>(this.name) && !this.name.isEmpty();
  }

  /**
   * @returns the \`address\` property value as a Address array
   */
  public getAddress(): Address[] {
    return this.address ?? ([] as Address[]);
  }

  /**
   * Assigns the provided Address array value to the \`address\` property.
   *
   * @param value - the \`address\` array value
   * @returns this
   */
  public setAddress(value: Address[] | undefined): this {
    if (isDefinedList<Address>(value)) {
      const optErrMsg = \`Invalid SimplePersonModel.address; Provided value array has an element that is not an instance of Address.\`;
      assertFhirTypeList<Address>(value, Address, optErrMsg);
      this.address = value;
    } else {
      this.address = undefined;
    }
    return this;
  }

  /**
   * Add the provided Address value to the \`address\` array property.
   *
   * @param value - the \`address\` value
   * @returns this
   */
  public addAddress(value: Address | undefined): this {
    if (isDefined<Address>(value)) {
      const optErrMsg = \`Invalid SimplePersonModel.address; Provided element is not an instance of Address.\`;
      assertFhirType<Address>(value, Address, optErrMsg);
      this.initAddress();
      this.address?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`address\` property exists and has a value; \`false\` otherwise
   */
  public hasAddress(): boolean {
    return isDefinedList<Address>(this.address) && this.address.some((item: Address) => !item.isEmpty());
  }

  /**
   * Initialize the \`address\` property
   */
  private initAddress(): void {
    if(!this.hasAddress()) {
      this.address = [] as Address[];
    }
  }

  /**
   * @returns the \`phone\` property value as a StringType object if defined; else an empty StringType object
   */
  public getPhoneElement(): StringType {
    return this.phone ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`phone\` property.
   *
   * @param element - the \`phone\` value
   * @returns this
   */
  public setPhoneElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid SimplePersonModel.phone; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.phone = element;
    } else {
      this.phone = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`phone\` property exists and has a value; \`false\` otherwise
   */
  public hasPhoneElement(): boolean {
    return isDefined<StringType>(this.phone) && !this.phone.isEmpty();
  }

  /**
   * @returns the \`phone\` property value as a fhirString if defined; else undefined
   */
  public getPhone(): fhirString | undefined {
    return this.phone?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`phone\` property.
   *
   * @param value - the \`phone\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setPhone(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid SimplePersonModel.phone (\${String(value)})\`;
      this.phone = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.phone = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`phone\` property exists and has a value; \`false\` otherwise
   */
  public hasPhone(): boolean {
    return this.hasPhoneElement();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'SimplePersonModel';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.identifier,
      this.name,
      this.address,
      this.phone,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): SimplePersonModel {
    const dest = new SimplePersonModel();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: SimplePersonModel): void {
    super.copyValues(dest);
    dest.identifier = this.identifier?.copy();
    dest.name = this.name?.copy();
    const addressList = copyListValues<Address>(this.address);
    dest.address = addressList.length === 0 ? undefined : addressList;
    dest.phone = this.phone?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasIdentifier()) {
      setFhirComplexJson(this.getIdentifier(), 'identifier', jsonObj);
    }

    if (this.hasName()) {
      setFhirComplexJson(this.getName(), 'name', jsonObj);
    }

    if (this.hasAddress()) {
      setFhirComplexListJson(this.getAddress(), 'address', jsonObj);
    }

    if (this.hasPhoneElement()) {
      setFhirPrimitiveJson<fhirString>(this.getPhoneElement(), 'phone', jsonObj);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "SimplePersonModel",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 76`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "Resource",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * TestDataModel Module
 *
 * StructureDefinition.url: https://test.ts-fhir-datamodels.com/StructureDefinition/TestDataModel
 * StructureDefinition.name: TestDataModel
 * StructureDefinition.description: Represents a FHIR data model for a non-existent FHIR StructureDefinition. This test class will be tested by a comprehensive test suite to ensure all possible FHIR patterns are tested to ensure reliable generated FHIR data models that use all of these possible patterns.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  BackboneElement,
  BooleanType,
  ChoiceDataTypes,
  ChoiceDataTypesMeta,
  CodeType,
  DataType,
  DateTimeType,
  EnumCodeType,
  FhirDataTypeParser,
  FhirError,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  IntegerType,
  InvalidTypeError,
  JSON,
  PrimitiveType,
  PrimitiveTypeJson,
  REQUIRED_PROPERTIES_DO_NOT_EXIST,
  REQUIRED_PROPERTIES_REQD_IN_JSON,
  StringType,
  UriType,
  assertEnumCodeType,
  assertEnumCodeTypeList,
  assertFhirType,
  assertFhirTypeList,
  assertIsDefined,
  assertIsDefinedList,
  constructorCodeValueAsEnumCodeType,
  constructorCodeValueAsEnumCodeTypeList,
  copyListValues,
  fhirBoolean,
  fhirBooleanSchema,
  fhirCode,
  fhirCodeSchema,
  fhirDateTime,
  fhirDateTimeSchema,
  fhirInteger,
  fhirIntegerSchema,
  fhirString,
  fhirStringSchema,
  getPrimitiveTypeJson,
  getPrimitiveTypeListJson,
  isDefined,
  isDefinedList,
  isElementEmpty,
  isEmpty,
  parseBooleanType,
  parseCodeType,
  parseDateTimeType,
  parseFhirPrimitiveData,
  parseIntegerType,
  parseStringType,
  setFhirBackboneElementJson,
  setFhirBackboneElementListJson,
  setFhirComplexJson,
  setFhirComplexListJson,
  setFhirPrimitiveJson,
  setFhirPrimitiveListJson,
  setPolymorphicValueJson,
} from '@paq-ts-fhir/fhir-core';
import {
  Address,
  ConsentStateCodesEnum,
  ContributorTypeEnum,
  DomainResource,
  Dosage,
  FhirResourceParser,
  FhirResourceType,
  HumanName,
  PARSABLE_DATATYPE_MAP,
  Period,
  Quantity,
  Range,
  Reference,
  ReferenceTargets,
  Resource,
  TaskCodeEnum,
  TaskStatusEnum,
  assertFhirResourceType,
  setFhirResourceJson,
} from '../index';

// eslint-disable-next-line @typescript-eslint/no-explicit-any -- Symbol.metadata polyfill secret sauce for decorator metadata
(Symbol.metadata as any) ??= Symbol('Symbol.metadata');

/**
 * TestDataModel Class
 *
 * @remarks
 * Represents a FHIR data model for a non-existent FHIR StructureDefinition. This test class will be tested by a comprehensive test suite to ensure all possible FHIR patterns are tested to ensure reliable generated FHIR data models that use all of these possible patterns.
 *
 * Provide a test (mock) data model that contains all possible FHIR patterns for data model elements representing all types of FHIR data types having each possible cardinality type. The BackboneElement classes will handle a subset of FHIR data types. This class includes choice and Resource data types along with nested BackboneElement data types.
 *
 * **FHIR Specification**
 * - **Short:** Test Data Model
 * - **Definition:** Represents a FHIR data model for a non-existent FHIR StructureDefinition. This test class will be tested by a comprehensive test suite to ensure all possible FHIR patterns are tested to ensure reliable generated FHIR data models that use all of these possible patterns.
 * - **FHIR Version:** 4.0.1
 *
 * @category DataModel: Resource
 * @see [FHIR TestDataModel](https://test.ts-fhir-datamodels.com/StructureDefinition/TestDataModel)
 */
export class TestDataModel extends DomainResource implements IBase {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`TestDataModel\` JSON to instantiate the TestDataModel data model.
   *
   * @param sourceJson - JSON representing FHIR \`TestDataModel\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to TestDataModel
   * @returns TestDataModel data model or undefined for \`TestDataModel\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): TestDataModel | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirResourceParser = new FhirResourceParser(PARSABLE_DATATYPE_MAP);
    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'TestDataModel';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new TestDataModel();
    fhirResourceParser.processDomainResourceJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';

    const classMetadata: DecoratorMetadataObject | null = TestDataModel[Symbol.metadata];
    const errorMessage = \`DecoratorMetadataObject does not exist for TestDataModel\`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    fieldName = 'choice01[x]';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const choice01: DataType | undefined = fhirDataTypeParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setChoice01(choice01);

    fieldName = 'resource01';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      const resource01: Resource | undefined = fhirResourceParser.parseInlineResource(classJsonObj[fieldName], sourceField);
      instance.setResource01(resource01);
    }

    fieldName = 'backbonePrimitive0x';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const componentJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      componentJsonArray.forEach((componentJson: JSON.Value, idx) => {
        const component: TestDataModelBackbonePrimitive0XComponent | undefined = TestDataModelBackbonePrimitive0XComponent.parse(componentJson, \`\${sourceField}[\${String(idx)}]\`);
        if (component !== undefined) {
          instance.addBackbonePrimitive0x(component);
        }
      });
    }

    fieldName = 'backboneComplex01';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const component: TestDataModelBackboneComplex01Component | undefined = TestDataModelBackboneComplex01Component.parse(classJsonObj[fieldName]!, sourceField);
      instance.setBackboneComplex01(component);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * TestDataModel.choice01[x] Element
   *
   * @decorator \`@ChoiceDataTypesMeta('TestDataModel.choice01[x]', ['Range','Quantity',]\`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** choice01
   * - **Definition:** choice01
   * - **Requirements:** Optional single \\'choice\\' data type supporting \\'Range\\' or \\'Quantity\\'
   * - **FHIR Types:**
   *     'Range',
   *     'Quantity',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  @ChoiceDataTypesMeta('TestDataModel.choice01[x]',[
    'Range',
    'Quantity',
  ])
  private choice01?: DataType | undefined;

  /**
   * TestDataModel.resource01 Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** resource01
   * - **Definition:** resource01
   * - **Requirements:** Optional single \\'Resource\\' data type
   * - **FHIR Type:** \`Resource\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private resource01?: Resource | undefined;

  /**
   * TestDataModel.backbonePrimitive0x Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** backbonePrimitive0x
   * - **Definition:** backbonePrimitive0x
   * - **Requirements:** Optional list of TestDataModelPrimitiveComponent \\'BackboneElement\\'
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private backbonePrimitive0x?: TestDataModelBackbonePrimitive0XComponent[] | undefined;

  /**
   * TestDataModel.backboneComplex01 Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** backboneComplex01
   * - **Definition:** backboneComplex01
   * - **Requirements:** Optional single TestDataModelComplexComponent \\'BackboneElement\\'
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private backboneComplex01?: TestDataModelBackboneComplex01Component | undefined;


  /**
   * @returns the FHIR resource type as defined by the FHIR specification
   */
  public override resourceType(): FhirResourceType {
    return this.fhirType() as FhirResourceType;
  }

  /**
   * @returns the \`choice01\` property value as a DataType object if defined; else undefined
   */
  public getChoice01(): DataType | undefined {
    return this.choice01;
  }

  /**
   * Assigns the provided DataType object value to the \`choice01\` property.
   *
   * @decorator \`@ChoiceDataTypes('TestDataModel.choice01[x]')\`
   *
   * @param value - the \`choice01\` object value
   * @returns this
   */
  @ChoiceDataTypes('TestDataModel.choice01[x]')
  public setChoice01(value: DataType | undefined): this {
    if (isDefined<DataType>(value)) {
      // assertFhirType<DataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.choice01 = value;
    } else {
      this.choice01 = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`choice01\` property exists and has a value; \`false\` otherwise
   */
  public hasChoice01(): boolean {
    return isDefined<DataType>(this.choice01) && !this.choice01.isEmpty();
  }

  // *** NOTE ***
  // Next "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the \`choice01\` property value as a Range object if defined; else undefined
   */
  public getChoice01Range(): Range | undefined {
    if (!isDefined<DataType | undefined>(this.choice01)) {
      return undefined;
    }
    if (!(this.choice01 instanceof Range)) {
      throw new InvalidTypeError(
        \`DataType mismatch for TestDataModel.choice01[x]: Expected Range but encountered \${this.choice01.fhirType()}\`,
      );
    }
    return this.choice01;
  }

  /**
   * @returns \`true\` if the \`choice01\` property exists as a Range and has a value; \`false\` otherwise
   */
  public hasChoice01Range(): boolean {
    return this.hasChoice01() && this.choice01 instanceof Range;
  }

  /**
   * @returns the \`choice01\` property value as a Quantity object if defined; else undefined
   */
  public getChoice01Quantity(): Quantity | undefined {
    if (!isDefined<DataType | undefined>(this.choice01)) {
      return undefined;
    }
    if (!(this.choice01 instanceof Quantity)) {
      throw new InvalidTypeError(
        \`DataType mismatch for TestDataModel.choice01[x]: Expected Quantity but encountered \${this.choice01.fhirType()}\`,
      );
    }
    return this.choice01;
  }

  /**
   * @returns \`true\` if the \`choice01\` property exists as a Quantity and has a value; \`false\` otherwise
   */
  public hasChoice01Quantity(): boolean {
    return this.hasChoice01() && this.choice01 instanceof Quantity;
  }

  /**
   * @returns the \`resource01\` property value as a Resource object if defined; else undefined
   */
  public getResource01(): Resource | undefined {
    return this.resource01;
  }

  /**
   * Assigns the provided Resource object value to the \`resource01\` property.
   *
   * @param value - the \`resource01\` object value
   * @returns this
   */
  public setResource01(value: Resource | undefined): this {
    if (isDefined<Resource>(value)) {
      const optErrMsg = \`Invalid TestDataModel.resource01; Provided element is not an instance of Resource.\`;
      assertFhirResourceType(value, optErrMsg);
      this.resource01 = value;
    } else {
      this.resource01 = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`resource01\` property exists and has a value; \`false\` otherwise
   */
  public hasResource01(): boolean {
    return isDefined<Resource>(this.resource01) && !this.resource01.isEmpty();
  }

  /**
   * @returns the \`backbonePrimitive0x\` property value as a TestDataModelBackbonePrimitive0XComponent array
   */
  public getBackbonePrimitive0x(): TestDataModelBackbonePrimitive0XComponent[] {
    return this.backbonePrimitive0x ?? ([] as TestDataModelBackbonePrimitive0XComponent[]);
  }

  /**
   * Assigns the provided TestDataModelBackbonePrimitive0XComponent array value to the \`backbonePrimitive0x\` property.
   *
   * @param value - the \`backbonePrimitive0x\` array value
   * @returns this
   */
  public setBackbonePrimitive0x(value: TestDataModelBackbonePrimitive0XComponent[] | undefined): this {
    if (isDefinedList<TestDataModelBackbonePrimitive0XComponent>(value)) {
      const optErrMsg = \`Invalid TestDataModel.backbonePrimitive0x; Provided value array has an element that is not an instance of TestDataModelBackbonePrimitive0XComponent.\`;
      assertFhirTypeList<TestDataModelBackbonePrimitive0XComponent>(value, TestDataModelBackbonePrimitive0XComponent, optErrMsg);
      this.backbonePrimitive0x = value;
    } else {
      this.backbonePrimitive0x = undefined;
    }
    return this;
  }

  /**
   * Add the provided TestDataModelBackbonePrimitive0XComponent value to the \`backbonePrimitive0x\` array property.
   *
   * @param value - the \`backbonePrimitive0x\` value
   * @returns this
   */
  public addBackbonePrimitive0x(value: TestDataModelBackbonePrimitive0XComponent | undefined): this {
    if (isDefined<TestDataModelBackbonePrimitive0XComponent>(value)) {
      const optErrMsg = \`Invalid TestDataModel.backbonePrimitive0x; Provided element is not an instance of TestDataModelBackbonePrimitive0XComponent.\`;
      assertFhirType<TestDataModelBackbonePrimitive0XComponent>(value, TestDataModelBackbonePrimitive0XComponent, optErrMsg);
      this.initBackbonePrimitive0x();
      this.backbonePrimitive0x?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`backbonePrimitive0x\` property exists and has a value; \`false\` otherwise
   */
  public hasBackbonePrimitive0x(): boolean {
    return isDefinedList<TestDataModelBackbonePrimitive0XComponent>(this.backbonePrimitive0x) && this.backbonePrimitive0x.some((item: TestDataModelBackbonePrimitive0XComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`backbonePrimitive0x\` property
   */
  private initBackbonePrimitive0x(): void {
    if(!this.hasBackbonePrimitive0x()) {
      this.backbonePrimitive0x = [] as TestDataModelBackbonePrimitive0XComponent[];
    }
  }

  /**
   * @returns the \`backboneComplex01\` property value as a TestDataModelBackboneComplex01Component object if defined; else an empty TestDataModelBackboneComplex01Component object
   */
  public getBackboneComplex01(): TestDataModelBackboneComplex01Component {
    return this.backboneComplex01 ?? new TestDataModelBackboneComplex01Component();
  }

  /**
   * Assigns the provided BackboneComplex01 object value to the \`backboneComplex01\` property.
   *
   * @param value - the \`backboneComplex01\` object value
   * @returns this
   */
  public setBackboneComplex01(value: TestDataModelBackboneComplex01Component | undefined): this {
    if (isDefined<TestDataModelBackboneComplex01Component>(value)) {
      const optErrMsg = \`Invalid TestDataModel.backboneComplex01; Provided element is not an instance of TestDataModelBackboneComplex01Component.\`;
      assertFhirType<TestDataModelBackboneComplex01Component>(value, TestDataModelBackboneComplex01Component, optErrMsg);
      this.backboneComplex01 = value;
    } else {
      this.backboneComplex01 = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`backboneComplex01\` property exists and has a value; \`false\` otherwise
   */
  public hasBackboneComplex01(): boolean {
    return isDefined<TestDataModelBackboneComplex01Component>(this.backboneComplex01) && !this.backboneComplex01.isEmpty();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'TestDataModel';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.choice01,
      this.resource01,
      this.backbonePrimitive0x,
      this.backboneComplex01,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): TestDataModel {
    const dest = new TestDataModel();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: TestDataModel): void {
    super.copyValues(dest);
    dest.choice01 = this.choice01?.copy();
    dest.resource01 = this.resource01?.copy();
    const backbonePrimitive0xList = copyListValues<TestDataModelBackbonePrimitive0XComponent>(this.backbonePrimitive0x);
    dest.backbonePrimitive0x = backbonePrimitive0xList.length === 0 ? undefined : backbonePrimitive0xList;
    dest.backboneComplex01 = this.backboneComplex01?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasChoice01()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getChoice01()!, 'choice01', jsonObj);
    }

    if (this.hasResource01()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirResourceJson(this.getResource01()!, 'resource01', jsonObj);
    }

    if (this.hasBackbonePrimitive0x()) {
      setFhirBackboneElementListJson(this.getBackbonePrimitive0x(), 'backbonePrimitive0x', jsonObj);
    }

    if (this.hasBackboneComplex01()) {
      setFhirBackboneElementJson(this.getBackboneComplex01(), 'backboneComplex01', jsonObj);
    }

    return jsonObj;
  }
}


/**
 * TestDataModelBackbonePrimitive0XComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** backbonePrimitive0x
 * - **Definition:** backbonePrimitive0x
 * - **Requirements:** Optional list of TestDataModelPrimitiveComponent \\'BackboneElement\\'
 *
 * @category DataModel: Resource
 * @see [FHIR TestDataModel](https://test.ts-fhir-datamodels.com/StructureDefinition/TestDataModel)
 */
export class TestDataModelBackbonePrimitive0XComponent extends BackboneElement {
  constructor(primitive11: BooleanType | fhirBoolean | null = null, primitive1x: StringType[] | fhirString[] | null = null, choice11: DataType | null = null) {
    super();

    this.primitive11 = null;
    if (isDefined<BooleanType | fhirBoolean>(primitive11)) {
      if (primitive11 instanceof PrimitiveType) {
        this.setPrimitive11Element(primitive11);
      } else {
        this.setPrimitive11(primitive11);
      }
    }

    this.primitive1x = null;
    if (isDefinedList<StringType | fhirString>(primitive1x)) {
      if (primitive1x[0] instanceof PrimitiveType) {
        this.setPrimitive1xElement(primitive1x as StringType[]);
      } else {
        this.setPrimitive1x(primitive1x as fhirString[]);
      }
    }

    this.choice11 = null;
    if (isDefined<DataType>(choice11)) {
      this.setChoice11(choice11);
    }
  }

  /**
   * Parse the provided \`TestDataModelBackbonePrimitive0XComponent\` JSON to instantiate the TestDataModelBackbonePrimitive0XComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`TestDataModelBackbonePrimitive0XComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to TestDataModelBackbonePrimitive0XComponent
   * @returns TestDataModelBackbonePrimitive0XComponent data model or undefined for \`TestDataModelBackbonePrimitive0XComponent\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): TestDataModelBackbonePrimitive0XComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'TestDataModelBackbonePrimitive0XComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new TestDataModelBackbonePrimitive0XComponent();
    fhirDataTypeParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const classMetadata: DecoratorMetadataObject | null = TestDataModelBackbonePrimitive0XComponent[Symbol.metadata];
    const errorMessage = \`DecoratorMetadataObject does not exist for TestDataModelBackbonePrimitive0XComponent\`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    const missingReqdProperties: string[] = [];

    fieldName = 'primitive01';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DateTimeType | undefined = parseDateTimeType(dtJson, dtSiblingJson);
      instance.setPrimitive01Element(datatype);
    }

    fieldName = 'primitive0x';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: IntegerType | undefined = parseIntegerType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addPrimitive0xElement(datatype);
        }
      });
    }

    fieldName = 'primitive11';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'boolean';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: BooleanType | undefined = parseBooleanType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setPrimitive11Element(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'primitive1x';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson, idx) => {
        const datatype: StringType | undefined = parseStringType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype === undefined) {
          missingReqdProperties.push(\`\${sourceField}[\${String(idx)}]\`);
        } else {
          instance.addPrimitive1xElement(datatype);
        }
      });
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'choice11[x]';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const choice11: DataType | undefined = fhirDataTypeParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    if (choice11 === undefined) {
      missingReqdProperties.push(sourceField);
    } else {
      instance.setChoice11(choice11);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * TestDataModel.backbonePrimitive0x.primitive01 Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** primitive01
   * - **Definition:** primitive01
   * - **Requirements:** Optional single \\'dateTime\\' data type
   * - **FHIR Type:** \`dateTime\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private primitive01?: DateTimeType | undefined;

  /**
   * TestDataModel.backbonePrimitive0x.primitive0x Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** primitive0x
   * - **Definition:** primitive0x
   * - **Requirements:** Optional list of \\'integer\\' data type
   * - **FHIR Type:** \`integer\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private primitive0x?: IntegerType[] | undefined;

  /**
   * TestDataModel.backbonePrimitive0x.primitive11 Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** primitive11
   * - **Definition:** primitive11
   * - **Requirements:** Required single \\'boolean\\' data type
   * - **FHIR Type:** \`boolean\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private primitive11: BooleanType | null;

  /**
   * TestDataModel.backbonePrimitive0x.primitive1x Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** primitive1x
   * - **Definition:** primitive1x
   * - **Requirements:** Required list of \\'string\\' data type
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 1..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private primitive1x: StringType[] | null;

  /**
   * TestDataModel.backbonePrimitive0x.choice11[x] Element
   *
   * @decorator \`@ChoiceDataTypesMeta('TestDataModel.backbonePrimitive0x.choice11[x]', ['uri','string',]\`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** choice11
   * - **Definition:** choice11
   * - **Requirements:** Required single \\'choice\\' data type supporting \\'uri\\' or \\'string\\'
   * - **FHIR Types:**
   *     'uri',
   *     'string',
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  @ChoiceDataTypesMeta('TestDataModel.backbonePrimitive0x.choice11[x]',[
    'uri',
    'string',
  ])
  private choice11: DataType | null;


  /**
   * @returns the \`primitive01\` property value as a DateTimeType object if defined; else an empty DateTimeType object
   */
  public getPrimitive01Element(): DateTimeType {
    return this.primitive01 ?? new DateTimeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`primitive01\` property.
   *
   * @param element - the \`primitive01\` value
   * @returns this
   */
  public setPrimitive01Element(element: DateTimeType | undefined): this {
    if (isDefined<DateTimeType>(element)) {
      const optErrMsg = \`Invalid TestDataModel.backbonePrimitive0x.primitive01; Provided element is not an instance of DateTimeType.\`;
      assertFhirType<DateTimeType>(element, DateTimeType, optErrMsg);
      this.primitive01 = element;
    } else {
      this.primitive01 = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`primitive01\` property exists and has a value; \`false\` otherwise
   */
  public hasPrimitive01Element(): boolean {
    return isDefined<DateTimeType>(this.primitive01) && !this.primitive01.isEmpty();
  }

  /**
   * @returns the \`primitive01\` property value as a fhirDateTime if defined; else undefined
   */
  public getPrimitive01(): fhirDateTime | undefined {
    return this.primitive01?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`primitive01\` property.
   *
   * @param value - the \`primitive01\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setPrimitive01(value: fhirDateTime | undefined): this {
    if (isDefined<fhirDateTime>(value)) {
      const optErrMsg = \`Invalid TestDataModel.backbonePrimitive0x.primitive01 (\${String(value)})\`;
      this.primitive01 = new DateTimeType(parseFhirPrimitiveData(value, fhirDateTimeSchema, optErrMsg));
    } else {
      this.primitive01 = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`primitive01\` property exists and has a value; \`false\` otherwise
   */
  public hasPrimitive01(): boolean {
    return this.hasPrimitive01Element();
  }

  /**
   * @returns the \`primitive0x\` property value as a IntegerType array
   */
  public getPrimitive0xElement(): IntegerType[] {
    return this.primitive0x ?? ([] as IntegerType[]);
  }

  /**
   * Assigns the provided IntegerType array value to the \`primitive0x\` property.
   *
   * @param element - the \`primitive0x\` array value
   * @returns this
   */
  public setPrimitive0xElement(element: IntegerType[] | undefined): this {
    if (isDefinedList<IntegerType>(element)) {
      const optErrMsg = \`Invalid TestDataModel.backbonePrimitive0x.primitive0x; Provided value array has an element that is not an instance of IntegerType.\`;
      assertFhirTypeList<IntegerType>(element, IntegerType, optErrMsg);
      this.primitive0x = element;
    } else {
      this.primitive0x = undefined;
    }
    return this;
  }

  /**
   * Add the provided IntegerType value to the \`primitive0x\` array property.
   *
   * @param element - the \`primitive0x\` value
   * @returns this
   */
  public addPrimitive0xElement(element: IntegerType | undefined): this {
    if (isDefined<IntegerType>(element)) {
      const optErrMsg = \`Invalid TestDataModel.backbonePrimitive0x.primitive0x; Provided element is not an instance of IntegerType.\`;
      assertFhirType<IntegerType>(element, IntegerType, optErrMsg);
      this.initPrimitive0x();
      this.primitive0x?.push(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`primitive0x\` property exists and has a value; \`false\` otherwise
   */
  public hasPrimitive0xElement(): boolean {
    return isDefinedList<IntegerType>(this.primitive0x) && this.primitive0x.some((item: IntegerType) => !item.isEmpty());
  }

  /**
   * @returns the \`primitive0x\` property value as a fhirInteger array
   */
  public getPrimitive0x(): fhirInteger[] {
    this.initPrimitive0x();
    const primitive0xValues = [] as fhirInteger[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.primitive0x!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        primitive0xValues.push(value);
      }
    }
    return primitive0xValues;
  }

  /**
   * Assigns the provided primitive value array to the \`primitive0x\` property.
   *
   * @param value - the \`primitive0x\` value array
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setPrimitive0x(value: fhirInteger[] | undefined): this {
    if (isDefinedList<fhirInteger>(value)) {
      const primitive0xElements = [] as IntegerType[];
      for (const primitive0xValue of value) {
        const optErrMsg = \`Invalid TestDataModel.backbonePrimitive0x.primitive0x array item (\${String(primitive0xValue)})\`;
        const element = new IntegerType(parseFhirPrimitiveData(primitive0xValue, fhirIntegerSchema, optErrMsg));
        primitive0xElements.push(element);
      }
      this.primitive0x = primitive0xElements;
    } else {
      this.primitive0x = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`primitive0x\` array property.
   *
   * @param value - the \`primitive0x\` value
   * @returns this
   */
  public addPrimitive0x(value: fhirInteger | undefined): this {
    if (isDefined<fhirInteger>(value)) {
      const optErrMsg = \`Invalid TestDataModel.backbonePrimitive0x.primitive0x array item (\${String(value)})\`;
      const element = new IntegerType(parseFhirPrimitiveData(value, fhirIntegerSchema, optErrMsg));
      this.initPrimitive0x();
      this.addPrimitive0xElement(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`primitive0x\` property exists and has a value; \`false\` otherwise
   */
  public hasPrimitive0x(): boolean {
    return this.hasPrimitive0xElement();
  }

  /**
   * Initialize the \`primitive0x\` property
   */
  private initPrimitive0x(): void {
    if (!this.hasPrimitive0x()) {
      this.primitive0x = [] as IntegerType[];
    }
  }

  /**
   * @returns the \`primitive11\` property value as a BooleanType object if defined; else null
   */
  public getPrimitive11Element(): BooleanType | null {
    return this.primitive11;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`primitive11\` property.
   *
   * @param element - the \`primitive11\` value
   * @returns this
   */
  public setPrimitive11Element(element: BooleanType): this {
    assertIsDefined<BooleanType>(element, \`TestDataModel.backbonePrimitive0x.primitive11 is required\`);
    const optErrMsg = \`Invalid TestDataModel.backbonePrimitive0x.primitive11; Provided value is not an instance of BooleanType.\`;
    assertFhirType<BooleanType>(element, BooleanType, optErrMsg);
    this.primitive11 = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`primitive11\` property exists and has a value; \`false\` otherwise
   */
  public hasPrimitive11Element(): boolean {
    return isDefined<BooleanType>(this.primitive11) && !this.primitive11.isEmpty();
  }

  /**
   * @returns the \`primitive11\` property value as a fhirBoolean if defined; else null
   */
  public getPrimitive11(): fhirBoolean | null {
    if (this.primitive11?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.primitive11.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`primitive11\` property.
   *
   * @param value - the \`primitive11\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setPrimitive11(value: fhirBoolean): this {
    assertIsDefined<fhirBoolean>(value, \`TestDataModel.backbonePrimitive0x.primitive11 is required\`);
    const optErrMsg = \`Invalid TestDataModel.backbonePrimitive0x.primitive11 (\${String(value)})\`;
    this.primitive11 = new BooleanType(parseFhirPrimitiveData(value, fhirBooleanSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`primitive11\` property exists and has a value; \`false\` otherwise
   */
  public hasPrimitive11(): boolean {
    return this.hasPrimitive11Element();
  }

  /**
   * @returns the \`primitive1x\` property value as a StringType array
   */
  public getPrimitive1xElement(): StringType[] {
    return this.primitive1x ?? ([] as StringType[]);
  }

  /**
   * Assigns the provided StringType array value to the \`primitive1x\` property.
   *
   * @param element - the \`primitive1x\` array value
   * @returns this
   */
  public setPrimitive1xElement(element: StringType[]): this {
    assertIsDefinedList<StringType>(element, \`TestDataModel.backbonePrimitive0x.primitive1x is required\`);
    const optErrMsg = \`Invalid TestDataModel.backbonePrimitive0x.primitive1x; Provided value array has an element that is not an instance of StringType.\`;
    assertFhirTypeList<StringType>(element, StringType, optErrMsg);
    this.primitive1x = element;
    return this;
  }

  /**
   * Add the provided StringType value to the \`primitive1x\` array property.
   *
   * @param element - the \`primitive1x\` value
   * @returns this
   */
  public addPrimitive1xElement(element: StringType): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid TestDataModel.backbonePrimitive0x.primitive1x; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.initPrimitive1x();
      this.primitive1x?.push(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`primitive1x\` property exists and has a value; \`false\` otherwise
   */
  public hasPrimitive1xElement(): boolean {
    return isDefinedList<StringType>(this.primitive1x) && this.primitive1x.some((item: StringType) => !item.isEmpty());
  }

  /**
   * @returns the \`primitive1x\` property value as a fhirString array
   */
  public getPrimitive1x(): fhirString[] {
    this.initPrimitive1x();
    const primitive1xValues = [] as fhirString[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.primitive1x!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        primitive1xValues.push(value);
      }
    }
    return primitive1xValues;
  }

  /**
   * Assigns the provided primitive value array to the \`primitive1x\` property.
   *
   * @param value - the \`primitive1x\` value array
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setPrimitive1x(value: fhirString[]): this {
    assertIsDefinedList<fhirString>(value, \`TestDataModel.backbonePrimitive0x.primitive1x is required\`);
    const primitive1xElements = [] as StringType[];
    for (const primitive1xValue of value) {
      const optErrMsg = \`Invalid TestDataModel.backbonePrimitive0x.primitive1x array item (\${String(primitive1xValue)})\`;
      const element = new StringType(parseFhirPrimitiveData(primitive1xValue, fhirStringSchema, optErrMsg));
      primitive1xElements.push(element);
    }
    this.primitive1x = primitive1xElements;
    return this;
  }

  /**
   * Add the provided primitive value to the \`primitive1x\` array property.
   *
   * @param value - the \`primitive1x\` value
   * @returns this
   */
  public addPrimitive1x(value: fhirString): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid TestDataModel.backbonePrimitive0x.primitive1x array item (\${String(value)})\`;
      const element = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
      this.initPrimitive1x();
      this.addPrimitive1xElement(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`primitive1x\` property exists and has a value; \`false\` otherwise
   */
  public hasPrimitive1x(): boolean {
    return this.hasPrimitive1xElement();
  }

  /**
   * Initialize the \`primitive1x\` property
   */
  private initPrimitive1x(): void {
    if (!this.hasPrimitive1x()) {
      this.primitive1x = [] as StringType[];
    }
  }

  /**
   * @returns the \`choice11\` property value as a DataType object; else null
   */
  public getChoice11(): DataType | null {
    return this.choice11;
  }

  /**
   * Assigns the provided DataType object value to the \`choice11\` property.
   *
   * @decorator \`@ChoiceDataTypes('TestDataModel.backbonePrimitive0x.choice11[x]')\`
   *
   * @param value - the \`choice11\` object value
   * @returns this
   */
  @ChoiceDataTypes('TestDataModel.backbonePrimitive0x.choice11[x]')
  public setChoice11(value: DataType): this {
    assertIsDefined<DataType>(value, \`TestDataModel.backbonePrimitive0x.choice11[x] is required\`);
    // assertFhirType<DataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
    this.choice11 = value;
    return this;
  }

  /**
   * @returns \`true\` if the \`choice11\` property exists and has a value; \`false\` otherwise
   */
  public hasChoice11(): boolean {
    return isDefined<DataType>(this.choice11) && !this.choice11.isEmpty();
  }

  // *** NOTE ***
  // Next "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the \`choice11\` property value as a UriType object if defined; else null
   */
  public getChoice11UriType(): UriType | null {
    if (!isDefined<DataType>(this.choice11)) {
      return null;
    }
    if (!(this.choice11 instanceof UriType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for TestDataModel.backbonePrimitive0x.choice11[x]: Expected UriType but encountered \${this.choice11.fhirType()}\`,
      );
    }
    return this.choice11;
  }

  /**
   * @returns \`true\` if the \`\` property exists as a UriType and has a value; \`false\` otherwise
   */
  public hasChoice11UriType(): boolean {
    return this.hasChoice11() && this.choice11 instanceof UriType;
  }

  /**
   * @returns the \`choice11\` property value as a StringType object if defined; else null
   */
  public getChoice11StringType(): StringType | null {
    if (!isDefined<DataType>(this.choice11)) {
      return null;
    }
    if (!(this.choice11 instanceof StringType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for TestDataModel.backbonePrimitive0x.choice11[x]: Expected StringType but encountered \${this.choice11.fhirType()}\`,
      );
    }
    return this.choice11;
  }

  /**
   * @returns \`true\` if the \`\` property exists as a StringType and has a value; \`false\` otherwise
   */
  public hasChoice11StringType(): boolean {
    return this.hasChoice11() && this.choice11 instanceof StringType;
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'TestDataModel.backbonePrimitive0x';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.primitive01,
      this.primitive0x,
      this.primitive11,
      this.primitive1x,
      this.choice11,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): TestDataModelBackbonePrimitive0XComponent {
    const dest = new TestDataModelBackbonePrimitive0XComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: TestDataModelBackbonePrimitive0XComponent): void {
    super.copyValues(dest);
    dest.primitive01 = this.primitive01?.copy();
    const primitive0xList = copyListValues<IntegerType>(this.primitive0x);
    dest.primitive0x = primitive0xList.length === 0 ? undefined : primitive0xList;
    dest.primitive11 = this.primitive11 ? this.primitive11.copy() : null;
    const primitive1xList = copyListValues<StringType>(this.primitive1x);
    dest.primitive1x = primitive1xList.length === 0 ? null : primitive1xList;
    dest.choice11 = this.choice11 ? this.choice11.copy() : null;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasPrimitive01Element()) {
      setFhirPrimitiveJson<fhirDateTime>(this.getPrimitive01Element(), 'primitive01', jsonObj);
    }

    if (this.hasPrimitive0x()) {
      setFhirPrimitiveListJson(this.getPrimitive0xElement(), 'primitive0x', jsonObj);
    }

    if (this.hasPrimitive11Element()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirBoolean>(this.getPrimitive11Element()!, 'primitive11', jsonObj);
    } else {
      missingReqdProperties.push(\`TestDataModel.backbonePrimitive0x.primitive11\`);
    }

    if (this.hasPrimitive1xElement()) {
      setFhirPrimitiveListJson(this.getPrimitive1xElement(), 'primitive1x', jsonObj);
    } else {
      missingReqdProperties.push(\`TestDataModel.backbonePrimitive0x.primitive1x\`);
    }

    if (this.hasChoice11()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getChoice11()!, 'choice11', jsonObj);
    } else {
      missingReqdProperties.push(\`TestDataModel.backbonePrimitive0x.choice11[x][x]\`);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

/**
 * TestDataModelBackboneComplex01Component Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** backboneComplex01
 * - **Definition:** backboneComplex01
 * - **Requirements:** Optional single TestDataModelComplexComponent \\'BackboneElement\\'
 *
 * @category DataModel: Resource
 * @see [FHIR TestDataModel](https://test.ts-fhir-datamodels.com/StructureDefinition/TestDataModel)
 */
export class TestDataModelBackboneComplex01Component extends BackboneElement {
  constructor(complex11: Dosage | null = null, complex1x: Period[] | null = null, backboneReference11: TestDataModelBackboneComplex01BackboneReference11Component | null = null) {
    super();

    this.complex11 = null;
    if (isDefined<Dosage>(complex11)) {
      this.setComplex11(complex11);
    }

    this.complex1x = null;
    if (isDefinedList<Period>(complex1x)) {
      this.setComplex1x(complex1x);
    }

    this.backboneReference11 = null;
    if (isDefined<TestDataModelBackboneComplex01BackboneReference11Component>(backboneReference11)) {
      this.setBackboneReference11(backboneReference11);
    }
  }

  /**
   * Parse the provided \`TestDataModelBackboneComplex01Component\` JSON to instantiate the TestDataModelBackboneComplex01Component data model.
   *
   * @param sourceJson - JSON representing FHIR \`TestDataModelBackboneComplex01Component\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to TestDataModelBackboneComplex01Component
   * @returns TestDataModelBackboneComplex01Component data model or undefined for \`TestDataModelBackboneComplex01Component\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): TestDataModelBackboneComplex01Component | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'TestDataModelBackboneComplex01Component';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new TestDataModelBackboneComplex01Component();
    fhirDataTypeParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';

    const missingReqdProperties: string[] = [];

    fieldName = 'complex01';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: HumanName | undefined = fhirDataTypeParser.parser<HumanName>(HumanName, classJsonObj[fieldName]!, sourceField);
      instance.setComplex01(datatype);
    }

    fieldName = 'complex0x';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Address | undefined = fhirDataTypeParser.parser<Address>(Address, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addComplex0x(datatype);
        }
      });
    }

    fieldName = 'complex11';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Dosage | undefined = fhirDataTypeParser.parser<Dosage>(Dosage, classJsonObj[fieldName]!, sourceField);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setComplex11(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'complex1x';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Period | undefined = fhirDataTypeParser.parser<Period>(Period, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype === undefined) {
          missingReqdProperties.push(\`\${sourceField}[\${String(idx)}]\`);
        } else {
          instance.addComplex1x(datatype);
        }
      });
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'backboneReference11';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const component: TestDataModelBackboneComplex01BackboneReference11Component | undefined = TestDataModelBackboneComplex01BackboneReference11Component.parse(classJsonObj[fieldName]!, sourceField);
      if (component === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setBackboneReference11(component);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * TestDataModel.backboneComplex01.complex01 Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** complex01
   * - **Definition:** complex01
   * - **Requirements:** Optional single \\'HumanName\\' data type
   * - **FHIR Type:** \`HumanName\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private complex01?: HumanName | undefined;

  /**
   * TestDataModel.backboneComplex01.complex0x Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** complex0x
   * - **Definition:** complex0x
   * - **Requirements:** Optional list of \\'Address\\' data type
   * - **FHIR Type:** \`Address\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private complex0x?: Address[] | undefined;

  /**
   * TestDataModel.backboneComplex01.complex11 Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** complex11
   * - **Definition:** complex11
   * - **Requirements:** Required single \\'Dosage\\' data type
   * - **FHIR Type:** \`Dosage\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private complex11: Dosage | null;

  /**
   * TestDataModel.backboneComplex01.complex1x Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** complex1x
   * - **Definition:** complex1x
   * - **Requirements:** Required list of \\'Period\\' data type
   * - **FHIR Type:** \`Period\`
   * - **Cardinality:** 1..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private complex1x: Period[] | null;

  /**
   * TestDataModel.backboneComplex01.backboneReference11 Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** backboneReference11
   * - **Definition:** backboneReference11
   * - **Requirements:** Required single TestDataModelReferenceComponent \\'BackboneElement\\'
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private backboneReference11: TestDataModelBackboneComplex01BackboneReference11Component | null;


  /**
   * @returns the \`complex01\` property value as a HumanName object if defined; else an empty HumanName object
   */
  public getComplex01(): HumanName {
    return this.complex01 ?? new HumanName();
  }

  /**
   * Assigns the provided Complex01 object value to the \`complex01\` property.
   *
   * @param value - the \`complex01\` object value
   * @returns this
   */
  public setComplex01(value: HumanName | undefined): this {
    if (isDefined<HumanName>(value)) {
      const optErrMsg = \`Invalid TestDataModel.backboneComplex01.complex01; Provided element is not an instance of HumanName.\`;
      assertFhirType<HumanName>(value, HumanName, optErrMsg);
      this.complex01 = value;
    } else {
      this.complex01 = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`complex01\` property exists and has a value; \`false\` otherwise
   */
  public hasComplex01(): boolean {
    return isDefined<HumanName>(this.complex01) && !this.complex01.isEmpty();
  }

  /**
   * @returns the \`complex0x\` property value as a Address array
   */
  public getComplex0x(): Address[] {
    return this.complex0x ?? ([] as Address[]);
  }

  /**
   * Assigns the provided Address array value to the \`complex0x\` property.
   *
   * @param value - the \`complex0x\` array value
   * @returns this
   */
  public setComplex0x(value: Address[] | undefined): this {
    if (isDefinedList<Address>(value)) {
      const optErrMsg = \`Invalid TestDataModel.backboneComplex01.complex0x; Provided value array has an element that is not an instance of Address.\`;
      assertFhirTypeList<Address>(value, Address, optErrMsg);
      this.complex0x = value;
    } else {
      this.complex0x = undefined;
    }
    return this;
  }

  /**
   * Add the provided Address value to the \`complex0x\` array property.
   *
   * @param value - the \`complex0x\` value
   * @returns this
   */
  public addComplex0x(value: Address | undefined): this {
    if (isDefined<Address>(value)) {
      const optErrMsg = \`Invalid TestDataModel.backboneComplex01.complex0x; Provided element is not an instance of Address.\`;
      assertFhirType<Address>(value, Address, optErrMsg);
      this.initComplex0x();
      this.complex0x?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`complex0x\` property exists and has a value; \`false\` otherwise
   */
  public hasComplex0x(): boolean {
    return isDefinedList<Address>(this.complex0x) && this.complex0x.some((item: Address) => !item.isEmpty());
  }

  /**
   * Initialize the \`complex0x\` property
   */
  private initComplex0x(): void {
    if(!this.hasComplex0x()) {
      this.complex0x = [] as Address[];
    }
  }

  /**
   * @returns the \`complex11\` property value as a Dosage object if defined; else null
   */
  public getComplex11(): Dosage | null {
    return this.complex11;
  }

  /**
   * Assigns the provided Dosage object value to the \`complex11\` property.
   *
   * @param value - the \`complex11\` object value
   * @returns this
   */
  public setComplex11(value: Dosage): this {
    assertIsDefined<Dosage>(value, \`TestDataModel.backboneComplex01.complex11 is required\`);
    const optErrMsg = \`Invalid TestDataModel.backboneComplex01.complex11; Provided element is not an instance of Dosage.\`;
    assertFhirType<Dosage>(value, Dosage, optErrMsg);
    this.complex11 = value;
    return this;
  }

  /**
   * @returns \`true\` if the \`complex11\` property exists and has a value; \`false\` otherwise
   */
  public hasComplex11(): boolean {
    return isDefined<Dosage>(this.complex11) && !this.complex11.isEmpty();
  }

  /**
   * @returns the \`complex1x\` property value as a Period array
   */
  public getComplex1x(): Period[] {
    return this.complex1x ?? ([] as Period[]);
  }

  /**
   * Assigns the provided Period array value to the \`complex1x\` property.
   *
   * @param value - the \`complex1x\` array value
   * @returns this
   */
  public setComplex1x(value: Period[]): this {
    assertIsDefinedList<Period>(value, \`TestDataModel.backboneComplex01.complex1x is required\`);
    const optErrMsg = \`Invalid TestDataModel.backboneComplex01.complex1x; Provided value array has an element that is not an instance of Period.\`;
    assertFhirTypeList<Period>(value, Period, optErrMsg);
    this.complex1x = value;
    return this;
  }

  /**
   * Add the provided Period value to the \`complex1x\` array property.
   *
   * @param value - the \`complex1x\` value
   * @returns this
   */
  public addComplex1x(value: Period | undefined): this {
    if (isDefined<Period>(value)) {
      const optErrMsg = \`Invalid TestDataModel.backboneComplex01.complex1x; Provided element is not an instance of Period.\`;
      assertFhirType<Period>(value, Period, optErrMsg);
      this.initComplex1x();
      this.complex1x?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`complex1x\` property exists and has a value; \`false\` otherwise
   */
  public hasComplex1x(): boolean {
    return isDefinedList<Period>(this.complex1x) && this.complex1x.some((item: Period) => !item.isEmpty());
  }

  /**
   * Initialize the \`complex1x\` property
   */
  private initComplex1x(): void {
    if(!this.hasComplex1x()) {
      this.complex1x = [] as Period[];
    }
  }

  /**
   * @returns the \`backboneReference11\` property value as a TestDataModelBackboneComplex01BackboneReference11Component object if defined; else null
   */
  public getBackboneReference11(): TestDataModelBackboneComplex01BackboneReference11Component | null {
    return this.backboneReference11;
  }

  /**
   * Assigns the provided TestDataModelBackboneComplex01BackboneReference11Component object value to the \`backboneReference11\` property.
   *
   * @param value - the \`backboneReference11\` object value
   * @returns this
   */
  public setBackboneReference11(value: TestDataModelBackboneComplex01BackboneReference11Component): this {
    assertIsDefined<TestDataModelBackboneComplex01BackboneReference11Component>(value, \`TestDataModel.backboneComplex01.backboneReference11 is required\`);
    const optErrMsg = \`Invalid TestDataModel.backboneComplex01.backboneReference11; Provided element is not an instance of TestDataModelBackboneComplex01BackboneReference11Component.\`;
    assertFhirType<TestDataModelBackboneComplex01BackboneReference11Component>(value, TestDataModelBackboneComplex01BackboneReference11Component, optErrMsg);
    this.backboneReference11 = value;
    return this;
  }

  /**
   * @returns \`true\` if the \`backboneReference11\` property exists and has a value; \`false\` otherwise
   */
  public hasBackboneReference11(): boolean {
    return isDefined<TestDataModelBackboneComplex01BackboneReference11Component>(this.backboneReference11) && !this.backboneReference11.isEmpty();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'TestDataModel.backboneComplex01';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.complex01,
      this.complex0x,
      this.complex11,
      this.complex1x,
      this.backboneReference11,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): TestDataModelBackboneComplex01Component {
    const dest = new TestDataModelBackboneComplex01Component();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: TestDataModelBackboneComplex01Component): void {
    super.copyValues(dest);
    dest.complex01 = this.complex01?.copy();
    const complex0xList = copyListValues<Address>(this.complex0x);
    dest.complex0x = complex0xList.length === 0 ? undefined : complex0xList;
    dest.complex11 = this.complex11 ? this.complex11.copy() : null;
    const complex1xList = copyListValues<Period>(this.complex1x);
    dest.complex1x = complex1xList.length === 0 ? null : complex1xList;
    dest.backboneReference11 = this.backboneReference11 ? this.backboneReference11.copy() : null;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasComplex01()) {
      setFhirComplexJson(this.getComplex01(), 'complex01', jsonObj);
    }

    if (this.hasComplex0x()) {
      setFhirComplexListJson(this.getComplex0x(), 'complex0x', jsonObj);
    }

    if (this.hasComplex11()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirComplexJson(this.getComplex11()!, 'complex11', jsonObj);
    } else {
      missingReqdProperties.push(\`TestDataModel.backboneComplex01.complex11\`);
    }

    if (this.hasComplex1x()) {
      setFhirComplexListJson(this.getComplex1x(), 'complex1x', jsonObj);
    } else {
      missingReqdProperties.push(\`TestDataModel.backboneComplex01.complex1x\`);
    }

    if (this.hasBackboneReference11()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirBackboneElementJson(this.getBackboneReference11()!, 'backboneReference11', jsonObj);
    } else {
      missingReqdProperties.push(\`TestDataModel.backboneComplex01.backboneReference11\`);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

/**
 * TestDataModelBackboneComplex01BackboneReference11Component Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** backboneReference11
 * - **Definition:** backboneReference11
 * - **Requirements:** Required single TestDataModelReferenceComponent \\'BackboneElement\\'
 *
 * @category DataModel: Resource
 * @see [FHIR TestDataModel](https://test.ts-fhir-datamodels.com/StructureDefinition/TestDataModel)
 */
export class TestDataModelBackboneComplex01BackboneReference11Component extends BackboneElement {
  constructor(reference11: Reference | null = null, reference1x: Reference[] | null = null, backboneEnumCode1x: TestDataModelBackboneComplex01BackboneReference11BackboneEnumCode1XComponent[] | null = null) {
    super();

    this.reference11 = null;
    if (isDefined<Reference>(reference11)) {
      this.setReference11(reference11);
    }

    this.reference1x = null;
    if (isDefinedList<Reference>(reference1x)) {
      this.setReference1x(reference1x);
    }

    this.backboneEnumCode1x = null;
    if (isDefinedList<TestDataModelBackboneComplex01BackboneReference11BackboneEnumCode1XComponent>(backboneEnumCode1x)) {
      this.setBackboneEnumCode1x(backboneEnumCode1x);
    }
  }

  /**
   * Parse the provided \`TestDataModelBackboneComplex01BackboneReference11Component\` JSON to instantiate the TestDataModelBackboneComplex01BackboneReference11Component data model.
   *
   * @param sourceJson - JSON representing FHIR \`TestDataModelBackboneComplex01BackboneReference11Component\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to TestDataModelBackboneComplex01BackboneReference11Component
   * @returns TestDataModelBackboneComplex01BackboneReference11Component data model or undefined for \`TestDataModelBackboneComplex01BackboneReference11Component\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): TestDataModelBackboneComplex01BackboneReference11Component | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'TestDataModelBackboneComplex01BackboneReference11Component';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new TestDataModelBackboneComplex01BackboneReference11Component();
    fhirDataTypeParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';

    const missingReqdProperties: string[] = [];

    fieldName = 'reference01';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = fhirDataTypeParser.parser<Reference>(Reference, classJsonObj[fieldName]!, sourceField);
      instance.setReference01(datatype);
    }

    fieldName = 'reference0x';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Reference | undefined = fhirDataTypeParser.parser<Reference>(Reference, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addReference0x(datatype);
        }
      });
  }

    fieldName = 'reference11';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = fhirDataTypeParser.parser<Reference>(Reference, classJsonObj[fieldName]!, sourceField);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setReference11(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'reference1x';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Reference | undefined = fhirDataTypeParser.parser<Reference>(Reference, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype === undefined) {
          missingReqdProperties.push(\`\${sourceField}[\${String(idx)}]\`);
        } else {
          instance.addReference1x(datatype);
        }
      });
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'backboneEnumCode1x';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const componentJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      componentJsonArray.forEach((componentJson: JSON.Value, idx) => {
        const component: TestDataModelBackboneComplex01BackboneReference11BackboneEnumCode1XComponent | undefined = TestDataModelBackboneComplex01BackboneReference11BackboneEnumCode1XComponent.parse(componentJson, \`\${sourceField}[\${String(idx)}]\`);
        if (component === undefined) {
          missingReqdProperties.push(\`\${sourceField}[\${String(idx)}]\`);
        } else {
          instance.addBackboneEnumCode1x(component);
        }
      });
    } else {
      missingReqdProperties.push(sourceField);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * TestDataModel.backboneComplex01.backboneReference11.reference01 Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** backboneReference11.reference01
   * - **Definition:** backboneReference11.reference01
   * - **Requirements:** Optional single \\'Reference(any)\\' data type
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Resource',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private reference01?: Reference | undefined;

  /**
   * TestDataModel.backboneComplex01.backboneReference11.reference0x Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** backboneReference11.reference0x
   * - **Definition:** backboneReference11.reference0x
   * - **Requirements:** Optional list of \\'Reference(Practitioner or PractitionerRole or Organization)\\' data type
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Practitioner',
   *       'http://hl7.org/fhir/StructureDefinition/PractitionerRole',
   *       'http://hl7.org/fhir/StructureDefinition/Organization',
   *     ]
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private reference0x?: Reference[] | undefined;

  /**
   * TestDataModel.backboneComplex01.backboneReference11.reference11 Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** backboneReference11.reference11
   * - **Definition:** backboneReference11.reference11
   * - **Requirements:** Required single \\'Reference(Patient or SimplePersonModel)\\' data type
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Patient',
   *       'https://test.ts-fhir-datamodels.com/StructureDefinition/SimplePersonModel',
   *     ]
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private reference11: Reference | null;

  /**
   * TestDataModel.backboneComplex01.backboneReference11.reference1x Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** backboneReference11.reference1x
   * - **Definition:** backboneReference11.reference1x
   * - **Requirements:** Required list of \\'Reference(Condition)\\' data type
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Condition',
   *     ]
   * - **Cardinality:** 1..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private reference1x: Reference[] | null;

  /**
   * TestDataModel.backboneComplex01.backboneReference11.backboneEnumCode1x Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** backboneEnumCode1x
   * - **Definition:** backboneEnumCode1x
   * - **Requirements:** Required list of TestDataModelEnumCodeComponent \\'BackboneElement\\'
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 1..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private backboneEnumCode1x: TestDataModelBackboneComplex01BackboneReference11BackboneEnumCode1XComponent[] | null;


  /**
   * @returns the \`reference01\` property value as a Reference object; else an empty Reference object
   */
  public getReference01(): Reference {
    return this.reference01 ?? new Reference();
  }

  /**
   * Assigns the provided Reference01 object value to the \`reference01\` property.
   *
   * @decorator \`@ReferenceTargets('TestDataModel.backboneComplex01.backboneReference11.reference01', ['Resource',])\`
   *
   * @param value - the \`reference01\` object value
   * @returns this
   */
  @ReferenceTargets('TestDataModel.backboneComplex01.backboneReference11.reference01', [
    'Resource',
  ])
  public setReference01(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.reference01 = value;
    } else {
      this.reference01 = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`reference01\` property exists and has a value; \`false\` otherwise
   */
  public hasReference01(): boolean {
    return isDefined<Reference>(this.reference01) && !this.reference01.isEmpty();
  }

  /**
   * @returns the \`reference0x\` property value as a Reference array
   */
  public getReference0x(): Reference[] {
    return this.reference0x ?? ([] as Reference[]);
  }

  /**
   * Assigns the provided Reference array value to the \`reference0x\` property.
   *
   * @decorator \`@ReferenceTargets('TestDataModel.backboneComplex01.backboneReference11.reference0x', ['Practitioner','PractitionerRole','Organization',])\`
   *
   * @param value - the \`reference0x\` array value
   * @returns this
   */
  @ReferenceTargets('TestDataModel.backboneComplex01.backboneReference11.reference0x', [
    'Practitioner',
  
    'PractitionerRole',
  
    'Organization',
  ])
  public setReference0x(value: Reference[] | undefined): this {
    if (isDefinedList<Reference>(value)) {
      // assertFhirTypeList<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.reference0x = value;
    } else {
      this.reference0x = undefined;
    }
    return this;
  }

  /**
   * Add the provided Reference value to the \`reference0x\` array property.
   *
   * @decorator \`@ReferenceTargets('TestDataModel.backboneComplex01.backboneReference11.reference0x', ['Practitioner','PractitionerRole','Organization',])\`
   *
   * @param value - the \`reference0x\` value
   * @returns this
   */
  @ReferenceTargets('TestDataModel.backboneComplex01.backboneReference11.reference0x', [
    'Practitioner',
  
    'PractitionerRole',
  
    'Organization',
  ])
  public addReference0x(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.initReference0x();
      this.reference0x?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`reference0x\` property exists and has a value; \`false\` otherwise
   */
  public hasReference0x(): boolean {
    return isDefinedList<Reference>(this.reference0x) && this.reference0x.some((item: Reference) => !item.isEmpty());
  }

  /**
   * Initialize the \`reference0x\` property
   */
  private initReference0x(): void {
    if (!this.hasReference0x()) {
      this.reference0x = [] as Reference[];
    }
  }

  /**
   * @returns the \`reference11\` property value as a Reference object if defined; else null
   */
  public getReference11(): Reference | null {
    return this.reference11;
  }

  /**
   * Assigns the provided Reference11 object value to the \`reference11\` property.
   *
   * @decorator \`@ReferenceTargets('TestDataModel.backboneComplex01.backboneReference11.reference11', ['Patient','SimplePersonModel',])\`
   *
   * @param value - the \`reference11\` object value
   * @returns this
   */
  @ReferenceTargets('TestDataModel.backboneComplex01.backboneReference11.reference11', [
    'Patient',
  
    'SimplePersonModel',
  ])
  public setReference11(value: Reference): this {
    assertIsDefined<Reference>(value, \`TestDataModel.backboneComplex01.backboneReference11.reference11 is required\`);
    // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
    this.reference11 = value;
    return this;
  }

  /**
   * @returns \`true\` if the \`reference11\` property exists and has a value; \`false\` otherwise
   */
  public hasReference11(): boolean {
    return isDefined<Reference>(this.reference11) && !this.reference11.isEmpty();
  }

  /**
   * @returns the \`reference1x\` property value as a Reference array
   */
  public getReference1x(): Reference[] {
    return this.reference1x ?? ([] as Reference[]);
  }

  /**
   * Assigns the provided Reference array value to the \`reference1x\` property.
   *
   * @decorator \`@ReferenceTargets('TestDataModel.backboneComplex01.backboneReference11.reference1x', ['Condition',])\`
   *
   * @param value - the \`reference1x\` array value
   * @returns this
   */
  @ReferenceTargets('TestDataModel.backboneComplex01.backboneReference11.reference1x', [
    'Condition',
  ])
  public setReference1x(value: Reference[]): this {
    assertIsDefinedList<Reference>(value, \`TestDataModel.backboneComplex01.backboneReference11.reference1x is required\`);
    // assertFhirTypeList<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
    this.reference1x = value;
    return this;
  }

  /**
   * Add the provided Reference value to the \`reference1x\` array property.
   *
   * @decorator \`@ReferenceTargets('TestDataModel.backboneComplex01.backboneReference11.reference1x', ['Condition',])\`
   *
   * @param value - the \`reference1x\` value
   * @returns this
   */
  @ReferenceTargets('TestDataModel.backboneComplex01.backboneReference11.reference1x', [
    'Condition',
  ])
  public addReference1x(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.initReference1x();
      this.reference1x?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`reference1x\` property exists and has a value; \`false\` otherwise
   */
  public hasReference1x(): boolean {
    return isDefinedList<Reference>(this.reference1x) && this.reference1x.some((item: Reference) => !item.isEmpty());
  }

  /**
   * Initialize the \`reference1x\` property
   */
  private initReference1x(): void {
    if (!this.hasReference1x()) {
      this.reference1x = [] as Reference[];
    }
  }

  /**
   * @returns the \`backboneEnumCode1x\` property value as a TestDataModelBackboneComplex01BackboneReference11BackboneEnumCode1XComponent array
   */
  public getBackboneEnumCode1x(): TestDataModelBackboneComplex01BackboneReference11BackboneEnumCode1XComponent[] {
    return this.backboneEnumCode1x ?? ([] as TestDataModelBackboneComplex01BackboneReference11BackboneEnumCode1XComponent[]);
  }

  /**
   * Assigns the provided TestDataModelBackboneComplex01BackboneReference11BackboneEnumCode1XComponent array value to the \`backboneEnumCode1x\` property.
   *
   * @param value - the \`backboneEnumCode1x\` array value
   * @returns this
   */
  public setBackboneEnumCode1x(value: TestDataModelBackboneComplex01BackboneReference11BackboneEnumCode1XComponent[]): this {
    assertIsDefinedList<TestDataModelBackboneComplex01BackboneReference11BackboneEnumCode1XComponent>(value, \`TestDataModel.backboneComplex01.backboneReference11.backboneEnumCode1x is required\`);
    const optErrMsg = \`Invalid TestDataModel.backboneComplex01.backboneReference11.backboneEnumCode1x; Provided value array has an element that is not an instance of TestDataModelBackboneComplex01BackboneReference11BackboneEnumCode1XComponent.\`;
    assertFhirTypeList<TestDataModelBackboneComplex01BackboneReference11BackboneEnumCode1XComponent>(value, TestDataModelBackboneComplex01BackboneReference11BackboneEnumCode1XComponent, optErrMsg);
    this.backboneEnumCode1x = value;
    return this;
  }

  /**
   * Add the provided TestDataModelBackboneComplex01BackboneReference11BackboneEnumCode1XComponent value to the \`backboneEnumCode1x\` array property.
   *
   * @param value - the \`backboneEnumCode1x\` value
   * @returns this
   */
  public addBackboneEnumCode1x(value: TestDataModelBackboneComplex01BackboneReference11BackboneEnumCode1XComponent | undefined): this {
    if (isDefined<TestDataModelBackboneComplex01BackboneReference11BackboneEnumCode1XComponent>(value)) {
      const optErrMsg = \`Invalid TestDataModel.backboneComplex01.backboneReference11.backboneEnumCode1x; Provided element is not an instance of TestDataModelBackboneComplex01BackboneReference11BackboneEnumCode1XComponent.\`;
      assertFhirType<TestDataModelBackboneComplex01BackboneReference11BackboneEnumCode1XComponent>(value, TestDataModelBackboneComplex01BackboneReference11BackboneEnumCode1XComponent, optErrMsg);
      this.initBackboneEnumCode1x();
      this.backboneEnumCode1x?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`backboneEnumCode1x\` property exists and has a value; \`false\` otherwise
   */
  public hasBackboneEnumCode1x(): boolean {
    return isDefinedList<TestDataModelBackboneComplex01BackboneReference11BackboneEnumCode1XComponent>(this.backboneEnumCode1x) && this.backboneEnumCode1x.some((item: TestDataModelBackboneComplex01BackboneReference11BackboneEnumCode1XComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`backboneEnumCode1x\` property
   */
  private initBackboneEnumCode1x(): void {
    if(!this.hasBackboneEnumCode1x()) {
      this.backboneEnumCode1x = [] as TestDataModelBackboneComplex01BackboneReference11BackboneEnumCode1XComponent[];
    }
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'TestDataModel.backboneComplex01.backboneReference11';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.reference01,
      this.reference0x,
      this.reference11,
      this.reference1x,
      this.backboneEnumCode1x,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): TestDataModelBackboneComplex01BackboneReference11Component {
    const dest = new TestDataModelBackboneComplex01BackboneReference11Component();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: TestDataModelBackboneComplex01BackboneReference11Component): void {
    super.copyValues(dest);
    dest.reference01 = this.reference01?.copy();
    const reference0xList = copyListValues<Reference>(this.reference0x);
    dest.reference0x = reference0xList.length === 0 ? undefined : reference0xList;
    dest.reference11 = this.reference11 ? this.reference11.copy() : null;
    const reference1xList = copyListValues<Reference>(this.reference1x);
    dest.reference1x = reference1xList.length === 0 ? null : reference1xList;
    const backboneEnumCode1xList = copyListValues<TestDataModelBackboneComplex01BackboneReference11BackboneEnumCode1XComponent>(this.backboneEnumCode1x);
    dest.backboneEnumCode1x = backboneEnumCode1xList.length === 0 ? null : backboneEnumCode1xList;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasReference01()) {
      setFhirComplexJson(this.getReference01(), 'reference01', jsonObj);
    }

    if (this.hasReference0x()) {
      setFhirComplexListJson(this.getReference0x(), 'reference0x', jsonObj);
    }

    if (this.hasReference11()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirComplexJson(this.getReference11()!, 'reference11', jsonObj);
    } else {
      missingReqdProperties.push(\`TestDataModel.backboneComplex01.backboneReference11.reference11\`);
    }

    if (this.hasReference1x()) {
      setFhirComplexListJson(this.getReference1x(), 'reference1x', jsonObj);
    } else {
      missingReqdProperties.push(\`TestDataModel.backboneComplex01.backboneReference11.reference1x\`);
    }

    if (this.hasBackboneEnumCode1x()) {
      setFhirBackboneElementListJson(this.getBackboneEnumCode1x(), 'backboneEnumCode1x', jsonObj);
    } else {
      missingReqdProperties.push(\`TestDataModel.backboneComplex01.backboneReference11.backboneEnumCode1x\`);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

/**
 * TestDataModelBackboneComplex01BackboneReference11BackboneEnumCode1XComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** backboneEnumCode1x
 * - **Definition:** backboneEnumCode1x
 * - **Requirements:** Required list of TestDataModelEnumCodeComponent \\'BackboneElement\\'
 *
 * @category DataModel: Resource
 * @see [FHIR TestDataModel](https://test.ts-fhir-datamodels.com/StructureDefinition/TestDataModel)
 */
export class TestDataModelBackboneComplex01BackboneReference11BackboneEnumCode1XComponent extends BackboneElement {
  constructor(enumCode11: EnumCodeType | CodeType | null = null, enumCode1x: EnumCodeType[] | CodeType[] | null = null) {
    super();

    this.taskCodeEnum = new TaskCodeEnum();
    this.contributorTypeEnum = new ContributorTypeEnum();
    this.taskStatusEnum = new TaskStatusEnum();
    this.consentStateCodesEnum = new ConsentStateCodesEnum();

    this.enumCode11 = constructorCodeValueAsEnumCodeType<ContributorTypeEnum>(
      enumCode11,
      ContributorTypeEnum,
      this.contributorTypeEnum,
      '.enumCode11',
    );

    this.enumCode1x = constructorCodeValueAsEnumCodeTypeList<ConsentStateCodesEnum>(
      enumCode1x,
      ConsentStateCodesEnum,
      this.consentStateCodesEnum,
      '.enumCode1x',
    );
  }

  /**
   * Parse the provided \`TestDataModelBackboneComplex01BackboneReference11BackboneEnumCode1XComponent\` JSON to instantiate the TestDataModelBackboneComplex01BackboneReference11BackboneEnumCode1XComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`TestDataModelBackboneComplex01BackboneReference11BackboneEnumCode1XComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to TestDataModelBackboneComplex01BackboneReference11BackboneEnumCode1XComponent
   * @returns TestDataModelBackboneComplex01BackboneReference11BackboneEnumCode1XComponent data model or undefined for \`TestDataModelBackboneComplex01BackboneReference11BackboneEnumCode1XComponent\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): TestDataModelBackboneComplex01BackboneReference11BackboneEnumCode1XComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'TestDataModelBackboneComplex01BackboneReference11BackboneEnumCode1XComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new TestDataModelBackboneComplex01BackboneReference11BackboneEnumCode1XComponent();
    fhirDataTypeParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'enumCode01';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      instance.setEnumCode01Element(datatype);
    }

    fieldName = 'enumCode11';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setEnumCode11Element(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'enumCode0x';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: CodeType | undefined = parseCodeType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addEnumCode0xElement(datatype);
        }
      });
    }

    fieldName = 'enumCode1x';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson, idx) => {
        const datatype: CodeType | undefined = parseCodeType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype === undefined) {
          missingReqdProperties.push(\`\${sourceField}[\${String(idx)}]\`);
        } else {
          instance.addEnumCode1xElement(datatype);
        }
      });
    } else {
      missingReqdProperties.push(\`XxxxParentClassElement.enumCode1x\`);
    }

    fieldName = 'backbonePrimitive01';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const component: TestDataModelBackbonePrimitive0XComponent | undefined = TestDataModelBackbonePrimitive0XComponent.parse(classJsonObj[fieldName]!, sourceField);
      instance.setBackbonePrimitive01(component);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: TaskCode
   *
   * @see {@link TaskCodeEnum }
   */
  private readonly taskCodeEnum: TaskCodeEnum;

  /**
   * TestDataModel.backboneComplex01.backboneReference11.backboneEnumCode1x.enumCode01 Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** backboneEnumCode1x.enumCode01
   * - **Definition:** backboneEnumCode1x.enumCode01
   * - **Requirements:** Optional single \\'code\\' data type with required ValueSet
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private enumCode01?: EnumCodeType | undefined;

  /**
   * FHIR CodeSystem: ContributorType
   *
   * @see {@link ContributorTypeEnum }
   */
  private readonly contributorTypeEnum: ContributorTypeEnum;

  /**
   * TestDataModel.backboneComplex01.backboneReference11.backboneEnumCode1x.enumCode11 Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** backboneEnumCode1x.enumCode11
   * - **Definition:** backboneEnumCode1x.enumCode11
   * - **Requirements:** Required single \\'code\\' data type with required ValueSet
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private enumCode11: EnumCodeType | null;

  /**
   * FHIR CodeSystem: TaskStatus
   *
   * @see {@link TaskStatusEnum }
   */
  private readonly taskStatusEnum: TaskStatusEnum;

  /**
   * TestDataModel.backboneComplex01.backboneReference11.backboneEnumCode1x.enumCode0x Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** backboneEnumCode1x.enumCode0x
   * - **Definition:** backboneEnumCode1x.enumCode0x
   * - **Requirements:** Optional list of \\'code\\' data type with required ValueSet
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private enumCode0x?: EnumCodeType[] | undefined;

  /**
   * FHIR CodeSystem: ConsentStateCodes
   *
   * @see {@link ConsentStateCodesEnum }
   */
  private readonly consentStateCodesEnum: ConsentStateCodesEnum;

  /**
   * TestDataModel.backboneComplex01.backboneReference11.backboneEnumCode1x.enumCode1x Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** backboneEnumCode1x.enumCode1x
   * - **Definition:** backboneEnumCode1x.enumCode1x
   * - **Requirements:** Required list of \\'code\\' data type with required ValueSet
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 1..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private enumCode1x: EnumCodeType[] | null;

  /**
   * TestDataModel.backboneComplex01.backboneReference11.backboneEnumCode1x.backbonePrimitive01 Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** backboneEnumCode1x.backbonePrimitive01
   * - **Definition:** backboneEnumCode1x.backbonePrimitive01
   * - **Requirements:** Optional single TestDataModelPrimitiveComponent \\'BackboneElement\\'
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private backbonePrimitive01?: TestDataModelBackbonePrimitive0XComponent | undefined;


  /**
   * @returns the \`enumCode01\` property value as a EnumCodeType if defined; else undefined
   */
  public getEnumCode01EnumType(): EnumCodeType | undefined {
    return this.enumCode01;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`enumCode01\` property.
   *
   * @param enumType - the \`enumCode01\` value
   * @returns this
   */
  public setEnumCode01EnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid TestDataModel.backboneComplex01.backboneReference11.backboneEnumCode1x.enumCode01';
      assertEnumCodeType<TaskCodeEnum>(enumType, TaskCodeEnum, errMsgPrefix);
      this.enumCode01 = enumType;
    } else {
      this.enumCode01 = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`enumCode01\` property exists and has a value; \`false\` otherwise
   */
  public hasEnumCode01EnumType(): boolean {
    return isDefined<EnumCodeType>(this.enumCode01) && !this.enumCode01.isEmpty() && this.enumCode01.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`enumCode01\` property value as a CodeType if defined; else undefined
   */
  public getEnumCode01Element(): CodeType | undefined {
    if (this.enumCode01 === undefined) {
      return undefined;
    }
    return this.enumCode01 as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`enumCode01\` property.
   *
   * @param element - the \`enumCode01\` value
   * @returns this
   */
  public setEnumCode01Element(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid TestDataModel.backboneComplex01.backboneReference11.backboneEnumCode1x.enumCode01; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.enumCode01 = new EnumCodeType(element, this.taskCodeEnum);
    } else {
      this.enumCode01 = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`enumCode01\` property exists and has a value; \`false\` otherwise
   */
  public hasEnumCode01Element(): boolean {
    return this.hasEnumCode01EnumType();
  }

  /**
   * @returns the \`enumCode01\` property value as a fhirCode if defined; else undefined
   */
  public getEnumCode01(): fhirCode | undefined {
    if (this.enumCode01 === undefined) {
      return undefined;
    }
    return this.enumCode01.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`enumCode01\` property.
   *
   * @param value - the \`enumCode01\` value
   * @returns this
   */
  public setEnumCode01(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid TestDataModel.backboneComplex01.backboneReference11.backboneEnumCode1x.enumCode01; Provided value is not an instance of fhirCode.\`;
      this.enumCode01 = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.taskCodeEnum);
    } else {
      this.enumCode01 = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`enumCode01\` property exists and has a value; \`false\` otherwise
   */
  public hasEnumCode01(): boolean {
    return this.hasEnumCode01EnumType();
  }

  /**
   * @returns the \`enumCode11\` property value as a EnumCodeType if defined; else null
   */
  public getEnumCode11EnumType(): EnumCodeType | null {
    return this.enumCode11;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`enumCode11\` property.
   *
   * @param enumType - the \`enumCode11\` value
   * @returns this
   */
  public setEnumCode11EnumType(enumType: EnumCodeType): this {
    assertIsDefined<EnumCodeType>(enumType, \`TestDataModel.backboneComplex01.backboneReference11.backboneEnumCode1x.enumCode11 is required\`);
    const errMsgPrefix = \`Invalid TestDataModel.backboneComplex01.backboneReference11.backboneEnumCode1x.enumCode11\`;
    assertEnumCodeType<ContributorTypeEnum>(enumType, ContributorTypeEnum, errMsgPrefix);
    this.enumCode11 = enumType;
    return this;
  }

  /**
   * @returns \`true\` if the \`enumCode11\` property exists and has a value; \`false\` otherwise
   */
  public hasEnumCode11EnumType(): boolean {
    return isDefined<EnumCodeType>(this.enumCode11) && !this.enumCode11.isEmpty() && this.enumCode11.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`enumCode11\` property value as a CodeType if defined; else null
   */
  public getEnumCode11Element(): CodeType | null {
    if (this.enumCode11 === null) {
      return null;
    }
    return this.enumCode11 as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`enumCode11\` property.
   *
   * @param element - the \`enumCode11\` value
   * @returns this
   */
  public setEnumCode11Element(element: CodeType): this {
    assertIsDefined<CodeType>(element, \`TestDataModel.backboneComplex01.backboneReference11.backboneEnumCode1x.enumCode11 is required\`);
    const optErrMsg = \`Invalid TestDataModel.backboneComplex01.backboneReference11.backboneEnumCode1x.enumCode11; Provided value is not an instance of CodeType.\`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.enumCode11 = new EnumCodeType(element, this.contributorTypeEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`enumCode11\` property exists and has a value; \`false\` otherwise
   */
  public hasEnumCode11Element(): boolean {
    return this.hasEnumCode11EnumType();
  }

  /**
   * @returns the \`enumCode11\` property value as a fhirCode if defined; else null
   */
  public getEnumCode11(): fhirCode | null {
    if (this.enumCode11 === null) {
      return null;
    }
    return this.enumCode11.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`enumCode11\` property.
   *
   * @param value - the \`enumCode11\` value
   * @returns this
   */
  public setEnumCode11(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, \`TestDataModel.backboneComplex01.backboneReference11.backboneEnumCode1x.enumCode11 is required\`);
    const optErrMsg = \`Invalid TestDataModel.backboneComplex01.backboneReference11.backboneEnumCode1x.enumCode11 (\${String(value)})\`;
    this.enumCode11 = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.contributorTypeEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`enumCode11\` property exists and has a value; \`false\` otherwise
   */
  public hasEnumCode11(): boolean {
    return this.hasEnumCode11EnumType();
  }

  /**
   * @returns the \`enumCode0x\` property value as a EnumCodeType array
   */
  public getEnumCode0xEnumType(): EnumCodeType[] {
    return this.enumCode0x ?? ([] as EnumCodeType[]);
  }

  /**
   * Assigns the provided EnumCodeType array value to the \`enumCode0x\` property.
   *
   * @param enumType - the \`enumCode0x\` array value
   * @returns this
   */
  public setEnumCode0xEnumType(enumType: EnumCodeType[] | undefined): this {
    if (isDefinedList<EnumCodeType>(enumType)) {
      const errMsgPrefix = \`Invalid TestDataModel.backboneComplex01.backboneReference11.backboneEnumCode1x.enumCode0x\`;
      assertEnumCodeTypeList<TaskStatusEnum>(enumType, TaskStatusEnum, errMsgPrefix);
      this.enumCode0x = enumType;
    } else {
      this.enumCode0x = undefined;
    }
    return this;
  }

  /**
   * Add the provided EnumCodeType value to the \`enumCode0x\` array property.
   *
   * @param enumType - the \`enumCode0x\` value
   * @returns this
   */
  public addEnumCode0xEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = \`Invalid TestDataModel.backboneComplex01.backboneReference11.backboneEnumCode1x.enumCode0x)\`;
      assertEnumCodeType<TaskStatusEnum>(enumType, TaskStatusEnum, errMsgPrefix);
      this.initEnumCode0x();
      this.enumCode0x?.push(enumType);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`enumCode0x\` property exists and has a value; \`false\` otherwise
   */
  public hasEnumCode0xEnumType(): boolean {
    return isDefinedList<EnumCodeType>(this.enumCode0x) && this.enumCode0x.some((item: EnumCodeType) => !item.isEmpty()) && this.enumCode0x.every((item: EnumCodeType) => item.fhirCodeEnumeration.length > 0);
  }

  /**
   * @returns the \`enumCode0x\` property value as a CodeType array
   */
  public getEnumCode0xElement(): CodeType[] {
    if (this.enumCode0x === undefined) {
      return [] as CodeType[];
    }
    return this.enumCode0x as CodeType[];
  }

  /**
   * Assigns the provided PrimitiveType array value to the \`enumCode0x\` property.
   *
   * @param element - the \`enumCode0x\` array value
   * @returns this
   */
  public setEnumCode0xElement(element: CodeType[] | undefined): this {
    if (isDefinedList<CodeType>(element)) {
      const optErrMsg = \`Invalid TestDataModel.backboneComplex01.backboneReference11.backboneEnumCode1x.enumCode0x; Provided element array has an element that is not an instance of CodeType.\`;
      assertFhirTypeList<CodeType>(element, CodeType, optErrMsg);
      const enumCodeTypes = [] as EnumCodeType[];
      element.forEach((type: CodeType) => {
        enumCodeTypes.push(new EnumCodeType(type, this.taskStatusEnum));
      });
      this.enumCode0x = enumCodeTypes;
    } else {
      this.enumCode0x = undefined;
    }
    return this;
  }

  /**
   * Add the provided PrimitiveType value to the \`enumCode0x\` array property.
   *
   * @param element - the \`enumCode0x\` value
   * @returns this
   */
  public addEnumCode0xElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid TestDataModel.backboneComplex01.backboneReference11.backboneEnumCode1x.enumCode0x; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.initEnumCode0x();
      this.enumCode0x?.push(new EnumCodeType(element, this.taskStatusEnum));
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`enumCode0x\` property exists and has a value; \`false\` otherwise
   */
  public hasEnumCode0xElement(): boolean {
    return this.hasEnumCode0xEnumType();
  }

  /**
   * @returns the \`enumCode0x\` property value as a fhirCode array
   */
  public getEnumCode0x(): fhirCode[] {
    if (this.enumCode0x === undefined) {
      return [] as fhirCode[];
    }
    const values = [] as fhirCode[];
    for (const item of this.enumCode0x) {
      values.push(item.fhirCode.code);
    }
    return values;
  }

  /**
   * Assigns the provided primitive value array to the \`enumCode0x\` property.
   *
   * @param value - the \`enumCode0x\` value array
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setEnumCode0x(value: fhirCode[] | undefined): this {
    if (isDefinedList<fhirCode>(value)) {
      const enumCodeTypes = [] as EnumCodeType[];
      const optErrMsg = \`Invalid TestDataModel.backboneComplex01.backboneReference11.backboneEnumCode1x.enumCode0x; Provided value is not an instance of fhirCode.\`;
      value.forEach((val: fhirCode) => {
        enumCodeTypes.push(new EnumCodeType(parseFhirPrimitiveData(val, fhirCodeSchema, optErrMsg), this.taskStatusEnum));
      });
      this.enumCode0x = enumCodeTypes;
    } else {
      this.enumCode0x = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`enumCode0x\` array property.
   *
   * @param value - the \`enumCode0x\` value
   * @returns this
   */
  public addEnumCode0x(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      this.initEnumCode0x();
      const optErrMsg = \`Invalid TestDataModel.backboneComplex01.backboneReference11.backboneEnumCode1x.enumCode0x; Provided value is not an instance of fhirCode.\`;
      this.enumCode0x?.push(new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.taskStatusEnum));
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`enumCode0x\` property exists and has a value; \`false\` otherwise
   */
  public hasEnumCode0x(): boolean {
    return this.hasEnumCode0xEnumType();
  }

  /**
   * Initialize the enumCode0x property
   */
  private initEnumCode0x(): void {
    if(!this.hasEnumCode0xEnumType()) {
      this.enumCode0x = [] as EnumCodeType[];
    }
  }

  /**
   * @returns the \`enumCode1x\` property value as a EnumCodeType array
   */
  public getEnumCode1xEnumType(): EnumCodeType[] {
    return this.enumCode1x ?? ([] as EnumCodeType[]);
  }

  /**
   * Assigns the provided EnumCodeType array value to the \`enumCode1x\` property.
   *
   * @param enumType - the \`enumCode1x\` array value
   * @returns this
   */
  public setEnumCode1xEnumType(enumType: EnumCodeType[]): this {
    assertIsDefinedList<EnumCodeType>(enumType, \`TestDataModel.backboneComplex01.backboneReference11.backboneEnumCode1x.enumCode1x is required\`);
    const errMsgPrefix = \`Invalid TestDataModel.backboneComplex01.backboneReference11.backboneEnumCode1x.enumCode1x\`;
    assertEnumCodeTypeList<ConsentStateCodesEnum>(enumType, ConsentStateCodesEnum, errMsgPrefix);
    this.enumCode1x = enumType;
    return this;
  }

  /**
   * Add the provided EnumCodeType value to the \`enumCode1x\` array property.
   *
   * @param enumType - the \`enumCode1x\` value
   * @returns this
   */
  public addEnumCode1xEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = \`Invalid TestDataModel.backboneComplex01.backboneReference11.backboneEnumCode1x.enumCode1x)\`;
      assertEnumCodeType<ConsentStateCodesEnum>(enumType, ConsentStateCodesEnum, errMsgPrefix);
      this.initEnumCode1x();
      this.enumCode1x?.push(enumType);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`enumCode1x\` property exists and has a value; \`false\` otherwise
   */
  public hasEnumCode1xEnumType(): boolean {
    return isDefinedList<EnumCodeType>(this.enumCode1x) && this.enumCode1x.some((item: EnumCodeType) => !item.isEmpty()) && this.enumCode1x.every((item: EnumCodeType) => item.fhirCodeEnumeration.length > 0);
  }

  /**
   * @returns the \`enumCode1x\` property value as a CodeType array
   */
  public getEnumCode1xElement(): CodeType[] {
    if (this.enumCode1x === null) {
      return [] as CodeType[];
    }
    return this.enumCode1x as CodeType[];
  }

  /**
   * Assigns the provided PrimitiveType array value to the \`enumCode1x\` property.
   *
   * @param element - the \`enumCode1x\` array value
   * @returns this
   */
  public setEnumCode1xElement(element: CodeType[]): this {
    assertIsDefinedList<CodeType>(element, \`TestDataModel.backboneComplex01.backboneReference11.backboneEnumCode1x.enumCode1x is required\`);
    const optErrMsg = \`Invalid TestDataModel.backboneComplex01.backboneReference11.backboneEnumCode1x.enumCode1x; Provided element array has an element that is not an instance of CodeType.\`;
    assertFhirTypeList<CodeType>(element, CodeType, optErrMsg);
    const enumCodeTypes = [] as EnumCodeType[];
    element.forEach((type: CodeType) => {
      enumCodeTypes.push(new EnumCodeType(type, this.consentStateCodesEnum));
    });
    this.enumCode1x = enumCodeTypes;
    return this;
  }

  /**
   * Add the provided PrimitiveType value to the \`enumCode1x\` array property.
   *
   * @param element - the \`enumCode1x\` value
   * @returns this
   */
  public addEnumCode1xElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid TestDataModel.backboneComplex01.backboneReference11.backboneEnumCode1x.enumCode1x; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.initEnumCode1x();
      this.enumCode1x?.push(new EnumCodeType(element, this.consentStateCodesEnum));
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`enumCode1x\` property exists and has a value; \`false\` otherwise
   */
  public hasEnumCode1xElement(): boolean {
    return this.hasEnumCode1xEnumType();
  }

  /**
   * @returns the \`enumCode1x\` property value as a fhirCode array
   */
  public getEnumCode1x(): fhirCode[] {
    if (this.enumCode1x === null) {
      return [] as fhirCode[];
    }
    const values = [] as fhirCode[];
    for (const item of this.enumCode1x) {
      values.push(item.fhirCode.code);
    }
    return values;
  }

  /**
   * Assigns the provided primitive value array to the \`enumCode1x\` property.
   *
   * @param value - the \`enumCode1x\` value array
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setEnumCode1x(value: fhirCode[]): this {
    assertIsDefinedList<fhirCode>(value, \`TestDataModel.backboneComplex01.backboneReference11.backboneEnumCode1x.enumCode1x is required\`);
    const enumCodeTypes = [] as EnumCodeType[];
    const optErrMsg = \`Invalid TestDataModel.backboneComplex01.backboneReference11.backboneEnumCode1x.enumCode1x; Provided value is not an instance of fhirCode.\`;
    value.forEach((val: fhirCode) => {
      enumCodeTypes.push(new EnumCodeType(parseFhirPrimitiveData(val, fhirCodeSchema, optErrMsg), this.consentStateCodesEnum));
    });
    this.enumCode1x = enumCodeTypes;
    return this;
  }

  /**
   * Add the provided primitive value to the \`enumCode1x\` array property.
   *
   * @param value - the \`enumCode1x\` value
   * @returns this
   */
  public addEnumCode1x(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      this.initEnumCode1x();
      const optErrMsg = \`Invalid TestDataModel.backboneComplex01.backboneReference11.backboneEnumCode1x.enumCode1x; Provided value is not an instance of fhirCode.\`;
      this.enumCode1x?.push(new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.consentStateCodesEnum));
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`enumCode1x\` property exists and has a value; \`false\` otherwise
   */
  public hasEnumCode1x(): boolean {
    return this.hasEnumCode1xEnumType();
  }

  /**
   * Initialize the enumCode1x property
   */
  private initEnumCode1x(): void {
    if(!this.hasEnumCode1xEnumType()) {
      this.enumCode1x = [] as EnumCodeType[];
    }
  }

  /**
   * @returns the \`backbonePrimitive01\` property value as a TestDataModelBackbonePrimitive0XComponent object if defined; else an empty TestDataModelBackbonePrimitive0XComponent object
   */
  public getBackbonePrimitive01(): TestDataModelBackbonePrimitive0XComponent {
    return this.backbonePrimitive01 ?? new TestDataModelBackbonePrimitive0XComponent();
  }

  /**
   * Assigns the provided BackbonePrimitive01 object value to the \`backbonePrimitive01\` property.
   *
   * @param value - the \`backbonePrimitive01\` object value
   * @returns this
   */
  public setBackbonePrimitive01(value: TestDataModelBackbonePrimitive0XComponent | undefined): this {
    if (isDefined<TestDataModelBackbonePrimitive0XComponent>(value)) {
      const optErrMsg = \`Invalid TestDataModel.backboneComplex01.backboneReference11.backboneEnumCode1x.backbonePrimitive01; Provided element is not an instance of TestDataModelBackbonePrimitive0XComponent.\`;
      assertFhirType<TestDataModelBackbonePrimitive0XComponent>(value, TestDataModelBackbonePrimitive0XComponent, optErrMsg);
      this.backbonePrimitive01 = value;
    } else {
      this.backbonePrimitive01 = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`backbonePrimitive01\` property exists and has a value; \`false\` otherwise
   */
  public hasBackbonePrimitive01(): boolean {
    return isDefined<TestDataModelBackbonePrimitive0XComponent>(this.backbonePrimitive01) && !this.backbonePrimitive01.isEmpty();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'TestDataModel.backboneComplex01.backboneReference11.backboneEnumCode1x';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.enumCode01,
      this.enumCode11,
      this.enumCode0x,
      this.enumCode1x,
      this.backbonePrimitive01,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): TestDataModelBackboneComplex01BackboneReference11BackboneEnumCode1XComponent {
    const dest = new TestDataModelBackboneComplex01BackboneReference11BackboneEnumCode1XComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: TestDataModelBackboneComplex01BackboneReference11BackboneEnumCode1XComponent): void {
    super.copyValues(dest);
    dest.enumCode01 = this.enumCode01?.copy();
    dest.enumCode11 = this.enumCode11 ? this.enumCode11.copy() : null;
    const enumCode0xList = copyListValues<EnumCodeType>(this.enumCode0x);
    dest.enumCode0x = enumCode0xList.length === 0 ? undefined : enumCode0xList;
    const enumCode1xList = copyListValues<EnumCodeType>(this.enumCode1x);
    dest.enumCode1x = enumCode1xList.length === 0 ? null : enumCode1xList;
    dest.backbonePrimitive01 = this.backbonePrimitive01?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasEnumCode01Element()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getEnumCode01Element()!, 'enumCode01', jsonObj);
    }

    if (this.hasEnumCode11Element()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getEnumCode11Element()!, 'enumCode11', jsonObj);
    } else {
      missingReqdProperties.push(\`TestDataModel.backboneComplex01.backboneReference11.backboneEnumCode1x.enumCode11\`);
    }

    if (this.hasEnumCode0xElement()) {
      setFhirPrimitiveListJson<fhirCode>(this.getEnumCode0xElement(), 'enumCode0x', jsonObj);
    }

    if (this.hasEnumCode1xElement()) {
      setFhirPrimitiveListJson<fhirCode>(this.getEnumCode1xElement(), 'enumCode1x', jsonObj);
    } else {
      missingReqdProperties.push(\`TestDataModel.backboneComplex01.backboneReference11.backboneEnumCode1x.enumCode1x\`);
    }

    if (this.hasBackbonePrimitive01()) {
      setFhirBackboneElementJson(this.getBackbonePrimitive01(), 'backbonePrimitive01', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
",
  "fileExtension": "ts",
  "filename": "TestDataModel",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 77`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "Resource",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from by the FHIR Package Generator.
 * DO NOT make any modifications!
 * 
 * resource-types.ts Module
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

/**
 * FHIR resource types
 *
 * @remarks
 * All defined FHIR resources that ultimately extend from Resource.
 *
 * @category Type Guards/Assertions
 */
export const RESOURCE_TYPES = [
  'Condition',
  'Organization',
  'Patient',
  'Practitioner',
  'PractitionerRole',
  'Resource',
  'SimplePersonModel',
  'TestDataModel',
] as const;
",
  "fileExtension": "ts",
  "filename": "resource-types",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 78`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "Resource",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from by the FHIR Package Generator.
 * DO NOT make any modifications!
 * 
 * parsable-resource-map.ts Module
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { Resource, ParsableResource } from '../base';
import { Condition } from './Condition';
import { Organization } from './Organization';
import { Patient } from './Patient';
import { Practitioner } from './Practitioner';
import { PractitionerRole } from './PractitionerRole';
import { SimplePersonModel } from './SimplePersonModel';
import { TestDataModel } from './TestDataModel';

/**
 * PARSABLE_RESOURCE_MAP
 *
 * @remarks
 * Map of all parsable Resources where the key is the name of the Resource and the value is its ParsableResource<Resource> class.
 *
 * @category Utilities: FHIR Parsers
 */
export const PARSABLE_RESOURCE_MAP = new Map<string, ParsableResource<Resource>>();
PARSABLE_RESOURCE_MAP.set('Condition', Condition);
PARSABLE_RESOURCE_MAP.set('Organization', Organization);
PARSABLE_RESOURCE_MAP.set('Patient', Patient);
PARSABLE_RESOURCE_MAP.set('Practitioner', Practitioner);
PARSABLE_RESOURCE_MAP.set('PractitionerRole', PractitionerRole);
PARSABLE_RESOURCE_MAP.set('SimplePersonModel', SimplePersonModel);
PARSABLE_RESOURCE_MAP.set('TestDataModel', TestDataModel);
",
  "fileExtension": "ts",
  "filename": "parsable-resource-map",
}
`;

exports[`src/generator-app functional test suite generator-app verify generated content should consistently create GeneratedContent[] 79`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/generated-func-test-src",
    "debug": false,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/functional-test/ftest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "Resource",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from by the FHIR Package Generator.
 * DO NOT make any modifications!
 * 
 * index.ts Module
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

export * from './Condition';
export * from './Organization';
export * from './Patient';
export * from './Practitioner';
export * from './PractitionerRole';
export * from './SimplePersonModel';
export * from './TestDataModel';
export * from './parsable-resource-map';
export * from './resource-types';
",
  "fileExtension": "ts",
  "filename": "index",
}
`;
