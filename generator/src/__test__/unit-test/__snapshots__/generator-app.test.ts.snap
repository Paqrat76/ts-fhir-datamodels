// Jest Snapshot v1, https://jestjs.io/docs/snapshot-testing

exports[`src/generator-app unit test suite generator-app verify generated content should consistently create GeneratedContent[] 1`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/test-out",
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/utest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * ContactPointSystemEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/contact-point-system
 * CodeSystem.name: ContactPointSystem
 * CodeSystem.description: Telecommunications form for contact point.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: ContactPointSystemEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem ContactPointSystem](http://hl7.org/fhir/contact-point-system)
 */
export class ContactPointSystemEnum implements IFhirCodeEnum {
  public static readonly PHONE = new FhirCodeDefinition(
    'PHONE',
    'phone',
    'http://hl7.org/fhir/contact-point-system',
    'Phone',
    'The value is a telephone number used for voice calls. Use of full international numbers starting with + is recommended to enable automatic dialing support but not required.',
  );
  public static readonly FAX = new FhirCodeDefinition(
    'FAX',
    'fax',
    'http://hl7.org/fhir/contact-point-system',
    'Fax',
    'The value is a fax machine. Use of full international numbers starting with + is recommended to enable automatic dialing support but not required.',
  );
  public static readonly EMAIL = new FhirCodeDefinition(
    'EMAIL',
    'email',
    'http://hl7.org/fhir/contact-point-system',
    'Email',
    'The value is an email address.',
  );
  public static readonly PAGER = new FhirCodeDefinition(
    'PAGER',
    'pager',
    'http://hl7.org/fhir/contact-point-system',
    'Pager',
    'The value is a pager number. These may be local pager numbers that are only usable on a particular pager system.',
  );
  public static readonly URL = new FhirCodeDefinition(
    'URL',
    'url',
    'http://hl7.org/fhir/contact-point-system',
    'URL',
    'A contact that is not a phone, fax, pager or email address and is expressed as a URL.  This is intended for various institutional or personal contacts including web sites, blogs, Skype, Twitter, Facebook, etc. Do not use for email addresses.',
  );
  public static readonly SMS = new FhirCodeDefinition(
    'SMS',
    'sms',
    'http://hl7.org/fhir/contact-point-system',
    'SMS',
    'A contact that can be used for sending an sms message (e.g. mobile phones, some landlines).',
  );
  public static readonly OTHER = new FhirCodeDefinition(
    'OTHER',
    'other',
    'http://hl7.org/fhir/contact-point-system',
    'Other',
    'A contact that is not a phone, fax, page or email address and is not expressible as a URL.  E.g. Internal mail address.  This SHOULD NOT be used for contacts that are expressible as a URL (e.g. Skype, Twitter, Facebook, etc.)  Extensions may be used to distinguish "other" contact types.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      ContactPointSystemEnum.PHONE,
      ContactPointSystemEnum.FAX,
      ContactPointSystemEnum.EMAIL,
      ContactPointSystemEnum.PAGER,
      ContactPointSystemEnum.URL,
      ContactPointSystemEnum.SMS,
      ContactPointSystemEnum.OTHER,
      ContactPointSystemEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (ContactPointSystemEnum.PHONE.code === code) {
      return ContactPointSystemEnum.PHONE;
    } else if (ContactPointSystemEnum.FAX.code === code) {
      return ContactPointSystemEnum.FAX;
    } else if (ContactPointSystemEnum.EMAIL.code === code) {
      return ContactPointSystemEnum.EMAIL;
    } else if (ContactPointSystemEnum.PAGER.code === code) {
      return ContactPointSystemEnum.PAGER;
    } else if (ContactPointSystemEnum.URL.code === code) {
      return ContactPointSystemEnum.URL;
    } else if (ContactPointSystemEnum.SMS.code === code) {
      return ContactPointSystemEnum.SMS;
    } else if (ContactPointSystemEnum.OTHER.code === code) {
      return ContactPointSystemEnum.OTHER;
    } else if (ContactPointSystemEnum.NULL.code === code) {
      return ContactPointSystemEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown ContactPointSystemEnum 'code' value '\${String(code)}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "ContactPointSystemEnum",
}
`;

exports[`src/generator-app unit test suite generator-app verify generated content should consistently create GeneratedContent[] 2`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/test-out",
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/utest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * ContactPointUseEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/contact-point-use
 * CodeSystem.name: ContactPointUse
 * CodeSystem.description: Use of contact point.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: ContactPointUseEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem ContactPointUse](http://hl7.org/fhir/contact-point-use)
 */
export class ContactPointUseEnum implements IFhirCodeEnum {
  public static readonly HOME = new FhirCodeDefinition(
    'HOME',
    'home',
    'http://hl7.org/fhir/contact-point-use',
    'Home',
    'A communication contact point at a home; attempted contacts for business purposes might intrude privacy and chances are one will contact family or other household members instead of the person one wishes to call. Typically used with urgent cases, or if no other contacts are available.',
  );
  public static readonly WORK = new FhirCodeDefinition(
    'WORK',
    'work',
    'http://hl7.org/fhir/contact-point-use',
    'Work',
    'An office contact point. First choice for business related contacts during business hours.',
  );
  public static readonly TEMP = new FhirCodeDefinition(
    'TEMP',
    'temp',
    'http://hl7.org/fhir/contact-point-use',
    'Temp',
    'A temporary contact point. The period can provide more detailed information.',
  );
  public static readonly OLD = new FhirCodeDefinition(
    'OLD',
    'old',
    'http://hl7.org/fhir/contact-point-use',
    'Old',
    'This contact point is no longer in use (or was never correct, but retained for records).',
  );
  public static readonly MOBILE = new FhirCodeDefinition(
    'MOBILE',
    'mobile',
    'http://hl7.org/fhir/contact-point-use',
    'Mobile',
    'A telecommunication device that moves and stays with its owner. May have characteristics of all other use codes, suitable for urgent matters, not the first choice for routine business.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      ContactPointUseEnum.HOME,
      ContactPointUseEnum.WORK,
      ContactPointUseEnum.TEMP,
      ContactPointUseEnum.OLD,
      ContactPointUseEnum.MOBILE,
      ContactPointUseEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (ContactPointUseEnum.HOME.code === code) {
      return ContactPointUseEnum.HOME;
    } else if (ContactPointUseEnum.WORK.code === code) {
      return ContactPointUseEnum.WORK;
    } else if (ContactPointUseEnum.TEMP.code === code) {
      return ContactPointUseEnum.TEMP;
    } else if (ContactPointUseEnum.OLD.code === code) {
      return ContactPointUseEnum.OLD;
    } else if (ContactPointUseEnum.MOBILE.code === code) {
      return ContactPointUseEnum.MOBILE;
    } else if (ContactPointUseEnum.NULL.code === code) {
      return ContactPointUseEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown ContactPointUseEnum 'code' value '\${String(code)}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "ContactPointUseEnum",
}
`;

exports[`src/generator-app unit test suite generator-app verify generated content should consistently create GeneratedContent[] 3`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/test-out",
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/utest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * IdentifierUseEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/identifier-use
 * CodeSystem.name: IdentifierUse
 * CodeSystem.description: Identifies the purpose for this identifier, if known .
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: IdentifierUseEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem IdentifierUse](http://hl7.org/fhir/identifier-use)
 */
export class IdentifierUseEnum implements IFhirCodeEnum {
  public static readonly USUAL = new FhirCodeDefinition(
    'USUAL',
    'usual',
    'http://hl7.org/fhir/identifier-use',
    'Usual',
    'The identifier recommended for display and use in real-world interactions.',
  );
  public static readonly OFFICIAL = new FhirCodeDefinition(
    'OFFICIAL',
    'official',
    'http://hl7.org/fhir/identifier-use',
    'Official',
    'The identifier considered to be most trusted for the identification of this item. Sometimes also known as "primary" and "main". The determination of "official" is subjective and implementation guides often provide additional guidelines for use.',
  );
  public static readonly TEMP = new FhirCodeDefinition(
    'TEMP',
    'temp',
    'http://hl7.org/fhir/identifier-use',
    'Temp',
    'A temporary identifier.',
  );
  public static readonly SECONDARY = new FhirCodeDefinition(
    'SECONDARY',
    'secondary',
    'http://hl7.org/fhir/identifier-use',
    'Secondary',
    'An identifier that was assigned in secondary use - it serves to identify the object in a relative context, but cannot be consistently assigned to the same object again in a different context.',
  );
  public static readonly OLD = new FhirCodeDefinition(
    'OLD',
    'old',
    'http://hl7.org/fhir/identifier-use',
    'Old',
    'The identifier id no longer considered valid, but may be relevant for search purposes.  E.g. Changes to identifier schemes, account merges, etc.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      IdentifierUseEnum.USUAL,
      IdentifierUseEnum.OFFICIAL,
      IdentifierUseEnum.TEMP,
      IdentifierUseEnum.SECONDARY,
      IdentifierUseEnum.OLD,
      IdentifierUseEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (IdentifierUseEnum.USUAL.code === code) {
      return IdentifierUseEnum.USUAL;
    } else if (IdentifierUseEnum.OFFICIAL.code === code) {
      return IdentifierUseEnum.OFFICIAL;
    } else if (IdentifierUseEnum.TEMP.code === code) {
      return IdentifierUseEnum.TEMP;
    } else if (IdentifierUseEnum.SECONDARY.code === code) {
      return IdentifierUseEnum.SECONDARY;
    } else if (IdentifierUseEnum.OLD.code === code) {
      return IdentifierUseEnum.OLD;
    } else if (IdentifierUseEnum.NULL.code === code) {
      return IdentifierUseEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown IdentifierUseEnum 'code' value '\${String(code)}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "IdentifierUseEnum",
}
`;

exports[`src/generator-app unit test suite generator-app verify generated content should consistently create GeneratedContent[] 4`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/test-out",
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/utest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * NarrativeStatusEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/narrative-status
 * CodeSystem.name: NarrativeStatus
 * CodeSystem.description: The status of a resource narrative.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: NarrativeStatusEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem NarrativeStatus](http://hl7.org/fhir/narrative-status)
 */
export class NarrativeStatusEnum implements IFhirCodeEnum {
  public static readonly GENERATED = new FhirCodeDefinition(
    'GENERATED',
    'generated',
    'http://hl7.org/fhir/narrative-status',
    'Generated',
    'The contents of the narrative are entirely generated from the core elements in the content.',
  );
  public static readonly EXTENSIONS = new FhirCodeDefinition(
    'EXTENSIONS',
    'extensions',
    'http://hl7.org/fhir/narrative-status',
    'Extensions',
    'The contents of the narrative are entirely generated from the core elements in the content and some of the content is generated from extensions. The narrative SHALL reflect the impact of all modifier extensions.',
  );
  public static readonly ADDITIONAL = new FhirCodeDefinition(
    'ADDITIONAL',
    'additional',
    'http://hl7.org/fhir/narrative-status',
    'Additional',
    'The contents of the narrative may contain additional information not found in the structured data. Note that there is no computable way to determine what the extra information is, other than by human inspection.',
  );
  public static readonly EMPTY = new FhirCodeDefinition(
    'EMPTY',
    'empty',
    'http://hl7.org/fhir/narrative-status',
    'Empty',
    'The contents of the narrative are some equivalent of "No human-readable text provided in this case".',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      NarrativeStatusEnum.GENERATED,
      NarrativeStatusEnum.EXTENSIONS,
      NarrativeStatusEnum.ADDITIONAL,
      NarrativeStatusEnum.EMPTY,
      NarrativeStatusEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (NarrativeStatusEnum.GENERATED.code === code) {
      return NarrativeStatusEnum.GENERATED;
    } else if (NarrativeStatusEnum.EXTENSIONS.code === code) {
      return NarrativeStatusEnum.EXTENSIONS;
    } else if (NarrativeStatusEnum.ADDITIONAL.code === code) {
      return NarrativeStatusEnum.ADDITIONAL;
    } else if (NarrativeStatusEnum.EMPTY.code === code) {
      return NarrativeStatusEnum.EMPTY;
    } else if (NarrativeStatusEnum.NULL.code === code) {
      return NarrativeStatusEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown NarrativeStatusEnum 'code' value '\${String(code)}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "NarrativeStatusEnum",
}
`;

exports[`src/generator-app unit test suite generator-app verify generated content should consistently create GeneratedContent[] 5`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/test-out",
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/utest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * DaysOfWeekEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/days-of-week
 * CodeSystem.name: DaysOfWeek
 * CodeSystem.description: The days of the week.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: DaysOfWeekEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem DaysOfWeek](http://hl7.org/fhir/days-of-week)
 */
export class DaysOfWeekEnum implements IFhirCodeEnum {
  public static readonly MON = new FhirCodeDefinition(
    'MON',
    'mon',
    'http://hl7.org/fhir/days-of-week',
    'Monday',
    'Monday.',
  );
  public static readonly TUE = new FhirCodeDefinition(
    'TUE',
    'tue',
    'http://hl7.org/fhir/days-of-week',
    'Tuesday',
    'Tuesday.',
  );
  public static readonly WED = new FhirCodeDefinition(
    'WED',
    'wed',
    'http://hl7.org/fhir/days-of-week',
    'Wednesday',
    'Wednesday.',
  );
  public static readonly THU = new FhirCodeDefinition(
    'THU',
    'thu',
    'http://hl7.org/fhir/days-of-week',
    'Thursday',
    'Thursday.',
  );
  public static readonly FRI = new FhirCodeDefinition(
    'FRI',
    'fri',
    'http://hl7.org/fhir/days-of-week',
    'Friday',
    'Friday.',
  );
  public static readonly SAT = new FhirCodeDefinition(
    'SAT',
    'sat',
    'http://hl7.org/fhir/days-of-week',
    'Saturday',
    'Saturday.',
  );
  public static readonly SUN = new FhirCodeDefinition(
    'SUN',
    'sun',
    'http://hl7.org/fhir/days-of-week',
    'Sunday',
    'Sunday.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      DaysOfWeekEnum.MON,
      DaysOfWeekEnum.TUE,
      DaysOfWeekEnum.WED,
      DaysOfWeekEnum.THU,
      DaysOfWeekEnum.FRI,
      DaysOfWeekEnum.SAT,
      DaysOfWeekEnum.SUN,
      DaysOfWeekEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (DaysOfWeekEnum.MON.code === code) {
      return DaysOfWeekEnum.MON;
    } else if (DaysOfWeekEnum.TUE.code === code) {
      return DaysOfWeekEnum.TUE;
    } else if (DaysOfWeekEnum.WED.code === code) {
      return DaysOfWeekEnum.WED;
    } else if (DaysOfWeekEnum.THU.code === code) {
      return DaysOfWeekEnum.THU;
    } else if (DaysOfWeekEnum.FRI.code === code) {
      return DaysOfWeekEnum.FRI;
    } else if (DaysOfWeekEnum.SAT.code === code) {
      return DaysOfWeekEnum.SAT;
    } else if (DaysOfWeekEnum.SUN.code === code) {
      return DaysOfWeekEnum.SUN;
    } else if (DaysOfWeekEnum.NULL.code === code) {
      return DaysOfWeekEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown DaysOfWeekEnum 'code' value '\${String(code)}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "DaysOfWeekEnum",
}
`;

exports[`src/generator-app unit test suite generator-app verify generated content should consistently create GeneratedContent[] 6`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/test-out",
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/utest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * BundleTypeEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/bundle-type
 * CodeSystem.name: BundleType
 * CodeSystem.description: Indicates the purpose of a bundle - how it is intended to be used.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: BundleTypeEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem BundleType](http://hl7.org/fhir/bundle-type)
 */
export class BundleTypeEnum implements IFhirCodeEnum {
  public static readonly DOCUMENT = new FhirCodeDefinition(
    'DOCUMENT',
    'document',
    'http://hl7.org/fhir/bundle-type',
    'Document',
    'The bundle is a document. The first resource is a Composition.',
  );
  public static readonly MESSAGE = new FhirCodeDefinition(
    'MESSAGE',
    'message',
    'http://hl7.org/fhir/bundle-type',
    'Message',
    'The bundle is a message. The first resource is a MessageHeader.',
  );
  public static readonly TRANSACTION = new FhirCodeDefinition(
    'TRANSACTION',
    'transaction',
    'http://hl7.org/fhir/bundle-type',
    'Transaction',
    'The bundle is a transaction - intended to be processed by a server as an atomic commit.',
  );
  public static readonly TRANSACTION_RESPONSE = new FhirCodeDefinition(
    'TRANSACTION_RESPONSE',
    'transaction-response',
    'http://hl7.org/fhir/bundle-type',
    'Transaction Response',
    'The bundle is a transaction response. Because the response is a transaction response, the transaction has succeeded, and all responses are error free.',
  );
  public static readonly BATCH = new FhirCodeDefinition(
    'BATCH',
    'batch',
    'http://hl7.org/fhir/bundle-type',
    'Batch',
    'The bundle is a set of actions - intended to be processed by a server as a group of independent actions.',
  );
  public static readonly BATCH_RESPONSE = new FhirCodeDefinition(
    'BATCH_RESPONSE',
    'batch-response',
    'http://hl7.org/fhir/bundle-type',
    'Batch Response',
    'The bundle is a batch response. Note that as a batch, some responses may indicate failure and others success.',
  );
  public static readonly HISTORY = new FhirCodeDefinition(
    'HISTORY',
    'history',
    'http://hl7.org/fhir/bundle-type',
    'History List',
    'The bundle is a list of resources from a history interaction on a server.',
  );
  public static readonly SEARCHSET = new FhirCodeDefinition(
    'SEARCHSET',
    'searchset',
    'http://hl7.org/fhir/bundle-type',
    'Search Results',
    'The bundle is a list of resources returned as a result of a search/query interaction, operation, or message.',
  );
  public static readonly COLLECTION = new FhirCodeDefinition(
    'COLLECTION',
    'collection',
    'http://hl7.org/fhir/bundle-type',
    'Collection',
    'The bundle is a set of resources collected into a single package for ease of distribution that imposes no processing obligations or behavioral rules beyond persistence.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      BundleTypeEnum.DOCUMENT,
      BundleTypeEnum.MESSAGE,
      BundleTypeEnum.TRANSACTION,
      BundleTypeEnum.TRANSACTION_RESPONSE,
      BundleTypeEnum.BATCH,
      BundleTypeEnum.BATCH_RESPONSE,
      BundleTypeEnum.HISTORY,
      BundleTypeEnum.SEARCHSET,
      BundleTypeEnum.COLLECTION,
      BundleTypeEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (BundleTypeEnum.DOCUMENT.code === code) {
      return BundleTypeEnum.DOCUMENT;
    } else if (BundleTypeEnum.MESSAGE.code === code) {
      return BundleTypeEnum.MESSAGE;
    } else if (BundleTypeEnum.TRANSACTION.code === code) {
      return BundleTypeEnum.TRANSACTION;
    } else if (BundleTypeEnum.TRANSACTION_RESPONSE.code === code) {
      return BundleTypeEnum.TRANSACTION_RESPONSE;
    } else if (BundleTypeEnum.BATCH.code === code) {
      return BundleTypeEnum.BATCH;
    } else if (BundleTypeEnum.BATCH_RESPONSE.code === code) {
      return BundleTypeEnum.BATCH_RESPONSE;
    } else if (BundleTypeEnum.HISTORY.code === code) {
      return BundleTypeEnum.HISTORY;
    } else if (BundleTypeEnum.SEARCHSET.code === code) {
      return BundleTypeEnum.SEARCHSET;
    } else if (BundleTypeEnum.COLLECTION.code === code) {
      return BundleTypeEnum.COLLECTION;
    } else if (BundleTypeEnum.NULL.code === code) {
      return BundleTypeEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown BundleTypeEnum 'code' value '\${String(code)}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "BundleTypeEnum",
}
`;

exports[`src/generator-app unit test suite generator-app verify generated content should consistently create GeneratedContent[] 7`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/test-out",
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/utest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * SearchEntryModeEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/search-entry-mode
 * CodeSystem.name: SearchEntryMode
 * CodeSystem.description: Why an entry is in the result set - whether it\\'s included as a match or because of an _include requirement, or to convey information or warning information about the search process.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: SearchEntryModeEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem SearchEntryMode](http://hl7.org/fhir/search-entry-mode)
 */
export class SearchEntryModeEnum implements IFhirCodeEnum {
  public static readonly MATCH = new FhirCodeDefinition(
    'MATCH',
    'match',
    'http://hl7.org/fhir/search-entry-mode',
    'Match',
    'This resource matched the search specification.',
  );
  public static readonly INCLUDE = new FhirCodeDefinition(
    'INCLUDE',
    'include',
    'http://hl7.org/fhir/search-entry-mode',
    'Include',
    'This resource is returned because it is referred to from another resource in the search set.',
  );
  public static readonly OUTCOME = new FhirCodeDefinition(
    'OUTCOME',
    'outcome',
    'http://hl7.org/fhir/search-entry-mode',
    'Outcome',
    'An OperationOutcome that provides additional information about the processing of a search.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      SearchEntryModeEnum.MATCH,
      SearchEntryModeEnum.INCLUDE,
      SearchEntryModeEnum.OUTCOME,
      SearchEntryModeEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (SearchEntryModeEnum.MATCH.code === code) {
      return SearchEntryModeEnum.MATCH;
    } else if (SearchEntryModeEnum.INCLUDE.code === code) {
      return SearchEntryModeEnum.INCLUDE;
    } else if (SearchEntryModeEnum.OUTCOME.code === code) {
      return SearchEntryModeEnum.OUTCOME;
    } else if (SearchEntryModeEnum.NULL.code === code) {
      return SearchEntryModeEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown SearchEntryModeEnum 'code' value '\${String(code)}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "SearchEntryModeEnum",
}
`;

exports[`src/generator-app unit test suite generator-app verify generated content should consistently create GeneratedContent[] 8`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/test-out",
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/utest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * HttpVerbEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/http-verb
 * CodeSystem.name: HttpVerb
 * CodeSystem.description: HTTP verbs (in the HTTP command line). See [HTTP rfc](https://tools.ietf.org/html/rfc7231) for details.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: HttpVerbEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem HttpVerb](http://hl7.org/fhir/http-verb)
 */
export class HttpVerbEnum implements IFhirCodeEnum {
  public static readonly GET = new FhirCodeDefinition(
    'GET',
    'GET',
    'http://hl7.org/fhir/http-verb',
    'GET',
    'HTTP GET Command.',
  );
  public static readonly HEAD = new FhirCodeDefinition(
    'HEAD',
    'HEAD',
    'http://hl7.org/fhir/http-verb',
    'HEAD',
    'HTTP HEAD Command.',
  );
  public static readonly POST = new FhirCodeDefinition(
    'POST',
    'POST',
    'http://hl7.org/fhir/http-verb',
    'POST',
    'HTTP POST Command.',
  );
  public static readonly PUT = new FhirCodeDefinition(
    'PUT',
    'PUT',
    'http://hl7.org/fhir/http-verb',
    'PUT',
    'HTTP PUT Command.',
  );
  public static readonly DELETE = new FhirCodeDefinition(
    'DELETE',
    'DELETE',
    'http://hl7.org/fhir/http-verb',
    'DELETE',
    'HTTP DELETE Command.',
  );
  public static readonly PATCH = new FhirCodeDefinition(
    'PATCH',
    'PATCH',
    'http://hl7.org/fhir/http-verb',
    'PATCH',
    'HTTP PATCH Command.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      HttpVerbEnum.GET,
      HttpVerbEnum.HEAD,
      HttpVerbEnum.POST,
      HttpVerbEnum.PUT,
      HttpVerbEnum.DELETE,
      HttpVerbEnum.PATCH,
      HttpVerbEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (HttpVerbEnum.GET.code === code) {
      return HttpVerbEnum.GET;
    } else if (HttpVerbEnum.HEAD.code === code) {
      return HttpVerbEnum.HEAD;
    } else if (HttpVerbEnum.POST.code === code) {
      return HttpVerbEnum.POST;
    } else if (HttpVerbEnum.PUT.code === code) {
      return HttpVerbEnum.PUT;
    } else if (HttpVerbEnum.DELETE.code === code) {
      return HttpVerbEnum.DELETE;
    } else if (HttpVerbEnum.PATCH.code === code) {
      return HttpVerbEnum.PATCH;
    } else if (HttpVerbEnum.NULL.code === code) {
      return HttpVerbEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown HttpVerbEnum 'code' value '\${String(code)}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "HttpVerbEnum",
}
`;

exports[`src/generator-app unit test suite generator-app verify generated content should consistently create GeneratedContent[] 9`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/test-out",
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/utest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from by the FHIR Package Generator.
 * DO NOT make any modifications!
 * 
 * index.ts Module
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

export * from './BundleTypeEnum';
export * from './ContactPointSystemEnum';
export * from './ContactPointUseEnum';
export * from './DaysOfWeekEnum';
export * from './HttpVerbEnum';
export * from './IdentifierUseEnum';
export * from './NarrativeStatusEnum';
export * from './SearchEntryModeEnum';
",
  "fileExtension": "ts",
  "filename": "index",
}
`;

exports[`src/generator-app unit test suite generator-app verify generated content should consistently create GeneratedContent[] 10`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/test-out",
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/utest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * CodeableConcept Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/CodeableConcept
 * StructureDefinition.name: CodeableConcept
 * StructureDefinition.description: Base StructureDefinition for CodeableConcept Type: A concept that may be defined by a formal reference to a terminology or ontology or may be provided by text.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  DataType,
  FhirDataTypeParser,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  StringType,
  assertFhirType,
  assertFhirTypeList,
  copyListValues,
  fhirString,
  fhirStringSchema,
  getPrimitiveTypeJson,
  isDefined,
  isDefinedList,
  isElementEmpty,
  isEmpty,
  parseFhirPrimitiveData,
  parseStringType,
  setFhirComplexListJson,
  setFhirPrimitiveJson,
} from '@paq-ts-fhir/fhir-core';
import {
  Coding,
  PARSABLE_DATATYPE_MAP,
} from '../index';

/**
 * CodeableConcept Class
 *
 * @remarks
 * Base StructureDefinition for CodeableConcept Type: A concept that may be defined by a formal reference to a terminology or ontology or may be provided by text.
 *
 * This is a common pattern in healthcare - a concept that may be defined by one or more codes from formal definitions including LOINC and SNOMED CT, and/or defined by the provision of text that captures a human sense of the concept.
 *
 * **FHIR Specification**
 * - **Short:** Concept - reference to a terminology or just  text
 * - **Definition:** A concept that may be defined by a formal reference to a terminology or ontology or may be provided by text.
 * - **Comment:** Not all terminology uses fit this general pattern. In some cases, models should not use CodeableConcept and use Coding directly and provide their own structure for managing text, codings, translations and the relationship between elements and pre- and post-coordination.
 * - **FHIR Version:** 4.0.1
 *
 * @category DataModel: ComplexType
 * @see [FHIR CodeableConcept](http://hl7.org/fhir/StructureDefinition/CodeableConcept)
 */
export class CodeableConcept extends DataType implements IBase {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`CodeableConcept\` JSON to instantiate the CodeableConcept data model.
   *
   * @param sourceJson - JSON representing FHIR \`CodeableConcept\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to CodeableConcept
   * @returns CodeableConcept data model or undefined for \`CodeableConcept\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): CodeableConcept | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'CodeableConcept';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new CodeableConcept();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    

    fieldName = 'coding';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Coding | undefined = fhirDataTypeParser.parser<Coding>(Coding, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addCoding(datatype);
        }
      });
    }

    fieldName = 'text';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setTextElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * CodeableConcept.coding Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Code defined by a terminology system
   * - **Definition:** A reference to a code defined by a terminology system.
   * - **Comment:** Codes may be defined very casually in enumerations, or code lists, up to very formal definitions such as SNOMED CT - see the HL7 v3 Core Principles for more information.  Ordering of codings is undefined and SHALL NOT be used to infer meaning. Generally, at most only one of the coding values will be labeled as UserSelected = true.
   * - **Requirements:** Allows for alternative encodings within a code system, and translations to other code systems.
   * - **FHIR Type:** \`Coding\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private coding?: Coding[] | undefined;

  /**
   * CodeableConcept.text Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Plain text representation of the concept
   * - **Definition:** A human language representation of the concept as seen/selected/uttered by the user who entered the data and/or which represents the intended meaning of the user.
   * - **Comment:** Very often the text is the same as a displayName of one of the codings.
   * - **Requirements:** The codes from the terminologies do not always capture the correct meaning with all the nuances of the human using them, or sometimes there is no appropriate code at all. In these cases, the text is used to capture the full meaning of the source.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private text?: StringType | undefined;


  /**
   * @returns the \`coding\` property value as a Coding array
   */
  public getCoding(): Coding[] {
    return this.coding ?? ([] as Coding[]);
  }

  /**
   * Assigns the provided Coding array value to the \`coding\` property.
   *
   * @param value - the \`coding\` array value
   * @returns this
   */
  public setCoding(value: Coding[] | undefined): this {
    if (isDefinedList<Coding>(value)) {
      const optErrMsg = \`Invalid CodeableConcept.coding; Provided value array has an element that is not an instance of Coding.\`;
      assertFhirTypeList<Coding>(value, Coding, optErrMsg);
      this.coding = value;
    } else {
      this.coding = undefined;
    }
    return this;
  }

  /**
   * Add the provided Coding value to the \`coding\` array property.
   *
   * @param value - the \`coding\` value
   * @returns this
   */
  public addCoding(value: Coding | undefined): this {
    if (isDefined<Coding>(value)) {
      const optErrMsg = \`Invalid CodeableConcept.coding; Provided element is not an instance of Coding.\`;
      assertFhirType<Coding>(value, Coding, optErrMsg);
      this.initCoding();
      this.coding?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`coding\` property exists and has a value; \`false\` otherwise
   */
  public hasCoding(): boolean {
    return isDefinedList<Coding>(this.coding) && this.coding.some((item: Coding) => !item.isEmpty());
  }

  /**
   * Initialize the \`coding\` property
   */
  private initCoding(): void {
    if(!this.hasCoding()) {
      this.coding = [] as Coding[];
    }
  }

  /**
   * @returns the \`text\` property value as a StringType object if defined; else an empty StringType object
   */
  public getTextElement(): StringType {
    return this.text ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`text\` property.
   *
   * @param element - the \`text\` value
   * @returns this
   */
  public setTextElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid CodeableConcept.text; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.text = element;
    } else {
      this.text = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`text\` property exists and has a value; \`false\` otherwise
   */
  public hasTextElement(): boolean {
    return isDefined<StringType>(this.text) && !this.text.isEmpty();
  }

  /**
   * @returns the \`text\` property value as a fhirString if defined; else undefined
   */
  public getText(): fhirString | undefined {
    return this.text?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`text\` property.
   *
   * @param value - the \`text\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setText(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid CodeableConcept.text (\${String(value)})\`;
      this.text = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.text = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`text\` property exists and has a value; \`false\` otherwise
   */
  public hasText(): boolean {
    return this.hasTextElement();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'CodeableConcept';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.coding,
      this.text,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): CodeableConcept {
    const dest = new CodeableConcept();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: CodeableConcept): void {
    super.copyValues(dest);
    const codingList = copyListValues<Coding>(this.coding);
    dest.coding = codingList.length === 0 ? undefined : codingList;
    dest.text = this.text?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasCoding()) {
      setFhirComplexListJson(this.getCoding(), 'coding', jsonObj);
    }

    if (this.hasTextElement()) {
      setFhirPrimitiveJson<fhirString>(this.getTextElement(), 'text', jsonObj);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "CodeableConcept",
}
`;

exports[`src/generator-app unit test suite generator-app verify generated content should consistently create GeneratedContent[] 11`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/test-out",
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/utest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * Coding Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/Coding
 * StructureDefinition.name: Coding
 * StructureDefinition.description: Base StructureDefinition for Coding Type: A reference to a code defined by a terminology system.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  BooleanType,
  CodeType,
  DataType,
  FhirDataTypeParser,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  StringType,
  UriType,
  assertFhirType,
  fhirBoolean,
  fhirBooleanSchema,
  fhirCode,
  fhirCodeSchema,
  fhirString,
  fhirStringSchema,
  fhirUri,
  fhirUriSchema,
  getPrimitiveTypeJson,
  isDefined,
  isElementEmpty,
  isEmpty,
  parseBooleanType,
  parseCodeType,
  parseFhirPrimitiveData,
  parseStringType,
  parseUriType,
  setFhirPrimitiveJson,
} from '@paq-ts-fhir/fhir-core';
import {
  PARSABLE_DATATYPE_MAP,
} from '../index';

/**
 * Coding Class
 *
 * @remarks
 * Base StructureDefinition for Coding Type: A reference to a code defined by a terminology system.
 *
 * References to codes are very common in healthcare models.
 *
 * **FHIR Specification**
 * - **Short:** A reference to a code defined by a terminology system
 * - **Definition:** A reference to a code defined by a terminology system.
 * - **Comment:** Codes may be defined very casually in enumerations or code lists, up to very formal definitions such as SNOMED CT - see the HL7 v3 Core Principles for more information.
 * - **FHIR Version:** 4.0.1
 *
 * @category DataModel: ComplexType
 * @see [FHIR Coding](http://hl7.org/fhir/StructureDefinition/Coding)
 */
export class Coding extends DataType implements IBase {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`Coding\` JSON to instantiate the Coding data model.
   *
   * @param sourceJson - JSON representing FHIR \`Coding\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Coding
   * @returns Coding data model or undefined for \`Coding\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Coding | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Coding';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Coding();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'system';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = parseUriType(dtJson, dtSiblingJson);
      instance.setSystemElement(datatype);
    }

    fieldName = 'version';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setVersionElement(datatype);
    }

    fieldName = 'code';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      instance.setCodeElement(datatype);
    }

    fieldName = 'display';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setDisplayElement(datatype);
    }

    fieldName = 'userSelected';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'boolean';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: BooleanType | undefined = parseBooleanType(dtJson, dtSiblingJson);
      instance.setUserSelectedElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Coding.system Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Identity of the terminology system
   * - **Definition:** The identification of the code system that defines the meaning of the symbol in the code.
   * - **Comment:** The URI may be an OID (urn:oid:...) or a UUID (urn:uuid:...).  OIDs and UUIDs SHALL be references to the HL7 OID registry. Otherwise, the URI should come from HL7\\'s list of FHIR defined special URIs or it should reference to some definition that establishes the system clearly and unambiguously.
   * - **Requirements:** Need to be unambiguous about the source of the definition of the symbol.
   * - **FHIR Type:** \`uri\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private system?: UriType | undefined;

  /**
   * Coding.version Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Version of the system - if relevant
   * - **Definition:** The version of the code system which was used when choosing this code. Note that a well-maintained code system does not need the version reported, because the meaning of codes is consistent across versions. However this cannot consistently be assured, and when the meaning is not guaranteed to be consistent, the version SHOULD be exchanged.
   * - **Comment:** Where the terminology does not clearly define what string should be used to identify code system versions, the recommendation is to use the date (expressed in FHIR date format) on which that version was officially published as the version date.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private version?: StringType | undefined;

  /**
   * Coding.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Symbol in syntax defined by the system
   * - **Definition:** A symbol in syntax defined by the system. The symbol may be a predefined code or an expression in a syntax defined by the coding system (e.g. post-coordination).
   * - **Requirements:** Need to refer to a particular code in the system.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code?: CodeType | undefined;

  /**
   * Coding.display Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Representation defined by the system
   * - **Definition:** A representation of the meaning of the code in the system, following the rules of the system.
   * - **Requirements:** Need to be able to carry a human-readable meaning of the code for readers that do not know  the system.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private display?: StringType | undefined;

  /**
   * Coding.userSelected Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** If this coding was chosen directly by the user
   * - **Definition:** Indicates that this coding was chosen by a user directly - e.g. off a pick list of available items (codes or displays).
   * - **Comment:** Amongst a set of alternatives, a directly chosen code is the most appropriate starting point for new translations. There is some ambiguity about what exactly \\'directly chosen\\' implies, and trading partner agreement may be needed to clarify the use of this element and its consequences more completely.
   * - **Requirements:** This has been identified as a clinical safety criterium - that this exact system/code pair was chosen explicitly, rather than inferred by the system based on some rules or language processing.
   * - **FHIR Type:** \`boolean\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private userSelected?: BooleanType | undefined;


  /**
   * @returns the \`system\` property value as a UriType object if defined; else an empty UriType object
   */
  public getSystemElement(): UriType {
    return this.system ?? new UriType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`system\` property.
   *
   * @param element - the \`system\` value
   * @returns this
   */
  public setSystemElement(element: UriType | undefined): this {
    if (isDefined<UriType>(element)) {
      const optErrMsg = \`Invalid Coding.system; Provided element is not an instance of UriType.\`;
      assertFhirType<UriType>(element, UriType, optErrMsg);
      this.system = element;
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`system\` property exists and has a value; \`false\` otherwise
   */
  public hasSystemElement(): boolean {
    return isDefined<UriType>(this.system) && !this.system.isEmpty();
  }

  /**
   * @returns the \`system\` property value as a fhirUri if defined; else undefined
   */
  public getSystem(): fhirUri | undefined {
    return this.system?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`system\` property.
   *
   * @param value - the \`system\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setSystem(value: fhirUri | undefined): this {
    if (isDefined<fhirUri>(value)) {
      const optErrMsg = \`Invalid Coding.system (\${String(value)})\`;
      this.system = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`system\` property exists and has a value; \`false\` otherwise
   */
  public hasSystem(): boolean {
    return this.hasSystemElement();
  }

  /**
   * @returns the \`version\` property value as a StringType object if defined; else an empty StringType object
   */
  public getVersionElement(): StringType {
    return this.version ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`version\` property.
   *
   * @param element - the \`version\` value
   * @returns this
   */
  public setVersionElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Coding.version; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.version = element;
    } else {
      this.version = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`version\` property exists and has a value; \`false\` otherwise
   */
  public hasVersionElement(): boolean {
    return isDefined<StringType>(this.version) && !this.version.isEmpty();
  }

  /**
   * @returns the \`version\` property value as a fhirString if defined; else undefined
   */
  public getVersion(): fhirString | undefined {
    return this.version?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`version\` property.
   *
   * @param value - the \`version\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setVersion(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Coding.version (\${String(value)})\`;
      this.version = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.version = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`version\` property exists and has a value; \`false\` otherwise
   */
  public hasVersion(): boolean {
    return this.hasVersionElement();
  }

  /**
   * @returns the \`code\` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getCodeElement(): CodeType {
    return this.code ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`code\` property.
   *
   * @param element - the \`code\` value
   * @returns this
   */
  public setCodeElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Coding.code; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.code = element;
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`code\` property exists and has a value; \`false\` otherwise
   */
  public hasCodeElement(): boolean {
    return isDefined<CodeType>(this.code) && !this.code.isEmpty();
  }

  /**
   * @returns the \`code\` property value as a fhirCode if defined; else undefined
   */
  public getCode(): fhirCode | undefined {
    return this.code?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`code\` property.
   *
   * @param value - the \`code\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setCode(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Coding.code (\${String(value)})\`;
      this.code = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`code\` property exists and has a value; \`false\` otherwise
   */
  public hasCode(): boolean {
    return this.hasCodeElement();
  }

  /**
   * @returns the \`display\` property value as a StringType object if defined; else an empty StringType object
   */
  public getDisplayElement(): StringType {
    return this.display ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`display\` property.
   *
   * @param element - the \`display\` value
   * @returns this
   */
  public setDisplayElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Coding.display; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.display = element;
    } else {
      this.display = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`display\` property exists and has a value; \`false\` otherwise
   */
  public hasDisplayElement(): boolean {
    return isDefined<StringType>(this.display) && !this.display.isEmpty();
  }

  /**
   * @returns the \`display\` property value as a fhirString if defined; else undefined
   */
  public getDisplay(): fhirString | undefined {
    return this.display?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`display\` property.
   *
   * @param value - the \`display\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setDisplay(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Coding.display (\${String(value)})\`;
      this.display = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.display = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`display\` property exists and has a value; \`false\` otherwise
   */
  public hasDisplay(): boolean {
    return this.hasDisplayElement();
  }

  /**
   * @returns the \`userSelected\` property value as a BooleanType object if defined; else an empty BooleanType object
   */
  public getUserSelectedElement(): BooleanType {
    return this.userSelected ?? new BooleanType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`userSelected\` property.
   *
   * @param element - the \`userSelected\` value
   * @returns this
   */
  public setUserSelectedElement(element: BooleanType | undefined): this {
    if (isDefined<BooleanType>(element)) {
      const optErrMsg = \`Invalid Coding.userSelected; Provided element is not an instance of BooleanType.\`;
      assertFhirType<BooleanType>(element, BooleanType, optErrMsg);
      this.userSelected = element;
    } else {
      this.userSelected = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`userSelected\` property exists and has a value; \`false\` otherwise
   */
  public hasUserSelectedElement(): boolean {
    return isDefined<BooleanType>(this.userSelected) && !this.userSelected.isEmpty();
  }

  /**
   * @returns the \`userSelected\` property value as a fhirBoolean if defined; else undefined
   */
  public getUserSelected(): fhirBoolean | undefined {
    return this.userSelected?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`userSelected\` property.
   *
   * @param value - the \`userSelected\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setUserSelected(value: fhirBoolean | undefined): this {
    if (isDefined<fhirBoolean>(value)) {
      const optErrMsg = \`Invalid Coding.userSelected (\${String(value)})\`;
      this.userSelected = new BooleanType(parseFhirPrimitiveData(value, fhirBooleanSchema, optErrMsg));
    } else {
      this.userSelected = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`userSelected\` property exists and has a value; \`false\` otherwise
   */
  public hasUserSelected(): boolean {
    return this.hasUserSelectedElement();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Coding';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.system,
      this.version,
      this.code,
      this.display,
      this.userSelected,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Coding {
    const dest = new Coding();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Coding): void {
    super.copyValues(dest);
    dest.system = this.system?.copy();
    dest.version = this.version?.copy();
    dest.code = this.code?.copy();
    dest.display = this.display?.copy();
    dest.userSelected = this.userSelected?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasSystemElement()) {
      setFhirPrimitiveJson<fhirUri>(this.getSystemElement(), 'system', jsonObj);
    }

    if (this.hasVersionElement()) {
      setFhirPrimitiveJson<fhirString>(this.getVersionElement(), 'version', jsonObj);
    }

    if (this.hasCodeElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getCodeElement(), 'code', jsonObj);
    }

    if (this.hasDisplayElement()) {
      setFhirPrimitiveJson<fhirString>(this.getDisplayElement(), 'display', jsonObj);
    }

    if (this.hasUserSelectedElement()) {
      setFhirPrimitiveJson<fhirBoolean>(this.getUserSelectedElement(), 'userSelected', jsonObj);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "Coding",
}
`;

exports[`src/generator-app unit test suite generator-app verify generated content should consistently create GeneratedContent[] 12`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/test-out",
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/utest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * ContactPoint Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/ContactPoint
 * StructureDefinition.name: ContactPoint
 * StructureDefinition.description: Base StructureDefinition for ContactPoint Type: Details for all kinds of technology mediated contact points for a person or organization, including telephone, email, etc.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  CodeType,
  DataType,
  EnumCodeType,
  FhirDataTypeParser,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  PositiveIntType,
  StringType,
  assertEnumCodeType,
  assertFhirType,
  fhirCode,
  fhirCodeSchema,
  fhirPositiveInt,
  fhirPositiveIntSchema,
  fhirString,
  fhirStringSchema,
  getPrimitiveTypeJson,
  isDefined,
  isElementEmpty,
  isEmpty,
  parseCodeType,
  parseFhirPrimitiveData,
  parsePositiveIntType,
  parseStringType,
  setFhirComplexJson,
  setFhirPrimitiveJson,
} from '@paq-ts-fhir/fhir-core';
import {
  ContactPointSystemEnum,
  ContactPointUseEnum,
  PARSABLE_DATATYPE_MAP,
  Period,
} from '../index';

/**
 * ContactPoint Class
 *
 * @remarks
 * Base StructureDefinition for ContactPoint Type: Details for all kinds of technology mediated contact points for a person or organization, including telephone, email, etc.
 *
 * Need to track phone, fax, mobile, sms numbers, email addresses, twitter tags, etc.
 *
 * **FHIR Specification**
 * - **Short:** Details of a Technology mediated contact point (phone, fax, email, etc.)
 * - **Definition:** Details for all kinds of technology mediated contact points for a person or organization, including telephone, email, etc.
 * - **FHIR Version:** 4.0.1
 *
 * @category DataModel: ComplexType
 * @see [FHIR ContactPoint](http://hl7.org/fhir/StructureDefinition/ContactPoint)
 */
export class ContactPoint extends DataType implements IBase {
  constructor() {
    super();

    this.contactPointSystemEnum = new ContactPointSystemEnum();
    this.contactPointUseEnum = new ContactPointUseEnum();
  }

  /**
   * Parse the provided \`ContactPoint\` JSON to instantiate the ContactPoint data model.
   *
   * @param sourceJson - JSON representing FHIR \`ContactPoint\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to ContactPoint
   * @returns ContactPoint data model or undefined for \`ContactPoint\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): ContactPoint | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'ContactPoint';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new ContactPoint();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'system';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      instance.setSystemElement(datatype);
    }

    fieldName = 'value';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setValueElement(datatype);
    }

    fieldName = 'use';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      instance.setUseElement(datatype);
    }

    fieldName = 'rank';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = parsePositiveIntType(dtJson, dtSiblingJson);
      instance.setRankElement(datatype);
    }

    fieldName = 'period';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Period | undefined = fhirDataTypeParser.parser<Period>(Period, classJsonObj[fieldName]!, sourceField);
      instance.setPeriod(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: ContactPointSystem
   *
   * @see {@link ContactPointSystemEnum }
   */
  private readonly contactPointSystemEnum: ContactPointSystemEnum;

  /**
   * ContactPoint.system Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** phone | fax | email | pager | url | sms | other
   * - **Definition:** Telecommunications form for contact point - what communications system is required to make use of the contact.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private system?: EnumCodeType | undefined;

  /**
   * ContactPoint.value Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The actual contact point details
   * - **Definition:** The actual contact point details, in a form that is meaningful to the designated communication system (i.e. phone number or email address).
   * - **Comment:** Additional text data such as phone extension numbers, or notes about use of the contact are sometimes included in the value.
   * - **Requirements:** Need to support legacy numbers that are not in a tightly controlled format.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private value?: StringType | undefined;

  /**
   * FHIR CodeSystem: ContactPointUse
   *
   * @see {@link ContactPointUseEnum }
   */
  private readonly contactPointUseEnum: ContactPointUseEnum;

  /**
   * ContactPoint.use Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** home | work | temp | old | mobile - purpose of this contact point
   * - **Definition:** Identifies the purpose for the contact point.
   * - **Comment:** Applications can assume that a contact is current unless it explicitly says that it is temporary or old.
   * - **Requirements:** Need to track the way a person uses this contact, so a user can choose which is appropriate for their purpose.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** true
   * - **isModifierReason:** This is labeled as &quot;Is Modifier&quot; because applications should not mistake a temporary or old contact etc.for a current/permanent one
   * - **isSummary:** true
   */
  private use?: EnumCodeType | undefined;

  /**
   * ContactPoint.rank Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Specify preferred order of use (1 = highest)
   * - **Definition:** Specifies a preferred order in which to use a set of contacts. ContactPoints with lower rank values are more preferred than those with higher rank values.
   * - **Comment:** Note that rank does not necessarily follow the order in which the contacts are represented in the instance.
   * - **FHIR Type:** \`positiveInt\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private rank?: PositiveIntType | undefined;

  /**
   * ContactPoint.period Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Time period when the contact point was/is in use
   * - **Definition:** Time period when the contact point was/is in use.
   * - **FHIR Type:** \`Period\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private period?: Period | undefined;


  /**
   * @returns the \`system\` property value as a EnumCodeType if defined; else undefined
   */
  public getSystemEnumType(): EnumCodeType | undefined {
    return this.system;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`system\` property.
   *
   * @param enumType - the \`system\` value
   * @returns this
   */
  public setSystemEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid ContactPoint.system';
      assertEnumCodeType<ContactPointSystemEnum>(enumType, ContactPointSystemEnum, errMsgPrefix);
      this.system = enumType;
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`system\` property exists and has a value; \`false\` otherwise
   */
  public hasSystemEnumType(): boolean {
    return isDefined<EnumCodeType>(this.system) && !this.system.isEmpty() && this.system.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`system\` property value as a CodeType if defined; else undefined
   */
  public getSystemElement(): CodeType | undefined {
    if (this.system === undefined) {
      return undefined;
    }
    return this.system as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`system\` property.
   *
   * @param element - the \`system\` value
   * @returns this
   */
  public setSystemElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid ContactPoint.system; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.system = new EnumCodeType(element, this.contactPointSystemEnum);
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`system\` property exists and has a value; \`false\` otherwise
   */
  public hasSystemElement(): boolean {
    return this.hasSystemEnumType();
  }

  /**
   * @returns the \`system\` property value as a fhirCode if defined; else undefined
   */
  public getSystem(): fhirCode | undefined {
    if (this.system === undefined) {
      return undefined;
    }
    return this.system.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`system\` property.
   *
   * @param value - the \`system\` value
   * @returns this
   */
  public setSystem(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid ContactPoint.system; Provided value is not an instance of fhirCode.\`;
      this.system = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.contactPointSystemEnum);
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`system\` property exists and has a value; \`false\` otherwise
   */
  public hasSystem(): boolean {
    return this.hasSystemEnumType();
  }

  /**
   * @returns the \`value\` property value as a StringType object if defined; else an empty StringType object
   */
  public getValueElement(): StringType {
    return this.value ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`value\` property.
   *
   * @param element - the \`value\` value
   * @returns this
   */
  public setValueElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid ContactPoint.value; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.value = element;
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`value\` property exists and has a value; \`false\` otherwise
   */
  public hasValueElement(): boolean {
    return isDefined<StringType>(this.value) && !this.value.isEmpty();
  }

  /**
   * @returns the \`value\` property value as a fhirString if defined; else undefined
   */
  public getValue(): fhirString | undefined {
    return this.value?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`value\` property.
   *
   * @param value - the \`value\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setValue(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid ContactPoint.value (\${String(value)})\`;
      this.value = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`value\` property exists and has a value; \`false\` otherwise
   */
  public hasValue(): boolean {
    return this.hasValueElement();
  }

  /**
   * @returns the \`use\` property value as a EnumCodeType if defined; else undefined
   */
  public getUseEnumType(): EnumCodeType | undefined {
    return this.use;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`use\` property.
   *
   * @param enumType - the \`use\` value
   * @returns this
   */
  public setUseEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid ContactPoint.use';
      assertEnumCodeType<ContactPointUseEnum>(enumType, ContactPointUseEnum, errMsgPrefix);
      this.use = enumType;
    } else {
      this.use = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`use\` property exists and has a value; \`false\` otherwise
   */
  public hasUseEnumType(): boolean {
    return isDefined<EnumCodeType>(this.use) && !this.use.isEmpty() && this.use.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`use\` property value as a CodeType if defined; else undefined
   */
  public getUseElement(): CodeType | undefined {
    if (this.use === undefined) {
      return undefined;
    }
    return this.use as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`use\` property.
   *
   * @param element - the \`use\` value
   * @returns this
   */
  public setUseElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid ContactPoint.use; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.use = new EnumCodeType(element, this.contactPointUseEnum);
    } else {
      this.use = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`use\` property exists and has a value; \`false\` otherwise
   */
  public hasUseElement(): boolean {
    return this.hasUseEnumType();
  }

  /**
   * @returns the \`use\` property value as a fhirCode if defined; else undefined
   */
  public getUse(): fhirCode | undefined {
    if (this.use === undefined) {
      return undefined;
    }
    return this.use.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`use\` property.
   *
   * @param value - the \`use\` value
   * @returns this
   */
  public setUse(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid ContactPoint.use; Provided value is not an instance of fhirCode.\`;
      this.use = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.contactPointUseEnum);
    } else {
      this.use = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`use\` property exists and has a value; \`false\` otherwise
   */
  public hasUse(): boolean {
    return this.hasUseEnumType();
  }

  /**
   * @returns the \`rank\` property value as a PositiveIntType object if defined; else an empty PositiveIntType object
   */
  public getRankElement(): PositiveIntType {
    return this.rank ?? new PositiveIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`rank\` property.
   *
   * @param element - the \`rank\` value
   * @returns this
   */
  public setRankElement(element: PositiveIntType | undefined): this {
    if (isDefined<PositiveIntType>(element)) {
      const optErrMsg = \`Invalid ContactPoint.rank; Provided element is not an instance of PositiveIntType.\`;
      assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
      this.rank = element;
    } else {
      this.rank = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`rank\` property exists and has a value; \`false\` otherwise
   */
  public hasRankElement(): boolean {
    return isDefined<PositiveIntType>(this.rank) && !this.rank.isEmpty();
  }

  /**
   * @returns the \`rank\` property value as a fhirPositiveInt if defined; else undefined
   */
  public getRank(): fhirPositiveInt | undefined {
    return this.rank?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`rank\` property.
   *
   * @param value - the \`rank\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setRank(value: fhirPositiveInt | undefined): this {
    if (isDefined<fhirPositiveInt>(value)) {
      const optErrMsg = \`Invalid ContactPoint.rank (\${String(value)})\`;
      this.rank = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    } else {
      this.rank = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`rank\` property exists and has a value; \`false\` otherwise
   */
  public hasRank(): boolean {
    return this.hasRankElement();
  }

  /**
   * @returns the \`period\` property value as a Period object if defined; else an empty Period object
   */
  public getPeriod(): Period {
    return this.period ?? new Period();
  }

  /**
   * Assigns the provided Period object value to the \`period\` property.
   *
   * @param value - the \`period\` object value
   * @returns this
   */
  public setPeriod(value: Period | undefined): this {
    if (isDefined<Period>(value)) {
      const optErrMsg = \`Invalid ContactPoint.period; Provided element is not an instance of Period.\`;
      assertFhirType<Period>(value, Period, optErrMsg);
      this.period = value;
    } else {
      this.period = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`period\` property exists and has a value; \`false\` otherwise
   */
  public hasPeriod(): boolean {
    return isDefined<Period>(this.period) && !this.period.isEmpty();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'ContactPoint';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.system,
      this.value,
      this.use,
      this.rank,
      this.period,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): ContactPoint {
    const dest = new ContactPoint();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: ContactPoint): void {
    super.copyValues(dest);
    dest.system = this.system?.copy();
    dest.value = this.value?.copy();
    dest.use = this.use?.copy();
    dest.rank = this.rank?.copy();
    dest.period = this.period?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasSystemElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getSystemElement()!, 'system', jsonObj);
    }

    if (this.hasValueElement()) {
      setFhirPrimitiveJson<fhirString>(this.getValueElement(), 'value', jsonObj);
    }

    if (this.hasUseElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getUseElement()!, 'use', jsonObj);
    }

    if (this.hasRankElement()) {
      setFhirPrimitiveJson<fhirPositiveInt>(this.getRankElement(), 'rank', jsonObj);
    }

    if (this.hasPeriod()) {
      setFhirComplexJson(this.getPeriod(), 'period', jsonObj);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "ContactPoint",
}
`;

exports[`src/generator-app unit test suite generator-app verify generated content should consistently create GeneratedContent[] 13`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/test-out",
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/utest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * Duration Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/Duration
 * StructureDefinition.name: Duration
 * StructureDefinition.description: Base StructureDefinition for Duration Type: A length of time.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  CodeType,
  DataType,
  DecimalType,
  FhirDataTypeParser,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  StringType,
  UriType,
  assertFhirType,
  fhirCode,
  fhirCodeSchema,
  fhirDecimal,
  fhirDecimalSchema,
  fhirString,
  fhirStringSchema,
  fhirUri,
  fhirUriSchema,
  getPrimitiveTypeJson,
  isDefined,
  isElementEmpty,
  isEmpty,
  parseCodeType,
  parseDecimalType,
  parseFhirPrimitiveData,
  parseStringType,
  parseUriType,
  setFhirPrimitiveJson,
} from '@paq-ts-fhir/fhir-core';
import {
  PARSABLE_DATATYPE_MAP,
} from '../index';

/**
 * Duration Class
 *
 * @remarks
 * Base StructureDefinition for Duration Type: A length of time.
 *
 * **FHIR Specification**
 * - **Short:** A length of time
 * - **Definition:** A length of time.
 * - **Comment:** The context of use may frequently define what kind of quantity this is and therefore what kind of units can be used. The context of use may also restrict the values for the comparator.
 * - **FHIR Version:** 4.0.1
 *
 * @category DataModel: ComplexType
 * @see [FHIR Duration](http://hl7.org/fhir/StructureDefinition/Duration)
 */
export class Duration extends DataType implements IBase {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`Duration\` JSON to instantiate the Duration data model.
   *
   * @param sourceJson - JSON representing FHIR \`Duration\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Duration
   * @returns Duration data model or undefined for \`Duration\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Duration | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Duration';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Duration();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'value';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = parseDecimalType(dtJson, dtSiblingJson);
      instance.setValueElement(datatype);
    }

    fieldName = 'comparator';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      instance.setComparatorElement(datatype);
    }

    fieldName = 'unit';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setUnitElement(datatype);
    }

    fieldName = 'system';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = parseUriType(dtJson, dtSiblingJson);
      instance.setSystemElement(datatype);
    }

    fieldName = 'code';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      instance.setCodeElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Duration.value Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Numerical value (with implicit precision)
   * - **Definition:** The value of the measured amount. The value includes an implicit precision in the presentation of the value.
   * - **Comment:** The implicit precision in the value should always be honored. Monetary values have their own rules for handling precision (refer to standard accounting text books).
   * - **Requirements:** Precision is handled implicitly in almost all cases of measurement.
   * - **FHIR Type:** \`decimal\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private value?: DecimalType | undefined;

  /**
   * Duration.comparator Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** < | <= | >= | > - how to understand the value
   * - **Definition:** How the value should be understood and represented - whether the actual value is greater or less than the stated value due to measurement issues; e.g. if the comparator is "<" , then the real value is < stated value.
   * - **Requirements:** Need a framework for handling measures where the value is <5ug/L or >400mg/L due to the limitations of measuring methodology.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** true
   * - **isModifierReason:** This is labeled as &quot;Is Modifier&quot; because the comparator modifies the interpretation of the value significantly. If there is no comparator, then there is no modification of the value
   * - **isSummary:** true
   */
  private comparator?: CodeType | undefined;

  /**
   * Duration.unit Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Unit representation
   * - **Definition:** A human-readable form of the unit.
   * - **Requirements:** There are many representations for units of measure and in many contexts, particular representations are fixed and required. I.e. mcg for micrograms.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private unit?: StringType | undefined;

  /**
   * Duration.system Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** System that defines coded unit form
   * - **Definition:** The identification of the system that provides the coded form of the unit.
   * - **Requirements:** Need to know the system that defines the coded form of the unit.
   * - **FHIR Type:** \`uri\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private system?: UriType | undefined;

  /**
   * Duration.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Coded form of the unit
   * - **Definition:** A computer processable form of the unit in some unit representation system.
   * - **Comment:** The preferred system is UCUM, but SNOMED CT can also be used (for customary units) or ISO 4217 for currency.  The context of use may additionally require a code from a particular system.
   * - **Requirements:** Need a computable form of the unit that is fixed across all forms. UCUM provides this for quantities, but SNOMED CT provides many units of interest.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code?: CodeType | undefined;


  /**
   * @returns the \`value\` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getValueElement(): DecimalType {
    return this.value ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`value\` property.
   *
   * @param element - the \`value\` value
   * @returns this
   */
  public setValueElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = \`Invalid Duration.value; Provided element is not an instance of DecimalType.\`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.value = element;
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`value\` property exists and has a value; \`false\` otherwise
   */
  public hasValueElement(): boolean {
    return isDefined<DecimalType>(this.value) && !this.value.isEmpty();
  }

  /**
   * @returns the \`value\` property value as a fhirDecimal if defined; else undefined
   */
  public getValue(): fhirDecimal | undefined {
    return this.value?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`value\` property.
   *
   * @param value - the \`value\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setValue(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = \`Invalid Duration.value (\${String(value)})\`;
      this.value = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`value\` property exists and has a value; \`false\` otherwise
   */
  public hasValue(): boolean {
    return this.hasValueElement();
  }

  /**
   * @returns the \`comparator\` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getComparatorElement(): CodeType {
    return this.comparator ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`comparator\` property.
   *
   * @param element - the \`comparator\` value
   * @returns this
   */
  public setComparatorElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Duration.comparator; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.comparator = element;
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`comparator\` property exists and has a value; \`false\` otherwise
   */
  public hasComparatorElement(): boolean {
    return isDefined<CodeType>(this.comparator) && !this.comparator.isEmpty();
  }

  /**
   * @returns the \`comparator\` property value as a fhirCode if defined; else undefined
   */
  public getComparator(): fhirCode | undefined {
    return this.comparator?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`comparator\` property.
   *
   * @param value - the \`comparator\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setComparator(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Duration.comparator (\${String(value)})\`;
      this.comparator = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`comparator\` property exists and has a value; \`false\` otherwise
   */
  public hasComparator(): boolean {
    return this.hasComparatorElement();
  }

  /**
   * @returns the \`unit\` property value as a StringType object if defined; else an empty StringType object
   */
  public getUnitElement(): StringType {
    return this.unit ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`unit\` property.
   *
   * @param element - the \`unit\` value
   * @returns this
   */
  public setUnitElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Duration.unit; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.unit = element;
    } else {
      this.unit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`unit\` property exists and has a value; \`false\` otherwise
   */
  public hasUnitElement(): boolean {
    return isDefined<StringType>(this.unit) && !this.unit.isEmpty();
  }

  /**
   * @returns the \`unit\` property value as a fhirString if defined; else undefined
   */
  public getUnit(): fhirString | undefined {
    return this.unit?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`unit\` property.
   *
   * @param value - the \`unit\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setUnit(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Duration.unit (\${String(value)})\`;
      this.unit = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.unit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`unit\` property exists and has a value; \`false\` otherwise
   */
  public hasUnit(): boolean {
    return this.hasUnitElement();
  }

  /**
   * @returns the \`system\` property value as a UriType object if defined; else an empty UriType object
   */
  public getSystemElement(): UriType {
    return this.system ?? new UriType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`system\` property.
   *
   * @param element - the \`system\` value
   * @returns this
   */
  public setSystemElement(element: UriType | undefined): this {
    if (isDefined<UriType>(element)) {
      const optErrMsg = \`Invalid Duration.system; Provided element is not an instance of UriType.\`;
      assertFhirType<UriType>(element, UriType, optErrMsg);
      this.system = element;
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`system\` property exists and has a value; \`false\` otherwise
   */
  public hasSystemElement(): boolean {
    return isDefined<UriType>(this.system) && !this.system.isEmpty();
  }

  /**
   * @returns the \`system\` property value as a fhirUri if defined; else undefined
   */
  public getSystem(): fhirUri | undefined {
    return this.system?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`system\` property.
   *
   * @param value - the \`system\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setSystem(value: fhirUri | undefined): this {
    if (isDefined<fhirUri>(value)) {
      const optErrMsg = \`Invalid Duration.system (\${String(value)})\`;
      this.system = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`system\` property exists and has a value; \`false\` otherwise
   */
  public hasSystem(): boolean {
    return this.hasSystemElement();
  }

  /**
   * @returns the \`code\` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getCodeElement(): CodeType {
    return this.code ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`code\` property.
   *
   * @param element - the \`code\` value
   * @returns this
   */
  public setCodeElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Duration.code; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.code = element;
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`code\` property exists and has a value; \`false\` otherwise
   */
  public hasCodeElement(): boolean {
    return isDefined<CodeType>(this.code) && !this.code.isEmpty();
  }

  /**
   * @returns the \`code\` property value as a fhirCode if defined; else undefined
   */
  public getCode(): fhirCode | undefined {
    return this.code?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`code\` property.
   *
   * @param value - the \`code\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setCode(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Duration.code (\${String(value)})\`;
      this.code = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`code\` property exists and has a value; \`false\` otherwise
   */
  public hasCode(): boolean {
    return this.hasCodeElement();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Duration';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.value,
      this.comparator,
      this.unit,
      this.system,
      this.code,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Duration {
    const dest = new Duration();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Duration): void {
    super.copyValues(dest);
    dest.value = this.value?.copy();
    dest.comparator = this.comparator?.copy();
    dest.unit = this.unit?.copy();
    dest.system = this.system?.copy();
    dest.code = this.code?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasValueElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getValueElement(), 'value', jsonObj);
    }

    if (this.hasComparatorElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getComparatorElement(), 'comparator', jsonObj);
    }

    if (this.hasUnitElement()) {
      setFhirPrimitiveJson<fhirString>(this.getUnitElement(), 'unit', jsonObj);
    }

    if (this.hasSystemElement()) {
      setFhirPrimitiveJson<fhirUri>(this.getSystemElement(), 'system', jsonObj);
    }

    if (this.hasCodeElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getCodeElement(), 'code', jsonObj);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "Duration",
}
`;

exports[`src/generator-app unit test suite generator-app verify generated content should consistently create GeneratedContent[] 14`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/test-out",
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/utest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * Identifier Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/Identifier
 * StructureDefinition.name: Identifier
 * StructureDefinition.description: Base StructureDefinition for Identifier Type: An identifier - identifies some entity uniquely and unambiguously. Typically this is used for business identifiers.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  CodeType,
  DataType,
  EnumCodeType,
  FhirDataTypeParser,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  StringType,
  UriType,
  assertEnumCodeType,
  assertFhirType,
  fhirCode,
  fhirCodeSchema,
  fhirString,
  fhirStringSchema,
  fhirUri,
  fhirUriSchema,
  getPrimitiveTypeJson,
  isDefined,
  isElementEmpty,
  isEmpty,
  parseCodeType,
  parseFhirPrimitiveData,
  parseStringType,
  parseUriType,
  setFhirComplexJson,
  setFhirPrimitiveJson,
} from '@paq-ts-fhir/fhir-core';
import {
  CodeableConcept,
  IdentifierUseEnum,
  PARSABLE_DATATYPE_MAP,
  Period,
  Reference,
  ReferenceTargets,
} from '../index';

/**
 * Identifier Class
 *
 * @remarks
 * Base StructureDefinition for Identifier Type: An identifier - identifies some entity uniquely and unambiguously. Typically this is used for business identifiers.
 *
 * Need to be able to identify things with confidence and be sure that the identification is not subject to misinterpretation.
 *
 * **FHIR Specification**
 * - **Short:** An identifier intended for computation
 * - **Definition:** An identifier - identifies some entity uniquely and unambiguously. Typically this is used for business identifiers.
 * - **FHIR Version:** 4.0.1
 *
 * @category DataModel: ComplexType
 * @see [FHIR Identifier](http://hl7.org/fhir/StructureDefinition/Identifier)
 */
export class Identifier extends DataType implements IBase {
  constructor() {
    super();

    this.identifierUseEnum = new IdentifierUseEnum();
  }

  /**
   * Parse the provided \`Identifier\` JSON to instantiate the Identifier data model.
   *
   * @param sourceJson - JSON representing FHIR \`Identifier\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Identifier
   * @returns Identifier data model or undefined for \`Identifier\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Identifier | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Identifier';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Identifier();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'use';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      instance.setUseElement(datatype);
    }

    fieldName = 'type';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = fhirDataTypeParser.parser<CodeableConcept>(CodeableConcept, classJsonObj[fieldName]!, sourceField);
      instance.setType(datatype);
    }

    fieldName = 'system';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = parseUriType(dtJson, dtSiblingJson);
      instance.setSystemElement(datatype);
    }

    fieldName = 'value';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setValueElement(datatype);
    }

    fieldName = 'period';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Period | undefined = fhirDataTypeParser.parser<Period>(Period, classJsonObj[fieldName]!, sourceField);
      instance.setPeriod(datatype);
    }

    fieldName = 'assigner';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = fhirDataTypeParser.parser<Reference>(Reference, classJsonObj[fieldName]!, sourceField);
      instance.setAssigner(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: IdentifierUse
   *
   * @see {@link IdentifierUseEnum }
   */
  private readonly identifierUseEnum: IdentifierUseEnum;

  /**
   * Identifier.use Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** usual | official | temp | secondary | old (If known)
   * - **Definition:** The purpose of this identifier.
   * - **Comment:** Applications can assume that an identifier is permanent unless it explicitly says that it is temporary.
   * - **Requirements:** Allows the appropriate identifier for a particular context of use to be selected from among a set of identifiers.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** true
   * - **isModifierReason:** This is labeled as &quot;Is Modifier&quot; because applications should not mistake a temporary id for a permanent one.
   * - **isSummary:** true
   */
  private use?: EnumCodeType | undefined;

  /**
   * Identifier.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Description of identifier
   * - **Definition:** A coded type for the identifier that can be used to determine which identifier to use for a specific purpose.
   * - **Comment:** This element deals only with general categories of identifiers.  It SHOULD not be used for codes that correspond 1..1 with the Identifier.system. Some identifiers may fall into multiple categories due to common usage.   Where the system is known, a type is unnecessary because the type is always part of the system definition. However systems often need to handle identifiers where the system is not known. There is not a 1:1 relationship between type and system, since many different systems have the same type.
   * - **Requirements:** Allows users to make use of identifiers when the identifier system is not known.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private type_?: CodeableConcept | undefined;

  /**
   * Identifier.system Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The namespace for the identifier value
   * - **Definition:** Establishes the namespace for the value - that is, a URL that describes a set values that are unique.
   * - **Comment:** Identifier.system is always case sensitive.
   * - **Requirements:** There are many sets  of identifiers.  To perform matching of two identifiers, we need to know what set we\\'re dealing with. The system identifies a particular set of unique identifiers.
   * - **FHIR Type:** \`uri\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private system?: UriType | undefined;

  /**
   * Identifier.value Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The value that is unique
   * - **Definition:** The portion of the identifier typically relevant to the user and which is unique within the context of the system.
   * - **Comment:** If the value is a full URI, then the system SHALL be urn:ietf:rfc:3986.  The value\\'s primary purpose is computational mapping.  As a result, it may be normalized for comparison purposes (e.g. removing non-significant whitespace, dashes, etc.)  A value formatted for human display can be conveyed using the [Rendered Value extension](https://hl7.org/fhir/extension-rendered-value.html). Identifier.value is to be treated as case sensitive unless knowledge of the Identifier.system allows the processer to be confident that non-case-sensitive processing is safe.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private value?: StringType | undefined;

  /**
   * Identifier.period Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Time period when id is/was valid for use
   * - **Definition:** Time period during which identifier is/was valid for use.
   * - **FHIR Type:** \`Period\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private period?: Period | undefined;

  /**
   * Identifier.assigner Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Organization that issued id (may be just text)
   * - **Definition:** Organization that issued/manages the identifier.
   * - **Comment:** The Identifier.assigner may omit the .reference element and only contain a .display element reflecting the name or other textual information about the assigning organization.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Organization',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private assigner?: Reference | undefined;


  /**
   * @returns the \`use\` property value as a EnumCodeType if defined; else undefined
   */
  public getUseEnumType(): EnumCodeType | undefined {
    return this.use;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`use\` property.
   *
   * @param enumType - the \`use\` value
   * @returns this
   */
  public setUseEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid Identifier.use';
      assertEnumCodeType<IdentifierUseEnum>(enumType, IdentifierUseEnum, errMsgPrefix);
      this.use = enumType;
    } else {
      this.use = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`use\` property exists and has a value; \`false\` otherwise
   */
  public hasUseEnumType(): boolean {
    return isDefined<EnumCodeType>(this.use) && !this.use.isEmpty() && this.use.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`use\` property value as a CodeType if defined; else undefined
   */
  public getUseElement(): CodeType | undefined {
    if (this.use === undefined) {
      return undefined;
    }
    return this.use as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`use\` property.
   *
   * @param element - the \`use\` value
   * @returns this
   */
  public setUseElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Identifier.use; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.use = new EnumCodeType(element, this.identifierUseEnum);
    } else {
      this.use = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`use\` property exists and has a value; \`false\` otherwise
   */
  public hasUseElement(): boolean {
    return this.hasUseEnumType();
  }

  /**
   * @returns the \`use\` property value as a fhirCode if defined; else undefined
   */
  public getUse(): fhirCode | undefined {
    if (this.use === undefined) {
      return undefined;
    }
    return this.use.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`use\` property.
   *
   * @param value - the \`use\` value
   * @returns this
   */
  public setUse(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Identifier.use; Provided value is not an instance of fhirCode.\`;
      this.use = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.identifierUseEnum);
    } else {
      this.use = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`use\` property exists and has a value; \`false\` otherwise
   */
  public hasUse(): boolean {
    return this.hasUseEnumType();
  }

  /**
   * @returns the \`type_\` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getType(): CodeableConcept {
    return this.type_ ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Type object value to the \`type_\` property.
   *
   * @param value - the \`type_\` object value
   * @returns this
   */
  public setType(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Identifier.type; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.type_ = value;
    } else {
      this.type_ = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasType(): boolean {
    return isDefined<CodeableConcept>(this.type_) && !this.type_.isEmpty();
  }

  /**
   * @returns the \`system\` property value as a UriType object if defined; else an empty UriType object
   */
  public getSystemElement(): UriType {
    return this.system ?? new UriType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`system\` property.
   *
   * @param element - the \`system\` value
   * @returns this
   */
  public setSystemElement(element: UriType | undefined): this {
    if (isDefined<UriType>(element)) {
      const optErrMsg = \`Invalid Identifier.system; Provided element is not an instance of UriType.\`;
      assertFhirType<UriType>(element, UriType, optErrMsg);
      this.system = element;
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`system\` property exists and has a value; \`false\` otherwise
   */
  public hasSystemElement(): boolean {
    return isDefined<UriType>(this.system) && !this.system.isEmpty();
  }

  /**
   * @returns the \`system\` property value as a fhirUri if defined; else undefined
   */
  public getSystem(): fhirUri | undefined {
    return this.system?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`system\` property.
   *
   * @param value - the \`system\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setSystem(value: fhirUri | undefined): this {
    if (isDefined<fhirUri>(value)) {
      const optErrMsg = \`Invalid Identifier.system (\${String(value)})\`;
      this.system = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`system\` property exists and has a value; \`false\` otherwise
   */
  public hasSystem(): boolean {
    return this.hasSystemElement();
  }

  /**
   * @returns the \`value\` property value as a StringType object if defined; else an empty StringType object
   */
  public getValueElement(): StringType {
    return this.value ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`value\` property.
   *
   * @param element - the \`value\` value
   * @returns this
   */
  public setValueElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Identifier.value; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.value = element;
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`value\` property exists and has a value; \`false\` otherwise
   */
  public hasValueElement(): boolean {
    return isDefined<StringType>(this.value) && !this.value.isEmpty();
  }

  /**
   * @returns the \`value\` property value as a fhirString if defined; else undefined
   */
  public getValue(): fhirString | undefined {
    return this.value?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`value\` property.
   *
   * @param value - the \`value\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setValue(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Identifier.value (\${String(value)})\`;
      this.value = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`value\` property exists and has a value; \`false\` otherwise
   */
  public hasValue(): boolean {
    return this.hasValueElement();
  }

  /**
   * @returns the \`period\` property value as a Period object if defined; else an empty Period object
   */
  public getPeriod(): Period {
    return this.period ?? new Period();
  }

  /**
   * Assigns the provided Period object value to the \`period\` property.
   *
   * @param value - the \`period\` object value
   * @returns this
   */
  public setPeriod(value: Period | undefined): this {
    if (isDefined<Period>(value)) {
      const optErrMsg = \`Invalid Identifier.period; Provided element is not an instance of Period.\`;
      assertFhirType<Period>(value, Period, optErrMsg);
      this.period = value;
    } else {
      this.period = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`period\` property exists and has a value; \`false\` otherwise
   */
  public hasPeriod(): boolean {
    return isDefined<Period>(this.period) && !this.period.isEmpty();
  }

  /**
   * @returns the \`assigner\` property value as a Reference object; else an empty Reference object
   */
  public getAssigner(): Reference {
    return this.assigner ?? new Reference();
  }

  /**
   * Assigns the provided Assigner object value to the \`assigner\` property.
   *
   * @decorator \`@ReferenceTargets('Identifier.assigner', ['Organization',])\`
   *
   * @param value - the \`assigner\` object value
   * @returns this
   */
  @ReferenceTargets('Identifier.assigner', [
    'Organization',
  ])
  public setAssigner(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.assigner = value;
    } else {
      this.assigner = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`assigner\` property exists and has a value; \`false\` otherwise
   */
  public hasAssigner(): boolean {
    return isDefined<Reference>(this.assigner) && !this.assigner.isEmpty();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Identifier';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.use,
      this.type_,
      this.system,
      this.value,
      this.period,
      this.assigner,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Identifier {
    const dest = new Identifier();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Identifier): void {
    super.copyValues(dest);
    dest.use = this.use?.copy();
    dest.type_ = this.type_?.copy();
    dest.system = this.system?.copy();
    dest.value = this.value?.copy();
    dest.period = this.period?.copy();
    dest.assigner = this.assigner?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasUseElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getUseElement()!, 'use', jsonObj);
    }

    if (this.hasType()) {
      setFhirComplexJson(this.getType(), 'type', jsonObj);
    }

    if (this.hasSystemElement()) {
      setFhirPrimitiveJson<fhirUri>(this.getSystemElement(), 'system', jsonObj);
    }

    if (this.hasValueElement()) {
      setFhirPrimitiveJson<fhirString>(this.getValueElement(), 'value', jsonObj);
    }

    if (this.hasPeriod()) {
      setFhirComplexJson(this.getPeriod(), 'period', jsonObj);
    }

    if (this.hasAssigner()) {
      setFhirComplexJson(this.getAssigner(), 'assigner', jsonObj);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "Identifier",
}
`;

exports[`src/generator-app unit test suite generator-app verify generated content should consistently create GeneratedContent[] 15`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/test-out",
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/utest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * Meta Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/Meta
 * StructureDefinition.name: Meta
 * StructureDefinition.description: Base StructureDefinition for Meta Type: The metadata about a resource. This is content in the resource that is maintained by the infrastructure. Changes to the content might not always be associated with version changes to the resource.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  CanonicalType,
  DataType,
  FhirDataTypeParser,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  IdType,
  InstantType,
  JSON,
  PrimitiveTypeJson,
  UriType,
  assertFhirType,
  assertFhirTypeList,
  copyListValues,
  fhirCanonical,
  fhirCanonicalSchema,
  fhirId,
  fhirIdSchema,
  fhirInstant,
  fhirInstantSchema,
  fhirUri,
  fhirUriSchema,
  getPrimitiveTypeJson,
  getPrimitiveTypeListJson,
  isDefined,
  isDefinedList,
  isElementEmpty,
  isEmpty,
  parseCanonicalType,
  parseFhirPrimitiveData,
  parseIdType,
  parseInstantType,
  parseUriType,
  setFhirComplexListJson,
  setFhirPrimitiveJson,
  setFhirPrimitiveListJson,
} from '@paq-ts-fhir/fhir-core';
import {
  Coding,
  PARSABLE_DATATYPE_MAP,
} from '../index';

/**
 * Meta Class
 *
 * @remarks
 * Base StructureDefinition for Meta Type: The metadata about a resource. This is content in the resource that is maintained by the infrastructure. Changes to the content might not always be associated with version changes to the resource.
 *
 * **FHIR Specification**
 * - **Short:** Metadata about a resource
 * - **Definition:** The metadata about a resource. This is content in the resource that is maintained by the infrastructure. Changes to the content might not always be associated with version changes to the resource.
 * - **FHIR Version:** 4.0.1
 *
 * @category DataModel: ComplexType
 * @see [FHIR Meta](http://hl7.org/fhir/StructureDefinition/Meta)
 */
export class Meta extends DataType implements IBase {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`Meta\` JSON to instantiate the Meta data model.
   *
   * @param sourceJson - JSON representing FHIR \`Meta\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Meta
   * @returns Meta data model or undefined for \`Meta\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Meta | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Meta';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Meta();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'versionId';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: IdType | undefined = parseIdType(dtJson, dtSiblingJson);
      instance.setVersionIdElement(datatype);
    }

    fieldName = 'lastUpdated';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: InstantType | undefined = parseInstantType(dtJson, dtSiblingJson);
      instance.setLastUpdatedElement(datatype);
    }

    fieldName = 'source';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = parseUriType(dtJson, dtSiblingJson);
      instance.setSourceElement(datatype);
    }

    fieldName = 'profile';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: CanonicalType | undefined = parseCanonicalType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addProfileElement(datatype);
        }
      });
    }

    fieldName = 'security';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Coding | undefined = fhirDataTypeParser.parser<Coding>(Coding, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addSecurity(datatype);
        }
      });
    }

    fieldName = 'tag';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Coding | undefined = fhirDataTypeParser.parser<Coding>(Coding, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addTag(datatype);
        }
      });
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Meta.versionId Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Version specific identifier
   * - **Definition:** The version specific identifier, as it appears in the version portion of the URL. This value changes when the resource is created, updated, or deleted.
   * - **Comment:** The server assigns this value, and ignores what the client specifies, except in the case that the server is imposing version integrity on updates/deletes.
   * - **FHIR Type:** \`id\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private versionId?: IdType | undefined;

  /**
   * Meta.lastUpdated Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** When the resource version last changed
   * - **Definition:** When the resource last changed - e.g. when the version changed.
   * - **Comment:** This value is always populated except when the resource is first being created. The server / resource manager sets this value; what a client provides is irrelevant. This is equivalent to the HTTP Last-Modified and SHOULD have the same value on a [read](https://hl7.org/fhir/http.html#read) interaction.
   * - **FHIR Type:** \`instant\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private lastUpdated?: InstantType | undefined;

  /**
   * Meta.source Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Identifies where the resource comes from
   * - **Definition:** A uri that identifies the source system of the resource. This provides a minimal amount of [Provenance](https://hl7.org/fhir/provenance.html#) information that can be used to track or differentiate the source of information in the resource. The source may identify another FHIR server, document, message, database, etc.
   * - **Comment:** In the provenance resource, this corresponds to Provenance.entity.what[x]. The exact use of the source (and the implied Provenance.entity.role) is left to implementer discretion. Only one nominated source is allowed; for additional provenance details, a full Provenance resource should be used.  This element can be used to indicate where the current master source of a resource that has a canonical URL if the resource is no longer hosted at the canonical URL.
   * - **FHIR Type:** \`uri\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private source?: UriType | undefined;

  /**
   * Meta.profile Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Profiles this resource claims to conform to
   * - **Definition:** A list of profiles (references to [StructureDefinition](https://hl7.org/fhir/structuredefinition.html#) resources) that this resource claims to conform to. The URL is a reference to [StructureDefinition.url](https://hl7.org/fhir/structuredefinition-definitions.html#StructureDefinition.url).
   * - **Comment:** It is up to the server and/or other infrastructure of policy to determine whether/how these claims are verified and/or updated over time.  The list of profile URLs is a set.
   * - **FHIR Type:** \`canonical\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/StructureDefinition',
   *     ]
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private profile?: CanonicalType[] | undefined;

  /**
   * Meta.security Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Security Labels applied to this resource
   * - **Definition:** Security labels applied to this resource. These tags connect specific resources to the overall security policy and infrastructure.
   * - **Comment:** The security labels can be updated without changing the stated version of the resource. The list of security labels is a set. Uniqueness is based the system/code, and version and display are ignored.
   * - **FHIR Type:** \`Coding\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private security?: Coding[] | undefined;

  /**
   * Meta.tag Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Tags applied to this resource
   * - **Definition:** Tags applied to this resource. Tags are intended to be used to identify and relate resources to process and workflow, and applications are not required to consider the tags when interpreting the meaning of a resource.
   * - **Comment:** The tags can be updated without changing the stated version of the resource. The list of tags is a set. Uniqueness is based the system/code, and version and display are ignored.
   * - **FHIR Type:** \`Coding\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private tag?: Coding[] | undefined;


  /**
   * @returns the \`versionId\` property value as a IdType object if defined; else an empty IdType object
   */
  public getVersionIdElement(): IdType {
    return this.versionId ?? new IdType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`versionId\` property.
   *
   * @param element - the \`versionId\` value
   * @returns this
   */
  public setVersionIdElement(element: IdType | undefined): this {
    if (isDefined<IdType>(element)) {
      const optErrMsg = \`Invalid Meta.versionId; Provided element is not an instance of IdType.\`;
      assertFhirType<IdType>(element, IdType, optErrMsg);
      this.versionId = element;
    } else {
      this.versionId = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`versionId\` property exists and has a value; \`false\` otherwise
   */
  public hasVersionIdElement(): boolean {
    return isDefined<IdType>(this.versionId) && !this.versionId.isEmpty();
  }

  /**
   * @returns the \`versionId\` property value as a fhirId if defined; else undefined
   */
  public getVersionId(): fhirId | undefined {
    return this.versionId?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`versionId\` property.
   *
   * @param value - the \`versionId\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setVersionId(value: fhirId | undefined): this {
    if (isDefined<fhirId>(value)) {
      const optErrMsg = \`Invalid Meta.versionId (\${String(value)})\`;
      this.versionId = new IdType(parseFhirPrimitiveData(value, fhirIdSchema, optErrMsg));
    } else {
      this.versionId = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`versionId\` property exists and has a value; \`false\` otherwise
   */
  public hasVersionId(): boolean {
    return this.hasVersionIdElement();
  }

  /**
   * @returns the \`lastUpdated\` property value as a InstantType object if defined; else an empty InstantType object
   */
  public getLastUpdatedElement(): InstantType {
    return this.lastUpdated ?? new InstantType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`lastUpdated\` property.
   *
   * @param element - the \`lastUpdated\` value
   * @returns this
   */
  public setLastUpdatedElement(element: InstantType | undefined): this {
    if (isDefined<InstantType>(element)) {
      const optErrMsg = \`Invalid Meta.lastUpdated; Provided element is not an instance of InstantType.\`;
      assertFhirType<InstantType>(element, InstantType, optErrMsg);
      this.lastUpdated = element;
    } else {
      this.lastUpdated = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`lastUpdated\` property exists and has a value; \`false\` otherwise
   */
  public hasLastUpdatedElement(): boolean {
    return isDefined<InstantType>(this.lastUpdated) && !this.lastUpdated.isEmpty();
  }

  /**
   * @returns the \`lastUpdated\` property value as a fhirInstant if defined; else undefined
   */
  public getLastUpdated(): fhirInstant | undefined {
    return this.lastUpdated?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`lastUpdated\` property.
   *
   * @param value - the \`lastUpdated\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setLastUpdated(value: fhirInstant | undefined): this {
    if (isDefined<fhirInstant>(value)) {
      const optErrMsg = \`Invalid Meta.lastUpdated (\${String(value)})\`;
      this.lastUpdated = new InstantType(parseFhirPrimitiveData(value, fhirInstantSchema, optErrMsg));
    } else {
      this.lastUpdated = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`lastUpdated\` property exists and has a value; \`false\` otherwise
   */
  public hasLastUpdated(): boolean {
    return this.hasLastUpdatedElement();
  }

  /**
   * @returns the \`source\` property value as a UriType object if defined; else an empty UriType object
   */
  public getSourceElement(): UriType {
    return this.source ?? new UriType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`source\` property.
   *
   * @param element - the \`source\` value
   * @returns this
   */
  public setSourceElement(element: UriType | undefined): this {
    if (isDefined<UriType>(element)) {
      const optErrMsg = \`Invalid Meta.source; Provided element is not an instance of UriType.\`;
      assertFhirType<UriType>(element, UriType, optErrMsg);
      this.source = element;
    } else {
      this.source = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`source\` property exists and has a value; \`false\` otherwise
   */
  public hasSourceElement(): boolean {
    return isDefined<UriType>(this.source) && !this.source.isEmpty();
  }

  /**
   * @returns the \`source\` property value as a fhirUri if defined; else undefined
   */
  public getSource(): fhirUri | undefined {
    return this.source?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`source\` property.
   *
   * @param value - the \`source\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setSource(value: fhirUri | undefined): this {
    if (isDefined<fhirUri>(value)) {
      const optErrMsg = \`Invalid Meta.source (\${String(value)})\`;
      this.source = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    } else {
      this.source = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`source\` property exists and has a value; \`false\` otherwise
   */
  public hasSource(): boolean {
    return this.hasSourceElement();
  }

  /**
   * @returns the \`profile\` property value as a CanonicalType array
   */
  public getProfileElement(): CanonicalType[] {
    return this.profile ?? ([] as CanonicalType[]);
  }

  /**
   * Assigns the provided CanonicalType array value to the \`profile\` property.
   *
   * @param element - the \`profile\` array value
   * @returns this
   */
  public setProfileElement(element: CanonicalType[] | undefined): this {
    if (isDefinedList<CanonicalType>(element)) {
      const optErrMsg = \`Invalid Meta.profile; Provided value array has an element that is not an instance of CanonicalType.\`;
      assertFhirTypeList<CanonicalType>(element, CanonicalType, optErrMsg);
      this.profile = element;
    } else {
      this.profile = undefined;
    }
    return this;
  }

  /**
   * Add the provided CanonicalType value to the \`profile\` array property.
   *
   * @param element - the \`profile\` value
   * @returns this
   */
  public addProfileElement(element: CanonicalType | undefined): this {
    if (isDefined<CanonicalType>(element)) {
      const optErrMsg = \`Invalid Meta.profile; Provided element is not an instance of CanonicalType.\`;
      assertFhirType<CanonicalType>(element, CanonicalType, optErrMsg);
      this.initProfile();
      this.profile?.push(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`profile\` property exists and has a value; \`false\` otherwise
   */
  public hasProfileElement(): boolean {
    return isDefinedList<CanonicalType>(this.profile) && this.profile.some((item: CanonicalType) => !item.isEmpty());
  }

  /**
   * @returns the \`profile\` property value as a fhirCanonical array
   */
  public getProfile(): fhirCanonical[] {
    this.initProfile();
    const profileValues = [] as fhirCanonical[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.profile!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        profileValues.push(value);
      }
    }
    return profileValues;
  }

  /**
   * Assigns the provided primitive value array to the \`profile\` property.
   *
   * @param value - the \`profile\` value array
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setProfile(value: fhirCanonical[] | undefined): this {
    if (isDefinedList<fhirCanonical>(value)) {
      const profileElements = [] as CanonicalType[];
      for (const profileValue of value) {
        const optErrMsg = \`Invalid Meta.profile array item (\${String(profileValue)})\`;
        const element = new CanonicalType(parseFhirPrimitiveData(profileValue, fhirCanonicalSchema, optErrMsg));
        profileElements.push(element);
      }
      this.profile = profileElements;
    } else {
      this.profile = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`profile\` array property.
   *
   * @param value - the \`profile\` value
   * @returns this
   */
  public addProfile(value: fhirCanonical | undefined): this {
    if (isDefined<fhirCanonical>(value)) {
      const optErrMsg = \`Invalid Meta.profile array item (\${String(value)})\`;
      const element = new CanonicalType(parseFhirPrimitiveData(value, fhirCanonicalSchema, optErrMsg));
      this.initProfile();
      this.addProfileElement(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`profile\` property exists and has a value; \`false\` otherwise
   */
  public hasProfile(): boolean {
    return this.hasProfileElement();
  }

  /**
   * Initialize the \`profile\` property
   */
  private initProfile(): void {
    if (!this.hasProfile()) {
      this.profile = [] as CanonicalType[];
    }
  }

  /**
   * @returns the \`security\` property value as a Coding array
   */
  public getSecurity(): Coding[] {
    return this.security ?? ([] as Coding[]);
  }

  /**
   * Assigns the provided Coding array value to the \`security\` property.
   *
   * @param value - the \`security\` array value
   * @returns this
   */
  public setSecurity(value: Coding[] | undefined): this {
    if (isDefinedList<Coding>(value)) {
      const optErrMsg = \`Invalid Meta.security; Provided value array has an element that is not an instance of Coding.\`;
      assertFhirTypeList<Coding>(value, Coding, optErrMsg);
      this.security = value;
    } else {
      this.security = undefined;
    }
    return this;
  }

  /**
   * Add the provided Coding value to the \`security\` array property.
   *
   * @param value - the \`security\` value
   * @returns this
   */
  public addSecurity(value: Coding | undefined): this {
    if (isDefined<Coding>(value)) {
      const optErrMsg = \`Invalid Meta.security; Provided element is not an instance of Coding.\`;
      assertFhirType<Coding>(value, Coding, optErrMsg);
      this.initSecurity();
      this.security?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`security\` property exists and has a value; \`false\` otherwise
   */
  public hasSecurity(): boolean {
    return isDefinedList<Coding>(this.security) && this.security.some((item: Coding) => !item.isEmpty());
  }

  /**
   * Initialize the \`security\` property
   */
  private initSecurity(): void {
    if(!this.hasSecurity()) {
      this.security = [] as Coding[];
    }
  }

  /**
   * @returns the \`tag\` property value as a Coding array
   */
  public getTag(): Coding[] {
    return this.tag ?? ([] as Coding[]);
  }

  /**
   * Assigns the provided Coding array value to the \`tag\` property.
   *
   * @param value - the \`tag\` array value
   * @returns this
   */
  public setTag(value: Coding[] | undefined): this {
    if (isDefinedList<Coding>(value)) {
      const optErrMsg = \`Invalid Meta.tag; Provided value array has an element that is not an instance of Coding.\`;
      assertFhirTypeList<Coding>(value, Coding, optErrMsg);
      this.tag = value;
    } else {
      this.tag = undefined;
    }
    return this;
  }

  /**
   * Add the provided Coding value to the \`tag\` array property.
   *
   * @param value - the \`tag\` value
   * @returns this
   */
  public addTag(value: Coding | undefined): this {
    if (isDefined<Coding>(value)) {
      const optErrMsg = \`Invalid Meta.tag; Provided element is not an instance of Coding.\`;
      assertFhirType<Coding>(value, Coding, optErrMsg);
      this.initTag();
      this.tag?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`tag\` property exists and has a value; \`false\` otherwise
   */
  public hasTag(): boolean {
    return isDefinedList<Coding>(this.tag) && this.tag.some((item: Coding) => !item.isEmpty());
  }

  /**
   * Initialize the \`tag\` property
   */
  private initTag(): void {
    if(!this.hasTag()) {
      this.tag = [] as Coding[];
    }
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Meta';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.versionId,
      this.lastUpdated,
      this.source,
      this.profile,
      this.security,
      this.tag,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Meta {
    const dest = new Meta();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Meta): void {
    super.copyValues(dest);
    dest.versionId = this.versionId?.copy();
    dest.lastUpdated = this.lastUpdated?.copy();
    dest.source = this.source?.copy();
    const profileList = copyListValues<CanonicalType>(this.profile);
    dest.profile = profileList.length === 0 ? undefined : profileList;
    const securityList = copyListValues<Coding>(this.security);
    dest.security = securityList.length === 0 ? undefined : securityList;
    const tagList = copyListValues<Coding>(this.tag);
    dest.tag = tagList.length === 0 ? undefined : tagList;
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasVersionIdElement()) {
      setFhirPrimitiveJson<fhirId>(this.getVersionIdElement(), 'versionId', jsonObj);
    }

    if (this.hasLastUpdatedElement()) {
      setFhirPrimitiveJson<fhirInstant>(this.getLastUpdatedElement(), 'lastUpdated', jsonObj);
    }

    if (this.hasSourceElement()) {
      setFhirPrimitiveJson<fhirUri>(this.getSourceElement(), 'source', jsonObj);
    }

    if (this.hasProfile()) {
      setFhirPrimitiveListJson(this.getProfileElement(), 'profile', jsonObj);
    }

    if (this.hasSecurity()) {
      setFhirComplexListJson(this.getSecurity(), 'security', jsonObj);
    }

    if (this.hasTag()) {
      setFhirComplexListJson(this.getTag(), 'tag', jsonObj);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "Meta",
}
`;

exports[`src/generator-app unit test suite generator-app verify generated content should consistently create GeneratedContent[] 16`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/test-out",
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/utest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * Narrative Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/Narrative
 * StructureDefinition.name: Narrative
 * StructureDefinition.description: Base StructureDefinition for Narrative Type: A human-readable summary of the resource conveying the essential clinical and business information for the resource.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  CodeType,
  DataType,
  EnumCodeType,
  FhirDataTypeParser,
  FhirError,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  PrimitiveType,
  REQUIRED_PROPERTIES_DO_NOT_EXIST,
  REQUIRED_PROPERTIES_REQD_IN_JSON,
  XhtmlType,
  assertEnumCodeType,
  assertFhirType,
  assertIsDefined,
  constructorCodeValueAsEnumCodeType,
  fhirCode,
  fhirCodeSchema,
  fhirXhtml,
  fhirXhtmlSchema,
  getPrimitiveTypeJson,
  isDefined,
  isElementEmpty,
  isEmpty,
  parseCodeType,
  parseFhirPrimitiveData,
  parseXhtmlType,
  setFhirPrimitiveJson,
} from '@paq-ts-fhir/fhir-core';
import {
  NarrativeStatusEnum,
  PARSABLE_DATATYPE_MAP,
} from '../index';

/**
 * Narrative Class
 *
 * @remarks
 * Base StructureDefinition for Narrative Type: A human-readable summary of the resource conveying the essential clinical and business information for the resource.
 *
 * **FHIR Specification**
 * - **Short:** Human-readable summary of the resource (essential clinical and business information)
 * - **Definition:** A human-readable summary of the resource conveying the essential clinical and business information for the resource.
 * - **FHIR Version:** 4.0.1
 *
 * @category DataModel: ComplexType
 * @see [FHIR Narrative](http://hl7.org/fhir/StructureDefinition/Narrative)
 */
export class Narrative extends DataType implements IBase {
  constructor(status: EnumCodeType | CodeType | null = null, div: XhtmlType | fhirXhtml | null = null) {
    super();

    this.narrativeStatusEnum = new NarrativeStatusEnum();

    this.status = constructorCodeValueAsEnumCodeType<NarrativeStatusEnum>(
      status,
      NarrativeStatusEnum,
      this.narrativeStatusEnum,
      '.status',
    );

    this.div = null;
    if (isDefined<XhtmlType | fhirXhtml>(div)) {
      if (div instanceof PrimitiveType) {
        this.setDivElement(div);
      } else {
        this.setDiv(div);
      }
    }
  }

  /**
   * Parse the provided \`Narrative\` JSON to instantiate the Narrative data model.
   *
   * @param sourceJson - JSON representing FHIR \`Narrative\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Narrative
   * @returns Narrative data model or undefined for \`Narrative\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Narrative | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Narrative';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Narrative();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'status';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setStatusElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'div';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: XhtmlType | undefined = parseXhtmlType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setDivElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: NarrativeStatus
   *
   * @see {@link NarrativeStatusEnum }
   */
  private readonly narrativeStatusEnum: NarrativeStatusEnum;

  /**
   * Narrative.status Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** generated | extensions | additional | empty
   * - **Definition:** The status of the narrative - whether it\\'s entirely generated (from just the defined data or the extensions too), or whether a human authored it and it may contain additional data.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private status: EnumCodeType | null;

  /**
   * Narrative.div Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Limited xhtml content
   * - **Definition:** The actual narrative content, a stripped down version of XHTML.
   * - **Comment:** The contents of the html element are an XHTML fragment containing only the basic html formatting elements described in chapters 7-11 and 15 of the HTML 4.0 standard, <a> elements (either name or href), images and internally contained stylesheets. The XHTML content SHALL NOT contain a head, a body, external stylesheet references, scripts, forms, base/link/xlink, frames, iframes and objects.
   * - **FHIR Type:** \`xhtml\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private div: XhtmlType | null;


  /**
   * @returns the \`status\` property value as a EnumCodeType if defined; else null
   */
  public getStatusEnumType(): EnumCodeType | null {
    return this.status;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`status\` property.
   *
   * @param enumType - the \`status\` value
   * @returns this
   */
  public setStatusEnumType(enumType: EnumCodeType): this {
    assertIsDefined<EnumCodeType>(enumType, \`Narrative.status is required\`);
    const errMsgPrefix = \`Invalid Narrative.status\`;
    assertEnumCodeType<NarrativeStatusEnum>(enumType, NarrativeStatusEnum, errMsgPrefix);
    this.status = enumType;
    return this;
  }

  /**
   * @returns \`true\` if the \`status\` property exists and has a value; \`false\` otherwise
   */
  public hasStatusEnumType(): boolean {
    return isDefined<EnumCodeType>(this.status) && !this.status.isEmpty() && this.status.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`status\` property value as a CodeType if defined; else null
   */
  public getStatusElement(): CodeType | null {
    if (this.status === null) {
      return null;
    }
    return this.status as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`status\` property.
   *
   * @param element - the \`status\` value
   * @returns this
   */
  public setStatusElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, \`Narrative.status is required\`);
    const optErrMsg = \`Invalid Narrative.status; Provided value is not an instance of CodeType.\`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.status = new EnumCodeType(element, this.narrativeStatusEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`status\` property exists and has a value; \`false\` otherwise
   */
  public hasStatusElement(): boolean {
    return this.hasStatusEnumType();
  }

  /**
   * @returns the \`status\` property value as a fhirCode if defined; else null
   */
  public getStatus(): fhirCode | null {
    if (this.status === null) {
      return null;
    }
    return this.status.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`status\` property.
   *
   * @param value - the \`status\` value
   * @returns this
   */
  public setStatus(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, \`Narrative.status is required\`);
    const optErrMsg = \`Invalid Narrative.status (\${String(value)})\`;
    this.status = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.narrativeStatusEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`status\` property exists and has a value; \`false\` otherwise
   */
  public hasStatus(): boolean {
    return this.hasStatusEnumType();
  }

  /**
   * @returns the \`div\` property value as a XhtmlType object if defined; else null
   */
  public getDivElement(): XhtmlType | null {
    return this.div;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`div\` property.
   *
   * @param element - the \`div\` value
   * @returns this
   */
  public setDivElement(element: XhtmlType): this {
    assertIsDefined<XhtmlType>(element, \`Narrative.div is required\`);
    const optErrMsg = \`Invalid Narrative.div; Provided value is not an instance of XhtmlType.\`;
    assertFhirType<XhtmlType>(element, XhtmlType, optErrMsg);
    this.div = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`div\` property exists and has a value; \`false\` otherwise
   */
  public hasDivElement(): boolean {
    return isDefined<XhtmlType>(this.div) && !this.div.isEmpty();
  }

  /**
   * @returns the \`div\` property value as a fhirXhtml if defined; else null
   */
  public getDiv(): fhirXhtml | null {
    if (this.div?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.div.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`div\` property.
   *
   * @param value - the \`div\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setDiv(value: fhirXhtml): this {
    assertIsDefined<fhirXhtml>(value, \`Narrative.div is required\`);
    const optErrMsg = \`Invalid Narrative.div (\${String(value)})\`;
    this.div = new XhtmlType(parseFhirPrimitiveData(value, fhirXhtmlSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`div\` property exists and has a value; \`false\` otherwise
   */
  public hasDiv(): boolean {
    return this.hasDivElement();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Narrative';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.status,
      this.div,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Narrative {
    const dest = new Narrative();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Narrative): void {
    super.copyValues(dest);
    dest.status = this.status ? this.status.copy() : null;
    dest.div = this.div ? this.div.copy() : null;
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasStatusElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getStatusElement()!, 'status', jsonObj);
    } else {
      missingReqdProperties.push(\`Narrative.status\`);
    }

    if (this.hasDivElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirXhtml>(this.getDivElement()!, 'div', jsonObj);
    } else {
      missingReqdProperties.push(\`Narrative.div\`);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "Narrative",
}
`;

exports[`src/generator-app unit test suite generator-app verify generated content should consistently create GeneratedContent[] 17`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/test-out",
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/utest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * Period Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/Period
 * StructureDefinition.name: Period
 * StructureDefinition.description: Base StructureDefinition for Period Type: A time period defined by a start and end date and optionally time.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  DataType,
  DateTimeType,
  FhirDataTypeParser,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  assertFhirType,
  fhirDateTime,
  fhirDateTimeSchema,
  getPrimitiveTypeJson,
  isDefined,
  isElementEmpty,
  isEmpty,
  parseDateTimeType,
  parseFhirPrimitiveData,
  setFhirPrimitiveJson,
} from '@paq-ts-fhir/fhir-core';
import {
  PARSABLE_DATATYPE_MAP,
} from '../index';

/**
 * Period Class
 *
 * @remarks
 * Base StructureDefinition for Period Type: A time period defined by a start and end date and optionally time.
 *
 * **FHIR Specification**
 * - **Short:** Time range defined by start and end date/time
 * - **Definition:** A time period defined by a start and end date and optionally time.
 * - **Comment:** A Period specifies a range of time; the context of use will specify whether the entire range applies (e.g. "the patient was an inpatient of the hospital for this time range") or one value from the range applies (e.g. "give to the patient between these two times"). Period is not used for a duration (a measure of elapsed time). See [Duration](https://hl7.org/fhir/datatypes.html#Duration).
 * - **FHIR Version:** 4.0.1
 *
 * @category DataModel: ComplexType
 * @see [FHIR Period](http://hl7.org/fhir/StructureDefinition/Period)
 */
export class Period extends DataType implements IBase {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`Period\` JSON to instantiate the Period data model.
   *
   * @param sourceJson - JSON representing FHIR \`Period\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Period
   * @returns Period data model or undefined for \`Period\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Period | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Period';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Period();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'start';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DateTimeType | undefined = parseDateTimeType(dtJson, dtSiblingJson);
      instance.setStartElement(datatype);
    }

    fieldName = 'end';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DateTimeType | undefined = parseDateTimeType(dtJson, dtSiblingJson);
      instance.setEndElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Period.start Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Starting time with inclusive boundary
   * - **Definition:** The start of the period. The boundary is inclusive.
   * - **Comment:** If the low element is missing, the meaning is that the low boundary is not known.
   * - **FHIR Type:** \`dateTime\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private start?: DateTimeType | undefined;

  /**
   * Period.end Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** End time with inclusive boundary, if not ongoing
   * - **Definition:** The end of the period. If the end of the period is missing, it means no end was known or planned at the time the instance was created. The start may be in the past, and the end date in the future, which means that period is expected/planned to end at that time.
   * - **Comment:** The high value includes any matching date/time. i.e. 2012-02-03T10:00:00 is in a period that has an end value of 2012-02-03.
   * - **FHIR Type:** \`dateTime\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private end?: DateTimeType | undefined;


  /**
   * @returns the \`start\` property value as a DateTimeType object if defined; else an empty DateTimeType object
   */
  public getStartElement(): DateTimeType {
    return this.start ?? new DateTimeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`start\` property.
   *
   * @param element - the \`start\` value
   * @returns this
   */
  public setStartElement(element: DateTimeType | undefined): this {
    if (isDefined<DateTimeType>(element)) {
      const optErrMsg = \`Invalid Period.start; Provided element is not an instance of DateTimeType.\`;
      assertFhirType<DateTimeType>(element, DateTimeType, optErrMsg);
      this.start = element;
    } else {
      this.start = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`start\` property exists and has a value; \`false\` otherwise
   */
  public hasStartElement(): boolean {
    return isDefined<DateTimeType>(this.start) && !this.start.isEmpty();
  }

  /**
   * @returns the \`start\` property value as a fhirDateTime if defined; else undefined
   */
  public getStart(): fhirDateTime | undefined {
    return this.start?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`start\` property.
   *
   * @param value - the \`start\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setStart(value: fhirDateTime | undefined): this {
    if (isDefined<fhirDateTime>(value)) {
      const optErrMsg = \`Invalid Period.start (\${String(value)})\`;
      this.start = new DateTimeType(parseFhirPrimitiveData(value, fhirDateTimeSchema, optErrMsg));
    } else {
      this.start = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`start\` property exists and has a value; \`false\` otherwise
   */
  public hasStart(): boolean {
    return this.hasStartElement();
  }

  /**
   * @returns the \`end\` property value as a DateTimeType object if defined; else an empty DateTimeType object
   */
  public getEndElement(): DateTimeType {
    return this.end ?? new DateTimeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`end\` property.
   *
   * @param element - the \`end\` value
   * @returns this
   */
  public setEndElement(element: DateTimeType | undefined): this {
    if (isDefined<DateTimeType>(element)) {
      const optErrMsg = \`Invalid Period.end; Provided element is not an instance of DateTimeType.\`;
      assertFhirType<DateTimeType>(element, DateTimeType, optErrMsg);
      this.end = element;
    } else {
      this.end = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`end\` property exists and has a value; \`false\` otherwise
   */
  public hasEndElement(): boolean {
    return isDefined<DateTimeType>(this.end) && !this.end.isEmpty();
  }

  /**
   * @returns the \`end\` property value as a fhirDateTime if defined; else undefined
   */
  public getEnd(): fhirDateTime | undefined {
    return this.end?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`end\` property.
   *
   * @param value - the \`end\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setEnd(value: fhirDateTime | undefined): this {
    if (isDefined<fhirDateTime>(value)) {
      const optErrMsg = \`Invalid Period.end (\${String(value)})\`;
      this.end = new DateTimeType(parseFhirPrimitiveData(value, fhirDateTimeSchema, optErrMsg));
    } else {
      this.end = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`end\` property exists and has a value; \`false\` otherwise
   */
  public hasEnd(): boolean {
    return this.hasEndElement();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Period';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.start,
      this.end,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Period {
    const dest = new Period();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Period): void {
    super.copyValues(dest);
    dest.start = this.start?.copy();
    dest.end = this.end?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasStartElement()) {
      setFhirPrimitiveJson<fhirDateTime>(this.getStartElement(), 'start', jsonObj);
    }

    if (this.hasEndElement()) {
      setFhirPrimitiveJson<fhirDateTime>(this.getEndElement(), 'end', jsonObj);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "Period",
}
`;

exports[`src/generator-app unit test suite generator-app verify generated content should consistently create GeneratedContent[] 18`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/test-out",
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/utest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * Reference Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/Reference
 * StructureDefinition.name: Reference
 * StructureDefinition.description: Base StructureDefinition for Reference Type: A reference from one resource to another.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  DataType,
  FhirDataTypeParser,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  StringType,
  UriType,
  assertFhirType,
  fhirString,
  fhirStringSchema,
  fhirUri,
  fhirUriSchema,
  getPrimitiveTypeJson,
  isDefined,
  isElementEmpty,
  isEmpty,
  parseFhirPrimitiveData,
  parseStringType,
  parseUriType,
  setFhirComplexJson,
  setFhirPrimitiveJson,
} from '@paq-ts-fhir/fhir-core';
import {
  Identifier,
  PARSABLE_DATATYPE_MAP,
} from '../index';

/**
 * Reference Class
 *
 * @remarks
 * Base StructureDefinition for Reference Type: A reference from one resource to another.
 *
 * **FHIR Specification**
 * - **Short:** A reference from one resource to another
 * - **Definition:** A reference from one resource to another.
 * - **Comment:** References SHALL be a reference to an actual FHIR resource, and SHALL be resolveable (allowing for access control, temporary unavailability, etc.). Resolution can be either by retrieval from the URL, or, where applicable by resource type, by treating an absolute reference as a canonical URL and looking it up in a local registry/repository.
 * - **FHIR Version:** 4.0.1
 *
 * @category DataModel: ComplexType
 * @see [FHIR Reference](http://hl7.org/fhir/StructureDefinition/Reference)
 */
export class Reference extends DataType implements IBase {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`Reference\` JSON to instantiate the Reference data model.
   *
   * @param sourceJson - JSON representing FHIR \`Reference\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Reference
   * @returns Reference data model or undefined for \`Reference\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Reference | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Reference';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Reference();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'reference';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setReferenceElement(datatype);
    }

    fieldName = 'type';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = parseUriType(dtJson, dtSiblingJson);
      instance.setTypeElement(datatype);
    }

    fieldName = 'identifier';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Identifier | undefined = fhirDataTypeParser.parser<Identifier>(Identifier, classJsonObj[fieldName]!, sourceField);
      instance.setIdentifier(datatype);
    }

    fieldName = 'display';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setDisplayElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Reference.reference Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Literal reference, Relative, internal or absolute URL
   * - **Definition:** A reference to a location at which the other resource is found. The reference may be a relative reference, in which case it is relative to the service base URL, or an absolute URL that resolves to the location where the resource is found. The reference may be version specific or not. If the reference is not to a FHIR RESTful server, then it should be assumed to be version specific. Internal fragment references (start with \\'#\\') refer to contained resources.
   * - **Comment:** Using absolute URLs provides a stable scalable approach suitable for a cloud/web context, while using relative/logical references provides a flexible approach suitable for use when trading across closed eco-system boundaries.   Absolute URLs do not need to point to a FHIR RESTful server, though this is the preferred approach. If the URL conforms to the structure "/[type]/[id]" then it should be assumed that the reference is to a FHIR RESTful server.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private reference?: StringType | undefined;

  /**
   * Reference.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Type the reference refers to (e.g. "Patient")
   * - **Definition:** The expected type of the target of the reference. If both Reference.type and Reference.reference are populated and Reference.reference is a FHIR URL, both SHALL be consistent. The type is the Canonical URL of Resource Definition that is the type this reference refers to. References are URLs that are relative to http://hl7.org/fhir/StructureDefinition/ e.g. "Patient" is a reference to http://hl7.org/fhir/StructureDefinition/Patient. Absolute URLs are only allowed for logical models (and can only be used in references in logical models, not resources).
   * - **Comment:** This element is used to indicate the type of  the target of the reference. This may be used which ever of the other elements are populated (or not). In some cases, the type of the target may be determined by inspection of the reference (e.g. a RESTful URL) or by resolving the target of the reference; if both the type and a reference is provided, the reference SHALL resolve to a resource of the same type as that specified.
   * - **FHIR Type:** \`uri\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private type_?: UriType | undefined;

  /**
   * Reference.identifier Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Logical reference, when literal reference is not known
   * - **Definition:** An identifier for the target resource. This is used when there is no way to reference the other resource directly, either because the entity it represents is not available through a FHIR server, or because there is no way for the author of the resource to convert a known identifier to an actual location. There is no requirement that a Reference.identifier point to something that is actually exposed as a FHIR instance, but it SHALL point to a business concept that would be expected to be exposed as a FHIR instance, and that instance would need to be of a FHIR resource type allowed by the reference.
   * - **Comment:** When an identifier is provided in place of a reference, any system processing the reference will only be able to resolve the identifier to a reference if it understands the business context in which the identifier is used. Sometimes this is global (e.g. a national identifier) but often it is not. For this reason, none of the useful mechanisms described for working with references (e.g. chaining, includes) are possible, nor should servers be expected to be able resolve the reference. Servers may accept an identifier based reference untouched, resolve it, and/or reject it - see CapabilityStatement.rest.resource.referencePolicy.  When both an identifier and a literal reference are provided, the literal reference is preferred. Applications processing the resource are allowed - but not required - to check that the identifier matches the literal reference Applications converting a logical reference to a literal reference may choose to leave the logical reference present, or remove it. Reference is intended to point to a structure that can potentially be expressed as a FHIR resource, though there is no need for it to exist as an actual FHIR resource instance - except in as much as an application wishes to actual find the target of the reference. The content referred to be the identifier must meet the logical constraints implied by any limitations on what resource types are permitted for the reference.  For example, it would not be legitimate to send the identifier for a drug prescription if the type were Reference(Observation|DiagnosticReport).  One of the use-cases for Reference.identifier is the situation where no FHIR representation exists (where the type is Reference (Any).
   * - **FHIR Type:** \`Identifier\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private identifier?: Identifier | undefined;

  /**
   * Reference.display Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Text alternative for the resource
   * - **Definition:** Plain text narrative that identifies the resource in addition to the resource reference.
   * - **Comment:** This is generally not the same as the Resource.text of the referenced resource.  The purpose is to identify what\\'s being referenced, not to fully describe it.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private display?: StringType | undefined;


  /**
   * @returns the \`reference\` property value as a StringType object if defined; else an empty StringType object
   */
  public getReferenceElement(): StringType {
    return this.reference ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`reference\` property.
   *
   * @param element - the \`reference\` value
   * @returns this
   */
  public setReferenceElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Reference.reference; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.reference = element;
    } else {
      this.reference = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`reference\` property exists and has a value; \`false\` otherwise
   */
  public hasReferenceElement(): boolean {
    return isDefined<StringType>(this.reference) && !this.reference.isEmpty();
  }

  /**
   * @returns the \`reference\` property value as a fhirString if defined; else undefined
   */
  public getReference(): fhirString | undefined {
    return this.reference?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`reference\` property.
   *
   * @param value - the \`reference\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setReference(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Reference.reference (\${String(value)})\`;
      this.reference = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.reference = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`reference\` property exists and has a value; \`false\` otherwise
   */
  public hasReference(): boolean {
    return this.hasReferenceElement();
  }

  /**
   * @returns the \`type_\` property value as a UriType object if defined; else an empty UriType object
   */
  public getTypeElement(): UriType {
    return this.type_ ?? new UriType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`type_\` property.
   *
   * @param element - the \`type_\` value
   * @returns this
   */
  public setTypeElement(element: UriType | undefined): this {
    if (isDefined<UriType>(element)) {
      const optErrMsg = \`Invalid Reference.type; Provided element is not an instance of UriType.\`;
      assertFhirType<UriType>(element, UriType, optErrMsg);
      this.type_ = element;
    } else {
      this.type_ = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasTypeElement(): boolean {
    return isDefined<UriType>(this.type_) && !this.type_.isEmpty();
  }

  /**
   * @returns the \`type_\` property value as a fhirUri if defined; else undefined
   */
  public getType(): fhirUri | undefined {
    return this.type_?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`type_\` property.
   *
   * @param value - the \`type_\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setType(value: fhirUri | undefined): this {
    if (isDefined<fhirUri>(value)) {
      const optErrMsg = \`Invalid Reference.type (\${String(value)})\`;
      this.type_ = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    } else {
      this.type_ = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasType(): boolean {
    return this.hasTypeElement();
  }

  /**
   * @returns the \`identifier\` property value as a Identifier object if defined; else an empty Identifier object
   */
  public getIdentifier(): Identifier {
    return this.identifier ?? new Identifier();
  }

  /**
   * Assigns the provided Identifier object value to the \`identifier\` property.
   *
   * @param value - the \`identifier\` object value
   * @returns this
   */
  public setIdentifier(value: Identifier | undefined): this {
    if (isDefined<Identifier>(value)) {
      const optErrMsg = \`Invalid Reference.identifier; Provided element is not an instance of Identifier.\`;
      assertFhirType<Identifier>(value, Identifier, optErrMsg);
      this.identifier = value;
    } else {
      this.identifier = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`identifier\` property exists and has a value; \`false\` otherwise
   */
  public hasIdentifier(): boolean {
    return isDefined<Identifier>(this.identifier) && !this.identifier.isEmpty();
  }

  /**
   * @returns the \`display\` property value as a StringType object if defined; else an empty StringType object
   */
  public getDisplayElement(): StringType {
    return this.display ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`display\` property.
   *
   * @param element - the \`display\` value
   * @returns this
   */
  public setDisplayElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Reference.display; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.display = element;
    } else {
      this.display = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`display\` property exists and has a value; \`false\` otherwise
   */
  public hasDisplayElement(): boolean {
    return isDefined<StringType>(this.display) && !this.display.isEmpty();
  }

  /**
   * @returns the \`display\` property value as a fhirString if defined; else undefined
   */
  public getDisplay(): fhirString | undefined {
    return this.display?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`display\` property.
   *
   * @param value - the \`display\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setDisplay(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Reference.display (\${String(value)})\`;
      this.display = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.display = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`display\` property exists and has a value; \`false\` otherwise
   */
  public hasDisplay(): boolean {
    return this.hasDisplayElement();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Reference';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.reference,
      this.type_,
      this.identifier,
      this.display,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Reference {
    const dest = new Reference();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Reference): void {
    super.copyValues(dest);
    dest.reference = this.reference?.copy();
    dest.type_ = this.type_?.copy();
    dest.identifier = this.identifier?.copy();
    dest.display = this.display?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasReferenceElement()) {
      setFhirPrimitiveJson<fhirString>(this.getReferenceElement(), 'reference', jsonObj);
    }

    if (this.hasTypeElement()) {
      setFhirPrimitiveJson<fhirUri>(this.getTypeElement(), 'type', jsonObj);
    }

    if (this.hasIdentifier()) {
      setFhirComplexJson(this.getIdentifier(), 'identifier', jsonObj);
    }

    if (this.hasDisplayElement()) {
      setFhirPrimitiveJson<fhirString>(this.getDisplayElement(), 'display', jsonObj);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "Reference",
}
`;

exports[`src/generator-app unit test suite generator-app verify generated content should consistently create GeneratedContent[] 19`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/test-out",
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/utest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * Signature Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/Signature
 * StructureDefinition.name: Signature
 * StructureDefinition.description: Base StructureDefinition for Signature Type: A signature along with supporting context. The signature may be a digital signature that is cryptographic in nature, or some other signature acceptable to the domain. This other signature may be as simple as a graphical image representing a hand-written signature, or a signature ceremony Different signature approaches have different utilities.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  Base64BinaryType,
  CodeType,
  DataType,
  FhirDataTypeParser,
  FhirError,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  InstantType,
  JSON,
  PrimitiveType,
  REQUIRED_PROPERTIES_DO_NOT_EXIST,
  REQUIRED_PROPERTIES_REQD_IN_JSON,
  assertFhirType,
  assertFhirTypeList,
  assertIsDefined,
  assertIsDefinedList,
  copyListValues,
  fhirBase64Binary,
  fhirBase64BinarySchema,
  fhirCode,
  fhirCodeSchema,
  fhirInstant,
  fhirInstantSchema,
  getPrimitiveTypeJson,
  isDefined,
  isDefinedList,
  isElementEmpty,
  isEmpty,
  parseBase64BinaryType,
  parseCodeType,
  parseFhirPrimitiveData,
  parseInstantType,
  setFhirComplexJson,
  setFhirComplexListJson,
  setFhirPrimitiveJson,
} from '@paq-ts-fhir/fhir-core';
import {
  Coding,
  PARSABLE_DATATYPE_MAP,
  Reference,
  ReferenceTargets,
} from '../index';

/**
 * Signature Class
 *
 * @remarks
 * Base StructureDefinition for Signature Type: A signature along with supporting context. The signature may be a digital signature that is cryptographic in nature, or some other signature acceptable to the domain. This other signature may be as simple as a graphical image representing a hand-written signature, or a signature ceremony Different signature approaches have different utilities.
 *
 * There are a number of places where content must be signed in healthcare.
 *
 * **FHIR Specification**
 * - **Short:** A Signature - XML DigSig, JWS, Graphical image of signature, etc.
 * - **Definition:** A signature along with supporting context. The signature may be a digital signature that is cryptographic in nature, or some other signature acceptable to the domain. This other signature may be as simple as a graphical image representing a hand-written signature, or a signature ceremony Different signature approaches have different utilities.
 * - **Comment:** The elements of the Signature Resource are for ease of access of these elements. For digital signatures (Xml DigSig, JWS), the non-repudiation proof comes from the Signature  validation, which includes validation of the referenced objects (e.g. Resources) (a.k.a., Content) in the XML-Signature Detached form.
 * - **FHIR Version:** 4.0.1
 *
 * @category DataModel: ComplexType
 * @see [FHIR Signature](http://hl7.org/fhir/StructureDefinition/Signature)
 */
export class Signature extends DataType implements IBase {
  constructor(type_: Coding[] | null = null, when: InstantType | fhirInstant | null = null, who: Reference | null = null) {
    super();

    this.type_ = null;
    if (isDefinedList<Coding>(type_)) {
      this.setType(type_);
    }

    this.when = null;
    if (isDefined<InstantType | fhirInstant>(when)) {
      if (when instanceof PrimitiveType) {
        this.setWhenElement(when);
      } else {
        this.setWhen(when);
      }
    }

    this.who = null;
    if (isDefined<Reference>(who)) {
      this.setWho(who);
    }
  }

  /**
   * Parse the provided \`Signature\` JSON to instantiate the Signature data model.
   *
   * @param sourceJson - JSON representing FHIR \`Signature\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Signature
   * @returns Signature data model or undefined for \`Signature\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Signature | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Signature';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Signature();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'type';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Coding | undefined = fhirDataTypeParser.parser<Coding>(Coding, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype === undefined) {
          missingReqdProperties.push(\`\${sourceField}[\${String(idx)}]\`);
        } else {
          instance.addType(datatype);
        }
      });
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'when';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: InstantType | undefined = parseInstantType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setWhenElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'who';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = fhirDataTypeParser.parser<Reference>(Reference, classJsonObj[fieldName]!, sourceField);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setWho(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'onBehalfOf';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = fhirDataTypeParser.parser<Reference>(Reference, classJsonObj[fieldName]!, sourceField);
      instance.setOnBehalfOf(datatype);
    }

    fieldName = 'targetFormat';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      instance.setTargetFormatElement(datatype);
    }

    fieldName = 'sigFormat';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      instance.setSigFormatElement(datatype);
    }

    fieldName = 'data';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: Base64BinaryType | undefined = parseBase64BinaryType(dtJson, dtSiblingJson);
      instance.setDataElement(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Signature.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Indication of the reason the entity signed the object(s)
   * - **Definition:** An indication of the reason that the entity signed this document. This may be explicitly included as part of the signature information and can be used when determining accountability for various actions concerning the document.
   * - **Comment:** Examples include attesting to: authorship, correct transcription, and witness of specific event. Also known as a &quot;Commitment Type Indication&quot;.
   * - **FHIR Type:** \`Coding\`
   * - **Cardinality:** 1..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private type_: Coding[] | null;

  /**
   * Signature.when Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** When the signature was created
   * - **Definition:** When the digital signature was signed.
   * - **Comment:** This should agree with the information in the signature.
   * - **FHIR Type:** \`instant\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private when: InstantType | null;

  /**
   * Signature.who Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Who signed
   * - **Definition:** A reference to an application-usable description of the identity that signed  (e.g. the signature used their private key).
   * - **Comment:** This should agree with the information in the signature.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Practitioner',
   *       'http://hl7.org/fhir/StructureDefinition/PractitionerRole',
   *       'http://hl7.org/fhir/StructureDefinition/RelatedPerson',
   *       'http://hl7.org/fhir/StructureDefinition/Patient',
   *       'http://hl7.org/fhir/StructureDefinition/Device',
   *       'http://hl7.org/fhir/StructureDefinition/Organization',
   *     ]
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private who: Reference | null;

  /**
   * Signature.onBehalfOf Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The party represented
   * - **Definition:** A reference to an application-usable description of the identity that is represented by the signature.
   * - **Comment:** The party that can\\'t sign. For example a child.
   * - **Requirements:** used when the signature is on behalf of a non-signer.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Practitioner',
   *       'http://hl7.org/fhir/StructureDefinition/PractitionerRole',
   *       'http://hl7.org/fhir/StructureDefinition/RelatedPerson',
   *       'http://hl7.org/fhir/StructureDefinition/Patient',
   *       'http://hl7.org/fhir/StructureDefinition/Device',
   *       'http://hl7.org/fhir/StructureDefinition/Organization',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private onBehalfOf?: Reference | undefined;

  /**
   * Signature.targetFormat Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The technical format of the signed resources
   * - **Definition:** A mime type that indicates the technical format of the target resources signed by the signature.
   * - **Comment:** "xml", "json" and "ttl" are allowed, which describe the simple encodings described in the specification (and imply appropriate bundle support). Otherwise, mime types are legal here.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private targetFormat?: CodeType | undefined;

  /**
   * Signature.sigFormat Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The technical format of the signature
   * - **Definition:** A mime type that indicates the technical format of the signature. Important mime types are application/signature+xml for X ML DigSig, application/jose for JWS, and image/* for a graphical image of a signature, etc.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private sigFormat?: CodeType | undefined;

  /**
   * Signature.data Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The actual signature content (XML DigSig. JWS, picture, etc.)
   * - **Definition:** The base64 encoding of the Signature content. When signature is not recorded electronically this element would be empty.
   * - **Comment:** Where the signature type is an XML DigSig, the signed content is a FHIR Resource(s), the signature is of the XML form of the Resource(s) using  XML-Signature (XMLDIG) "Detached Signature" form.
   * - **FHIR Type:** \`base64Binary\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private data?: Base64BinaryType | undefined;


  /**
   * @returns the \`type_\` property value as a Coding array
   */
  public getType(): Coding[] {
    return this.type_ ?? ([] as Coding[]);
  }

  /**
   * Assigns the provided Coding array value to the \`type_\` property.
   *
   * @param value - the \`type_\` array value
   * @returns this
   */
  public setType(value: Coding[]): this {
    assertIsDefinedList<Coding>(value, \`Signature.type is required\`);
    const optErrMsg = \`Invalid Signature.type; Provided value array has an element that is not an instance of Coding.\`;
    assertFhirTypeList<Coding>(value, Coding, optErrMsg);
    this.type_ = value;
    return this;
  }

  /**
   * Add the provided Coding value to the \`type_\` array property.
   *
   * @param value - the \`type_\` value
   * @returns this
   */
  public addType(value: Coding | undefined): this {
    if (isDefined<Coding>(value)) {
      const optErrMsg = \`Invalid Signature.type; Provided element is not an instance of Coding.\`;
      assertFhirType<Coding>(value, Coding, optErrMsg);
      this.initType();
      this.type_?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasType(): boolean {
    return isDefinedList<Coding>(this.type_) && this.type_.some((item: Coding) => !item.isEmpty());
  }

  /**
   * Initialize the \`type_\` property
   */
  private initType(): void {
    if(!this.hasType()) {
      this.type_ = [] as Coding[];
    }
  }

  /**
   * @returns the \`when\` property value as a InstantType object if defined; else null
   */
  public getWhenElement(): InstantType | null {
    return this.when;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`when\` property.
   *
   * @param element - the \`when\` value
   * @returns this
   */
  public setWhenElement(element: InstantType): this {
    assertIsDefined<InstantType>(element, \`Signature.when is required\`);
    const optErrMsg = \`Invalid Signature.when; Provided value is not an instance of InstantType.\`;
    assertFhirType<InstantType>(element, InstantType, optErrMsg);
    this.when = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`when\` property exists and has a value; \`false\` otherwise
   */
  public hasWhenElement(): boolean {
    return isDefined<InstantType>(this.when) && !this.when.isEmpty();
  }

  /**
   * @returns the \`when\` property value as a fhirInstant if defined; else null
   */
  public getWhen(): fhirInstant | null {
    if (this.when?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.when.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`when\` property.
   *
   * @param value - the \`when\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setWhen(value: fhirInstant): this {
    assertIsDefined<fhirInstant>(value, \`Signature.when is required\`);
    const optErrMsg = \`Invalid Signature.when (\${String(value)})\`;
    this.when = new InstantType(parseFhirPrimitiveData(value, fhirInstantSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`when\` property exists and has a value; \`false\` otherwise
   */
  public hasWhen(): boolean {
    return this.hasWhenElement();
  }

  /**
   * @returns the \`who\` property value as a Reference object if defined; else null
   */
  public getWho(): Reference | null {
    return this.who;
  }

  /**
   * Assigns the provided Who object value to the \`who\` property.
   *
   * @decorator \`@ReferenceTargets('Signature.who', ['Practitioner','PractitionerRole','RelatedPerson','Patient','Device','Organization',])\`
   *
   * @param value - the \`who\` object value
   * @returns this
   */
  @ReferenceTargets('Signature.who', [
    'Practitioner',
  
    'PractitionerRole',
  
    'RelatedPerson',
  
    'Patient',
  
    'Device',
  
    'Organization',
  ])
  public setWho(value: Reference): this {
    assertIsDefined<Reference>(value, \`Signature.who is required\`);
    // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
    this.who = value;
    return this;
  }

  /**
   * @returns \`true\` if the \`who\` property exists and has a value; \`false\` otherwise
   */
  public hasWho(): boolean {
    return isDefined<Reference>(this.who) && !this.who.isEmpty();
  }

  /**
   * @returns the \`onBehalfOf\` property value as a Reference object; else an empty Reference object
   */
  public getOnBehalfOf(): Reference {
    return this.onBehalfOf ?? new Reference();
  }

  /**
   * Assigns the provided OnBehalfOf object value to the \`onBehalfOf\` property.
   *
   * @decorator \`@ReferenceTargets('Signature.onBehalfOf', ['Practitioner','PractitionerRole','RelatedPerson','Patient','Device','Organization',])\`
   *
   * @param value - the \`onBehalfOf\` object value
   * @returns this
   */
  @ReferenceTargets('Signature.onBehalfOf', [
    'Practitioner',
  
    'PractitionerRole',
  
    'RelatedPerson',
  
    'Patient',
  
    'Device',
  
    'Organization',
  ])
  public setOnBehalfOf(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.onBehalfOf = value;
    } else {
      this.onBehalfOf = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`onBehalfOf\` property exists and has a value; \`false\` otherwise
   */
  public hasOnBehalfOf(): boolean {
    return isDefined<Reference>(this.onBehalfOf) && !this.onBehalfOf.isEmpty();
  }

  /**
   * @returns the \`targetFormat\` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getTargetFormatElement(): CodeType {
    return this.targetFormat ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`targetFormat\` property.
   *
   * @param element - the \`targetFormat\` value
   * @returns this
   */
  public setTargetFormatElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Signature.targetFormat; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.targetFormat = element;
    } else {
      this.targetFormat = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`targetFormat\` property exists and has a value; \`false\` otherwise
   */
  public hasTargetFormatElement(): boolean {
    return isDefined<CodeType>(this.targetFormat) && !this.targetFormat.isEmpty();
  }

  /**
   * @returns the \`targetFormat\` property value as a fhirCode if defined; else undefined
   */
  public getTargetFormat(): fhirCode | undefined {
    return this.targetFormat?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`targetFormat\` property.
   *
   * @param value - the \`targetFormat\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setTargetFormat(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Signature.targetFormat (\${String(value)})\`;
      this.targetFormat = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.targetFormat = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`targetFormat\` property exists and has a value; \`false\` otherwise
   */
  public hasTargetFormat(): boolean {
    return this.hasTargetFormatElement();
  }

  /**
   * @returns the \`sigFormat\` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getSigFormatElement(): CodeType {
    return this.sigFormat ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`sigFormat\` property.
   *
   * @param element - the \`sigFormat\` value
   * @returns this
   */
  public setSigFormatElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Signature.sigFormat; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.sigFormat = element;
    } else {
      this.sigFormat = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`sigFormat\` property exists and has a value; \`false\` otherwise
   */
  public hasSigFormatElement(): boolean {
    return isDefined<CodeType>(this.sigFormat) && !this.sigFormat.isEmpty();
  }

  /**
   * @returns the \`sigFormat\` property value as a fhirCode if defined; else undefined
   */
  public getSigFormat(): fhirCode | undefined {
    return this.sigFormat?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`sigFormat\` property.
   *
   * @param value - the \`sigFormat\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setSigFormat(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Signature.sigFormat (\${String(value)})\`;
      this.sigFormat = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.sigFormat = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`sigFormat\` property exists and has a value; \`false\` otherwise
   */
  public hasSigFormat(): boolean {
    return this.hasSigFormatElement();
  }

  /**
   * @returns the \`data\` property value as a Base64BinaryType object if defined; else an empty Base64BinaryType object
   */
  public getDataElement(): Base64BinaryType {
    return this.data ?? new Base64BinaryType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`data\` property.
   *
   * @param element - the \`data\` value
   * @returns this
   */
  public setDataElement(element: Base64BinaryType | undefined): this {
    if (isDefined<Base64BinaryType>(element)) {
      const optErrMsg = \`Invalid Signature.data; Provided element is not an instance of Base64BinaryType.\`;
      assertFhirType<Base64BinaryType>(element, Base64BinaryType, optErrMsg);
      this.data = element;
    } else {
      this.data = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`data\` property exists and has a value; \`false\` otherwise
   */
  public hasDataElement(): boolean {
    return isDefined<Base64BinaryType>(this.data) && !this.data.isEmpty();
  }

  /**
   * @returns the \`data\` property value as a fhirBase64Binary if defined; else undefined
   */
  public getData(): fhirBase64Binary | undefined {
    return this.data?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`data\` property.
   *
   * @param value - the \`data\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setData(value: fhirBase64Binary | undefined): this {
    if (isDefined<fhirBase64Binary>(value)) {
      const optErrMsg = \`Invalid Signature.data (\${String(value)})\`;
      this.data = new Base64BinaryType(parseFhirPrimitiveData(value, fhirBase64BinarySchema, optErrMsg));
    } else {
      this.data = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`data\` property exists and has a value; \`false\` otherwise
   */
  public hasData(): boolean {
    return this.hasDataElement();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Signature';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.type_,
      this.when,
      this.who,
      this.onBehalfOf,
      this.targetFormat,
      this.sigFormat,
      this.data,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Signature {
    const dest = new Signature();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Signature): void {
    super.copyValues(dest);
    const typeList = copyListValues<Coding>(this.type_);
    dest.type_ = typeList.length === 0 ? null : typeList;
    dest.when = this.when ? this.when.copy() : null;
    dest.who = this.who ? this.who.copy() : null;
    dest.onBehalfOf = this.onBehalfOf?.copy();
    dest.targetFormat = this.targetFormat?.copy();
    dest.sigFormat = this.sigFormat?.copy();
    dest.data = this.data?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasType()) {
      setFhirComplexListJson(this.getType(), 'type', jsonObj);
    } else {
      missingReqdProperties.push(\`Signature.type\`);
    }

    if (this.hasWhenElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirInstant>(this.getWhenElement()!, 'when', jsonObj);
    } else {
      missingReqdProperties.push(\`Signature.when\`);
    }

    if (this.hasWho()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirComplexJson(this.getWho()!, 'who', jsonObj);
    } else {
      missingReqdProperties.push(\`Signature.who\`);
    }

    if (this.hasOnBehalfOf()) {
      setFhirComplexJson(this.getOnBehalfOf(), 'onBehalfOf', jsonObj);
    }

    if (this.hasTargetFormatElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getTargetFormatElement(), 'targetFormat', jsonObj);
    }

    if (this.hasSigFormatElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getSigFormatElement(), 'sigFormat', jsonObj);
    }

    if (this.hasDataElement()) {
      setFhirPrimitiveJson<fhirBase64Binary>(this.getDataElement(), 'data', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "Signature",
}
`;

exports[`src/generator-app unit test suite generator-app verify generated content should consistently create GeneratedContent[] 20`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/test-out",
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/utest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * Timing Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/Timing
 * StructureDefinition.name: Timing
 * StructureDefinition.description: Base StructureDefinition for Timing Type: Specifies an event that may occur multiple times. Timing schedules are used to record when things are planned, expected or requested to occur. The most common usage is in dosage instructions for medications. They are also used when planning care of various kinds, and may be used for reporting the schedule to which past regular activities were carried out.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  BackboneType,
  ChoiceDataTypes,
  ChoiceDataTypesMeta,
  CodeType,
  DataType,
  DateTimeType,
  DecimalType,
  Element,
  EnumCodeType,
  FhirDataTypeParser,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  InvalidTypeError,
  JSON,
  PositiveIntType,
  PrimitiveTypeJson,
  TimeType,
  UnsignedIntType,
  assertEnumCodeType,
  assertEnumCodeTypeList,
  assertFhirType,
  assertFhirTypeList,
  assertIsDefined,
  copyListValues,
  fhirCode,
  fhirCodeSchema,
  fhirDateTime,
  fhirDateTimeSchema,
  fhirDecimal,
  fhirDecimalSchema,
  fhirPositiveInt,
  fhirPositiveIntSchema,
  fhirTime,
  fhirTimeSchema,
  fhirUnsignedInt,
  fhirUnsignedIntSchema,
  getPrimitiveTypeJson,
  getPrimitiveTypeListJson,
  isDefined,
  isDefinedList,
  isElementEmpty,
  isEmpty,
  parseCodeType,
  parseDateTimeType,
  parseDecimalType,
  parseFhirPrimitiveData,
  parsePositiveIntType,
  parseTimeType,
  parseUnsignedIntType,
  setFhirComplexJson,
  setFhirPrimitiveJson,
  setFhirPrimitiveListJson,
  setPolymorphicValueJson,
} from '@paq-ts-fhir/fhir-core';
import {
  CodeableConcept,
  DaysOfWeekEnum,
  Duration,
  PARSABLE_DATATYPE_MAP,
  Period,
  Range,
} from '../index';

// eslint-disable-next-line @typescript-eslint/no-explicit-any -- Symbol.metadata polyfill secret sauce for decorator metadata
(Symbol.metadata as any) ??= Symbol('Symbol.metadata');

/**
 * Timing Class
 *
 * @remarks
 * Base StructureDefinition for Timing Type: Specifies an event that may occur multiple times. Timing schedules are used to record when things are planned, expected or requested to occur. The most common usage is in dosage instructions for medications. They are also used when planning care of various kinds, and may be used for reporting the schedule to which past regular activities were carried out.
 *
 * Need to able to track proposed timing schedules. There are several different ways to do this: one or more specified times, a simple rules like three times a day, or  before/after meals.
 *
 * **FHIR Specification**
 * - **Short:** A timing schedule that specifies an event that may occur multiple times
 * - **Definition:** Specifies an event that may occur multiple times. Timing schedules are used to record when things are planned, expected or requested to occur. The most common usage is in dosage instructions for medications. They are also used when planning care of various kinds, and may be used for reporting the schedule to which past regular activities were carried out.
 * - **Comment:** Describes the occurrence of an event that may occur multiple times. Timing schedules are used for specifying when events are expected or requested to occur, and may also be used to represent the summary of a past or ongoing event.  For simplicity, the definitions of Timing components are expressed as \\'future\\' events, but such components can also be used to describe historic or ongoing events. A Timing schedule can be a list of events and/or criteria for when the event happens, which can be expressed in a structured form and/or as a code. When both event and a repeating specification are provided, the list of events should be understood as an interpretation of the information in the repeat structure.
 * - **FHIR Version:** 4.0.1
 *
 * @category DataModel: ComplexType
 * @see [FHIR Timing](http://hl7.org/fhir/StructureDefinition/Timing)
 */
export class Timing extends BackboneType implements IBase {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`Timing\` JSON to instantiate the Timing data model.
   *
   * @param sourceJson - JSON representing FHIR \`Timing\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Timing
   * @returns Timing data model or undefined for \`Timing\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Timing | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Timing';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Timing();
    fhirDataTypeParser.processBackboneTypeJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    

    fieldName = 'event';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: DateTimeType | undefined = parseDateTimeType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addEventElement(datatype);
        }
      });
    }

    fieldName = 'repeat';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: TimingRepeatComponent | undefined = fhirDataTypeParser.parser<TimingRepeatComponent>(TimingRepeatComponent, classJsonObj[fieldName]!, sourceField);
      instance.setRepeat(datatype);
    }

    fieldName = 'code';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = fhirDataTypeParser.parser<CodeableConcept>(CodeableConcept, classJsonObj[fieldName]!, sourceField);
      instance.setCode(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Timing.event Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** When the event occurs
   * - **Definition:** Identifies specific times when the event occurs.
   * - **Requirements:** In a Medication Administration Record, for instance, you need to take a general specification, and turn it into a precise specification.
   * - **FHIR Type:** \`dateTime\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private event?: DateTimeType[] | undefined;

  /**
   * Timing.repeat Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** When the event is to occur
   * - **Definition:** A set of rules that describe when the event is scheduled.
   * - **Requirements:** Many timing schedules are determined by regular repetitions.
   * - **FHIR Type:** \`Element\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private repeat?: TimingRepeatComponent | undefined;

  /**
   * Timing.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** BID | TID | QID | AM | PM | QD | QOD | +
   * - **Definition:** A code for the timing schedule (or just text in code.text). Some codes such as BID are ubiquitous, but many institutions define their own additional codes. If a code is provided, the code is understood to be a complete statement of whatever is specified in the structured timing data, and either the code or the data may be used to interpret the Timing, with the exception that .repeat.bounds still applies over the code (and is not contained in the code).
   * - **Comment:** BID etc. are defined as \\'at institutionally specified times\\'. For example, an institution may choose that BID is "always at 7am and 6pm".  If it is inappropriate for this choice to be made, the code BID should not be used. Instead, a distinct organization-specific code should be used in place of the HL7-defined BID code and/or a structured representation should be used (in this case, specifying the two event times).
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code?: CodeableConcept | undefined;


  /**
   * @returns the \`event\` property value as a DateTimeType array
   */
  public getEventElement(): DateTimeType[] {
    return this.event ?? ([] as DateTimeType[]);
  }

  /**
   * Assigns the provided DateTimeType array value to the \`event\` property.
   *
   * @param element - the \`event\` array value
   * @returns this
   */
  public setEventElement(element: DateTimeType[] | undefined): this {
    if (isDefinedList<DateTimeType>(element)) {
      const optErrMsg = \`Invalid Timing.event; Provided value array has an element that is not an instance of DateTimeType.\`;
      assertFhirTypeList<DateTimeType>(element, DateTimeType, optErrMsg);
      this.event = element;
    } else {
      this.event = undefined;
    }
    return this;
  }

  /**
   * Add the provided DateTimeType value to the \`event\` array property.
   *
   * @param element - the \`event\` value
   * @returns this
   */
  public addEventElement(element: DateTimeType | undefined): this {
    if (isDefined<DateTimeType>(element)) {
      const optErrMsg = \`Invalid Timing.event; Provided element is not an instance of DateTimeType.\`;
      assertFhirType<DateTimeType>(element, DateTimeType, optErrMsg);
      this.initEvent();
      this.event?.push(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`event\` property exists and has a value; \`false\` otherwise
   */
  public hasEventElement(): boolean {
    return isDefinedList<DateTimeType>(this.event) && this.event.some((item: DateTimeType) => !item.isEmpty());
  }

  /**
   * @returns the \`event\` property value as a fhirDateTime array
   */
  public getEvent(): fhirDateTime[] {
    this.initEvent();
    const eventValues = [] as fhirDateTime[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.event!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        eventValues.push(value);
      }
    }
    return eventValues;
  }

  /**
   * Assigns the provided primitive value array to the \`event\` property.
   *
   * @param value - the \`event\` value array
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setEvent(value: fhirDateTime[] | undefined): this {
    if (isDefinedList<fhirDateTime>(value)) {
      const eventElements = [] as DateTimeType[];
      for (const eventValue of value) {
        const optErrMsg = \`Invalid Timing.event array item (\${String(eventValue)})\`;
        const element = new DateTimeType(parseFhirPrimitiveData(eventValue, fhirDateTimeSchema, optErrMsg));
        eventElements.push(element);
      }
      this.event = eventElements;
    } else {
      this.event = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`event\` array property.
   *
   * @param value - the \`event\` value
   * @returns this
   */
  public addEvent(value: fhirDateTime | undefined): this {
    if (isDefined<fhirDateTime>(value)) {
      const optErrMsg = \`Invalid Timing.event array item (\${String(value)})\`;
      const element = new DateTimeType(parseFhirPrimitiveData(value, fhirDateTimeSchema, optErrMsg));
      this.initEvent();
      this.addEventElement(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`event\` property exists and has a value; \`false\` otherwise
   */
  public hasEvent(): boolean {
    return this.hasEventElement();
  }

  /**
   * Initialize the \`event\` property
   */
  private initEvent(): void {
    if (!this.hasEvent()) {
      this.event = [] as DateTimeType[];
    }
  }

  /**
   * @returns the \`repeat\` property value as a TimingRepeatComponent object if defined; else an empty TimingRepeatComponent object
   */
  public getRepeat(): TimingRepeatComponent {
    return this.repeat ?? new TimingRepeatComponent();
  }

  /**
   * Assigns the provided Repeat object value to the \`repeat\` property.
   *
   * @param value - the \`repeat\` object value
   * @returns this
   */
  public setRepeat(value: TimingRepeatComponent | undefined): this {
    if (isDefined<TimingRepeatComponent>(value)) {
      const optErrMsg = \`Invalid Timing.repeat; Provided element is not an instance of TimingRepeatComponent.\`;
      assertFhirType<TimingRepeatComponent>(value, TimingRepeatComponent, optErrMsg);
      this.repeat = value;
    } else {
      this.repeat = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`repeat\` property exists and has a value; \`false\` otherwise
   */
  public hasRepeat(): boolean {
    return isDefined<TimingRepeatComponent>(this.repeat) && !this.repeat.isEmpty();
  }

  /**
   * @returns the \`code\` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getCode(): CodeableConcept {
    return this.code ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Code object value to the \`code\` property.
   *
   * @param value - the \`code\` object value
   * @returns this
   */
  public setCode(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Timing.code; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.code = value;
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`code\` property exists and has a value; \`false\` otherwise
   */
  public hasCode(): boolean {
    return isDefined<CodeableConcept>(this.code) && !this.code.isEmpty();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Timing';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.event,
      this.repeat,
      this.code,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Timing {
    const dest = new Timing();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Timing): void {
    super.copyValues(dest);
    const eventList = copyListValues<DateTimeType>(this.event);
    dest.event = eventList.length === 0 ? undefined : eventList;
    dest.repeat = this.repeat?.copy();
    dest.code = this.code?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasEvent()) {
      setFhirPrimitiveListJson(this.getEventElement(), 'event', jsonObj);
    }

    if (this.hasRepeat()) {
      setFhirComplexJson(this.getRepeat(), 'repeat', jsonObj);
    }

    if (this.hasCode()) {
      setFhirComplexJson(this.getCode(), 'code', jsonObj);
    }

    return jsonObj;
  }
}


/**
 * TimingRepeatComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** When the event is to occur
 * - **Definition:** A set of rules that describe when the event is scheduled.
 * - **Requirements:** Many timing schedules are determined by regular repetitions.
 *
 * @category DataModel: ComplexType
 * @see [FHIR Timing](http://hl7.org/fhir/StructureDefinition/Timing)
 */
export class TimingRepeatComponent extends Element {
  constructor() {
    super();

    this.daysOfWeekEnum = new DaysOfWeekEnum();
  }

  /**
   * Parse the provided \`TimingRepeatComponent\` JSON to instantiate the TimingRepeatComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`TimingRepeatComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to TimingRepeatComponent
   * @returns TimingRepeatComponent data model or undefined for \`TimingRepeatComponent\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): TimingRepeatComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'TimingRepeatComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new TimingRepeatComponent();
    fhirDataTypeParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const classMetadata: DecoratorMetadataObject | null = TimingRepeatComponent[Symbol.metadata];
    const errorMessage = \`DecoratorMetadataObject does not exist for TimingRepeatComponent\`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    fieldName = 'bounds[x]';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const bounds: DataType | undefined = fhirDataTypeParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setBounds(bounds);

    fieldName = 'count';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = parsePositiveIntType(dtJson, dtSiblingJson);
      instance.setCountElement(datatype);
    }

    fieldName = 'countMax';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = parsePositiveIntType(dtJson, dtSiblingJson);
      instance.setCountMaxElement(datatype);
    }

    fieldName = 'duration';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = parseDecimalType(dtJson, dtSiblingJson);
      instance.setDurationElement(datatype);
    }

    fieldName = 'durationMax';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = parseDecimalType(dtJson, dtSiblingJson);
      instance.setDurationMaxElement(datatype);
    }

    fieldName = 'durationUnit';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      instance.setDurationUnitElement(datatype);
    }

    fieldName = 'frequency';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = parsePositiveIntType(dtJson, dtSiblingJson);
      instance.setFrequencyElement(datatype);
    }

    fieldName = 'frequencyMax';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = parsePositiveIntType(dtJson, dtSiblingJson);
      instance.setFrequencyMaxElement(datatype);
    }

    fieldName = 'period';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = parseDecimalType(dtJson, dtSiblingJson);
      instance.setPeriodElement(datatype);
    }

    fieldName = 'periodMax';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = parseDecimalType(dtJson, dtSiblingJson);
      instance.setPeriodMaxElement(datatype);
    }

    fieldName = 'periodUnit';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      instance.setPeriodUnitElement(datatype);
    }

    fieldName = 'dayOfWeek';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: CodeType | undefined = parseCodeType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addDayOfWeekElement(datatype);
        }
      });
    }

    fieldName = 'timeOfDay';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: TimeType | undefined = parseTimeType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addTimeOfDayElement(datatype);
        }
      });
    }

    fieldName = 'when';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: CodeType | undefined = parseCodeType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addWhenElement(datatype);
        }
      });
    }

    fieldName = 'offset';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UnsignedIntType | undefined = parseUnsignedIntType(dtJson, dtSiblingJson);
      instance.setOffsetElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Timing.repeat.bounds[x] Element
   *
   * @decorator \`@ChoiceDataTypesMeta('Timing.repeat.bounds[x]', ['Duration','Range','Period',]\`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Length/Range of lengths, or (Start and/or end) limits
   * - **Definition:** Either a duration for the length of the timing schedule, a range of possible length, or outer bounds for start and/or end limits of the timing schedule.
   * - **FHIR Types:**
   *     'Duration',
   *     'Range',
   *     'Period',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('Timing.repeat.bounds[x]',[
    'Duration',
    'Range',
    'Period',
  ])
  private bounds?: DataType | undefined;

  /**
   * Timing.repeat.count Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Number of times to repeat
   * - **Definition:** A total count of the desired number of repetitions across the duration of the entire timing specification. If countMax is present, this element indicates the lower bound of the allowed range of count values.
   * - **Comment:** If you have both bounds and count, then this should be understood as within the bounds period, until count times happens.
   * - **Requirements:** Repetitions may be limited by end time or total occurrences.
   * - **FHIR Type:** \`positiveInt\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private count?: PositiveIntType | undefined;

  /**
   * Timing.repeat.countMax Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Maximum number of times to repeat
   * - **Definition:** If present, indicates that the count is a range - so to perform the action between [count] and [countMax] times.
   * - **FHIR Type:** \`positiveInt\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private countMax?: PositiveIntType | undefined;

  /**
   * Timing.repeat.duration Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** How long when it happens
   * - **Definition:** How long this thing happens for when it happens. If durationMax is present, this element indicates the lower bound of the allowed range of the duration.
   * - **Comment:** For some events the duration is part of the definition of the event (e.g. IV infusions, where the duration is implicit in the specified quantity and rate). For others, it\\'s part of the timing specification (e.g. exercise).
   * - **Requirements:** Some activities are not instantaneous and need to be maintained for a period of time.
   * - **FHIR Type:** \`decimal\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private duration?: DecimalType | undefined;

  /**
   * Timing.repeat.durationMax Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** How long when it happens (Max)
   * - **Definition:** If present, indicates that the duration is a range - so to perform the action between [duration] and [durationMax] time length.
   * - **Comment:** For some events the duration is part of the definition of the event (e.g. IV infusions, where the duration is implicit in the specified quantity and rate). For others, it\\'s part of the timing specification (e.g. exercise).
   * - **Requirements:** Some activities are not instantaneous and need to be maintained for a period of time.
   * - **FHIR Type:** \`decimal\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private durationMax?: DecimalType | undefined;

  /**
   * Timing.repeat.durationUnit Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** s | min | h | d | wk | mo | a - unit of time (UCUM)
   * - **Definition:** The units of time for the duration, in UCUM units.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private durationUnit?: CodeType | undefined;

  /**
   * Timing.repeat.frequency Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Event occurs frequency times per period
   * - **Definition:** The number of times to repeat the action within the specified period. If frequencyMax is present, this element indicates the lower bound of the allowed range of the frequency.
   * - **FHIR Type:** \`positiveInt\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private frequency?: PositiveIntType | undefined;

  /**
   * Timing.repeat.frequencyMax Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Event occurs up to frequencyMax times per period
   * - **Definition:** If present, indicates that the frequency is a range - so to repeat between [frequency] and [frequencyMax] times within the period or period range.
   * - **FHIR Type:** \`positiveInt\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private frequencyMax?: PositiveIntType | undefined;

  /**
   * Timing.repeat.period Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Event occurs frequency times per period
   * - **Definition:** Indicates the duration of time over which repetitions are to occur; e.g. to express "3 times per day", 3 would be the frequency and "1 day" would be the period. If periodMax is present, this element indicates the lower bound of the allowed range of the period length.
   * - **FHIR Type:** \`decimal\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private period?: DecimalType | undefined;

  /**
   * Timing.repeat.periodMax Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Upper limit of period (3-4 hours)
   * - **Definition:** If present, indicates that the period is a range from [period] to [periodMax], allowing expressing concepts such as "do this once every 3-5 days.
   * - **FHIR Type:** \`decimal\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private periodMax?: DecimalType | undefined;

  /**
   * Timing.repeat.periodUnit Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** s | min | h | d | wk | mo | a - unit of time (UCUM)
   * - **Definition:** The units of time for the period in UCUM units.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private periodUnit?: CodeType | undefined;

  /**
   * FHIR CodeSystem: DaysOfWeek
   *
   * @see {@link DaysOfWeekEnum }
   */
  private readonly daysOfWeekEnum: DaysOfWeekEnum;

  /**
   * Timing.repeat.dayOfWeek Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** mon | tue | wed | thu | fri | sat | sun
   * - **Definition:** If one or more days of week is provided, then the action happens only on the specified day(s).
   * - **Comment:** If no days are specified, the action is assumed to happen every day as otherwise specified. The elements frequency and period cannot be used as well as dayOfWeek.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private dayOfWeek?: EnumCodeType[] | undefined;

  /**
   * Timing.repeat.timeOfDay Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Time of day for action
   * - **Definition:** Specified time of day for action to take place.
   * - **Comment:** When time of day is specified, it is inferred that the action happens every day (as filtered by dayofWeek) on the specified times. The elements when, frequency and period cannot be used as well as timeOfDay.
   * - **FHIR Type:** \`time\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private timeOfDay?: TimeType[] | undefined;

  /**
   * Timing.repeat.when Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Code for time period of occurrence
   * - **Definition:** An approximate time period during the day, potentially linked to an event of daily living that indicates when the action should occur.
   * - **Comment:** When more than one event is listed, the event is tied to the union of the specified events.
   * - **Requirements:** Timings are frequently determined by occurrences such as waking, eating and sleep.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private when?: CodeType[] | undefined;

  /**
   * Timing.repeat.offset Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Minutes from event (before or after)
   * - **Definition:** The number of minutes from the event. If the event code does not indicate whether the minutes is before or after the event, then the offset is assumed to be after the event.
   * - **FHIR Type:** \`unsignedInt\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private offset?: UnsignedIntType | undefined;


  /**
   * @returns the \`bounds\` property value as a DataType object if defined; else undefined
   */
  public getBounds(): DataType | undefined {
    return this.bounds;
  }

  /**
   * Assigns the provided DataType object value to the \`bounds\` property.
   *
   * @decorator \`@ChoiceDataTypes('Timing.repeat.bounds[x]')\`
   *
   * @param value - the \`bounds\` object value
   * @returns this
   */
  @ChoiceDataTypes('Timing.repeat.bounds[x]')
  public setBounds(value: DataType | undefined): this {
    if (isDefined<DataType>(value)) {
      // assertFhirType<DataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.bounds = value;
    } else {
      this.bounds = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`bounds\` property exists and has a value; \`false\` otherwise
   */
  public hasBounds(): boolean {
    return isDefined<DataType>(this.bounds) && !this.bounds.isEmpty();
  }

  // *** NOTE ***
  // Next "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the \`bounds\` property value as a Duration object if defined; else undefined
   */
  public getBoundsDuration(): Duration | undefined {
    if (!isDefined<DataType | undefined>(this.bounds)) {
      return undefined;
    }
    if (!(this.bounds instanceof Duration)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Timing.repeat.bounds[x]: Expected Duration but encountered \${this.bounds.fhirType()}\`,
      );
    }
    return this.bounds;
  }

  /**
   * @returns \`true\` if the \`bounds\` property exists as a Duration and has a value; \`false\` otherwise
   */
  public hasBoundsDuration(): boolean {
    return this.hasBounds() && this.bounds instanceof Duration;
  }

  /**
   * @returns the \`bounds\` property value as a Range object if defined; else undefined
   */
  public getBoundsRange(): Range | undefined {
    if (!isDefined<DataType | undefined>(this.bounds)) {
      return undefined;
    }
    if (!(this.bounds instanceof Range)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Timing.repeat.bounds[x]: Expected Range but encountered \${this.bounds.fhirType()}\`,
      );
    }
    return this.bounds;
  }

  /**
   * @returns \`true\` if the \`bounds\` property exists as a Range and has a value; \`false\` otherwise
   */
  public hasBoundsRange(): boolean {
    return this.hasBounds() && this.bounds instanceof Range;
  }

  /**
   * @returns the \`bounds\` property value as a Period object if defined; else undefined
   */
  public getBoundsPeriod(): Period | undefined {
    if (!isDefined<DataType | undefined>(this.bounds)) {
      return undefined;
    }
    if (!(this.bounds instanceof Period)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Timing.repeat.bounds[x]: Expected Period but encountered \${this.bounds.fhirType()}\`,
      );
    }
    return this.bounds;
  }

  /**
   * @returns \`true\` if the \`bounds\` property exists as a Period and has a value; \`false\` otherwise
   */
  public hasBoundsPeriod(): boolean {
    return this.hasBounds() && this.bounds instanceof Period;
  }

  /**
   * @returns the \`count\` property value as a PositiveIntType object if defined; else an empty PositiveIntType object
   */
  public getCountElement(): PositiveIntType {
    return this.count ?? new PositiveIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`count\` property.
   *
   * @param element - the \`count\` value
   * @returns this
   */
  public setCountElement(element: PositiveIntType | undefined): this {
    if (isDefined<PositiveIntType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.count; Provided element is not an instance of PositiveIntType.\`;
      assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
      this.count = element;
    } else {
      this.count = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`count\` property exists and has a value; \`false\` otherwise
   */
  public hasCountElement(): boolean {
    return isDefined<PositiveIntType>(this.count) && !this.count.isEmpty();
  }

  /**
   * @returns the \`count\` property value as a fhirPositiveInt if defined; else undefined
   */
  public getCount(): fhirPositiveInt | undefined {
    return this.count?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`count\` property.
   *
   * @param value - the \`count\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setCount(value: fhirPositiveInt | undefined): this {
    if (isDefined<fhirPositiveInt>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.count (\${String(value)})\`;
      this.count = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    } else {
      this.count = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`count\` property exists and has a value; \`false\` otherwise
   */
  public hasCount(): boolean {
    return this.hasCountElement();
  }

  /**
   * @returns the \`countMax\` property value as a PositiveIntType object if defined; else an empty PositiveIntType object
   */
  public getCountMaxElement(): PositiveIntType {
    return this.countMax ?? new PositiveIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`countMax\` property.
   *
   * @param element - the \`countMax\` value
   * @returns this
   */
  public setCountMaxElement(element: PositiveIntType | undefined): this {
    if (isDefined<PositiveIntType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.countMax; Provided element is not an instance of PositiveIntType.\`;
      assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
      this.countMax = element;
    } else {
      this.countMax = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`countMax\` property exists and has a value; \`false\` otherwise
   */
  public hasCountMaxElement(): boolean {
    return isDefined<PositiveIntType>(this.countMax) && !this.countMax.isEmpty();
  }

  /**
   * @returns the \`countMax\` property value as a fhirPositiveInt if defined; else undefined
   */
  public getCountMax(): fhirPositiveInt | undefined {
    return this.countMax?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`countMax\` property.
   *
   * @param value - the \`countMax\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setCountMax(value: fhirPositiveInt | undefined): this {
    if (isDefined<fhirPositiveInt>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.countMax (\${String(value)})\`;
      this.countMax = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    } else {
      this.countMax = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`countMax\` property exists and has a value; \`false\` otherwise
   */
  public hasCountMax(): boolean {
    return this.hasCountMaxElement();
  }

  /**
   * @returns the \`duration\` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getDurationElement(): DecimalType {
    return this.duration ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`duration\` property.
   *
   * @param element - the \`duration\` value
   * @returns this
   */
  public setDurationElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.duration; Provided element is not an instance of DecimalType.\`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.duration = element;
    } else {
      this.duration = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`duration\` property exists and has a value; \`false\` otherwise
   */
  public hasDurationElement(): boolean {
    return isDefined<DecimalType>(this.duration) && !this.duration.isEmpty();
  }

  /**
   * @returns the \`duration\` property value as a fhirDecimal if defined; else undefined
   */
  public getDuration(): fhirDecimal | undefined {
    return this.duration?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`duration\` property.
   *
   * @param value - the \`duration\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setDuration(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.duration (\${String(value)})\`;
      this.duration = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.duration = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`duration\` property exists and has a value; \`false\` otherwise
   */
  public hasDuration(): boolean {
    return this.hasDurationElement();
  }

  /**
   * @returns the \`durationMax\` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getDurationMaxElement(): DecimalType {
    return this.durationMax ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`durationMax\` property.
   *
   * @param element - the \`durationMax\` value
   * @returns this
   */
  public setDurationMaxElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.durationMax; Provided element is not an instance of DecimalType.\`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.durationMax = element;
    } else {
      this.durationMax = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`durationMax\` property exists and has a value; \`false\` otherwise
   */
  public hasDurationMaxElement(): boolean {
    return isDefined<DecimalType>(this.durationMax) && !this.durationMax.isEmpty();
  }

  /**
   * @returns the \`durationMax\` property value as a fhirDecimal if defined; else undefined
   */
  public getDurationMax(): fhirDecimal | undefined {
    return this.durationMax?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`durationMax\` property.
   *
   * @param value - the \`durationMax\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setDurationMax(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.durationMax (\${String(value)})\`;
      this.durationMax = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.durationMax = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`durationMax\` property exists and has a value; \`false\` otherwise
   */
  public hasDurationMax(): boolean {
    return this.hasDurationMaxElement();
  }

  /**
   * @returns the \`durationUnit\` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getDurationUnitElement(): CodeType {
    return this.durationUnit ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`durationUnit\` property.
   *
   * @param element - the \`durationUnit\` value
   * @returns this
   */
  public setDurationUnitElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.durationUnit; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.durationUnit = element;
    } else {
      this.durationUnit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`durationUnit\` property exists and has a value; \`false\` otherwise
   */
  public hasDurationUnitElement(): boolean {
    return isDefined<CodeType>(this.durationUnit) && !this.durationUnit.isEmpty();
  }

  /**
   * @returns the \`durationUnit\` property value as a fhirCode if defined; else undefined
   */
  public getDurationUnit(): fhirCode | undefined {
    return this.durationUnit?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`durationUnit\` property.
   *
   * @param value - the \`durationUnit\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setDurationUnit(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.durationUnit (\${String(value)})\`;
      this.durationUnit = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.durationUnit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`durationUnit\` property exists and has a value; \`false\` otherwise
   */
  public hasDurationUnit(): boolean {
    return this.hasDurationUnitElement();
  }

  /**
   * @returns the \`frequency\` property value as a PositiveIntType object if defined; else an empty PositiveIntType object
   */
  public getFrequencyElement(): PositiveIntType {
    return this.frequency ?? new PositiveIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`frequency\` property.
   *
   * @param element - the \`frequency\` value
   * @returns this
   */
  public setFrequencyElement(element: PositiveIntType | undefined): this {
    if (isDefined<PositiveIntType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.frequency; Provided element is not an instance of PositiveIntType.\`;
      assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
      this.frequency = element;
    } else {
      this.frequency = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`frequency\` property exists and has a value; \`false\` otherwise
   */
  public hasFrequencyElement(): boolean {
    return isDefined<PositiveIntType>(this.frequency) && !this.frequency.isEmpty();
  }

  /**
   * @returns the \`frequency\` property value as a fhirPositiveInt if defined; else undefined
   */
  public getFrequency(): fhirPositiveInt | undefined {
    return this.frequency?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`frequency\` property.
   *
   * @param value - the \`frequency\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setFrequency(value: fhirPositiveInt | undefined): this {
    if (isDefined<fhirPositiveInt>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.frequency (\${String(value)})\`;
      this.frequency = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    } else {
      this.frequency = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`frequency\` property exists and has a value; \`false\` otherwise
   */
  public hasFrequency(): boolean {
    return this.hasFrequencyElement();
  }

  /**
   * @returns the \`frequencyMax\` property value as a PositiveIntType object if defined; else an empty PositiveIntType object
   */
  public getFrequencyMaxElement(): PositiveIntType {
    return this.frequencyMax ?? new PositiveIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`frequencyMax\` property.
   *
   * @param element - the \`frequencyMax\` value
   * @returns this
   */
  public setFrequencyMaxElement(element: PositiveIntType | undefined): this {
    if (isDefined<PositiveIntType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.frequencyMax; Provided element is not an instance of PositiveIntType.\`;
      assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
      this.frequencyMax = element;
    } else {
      this.frequencyMax = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`frequencyMax\` property exists and has a value; \`false\` otherwise
   */
  public hasFrequencyMaxElement(): boolean {
    return isDefined<PositiveIntType>(this.frequencyMax) && !this.frequencyMax.isEmpty();
  }

  /**
   * @returns the \`frequencyMax\` property value as a fhirPositiveInt if defined; else undefined
   */
  public getFrequencyMax(): fhirPositiveInt | undefined {
    return this.frequencyMax?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`frequencyMax\` property.
   *
   * @param value - the \`frequencyMax\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setFrequencyMax(value: fhirPositiveInt | undefined): this {
    if (isDefined<fhirPositiveInt>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.frequencyMax (\${String(value)})\`;
      this.frequencyMax = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    } else {
      this.frequencyMax = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`frequencyMax\` property exists and has a value; \`false\` otherwise
   */
  public hasFrequencyMax(): boolean {
    return this.hasFrequencyMaxElement();
  }

  /**
   * @returns the \`period\` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getPeriodElement(): DecimalType {
    return this.period ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`period\` property.
   *
   * @param element - the \`period\` value
   * @returns this
   */
  public setPeriodElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.period; Provided element is not an instance of DecimalType.\`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.period = element;
    } else {
      this.period = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`period\` property exists and has a value; \`false\` otherwise
   */
  public hasPeriodElement(): boolean {
    return isDefined<DecimalType>(this.period) && !this.period.isEmpty();
  }

  /**
   * @returns the \`period\` property value as a fhirDecimal if defined; else undefined
   */
  public getPeriod(): fhirDecimal | undefined {
    return this.period?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`period\` property.
   *
   * @param value - the \`period\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setPeriod(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.period (\${String(value)})\`;
      this.period = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.period = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`period\` property exists and has a value; \`false\` otherwise
   */
  public hasPeriod(): boolean {
    return this.hasPeriodElement();
  }

  /**
   * @returns the \`periodMax\` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getPeriodMaxElement(): DecimalType {
    return this.periodMax ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`periodMax\` property.
   *
   * @param element - the \`periodMax\` value
   * @returns this
   */
  public setPeriodMaxElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.periodMax; Provided element is not an instance of DecimalType.\`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.periodMax = element;
    } else {
      this.periodMax = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`periodMax\` property exists and has a value; \`false\` otherwise
   */
  public hasPeriodMaxElement(): boolean {
    return isDefined<DecimalType>(this.periodMax) && !this.periodMax.isEmpty();
  }

  /**
   * @returns the \`periodMax\` property value as a fhirDecimal if defined; else undefined
   */
  public getPeriodMax(): fhirDecimal | undefined {
    return this.periodMax?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`periodMax\` property.
   *
   * @param value - the \`periodMax\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setPeriodMax(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.periodMax (\${String(value)})\`;
      this.periodMax = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.periodMax = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`periodMax\` property exists and has a value; \`false\` otherwise
   */
  public hasPeriodMax(): boolean {
    return this.hasPeriodMaxElement();
  }

  /**
   * @returns the \`periodUnit\` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getPeriodUnitElement(): CodeType {
    return this.periodUnit ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`periodUnit\` property.
   *
   * @param element - the \`periodUnit\` value
   * @returns this
   */
  public setPeriodUnitElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.periodUnit; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.periodUnit = element;
    } else {
      this.periodUnit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`periodUnit\` property exists and has a value; \`false\` otherwise
   */
  public hasPeriodUnitElement(): boolean {
    return isDefined<CodeType>(this.periodUnit) && !this.periodUnit.isEmpty();
  }

  /**
   * @returns the \`periodUnit\` property value as a fhirCode if defined; else undefined
   */
  public getPeriodUnit(): fhirCode | undefined {
    return this.periodUnit?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`periodUnit\` property.
   *
   * @param value - the \`periodUnit\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setPeriodUnit(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.periodUnit (\${String(value)})\`;
      this.periodUnit = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.periodUnit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`periodUnit\` property exists and has a value; \`false\` otherwise
   */
  public hasPeriodUnit(): boolean {
    return this.hasPeriodUnitElement();
  }

  /**
   * @returns the \`dayOfWeek\` property value as a EnumCodeType array
   */
  public getDayOfWeekEnumType(): EnumCodeType[] {
    return this.dayOfWeek ?? ([] as EnumCodeType[]);
  }

  /**
   * Assigns the provided EnumCodeType array value to the \`dayOfWeek\` property.
   *
   * @param enumType - the \`dayOfWeek\` array value
   * @returns this
   */
  public setDayOfWeekEnumType(enumType: EnumCodeType[] | undefined): this {
    if (isDefinedList<EnumCodeType>(enumType)) {
      const errMsgPrefix = \`Invalid Timing.repeat.dayOfWeek\`;
      assertEnumCodeTypeList<DaysOfWeekEnum>(enumType, DaysOfWeekEnum, errMsgPrefix);
      this.dayOfWeek = enumType;
    } else {
      this.dayOfWeek = undefined;
    }
    return this;
  }

  /**
   * Add the provided EnumCodeType value to the \`dayOfWeek\` array property.
   *
   * @param enumType - the \`dayOfWeek\` value
   * @returns this
   */
  public addDayOfWeekEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = \`Invalid Timing.repeat.dayOfWeek)\`;
      assertEnumCodeType<DaysOfWeekEnum>(enumType, DaysOfWeekEnum, errMsgPrefix);
      this.initDayOfWeek();
      this.dayOfWeek?.push(enumType);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`dayOfWeek\` property exists and has a value; \`false\` otherwise
   */
  public hasDayOfWeekEnumType(): boolean {
    return isDefinedList<EnumCodeType>(this.dayOfWeek) && this.dayOfWeek.some((item: EnumCodeType) => !item.isEmpty()) && this.dayOfWeek.every((item: EnumCodeType) => item.fhirCodeEnumeration.length > 0);
  }

  /**
   * @returns the \`dayOfWeek\` property value as a CodeType array
   */
  public getDayOfWeekElement(): CodeType[] {
    if (this.dayOfWeek === undefined) {
      return [] as CodeType[];
    }
    return this.dayOfWeek as CodeType[];
  }

  /**
   * Assigns the provided PrimitiveType array value to the \`dayOfWeek\` property.
   *
   * @param element - the \`dayOfWeek\` array value
   * @returns this
   */
  public setDayOfWeekElement(element: CodeType[] | undefined): this {
    if (isDefinedList<CodeType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.dayOfWeek; Provided element array has an element that is not an instance of CodeType.\`;
      assertFhirTypeList<CodeType>(element, CodeType, optErrMsg);
      const enumCodeTypes = [] as EnumCodeType[];
      element.forEach((type: CodeType) => {
        enumCodeTypes.push(new EnumCodeType(type, this.daysOfWeekEnum));
      });
      this.dayOfWeek = enumCodeTypes;
    } else {
      this.dayOfWeek = undefined;
    }
    return this;
  }

  /**
   * Add the provided PrimitiveType value to the \`dayOfWeek\` array property.
   *
   * @param element - the \`dayOfWeek\` value
   * @returns this
   */
  public addDayOfWeekElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.dayOfWeek; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.initDayOfWeek();
      this.dayOfWeek?.push(new EnumCodeType(element, this.daysOfWeekEnum));
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`dayOfWeek\` property exists and has a value; \`false\` otherwise
   */
  public hasDayOfWeekElement(): boolean {
    return this.hasDayOfWeekEnumType();
  }

  /**
   * @returns the \`dayOfWeek\` property value as a fhirCode array
   */
  public getDayOfWeek(): fhirCode[] {
    if (this.dayOfWeek === undefined) {
      return [] as fhirCode[];
    }
    const values = [] as fhirCode[];
    for (const item of this.dayOfWeek) {
      values.push(item.fhirCode.code);
    }
    return values;
  }

  /**
   * Assigns the provided primitive value array to the \`dayOfWeek\` property.
   *
   * @param value - the \`dayOfWeek\` value array
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setDayOfWeek(value: fhirCode[] | undefined): this {
    if (isDefinedList<fhirCode>(value)) {
      const enumCodeTypes = [] as EnumCodeType[];
      const optErrMsg = \`Invalid Timing.repeat.dayOfWeek; Provided value is not an instance of fhirCode.\`;
      value.forEach((val: fhirCode) => {
        enumCodeTypes.push(new EnumCodeType(parseFhirPrimitiveData(val, fhirCodeSchema, optErrMsg), this.daysOfWeekEnum));
      });
      this.dayOfWeek = enumCodeTypes;
    } else {
      this.dayOfWeek = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`dayOfWeek\` array property.
   *
   * @param value - the \`dayOfWeek\` value
   * @returns this
   */
  public addDayOfWeek(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      this.initDayOfWeek();
      const optErrMsg = \`Invalid Timing.repeat.dayOfWeek; Provided value is not an instance of fhirCode.\`;
      this.dayOfWeek?.push(new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.daysOfWeekEnum));
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`dayOfWeek\` property exists and has a value; \`false\` otherwise
   */
  public hasDayOfWeek(): boolean {
    return this.hasDayOfWeekEnumType();
  }

  /**
   * Initialize the dayOfWeek property
   */
  private initDayOfWeek(): void {
    if(!this.hasDayOfWeekEnumType()) {
      this.dayOfWeek = [] as EnumCodeType[];
    }
  }

  /**
   * @returns the \`timeOfDay\` property value as a TimeType array
   */
  public getTimeOfDayElement(): TimeType[] {
    return this.timeOfDay ?? ([] as TimeType[]);
  }

  /**
   * Assigns the provided TimeType array value to the \`timeOfDay\` property.
   *
   * @param element - the \`timeOfDay\` array value
   * @returns this
   */
  public setTimeOfDayElement(element: TimeType[] | undefined): this {
    if (isDefinedList<TimeType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.timeOfDay; Provided value array has an element that is not an instance of TimeType.\`;
      assertFhirTypeList<TimeType>(element, TimeType, optErrMsg);
      this.timeOfDay = element;
    } else {
      this.timeOfDay = undefined;
    }
    return this;
  }

  /**
   * Add the provided TimeType value to the \`timeOfDay\` array property.
   *
   * @param element - the \`timeOfDay\` value
   * @returns this
   */
  public addTimeOfDayElement(element: TimeType | undefined): this {
    if (isDefined<TimeType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.timeOfDay; Provided element is not an instance of TimeType.\`;
      assertFhirType<TimeType>(element, TimeType, optErrMsg);
      this.initTimeOfDay();
      this.timeOfDay?.push(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`timeOfDay\` property exists and has a value; \`false\` otherwise
   */
  public hasTimeOfDayElement(): boolean {
    return isDefinedList<TimeType>(this.timeOfDay) && this.timeOfDay.some((item: TimeType) => !item.isEmpty());
  }

  /**
   * @returns the \`timeOfDay\` property value as a fhirTime array
   */
  public getTimeOfDay(): fhirTime[] {
    this.initTimeOfDay();
    const timeOfDayValues = [] as fhirTime[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.timeOfDay!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        timeOfDayValues.push(value);
      }
    }
    return timeOfDayValues;
  }

  /**
   * Assigns the provided primitive value array to the \`timeOfDay\` property.
   *
   * @param value - the \`timeOfDay\` value array
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setTimeOfDay(value: fhirTime[] | undefined): this {
    if (isDefinedList<fhirTime>(value)) {
      const timeOfDayElements = [] as TimeType[];
      for (const timeOfDayValue of value) {
        const optErrMsg = \`Invalid Timing.repeat.timeOfDay array item (\${String(timeOfDayValue)})\`;
        const element = new TimeType(parseFhirPrimitiveData(timeOfDayValue, fhirTimeSchema, optErrMsg));
        timeOfDayElements.push(element);
      }
      this.timeOfDay = timeOfDayElements;
    } else {
      this.timeOfDay = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`timeOfDay\` array property.
   *
   * @param value - the \`timeOfDay\` value
   * @returns this
   */
  public addTimeOfDay(value: fhirTime | undefined): this {
    if (isDefined<fhirTime>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.timeOfDay array item (\${String(value)})\`;
      const element = new TimeType(parseFhirPrimitiveData(value, fhirTimeSchema, optErrMsg));
      this.initTimeOfDay();
      this.addTimeOfDayElement(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`timeOfDay\` property exists and has a value; \`false\` otherwise
   */
  public hasTimeOfDay(): boolean {
    return this.hasTimeOfDayElement();
  }

  /**
   * Initialize the \`timeOfDay\` property
   */
  private initTimeOfDay(): void {
    if (!this.hasTimeOfDay()) {
      this.timeOfDay = [] as TimeType[];
    }
  }

  /**
   * @returns the \`when\` property value as a CodeType array
   */
  public getWhenElement(): CodeType[] {
    return this.when ?? ([] as CodeType[]);
  }

  /**
   * Assigns the provided CodeType array value to the \`when\` property.
   *
   * @param element - the \`when\` array value
   * @returns this
   */
  public setWhenElement(element: CodeType[] | undefined): this {
    if (isDefinedList<CodeType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.when; Provided value array has an element that is not an instance of CodeType.\`;
      assertFhirTypeList<CodeType>(element, CodeType, optErrMsg);
      this.when = element;
    } else {
      this.when = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeType value to the \`when\` array property.
   *
   * @param element - the \`when\` value
   * @returns this
   */
  public addWhenElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.when; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.initWhen();
      this.when?.push(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`when\` property exists and has a value; \`false\` otherwise
   */
  public hasWhenElement(): boolean {
    return isDefinedList<CodeType>(this.when) && this.when.some((item: CodeType) => !item.isEmpty());
  }

  /**
   * @returns the \`when\` property value as a fhirCode array
   */
  public getWhen(): fhirCode[] {
    this.initWhen();
    const whenValues = [] as fhirCode[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.when!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        whenValues.push(value);
      }
    }
    return whenValues;
  }

  /**
   * Assigns the provided primitive value array to the \`when\` property.
   *
   * @param value - the \`when\` value array
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setWhen(value: fhirCode[] | undefined): this {
    if (isDefinedList<fhirCode>(value)) {
      const whenElements = [] as CodeType[];
      for (const whenValue of value) {
        const optErrMsg = \`Invalid Timing.repeat.when array item (\${String(whenValue)})\`;
        const element = new CodeType(parseFhirPrimitiveData(whenValue, fhirCodeSchema, optErrMsg));
        whenElements.push(element);
      }
      this.when = whenElements;
    } else {
      this.when = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`when\` array property.
   *
   * @param value - the \`when\` value
   * @returns this
   */
  public addWhen(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.when array item (\${String(value)})\`;
      const element = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
      this.initWhen();
      this.addWhenElement(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`when\` property exists and has a value; \`false\` otherwise
   */
  public hasWhen(): boolean {
    return this.hasWhenElement();
  }

  /**
   * Initialize the \`when\` property
   */
  private initWhen(): void {
    if (!this.hasWhen()) {
      this.when = [] as CodeType[];
    }
  }

  /**
   * @returns the \`offset\` property value as a UnsignedIntType object if defined; else an empty UnsignedIntType object
   */
  public getOffsetElement(): UnsignedIntType {
    return this.offset ?? new UnsignedIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`offset\` property.
   *
   * @param element - the \`offset\` value
   * @returns this
   */
  public setOffsetElement(element: UnsignedIntType | undefined): this {
    if (isDefined<UnsignedIntType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.offset; Provided element is not an instance of UnsignedIntType.\`;
      assertFhirType<UnsignedIntType>(element, UnsignedIntType, optErrMsg);
      this.offset = element;
    } else {
      this.offset = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`offset\` property exists and has a value; \`false\` otherwise
   */
  public hasOffsetElement(): boolean {
    return isDefined<UnsignedIntType>(this.offset) && !this.offset.isEmpty();
  }

  /**
   * @returns the \`offset\` property value as a fhirUnsignedInt if defined; else undefined
   */
  public getOffset(): fhirUnsignedInt | undefined {
    return this.offset?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`offset\` property.
   *
   * @param value - the \`offset\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setOffset(value: fhirUnsignedInt | undefined): this {
    if (isDefined<fhirUnsignedInt>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.offset (\${String(value)})\`;
      this.offset = new UnsignedIntType(parseFhirPrimitiveData(value, fhirUnsignedIntSchema, optErrMsg));
    } else {
      this.offset = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`offset\` property exists and has a value; \`false\` otherwise
   */
  public hasOffset(): boolean {
    return this.hasOffsetElement();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Timing.repeat';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.bounds,
      this.count,
      this.countMax,
      this.duration,
      this.durationMax,
      this.durationUnit,
      this.frequency,
      this.frequencyMax,
      this.period,
      this.periodMax,
      this.periodUnit,
      this.dayOfWeek,
      this.timeOfDay,
      this.when,
      this.offset,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): TimingRepeatComponent {
    const dest = new TimingRepeatComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: TimingRepeatComponent): void {
    super.copyValues(dest);
    dest.bounds = this.bounds?.copy();
    dest.count = this.count?.copy();
    dest.countMax = this.countMax?.copy();
    dest.duration = this.duration?.copy();
    dest.durationMax = this.durationMax?.copy();
    dest.durationUnit = this.durationUnit?.copy();
    dest.frequency = this.frequency?.copy();
    dest.frequencyMax = this.frequencyMax?.copy();
    dest.period = this.period?.copy();
    dest.periodMax = this.periodMax?.copy();
    dest.periodUnit = this.periodUnit?.copy();
    const dayOfWeekList = copyListValues<EnumCodeType>(this.dayOfWeek);
    dest.dayOfWeek = dayOfWeekList.length === 0 ? undefined : dayOfWeekList;
    const timeOfDayList = copyListValues<TimeType>(this.timeOfDay);
    dest.timeOfDay = timeOfDayList.length === 0 ? undefined : timeOfDayList;
    const whenList = copyListValues<CodeType>(this.when);
    dest.when = whenList.length === 0 ? undefined : whenList;
    dest.offset = this.offset?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasBounds()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getBounds()!, 'bounds', jsonObj);
    }

    if (this.hasCountElement()) {
      setFhirPrimitiveJson<fhirPositiveInt>(this.getCountElement(), 'count', jsonObj);
    }

    if (this.hasCountMaxElement()) {
      setFhirPrimitiveJson<fhirPositiveInt>(this.getCountMaxElement(), 'countMax', jsonObj);
    }

    if (this.hasDurationElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getDurationElement(), 'duration', jsonObj);
    }

    if (this.hasDurationMaxElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getDurationMaxElement(), 'durationMax', jsonObj);
    }

    if (this.hasDurationUnitElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getDurationUnitElement(), 'durationUnit', jsonObj);
    }

    if (this.hasFrequencyElement()) {
      setFhirPrimitiveJson<fhirPositiveInt>(this.getFrequencyElement(), 'frequency', jsonObj);
    }

    if (this.hasFrequencyMaxElement()) {
      setFhirPrimitiveJson<fhirPositiveInt>(this.getFrequencyMaxElement(), 'frequencyMax', jsonObj);
    }

    if (this.hasPeriodElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getPeriodElement(), 'period', jsonObj);
    }

    if (this.hasPeriodMaxElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getPeriodMaxElement(), 'periodMax', jsonObj);
    }

    if (this.hasPeriodUnitElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getPeriodUnitElement(), 'periodUnit', jsonObj);
    }

    if (this.hasDayOfWeekElement()) {
      setFhirPrimitiveListJson<fhirCode>(this.getDayOfWeekElement(), 'dayOfWeek', jsonObj);
    }

    if (this.hasTimeOfDay()) {
      setFhirPrimitiveListJson(this.getTimeOfDayElement(), 'timeOfDay', jsonObj);
    }

    if (this.hasWhen()) {
      setFhirPrimitiveListJson(this.getWhenElement(), 'when', jsonObj);
    }

    if (this.hasOffsetElement()) {
      setFhirPrimitiveJson<fhirUnsignedInt>(this.getOffsetElement(), 'offset', jsonObj);
    }

    return jsonObj;
  }
}
",
  "fileExtension": "ts",
  "filename": "Timing",
}
`;

exports[`src/generator-app unit test suite generator-app verify generated content should consistently create GeneratedContent[] 21`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/test-out",
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/utest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from by the FHIR Package Generator.
 * DO NOT make any modifications!
 * 
 * parsable-datatype-map.ts Module
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { DataType, ParsableDataType } from '@paq-ts-fhir/fhir-core';
import { CodeableConcept } from './CodeableConcept';
import { Coding } from './Coding';
import { ContactPoint } from './ContactPoint';
import { Duration } from './Duration';
import { Identifier } from './Identifier';
import { Meta } from './Meta';
import { Narrative } from './Narrative';
import { Period } from './Period';
import { Reference } from './Reference';
import { Signature } from './Signature';
import { Timing } from './Timing';

/**
 * PARSABLE_DATATYPE_MAP
 *
 * @remarks
 * Map of all parsable DataTypes where the key is the name of the DataType and the value is its ParsableDataType<DataType> class.
 *
 * @category Utilities: FHIR Parsers
 */
export const PARSABLE_DATATYPE_MAP = new Map<string, ParsableDataType<DataType>>();
PARSABLE_DATATYPE_MAP.set('CodeableConcept', CodeableConcept);
PARSABLE_DATATYPE_MAP.set('Coding', Coding);
PARSABLE_DATATYPE_MAP.set('ContactPoint', ContactPoint);
PARSABLE_DATATYPE_MAP.set('Duration', Duration);
PARSABLE_DATATYPE_MAP.set('Identifier', Identifier);
PARSABLE_DATATYPE_MAP.set('Meta', Meta);
PARSABLE_DATATYPE_MAP.set('Narrative', Narrative);
PARSABLE_DATATYPE_MAP.set('Period', Period);
PARSABLE_DATATYPE_MAP.set('Reference', Reference);
PARSABLE_DATATYPE_MAP.set('Signature', Signature);
PARSABLE_DATATYPE_MAP.set('Timing', Timing);
",
  "fileExtension": "ts",
  "filename": "parsable-datatype-map",
}
`;

exports[`src/generator-app unit test suite generator-app verify generated content should consistently create GeneratedContent[] 22`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/test-out",
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/utest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from by the FHIR Package Generator.
 * DO NOT make any modifications!
 * 
 * index.ts Module
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

export * from './CodeableConcept';
export * from './Coding';
export * from './ContactPoint';
export * from './Duration';
export * from './Identifier';
export * from './Meta';
export * from './Narrative';
export * from './Period';
export * from './Reference';
export * from './Signature';
export * from './Timing';
export * from './parsable-datatype-map';
",
  "fileExtension": "ts",
  "filename": "index",
}
`;

exports[`src/generator-app unit test suite generator-app verify generated content should consistently create GeneratedContent[] 23`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/test-out",
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/utest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "Resource",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * Bundle Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/Bundle
 * StructureDefinition.name: Bundle
 * StructureDefinition.description: A container for a collection of resources.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  BackboneElement,
  CodeType,
  DecimalType,
  EnumCodeType,
  FhirDataTypeParser,
  FhirError,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  InstantType,
  JSON,
  PrimitiveType,
  REQUIRED_PROPERTIES_DO_NOT_EXIST,
  REQUIRED_PROPERTIES_REQD_IN_JSON,
  StringType,
  UnsignedIntType,
  UriType,
  assertEnumCodeType,
  assertFhirType,
  assertFhirTypeList,
  assertIsDefined,
  constructorCodeValueAsEnumCodeType,
  copyListValues,
  fhirCode,
  fhirCodeSchema,
  fhirDecimal,
  fhirDecimalSchema,
  fhirInstant,
  fhirInstantSchema,
  fhirString,
  fhirStringSchema,
  fhirUnsignedInt,
  fhirUnsignedIntSchema,
  fhirUri,
  fhirUriSchema,
  getPrimitiveTypeJson,
  isDefined,
  isDefinedList,
  isElementEmpty,
  isEmpty,
  parseCodeType,
  parseDecimalType,
  parseFhirPrimitiveData,
  parseInstantType,
  parseStringType,
  parseUnsignedIntType,
  parseUriType,
  setFhirBackboneElementJson,
  setFhirBackboneElementListJson,
  setFhirComplexJson,
  setFhirPrimitiveJson,
} from '@paq-ts-fhir/fhir-core';
import {
  BundleTypeEnum,
  FhirResourceParser,
  FhirResourceType,
  HttpVerbEnum,
  Identifier,
  PARSABLE_DATATYPE_MAP,
  Resource,
  SearchEntryModeEnum,
  Signature,
  assertFhirResourceType,
  setFhirResourceJson,
} from '../index';

/**
 * Bundle Class
 *
 * @remarks
 * A container for a collection of resources.
 *
 * **FHIR Specification**
 * - **Short:** Contains a collection of resources
 * - **Definition:** A container for a collection of resources.
 * - **FHIR Version:** 4.0.1
 *
 * @category DataModel: Resource
 * @see [FHIR Bundle](http://hl7.org/fhir/StructureDefinition/Bundle)
 */
export class Bundle extends Resource implements IBase {
  constructor(type_: EnumCodeType | CodeType | null = null) {
    super();

    this.bundleTypeEnum = new BundleTypeEnum();

    this.type_ = constructorCodeValueAsEnumCodeType<BundleTypeEnum>(
      type_,
      BundleTypeEnum,
      this.bundleTypeEnum,
      '.type',
    );
  }

  /**
   * Parse the provided \`Bundle\` JSON to instantiate the Bundle data model.
   *
   * @param sourceJson - JSON representing FHIR \`Bundle\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Bundle
   * @returns Bundle data model or undefined for \`Bundle\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Bundle | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirResourceParser = new FhirResourceParser(PARSABLE_DATATYPE_MAP);
    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Bundle';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Bundle();
    fhirResourceParser.processResourceJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'identifier';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Identifier | undefined = fhirDataTypeParser.parser<Identifier>(Identifier, classJsonObj[fieldName]!, sourceField);
      instance.setIdentifier(datatype);
    }

    fieldName = 'type';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setTypeElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'timestamp';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: InstantType | undefined = parseInstantType(dtJson, dtSiblingJson);
      instance.setTimestampElement(datatype);
    }

    fieldName = 'total';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UnsignedIntType | undefined = parseUnsignedIntType(dtJson, dtSiblingJson);
      instance.setTotalElement(datatype);
    }

    fieldName = 'link';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const componentJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      componentJsonArray.forEach((componentJson: JSON.Value, idx) => {
        const component: BundleLinkComponent | undefined = BundleLinkComponent.parse(componentJson, \`\${sourceField}[\${String(idx)}]\`);
        if (component !== undefined) {
          instance.addLink(component);
        }
      });
    }

    fieldName = 'entry';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const componentJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      componentJsonArray.forEach((componentJson: JSON.Value, idx) => {
        const component: BundleEntryComponent | undefined = BundleEntryComponent.parse(componentJson, \`\${sourceField}[\${String(idx)}]\`);
        if (component !== undefined) {
          instance.addEntry(component);
        }
      });
    }

    fieldName = 'signature';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Signature | undefined = fhirDataTypeParser.parser<Signature>(Signature, classJsonObj[fieldName]!, sourceField);
      instance.setSignature(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Bundle.identifier Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Persistent identifier for the bundle
   * - **Definition:** A persistent identifier for the bundle that won\\'t change as a bundle is copied from server to server.
   * - **Comment:** Persistent identity generally only matters for batches of type Document, Message, and Collection. It would not normally be populated for search and history results and servers ignore Bundle.identifier when processing batches and transactions. For Documents  the .identifier SHALL be populated such that the .identifier is globally unique.
   * - **FHIR Type:** \`Identifier\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private identifier?: Identifier | undefined;

  /**
   * FHIR CodeSystem: BundleType
   *
   * @see {@link BundleTypeEnum }
   */
  private readonly bundleTypeEnum: BundleTypeEnum;

  /**
   * Bundle.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** document | message | transaction | transaction-response | batch | batch-response | history | searchset | collection
   * - **Definition:** Indicates the purpose of this bundle - how it is intended to be used.
   * - **Comment:** It\\'s possible to use a bundle for other purposes (e.g. a document can be accepted as a transaction). This is primarily defined so that there can be specific rules for some of the bundle types.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private type_: EnumCodeType | null;

  /**
   * Bundle.timestamp Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** When the bundle was assembled
   * - **Definition:** The date/time that the bundle was assembled - i.e. when the resources were placed in the bundle.
   * - **Comment:** For many bundles, the timestamp is equal to .meta.lastUpdated, because they are not stored (e.g. search results). When a bundle is placed in a persistent store, .meta.lastUpdated will be usually be changed by the server. When the bundle is a message, a middleware agent altering the message (even if not stored) SHOULD update .meta.lastUpdated. .timestamp is used to track the original time of the Bundle, and SHOULD be populated.   Usage: * document : the date the document was created. Note: the composition may predate the document, or be associated with multiple documents. The date of the composition - the authoring time - may be earlier than the document assembly time * message : the date that the content of the message was assembled. This date is not changed by middleware engines unless they add additional data that changes the meaning of the time of the message * history : the date that the history was assembled. This time would be used as the _since time to ask for subsequent updates * searchset : the time that the search set was assembled. Note that different pages MAY have different timestamps but need not. Having different timestamps does not imply that subsequent pages will represent or include changes made since the initial query * transaction | transaction-response | batch | batch-response | collection : no particular assigned meaning The timestamp value should be greater than the lastUpdated and other timestamps in the resources in the bundle, and it should be equal or earlier than the .meta.lastUpdated on the Bundle itself.
   * - **FHIR Type:** \`instant\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private timestamp?: InstantType | undefined;

  /**
   * Bundle.total Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** If search, the total number of matches
   * - **Definition:** If a set of search matches, this is the total number of entries of type \\'match\\' across all pages in the search.  It does not include search.mode = \\'include\\' or \\'outcome\\' entries and it does not provide a count of the number of entries in the Bundle.
   * - **Comment:** Only used if the bundle is a search result set. The total does not include resources such as OperationOutcome and included resources, only the total number of matching resources.
   * - **FHIR Type:** \`unsignedInt\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private total?: UnsignedIntType | undefined;

  /**
   * Bundle.link Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Links related to this Bundle
   * - **Definition:** A series of links that provide context to this bundle.
   * - **Comment:** Both Bundle.link and Bundle.entry.link are defined to support providing additional context when Bundles are used (e.g. [HATEOAS](http://en.wikipedia.org/wiki/HATEOAS)).  Bundle.entry.link corresponds to links found in the HTTP header if the resource in the entry was [read](https://hl7.org/fhir/http.html#read) directly. This specification defines some specific uses of Bundle.link for [searching](https://hl7.org/fhir/search.html#conformance) and [paging](https://hl7.org/fhir/http.html#paging), but no specific uses for Bundle.entry.link, and no defined function in a transaction - the meaning is implementation specific.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private link?: BundleLinkComponent[] | undefined;

  /**
   * Bundle.entry Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Entry in the bundle - will have a resource or information
   * - **Definition:** An entry in a bundle resource - will either contain a resource or information about a resource (transactions and history only).
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private entry?: BundleEntryComponent[] | undefined;

  /**
   * Bundle.signature Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Digital Signature
   * - **Definition:** Digital Signature - base64 encoded. XML-DSig or a JWT.
   * - **Comment:** The signature could be created by the "author" of the bundle or by the originating device.   Requirements around inclusion of a signature, verification of signatures and treatment of signed/non-signed bundles is implementation-environment specific.
   * - **Requirements:** A Signature holds an electronic representation of a signature and its supporting context in a FHIR accessible form. The signature may either be a cryptographic type (XML DigSig or a JWS), which is able to provide non-repudiation proof, or it may be a graphical image that represents a signature or a signature process. This element allows capturing signatures on documents, messages, transactions or even search responses, to support content-authentication, non-repudiation or other business cases. This is primarily relevant where the bundle may travel through multiple hops or via other mechanisms where HTTPS non-repudiation is insufficient.
   * - **FHIR Type:** \`Signature\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private signature?: Signature | undefined;


  /**
   * @returns the FHIR resource type as defined by the FHIR specification
   */
  public override resourceType(): FhirResourceType {
    return this.fhirType() as FhirResourceType;
  }

  /**
   * @returns the \`identifier\` property value as a Identifier object if defined; else an empty Identifier object
   */
  public getIdentifier(): Identifier {
    return this.identifier ?? new Identifier();
  }

  /**
   * Assigns the provided Identifier object value to the \`identifier\` property.
   *
   * @param value - the \`identifier\` object value
   * @returns this
   */
  public setIdentifier(value: Identifier | undefined): this {
    if (isDefined<Identifier>(value)) {
      const optErrMsg = \`Invalid Bundle.identifier; Provided element is not an instance of Identifier.\`;
      assertFhirType<Identifier>(value, Identifier, optErrMsg);
      this.identifier = value;
    } else {
      this.identifier = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`identifier\` property exists and has a value; \`false\` otherwise
   */
  public hasIdentifier(): boolean {
    return isDefined<Identifier>(this.identifier) && !this.identifier.isEmpty();
  }

  /**
   * @returns the \`type_\` property value as a EnumCodeType if defined; else null
   */
  public getTypeEnumType(): EnumCodeType | null {
    return this.type_;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`type_\` property.
   *
   * @param enumType - the \`type_\` value
   * @returns this
   */
  public setTypeEnumType(enumType: EnumCodeType): this {
    assertIsDefined<EnumCodeType>(enumType, \`Bundle.type is required\`);
    const errMsgPrefix = \`Invalid Bundle.type\`;
    assertEnumCodeType<BundleTypeEnum>(enumType, BundleTypeEnum, errMsgPrefix);
    this.type_ = enumType;
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasTypeEnumType(): boolean {
    return isDefined<EnumCodeType>(this.type_) && !this.type_.isEmpty() && this.type_.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`type_\` property value as a CodeType if defined; else null
   */
  public getTypeElement(): CodeType | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_ as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`type_\` property.
   *
   * @param element - the \`type_\` value
   * @returns this
   */
  public setTypeElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, \`Bundle.type is required\`);
    const optErrMsg = \`Invalid Bundle.type; Provided value is not an instance of CodeType.\`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.type_ = new EnumCodeType(element, this.bundleTypeEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasTypeElement(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the \`type_\` property value as a fhirCode if defined; else null
   */
  public getType(): fhirCode | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`type_\` property.
   *
   * @param value - the \`type_\` value
   * @returns this
   */
  public setType(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, \`Bundle.type is required\`);
    const optErrMsg = \`Invalid Bundle.type (\${String(value)})\`;
    this.type_ = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.bundleTypeEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasType(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the \`timestamp\` property value as a InstantType object if defined; else an empty InstantType object
   */
  public getTimestampElement(): InstantType {
    return this.timestamp ?? new InstantType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`timestamp\` property.
   *
   * @param element - the \`timestamp\` value
   * @returns this
   */
  public setTimestampElement(element: InstantType | undefined): this {
    if (isDefined<InstantType>(element)) {
      const optErrMsg = \`Invalid Bundle.timestamp; Provided element is not an instance of InstantType.\`;
      assertFhirType<InstantType>(element, InstantType, optErrMsg);
      this.timestamp = element;
    } else {
      this.timestamp = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`timestamp\` property exists and has a value; \`false\` otherwise
   */
  public hasTimestampElement(): boolean {
    return isDefined<InstantType>(this.timestamp) && !this.timestamp.isEmpty();
  }

  /**
   * @returns the \`timestamp\` property value as a fhirInstant if defined; else undefined
   */
  public getTimestamp(): fhirInstant | undefined {
    return this.timestamp?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`timestamp\` property.
   *
   * @param value - the \`timestamp\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setTimestamp(value: fhirInstant | undefined): this {
    if (isDefined<fhirInstant>(value)) {
      const optErrMsg = \`Invalid Bundle.timestamp (\${String(value)})\`;
      this.timestamp = new InstantType(parseFhirPrimitiveData(value, fhirInstantSchema, optErrMsg));
    } else {
      this.timestamp = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`timestamp\` property exists and has a value; \`false\` otherwise
   */
  public hasTimestamp(): boolean {
    return this.hasTimestampElement();
  }

  /**
   * @returns the \`total\` property value as a UnsignedIntType object if defined; else an empty UnsignedIntType object
   */
  public getTotalElement(): UnsignedIntType {
    return this.total ?? new UnsignedIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`total\` property.
   *
   * @param element - the \`total\` value
   * @returns this
   */
  public setTotalElement(element: UnsignedIntType | undefined): this {
    if (isDefined<UnsignedIntType>(element)) {
      const optErrMsg = \`Invalid Bundle.total; Provided element is not an instance of UnsignedIntType.\`;
      assertFhirType<UnsignedIntType>(element, UnsignedIntType, optErrMsg);
      this.total = element;
    } else {
      this.total = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`total\` property exists and has a value; \`false\` otherwise
   */
  public hasTotalElement(): boolean {
    return isDefined<UnsignedIntType>(this.total) && !this.total.isEmpty();
  }

  /**
   * @returns the \`total\` property value as a fhirUnsignedInt if defined; else undefined
   */
  public getTotal(): fhirUnsignedInt | undefined {
    return this.total?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`total\` property.
   *
   * @param value - the \`total\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setTotal(value: fhirUnsignedInt | undefined): this {
    if (isDefined<fhirUnsignedInt>(value)) {
      const optErrMsg = \`Invalid Bundle.total (\${String(value)})\`;
      this.total = new UnsignedIntType(parseFhirPrimitiveData(value, fhirUnsignedIntSchema, optErrMsg));
    } else {
      this.total = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`total\` property exists and has a value; \`false\` otherwise
   */
  public hasTotal(): boolean {
    return this.hasTotalElement();
  }

  /**
   * @returns the \`link\` property value as a BundleLinkComponent array
   */
  public getLink(): BundleLinkComponent[] {
    return this.link ?? ([] as BundleLinkComponent[]);
  }

  /**
   * Assigns the provided BundleLinkComponent array value to the \`link\` property.
   *
   * @param value - the \`link\` array value
   * @returns this
   */
  public setLink(value: BundleLinkComponent[] | undefined): this {
    if (isDefinedList<BundleLinkComponent>(value)) {
      const optErrMsg = \`Invalid Bundle.link; Provided value array has an element that is not an instance of BundleLinkComponent.\`;
      assertFhirTypeList<BundleLinkComponent>(value, BundleLinkComponent, optErrMsg);
      this.link = value;
    } else {
      this.link = undefined;
    }
    return this;
  }

  /**
   * Add the provided BundleLinkComponent value to the \`link\` array property.
   *
   * @param value - the \`link\` value
   * @returns this
   */
  public addLink(value: BundleLinkComponent | undefined): this {
    if (isDefined<BundleLinkComponent>(value)) {
      const optErrMsg = \`Invalid Bundle.link; Provided element is not an instance of BundleLinkComponent.\`;
      assertFhirType<BundleLinkComponent>(value, BundleLinkComponent, optErrMsg);
      this.initLink();
      this.link?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`link\` property exists and has a value; \`false\` otherwise
   */
  public hasLink(): boolean {
    return isDefinedList<BundleLinkComponent>(this.link) && this.link.some((item: BundleLinkComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`link\` property
   */
  private initLink(): void {
    if(!this.hasLink()) {
      this.link = [] as BundleLinkComponent[];
    }
  }

  /**
   * @returns the \`entry\` property value as a BundleEntryComponent array
   */
  public getEntry(): BundleEntryComponent[] {
    return this.entry ?? ([] as BundleEntryComponent[]);
  }

  /**
   * Assigns the provided BundleEntryComponent array value to the \`entry\` property.
   *
   * @param value - the \`entry\` array value
   * @returns this
   */
  public setEntry(value: BundleEntryComponent[] | undefined): this {
    if (isDefinedList<BundleEntryComponent>(value)) {
      const optErrMsg = \`Invalid Bundle.entry; Provided value array has an element that is not an instance of BundleEntryComponent.\`;
      assertFhirTypeList<BundleEntryComponent>(value, BundleEntryComponent, optErrMsg);
      this.entry = value;
    } else {
      this.entry = undefined;
    }
    return this;
  }

  /**
   * Add the provided BundleEntryComponent value to the \`entry\` array property.
   *
   * @param value - the \`entry\` value
   * @returns this
   */
  public addEntry(value: BundleEntryComponent | undefined): this {
    if (isDefined<BundleEntryComponent>(value)) {
      const optErrMsg = \`Invalid Bundle.entry; Provided element is not an instance of BundleEntryComponent.\`;
      assertFhirType<BundleEntryComponent>(value, BundleEntryComponent, optErrMsg);
      this.initEntry();
      this.entry?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`entry\` property exists and has a value; \`false\` otherwise
   */
  public hasEntry(): boolean {
    return isDefinedList<BundleEntryComponent>(this.entry) && this.entry.some((item: BundleEntryComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`entry\` property
   */
  private initEntry(): void {
    if(!this.hasEntry()) {
      this.entry = [] as BundleEntryComponent[];
    }
  }

  /**
   * @returns the \`signature\` property value as a Signature object if defined; else an empty Signature object
   */
  public getSignature(): Signature {
    return this.signature ?? new Signature();
  }

  /**
   * Assigns the provided Signature object value to the \`signature\` property.
   *
   * @param value - the \`signature\` object value
   * @returns this
   */
  public setSignature(value: Signature | undefined): this {
    if (isDefined<Signature>(value)) {
      const optErrMsg = \`Invalid Bundle.signature; Provided element is not an instance of Signature.\`;
      assertFhirType<Signature>(value, Signature, optErrMsg);
      this.signature = value;
    } else {
      this.signature = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`signature\` property exists and has a value; \`false\` otherwise
   */
  public hasSignature(): boolean {
    return isDefined<Signature>(this.signature) && !this.signature.isEmpty();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Bundle';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.identifier,
      this.type_,
      this.timestamp,
      this.total,
      this.link,
      this.entry,
      this.signature,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Bundle {
    const dest = new Bundle();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Bundle): void {
    super.copyValues(dest);
    dest.identifier = this.identifier?.copy();
    dest.type_ = this.type_ ? this.type_.copy() : null;
    dest.timestamp = this.timestamp?.copy();
    dest.total = this.total?.copy();
    const linkList = copyListValues<BundleLinkComponent>(this.link);
    dest.link = linkList.length === 0 ? undefined : linkList;
    const entryList = copyListValues<BundleEntryComponent>(this.entry);
    dest.entry = entryList.length === 0 ? undefined : entryList;
    dest.signature = this.signature?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasIdentifier()) {
      setFhirComplexJson(this.getIdentifier(), 'identifier', jsonObj);
    }

    if (this.hasTypeElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getTypeElement()!, 'type', jsonObj);
    } else {
      missingReqdProperties.push(\`Bundle.type\`);
    }

    if (this.hasTimestampElement()) {
      setFhirPrimitiveJson<fhirInstant>(this.getTimestampElement(), 'timestamp', jsonObj);
    }

    if (this.hasTotalElement()) {
      setFhirPrimitiveJson<fhirUnsignedInt>(this.getTotalElement(), 'total', jsonObj);
    }

    if (this.hasLink()) {
      setFhirBackboneElementListJson(this.getLink(), 'link', jsonObj);
    }

    if (this.hasEntry()) {
      setFhirBackboneElementListJson(this.getEntry(), 'entry', jsonObj);
    }

    if (this.hasSignature()) {
      setFhirComplexJson(this.getSignature(), 'signature', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}


/**
 * BundleLinkComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Links related to this Bundle
 * - **Definition:** A series of links that provide context to this bundle.
 * - **Comment:** Both Bundle.link and Bundle.entry.link are defined to support providing additional context when Bundles are used (e.g. [HATEOAS](http://en.wikipedia.org/wiki/HATEOAS)).  Bundle.entry.link corresponds to links found in the HTTP header if the resource in the entry was [read](https://hl7.org/fhir/http.html#read) directly. This specification defines some specific uses of Bundle.link for [searching](https://hl7.org/fhir/search.html#conformance) and [paging](https://hl7.org/fhir/http.html#paging), but no specific uses for Bundle.entry.link, and no defined function in a transaction - the meaning is implementation specific.
 *
 * @category DataModel: Resource
 * @see [FHIR Bundle](http://hl7.org/fhir/StructureDefinition/Bundle)
 */
export class BundleLinkComponent extends BackboneElement {
  constructor(relation: StringType | fhirString | null = null, url: UriType | fhirUri | null = null) {
    super();

    this.relation = null;
    if (isDefined<StringType | fhirString>(relation)) {
      if (relation instanceof PrimitiveType) {
        this.setRelationElement(relation);
      } else {
        this.setRelation(relation);
      }
    }

    this.url = null;
    if (isDefined<UriType | fhirUri>(url)) {
      if (url instanceof PrimitiveType) {
        this.setUrlElement(url);
      } else {
        this.setUrl(url);
      }
    }
  }

  /**
   * Parse the provided \`BundleLinkComponent\` JSON to instantiate the BundleLinkComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`BundleLinkComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to BundleLinkComponent
   * @returns BundleLinkComponent data model or undefined for \`BundleLinkComponent\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): BundleLinkComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'BundleLinkComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new BundleLinkComponent();
    fhirDataTypeParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'relation';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setRelationElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'url';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = parseUriType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setUrlElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Bundle.link.relation Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** See http://www.iana.org/assignments/link-relations/link-relations.xhtml#link-relations-1
   * - **Definition:** A name which details the functional use for this link - see [http://www.iana.org/assignments/link-relations/link-relations.xhtml#link-relations-1](http://www.iana.org/assignments/link-relations/link-relations.xhtml#link-relations-1).
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private relation: StringType | null;

  /**
   * Bundle.link.url Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Reference details for the link
   * - **Definition:** The reference details for the link.
   * - **FHIR Type:** \`uri\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private url: UriType | null;


  /**
   * @returns the \`relation\` property value as a StringType object if defined; else null
   */
  public getRelationElement(): StringType | null {
    return this.relation;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`relation\` property.
   *
   * @param element - the \`relation\` value
   * @returns this
   */
  public setRelationElement(element: StringType): this {
    assertIsDefined<StringType>(element, \`Bundle.link.relation is required\`);
    const optErrMsg = \`Invalid Bundle.link.relation; Provided value is not an instance of StringType.\`;
    assertFhirType<StringType>(element, StringType, optErrMsg);
    this.relation = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`relation\` property exists and has a value; \`false\` otherwise
   */
  public hasRelationElement(): boolean {
    return isDefined<StringType>(this.relation) && !this.relation.isEmpty();
  }

  /**
   * @returns the \`relation\` property value as a fhirString if defined; else null
   */
  public getRelation(): fhirString | null {
    if (this.relation?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.relation.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`relation\` property.
   *
   * @param value - the \`relation\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setRelation(value: fhirString): this {
    assertIsDefined<fhirString>(value, \`Bundle.link.relation is required\`);
    const optErrMsg = \`Invalid Bundle.link.relation (\${String(value)})\`;
    this.relation = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`relation\` property exists and has a value; \`false\` otherwise
   */
  public hasRelation(): boolean {
    return this.hasRelationElement();
  }

  /**
   * @returns the \`url\` property value as a UriType object if defined; else null
   */
  public getUrlElement(): UriType | null {
    return this.url;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`url\` property.
   *
   * @param element - the \`url\` value
   * @returns this
   */
  public setUrlElement(element: UriType): this {
    assertIsDefined<UriType>(element, \`Bundle.link.url is required\`);
    const optErrMsg = \`Invalid Bundle.link.url; Provided value is not an instance of UriType.\`;
    assertFhirType<UriType>(element, UriType, optErrMsg);
    this.url = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`url\` property exists and has a value; \`false\` otherwise
   */
  public hasUrlElement(): boolean {
    return isDefined<UriType>(this.url) && !this.url.isEmpty();
  }

  /**
   * @returns the \`url\` property value as a fhirUri if defined; else null
   */
  public getUrl(): fhirUri | null {
    if (this.url?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.url.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`url\` property.
   *
   * @param value - the \`url\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setUrl(value: fhirUri): this {
    assertIsDefined<fhirUri>(value, \`Bundle.link.url is required\`);
    const optErrMsg = \`Invalid Bundle.link.url (\${String(value)})\`;
    this.url = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`url\` property exists and has a value; \`false\` otherwise
   */
  public hasUrl(): boolean {
    return this.hasUrlElement();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Bundle.link';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.relation,
      this.url,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): BundleLinkComponent {
    const dest = new BundleLinkComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: BundleLinkComponent): void {
    super.copyValues(dest);
    dest.relation = this.relation ? this.relation.copy() : null;
    dest.url = this.url ? this.url.copy() : null;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasRelationElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirString>(this.getRelationElement()!, 'relation', jsonObj);
    } else {
      missingReqdProperties.push(\`Bundle.link.relation\`);
    }

    if (this.hasUrlElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirUri>(this.getUrlElement()!, 'url', jsonObj);
    } else {
      missingReqdProperties.push(\`Bundle.link.url\`);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

/**
 * BundleEntryComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Entry in the bundle - will have a resource or information
 * - **Definition:** An entry in a bundle resource - will either contain a resource or information about a resource (transactions and history only).
 *
 * @category DataModel: Resource
 * @see [FHIR Bundle](http://hl7.org/fhir/StructureDefinition/Bundle)
 */
export class BundleEntryComponent extends BackboneElement {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`BundleEntryComponent\` JSON to instantiate the BundleEntryComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`BundleEntryComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to BundleEntryComponent
   * @returns BundleEntryComponent data model or undefined for \`BundleEntryComponent\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): BundleEntryComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirResourceParser = new FhirResourceParser(PARSABLE_DATATYPE_MAP);
    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'BundleEntryComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new BundleEntryComponent();
    fhirDataTypeParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    

    fieldName = 'link';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const componentJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      componentJsonArray.forEach((componentJson: JSON.Value, idx) => {
        const component: BundleLinkComponent | undefined = BundleLinkComponent.parse(componentJson, \`\${sourceField}[\${String(idx)}]\`);
        if (component !== undefined) {
          instance.addLink(component);
        }
      });
    }

    fieldName = 'fullUrl';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = parseUriType(dtJson, dtSiblingJson);
      instance.setFullUrlElement(datatype);
    }

    fieldName = 'resource';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      const resource: Resource | undefined = fhirResourceParser.parseInlineResource(classJsonObj[fieldName], sourceField);
      instance.setResource(resource);
    }

    fieldName = 'search';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const component: BundleEntrySearchComponent | undefined = BundleEntrySearchComponent.parse(classJsonObj[fieldName]!, sourceField);
      instance.setSearch(component);
    }

    fieldName = 'request';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const component: BundleEntryRequestComponent | undefined = BundleEntryRequestComponent.parse(classJsonObj[fieldName]!, sourceField);
      instance.setRequest(component);
    }

    fieldName = 'response';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const component: BundleEntryResponseComponent | undefined = BundleEntryResponseComponent.parse(classJsonObj[fieldName]!, sourceField);
      instance.setResponse(component);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Bundle.entry.link Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Links related to this entry
   * - **Definition:** A series of links that provide context to this entry.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private link?: BundleLinkComponent[] | undefined;

  /**
   * Bundle.entry.fullUrl Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** URI for resource (Absolute URL server address or URI for UUID/OID)
   * - **Definition:** The Absolute URL for the resource.  The fullUrl SHALL NOT disagree with the id in the resource - i.e. if the fullUrl is not a urn:uuid, the URL shall be version-independent URL consistent with the Resource.id. The fullUrl is a version independent reference to the resource. The fullUrl element SHALL have a value except that:  * fullUrl can be empty on a POST (although it does not need to when specifying a temporary id for reference in the bundle) * Results from operations might involve resources that are not identified.
   * - **Comment:** fullUrl might not be [unique in the context of a resource](https://hl7.org/fhir/bundle.html#bundle-unique). Note that since [FHIR resources do not need to be served through the FHIR API](https://hl7.org/fhir/references.html), the fullURL might be a URN or an absolute URL that does not end with the logical id of the resource (Resource.id). However, but if the fullUrl does look like a RESTful server URL (e.g. meets the [regex](https://hl7.org/fhir/references.html#regex), then the \\'id\\' portion of the fullUrl SHALL end with the Resource.id. Note that the fullUrl is not the same as the canonical URL - it\\'s an absolute url for an endpoint serving the resource (these will happen to have the same value on the canonical server for the resource with the canonical URL).
   * - **FHIR Type:** \`uri\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private fullUrl?: UriType | undefined;

  /**
   * Bundle.entry.resource Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A resource in the bundle
   * - **Definition:** The Resource for the entry. The purpose/meaning of the resource is determined by the Bundle.type.
   * - **FHIR Type:** \`Resource\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private resource?: Resource | undefined;

  /**
   * Bundle.entry.search Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Search related information
   * - **Definition:** Information about the search process that lead to the creation of this entry.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private search?: BundleEntrySearchComponent | undefined;

  /**
   * Bundle.entry.request Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Additional execution information (transaction/batch/history)
   * - **Definition:** Additional information about how this entry should be processed as part of a transaction or batch.  For history, it shows how the entry was processed to create the version contained in the entry.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private request?: BundleEntryRequestComponent | undefined;

  /**
   * Bundle.entry.response Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Results of execution (transaction/batch/history)
   * - **Definition:** Indicates the results of processing the corresponding \\'request\\' entry in the batch or transaction being responded to or what the results of an operation where when returning history.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private response?: BundleEntryResponseComponent | undefined;


  /**
   * @returns the \`link\` property value as a BundleLinkComponent array
   */
  public getLink(): BundleLinkComponent[] {
    return this.link ?? ([] as BundleLinkComponent[]);
  }

  /**
   * Assigns the provided BundleLinkComponent array value to the \`link\` property.
   *
   * @param value - the \`link\` array value
   * @returns this
   */
  public setLink(value: BundleLinkComponent[] | undefined): this {
    if (isDefinedList<BundleLinkComponent>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.link; Provided value array has an element that is not an instance of BundleLinkComponent.\`;
      assertFhirTypeList<BundleLinkComponent>(value, BundleLinkComponent, optErrMsg);
      this.link = value;
    } else {
      this.link = undefined;
    }
    return this;
  }

  /**
   * Add the provided BundleLinkComponent value to the \`link\` array property.
   *
   * @param value - the \`link\` value
   * @returns this
   */
  public addLink(value: BundleLinkComponent | undefined): this {
    if (isDefined<BundleLinkComponent>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.link; Provided element is not an instance of BundleLinkComponent.\`;
      assertFhirType<BundleLinkComponent>(value, BundleLinkComponent, optErrMsg);
      this.initLink();
      this.link?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`link\` property exists and has a value; \`false\` otherwise
   */
  public hasLink(): boolean {
    return isDefinedList<BundleLinkComponent>(this.link) && this.link.some((item: BundleLinkComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`link\` property
   */
  private initLink(): void {
    if(!this.hasLink()) {
      this.link = [] as BundleLinkComponent[];
    }
  }

  /**
   * @returns the \`fullUrl\` property value as a UriType object if defined; else an empty UriType object
   */
  public getFullUrlElement(): UriType {
    return this.fullUrl ?? new UriType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`fullUrl\` property.
   *
   * @param element - the \`fullUrl\` value
   * @returns this
   */
  public setFullUrlElement(element: UriType | undefined): this {
    if (isDefined<UriType>(element)) {
      const optErrMsg = \`Invalid Bundle.entry.fullUrl; Provided element is not an instance of UriType.\`;
      assertFhirType<UriType>(element, UriType, optErrMsg);
      this.fullUrl = element;
    } else {
      this.fullUrl = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`fullUrl\` property exists and has a value; \`false\` otherwise
   */
  public hasFullUrlElement(): boolean {
    return isDefined<UriType>(this.fullUrl) && !this.fullUrl.isEmpty();
  }

  /**
   * @returns the \`fullUrl\` property value as a fhirUri if defined; else undefined
   */
  public getFullUrl(): fhirUri | undefined {
    return this.fullUrl?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`fullUrl\` property.
   *
   * @param value - the \`fullUrl\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setFullUrl(value: fhirUri | undefined): this {
    if (isDefined<fhirUri>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.fullUrl (\${String(value)})\`;
      this.fullUrl = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    } else {
      this.fullUrl = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`fullUrl\` property exists and has a value; \`false\` otherwise
   */
  public hasFullUrl(): boolean {
    return this.hasFullUrlElement();
  }

  /**
   * @returns the \`resource\` property value as a Resource object if defined; else undefined
   */
  public getResource(): Resource | undefined {
    return this.resource;
  }

  /**
   * Assigns the provided Resource object value to the \`resource\` property.
   *
   * @param value - the \`resource\` object value
   * @returns this
   */
  public setResource(value: Resource | undefined): this {
    if (isDefined<Resource>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.resource; Provided element is not an instance of Resource.\`;
      assertFhirResourceType(value, optErrMsg);
      this.resource = value;
    } else {
      this.resource = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`resource\` property exists and has a value; \`false\` otherwise
   */
  public hasResource(): boolean {
    return isDefined<Resource>(this.resource) && !this.resource.isEmpty();
  }

  /**
   * @returns the \`search\` property value as a BundleEntrySearchComponent object if defined; else an empty BundleEntrySearchComponent object
   */
  public getSearch(): BundleEntrySearchComponent {
    return this.search ?? new BundleEntrySearchComponent();
  }

  /**
   * Assigns the provided Search object value to the \`search\` property.
   *
   * @param value - the \`search\` object value
   * @returns this
   */
  public setSearch(value: BundleEntrySearchComponent | undefined): this {
    if (isDefined<BundleEntrySearchComponent>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.search; Provided element is not an instance of BundleEntrySearchComponent.\`;
      assertFhirType<BundleEntrySearchComponent>(value, BundleEntrySearchComponent, optErrMsg);
      this.search = value;
    } else {
      this.search = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`search\` property exists and has a value; \`false\` otherwise
   */
  public hasSearch(): boolean {
    return isDefined<BundleEntrySearchComponent>(this.search) && !this.search.isEmpty();
  }

  /**
   * @returns the \`request\` property value as a BundleEntryRequestComponent object if defined; else an empty BundleEntryRequestComponent object
   */
  public getRequest(): BundleEntryRequestComponent {
    return this.request ?? new BundleEntryRequestComponent();
  }

  /**
   * Assigns the provided Request object value to the \`request\` property.
   *
   * @param value - the \`request\` object value
   * @returns this
   */
  public setRequest(value: BundleEntryRequestComponent | undefined): this {
    if (isDefined<BundleEntryRequestComponent>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.request; Provided element is not an instance of BundleEntryRequestComponent.\`;
      assertFhirType<BundleEntryRequestComponent>(value, BundleEntryRequestComponent, optErrMsg);
      this.request = value;
    } else {
      this.request = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`request\` property exists and has a value; \`false\` otherwise
   */
  public hasRequest(): boolean {
    return isDefined<BundleEntryRequestComponent>(this.request) && !this.request.isEmpty();
  }

  /**
   * @returns the \`response\` property value as a BundleEntryResponseComponent object if defined; else an empty BundleEntryResponseComponent object
   */
  public getResponse(): BundleEntryResponseComponent {
    return this.response ?? new BundleEntryResponseComponent();
  }

  /**
   * Assigns the provided Response object value to the \`response\` property.
   *
   * @param value - the \`response\` object value
   * @returns this
   */
  public setResponse(value: BundleEntryResponseComponent | undefined): this {
    if (isDefined<BundleEntryResponseComponent>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.response; Provided element is not an instance of BundleEntryResponseComponent.\`;
      assertFhirType<BundleEntryResponseComponent>(value, BundleEntryResponseComponent, optErrMsg);
      this.response = value;
    } else {
      this.response = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`response\` property exists and has a value; \`false\` otherwise
   */
  public hasResponse(): boolean {
    return isDefined<BundleEntryResponseComponent>(this.response) && !this.response.isEmpty();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Bundle.entry';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.link,
      this.fullUrl,
      this.resource,
      this.search,
      this.request,
      this.response,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): BundleEntryComponent {
    const dest = new BundleEntryComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: BundleEntryComponent): void {
    super.copyValues(dest);
    const linkList = copyListValues<BundleLinkComponent>(this.link);
    dest.link = linkList.length === 0 ? undefined : linkList;
    dest.fullUrl = this.fullUrl?.copy();
    dest.resource = this.resource?.copy();
    dest.search = this.search?.copy();
    dest.request = this.request?.copy();
    dest.response = this.response?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasLink()) {
      setFhirBackboneElementListJson(this.getLink(), 'link', jsonObj);
    }

    if (this.hasFullUrlElement()) {
      setFhirPrimitiveJson<fhirUri>(this.getFullUrlElement(), 'fullUrl', jsonObj);
    }

    if (this.hasResource()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirResourceJson(this.getResource()!, 'resource', jsonObj);
    }

    if (this.hasSearch()) {
      setFhirBackboneElementJson(this.getSearch(), 'search', jsonObj);
    }

    if (this.hasRequest()) {
      setFhirBackboneElementJson(this.getRequest(), 'request', jsonObj);
    }

    if (this.hasResponse()) {
      setFhirBackboneElementJson(this.getResponse(), 'response', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * BundleEntrySearchComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Search related information
 * - **Definition:** Information about the search process that lead to the creation of this entry.
 *
 * @category DataModel: Resource
 * @see [FHIR Bundle](http://hl7.org/fhir/StructureDefinition/Bundle)
 */
export class BundleEntrySearchComponent extends BackboneElement {
  constructor() {
    super();

    this.searchEntryModeEnum = new SearchEntryModeEnum();
  }

  /**
   * Parse the provided \`BundleEntrySearchComponent\` JSON to instantiate the BundleEntrySearchComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`BundleEntrySearchComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to BundleEntrySearchComponent
   * @returns BundleEntrySearchComponent data model or undefined for \`BundleEntrySearchComponent\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): BundleEntrySearchComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'BundleEntrySearchComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new BundleEntrySearchComponent();
    fhirDataTypeParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'mode';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      instance.setModeElement(datatype);
    }

    fieldName = 'score';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = parseDecimalType(dtJson, dtSiblingJson);
      instance.setScoreElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: SearchEntryMode
   *
   * @see {@link SearchEntryModeEnum }
   */
  private readonly searchEntryModeEnum: SearchEntryModeEnum;

  /**
   * Bundle.entry.search.mode Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** match | include | outcome - why this is in the result set
   * - **Definition:** Why this entry is in the result set - whether it\\'s included as a match or because of an _include requirement, or to convey information or warning information about the search process.
   * - **Comment:** There is only one mode. In some corner cases, a resource may be included because it is both a match and an include. In these circumstances, \\'match\\' takes precedence.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private mode?: EnumCodeType | undefined;

  /**
   * Bundle.entry.search.score Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Search ranking (between 0 and 1)
   * - **Definition:** When searching, the server\\'s search ranking score for the entry.
   * - **Comment:** Servers are not required to return a ranking score. 1 is most relevant, and 0 is least relevant. Often, search results are sorted by score, but the client may specify a different sort order. See [Patient Match](https://hl7.org/fhir/patient-operation-match.html) for the EMPI search which relates to this element.
   * - **FHIR Type:** \`decimal\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private score?: DecimalType | undefined;


  /**
   * @returns the \`mode\` property value as a EnumCodeType if defined; else undefined
   */
  public getModeEnumType(): EnumCodeType | undefined {
    return this.mode;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`mode\` property.
   *
   * @param enumType - the \`mode\` value
   * @returns this
   */
  public setModeEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid Bundle.entry.search.mode';
      assertEnumCodeType<SearchEntryModeEnum>(enumType, SearchEntryModeEnum, errMsgPrefix);
      this.mode = enumType;
    } else {
      this.mode = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`mode\` property exists and has a value; \`false\` otherwise
   */
  public hasModeEnumType(): boolean {
    return isDefined<EnumCodeType>(this.mode) && !this.mode.isEmpty() && this.mode.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`mode\` property value as a CodeType if defined; else undefined
   */
  public getModeElement(): CodeType | undefined {
    if (this.mode === undefined) {
      return undefined;
    }
    return this.mode as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`mode\` property.
   *
   * @param element - the \`mode\` value
   * @returns this
   */
  public setModeElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Bundle.entry.search.mode; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.mode = new EnumCodeType(element, this.searchEntryModeEnum);
    } else {
      this.mode = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`mode\` property exists and has a value; \`false\` otherwise
   */
  public hasModeElement(): boolean {
    return this.hasModeEnumType();
  }

  /**
   * @returns the \`mode\` property value as a fhirCode if defined; else undefined
   */
  public getMode(): fhirCode | undefined {
    if (this.mode === undefined) {
      return undefined;
    }
    return this.mode.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`mode\` property.
   *
   * @param value - the \`mode\` value
   * @returns this
   */
  public setMode(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.search.mode; Provided value is not an instance of fhirCode.\`;
      this.mode = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.searchEntryModeEnum);
    } else {
      this.mode = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`mode\` property exists and has a value; \`false\` otherwise
   */
  public hasMode(): boolean {
    return this.hasModeEnumType();
  }

  /**
   * @returns the \`score\` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getScoreElement(): DecimalType {
    return this.score ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`score\` property.
   *
   * @param element - the \`score\` value
   * @returns this
   */
  public setScoreElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = \`Invalid Bundle.entry.search.score; Provided element is not an instance of DecimalType.\`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.score = element;
    } else {
      this.score = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`score\` property exists and has a value; \`false\` otherwise
   */
  public hasScoreElement(): boolean {
    return isDefined<DecimalType>(this.score) && !this.score.isEmpty();
  }

  /**
   * @returns the \`score\` property value as a fhirDecimal if defined; else undefined
   */
  public getScore(): fhirDecimal | undefined {
    return this.score?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`score\` property.
   *
   * @param value - the \`score\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setScore(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.search.score (\${String(value)})\`;
      this.score = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.score = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`score\` property exists and has a value; \`false\` otherwise
   */
  public hasScore(): boolean {
    return this.hasScoreElement();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Bundle.entry.search';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.mode,
      this.score,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): BundleEntrySearchComponent {
    const dest = new BundleEntrySearchComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: BundleEntrySearchComponent): void {
    super.copyValues(dest);
    dest.mode = this.mode?.copy();
    dest.score = this.score?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasModeElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getModeElement()!, 'mode', jsonObj);
    }

    if (this.hasScoreElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getScoreElement(), 'score', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * BundleEntryRequestComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Additional execution information (transaction/batch/history)
 * - **Definition:** Additional information about how this entry should be processed as part of a transaction or batch.  For history, it shows how the entry was processed to create the version contained in the entry.
 *
 * @category DataModel: Resource
 * @see [FHIR Bundle](http://hl7.org/fhir/StructureDefinition/Bundle)
 */
export class BundleEntryRequestComponent extends BackboneElement {
  constructor(method: EnumCodeType | CodeType | null = null, url: UriType | fhirUri | null = null) {
    super();

    this.httpVerbEnum = new HttpVerbEnum();

    this.method = constructorCodeValueAsEnumCodeType<HttpVerbEnum>(
      method,
      HttpVerbEnum,
      this.httpVerbEnum,
      '.method',
    );

    this.url = null;
    if (isDefined<UriType | fhirUri>(url)) {
      if (url instanceof PrimitiveType) {
        this.setUrlElement(url);
      } else {
        this.setUrl(url);
      }
    }
  }

  /**
   * Parse the provided \`BundleEntryRequestComponent\` JSON to instantiate the BundleEntryRequestComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`BundleEntryRequestComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to BundleEntryRequestComponent
   * @returns BundleEntryRequestComponent data model or undefined for \`BundleEntryRequestComponent\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): BundleEntryRequestComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'BundleEntryRequestComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new BundleEntryRequestComponent();
    fhirDataTypeParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'method';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setMethodElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'url';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = parseUriType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setUrlElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'ifNoneMatch';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setIfNoneMatchElement(datatype);
    }

    fieldName = 'ifModifiedSince';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: InstantType | undefined = parseInstantType(dtJson, dtSiblingJson);
      instance.setIfModifiedSinceElement(datatype);
    }

    fieldName = 'ifMatch';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setIfMatchElement(datatype);
    }

    fieldName = 'ifNoneExist';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setIfNoneExistElement(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: HttpVerb
   *
   * @see {@link HttpVerbEnum }
   */
  private readonly httpVerbEnum: HttpVerbEnum;

  /**
   * Bundle.entry.request.method Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** GET | HEAD | POST | PUT | DELETE | PATCH
   * - **Definition:** In a transaction or batch, this is the HTTP action to be executed for this entry. In a history bundle, this indicates the HTTP action that occurred.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private method: EnumCodeType | null;

  /**
   * Bundle.entry.request.url Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** URL for HTTP equivalent of this entry
   * - **Definition:** The URL for this entry, relative to the root (the address to which the request is posted).
   * - **Comment:** E.g. for a Patient Create, the method would be "POST" and the URL would be "Patient". For a Patient Update, the method would be PUT and the URL would be "Patient/[id]".
   * - **FHIR Type:** \`uri\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private url: UriType | null;

  /**
   * Bundle.entry.request.ifNoneMatch Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** For managing cache currency
   * - **Definition:** If the ETag values match, return a 304 Not Modified status. See the API documentation for ["Conditional Read"](https://hl7.org/fhir/http.html#cread).
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private ifNoneMatch?: StringType | undefined;

  /**
   * Bundle.entry.request.ifModifiedSince Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** For managing cache currency
   * - **Definition:** Only perform the operation if the last updated date matches. See the API documentation for ["Conditional Read"](https://hl7.org/fhir/http.html#cread).
   * - **FHIR Type:** \`instant\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private ifModifiedSince?: InstantType | undefined;

  /**
   * Bundle.entry.request.ifMatch Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** For managing update contention
   * - **Definition:** Only perform the operation if the Etag value matches. For more information, see the API section ["Managing Resource Contention"](https://hl7.org/fhir/http.html#concurrency).
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private ifMatch?: StringType | undefined;

  /**
   * Bundle.entry.request.ifNoneExist Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** For conditional creates
   * - **Definition:** Instruct the server not to perform the create if a specified resource already exists. For further information, see the API documentation for ["Conditional Create"](https://hl7.org/fhir/http.html#ccreate). This is just the query portion of the URL - what follows the "?" (not including the "?").
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private ifNoneExist?: StringType | undefined;


  /**
   * @returns the \`method\` property value as a EnumCodeType if defined; else null
   */
  public getMethodEnumType(): EnumCodeType | null {
    return this.method;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`method\` property.
   *
   * @param enumType - the \`method\` value
   * @returns this
   */
  public setMethodEnumType(enumType: EnumCodeType): this {
    assertIsDefined<EnumCodeType>(enumType, \`Bundle.entry.request.method is required\`);
    const errMsgPrefix = \`Invalid Bundle.entry.request.method\`;
    assertEnumCodeType<HttpVerbEnum>(enumType, HttpVerbEnum, errMsgPrefix);
    this.method = enumType;
    return this;
  }

  /**
   * @returns \`true\` if the \`method\` property exists and has a value; \`false\` otherwise
   */
  public hasMethodEnumType(): boolean {
    return isDefined<EnumCodeType>(this.method) && !this.method.isEmpty() && this.method.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`method\` property value as a CodeType if defined; else null
   */
  public getMethodElement(): CodeType | null {
    if (this.method === null) {
      return null;
    }
    return this.method as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`method\` property.
   *
   * @param element - the \`method\` value
   * @returns this
   */
  public setMethodElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, \`Bundle.entry.request.method is required\`);
    const optErrMsg = \`Invalid Bundle.entry.request.method; Provided value is not an instance of CodeType.\`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.method = new EnumCodeType(element, this.httpVerbEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`method\` property exists and has a value; \`false\` otherwise
   */
  public hasMethodElement(): boolean {
    return this.hasMethodEnumType();
  }

  /**
   * @returns the \`method\` property value as a fhirCode if defined; else null
   */
  public getMethod(): fhirCode | null {
    if (this.method === null) {
      return null;
    }
    return this.method.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`method\` property.
   *
   * @param value - the \`method\` value
   * @returns this
   */
  public setMethod(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, \`Bundle.entry.request.method is required\`);
    const optErrMsg = \`Invalid Bundle.entry.request.method (\${String(value)})\`;
    this.method = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.httpVerbEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`method\` property exists and has a value; \`false\` otherwise
   */
  public hasMethod(): boolean {
    return this.hasMethodEnumType();
  }

  /**
   * @returns the \`url\` property value as a UriType object if defined; else null
   */
  public getUrlElement(): UriType | null {
    return this.url;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`url\` property.
   *
   * @param element - the \`url\` value
   * @returns this
   */
  public setUrlElement(element: UriType): this {
    assertIsDefined<UriType>(element, \`Bundle.entry.request.url is required\`);
    const optErrMsg = \`Invalid Bundle.entry.request.url; Provided value is not an instance of UriType.\`;
    assertFhirType<UriType>(element, UriType, optErrMsg);
    this.url = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`url\` property exists and has a value; \`false\` otherwise
   */
  public hasUrlElement(): boolean {
    return isDefined<UriType>(this.url) && !this.url.isEmpty();
  }

  /**
   * @returns the \`url\` property value as a fhirUri if defined; else null
   */
  public getUrl(): fhirUri | null {
    if (this.url?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.url.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`url\` property.
   *
   * @param value - the \`url\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setUrl(value: fhirUri): this {
    assertIsDefined<fhirUri>(value, \`Bundle.entry.request.url is required\`);
    const optErrMsg = \`Invalid Bundle.entry.request.url (\${String(value)})\`;
    this.url = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`url\` property exists and has a value; \`false\` otherwise
   */
  public hasUrl(): boolean {
    return this.hasUrlElement();
  }

  /**
   * @returns the \`ifNoneMatch\` property value as a StringType object if defined; else an empty StringType object
   */
  public getIfNoneMatchElement(): StringType {
    return this.ifNoneMatch ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`ifNoneMatch\` property.
   *
   * @param element - the \`ifNoneMatch\` value
   * @returns this
   */
  public setIfNoneMatchElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Bundle.entry.request.ifNoneMatch; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.ifNoneMatch = element;
    } else {
      this.ifNoneMatch = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`ifNoneMatch\` property exists and has a value; \`false\` otherwise
   */
  public hasIfNoneMatchElement(): boolean {
    return isDefined<StringType>(this.ifNoneMatch) && !this.ifNoneMatch.isEmpty();
  }

  /**
   * @returns the \`ifNoneMatch\` property value as a fhirString if defined; else undefined
   */
  public getIfNoneMatch(): fhirString | undefined {
    return this.ifNoneMatch?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`ifNoneMatch\` property.
   *
   * @param value - the \`ifNoneMatch\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setIfNoneMatch(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.request.ifNoneMatch (\${String(value)})\`;
      this.ifNoneMatch = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.ifNoneMatch = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`ifNoneMatch\` property exists and has a value; \`false\` otherwise
   */
  public hasIfNoneMatch(): boolean {
    return this.hasIfNoneMatchElement();
  }

  /**
   * @returns the \`ifModifiedSince\` property value as a InstantType object if defined; else an empty InstantType object
   */
  public getIfModifiedSinceElement(): InstantType {
    return this.ifModifiedSince ?? new InstantType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`ifModifiedSince\` property.
   *
   * @param element - the \`ifModifiedSince\` value
   * @returns this
   */
  public setIfModifiedSinceElement(element: InstantType | undefined): this {
    if (isDefined<InstantType>(element)) {
      const optErrMsg = \`Invalid Bundle.entry.request.ifModifiedSince; Provided element is not an instance of InstantType.\`;
      assertFhirType<InstantType>(element, InstantType, optErrMsg);
      this.ifModifiedSince = element;
    } else {
      this.ifModifiedSince = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`ifModifiedSince\` property exists and has a value; \`false\` otherwise
   */
  public hasIfModifiedSinceElement(): boolean {
    return isDefined<InstantType>(this.ifModifiedSince) && !this.ifModifiedSince.isEmpty();
  }

  /**
   * @returns the \`ifModifiedSince\` property value as a fhirInstant if defined; else undefined
   */
  public getIfModifiedSince(): fhirInstant | undefined {
    return this.ifModifiedSince?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`ifModifiedSince\` property.
   *
   * @param value - the \`ifModifiedSince\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setIfModifiedSince(value: fhirInstant | undefined): this {
    if (isDefined<fhirInstant>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.request.ifModifiedSince (\${String(value)})\`;
      this.ifModifiedSince = new InstantType(parseFhirPrimitiveData(value, fhirInstantSchema, optErrMsg));
    } else {
      this.ifModifiedSince = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`ifModifiedSince\` property exists and has a value; \`false\` otherwise
   */
  public hasIfModifiedSince(): boolean {
    return this.hasIfModifiedSinceElement();
  }

  /**
   * @returns the \`ifMatch\` property value as a StringType object if defined; else an empty StringType object
   */
  public getIfMatchElement(): StringType {
    return this.ifMatch ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`ifMatch\` property.
   *
   * @param element - the \`ifMatch\` value
   * @returns this
   */
  public setIfMatchElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Bundle.entry.request.ifMatch; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.ifMatch = element;
    } else {
      this.ifMatch = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`ifMatch\` property exists and has a value; \`false\` otherwise
   */
  public hasIfMatchElement(): boolean {
    return isDefined<StringType>(this.ifMatch) && !this.ifMatch.isEmpty();
  }

  /**
   * @returns the \`ifMatch\` property value as a fhirString if defined; else undefined
   */
  public getIfMatch(): fhirString | undefined {
    return this.ifMatch?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`ifMatch\` property.
   *
   * @param value - the \`ifMatch\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setIfMatch(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.request.ifMatch (\${String(value)})\`;
      this.ifMatch = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.ifMatch = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`ifMatch\` property exists and has a value; \`false\` otherwise
   */
  public hasIfMatch(): boolean {
    return this.hasIfMatchElement();
  }

  /**
   * @returns the \`ifNoneExist\` property value as a StringType object if defined; else an empty StringType object
   */
  public getIfNoneExistElement(): StringType {
    return this.ifNoneExist ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`ifNoneExist\` property.
   *
   * @param element - the \`ifNoneExist\` value
   * @returns this
   */
  public setIfNoneExistElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Bundle.entry.request.ifNoneExist; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.ifNoneExist = element;
    } else {
      this.ifNoneExist = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`ifNoneExist\` property exists and has a value; \`false\` otherwise
   */
  public hasIfNoneExistElement(): boolean {
    return isDefined<StringType>(this.ifNoneExist) && !this.ifNoneExist.isEmpty();
  }

  /**
   * @returns the \`ifNoneExist\` property value as a fhirString if defined; else undefined
   */
  public getIfNoneExist(): fhirString | undefined {
    return this.ifNoneExist?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`ifNoneExist\` property.
   *
   * @param value - the \`ifNoneExist\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setIfNoneExist(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.request.ifNoneExist (\${String(value)})\`;
      this.ifNoneExist = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.ifNoneExist = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`ifNoneExist\` property exists and has a value; \`false\` otherwise
   */
  public hasIfNoneExist(): boolean {
    return this.hasIfNoneExistElement();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Bundle.entry.request';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.method,
      this.url,
      this.ifNoneMatch,
      this.ifModifiedSince,
      this.ifMatch,
      this.ifNoneExist,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): BundleEntryRequestComponent {
    const dest = new BundleEntryRequestComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: BundleEntryRequestComponent): void {
    super.copyValues(dest);
    dest.method = this.method ? this.method.copy() : null;
    dest.url = this.url ? this.url.copy() : null;
    dest.ifNoneMatch = this.ifNoneMatch?.copy();
    dest.ifModifiedSince = this.ifModifiedSince?.copy();
    dest.ifMatch = this.ifMatch?.copy();
    dest.ifNoneExist = this.ifNoneExist?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasMethodElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getMethodElement()!, 'method', jsonObj);
    } else {
      missingReqdProperties.push(\`Bundle.entry.request.method\`);
    }

    if (this.hasUrlElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirUri>(this.getUrlElement()!, 'url', jsonObj);
    } else {
      missingReqdProperties.push(\`Bundle.entry.request.url\`);
    }

    if (this.hasIfNoneMatchElement()) {
      setFhirPrimitiveJson<fhirString>(this.getIfNoneMatchElement(), 'ifNoneMatch', jsonObj);
    }

    if (this.hasIfModifiedSinceElement()) {
      setFhirPrimitiveJson<fhirInstant>(this.getIfModifiedSinceElement(), 'ifModifiedSince', jsonObj);
    }

    if (this.hasIfMatchElement()) {
      setFhirPrimitiveJson<fhirString>(this.getIfMatchElement(), 'ifMatch', jsonObj);
    }

    if (this.hasIfNoneExistElement()) {
      setFhirPrimitiveJson<fhirString>(this.getIfNoneExistElement(), 'ifNoneExist', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

/**
 * BundleEntryResponseComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Results of execution (transaction/batch/history)
 * - **Definition:** Indicates the results of processing the corresponding \\'request\\' entry in the batch or transaction being responded to or what the results of an operation where when returning history.
 *
 * @category DataModel: Resource
 * @see [FHIR Bundle](http://hl7.org/fhir/StructureDefinition/Bundle)
 */
export class BundleEntryResponseComponent extends BackboneElement {
  constructor(status: StringType | fhirString | null = null) {
    super();

    this.status = null;
    if (isDefined<StringType | fhirString>(status)) {
      if (status instanceof PrimitiveType) {
        this.setStatusElement(status);
      } else {
        this.setStatus(status);
      }
    }
  }

  /**
   * Parse the provided \`BundleEntryResponseComponent\` JSON to instantiate the BundleEntryResponseComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`BundleEntryResponseComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to BundleEntryResponseComponent
   * @returns BundleEntryResponseComponent data model or undefined for \`BundleEntryResponseComponent\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): BundleEntryResponseComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirResourceParser = new FhirResourceParser(PARSABLE_DATATYPE_MAP);
    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'BundleEntryResponseComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new BundleEntryResponseComponent();
    fhirDataTypeParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'status';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setStatusElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'location';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = parseUriType(dtJson, dtSiblingJson);
      instance.setLocationElement(datatype);
    }

    fieldName = 'etag';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setEtagElement(datatype);
    }

    fieldName = 'lastModified';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: InstantType | undefined = parseInstantType(dtJson, dtSiblingJson);
      instance.setLastModifiedElement(datatype);
    }

    fieldName = 'outcome';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      const outcome: Resource | undefined = fhirResourceParser.parseInlineResource(classJsonObj[fieldName], sourceField);
      instance.setOutcome(outcome);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Bundle.entry.response.status Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Status response code (text optional)
   * - **Definition:** The status code returned by processing this entry. The status SHALL start with a 3 digit HTTP code (e.g. 404) and may contain the standard HTTP description associated with the status code.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private status: StringType | null;

  /**
   * Bundle.entry.response.location Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The location (if the operation returns a location)
   * - **Definition:** The location header created by processing this operation, populated if the operation returns a location.
   * - **FHIR Type:** \`uri\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private location?: UriType | undefined;

  /**
   * Bundle.entry.response.etag Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The Etag for the resource (if relevant)
   * - **Definition:** The Etag for the resource, if the operation for the entry produced a versioned resource (see [Resource Metadata and Versioning](https://hl7.org/fhir/http.html#versioning) and [Managing Resource Contention](https://hl7.org/fhir/http.html#concurrency)).
   * - **Comment:** Etags match the Resource.meta.versionId. The ETag has to match the version id in the header if a resource is included.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private etag?: StringType | undefined;

  /**
   * Bundle.entry.response.lastModified Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Server\\'s date time modified
   * - **Definition:** The date/time that the resource was modified on the server.
   * - **Comment:** This has to match the same time in the meta header (meta.lastUpdated) if a resource is included.
   * - **FHIR Type:** \`instant\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private lastModified?: InstantType | undefined;

  /**
   * Bundle.entry.response.outcome Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** OperationOutcome with hints and warnings (for batch/transaction)
   * - **Definition:** An OperationOutcome containing hints and warnings produced as part of processing this entry in a batch or transaction.
   * - **Comment:** For a POST/PUT operation, this is the equivalent outcome that would be returned for prefer = operationoutcome - except that the resource is always returned whether or not the outcome is returned. This outcome is not used for error responses in batch/transaction, only for hints and warnings. In a batch operation, the error will be in Bundle.entry.response, and for transaction, there will be a single OperationOutcome instead of a bundle in the case of an error.
   * - **FHIR Type:** \`Resource\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private outcome?: Resource | undefined;


  /**
   * @returns the \`status\` property value as a StringType object if defined; else null
   */
  public getStatusElement(): StringType | null {
    return this.status;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`status\` property.
   *
   * @param element - the \`status\` value
   * @returns this
   */
  public setStatusElement(element: StringType): this {
    assertIsDefined<StringType>(element, \`Bundle.entry.response.status is required\`);
    const optErrMsg = \`Invalid Bundle.entry.response.status; Provided value is not an instance of StringType.\`;
    assertFhirType<StringType>(element, StringType, optErrMsg);
    this.status = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`status\` property exists and has a value; \`false\` otherwise
   */
  public hasStatusElement(): boolean {
    return isDefined<StringType>(this.status) && !this.status.isEmpty();
  }

  /**
   * @returns the \`status\` property value as a fhirString if defined; else null
   */
  public getStatus(): fhirString | null {
    if (this.status?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.status.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`status\` property.
   *
   * @param value - the \`status\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setStatus(value: fhirString): this {
    assertIsDefined<fhirString>(value, \`Bundle.entry.response.status is required\`);
    const optErrMsg = \`Invalid Bundle.entry.response.status (\${String(value)})\`;
    this.status = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`status\` property exists and has a value; \`false\` otherwise
   */
  public hasStatus(): boolean {
    return this.hasStatusElement();
  }

  /**
   * @returns the \`location\` property value as a UriType object if defined; else an empty UriType object
   */
  public getLocationElement(): UriType {
    return this.location ?? new UriType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`location\` property.
   *
   * @param element - the \`location\` value
   * @returns this
   */
  public setLocationElement(element: UriType | undefined): this {
    if (isDefined<UriType>(element)) {
      const optErrMsg = \`Invalid Bundle.entry.response.location; Provided element is not an instance of UriType.\`;
      assertFhirType<UriType>(element, UriType, optErrMsg);
      this.location = element;
    } else {
      this.location = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`location\` property exists and has a value; \`false\` otherwise
   */
  public hasLocationElement(): boolean {
    return isDefined<UriType>(this.location) && !this.location.isEmpty();
  }

  /**
   * @returns the \`location\` property value as a fhirUri if defined; else undefined
   */
  public getLocation(): fhirUri | undefined {
    return this.location?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`location\` property.
   *
   * @param value - the \`location\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setLocation(value: fhirUri | undefined): this {
    if (isDefined<fhirUri>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.response.location (\${String(value)})\`;
      this.location = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    } else {
      this.location = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`location\` property exists and has a value; \`false\` otherwise
   */
  public hasLocation(): boolean {
    return this.hasLocationElement();
  }

  /**
   * @returns the \`etag\` property value as a StringType object if defined; else an empty StringType object
   */
  public getEtagElement(): StringType {
    return this.etag ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`etag\` property.
   *
   * @param element - the \`etag\` value
   * @returns this
   */
  public setEtagElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Bundle.entry.response.etag; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.etag = element;
    } else {
      this.etag = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`etag\` property exists and has a value; \`false\` otherwise
   */
  public hasEtagElement(): boolean {
    return isDefined<StringType>(this.etag) && !this.etag.isEmpty();
  }

  /**
   * @returns the \`etag\` property value as a fhirString if defined; else undefined
   */
  public getEtag(): fhirString | undefined {
    return this.etag?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`etag\` property.
   *
   * @param value - the \`etag\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setEtag(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.response.etag (\${String(value)})\`;
      this.etag = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.etag = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`etag\` property exists and has a value; \`false\` otherwise
   */
  public hasEtag(): boolean {
    return this.hasEtagElement();
  }

  /**
   * @returns the \`lastModified\` property value as a InstantType object if defined; else an empty InstantType object
   */
  public getLastModifiedElement(): InstantType {
    return this.lastModified ?? new InstantType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`lastModified\` property.
   *
   * @param element - the \`lastModified\` value
   * @returns this
   */
  public setLastModifiedElement(element: InstantType | undefined): this {
    if (isDefined<InstantType>(element)) {
      const optErrMsg = \`Invalid Bundle.entry.response.lastModified; Provided element is not an instance of InstantType.\`;
      assertFhirType<InstantType>(element, InstantType, optErrMsg);
      this.lastModified = element;
    } else {
      this.lastModified = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`lastModified\` property exists and has a value; \`false\` otherwise
   */
  public hasLastModifiedElement(): boolean {
    return isDefined<InstantType>(this.lastModified) && !this.lastModified.isEmpty();
  }

  /**
   * @returns the \`lastModified\` property value as a fhirInstant if defined; else undefined
   */
  public getLastModified(): fhirInstant | undefined {
    return this.lastModified?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`lastModified\` property.
   *
   * @param value - the \`lastModified\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setLastModified(value: fhirInstant | undefined): this {
    if (isDefined<fhirInstant>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.response.lastModified (\${String(value)})\`;
      this.lastModified = new InstantType(parseFhirPrimitiveData(value, fhirInstantSchema, optErrMsg));
    } else {
      this.lastModified = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`lastModified\` property exists and has a value; \`false\` otherwise
   */
  public hasLastModified(): boolean {
    return this.hasLastModifiedElement();
  }

  /**
   * @returns the \`outcome\` property value as a Resource object if defined; else undefined
   */
  public getOutcome(): Resource | undefined {
    return this.outcome;
  }

  /**
   * Assigns the provided Resource object value to the \`outcome\` property.
   *
   * @param value - the \`outcome\` object value
   * @returns this
   */
  public setOutcome(value: Resource | undefined): this {
    if (isDefined<Resource>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.response.outcome; Provided element is not an instance of Resource.\`;
      assertFhirResourceType(value, optErrMsg);
      this.outcome = value;
    } else {
      this.outcome = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`outcome\` property exists and has a value; \`false\` otherwise
   */
  public hasOutcome(): boolean {
    return isDefined<Resource>(this.outcome) && !this.outcome.isEmpty();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Bundle.entry.response';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.status,
      this.location,
      this.etag,
      this.lastModified,
      this.outcome,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): BundleEntryResponseComponent {
    const dest = new BundleEntryResponseComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: BundleEntryResponseComponent): void {
    super.copyValues(dest);
    dest.status = this.status ? this.status.copy() : null;
    dest.location = this.location?.copy();
    dest.etag = this.etag?.copy();
    dest.lastModified = this.lastModified?.copy();
    dest.outcome = this.outcome?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasStatusElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirString>(this.getStatusElement()!, 'status', jsonObj);
    } else {
      missingReqdProperties.push(\`Bundle.entry.response.status\`);
    }

    if (this.hasLocationElement()) {
      setFhirPrimitiveJson<fhirUri>(this.getLocationElement(), 'location', jsonObj);
    }

    if (this.hasEtagElement()) {
      setFhirPrimitiveJson<fhirString>(this.getEtagElement(), 'etag', jsonObj);
    }

    if (this.hasLastModifiedElement()) {
      setFhirPrimitiveJson<fhirInstant>(this.getLastModifiedElement(), 'lastModified', jsonObj);
    }

    if (this.hasOutcome()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirResourceJson(this.getOutcome()!, 'outcome', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
",
  "fileExtension": "ts",
  "filename": "Bundle",
}
`;

exports[`src/generator-app unit test suite generator-app verify generated content should consistently create GeneratedContent[] 24`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/test-out",
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/utest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "Resource",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * PractitionerRole Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/PractitionerRole
 * StructureDefinition.name: PractitionerRole
 * StructureDefinition.description: A specific set of Roles/Locations/specialties/services that a practitioner may perform at an organization for a period of time.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  BackboneElement,
  BooleanType,
  CodeType,
  EnumCodeType,
  FhirDataTypeParser,
  FhirError,
  IBase,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  PrimitiveType,
  PrimitiveTypeJson,
  REQUIRED_PROPERTIES_DO_NOT_EXIST,
  REQUIRED_PROPERTIES_REQD_IN_JSON,
  StringType,
  TimeType,
  assertEnumCodeType,
  assertEnumCodeTypeList,
  assertFhirType,
  assertFhirTypeList,
  assertIsDefined,
  copyListValues,
  fhirBoolean,
  fhirBooleanSchema,
  fhirCode,
  fhirCodeSchema,
  fhirString,
  fhirStringSchema,
  fhirTime,
  fhirTimeSchema,
  getPrimitiveTypeJson,
  getPrimitiveTypeListJson,
  isDefined,
  isDefinedList,
  isElementEmpty,
  isEmpty,
  parseBooleanType,
  parseCodeType,
  parseFhirPrimitiveData,
  parseStringType,
  parseTimeType,
  setFhirBackboneElementListJson,
  setFhirComplexJson,
  setFhirComplexListJson,
  setFhirPrimitiveJson,
  setFhirPrimitiveListJson,
} from '@paq-ts-fhir/fhir-core';
import {
  CodeableConcept,
  ContactPoint,
  DaysOfWeekEnum,
  DomainResource,
  FhirResourceParser,
  FhirResourceType,
  Identifier,
  PARSABLE_DATATYPE_MAP,
  Period,
  Reference,
  ReferenceTargets,
} from '../index';

/**
 * PractitionerRole Class
 *
 * @remarks
 * A specific set of Roles/Locations/specialties/services that a practitioner may perform at an organization for a period of time.
 *
 * Need to track services that a healthcare provider is able to provide at an organization\\'s location, and the services that they can perform there.
 *
 * **FHIR Specification**
 * - **Short:** Roles/organizations the practitioner is associated with
 * - **Definition:** A specific set of Roles/Locations/specialties/services that a practitioner may perform at an organization for a period of time.
 * - **FHIR Version:** 4.0.1
 *
 * @category DataModel: Resource
 * @see [FHIR PractitionerRole](http://hl7.org/fhir/StructureDefinition/PractitionerRole)
 */
export class PractitionerRole extends DomainResource implements IBase {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`PractitionerRole\` JSON to instantiate the PractitionerRole data model.
   *
   * @param sourceJson - JSON representing FHIR \`PractitionerRole\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to PractitionerRole
   * @returns PractitionerRole data model or undefined for \`PractitionerRole\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): PractitionerRole | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirResourceParser = new FhirResourceParser(PARSABLE_DATATYPE_MAP);
    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'PractitionerRole';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new PractitionerRole();
    fhirResourceParser.processDomainResourceJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'identifier';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Identifier | undefined = fhirDataTypeParser.parser<Identifier>(Identifier, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addIdentifier(datatype);
        }
      });
    }

    fieldName = 'active';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'boolean';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: BooleanType | undefined = parseBooleanType(dtJson, dtSiblingJson);
      instance.setActiveElement(datatype);
    }

    fieldName = 'period';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Period | undefined = fhirDataTypeParser.parser<Period>(Period, classJsonObj[fieldName]!, sourceField);
      instance.setPeriod(datatype);
    }

    fieldName = 'practitioner';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = fhirDataTypeParser.parser<Reference>(Reference, classJsonObj[fieldName]!, sourceField);
      instance.setPractitioner(datatype);
    }

    fieldName = 'organization';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = fhirDataTypeParser.parser<Reference>(Reference, classJsonObj[fieldName]!, sourceField);
      instance.setOrganization(datatype);
    }

    fieldName = 'code';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: CodeableConcept | undefined = fhirDataTypeParser.parser<CodeableConcept>(CodeableConcept, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addCode(datatype);
        }
      });
    }

    fieldName = 'specialty';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: CodeableConcept | undefined = fhirDataTypeParser.parser<CodeableConcept>(CodeableConcept, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addSpecialty(datatype);
        }
      });
    }

    fieldName = 'location';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Reference | undefined = fhirDataTypeParser.parser<Reference>(Reference, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addLocation(datatype);
        }
      });
  }

    fieldName = 'healthcareService';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Reference | undefined = fhirDataTypeParser.parser<Reference>(Reference, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addHealthcareService(datatype);
        }
      });
  }

    fieldName = 'telecom';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: ContactPoint | undefined = fhirDataTypeParser.parser<ContactPoint>(ContactPoint, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addTelecom(datatype);
        }
      });
    }

    fieldName = 'availableTime';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const componentJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      componentJsonArray.forEach((componentJson: JSON.Value, idx) => {
        const component: PractitionerRoleAvailableTimeComponent | undefined = PractitionerRoleAvailableTimeComponent.parse(componentJson, \`\${sourceField}[\${String(idx)}]\`);
        if (component !== undefined) {
          instance.addAvailableTime(component);
        }
      });
    }

    fieldName = 'notAvailable';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const componentJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      componentJsonArray.forEach((componentJson: JSON.Value, idx) => {
        const component: PractitionerRoleNotAvailableComponent | undefined = PractitionerRoleNotAvailableComponent.parse(componentJson, \`\${sourceField}[\${String(idx)}]\`);
        if (component !== undefined) {
          instance.addNotAvailable(component);
        }
      });
    }

    fieldName = 'availabilityExceptions';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      instance.setAvailabilityExceptionsElement(datatype);
    }

    fieldName = 'endpoint';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Reference | undefined = fhirDataTypeParser.parser<Reference>(Reference, dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addEndpoint(datatype);
        }
      });
  }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * PractitionerRole.identifier Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Business Identifiers that are specific to a role/location
   * - **Definition:** Business Identifiers that are specific to a role/location.
   * - **Requirements:** Often, specific identities are assigned for the agent.
   * - **FHIR Type:** \`Identifier\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private identifier?: Identifier[] | undefined;

  /**
   * PractitionerRole.active Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Whether this practitioner role record is in active use
   * - **Definition:** Whether this practitioner role record is in active use.
   * - **Comment:** If this value is false, you may refer to the period to see when the role was in active use. If there is no period specified, no inference can be made about when it was active.
   * - **Requirements:** Need to be able to mark a practitioner role record as not to be used because it was created in error, or otherwise no longer in active use.
   * - **FHIR Type:** \`boolean\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private active?: BooleanType | undefined;

  /**
   * PractitionerRole.period Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The period during which the practitioner is authorized to perform in these role(s)
   * - **Definition:** The period during which the person is authorized to act as a practitioner in these role(s) for the organization.
   * - **Requirements:** Even after the agencies is revoked, the fact that it existed must still be recorded.
   * - **FHIR Type:** \`Period\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private period?: Period | undefined;

  /**
   * PractitionerRole.practitioner Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Practitioner that is able to provide the defined services for the organization
   * - **Definition:** Practitioner that is able to provide the defined services for the organization.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Practitioner',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private practitioner?: Reference | undefined;

  /**
   * PractitionerRole.organization Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Organization where the roles are available
   * - **Definition:** The organization where the Practitioner performs the roles associated.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Organization',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private organization?: Reference | undefined;

  /**
   * PractitionerRole.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Roles which this practitioner may perform
   * - **Definition:** Roles which this practitioner is authorized to perform for the organization.
   * - **Comment:** A person may have more than one role.
   * - **Requirements:** Need to know what authority the practitioner has - what can they do?
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code?: CodeableConcept[] | undefined;

  /**
   * PractitionerRole.specialty Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Specific specialty of the practitioner
   * - **Definition:** Specific specialty of the practitioner.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private specialty?: CodeableConcept[] | undefined;

  /**
   * PractitionerRole.location Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The location(s) at which this practitioner provides care
   * - **Definition:** The location(s) at which this practitioner provides care.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Location',
   *     ]
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private location?: Reference[] | undefined;

  /**
   * PractitionerRole.healthcareService Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The list of healthcare services that this worker provides for this role\\'s Organization/Location(s)
   * - **Definition:** The list of healthcare services that this worker provides for this role\\'s Organization/Location(s).
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/HealthcareService',
   *     ]
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private healthcareService?: Reference[] | undefined;

  /**
   * PractitionerRole.telecom Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Contact details that are specific to the role/location/service
   * - **Definition:** Contact details that are specific to the role/location/service.
   * - **Requirements:** Often practitioners have a dedicated line for each location (or service) that they work at, and need to be able to define separate contact details for each of these.
   * - **FHIR Type:** \`ContactPoint\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private telecom?: ContactPoint[] | undefined;

  /**
   * PractitionerRole.availableTime Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Times the Service Site is available
   * - **Definition:** A collection of times the practitioner is available or performing this role at the location and/or healthcareservice.
   * - **Comment:** More detailed availability information may be provided in associated Schedule/Slot resources.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private availableTime?: PractitionerRoleAvailableTimeComponent[] | undefined;

  /**
   * PractitionerRole.notAvailable Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Not available during this time due to provided reason
   * - **Definition:** The practitioner is not available or performing this role during this period of time due to the provided reason.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private notAvailable?: PractitionerRoleNotAvailableComponent[] | undefined;

  /**
   * PractitionerRole.availabilityExceptions Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Description of availability exceptions
   * - **Definition:** A description of site availability exceptions, e.g. public holiday availability. Succinctly describing all possible exceptions to normal site availability as details in the available Times and not available Times.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private availabilityExceptions?: StringType | undefined;

  /**
   * PractitionerRole.endpoint Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Technical endpoints providing access to services operated for the practitioner with this role
   * - **Definition:** Technical endpoints providing access to services operated for the practitioner with this role.
   * - **Requirements:** Organizations have multiple systems that provide various services and ,ay also be different for practitioners too. So the endpoint satisfies the need to be able to define the technical connection details for how to connect to them, and for what purpose.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Endpoint',
   *     ]
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private endpoint?: Reference[] | undefined;


  /**
   * @returns the FHIR resource type as defined by the FHIR specification
   */
  public override resourceType(): FhirResourceType {
    return this.fhirType() as FhirResourceType;
  }

  /**
   * @returns the \`identifier\` property value as a Identifier array
   */
  public getIdentifier(): Identifier[] {
    return this.identifier ?? ([] as Identifier[]);
  }

  /**
   * Assigns the provided Identifier array value to the \`identifier\` property.
   *
   * @param value - the \`identifier\` array value
   * @returns this
   */
  public setIdentifier(value: Identifier[] | undefined): this {
    if (isDefinedList<Identifier>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.identifier; Provided value array has an element that is not an instance of Identifier.\`;
      assertFhirTypeList<Identifier>(value, Identifier, optErrMsg);
      this.identifier = value;
    } else {
      this.identifier = undefined;
    }
    return this;
  }

  /**
   * Add the provided Identifier value to the \`identifier\` array property.
   *
   * @param value - the \`identifier\` value
   * @returns this
   */
  public addIdentifier(value: Identifier | undefined): this {
    if (isDefined<Identifier>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.identifier; Provided element is not an instance of Identifier.\`;
      assertFhirType<Identifier>(value, Identifier, optErrMsg);
      this.initIdentifier();
      this.identifier?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`identifier\` property exists and has a value; \`false\` otherwise
   */
  public hasIdentifier(): boolean {
    return isDefinedList<Identifier>(this.identifier) && this.identifier.some((item: Identifier) => !item.isEmpty());
  }

  /**
   * Initialize the \`identifier\` property
   */
  private initIdentifier(): void {
    if(!this.hasIdentifier()) {
      this.identifier = [] as Identifier[];
    }
  }

  /**
   * @returns the \`active\` property value as a BooleanType object if defined; else an empty BooleanType object
   */
  public getActiveElement(): BooleanType {
    return this.active ?? new BooleanType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`active\` property.
   *
   * @param element - the \`active\` value
   * @returns this
   */
  public setActiveElement(element: BooleanType | undefined): this {
    if (isDefined<BooleanType>(element)) {
      const optErrMsg = \`Invalid PractitionerRole.active; Provided element is not an instance of BooleanType.\`;
      assertFhirType<BooleanType>(element, BooleanType, optErrMsg);
      this.active = element;
    } else {
      this.active = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`active\` property exists and has a value; \`false\` otherwise
   */
  public hasActiveElement(): boolean {
    return isDefined<BooleanType>(this.active) && !this.active.isEmpty();
  }

  /**
   * @returns the \`active\` property value as a fhirBoolean if defined; else undefined
   */
  public getActive(): fhirBoolean | undefined {
    return this.active?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`active\` property.
   *
   * @param value - the \`active\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setActive(value: fhirBoolean | undefined): this {
    if (isDefined<fhirBoolean>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.active (\${String(value)})\`;
      this.active = new BooleanType(parseFhirPrimitiveData(value, fhirBooleanSchema, optErrMsg));
    } else {
      this.active = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`active\` property exists and has a value; \`false\` otherwise
   */
  public hasActive(): boolean {
    return this.hasActiveElement();
  }

  /**
   * @returns the \`period\` property value as a Period object if defined; else an empty Period object
   */
  public getPeriod(): Period {
    return this.period ?? new Period();
  }

  /**
   * Assigns the provided Period object value to the \`period\` property.
   *
   * @param value - the \`period\` object value
   * @returns this
   */
  public setPeriod(value: Period | undefined): this {
    if (isDefined<Period>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.period; Provided element is not an instance of Period.\`;
      assertFhirType<Period>(value, Period, optErrMsg);
      this.period = value;
    } else {
      this.period = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`period\` property exists and has a value; \`false\` otherwise
   */
  public hasPeriod(): boolean {
    return isDefined<Period>(this.period) && !this.period.isEmpty();
  }

  /**
   * @returns the \`practitioner\` property value as a Reference object; else an empty Reference object
   */
  public getPractitioner(): Reference {
    return this.practitioner ?? new Reference();
  }

  /**
   * Assigns the provided Practitioner object value to the \`practitioner\` property.
   *
   * @decorator \`@ReferenceTargets('PractitionerRole.practitioner', ['Practitioner',])\`
   *
   * @param value - the \`practitioner\` object value
   * @returns this
   */
  @ReferenceTargets('PractitionerRole.practitioner', [
    'Practitioner',
  ])
  public setPractitioner(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.practitioner = value;
    } else {
      this.practitioner = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`practitioner\` property exists and has a value; \`false\` otherwise
   */
  public hasPractitioner(): boolean {
    return isDefined<Reference>(this.practitioner) && !this.practitioner.isEmpty();
  }

  /**
   * @returns the \`organization\` property value as a Reference object; else an empty Reference object
   */
  public getOrganization(): Reference {
    return this.organization ?? new Reference();
  }

  /**
   * Assigns the provided Organization object value to the \`organization\` property.
   *
   * @decorator \`@ReferenceTargets('PractitionerRole.organization', ['Organization',])\`
   *
   * @param value - the \`organization\` object value
   * @returns this
   */
  @ReferenceTargets('PractitionerRole.organization', [
    'Organization',
  ])
  public setOrganization(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.organization = value;
    } else {
      this.organization = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`organization\` property exists and has a value; \`false\` otherwise
   */
  public hasOrganization(): boolean {
    return isDefined<Reference>(this.organization) && !this.organization.isEmpty();
  }

  /**
   * @returns the \`code\` property value as a CodeableConcept array
   */
  public getCode(): CodeableConcept[] {
    return this.code ?? ([] as CodeableConcept[]);
  }

  /**
   * Assigns the provided CodeableConcept array value to the \`code\` property.
   *
   * @param value - the \`code\` array value
   * @returns this
   */
  public setCode(value: CodeableConcept[] | undefined): this {
    if (isDefinedList<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.code; Provided value array has an element that is not an instance of CodeableConcept.\`;
      assertFhirTypeList<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.code = value;
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeableConcept value to the \`code\` array property.
   *
   * @param value - the \`code\` value
   * @returns this
   */
  public addCode(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.code; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.initCode();
      this.code?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`code\` property exists and has a value; \`false\` otherwise
   */
  public hasCode(): boolean {
    return isDefinedList<CodeableConcept>(this.code) && this.code.some((item: CodeableConcept) => !item.isEmpty());
  }

  /**
   * Initialize the \`code\` property
   */
  private initCode(): void {
    if(!this.hasCode()) {
      this.code = [] as CodeableConcept[];
    }
  }

  /**
   * @returns the \`specialty\` property value as a CodeableConcept array
   */
  public getSpecialty(): CodeableConcept[] {
    return this.specialty ?? ([] as CodeableConcept[]);
  }

  /**
   * Assigns the provided CodeableConcept array value to the \`specialty\` property.
   *
   * @param value - the \`specialty\` array value
   * @returns this
   */
  public setSpecialty(value: CodeableConcept[] | undefined): this {
    if (isDefinedList<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.specialty; Provided value array has an element that is not an instance of CodeableConcept.\`;
      assertFhirTypeList<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.specialty = value;
    } else {
      this.specialty = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeableConcept value to the \`specialty\` array property.
   *
   * @param value - the \`specialty\` value
   * @returns this
   */
  public addSpecialty(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.specialty; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.initSpecialty();
      this.specialty?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`specialty\` property exists and has a value; \`false\` otherwise
   */
  public hasSpecialty(): boolean {
    return isDefinedList<CodeableConcept>(this.specialty) && this.specialty.some((item: CodeableConcept) => !item.isEmpty());
  }

  /**
   * Initialize the \`specialty\` property
   */
  private initSpecialty(): void {
    if(!this.hasSpecialty()) {
      this.specialty = [] as CodeableConcept[];
    }
  }

  /**
   * @returns the \`location\` property value as a Reference array
   */
  public getLocation(): Reference[] {
    return this.location ?? ([] as Reference[]);
  }

  /**
   * Assigns the provided Reference array value to the \`location\` property.
   *
   * @decorator \`@ReferenceTargets('PractitionerRole.location', ['Location',])\`
   *
   * @param value - the \`location\` array value
   * @returns this
   */
  @ReferenceTargets('PractitionerRole.location', [
    'Location',
  ])
  public setLocation(value: Reference[] | undefined): this {
    if (isDefinedList<Reference>(value)) {
      // assertFhirTypeList<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.location = value;
    } else {
      this.location = undefined;
    }
    return this;
  }

  /**
   * Add the provided Reference value to the \`location\` array property.
   *
   * @decorator \`@ReferenceTargets('PractitionerRole.location', ['Location',])\`
   *
   * @param value - the \`location\` value
   * @returns this
   */
  @ReferenceTargets('PractitionerRole.location', [
    'Location',
  ])
  public addLocation(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.initLocation();
      this.location?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`location\` property exists and has a value; \`false\` otherwise
   */
  public hasLocation(): boolean {
    return isDefinedList<Reference>(this.location) && this.location.some((item: Reference) => !item.isEmpty());
  }

  /**
   * Initialize the \`location\` property
   */
  private initLocation(): void {
    if (!this.hasLocation()) {
      this.location = [] as Reference[];
    }
  }

  /**
   * @returns the \`healthcareService\` property value as a Reference array
   */
  public getHealthcareService(): Reference[] {
    return this.healthcareService ?? ([] as Reference[]);
  }

  /**
   * Assigns the provided Reference array value to the \`healthcareService\` property.
   *
   * @decorator \`@ReferenceTargets('PractitionerRole.healthcareService', ['HealthcareService',])\`
   *
   * @param value - the \`healthcareService\` array value
   * @returns this
   */
  @ReferenceTargets('PractitionerRole.healthcareService', [
    'HealthcareService',
  ])
  public setHealthcareService(value: Reference[] | undefined): this {
    if (isDefinedList<Reference>(value)) {
      // assertFhirTypeList<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.healthcareService = value;
    } else {
      this.healthcareService = undefined;
    }
    return this;
  }

  /**
   * Add the provided Reference value to the \`healthcareService\` array property.
   *
   * @decorator \`@ReferenceTargets('PractitionerRole.healthcareService', ['HealthcareService',])\`
   *
   * @param value - the \`healthcareService\` value
   * @returns this
   */
  @ReferenceTargets('PractitionerRole.healthcareService', [
    'HealthcareService',
  ])
  public addHealthcareService(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.initHealthcareService();
      this.healthcareService?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`healthcareService\` property exists and has a value; \`false\` otherwise
   */
  public hasHealthcareService(): boolean {
    return isDefinedList<Reference>(this.healthcareService) && this.healthcareService.some((item: Reference) => !item.isEmpty());
  }

  /**
   * Initialize the \`healthcareService\` property
   */
  private initHealthcareService(): void {
    if (!this.hasHealthcareService()) {
      this.healthcareService = [] as Reference[];
    }
  }

  /**
   * @returns the \`telecom\` property value as a ContactPoint array
   */
  public getTelecom(): ContactPoint[] {
    return this.telecom ?? ([] as ContactPoint[]);
  }

  /**
   * Assigns the provided ContactPoint array value to the \`telecom\` property.
   *
   * @param value - the \`telecom\` array value
   * @returns this
   */
  public setTelecom(value: ContactPoint[] | undefined): this {
    if (isDefinedList<ContactPoint>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.telecom; Provided value array has an element that is not an instance of ContactPoint.\`;
      assertFhirTypeList<ContactPoint>(value, ContactPoint, optErrMsg);
      this.telecom = value;
    } else {
      this.telecom = undefined;
    }
    return this;
  }

  /**
   * Add the provided ContactPoint value to the \`telecom\` array property.
   *
   * @param value - the \`telecom\` value
   * @returns this
   */
  public addTelecom(value: ContactPoint | undefined): this {
    if (isDefined<ContactPoint>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.telecom; Provided element is not an instance of ContactPoint.\`;
      assertFhirType<ContactPoint>(value, ContactPoint, optErrMsg);
      this.initTelecom();
      this.telecom?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`telecom\` property exists and has a value; \`false\` otherwise
   */
  public hasTelecom(): boolean {
    return isDefinedList<ContactPoint>(this.telecom) && this.telecom.some((item: ContactPoint) => !item.isEmpty());
  }

  /**
   * Initialize the \`telecom\` property
   */
  private initTelecom(): void {
    if(!this.hasTelecom()) {
      this.telecom = [] as ContactPoint[];
    }
  }

  /**
   * @returns the \`availableTime\` property value as a PractitionerRoleAvailableTimeComponent array
   */
  public getAvailableTime(): PractitionerRoleAvailableTimeComponent[] {
    return this.availableTime ?? ([] as PractitionerRoleAvailableTimeComponent[]);
  }

  /**
   * Assigns the provided PractitionerRoleAvailableTimeComponent array value to the \`availableTime\` property.
   *
   * @param value - the \`availableTime\` array value
   * @returns this
   */
  public setAvailableTime(value: PractitionerRoleAvailableTimeComponent[] | undefined): this {
    if (isDefinedList<PractitionerRoleAvailableTimeComponent>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.availableTime; Provided value array has an element that is not an instance of PractitionerRoleAvailableTimeComponent.\`;
      assertFhirTypeList<PractitionerRoleAvailableTimeComponent>(value, PractitionerRoleAvailableTimeComponent, optErrMsg);
      this.availableTime = value;
    } else {
      this.availableTime = undefined;
    }
    return this;
  }

  /**
   * Add the provided PractitionerRoleAvailableTimeComponent value to the \`availableTime\` array property.
   *
   * @param value - the \`availableTime\` value
   * @returns this
   */
  public addAvailableTime(value: PractitionerRoleAvailableTimeComponent | undefined): this {
    if (isDefined<PractitionerRoleAvailableTimeComponent>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.availableTime; Provided element is not an instance of PractitionerRoleAvailableTimeComponent.\`;
      assertFhirType<PractitionerRoleAvailableTimeComponent>(value, PractitionerRoleAvailableTimeComponent, optErrMsg);
      this.initAvailableTime();
      this.availableTime?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`availableTime\` property exists and has a value; \`false\` otherwise
   */
  public hasAvailableTime(): boolean {
    return isDefinedList<PractitionerRoleAvailableTimeComponent>(this.availableTime) && this.availableTime.some((item: PractitionerRoleAvailableTimeComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`availableTime\` property
   */
  private initAvailableTime(): void {
    if(!this.hasAvailableTime()) {
      this.availableTime = [] as PractitionerRoleAvailableTimeComponent[];
    }
  }

  /**
   * @returns the \`notAvailable\` property value as a PractitionerRoleNotAvailableComponent array
   */
  public getNotAvailable(): PractitionerRoleNotAvailableComponent[] {
    return this.notAvailable ?? ([] as PractitionerRoleNotAvailableComponent[]);
  }

  /**
   * Assigns the provided PractitionerRoleNotAvailableComponent array value to the \`notAvailable\` property.
   *
   * @param value - the \`notAvailable\` array value
   * @returns this
   */
  public setNotAvailable(value: PractitionerRoleNotAvailableComponent[] | undefined): this {
    if (isDefinedList<PractitionerRoleNotAvailableComponent>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.notAvailable; Provided value array has an element that is not an instance of PractitionerRoleNotAvailableComponent.\`;
      assertFhirTypeList<PractitionerRoleNotAvailableComponent>(value, PractitionerRoleNotAvailableComponent, optErrMsg);
      this.notAvailable = value;
    } else {
      this.notAvailable = undefined;
    }
    return this;
  }

  /**
   * Add the provided PractitionerRoleNotAvailableComponent value to the \`notAvailable\` array property.
   *
   * @param value - the \`notAvailable\` value
   * @returns this
   */
  public addNotAvailable(value: PractitionerRoleNotAvailableComponent | undefined): this {
    if (isDefined<PractitionerRoleNotAvailableComponent>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.notAvailable; Provided element is not an instance of PractitionerRoleNotAvailableComponent.\`;
      assertFhirType<PractitionerRoleNotAvailableComponent>(value, PractitionerRoleNotAvailableComponent, optErrMsg);
      this.initNotAvailable();
      this.notAvailable?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`notAvailable\` property exists and has a value; \`false\` otherwise
   */
  public hasNotAvailable(): boolean {
    return isDefinedList<PractitionerRoleNotAvailableComponent>(this.notAvailable) && this.notAvailable.some((item: PractitionerRoleNotAvailableComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`notAvailable\` property
   */
  private initNotAvailable(): void {
    if(!this.hasNotAvailable()) {
      this.notAvailable = [] as PractitionerRoleNotAvailableComponent[];
    }
  }

  /**
   * @returns the \`availabilityExceptions\` property value as a StringType object if defined; else an empty StringType object
   */
  public getAvailabilityExceptionsElement(): StringType {
    return this.availabilityExceptions ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`availabilityExceptions\` property.
   *
   * @param element - the \`availabilityExceptions\` value
   * @returns this
   */
  public setAvailabilityExceptionsElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid PractitionerRole.availabilityExceptions; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.availabilityExceptions = element;
    } else {
      this.availabilityExceptions = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`availabilityExceptions\` property exists and has a value; \`false\` otherwise
   */
  public hasAvailabilityExceptionsElement(): boolean {
    return isDefined<StringType>(this.availabilityExceptions) && !this.availabilityExceptions.isEmpty();
  }

  /**
   * @returns the \`availabilityExceptions\` property value as a fhirString if defined; else undefined
   */
  public getAvailabilityExceptions(): fhirString | undefined {
    return this.availabilityExceptions?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`availabilityExceptions\` property.
   *
   * @param value - the \`availabilityExceptions\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setAvailabilityExceptions(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.availabilityExceptions (\${String(value)})\`;
      this.availabilityExceptions = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.availabilityExceptions = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`availabilityExceptions\` property exists and has a value; \`false\` otherwise
   */
  public hasAvailabilityExceptions(): boolean {
    return this.hasAvailabilityExceptionsElement();
  }

  /**
   * @returns the \`endpoint\` property value as a Reference array
   */
  public getEndpoint(): Reference[] {
    return this.endpoint ?? ([] as Reference[]);
  }

  /**
   * Assigns the provided Reference array value to the \`endpoint\` property.
   *
   * @decorator \`@ReferenceTargets('PractitionerRole.endpoint', ['Endpoint',])\`
   *
   * @param value - the \`endpoint\` array value
   * @returns this
   */
  @ReferenceTargets('PractitionerRole.endpoint', [
    'Endpoint',
  ])
  public setEndpoint(value: Reference[] | undefined): this {
    if (isDefinedList<Reference>(value)) {
      // assertFhirTypeList<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.endpoint = value;
    } else {
      this.endpoint = undefined;
    }
    return this;
  }

  /**
   * Add the provided Reference value to the \`endpoint\` array property.
   *
   * @decorator \`@ReferenceTargets('PractitionerRole.endpoint', ['Endpoint',])\`
   *
   * @param value - the \`endpoint\` value
   * @returns this
   */
  @ReferenceTargets('PractitionerRole.endpoint', [
    'Endpoint',
  ])
  public addEndpoint(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.initEndpoint();
      this.endpoint?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`endpoint\` property exists and has a value; \`false\` otherwise
   */
  public hasEndpoint(): boolean {
    return isDefinedList<Reference>(this.endpoint) && this.endpoint.some((item: Reference) => !item.isEmpty());
  }

  /**
   * Initialize the \`endpoint\` property
   */
  private initEndpoint(): void {
    if (!this.hasEndpoint()) {
      this.endpoint = [] as Reference[];
    }
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'PractitionerRole';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.identifier,
      this.active,
      this.period,
      this.practitioner,
      this.organization,
      this.code,
      this.specialty,
      this.location,
      this.healthcareService,
      this.telecom,
      this.availableTime,
      this.notAvailable,
      this.availabilityExceptions,
      this.endpoint,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): PractitionerRole {
    const dest = new PractitionerRole();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: PractitionerRole): void {
    super.copyValues(dest);
    const identifierList = copyListValues<Identifier>(this.identifier);
    dest.identifier = identifierList.length === 0 ? undefined : identifierList;
    dest.active = this.active?.copy();
    dest.period = this.period?.copy();
    dest.practitioner = this.practitioner?.copy();
    dest.organization = this.organization?.copy();
    const codeList = copyListValues<CodeableConcept>(this.code);
    dest.code = codeList.length === 0 ? undefined : codeList;
    const specialtyList = copyListValues<CodeableConcept>(this.specialty);
    dest.specialty = specialtyList.length === 0 ? undefined : specialtyList;
    const locationList = copyListValues<Reference>(this.location);
    dest.location = locationList.length === 0 ? undefined : locationList;
    const healthcareServiceList = copyListValues<Reference>(this.healthcareService);
    dest.healthcareService = healthcareServiceList.length === 0 ? undefined : healthcareServiceList;
    const telecomList = copyListValues<ContactPoint>(this.telecom);
    dest.telecom = telecomList.length === 0 ? undefined : telecomList;
    const availableTimeList = copyListValues<PractitionerRoleAvailableTimeComponent>(this.availableTime);
    dest.availableTime = availableTimeList.length === 0 ? undefined : availableTimeList;
    const notAvailableList = copyListValues<PractitionerRoleNotAvailableComponent>(this.notAvailable);
    dest.notAvailable = notAvailableList.length === 0 ? undefined : notAvailableList;
    dest.availabilityExceptions = this.availabilityExceptions?.copy();
    const endpointList = copyListValues<Reference>(this.endpoint);
    dest.endpoint = endpointList.length === 0 ? undefined : endpointList;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasIdentifier()) {
      setFhirComplexListJson(this.getIdentifier(), 'identifier', jsonObj);
    }

    if (this.hasActiveElement()) {
      setFhirPrimitiveJson<fhirBoolean>(this.getActiveElement(), 'active', jsonObj);
    }

    if (this.hasPeriod()) {
      setFhirComplexJson(this.getPeriod(), 'period', jsonObj);
    }

    if (this.hasPractitioner()) {
      setFhirComplexJson(this.getPractitioner(), 'practitioner', jsonObj);
    }

    if (this.hasOrganization()) {
      setFhirComplexJson(this.getOrganization(), 'organization', jsonObj);
    }

    if (this.hasCode()) {
      setFhirComplexListJson(this.getCode(), 'code', jsonObj);
    }

    if (this.hasSpecialty()) {
      setFhirComplexListJson(this.getSpecialty(), 'specialty', jsonObj);
    }

    if (this.hasLocation()) {
      setFhirComplexListJson(this.getLocation(), 'location', jsonObj);
    }

    if (this.hasHealthcareService()) {
      setFhirComplexListJson(this.getHealthcareService(), 'healthcareService', jsonObj);
    }

    if (this.hasTelecom()) {
      setFhirComplexListJson(this.getTelecom(), 'telecom', jsonObj);
    }

    if (this.hasAvailableTime()) {
      setFhirBackboneElementListJson(this.getAvailableTime(), 'availableTime', jsonObj);
    }

    if (this.hasNotAvailable()) {
      setFhirBackboneElementListJson(this.getNotAvailable(), 'notAvailable', jsonObj);
    }

    if (this.hasAvailabilityExceptionsElement()) {
      setFhirPrimitiveJson<fhirString>(this.getAvailabilityExceptionsElement(), 'availabilityExceptions', jsonObj);
    }

    if (this.hasEndpoint()) {
      setFhirComplexListJson(this.getEndpoint(), 'endpoint', jsonObj);
    }

    return jsonObj;
  }
}


/**
 * PractitionerRoleAvailableTimeComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Times the Service Site is available
 * - **Definition:** A collection of times the practitioner is available or performing this role at the location and/or healthcareservice.
 * - **Comment:** More detailed availability information may be provided in associated Schedule/Slot resources.
 *
 * @category DataModel: Resource
 * @see [FHIR PractitionerRole](http://hl7.org/fhir/StructureDefinition/PractitionerRole)
 */
export class PractitionerRoleAvailableTimeComponent extends BackboneElement {
  constructor() {
    super();

    this.daysOfWeekEnum = new DaysOfWeekEnum();
  }

  /**
   * Parse the provided \`PractitionerRoleAvailableTimeComponent\` JSON to instantiate the PractitionerRoleAvailableTimeComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`PractitionerRoleAvailableTimeComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to PractitionerRoleAvailableTimeComponent
   * @returns PractitionerRoleAvailableTimeComponent data model or undefined for \`PractitionerRoleAvailableTimeComponent\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): PractitionerRoleAvailableTimeComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'PractitionerRoleAvailableTimeComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new PractitionerRoleAvailableTimeComponent();
    fhirDataTypeParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'daysOfWeek';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: CodeType | undefined = parseCodeType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addDaysOfWeekElement(datatype);
        }
      });
    }

    fieldName = 'allDay';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'boolean';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: BooleanType | undefined = parseBooleanType(dtJson, dtSiblingJson);
      instance.setAllDayElement(datatype);
    }

    fieldName = 'availableStartTime';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: TimeType | undefined = parseTimeType(dtJson, dtSiblingJson);
      instance.setAvailableStartTimeElement(datatype);
    }

    fieldName = 'availableEndTime';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: TimeType | undefined = parseTimeType(dtJson, dtSiblingJson);
      instance.setAvailableEndTimeElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: DaysOfWeek
   *
   * @see {@link DaysOfWeekEnum }
   */
  private readonly daysOfWeekEnum: DaysOfWeekEnum;

  /**
   * PractitionerRole.availableTime.daysOfWeek Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** mon | tue | wed | thu | fri | sat | sun
   * - **Definition:** Indicates which days of the week are available between the start and end Times.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private daysOfWeek?: EnumCodeType[] | undefined;

  /**
   * PractitionerRole.availableTime.allDay Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Always available? e.g. 24 hour service
   * - **Definition:** Is this always available? (hence times are irrelevant) e.g. 24 hour service.
   * - **FHIR Type:** \`boolean\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private allDay?: BooleanType | undefined;

  /**
   * PractitionerRole.availableTime.availableStartTime Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Opening time of day (ignored if allDay = true)
   * - **Definition:** The opening time of day. Note: If the AllDay flag is set, then this time is ignored.
   * - **Comment:** The timezone is expected to be for where this HealthcareService is provided at.
   * - **FHIR Type:** \`time\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private availableStartTime?: TimeType | undefined;

  /**
   * PractitionerRole.availableTime.availableEndTime Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Closing time of day (ignored if allDay = true)
   * - **Definition:** The closing time of day. Note: If the AllDay flag is set, then this time is ignored.
   * - **Comment:** The timezone is expected to be for where this HealthcareService is provided at.
   * - **FHIR Type:** \`time\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private availableEndTime?: TimeType | undefined;


  /**
   * @returns the \`daysOfWeek\` property value as a EnumCodeType array
   */
  public getDaysOfWeekEnumType(): EnumCodeType[] {
    return this.daysOfWeek ?? ([] as EnumCodeType[]);
  }

  /**
   * Assigns the provided EnumCodeType array value to the \`daysOfWeek\` property.
   *
   * @param enumType - the \`daysOfWeek\` array value
   * @returns this
   */
  public setDaysOfWeekEnumType(enumType: EnumCodeType[] | undefined): this {
    if (isDefinedList<EnumCodeType>(enumType)) {
      const errMsgPrefix = \`Invalid PractitionerRole.availableTime.daysOfWeek\`;
      assertEnumCodeTypeList<DaysOfWeekEnum>(enumType, DaysOfWeekEnum, errMsgPrefix);
      this.daysOfWeek = enumType;
    } else {
      this.daysOfWeek = undefined;
    }
    return this;
  }

  /**
   * Add the provided EnumCodeType value to the \`daysOfWeek\` array property.
   *
   * @param enumType - the \`daysOfWeek\` value
   * @returns this
   */
  public addDaysOfWeekEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = \`Invalid PractitionerRole.availableTime.daysOfWeek)\`;
      assertEnumCodeType<DaysOfWeekEnum>(enumType, DaysOfWeekEnum, errMsgPrefix);
      this.initDaysOfWeek();
      this.daysOfWeek?.push(enumType);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`daysOfWeek\` property exists and has a value; \`false\` otherwise
   */
  public hasDaysOfWeekEnumType(): boolean {
    return isDefinedList<EnumCodeType>(this.daysOfWeek) && this.daysOfWeek.some((item: EnumCodeType) => !item.isEmpty()) && this.daysOfWeek.every((item: EnumCodeType) => item.fhirCodeEnumeration.length > 0);
  }

  /**
   * @returns the \`daysOfWeek\` property value as a CodeType array
   */
  public getDaysOfWeekElement(): CodeType[] {
    if (this.daysOfWeek === undefined) {
      return [] as CodeType[];
    }
    return this.daysOfWeek as CodeType[];
  }

  /**
   * Assigns the provided PrimitiveType array value to the \`daysOfWeek\` property.
   *
   * @param element - the \`daysOfWeek\` array value
   * @returns this
   */
  public setDaysOfWeekElement(element: CodeType[] | undefined): this {
    if (isDefinedList<CodeType>(element)) {
      const optErrMsg = \`Invalid PractitionerRole.availableTime.daysOfWeek; Provided element array has an element that is not an instance of CodeType.\`;
      assertFhirTypeList<CodeType>(element, CodeType, optErrMsg);
      const enumCodeTypes = [] as EnumCodeType[];
      element.forEach((type: CodeType) => {
        enumCodeTypes.push(new EnumCodeType(type, this.daysOfWeekEnum));
      });
      this.daysOfWeek = enumCodeTypes;
    } else {
      this.daysOfWeek = undefined;
    }
    return this;
  }

  /**
   * Add the provided PrimitiveType value to the \`daysOfWeek\` array property.
   *
   * @param element - the \`daysOfWeek\` value
   * @returns this
   */
  public addDaysOfWeekElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid PractitionerRole.availableTime.daysOfWeek; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.initDaysOfWeek();
      this.daysOfWeek?.push(new EnumCodeType(element, this.daysOfWeekEnum));
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`daysOfWeek\` property exists and has a value; \`false\` otherwise
   */
  public hasDaysOfWeekElement(): boolean {
    return this.hasDaysOfWeekEnumType();
  }

  /**
   * @returns the \`daysOfWeek\` property value as a fhirCode array
   */
  public getDaysOfWeek(): fhirCode[] {
    if (this.daysOfWeek === undefined) {
      return [] as fhirCode[];
    }
    const values = [] as fhirCode[];
    for (const item of this.daysOfWeek) {
      values.push(item.fhirCode.code);
    }
    return values;
  }

  /**
   * Assigns the provided primitive value array to the \`daysOfWeek\` property.
   *
   * @param value - the \`daysOfWeek\` value array
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setDaysOfWeek(value: fhirCode[] | undefined): this {
    if (isDefinedList<fhirCode>(value)) {
      const enumCodeTypes = [] as EnumCodeType[];
      const optErrMsg = \`Invalid PractitionerRole.availableTime.daysOfWeek; Provided value is not an instance of fhirCode.\`;
      value.forEach((val: fhirCode) => {
        enumCodeTypes.push(new EnumCodeType(parseFhirPrimitiveData(val, fhirCodeSchema, optErrMsg), this.daysOfWeekEnum));
      });
      this.daysOfWeek = enumCodeTypes;
    } else {
      this.daysOfWeek = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`daysOfWeek\` array property.
   *
   * @param value - the \`daysOfWeek\` value
   * @returns this
   */
  public addDaysOfWeek(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      this.initDaysOfWeek();
      const optErrMsg = \`Invalid PractitionerRole.availableTime.daysOfWeek; Provided value is not an instance of fhirCode.\`;
      this.daysOfWeek?.push(new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.daysOfWeekEnum));
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`daysOfWeek\` property exists and has a value; \`false\` otherwise
   */
  public hasDaysOfWeek(): boolean {
    return this.hasDaysOfWeekEnumType();
  }

  /**
   * Initialize the daysOfWeek property
   */
  private initDaysOfWeek(): void {
    if(!this.hasDaysOfWeekEnumType()) {
      this.daysOfWeek = [] as EnumCodeType[];
    }
  }

  /**
   * @returns the \`allDay\` property value as a BooleanType object if defined; else an empty BooleanType object
   */
  public getAllDayElement(): BooleanType {
    return this.allDay ?? new BooleanType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`allDay\` property.
   *
   * @param element - the \`allDay\` value
   * @returns this
   */
  public setAllDayElement(element: BooleanType | undefined): this {
    if (isDefined<BooleanType>(element)) {
      const optErrMsg = \`Invalid PractitionerRole.availableTime.allDay; Provided element is not an instance of BooleanType.\`;
      assertFhirType<BooleanType>(element, BooleanType, optErrMsg);
      this.allDay = element;
    } else {
      this.allDay = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`allDay\` property exists and has a value; \`false\` otherwise
   */
  public hasAllDayElement(): boolean {
    return isDefined<BooleanType>(this.allDay) && !this.allDay.isEmpty();
  }

  /**
   * @returns the \`allDay\` property value as a fhirBoolean if defined; else undefined
   */
  public getAllDay(): fhirBoolean | undefined {
    return this.allDay?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`allDay\` property.
   *
   * @param value - the \`allDay\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setAllDay(value: fhirBoolean | undefined): this {
    if (isDefined<fhirBoolean>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.availableTime.allDay (\${String(value)})\`;
      this.allDay = new BooleanType(parseFhirPrimitiveData(value, fhirBooleanSchema, optErrMsg));
    } else {
      this.allDay = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`allDay\` property exists and has a value; \`false\` otherwise
   */
  public hasAllDay(): boolean {
    return this.hasAllDayElement();
  }

  /**
   * @returns the \`availableStartTime\` property value as a TimeType object if defined; else an empty TimeType object
   */
  public getAvailableStartTimeElement(): TimeType {
    return this.availableStartTime ?? new TimeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`availableStartTime\` property.
   *
   * @param element - the \`availableStartTime\` value
   * @returns this
   */
  public setAvailableStartTimeElement(element: TimeType | undefined): this {
    if (isDefined<TimeType>(element)) {
      const optErrMsg = \`Invalid PractitionerRole.availableTime.availableStartTime; Provided element is not an instance of TimeType.\`;
      assertFhirType<TimeType>(element, TimeType, optErrMsg);
      this.availableStartTime = element;
    } else {
      this.availableStartTime = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`availableStartTime\` property exists and has a value; \`false\` otherwise
   */
  public hasAvailableStartTimeElement(): boolean {
    return isDefined<TimeType>(this.availableStartTime) && !this.availableStartTime.isEmpty();
  }

  /**
   * @returns the \`availableStartTime\` property value as a fhirTime if defined; else undefined
   */
  public getAvailableStartTime(): fhirTime | undefined {
    return this.availableStartTime?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`availableStartTime\` property.
   *
   * @param value - the \`availableStartTime\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setAvailableStartTime(value: fhirTime | undefined): this {
    if (isDefined<fhirTime>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.availableTime.availableStartTime (\${String(value)})\`;
      this.availableStartTime = new TimeType(parseFhirPrimitiveData(value, fhirTimeSchema, optErrMsg));
    } else {
      this.availableStartTime = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`availableStartTime\` property exists and has a value; \`false\` otherwise
   */
  public hasAvailableStartTime(): boolean {
    return this.hasAvailableStartTimeElement();
  }

  /**
   * @returns the \`availableEndTime\` property value as a TimeType object if defined; else an empty TimeType object
   */
  public getAvailableEndTimeElement(): TimeType {
    return this.availableEndTime ?? new TimeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`availableEndTime\` property.
   *
   * @param element - the \`availableEndTime\` value
   * @returns this
   */
  public setAvailableEndTimeElement(element: TimeType | undefined): this {
    if (isDefined<TimeType>(element)) {
      const optErrMsg = \`Invalid PractitionerRole.availableTime.availableEndTime; Provided element is not an instance of TimeType.\`;
      assertFhirType<TimeType>(element, TimeType, optErrMsg);
      this.availableEndTime = element;
    } else {
      this.availableEndTime = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`availableEndTime\` property exists and has a value; \`false\` otherwise
   */
  public hasAvailableEndTimeElement(): boolean {
    return isDefined<TimeType>(this.availableEndTime) && !this.availableEndTime.isEmpty();
  }

  /**
   * @returns the \`availableEndTime\` property value as a fhirTime if defined; else undefined
   */
  public getAvailableEndTime(): fhirTime | undefined {
    return this.availableEndTime?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`availableEndTime\` property.
   *
   * @param value - the \`availableEndTime\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setAvailableEndTime(value: fhirTime | undefined): this {
    if (isDefined<fhirTime>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.availableTime.availableEndTime (\${String(value)})\`;
      this.availableEndTime = new TimeType(parseFhirPrimitiveData(value, fhirTimeSchema, optErrMsg));
    } else {
      this.availableEndTime = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`availableEndTime\` property exists and has a value; \`false\` otherwise
   */
  public hasAvailableEndTime(): boolean {
    return this.hasAvailableEndTimeElement();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'PractitionerRole.availableTime';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.daysOfWeek,
      this.allDay,
      this.availableStartTime,
      this.availableEndTime,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): PractitionerRoleAvailableTimeComponent {
    const dest = new PractitionerRoleAvailableTimeComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: PractitionerRoleAvailableTimeComponent): void {
    super.copyValues(dest);
    const daysOfWeekList = copyListValues<EnumCodeType>(this.daysOfWeek);
    dest.daysOfWeek = daysOfWeekList.length === 0 ? undefined : daysOfWeekList;
    dest.allDay = this.allDay?.copy();
    dest.availableStartTime = this.availableStartTime?.copy();
    dest.availableEndTime = this.availableEndTime?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasDaysOfWeekElement()) {
      setFhirPrimitiveListJson<fhirCode>(this.getDaysOfWeekElement(), 'daysOfWeek', jsonObj);
    }

    if (this.hasAllDayElement()) {
      setFhirPrimitiveJson<fhirBoolean>(this.getAllDayElement(), 'allDay', jsonObj);
    }

    if (this.hasAvailableStartTimeElement()) {
      setFhirPrimitiveJson<fhirTime>(this.getAvailableStartTimeElement(), 'availableStartTime', jsonObj);
    }

    if (this.hasAvailableEndTimeElement()) {
      setFhirPrimitiveJson<fhirTime>(this.getAvailableEndTimeElement(), 'availableEndTime', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * PractitionerRoleNotAvailableComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Not available during this time due to provided reason
 * - **Definition:** The practitioner is not available or performing this role during this period of time due to the provided reason.
 *
 * @category DataModel: Resource
 * @see [FHIR PractitionerRole](http://hl7.org/fhir/StructureDefinition/PractitionerRole)
 */
export class PractitionerRoleNotAvailableComponent extends BackboneElement {
  constructor(description: StringType | fhirString | null = null) {
    super();

    this.description = null;
    if (isDefined<StringType | fhirString>(description)) {
      if (description instanceof PrimitiveType) {
        this.setDescriptionElement(description);
      } else {
        this.setDescription(description);
      }
    }
  }

  /**
   * Parse the provided \`PractitionerRoleNotAvailableComponent\` JSON to instantiate the PractitionerRoleNotAvailableComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`PractitionerRoleNotAvailableComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to PractitionerRoleNotAvailableComponent
   * @returns PractitionerRoleNotAvailableComponent data model or undefined for \`PractitionerRoleNotAvailableComponent\`
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): PractitionerRoleNotAvailableComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const fhirDataTypeParser = new FhirDataTypeParser(PARSABLE_DATATYPE_MAP);

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'PractitionerRoleNotAvailableComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new PractitionerRoleNotAvailableComponent();
    fhirDataTypeParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    

    const missingReqdProperties: string[] = [];

    fieldName = 'description';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = parseStringType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setDescriptionElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'during';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Period | undefined = fhirDataTypeParser.parser<Period>(Period, classJsonObj[fieldName]!, sourceField);
      instance.setDuring(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * PractitionerRole.notAvailable.description Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Reason presented to the user explaining why time not available
   * - **Definition:** The reason that can be presented to the user as to why this time is not available.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private description: StringType | null;

  /**
   * PractitionerRole.notAvailable.during Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Service not available from this date
   * - **Definition:** Service is not available (seasonally or for a public holiday) from this date.
   * - **FHIR Type:** \`Period\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private during?: Period | undefined;


  /**
   * @returns the \`description\` property value as a StringType object if defined; else null
   */
  public getDescriptionElement(): StringType | null {
    return this.description;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`description\` property.
   *
   * @param element - the \`description\` value
   * @returns this
   */
  public setDescriptionElement(element: StringType): this {
    assertIsDefined<StringType>(element, \`PractitionerRole.notAvailable.description is required\`);
    const optErrMsg = \`Invalid PractitionerRole.notAvailable.description; Provided value is not an instance of StringType.\`;
    assertFhirType<StringType>(element, StringType, optErrMsg);
    this.description = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`description\` property exists and has a value; \`false\` otherwise
   */
  public hasDescriptionElement(): boolean {
    return isDefined<StringType>(this.description) && !this.description.isEmpty();
  }

  /**
   * @returns the \`description\` property value as a fhirString if defined; else null
   */
  public getDescription(): fhirString | null {
    if (this.description?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.description.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`description\` property.
   *
   * @param value - the \`description\` value
   * @returns this
   * @throws PrimitiveTypeError for invalid primitive types
   */
  public setDescription(value: fhirString): this {
    assertIsDefined<fhirString>(value, \`PractitionerRole.notAvailable.description is required\`);
    const optErrMsg = \`Invalid PractitionerRole.notAvailable.description (\${String(value)})\`;
    this.description = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`description\` property exists and has a value; \`false\` otherwise
   */
  public hasDescription(): boolean {
    return this.hasDescriptionElement();
  }

  /**
   * @returns the \`during\` property value as a Period object if defined; else an empty Period object
   */
  public getDuring(): Period {
    return this.during ?? new Period();
  }

  /**
   * Assigns the provided During object value to the \`during\` property.
   *
   * @param value - the \`during\` object value
   * @returns this
   */
  public setDuring(value: Period | undefined): this {
    if (isDefined<Period>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.notAvailable.during; Provided element is not an instance of Period.\`;
      assertFhirType<Period>(value, Period, optErrMsg);
      this.during = value;
    } else {
      this.during = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`during\` property exists and has a value; \`false\` otherwise
   */
  public hasDuring(): boolean {
    return isDefined<Period>(this.during) && !this.during.isEmpty();
  }


  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'PractitionerRole.notAvailable';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.description,
      this.during,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): PractitionerRoleNotAvailableComponent {
    const dest = new PractitionerRoleNotAvailableComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: PractitionerRoleNotAvailableComponent): void {
    super.copyValues(dest);
    dest.description = this.description ? this.description.copy() : null;
    dest.during = this.during?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasDescriptionElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirString>(this.getDescriptionElement()!, 'description', jsonObj);
    } else {
      missingReqdProperties.push(\`PractitionerRole.notAvailable.description\`);
    }

    if (this.hasDuring()) {
      setFhirComplexJson(this.getDuring(), 'during', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
",
  "fileExtension": "ts",
  "filename": "PractitionerRole",
}
`;

exports[`src/generator-app unit test suite generator-app verify generated content should consistently create GeneratedContent[] 25`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/test-out",
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/utest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "Resource",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from by the FHIR Package Generator.
 * DO NOT make any modifications!
 * 
 * resource-types.ts Module
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

/**
 * FHIR resource types
 *
 * @remarks
 * All defined FHIR resources that ultimately extend from Resource.
 *
 * @category Type Guards/Assertions
 */
export const RESOURCE_TYPES = [
  'Bundle',
  'PractitionerRole',
  'Resource',
] as const;
",
  "fileExtension": "ts",
  "filename": "resource-types",
}
`;

exports[`src/generator-app unit test suite generator-app verify generated content should consistently create GeneratedContent[] 26`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/test-out",
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/utest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "Resource",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from by the FHIR Package Generator.
 * DO NOT make any modifications!
 * 
 * parsable-resource-map.ts Module
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { Resource, ParsableResource } from '../base';
import { Bundle } from './Bundle';
import { PractitionerRole } from './PractitionerRole';

/**
 * PARSABLE_RESOURCE_MAP
 *
 * @remarks
 * Map of all parsable Resources where the key is the name of the Resource and the value is its ParsableResource<Resource> class.
 *
 * @category Utilities: FHIR Parsers
 */
export const PARSABLE_RESOURCE_MAP = new Map<string, ParsableResource<Resource>>();
PARSABLE_RESOURCE_MAP.set('Bundle', Bundle);
PARSABLE_RESOURCE_MAP.set('PractitionerRole', PractitionerRole);
",
  "fileExtension": "ts",
  "filename": "parsable-resource-map",
}
`;

exports[`src/generator-app unit test suite generator-app verify generated content should consistently create GeneratedContent[] 27`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/test-out",
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/generator/src/__test__/unit-test/utest-cache",
    "pkgName": "test.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "Resource",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from by the FHIR Package Generator.
 * DO NOT make any modifications!
 * 
 * index.ts Module
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

export * from './Bundle';
export * from './PractitionerRole';
export * from './parsable-resource-map';
export * from './resource-types';
",
  "fileExtension": "ts",
  "filename": "index",
}
`;
