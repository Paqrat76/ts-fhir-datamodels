/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/*
 * [ORIGINAL LICENSE](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/LICENSE):
 *
 * This project is licensed under the MIT license.
 * Copyrights are respective of each contributor listed at the beginning of each definition file.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
 * to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
 * TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 */

/**
 * This FHIR interfaces file was cloned from the [@types/fhir r5.d.ts](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/fhir/r5.d.ts).
 *
 * The source file (@types/fhir r5.d.ts) is generated from HL7 FHIR R5 artifacts that are considered "locked down".
 * The risk of the source file changing and thereby differing from the cloned content here is extremely low. Unless
 * we discover an error in a specific interface, there should be no need to consider any changes to this content.
 * Additionally, we only need to focus on FHIR `StructureDefinition`, `ValueSet`, and `CodeSystem` and their dependent
 * data types. Since these resources' maturity level were "normative" in FHIR R4, we are not concerned with breaking
 * changes in FHIR releases that come after FHIR R4.
 *
 * All resources not required for the [`fhir-package-loader` library](https://github.com/FHIR/fhir-package-loader)
 * were removed.
 *
 * This file was modified to satisfy this project's ESLint and Prettier configurations.
 *
 * Usage: `import * as fhir from './fhir-artifact-interfaces';`
 *        Access an interface: `fhir.StructureDefinition`
 */

// cloned from the @types/fhir r5.d.ts:
// <auto-generated/>
// Contents of: hl7.fhir.r5.core version: 5.0.0
// Primitive Naming Style: None
// Complex Type / Resource Naming Style: PascalCase
// Interaction Naming Style: None
// Extension Support: NonPrimitive
// Language option: "namespace" = "true"
//export as namespace fhir5;

/* eslint-disable @typescript-eslint/no-empty-object-type */

/**
 * Base definition for all types defined in FHIR type system.
 */
export interface Base {}
/**
 * Base definition for all elements in a resource.
 */
export interface Element {
  /**
   * There can be no stigma associated with the use of extensions by any application, project, or standard - regardless of the institution or jurisdiction that uses or defines the extensions.  The use of extensions is what allows the FHIR specification to retain a core level of simplicity for everyone.
   */
  extension?: Extension[] | undefined;
  /**
   * Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
   */
  id?: string | undefined;
  _id?: Element | undefined;
}
/**
 * The base class for all re-useable types defined as part of the FHIR Specification.
 */
export interface DataType extends Element {}
/**
 * Base definition for all elements that are defined inside a resource - but not those in a data type.
 */
export interface BackboneElement extends Element {
  /**
   * There can be no stigma associated with the use of extensions by any application, project, or standard - regardless of the institution or jurisdiction that uses or defines the extensions.  The use of extensions is what allows the FHIR specification to retain a core level of simplicity for everyone.
   */
  modifierExtension?: Extension[] | undefined;
}
/**
 * Base definition for the few data types that are allowed to carry modifier extensions.
 */
export interface BackboneType extends DataType {
  /**
   * There can be no stigma associated with the use of extensions by any application, project, or standard - regardless of the institution or jurisdiction that uses or defines the extensions.  The use of extensions is what allows the FHIR specification to retain a core level of simplicity for everyone.
   */
  modifierExtension?: Extension[] | undefined;
}

/**
 * If there is no discriminator, the content is hard to process, so this should be avoided.
 */
export interface ElementDefinitionSlicingDiscriminator extends Element {
  /**
   * A FHIRPath expression, using [the simple subset of FHIRPath](fhirpath.html#simple), that is used to identify the element on which discrimination is based.
   */
  path: string;
  _path?: Element | undefined;
  /**
   * 'pattern' is deprecated - it works exactly the same as 'value'.
   */
  type: 'value' | 'exists' | 'type' | 'profile' | 'position' | 'pattern';
  _type?: Element | undefined;
}
/**
 * The first element in the sequence, the one that carries the slicing, is the definition that applies to all the slices. This is based on the unconstrained element, but can apply any constraints as appropriate. This may include the common constraints on the children of the element.
 */
export interface ElementDefinitionSlicing extends Element {
  /**
   * If it's really not possible to differentiate them, the design should be re-evaluated to make the content usable.
   */
  description?: string | undefined;
  _description?: Element | undefined;
  /**
   * If there is no discriminator, the content is hard to process, so this should be avoided.
   */
  discriminator?: ElementDefinitionSlicingDiscriminator[] | undefined;
  /**
   * Order should only be required when it is a pressing concern for presentation. Profile authors should consider making the order a feature of the rules about the narrative, not the rules about the data - requiring ordered data makes the profile much less re-usable.
   */
  ordered?: boolean | undefined;
  _ordered?: Element | undefined;
  /**
   * Allowing additional elements makes for a much for flexible template - it's open for use in wider contexts, but also means that the content of the resource is not closed, and applications have to decide how to handle content not described by the profile.
   */
  rules: 'closed' | 'open' | 'openAtEnd';
  _rules?: Element | undefined;
}
/**
 * The base information does not carry any information that could not be determined from the path and related profiles, but making this determination requires both that the related profiles are available, and that the algorithm to determine them be available. For tooling simplicity, the base information must always be populated in element definitions in snap shots, even if it is the same.
 */
export interface ElementDefinitionBase extends Element {
  /**
   * This is provided to code generation, since the serialization representation in JSON differs depending on whether the base element has max > 1. Also, some forms of code generation may differ.
   */
  max: string;
  _max?: Element | undefined;
  /**
   * This is provided for consistency with max, and may affect code generation of mandatory elements of the base resource are generated differently (some reference implementations have done this).
   */
  min: number;
  /**
   * The Path that identifies the base element - this matches the ElementDefinition.path for that element. Across FHIR, there is only one base definition of any element - that is, an element definition on a [StructureDefinition](structuredefinition.html#) without a StructureDefinition.base.
   */
  path: string;
  _path?: Element | undefined;
}
/**
 * The Type of the element can be left blank in a differential constraint, in which case the type is inherited from the resource. Abstract types are not permitted to appear as a type when multiple types are listed.  (I.e. Abstract types cannot be part of a choice).
 */
export interface ElementDefinitionType extends Element {
  /**
   * See [Aggregation Rules](elementdefinition.html#aggregation) for further clarification.
   */
  aggregation?: ('contained' | 'referenced' | 'bundled')[] | undefined;
  _aggregation?: Element[] | undefined;
  /**
   * If the element is a reference to another resource, this element contains "Reference", and the targetProfile element defines what resources can be referenced. The targetProfile may be a reference to the general definition of a resource (e.g. http://hl7.org/fhir/StructureDefinition/Patient).
   */
  code: string;
  _code?: Element | undefined;
  /**
   * It is possible to profile  backbone element (e.g. part of a resource), using the [http://hl7.org/fhir/StructureDefinition/elementdefinition-profile-element](http://hl7.org/fhir/extensions/StructureDefinition-elementdefinition-profile-element.html) extension.
   */
  profile?: string[] | undefined;
  _profile?: Element[] | undefined;
  /**
   * Used when the type is "Reference" or "canonical", and identifies a profile structure or implementation Guide that applies to the target of the reference this element refers to. If any profiles are specified, then the content must conform to at least one of them. The URL can be a local reference - to a contained StructureDefinition, or a reference to another StructureDefinition or Implementation Guide by a canonical URL. When an implementation guide is specified, the target resource SHALL conform to at least one profile defined in the implementation guide.
   */
  targetProfile?: string[] | undefined;
  _targetProfile?: Element[] | undefined;
  /**
   * The base specification never makes a rule as to which form is allowed, but implementation guides may do this. See [Aggregation Rules](elementdefinition.html#aggregation) for further clarification.
   */
  versioning?: ('either' | 'independent' | 'specific') | undefined;
  _versioning?: Element | undefined;
}
/**
 * Examples will most commonly be present for data where it's not implicitly obvious from either the data type or value set what the values might be.  (I.e. Example values for dates or quantities would generally be unnecessary.)  If the example value is fully populated, the publication tool can generate an instance automatically.
 */
export interface ElementDefinitionExample extends Element {
  /**
   * Describes the purpose of this example among the set of examples.
   */
  label: string;
  _label?: Element | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueBase64Binary?: string | undefined;
  _valueBase64Binary?: Element | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueBoolean?: boolean | undefined;
  _valueBoolean?: Element | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueCanonical?: string | undefined;
  _valueCanonical?: Element | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueCode?: string | undefined;
  _valueCode?: Element | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueDate?: string | undefined;
  _valueDate?: Element | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueDateTime?: string | undefined;
  _valueDateTime?: Element | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueDecimal?: number | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueId?: string | undefined;
  _valueId?: Element | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueInstant?: string | undefined;
  _valueInstant?: Element | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueInteger?: number | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueInteger64?: string | undefined;
  _valueInteger64?: Element | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueMarkdown?: string | undefined;
  _valueMarkdown?: Element | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueOid?: string | undefined;
  _valueOid?: Element | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valuePositiveInt?: number | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueString?: string | undefined;
  _valueString?: Element | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueTime?: string | undefined;
  _valueTime?: Element | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueUnsignedInt?: number | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueUri?: string | undefined;
  _valueUri?: Element | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueUrl?: string | undefined;
  _valueUrl?: Element | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueUuid?: string | undefined;
  _valueUuid?: Element | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueAddress?: Address | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueAge?: Age | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueAnnotation?: Annotation | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueAttachment?: Attachment | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueCodeableConcept?: CodeableConcept | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueCodeableReference?: CodeableReference | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueCoding?: Coding | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueContactPoint?: ContactPoint | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueCount?: Count | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueDistance?: Distance | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueDuration?: Duration | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueHumanName?: HumanName | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueIdentifier?: Identifier | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueMoney?: Money | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valuePeriod?: Period | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueQuantity?: Quantity | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueRange?: Range | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueRatio?: Ratio | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueRatioRange?: RatioRange | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueReference?: Reference | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueSampledData?: SampledData | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueSignature?: Signature | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueTiming?: Timing | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueContactDetail?: ContactDetail | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueDataRequirement?: DataRequirement | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueExpression?: Expression | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueParameterDefinition?: ParameterDefinition | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueRelatedArtifact?: RelatedArtifact | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueTriggerDefinition?: TriggerDefinition | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueUsageContext?: UsageContext | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueAvailability?: Availability | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueExtendedContactDetail?: ExtendedContactDetail | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueDosage?: Dosage | undefined;
  /**
   * The actual value for the element, which must be one of the types allowed for this element.
   */
  valueMeta?: Meta | undefined;
}
/**
 * Constraints should be declared on the "context" element - the lowest element in the hierarchy that is common to all nodes referenced by the constraint.
 */
export interface ElementDefinitionConstraint extends Element {
  /**
   * In the absense of an expression, the expression is likely not enforceable by validators, and might be missed by many systems.
   */
  expression?: string | undefined;
  _expression?: Element | undefined;
  /**
   * Should be expressed in business terms as much as possible.
   */
  human: string;
  _human?: Element | undefined;
  /**
   * Allows identification of which elements have their cardinalities impacted by the constraint.  Will not be referenced for constraints that do not affect cardinality.
   */
  key: string;
  _key?: Element | undefined;
  /**
   * To be used if the reason for the constraint might not be intuitive to all implementers.
   */
  requirements?: string | undefined;
  _requirements?: Element | undefined;
  /**
   * This allows constraints to be asserted as "shall" (error) and "should" (warning).
   */
  severity: 'error' | 'warning';
  _severity?: Element | undefined;
  /**
   * This is used when, e.g. rendering, where it is not useful to present inherited constraints when rendering the snapshot.
   */
  source?: string | undefined;
  _source?: Element | undefined;
  /**
   * This element should only be present in a derived profile where a warning or hint has been determined to be spurious/incorrect. E.g. a warning encouraging the inclusion of an element that the profile explicitly prohibits.
   */
  suppress?: boolean | undefined;
  _suppress?: Element | undefined;
}
/**
 * Additional bindings that help applications implementing this element. Additional bindings do not replace the main binding but provide more information and/or context.
 */
export interface ElementDefinitionBindingAdditional extends Element {
  /**
   * A common pattern is to make a conformance binding to all repeats, and then make a binding that one of the repeats must conform to.
   */
  any?: boolean | undefined;
  _any?: Element | undefined;
  /**
   * Documentation of the purpose of use of the bindingproviding additional information about how it is intended to be used.
   */
  documentation?: string | undefined;
  _documentation?: Element | undefined;
  /**
   * Conformance bindings are in addition to the base binding, not instead of it.
   */
  purpose:
    | 'maximum'
    | 'minimum'
    | 'required'
    | 'extensible'
    | 'candidate'
    | 'current'
    | 'preferred'
    | 'ui'
    | 'starter'
    | 'component';
  _purpose?: Element | undefined;
  /**
   * Concise documentation - for summary tables.
   */
  shortDoco?: string | undefined;
  _shortDoco?: Element | undefined;
  /**
   * This specification does not define exactly how the context is determined for the usage; typically, this will be described in implementation guides.
   */
  usage?: UsageContext[] | undefined;
  /**
   * The valueSet that is being bound for the purpose.
   */
  valueSet: string;
  _valueSet?: Element | undefined;
}
/**
 * For a CodeableConcept, when no codes are allowed - only text, use a binding of strength "required" with a description explaining that no coded values are allowed and what sort of information to put in the "text" element.
 */
export interface ElementDefinitionBinding extends Element {
  /**
   * Additional bindings that help applications implementing this element. Additional bindings do not replace the main binding but provide more information and/or context.
   */
  additional?: ElementDefinitionBindingAdditional[] | undefined;
  /**
   * Describes the intended use of this particular set of codes.
   */
  description?: string | undefined;
  _description?: Element | undefined;
  /**
   * For further discussion, see [Using Terminologies](terminologies.html).
   */
  strength: 'required' | 'extensible' | 'preferred' | 'example';
  _strength?: Element | undefined;
  /**
   * The reference may be version-specific or not (e.g. have a |[version] at the end of the canonical URL).
   */
  valueSet?: string | undefined;
  _valueSet?: Element | undefined;
}
/**
 * Mappings are not necessarily specific enough for safe translation.
 */
export interface ElementDefinitionMapping extends Element {
  /**
   * Comments that provide information about the mapping or its use.
   */
  comment?: string | undefined;
  _comment?: Element | undefined;
  /**
   * An internal reference to the definition of a mapping.
   */
  identity: string;
  _identity?: Element | undefined;
  /**
   * If omitted, then there can be no expectation of computational interpretation of the mapping.
   */
  language?: string | undefined;
  _language?: Element | undefined;
  /**
   * For most mappings, the syntax is undefined.  Syntax will be provided for mappings to the RIM.  Multiple mappings may be possible and may include constraints on other resource elements that identify when a particular mapping applies.
   */
  map: string;
  _map?: Element | undefined;
}
/**
 * Captures constraints on each element within the resource, profile, or extension.
 */
export interface ElementDefinition extends BackboneType {
  /**
   * Identifies additional names by which this element might also be known.
   */
  alias?: string[] | undefined;
  _alias?: Element[] | undefined;
  /**
   * The base information does not carry any information that could not be determined from the path and related profiles, but making this determination requires both that the related profiles are available, and that the algorithm to determine them be available. For tooling simplicity, the base information must always be populated in element definitions in snap shots, even if it is the same.
   */
  base?: ElementDefinitionBase | undefined;
  /**
   * For a CodeableConcept, when no codes are allowed - only text, use a binding of strength "required" with a description explaining that no coded values are allowed and what sort of information to put in the "text" element.
   */
  binding?: ElementDefinitionBinding | undefined;
  /**
   * The concept SHALL be properly aligned with the data element definition and other constraints, as defined in the code system, including relationships, of any code listed here.  Where multiple codes exist in a terminology that could correspond to the data element, the most granular code(s) should be selected, so long as they are not more restrictive than the data element itself. The mappings may be used to provide more or less granular or structured equivalences in the code system.
   */
  code?: Coding[] | undefined;
  /**
   * If it is possible to capture usage rules using constraints, that mechanism should be used in preference to this element.
   */
  comment?: string | undefined;
  _comment?: Element | undefined;
  /**
   * A reference to an invariant that may make additional statements about the cardinality or value in the instance.
   */
  condition?: string[] | undefined;
  _condition?: Element[] | undefined;
  /**
   * Constraints should be declared on the "context" element - the lowest element in the hierarchy that is common to all nodes referenced by the constraint.
   */
  constraint?: ElementDefinitionConstraint[] | undefined;
  /**
   * ContentReferences can only be defined in specializations, not constrained types, and they cannot be changed and always reference the non-constrained definition.
   */
  contentReference?: string | undefined;
  _contentReference?: Element | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueBase64Binary?: string | undefined;
  _defaultValueBase64Binary?: Element | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueBoolean?: boolean | undefined;
  _defaultValueBoolean?: Element | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueCanonical?: string | undefined;
  _defaultValueCanonical?: Element | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueCode?: string | undefined;
  _defaultValueCode?: Element | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueDate?: string | undefined;
  _defaultValueDate?: Element | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueDateTime?: string | undefined;
  _defaultValueDateTime?: Element | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueDecimal?: number | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueId?: string | undefined;
  _defaultValueId?: Element | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueInstant?: string | undefined;
  _defaultValueInstant?: Element | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueInteger?: number | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueInteger64?: string | undefined;
  _defaultValueInteger64?: Element | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueMarkdown?: string | undefined;
  _defaultValueMarkdown?: Element | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueOid?: string | undefined;
  _defaultValueOid?: Element | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValuePositiveInt?: number | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueString?: string | undefined;
  _defaultValueString?: Element | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueTime?: string | undefined;
  _defaultValueTime?: Element | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueUnsignedInt?: number | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueUri?: string | undefined;
  _defaultValueUri?: Element | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueUrl?: string | undefined;
  _defaultValueUrl?: Element | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueUuid?: string | undefined;
  _defaultValueUuid?: Element | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueAddress?: Address | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueAge?: Age | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueAnnotation?: Annotation | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueAttachment?: Attachment | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueCodeableConcept?: CodeableConcept | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueCodeableReference?: CodeableReference | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueCoding?: Coding | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueContactPoint?: ContactPoint | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueCount?: Count | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueDistance?: Distance | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueDuration?: Duration | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueHumanName?: HumanName | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueIdentifier?: Identifier | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueMoney?: Money | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValuePeriod?: Period | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueQuantity?: Quantity | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueRange?: Range | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueRatio?: Ratio | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueRatioRange?: RatioRange | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueReference?: Reference | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueSampledData?: SampledData | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueSignature?: Signature | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueTiming?: Timing | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueContactDetail?: ContactDetail | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueDataRequirement?: DataRequirement | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueExpression?: Expression | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueParameterDefinition?: ParameterDefinition | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueRelatedArtifact?: RelatedArtifact | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueTriggerDefinition?: TriggerDefinition | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueUsageContext?: UsageContext | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueAvailability?: Availability | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueExtendedContactDetail?: ExtendedContactDetail | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueDosage?: Dosage | undefined;
  /**
   * Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.
   * No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   */
  defaultValueMeta?: Meta | undefined;
  /**
   * It is easy for a different definition to change the meaning of an element and this can have nasty downstream consequences. Please be careful when providing definitions in a profile.
   */
  definition?: string | undefined;
  _definition?: Element | undefined;
  /**
   * Examples will most commonly be present for data where it's not implicitly obvious from either the data type or value set what the values might be.  (I.e. Example values for dates or quantities would generally be unnecessary.)  If the example value is fully populated, the publication tool can generate an instance automatically.
   */
  example?: ElementDefinitionExample[] | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedBase64Binary?: string | undefined;
  _fixedBase64Binary?: Element | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedBoolean?: boolean | undefined;
  _fixedBoolean?: Element | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedCanonical?: string | undefined;
  _fixedCanonical?: Element | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedCode?: string | undefined;
  _fixedCode?: Element | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedDate?: string | undefined;
  _fixedDate?: Element | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedDateTime?: string | undefined;
  _fixedDateTime?: Element | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedDecimal?: number | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedId?: string | undefined;
  _fixedId?: Element | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedInstant?: string | undefined;
  _fixedInstant?: Element | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedInteger?: number | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedInteger64?: string | undefined;
  _fixedInteger64?: Element | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedMarkdown?: string | undefined;
  _fixedMarkdown?: Element | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedOid?: string | undefined;
  _fixedOid?: Element | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedPositiveInt?: number | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedString?: string | undefined;
  _fixedString?: Element | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedTime?: string | undefined;
  _fixedTime?: Element | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedUnsignedInt?: number | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedUri?: string | undefined;
  _fixedUri?: Element | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedUrl?: string | undefined;
  _fixedUrl?: Element | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedUuid?: string | undefined;
  _fixedUuid?: Element | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedAddress?: Address | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedAge?: Age | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedAnnotation?: Annotation | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedAttachment?: Attachment | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedCodeableConcept?: CodeableConcept | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedCodeableReference?: CodeableReference | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedCoding?: Coding | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedContactPoint?: ContactPoint | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedCount?: Count | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedDistance?: Distance | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedDuration?: Duration | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedHumanName?: HumanName | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedIdentifier?: Identifier | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedMoney?: Money | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedPeriod?: Period | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedQuantity?: Quantity | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedRange?: Range | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedRatio?: Ratio | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedRatioRange?: RatioRange | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedReference?: Reference | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedSampledData?: SampledData | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedSignature?: Signature | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedTiming?: Timing | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedContactDetail?: ContactDetail | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedDataRequirement?: DataRequirement | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedExpression?: Expression | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedParameterDefinition?: ParameterDefinition | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedRelatedArtifact?: RelatedArtifact | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedTriggerDefinition?: TriggerDefinition | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedUsageContext?: UsageContext | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedAvailability?: Availability | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedExtendedContactDetail?: ExtendedContactDetail | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedDosage?: Dosage | undefined;
  /**
   * This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   */
  fixedMeta?: Meta | undefined;
  /**
   * Only the definition of an element can set IsModifier true - either the specification itself or where an extension is originally defined. Once set, it cannot be changed in derived profiles (except in the special case of the defining a new extension). An element/extension that has isModifier=true SHOULD also have a minimum cardinality of 1, so that there is no lack of clarity about what to do if it is missing. If it can be missing, the definition SHALL make the meaning of a missing element clear.
   */
  isModifier?: boolean | undefined;
  _isModifier?: Element | undefined;
  /**
   * Explains how that element affects the interpretation of the resource or element that contains it.
   */
  isModifierReason?: string | undefined;
  _isModifierReason?: Element | undefined;
  /**
   * Some resources include a set of simple metadata, and some very large data. This element is used to reduce the quantity of data returned in searches. Note that servers may pre-cache summarized resources for optimal performance. When a request is made with _summary=true, serializers only include elements marked as 'isSummary = true'. With a few exceptions (listed below), all datatype properties are included in the summary form. In resource and datatype definitions, if an element has a descendant marked as isSummary=true or if it satisfies both of the following conditions, it must be marked as isSummary=true:
   * - is at the root or has a parent that is 'mustSupport'
   * - has a minimum cardinality of 1 or is a modifier element
   * The following datatype properties are exceptions, and are not marked as isSummary:
   * - Attachment.data
   * - Signature.data, Signature.targetFormat, Signature.sigFormat
   * - Narrative.status, Narrative.div
   * - SampledData.data.
   */
  isSummary?: boolean | undefined;
  _isSummary?: Element | undefined;
  /**
   * See also the extension [http://hl7.org/fhir/StructureDefinition/elementdefinition-question](http://hl7.org/fhir/extensions/StructureDefinition-elementdefinition-question.html).
   */
  label?: string | undefined;
  _label?: Element | undefined;
  /**
   * Mappings are not necessarily specific enough for safe translation.
   */
  mapping?: ElementDefinitionMapping[] | undefined;
  /**
   * The maximum number of times this element is permitted to appear in the instance.
   */
  max?: string | undefined;
  _max?: Element | undefined;
  /**
   * Receivers are not required to reject instances that exceed the maximum length.  The full length could be stored.  In some cases, data might be truncated, though truncation should be undertaken with care and an understanding of the consequences of doing so. If not specified, there is no conformance expectation for length support.
   */
  maxLength?: number | undefined;
  /**
   * Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a [Duration](datatypes.html#Duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as a canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
   */
  maxValueDate?: string | undefined;
  _maxValueDate?: Element | undefined;
  /**
   * Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a [Duration](datatypes.html#Duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as a canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
   */
  maxValueDateTime?: string | undefined;
  _maxValueDateTime?: Element | undefined;
  /**
   * Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a [Duration](datatypes.html#Duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as a canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
   */
  maxValueInstant?: string | undefined;
  _maxValueInstant?: Element | undefined;
  /**
   * Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a [Duration](datatypes.html#Duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as a canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
   */
  maxValueTime?: string | undefined;
  _maxValueTime?: Element | undefined;
  /**
   * Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a [Duration](datatypes.html#Duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as a canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
   */
  maxValueDecimal?: number | undefined;
  /**
   * Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a [Duration](datatypes.html#Duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as a canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
   */
  maxValueInteger?: number | undefined;
  /**
   * Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a [Duration](datatypes.html#Duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as a canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
   */
  maxValueInteger64?: string | undefined;
  _maxValueInteger64?: Element | undefined;
  /**
   * Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a [Duration](datatypes.html#Duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as a canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
   */
  maxValuePositiveInt?: number | undefined;
  /**
   * Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a [Duration](datatypes.html#Duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as a canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
   */
  maxValueUnsignedInt?: number | undefined;
  /**
   * Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a [Duration](datatypes.html#Duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as a canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
   */
  maxValueQuantity?: Quantity | undefined;
  /**
   * Implicit meanings for missing values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. An implicit meaning for a missing value can never be changed, and specifying one has the consequence that constraining its use in profiles eliminates use cases as possibilities, not merely moving them out of scope.
   */
  meaningWhenMissing?: string | undefined;
  _meaningWhenMissing?: Element | undefined;
  /**
   * The minimum number of times this element SHALL appear in the instance.
   */
  min?: number | undefined;
  /**
   * Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a [Duration](datatypes.html#Duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as a canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
   */
  minValueDate?: string | undefined;
  _minValueDate?: Element | undefined;
  /**
   * Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a [Duration](datatypes.html#Duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as a canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
   */
  minValueDateTime?: string | undefined;
  _minValueDateTime?: Element | undefined;
  /**
   * Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a [Duration](datatypes.html#Duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as a canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
   */
  minValueInstant?: string | undefined;
  _minValueInstant?: Element | undefined;
  /**
   * Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a [Duration](datatypes.html#Duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as a canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
   */
  minValueTime?: string | undefined;
  _minValueTime?: Element | undefined;
  /**
   * Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a [Duration](datatypes.html#Duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as a canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
   */
  minValueDecimal?: number | undefined;
  /**
   * Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a [Duration](datatypes.html#Duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as a canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
   */
  minValueInteger?: number | undefined;
  /**
   * Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a [Duration](datatypes.html#Duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as a canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
   */
  minValueInteger64?: string | undefined;
  _minValueInteger64?: Element | undefined;
  /**
   * Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a [Duration](datatypes.html#Duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as a canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
   */
  minValuePositiveInt?: number | undefined;
  /**
   * Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a [Duration](datatypes.html#Duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as a canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
   */
  minValueUnsignedInt?: number | undefined;
  /**
   * Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a [Duration](datatypes.html#Duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as a canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
   */
  minValueQuantity?: Quantity | undefined;
  /**
   * Typical extensions that can be provided in place of a the value are [http://hl7.org/fhir/StructureDefinition/data-absent-reason](http://hl7.org/fhir/extensions/StructureDefinition-data-absent-reason.html),  [http://hl7.org/fhir/StructureDefinition/iso21090-nullFlavor](http://hl7.org/fhir/extensions/StructureDefinition-iso21090-nullFlavor.html),  [http://hl7.org/fhir/StructureDefinition/originalText](http://hl7.org/fhir/extensions/StructureDefinition-originalText.html), and [http://hl7.org/fhir/StructureDefinition/cqf-expression](http://hl7.org/fhir/extensions/StructureDefinition-cqf-expression.html). Note that this element has no meaning when a value is provided, and extensions can be provided in addition to a value.
   */
  mustHaveValue?: boolean | undefined;
  _mustHaveValue?: Element | undefined;
  /**
   * "Something meaningful" is context dependent and impossible to describe in the base FHIR specification. For this reason, the mustSupport flag is never set to true by the FHIR specification itself - it is only set to true in profiles.  A profile on a type can always make mustSupport = true if it is false in the base type but cannot make mustSupport = false if it is true in the base type.   This is done in [Resource Profiles](profiling.html#mustsupport), where the profile labels an element as mustSupport=true. When a profile does this, it SHALL also make clear exactly what kind of "support" is required, as this can mean many things.    Note that an element that has the property IsModifier is not necessarily a "key" element (e.g. one of the important elements to make use of the resource), nor is it automatically mustSupport - however both of these things are more likely to be true for IsModifier elements than for other elements.
   */
  mustSupport?: boolean | undefined;
  _mustSupport?: Element | undefined;
  /**
   * This element can only be asserted on repeating elements and can only be introduced when defining resources or data types.  It can be further refined profiled elements but if absent in the base type, a profile cannot assert meaning.
   */
  orderMeaning?: string | undefined;
  _orderMeaning?: Element | undefined;
  /**
   * The path identifies the element and is expressed as a "."-separated list of ancestor elements, beginning with the name of the resource or extension.
   */
  path: string;
  _path?: Element | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternBase64Binary?: string | undefined;
  _patternBase64Binary?: Element | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternBoolean?: boolean | undefined;
  _patternBoolean?: Element | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternCanonical?: string | undefined;
  _patternCanonical?: Element | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternCode?: string | undefined;
  _patternCode?: Element | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternDate?: string | undefined;
  _patternDate?: Element | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternDateTime?: string | undefined;
  _patternDateTime?: Element | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternDecimal?: number | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternId?: string | undefined;
  _patternId?: Element | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternInstant?: string | undefined;
  _patternInstant?: Element | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternInteger?: number | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternInteger64?: string | undefined;
  _patternInteger64?: Element | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternMarkdown?: string | undefined;
  _patternMarkdown?: Element | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternOid?: string | undefined;
  _patternOid?: Element | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternPositiveInt?: number | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternString?: string | undefined;
  _patternString?: Element | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternTime?: string | undefined;
  _patternTime?: Element | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternUnsignedInt?: number | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternUri?: string | undefined;
  _patternUri?: Element | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternUrl?: string | undefined;
  _patternUrl?: Element | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternUuid?: string | undefined;
  _patternUuid?: Element | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternAddress?: Address | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternAge?: Age | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternAnnotation?: Annotation | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternAttachment?: Attachment | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternCodeableConcept?: CodeableConcept | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternCodeableReference?: CodeableReference | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternCoding?: Coding | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternContactPoint?: ContactPoint | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternCount?: Count | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternDistance?: Distance | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternDuration?: Duration | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternHumanName?: HumanName | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternIdentifier?: Identifier | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternMoney?: Money | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternPeriod?: Period | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternQuantity?: Quantity | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternRange?: Range | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternRatio?: Ratio | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternRatioRange?: RatioRange | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternReference?: Reference | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternSampledData?: SampledData | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternSignature?: Signature | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternTiming?: Timing | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternContactDetail?: ContactDetail | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternDataRequirement?: DataRequirement | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternExpression?: Expression | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternParameterDefinition?: ParameterDefinition | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternRelatedArtifact?: RelatedArtifact | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternTriggerDefinition?: TriggerDefinition | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternUsageContext?: UsageContext | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternAvailability?: Availability | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternExtendedContactDetail?: ExtendedContactDetail | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternDosage?: Dosage | undefined;
  /**
   * Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   */
  patternMeta?: Meta | undefined;
  /**
   * In resources, this is rarely used except for special cases where the representation deviates from the normal, and can only be done in the base standard (and profiles must reproduce what the base standard does). This element is used quite commonly in Logical models when the logical models represent a specific serialization format (e.g. CDA, v2 etc.).
   */
  representation?: ('xmlAttr' | 'xmlText' | 'typeAttr' | 'cdaText' | 'xhtml')[] | undefined;
  _representation?: Element[] | undefined;
  /**
   * This element does not describe the usage of the element (that's done in comments), rather it's for traceability of *why* the element is either needed or why the constraints exist as they do.  This may be used to point to source materials or specifications that drove the structure of this data element.
   */
  requirements?: string | undefined;
  _requirements?: Element | undefined;
  /**
   * It is easy for a different short definition to change the meaning of an element and this can have nasty downstream consequences. Please be careful when providing short definitions in a profile.
   */
  short?: string | undefined;
  _short?: Element | undefined;
  /**
   * If set to true, an ancestor profile SHALL have a slicing definition with this name.  If set to false, no ancestor profile is permitted to have a slicing definition with this name.
   */
  sliceIsConstraining?: boolean | undefined;
  _sliceIsConstraining?: Element | undefined;
  /**
   * The name SHALL be unique within the structure within the context of the constrained resource element.  (Though to avoid confusion, uniqueness across all elements is recommended.).
   */
  sliceName?: string | undefined;
  _sliceName?: Element | undefined;
  /**
   * The first element in the sequence, the one that carries the slicing, is the definition that applies to all the slices. This is based on the unconstrained element, but can apply any constraints as appropriate. This may include the common constraints on the children of the element.
   */
  slicing?: ElementDefinitionSlicing | undefined;
  /**
   * The Type of the element can be left blank in a differential constraint, in which case the type is inherited from the resource. Abstract types are not permitted to appear as a type when multiple types are listed.  (I.e. Abstract types cannot be part of a choice).
   */
  type?: ElementDefinitionType[] | undefined;
  /**
   * if mustHaveValue is true, then this element should not be present, since no extensions are allowed in place of the value. Note that this element has no impact if the value is present.
   */
  valueAlternatives?: string[] | undefined;
  _valueAlternatives?: Element[] | undefined;
}

/**
 * Optional Extension Element - found in all resources.
 */
export interface Extension extends DataType {
  /**
   * The definition may point directly to a computable or human-readable definition of the extensibility codes, or it may be a logical URI as declared in some other specification. The definition SHALL be a URI for the Structure Definition defining the extension.
   */
  url: string;
  _url?: Element | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueBase64Binary?: string | undefined;
  _valueBase64Binary?: Element | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueBoolean?: boolean | undefined;
  _valueBoolean?: Element | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueCanonical?: string | undefined;
  _valueCanonical?: Element | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueCode?: string | undefined;
  _valueCode?: Element | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueDate?: string | undefined;
  _valueDate?: Element | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueDateTime?: string | undefined;
  _valueDateTime?: Element | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueDecimal?: number | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueId?: string | undefined;
  _valueId?: Element | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueInstant?: string | undefined;
  _valueInstant?: Element | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueInteger?: number | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueInteger64?: string | undefined;
  _valueInteger64?: Element | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueMarkdown?: string | undefined;
  _valueMarkdown?: Element | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueOid?: string | undefined;
  _valueOid?: Element | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valuePositiveInt?: number | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueString?: string | undefined;
  _valueString?: Element | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueTime?: string | undefined;
  _valueTime?: Element | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueUnsignedInt?: number | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueUri?: string | undefined;
  _valueUri?: Element | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueUrl?: string | undefined;
  _valueUrl?: Element | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueUuid?: string | undefined;
  _valueUuid?: Element | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueAddress?: Address | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueAge?: Age | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueAnnotation?: Annotation | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueAttachment?: Attachment | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueCodeableConcept?: CodeableConcept | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueCodeableReference?: CodeableReference | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueCoding?: Coding | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueContactPoint?: ContactPoint | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueCount?: Count | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueDistance?: Distance | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueDuration?: Duration | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueHumanName?: HumanName | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueIdentifier?: Identifier | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueMoney?: Money | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valuePeriod?: Period | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueQuantity?: Quantity | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueRange?: Range | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueRatio?: Ratio | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueRatioRange?: RatioRange | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueReference?: Reference | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueSampledData?: SampledData | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueSignature?: Signature | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueTiming?: Timing | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueContactDetail?: ContactDetail | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueDataRequirement?: DataRequirement | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueExpression?: Expression | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueParameterDefinition?: ParameterDefinition | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueRelatedArtifact?: RelatedArtifact | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueTriggerDefinition?: TriggerDefinition | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueUsageContext?: UsageContext | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueAvailability?: Availability | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueExtendedContactDetail?: ExtendedContactDetail | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueDosage?: Dosage | undefined;
  /**
   * Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
   */
  valueMeta?: Meta | undefined;
}

/**
 * An address expressed using postal conventions (as opposed to GPS or other location definition formats).  This data type may be used to convey addresses for use in delivering mail as well as for visiting locations which might not be valid for mail delivery.  There are a variety of postal address formats defined around the world.
 * The ISO21090-codedString may be used to provide a coded representation of the contents of strings in an Address.
 */
export interface Address extends DataType {
  /**
   * The name of the city, town, suburb, village or other community or delivery center.
   */
  city?: string | undefined;
  _city?: Element | undefined;
  /**
   * ISO 3166 2- or 3- letter codes MAY be used in place of a human readable country name.
   */
  country?: string | undefined;
  _country?: Element | undefined;
  /**
   * District is sometimes known as county, but in some regions 'county' is used in place of city (municipality), so county name should be conveyed in city instead.
   */
  district?: string | undefined;
  _district?: Element | undefined;
  /**
   * This component contains the house number, apartment number, street name, street direction,  P.O. Box number, delivery hints, and similar address information.
   */
  line?: string[] | undefined;
  _line?: Element[] | undefined;
  /**
   * Time period when address was/is in use.
   */
  period?: Period | undefined;
  /**
   * A postal code designating a region defined by the postal service.
   */
  postalCode?: string | undefined;
  _postalCode?: Element | undefined;
  /**
   * Sub-unit of a country with limited sovereignty in a federally organized country. A code may be used if codes are in common use (e.g. US 2 letter state codes).
   */
  state?: string | undefined;
  _state?: Element | undefined;
  /**
   * Can provide both a text representation and parts. Applications updating an address SHALL ensure that  when both text and parts are present,  no content is included in the text that isn't found in a part.
   */
  text?: string | undefined;
  _text?: Element | undefined;
  /**
   * The definition of Address states that "address is intended to describe postal addresses, not physical locations". However, many applications track whether an address has a dual purpose of being a location that can be visited as well as being a valid delivery destination, and Postal addresses are often used as proxies for physical locations (also see the [Location](location.html#) resource).
   */
  type?: ('postal' | 'physical' | 'both') | undefined;
  _type?: Element | undefined;
  /**
   * Applications can assume that an address is current unless it explicitly says that it is temporary or old.
   */
  use?: ('home' | 'work' | 'temp' | 'old' | 'billing') | undefined;
  _use?: Element | undefined;
}
/**
 * A duration of time during which an organism (or a process) has existed.
 */
export interface Age extends Quantity {}
/**
 * A  text note which also  contains information about who made the statement and when.
 */
export interface Annotation extends DataType {
  /**
   * Organization is used when there's no need for specific attribution as to who made the comment.
   */
  authorReference?: Reference | undefined;
  /**
   * Organization is used when there's no need for specific attribution as to who made the comment.
   */
  authorString?: string | undefined;
  _authorString?: Element | undefined;
  /**
   * The text of the annotation in markdown format.
   */
  text: string;
  _text?: Element | undefined;
  /**
   * Indicates when this particular annotation was made.
   */
  time?: string | undefined;
  _time?: Element | undefined;
}
/**
 * For referring to data content defined in other formats.
 */
export interface Attachment extends DataType {
  /**
   * Identifies the type of the data in the attachment and allows a method to be chosen to interpret or render the data. Includes mime type parameters such as charset where appropriate.
   */
  contentType?: string | undefined;
  _contentType?: Element | undefined;
  /**
   * The date that the attachment was first created.
   */
  creation?: string | undefined;
  _creation?: Element | undefined;
  /**
   * The base64-encoded data SHALL be expressed in the same character set as the base resource XML or JSON.
   */
  data?: string | undefined;
  _data?: Element | undefined;
  /**
   * The duration might differ from occurrencePeriod if recording was paused.
   */
  duration?: number | undefined;
  /**
   * if the number of frames is not supplied, the value may be unknown. Applications should not assume that there is only one frame unless it is explicitly stated.
   */
  frames?: number | undefined;
  /**
   * The hash is calculated on the data prior to base64 encoding, if the data is based64 encoded. The hash is not intended to support digital signatures. Where protection against malicious threats a digital signature should be considered, see [Provenance.signature](provenance-definitions.html#Provenance.signature) for mechanism to protect a resource with a digital signature.
   */
  hash?: string | undefined;
  _hash?: Element | undefined;
  /**
   * Height of the image in pixels (photo/video).
   */
  height?: number | undefined;
  /**
   * The human language of the content. The value can be any valid value according to BCP 47.
   */
  language?: string | undefined;
  _language?: Element | undefined;
  /**
   * The number of pages when printed.
   */
  pages?: number | undefined;
  /**
   * The number of bytes is redundant if the data is provided as a base64binary, but is useful if the data is provided as a url reference.
   */
  size?: string | undefined;
  _size?: Element | undefined;
  /**
   * May sometimes be derived from the source filename.
   */
  title?: string | undefined;
  _title?: Element | undefined;
  /**
   * If both data and url are provided, the url SHALL point to the same content as the data contains. Urls may be relative references or may reference transient locations such as a wrapping envelope using cid: though this has ramifications for using signatures. Relative URLs are interpreted relative to the service url, like a resource reference, rather than relative to the resource itself. If a URL is provided, it SHALL resolve to actual data.
   */
  url?: string | undefined;
  _url?: Element | undefined;
  /**
   * Width of the image in pixels (photo/video).
   */
  width?: number | undefined;
}
/**
 * Times the {item} is available.
 */
export interface AvailabilityAvailableTime extends Element {
  /**
   * Always available? i.e. 24 hour service.
   */
  allDay?: boolean | undefined;
  _allDay?: Element | undefined;
  /**
   * The timezone is expected to be specified or implied by the context this datatype is used.
   */
  availableEndTime?: string | undefined;
  _availableEndTime?: Element | undefined;
  /**
   * The timezone is expected to be specified or implied by the context this datatype is used.
   */
  availableStartTime?: string | undefined;
  _availableStartTime?: Element | undefined;
  /**
   * mon | tue | wed | thu | fri | sat | sun.
   */
  daysOfWeek?: ('mon' | 'tue' | 'wed' | 'thu' | 'fri' | 'sat' | 'sun')[] | undefined;
  _daysOfWeek?: Element[] | undefined;
}
/**
 * Not available during this time due to provided reason.
 */
export interface AvailabilityNotAvailableTime extends Element {
  /**
   * The reason will generally be provided to give the textual reason for displaying when the {item} is not available, e.g. 'Closed public holidays' or 'Independence Day'. In cases such as this, the `during` might not be included and local knowledge would be required in such cases (as don't desire to keep updating when the holiday occurs each year).
   * e.g.2: 'Closed for maintenance over the summer' for this example you would want to include the `during` period, unless this was a university hospital and the "summer" period was well known, but would recommend its inclusion anyway.
   */
  description?: string | undefined;
  _description?: Element | undefined;
  /**
   * Service not available during this period.
   */
  during?: Period | undefined;
}
/**
 * Availability data for an {item}.
 */
export interface Availability extends DataType {
  /**
   * Times the {item} is available.
   */
  availableTime?: AvailabilityAvailableTime[] | undefined;
  /**
   * Not available during this time due to provided reason.
   */
  notAvailableTime?: AvailabilityNotAvailableTime[] | undefined;
}
/**
 * A concept that may be defined by a formal reference to a terminology or ontology or may be provided by text.
 */
export interface CodeableConcept extends DataType {
  /**
   * Codes may be defined very casually in enumerations, or code lists, up to very formal definitions such as SNOMED CT - see the HL7 v3 Core Principles for more information.  Ordering of codings is undefined and SHALL NOT be used to infer meaning. Generally, at most only one of the coding values will be labeled as UserSelected = true.
   */
  coding?: Coding[] | undefined;
  /**
   * Very often the text is the same as a displayName of one of the codings.
   */
  text?: string | undefined;
  _text?: Element | undefined;
}
/**
 * A reference to a resource (by instance), or instead, a reference to a concept defined in a terminology or ontology (by class).
 */
export interface CodeableReference extends DataType {
  /**
   * A reference to a concept - e.g. the information is identified by its general class to the degree of precision found in the terminology.
   */
  concept?: CodeableConcept | undefined;
  /**
   * A reference to a resource the provides exact details about the information being referenced.
   */
  reference?: Reference | undefined;
}
/**
 * A reference to a code defined by a terminology system.
 */
export interface Coding extends DataType {
  /**
   * A symbol in syntax defined by the system. The symbol may be a predefined code or an expression in a syntax defined by the coding system (e.g. post-coordination).
   */
  code?: string | undefined;
  _code?: Element | undefined;
  /**
   * A representation of the meaning of the code in the system, following the rules of the system.
   */
  display?: string | undefined;
  _display?: Element | undefined;
  /**
   * The URI may be an OID (urn:oid:...) or a UUID (urn:uuid:...).  OIDs and UUIDs SHALL be references to the HL7 OID registry. Otherwise, the URI should come from HL7's list of FHIR defined special URIs or it should be an absolute reference to some definition that establishes the system clearly and unambiguously.
   */
  system?: string | undefined;
  _system?: Element | undefined;
  /**
   * Amongst a set of alternatives, a directly chosen code is the most appropriate starting point for new translations. There is some ambiguity about what exactly 'directly chosen' implies, and trading partner agreement may be needed to clarify the use of this element and its consequences more completely.
   */
  userSelected?: boolean | undefined;
  _userSelected?: Element | undefined;
  /**
   * Where the terminology does not clearly define what string should be used to identify code system versions, the recommendation is to use the date (expressed in FHIR date format) on which that version was officially published as the version date.
   */
  version?: string | undefined;
  _version?: Element | undefined;
}
/**
 * Specifies contact information for a person or organization.
 */
export interface ContactDetail extends DataType {
  /**
   * If there is no named individual, the telecom information is for the organization as a whole.
   */
  name?: string | undefined;
  _name?: Element | undefined;
  /**
   * The contact details for the individual (if a name was provided) or the organization.
   */
  telecom?: ContactPoint[] | undefined;
}
/**
 * Details for all kinds of technology mediated contact points for a person or organization, including telephone, email, etc.
 */
export interface ContactPoint extends DataType {
  /**
   * Time period when the contact point was/is in use.
   */
  period?: Period | undefined;
  /**
   * Note that rank does not necessarily follow the order in which the contacts are represented in the instance.
   * Ranks need not be unique.  E.g. it's possible to have multiple contacts with rank=1.  If the ranks have different systems or uses, this would be interpreted to mean "X is my most preferred phone number, Y is my most preferred email address" or "X is my preferred home email and Y is my preferred work email".  If the system and use for equally-ranked contacts are the same, then the level of preference is equivalent for both repetitions.
   * Ranks need not be sequential and not all repetitions must have a rank.  For example, it's possible to have 4 contacts with ranks of 2, 5 and two with no rank specified.  That would be interpreted to mean the first is preferred over the second and no preference stated for the remaining contacts.
   */
  rank?: number | undefined;
  /**
   * Telecommunications form for contact point - what communications system is required to make use of the contact.
   */
  system?: ('phone' | 'fax' | 'email' | 'pager' | 'url' | 'sms' | 'other') | undefined;
  _system?: Element | undefined;
  /**
   * Applications can assume that a contact is current unless it explicitly says that it is temporary or old.
   */
  use?: ('home' | 'work' | 'temp' | 'old' | 'mobile') | undefined;
  _use?: Element | undefined;
  /**
   * Additional text data such as phone extension numbers, or notes about use of the contact are sometimes included in the value.
   */
  value?: string | undefined;
  _value?: Element | undefined;
}
/**
 * A measured amount (or an amount that can potentially be measured). Note that measured amounts include amounts that are not precisely quantified, including amounts involving arbitrary units and floating currencies.
 */
export interface Count extends Quantity {}
/**
 * Code filters specify additional constraints on the data, specifying the value set of interest for a particular element of the data. Each code filter defines an additional constraint on the data, i.e. code filters are AND'ed, not OR'ed.
 */
export interface DataRequirementCodeFilter extends Element {
  /**
   * The codes for the code filter. If values are given, the filter will return only those data items for which the code-valued attribute specified by the path has a value that is one of the specified codes. If codes are specified in addition to a value set, the filter returns items matching a code in the value set or one of the specified codes.
   */
  code?: Coding[] | undefined;
  /**
   * The path attribute contains a [Simple FHIRPath Subset](fhirpath.html#simple) that allows path traversal, but not calculation.
   */
  path?: string | undefined;
  _path?: Element | undefined;
  /**
   * A token parameter that refers to a search parameter defined on the specified type of the DataRequirement, and which searches on elements of type code, Coding, or CodeableConcept.
   */
  searchParam?: string | undefined;
  _searchParam?: Element | undefined;
  /**
   * The valueset for the code filter. The valueSet and code elements are additive. If valueSet is specified, the filter will return only those data items for which the value of the code-valued element specified in the path is a member of the specified valueset.
   */
  valueSet?: string | undefined;
  _valueSet?: Element | undefined;
}
/**
 * Date filters specify additional constraints on the data in terms of the applicable date range for specific elements. Each date filter specifies an additional constraint on the data, i.e. date filters are AND'ed, not OR'ed.
 */
export interface DataRequirementDateFilter extends Element {
  /**
   * The path attribute contains a [Simple FHIR Subset](fhirpath.html#simple) that allows path traversal, but not calculation.
   */
  path?: string | undefined;
  _path?: Element | undefined;
  /**
   * A date parameter that refers to a search parameter defined on the specified type of the DataRequirement, and which searches on elements of type date, dateTime, Period, Schedule, or Timing.
   */
  searchParam?: string | undefined;
  _searchParam?: Element | undefined;
  /**
   * The value of the filter. If period is specified, the filter will return only those data items that fall within the bounds determined by the Period, inclusive of the period boundaries. If dateTime is specified, the filter will return only those data items that are equal to the specified dateTime. If a Duration is specified, the filter will return only those data items that fall within Duration before now.
   */
  valueDateTime?: string | undefined;
  _valueDateTime?: Element | undefined;
  /**
   * The value of the filter. If period is specified, the filter will return only those data items that fall within the bounds determined by the Period, inclusive of the period boundaries. If dateTime is specified, the filter will return only those data items that are equal to the specified dateTime. If a Duration is specified, the filter will return only those data items that fall within Duration before now.
   */
  valuePeriod?: Period | undefined;
  /**
   * The value of the filter. If period is specified, the filter will return only those data items that fall within the bounds determined by the Period, inclusive of the period boundaries. If dateTime is specified, the filter will return only those data items that are equal to the specified dateTime. If a Duration is specified, the filter will return only those data items that fall within Duration before now.
   */
  valueDuration?: Duration | undefined;
}
/**
 * Value filters specify additional constraints on the data for elements other than code-valued or date-valued. Each value filter specifies an additional constraint on the data (i.e. valueFilters are AND'ed, not OR'ed).
 */
export interface DataRequirementValueFilter extends Element {
  /**
   * The comparator to be used to determine whether the value is matching.
   */
  comparator?: ('eq' | 'gt' | 'lt' | 'ge' | 'le' | 'sa' | 'eb') | undefined;
  _comparator?: Element | undefined;
  /**
   * The path attribute contains a [Simple FHIR Subset](fhirpath.html#simple) that allows path traversal, but not calculation.
   */
  path?: string | undefined;
  _path?: Element | undefined;
  /**
   * A search parameter defined on the specified type of the DataRequirement, and which searches on elements of a type compatible with the type of the valueFilter.value[x] for the filter.
   */
  searchParam?: string | undefined;
  _searchParam?: Element | undefined;
  /**
   * The value of the filter.
   */
  valueDateTime?: string | undefined;
  _valueDateTime?: Element | undefined;
  /**
   * The value of the filter.
   */
  valuePeriod?: Period | undefined;
  /**
   * The value of the filter.
   */
  valueDuration?: Duration | undefined;
}
/**
 * This element can be used in combination with the sort element to specify quota requirements such as "the most recent 5" or "the highest 5". When multiple sorts are specified, they are applied in the order they appear in the resource.
 */
export interface DataRequirementSort extends Element {
  /**
   * The direction of the sort, ascending or descending.
   */
  direction: 'ascending' | 'descending';
  _direction?: Element | undefined;
  /**
   * The attribute of the sort. The specified path must be resolvable from the type of the required data. The path is allowed to contain qualifiers (.) to traverse sub-elements, as well as indexers ([x]) to traverse multiple-cardinality sub-elements. Note that the index must be an integer constant.
   */
  path: string;
  _path?: Element | undefined;
}
/**
 * Describes a required data item for evaluation in terms of the type of data, and optional code or date-based filters of the data.
 */
export interface DataRequirement extends DataType {
  /**
   * Code filters specify additional constraints on the data, specifying the value set of interest for a particular element of the data. Each code filter defines an additional constraint on the data, i.e. code filters are AND'ed, not OR'ed.
   */
  codeFilter?: DataRequirementCodeFilter[] | undefined;
  /**
   * Date filters specify additional constraints on the data in terms of the applicable date range for specific elements. Each date filter specifies an additional constraint on the data, i.e. date filters are AND'ed, not OR'ed.
   */
  dateFilter?: DataRequirementDateFilter[] | undefined;
  /**
   * This element can be used in combination with the sort element to specify quota requirements such as "the most recent 5" or "the highest 5".
   */
  limit?: number | undefined;
  /**
   * Indicates that specific elements of the type are referenced by the knowledge module and must be supported by the consumer in order to obtain an effective evaluation. This does not mean that a value is required for this element, only that the consuming system must understand the element and be able to provide values for it if they are available.
   * The value of mustSupport SHALL be a FHIRPath resolvable on the type of the DataRequirement. The path SHALL consist only of identifiers, constant indexers, and .resolve() (see the [Simple FHIRPath Profile](fhirpath.html#simple) for full details).
   */
  mustSupport?: string[] | undefined;
  _mustSupport?: Element[] | undefined;
  /**
   * The profile of the required data, specified as the uri of the profile definition.
   */
  profile?: string[] | undefined;
  _profile?: Element[] | undefined;
  /**
   * This element can be used in combination with the sort element to specify quota requirements such as "the most recent 5" or "the highest 5". When multiple sorts are specified, they are applied in the order they appear in the resource.
   */
  sort?: DataRequirementSort[] | undefined;
  /**
   * The subject of a data requirement is critical, as the data being specified is determined with respect to a particular subject. This corresponds roughly to the notion of a Compartment in that it limits what data is available based on its relationship to the subject. In CQL, this corresponds to the context declaration.
   */
  subjectCodeableConcept?: CodeableConcept | undefined;
  /**
   * The subject of a data requirement is critical, as the data being specified is determined with respect to a particular subject. This corresponds roughly to the notion of a Compartment in that it limits what data is available based on its relationship to the subject. In CQL, this corresponds to the context declaration.
   */
  subjectReference?: Reference | undefined;
  /**
   * The type of the required data, specified as the type name of a resource. For profiles, this value is set to the type of the base resource of the profile.
   */
  type: string;
  _type?: Element | undefined;
  /**
   * Value filters specify additional constraints on the data for elements other than code-valued or date-valued. Each value filter specifies an additional constraint on the data (i.e. valueFilters are AND'ed, not OR'ed).
   */
  valueFilter?: DataRequirementValueFilter[] | undefined;
}
/**
 * A length - a value with a unit that is a physical distance.
 */
export interface Distance extends Quantity {}
/**
 * Depending on the resource,this is the amount of medication administered, to  be administered or typical amount to be administered.
 */
export interface DosageDoseAndRate extends Element {
  /**
   * Note that this specifies the quantity of the specified medication, not the quantity for each active ingredient(s). Each ingredient amount can be communicated in the Medication resource. For example, if one wants to communicate that a tablet was 375 mg, where the dose was one tablet, you can use the Medication resource to document that the tablet was comprised of 375 mg of drug XYZ. Alternatively if the dose was 375 mg, then you may only need to use the Medication resource to indicate this was a tablet. If the example were an IV such as dopamine and you wanted to communicate that 400mg of dopamine was mixed in 500 ml of some IV solution, then this would all be communicated in the Medication resource. If the administration is not intended to be instantaneous (rate is present or timing has a duration), this can be specified to convey the total amount to be administered over the period of time as indicated by the schedule e.g. 500 ml in dose, with timing used to convey that this should be done over 4 hours.
   */
  doseRange?: Range | undefined;
  /**
   * Note that this specifies the quantity of the specified medication, not the quantity for each active ingredient(s). Each ingredient amount can be communicated in the Medication resource. For example, if one wants to communicate that a tablet was 375 mg, where the dose was one tablet, you can use the Medication resource to document that the tablet was comprised of 375 mg of drug XYZ. Alternatively if the dose was 375 mg, then you may only need to use the Medication resource to indicate this was a tablet. If the example were an IV such as dopamine and you wanted to communicate that 400mg of dopamine was mixed in 500 ml of some IV solution, then this would all be communicated in the Medication resource. If the administration is not intended to be instantaneous (rate is present or timing has a duration), this can be specified to convey the total amount to be administered over the period of time as indicated by the schedule e.g. 500 ml in dose, with timing used to convey that this should be done over 4 hours.
   */
  doseQuantity?: Quantity | undefined;
  /**
   * It is possible to supply both a rate and a doseQuantity to provide full details about how the medication is to be administered and supplied. If the rate is intended to change over time, depending on local rules/regulations, each change should be captured as a new version of the MedicationRequest with an updated rate, or captured with a new MedicationRequest with the new rate.
   * It is possible to specify a rate over time (for example, 100 ml/hour) using either the rateRatio and rateQuantity.  The rateQuantity approach requires systems to have the capability to parse UCUM grammar where ml/hour is included rather than a specific ratio where the time is specified as the denominator.  Where a rate such as 500ml over 2 hours is specified, the use of rateRatio may be more semantically correct than specifying using a rateQuantity of 250 mg/hour.
   */
  rateRatio?: Ratio | undefined;
  /**
   * It is possible to supply both a rate and a doseQuantity to provide full details about how the medication is to be administered and supplied. If the rate is intended to change over time, depending on local rules/regulations, each change should be captured as a new version of the MedicationRequest with an updated rate, or captured with a new MedicationRequest with the new rate.
   * It is possible to specify a rate over time (for example, 100 ml/hour) using either the rateRatio and rateQuantity.  The rateQuantity approach requires systems to have the capability to parse UCUM grammar where ml/hour is included rather than a specific ratio where the time is specified as the denominator.  Where a rate such as 500ml over 2 hours is specified, the use of rateRatio may be more semantically correct than specifying using a rateQuantity of 250 mg/hour.
   */
  rateRange?: Range | undefined;
  /**
   * It is possible to supply both a rate and a doseQuantity to provide full details about how the medication is to be administered and supplied. If the rate is intended to change over time, depending on local rules/regulations, each change should be captured as a new version of the MedicationRequest with an updated rate, or captured with a new MedicationRequest with the new rate.
   * It is possible to specify a rate over time (for example, 100 ml/hour) using either the rateRatio and rateQuantity.  The rateQuantity approach requires systems to have the capability to parse UCUM grammar where ml/hour is included rather than a specific ratio where the time is specified as the denominator.  Where a rate such as 500ml over 2 hours is specified, the use of rateRatio may be more semantically correct than specifying using a rateQuantity of 250 mg/hour.
   */
  rateQuantity?: Quantity | undefined;
  /**
   * The kind of dose or rate specified, for example, ordered or calculated.
   */
  type?: CodeableConcept | undefined;
}
/**
 * Indicates how the medication is/was taken or should be taken by the patient.
 */
export interface Dosage extends BackboneType {
  /**
   * Information about administration or preparation of the medication (e.g. "infuse as rapidly as possibly via intraperitoneal port" or take "immediately following drug x") should be populated in dosage.text.
   */
  additionalInstruction?: CodeableConcept[] | undefined;
  /**
   * Can express "as needed" without a reason by setting the Boolean = True.  In this case the CodeableConcept is not populated.
   */
  asNeeded?: boolean | undefined;
  _asNeeded?: Element | undefined;
  /**
   * Can express "as needed" with a reason by including the CodeableConcept.  In this case the Boolean is assumed to be False, then the dose is given according to the schedule and is not "prn" or "as needed".
   */
  asNeededFor?: CodeableConcept[] | undefined;
  /**
   * Depending on the resource,this is the amount of medication administered, to  be administered or typical amount to be administered.
   */
  doseAndRate?: DosageDoseAndRate[] | undefined;
  /**
   * This is intended for use as an adjunct to the dosage when there is an upper cap.  For example, a body surface area related dose with a maximum amount, such as 1.5 mg/m2 (maximum 2 mg) IV over 5  10 minutes would have doseQuantity of 1.5 mg/m2 and maxDosePerAdministration of 2 mg.
   */
  maxDosePerAdministration?: Quantity | undefined;
  /**
   * Upper limit on medication per lifetime of the patient.
   */
  maxDosePerLifetime?: Quantity | undefined;
  /**
   * This is intended for use as an adjunct to the dosage when there is an upper cap.  For example "2 tablets every 4 hours to a maximum of 8/day".
   */
  maxDosePerPeriod?: Ratio[] | undefined;
  /**
   * Terminologies used often pre-coordinate this term with the route and or form of administration.
   */
  method?: CodeableConcept | undefined;
  /**
   * Instructions in terms that are understood by the patient or consumer.
   */
  patientInstruction?: string | undefined;
  _patientInstruction?: Element | undefined;
  /**
   * How drug should enter body.
   */
  route?: CodeableConcept | undefined;
  /**
   * Indicates the order in which the dosage instructions should be applied or interpreted.
   */
  sequence?: number | undefined;
  /**
   * If the use case requires attributes from the BodySite resource (e.g. to identify and track separately) then use the standard extension [http://hl7.org/fhir/StructureDefinition/bodySite](http://hl7.org/fhir/extensions/StructureDefinition-bodySite.html).  May be a summary code, or a reference to a very precise definition of the location, or both.
   */
  site?: CodeableConcept | undefined;
  /**
   * Free text dosage instructions e.g. SIG.
   */
  text?: string | undefined;
  _text?: Element | undefined;
  /**
   * This attribute might not always be populated while the Dosage.text is expected to be populated.  If both are populated, then the Dosage.text should reflect the content of the Dosage.timing.
   */
  timing?: Timing | undefined;
}
/**
 * A length of time.
 */
export interface Duration extends Quantity {}
/**
 * A expression that is evaluated in a specified context and returns a value. The context of use of the expression must specify the context in which the expression is evaluated, and how the result of the expression is used.
 */
export interface Expression extends DataType {
  /**
   * A brief, natural language description of the condition that effectively communicates the intended semantics.
   */
  description?: string | undefined;
  _description?: Element | undefined;
  /**
   * If Expression.expression and Expression.reference are both present, the Expression.expression might just be a name pointing something within the referenced content.
   */
  expression?: string | undefined;
  _expression?: Element | undefined;
  /**
   * The media type of the language for the expression.
   */
  language?: string | undefined;
  _language?: Element | undefined;
  /**
   * A short name assigned to the expression to allow for multiple reuse of the expression in the context where it is defined.
   */
  name?: string | undefined;
  _name?: Element | undefined;
  /**
   * If both a reference and an expression is found, the reference SHALL point to the same expression.
   */
  reference?: string | undefined;
  _reference?: Element | undefined;
}
/**
 * Specifies contact information for a specific purpose over a period of time, might be handled/monitored by a specific named person or organization.
 */
export interface ExtendedContactDetail extends DataType {
  /**
   * More than 1 address would be for different purposes, and thus should be entered as a different entry,.
   */
  address?: Address | undefined;
  /**
   * If there is no named individual, the telecom/address information is not generally monitored by a specific individual.
   */
  name?: HumanName[] | undefined;
  /**
   * This contact detail is handled/monitored by a specific organization. If the name is provided in the contact, then it is referring to the named individual within this organization.
   */
  organization?: Reference | undefined;
  /**
   * If the details have multiple periods, then enter in a new ExtendedContact with the new period.
   */
  period?: Period | undefined;
  /**
   * If no purpose is defined, then these contact details may be used for any purpose.
   */
  purpose?: CodeableConcept | undefined;
  /**
   * The contact details application for the purpose defined.
   */
  telecom?: ContactPoint[] | undefined;
}
/**
 * A name, normally of a human, that can be used for other living entities (e.g. animals but not organizations) that have been assigned names by a human and may need the use of name parts or the need for usage information.
 */
export interface HumanName extends DataType {
  /**
   * Family Name may be decomposed into specific parts using extensions (de, nl, es related cultures).
   */
  family?: string | undefined;
  _family?: Element | undefined;
  /**
   * If only initials are recorded, they may be used in place of the full name parts. Initials may be separated into multiple given names but often aren't due to paractical limitations.  This element is not called "first name" since given names do not always come first.
   */
  given?: string[] | undefined;
  _given?: Element[] | undefined;
  /**
   * Indicates the period of time when this name was valid for the named person.
   */
  period?: Period | undefined;
  /**
   * Part of the name that is acquired as a title due to academic, legal, employment or nobility status, etc. and that appears at the start of the name.
   */
  prefix?: string[] | undefined;
  _prefix?: Element[] | undefined;
  /**
   * Part of the name that is acquired as a title due to academic, legal, employment or nobility status, etc. and that appears at the end of the name.
   */
  suffix?: string[] | undefined;
  _suffix?: Element[] | undefined;
  /**
   * Can provide both a text representation and parts. Applications updating a name SHALL ensure that when both text and parts are present,  no content is included in the text that isn't found in a part.
   */
  text?: string | undefined;
  _text?: Element | undefined;
  /**
   * Applications can assume that a name is current unless it explicitly says that it is temporary or old.
   */
  use?: ('usual' | 'official' | 'temp' | 'nickname' | 'anonymous' | 'old' | 'maiden') | undefined;
  _use?: Element | undefined;
}
/**
 * An identifier - identifies some entity uniquely and unambiguously. Typically this is used for business identifiers.
 */
export interface Identifier extends DataType {
  /**
   * The Identifier.assigner may omit the .reference element and only contain a .display element reflecting the name or other textual information about the assigning organization.
   */
  assigner?: Reference | undefined;
  /**
   * Time period during which identifier is/was valid for use.
   */
  period?: Period | undefined;
  /**
   * Identifier.system is always case sensitive.
   */
  system?: string | undefined;
  _system?: Element | undefined;
  /**
   * This element deals only with general categories of identifiers.  It SHOULD not be used for codes that correspond 1..1 with the Identifier.system. Some identifiers may fall into multiple categories due to common usage.   Where the system is known, a type is unnecessary because the type is always part of the system definition. However systems often need to handle identifiers where the system is not known. There is not a 1:1 relationship between type and system, since many different systems have the same type.
   */
  type?: CodeableConcept | undefined;
  /**
   * Applications can assume that an identifier is permanent unless it explicitly says that it is temporary.
   */
  use?: ('usual' | 'official' | 'temp' | 'secondary' | 'old') | undefined;
  _use?: Element | undefined;
  /**
   * If the value is a full URI, then the system SHALL be urn:ietf:rfc:3986.  The value's primary purpose is computational mapping.  As a result, it may be normalized for comparison purposes (e.g. removing non-significant whitespace, dashes, etc.)  A value formatted for human display can be conveyed using the [http://hl7.org/fhir/StructureDefinition/rendered-value](http://hl7.org/fhir/extensions/StructureDefinition-rendered-value.html)). Identifier.value is to be treated as case sensitive unless knowledge of the Identifier.system allows the processer to be confident that non-case-sensitive processing is safe.
   */
  value?: string | undefined;
  _value?: Element | undefined;
}
/**
 * The metadata about a resource. This is content in the resource that is maintained by the infrastructure. Changes to the content might not always be associated with version changes to the resource.
 */
export interface Meta extends DataType {
  /**
   * This element is generally omitted in instances submitted in a PUT or POST. Instead, it is populated in the response instance and when retrieving information using a GET. The server / resource manager sets this value; what a client provides is irrelevant. This is equivalent to the HTTP Last-Modified and SHOULD have the same value on a [read](http.html#read) interaction.
   */
  lastUpdated?: string | undefined;
  _lastUpdated?: Element | undefined;
  /**
   * It is up to the server and/or other infrastructure of policy to determine whether/how these claims are verified and/or updated over time.  The list of profile URLs is a set.
   */
  profile?: string[] | undefined;
  _profile?: Element[] | undefined;
  /**
   * The security labels can be updated without changing the stated version of the resource. The list of security labels is a set. Uniqueness is based the system/code, and version and display are ignored.
   */
  security?: Coding[] | undefined;
  /**
   * The exact use of the source (and the possible implied Provenance.entity.role and agent.role) is left to implementer discretion. Only one nominated source is allowed; for additional provenance details, a full Provenance resource should be used. The source may correspond to Provenance.entity.what[x] or Provenance.agent.who[x], though it may be a more general or abstract reference.
   * This element can be used to indicate where the current master source of a resource that has a canonical URL if the resource is no longer hosted at the canonical URL.
   */
  source?: string | undefined;
  _source?: Element | undefined;
  /**
   * The tags can be updated without changing the stated version of the resource. The list of tags is a set. Uniqueness is based the system/code, and version and display are ignored.
   */
  tag?: Coding[] | undefined;
  /**
   * The server assigns this value, and ignores what the client specifies, except in the case that the server is imposing version integrity on updates/deletes.
   */
  versionId?: string | undefined;
  _versionId?: Element | undefined;
}
/**
 * An amount of economic utility in some recognized currency.
 */
export interface Money extends DataType {
  /**
   * ISO 4217 Currency Code.
   */
  currency?: string | undefined;
  _currency?: Element | undefined;
  /**
   * Monetary values have their own rules for handling precision (refer to standard accounting text books).
   */
  value?: number | undefined;
}
/**
 * A human-readable summary of the resource conveying the essential clinical and business information for the resource.
 */
export interface Narrative extends DataType {
  /**
   * The contents of the html element are an XHTML fragment containing only the basic html formatting elements described in chapters 7-11 and 15 of the HTML 4.0 standard, <a> elements (either name or href), images and internally contained stylesheets. The XHTML content SHALL NOT contain a head, a body, external stylesheet references, scripts, forms, base/link/xlink, frames, iframes and objects.
   */
  div: string;
  _div?: Element | undefined;
  /**
   * The status of the narrative - whether it's entirely generated (from just the defined data or the extensions too), or whether a human authored it and it may contain additional data.
   */
  status: 'generated' | 'extensions' | 'additional' | 'empty';
  _status?: Element | undefined;
}
/**
 * The parameters to the module. This collection specifies both the input and output parameters. Input parameters are provided by the caller as part of the $evaluate operation. Output parameters are included in the GuidanceResponse.
 */
export interface ParameterDefinition extends DataType {
  /**
   * A brief discussion of what the parameter is for and how it is used by the module.
   */
  documentation?: string | undefined;
  _documentation?: Element | undefined;
  /**
   * The maximum number of times this element is permitted to appear in the request or response.
   */
  max?: string | undefined;
  _max?: Element | undefined;
  /**
   * The minimum number of times this parameter SHALL appear in the request or response.
   */
  min?: number | undefined;
  /**
   * The name of the parameter used to allow access to the value of the parameter in evaluation contexts.
   */
  name?: string | undefined;
  _name?: Element | undefined;
  /**
   * If specified, this indicates a profile that the input data must conform to, or that the output data will conform to.
   */
  profile?: string | undefined;
  _profile?: Element | undefined;
  /**
   * The type of the parameter.
   */
  type: string;
  _type?: Element | undefined;
  /**
   * Whether the parameter is input or output for the module.
   */
  use: 'in' | 'out';
  _use?: Element | undefined;
}
/**
 * A time period defined by a start and end date and optionally time.
 */
export interface Period extends DataType {
  /**
   * The end value includes any matching date/time. i.e. 2012-02-03T10:00:00 is in a period that has an end value of 2012-02-03.
   */
  end?: string | undefined;
  _end?: Element | undefined;
  /**
   * If the low element is missing, the meaning is that the low boundary is not known.
   */
  start?: string | undefined;
  _start?: Element | undefined;
}
/**
 * A measured amount (or an amount that can potentially be measured). Note that measured amounts include amounts that are not precisely quantified, including amounts involving arbitrary units and floating currencies.
 */
export interface Quantity extends DataType {
  /**
   * The preferred system is UCUM, but SNOMED CT can also be used (for customary units) or ISO 4217 for currency.  The context of use may additionally require a code from a particular system.
   */
  code?: string | undefined;
  _code?: Element | undefined;
  /**
   * How the value should be understood and represented - whether the actual value is greater or less than the stated value due to measurement issues; e.g. if the comparator is "<" , then the real value is < stated value.
   */
  comparator?: ('<' | '<=' | '>=' | '>' | 'ad') | undefined;
  _comparator?: Element | undefined;
  /**
   * The identification of the system that provides the coded form of the unit.
   */
  system?: string | undefined;
  _system?: Element | undefined;
  /**
   * A human-readable form of the unit.
   */
  unit?: string | undefined;
  _unit?: Element | undefined;
  /**
   * The implicit precision in the value should always be honored. Monetary values have their own rules for handling precision (refer to standard accounting text books).
   */
  value?: number | undefined;
}
/**
 * A set of ordered Quantities defined by a low and high limit.
 */
export interface Range extends DataType {
  /**
   * If the high element is missing, the high boundary is not known.
   */
  high?: Quantity | undefined;
  /**
   * If the low element is missing, the low boundary is not known.
   */
  low?: Quantity | undefined;
}
/**
 * A relationship of two Quantity values - expressed as a numerator and a denominator.
 */
export interface Ratio extends DataType {
  /**
   * The value of the denominator.
   */
  denominator?: Quantity | undefined;
  /**
   * The value of the numerator.
   */
  numerator?: Quantity | undefined;
}
/**
 * A range of ratios expressed as a low and high numerator and a denominator.
 */
export interface RatioRange extends DataType {
  /**
   * The value of the denominator.
   */
  denominator?: Quantity | undefined;
  /**
   * If the high element is missing, the high boundary is not known.
   */
  highNumerator?: Quantity | undefined;
  /**
   * If the low element is missing, the low boundary is not known.
   */
  lowNumerator?: Quantity | undefined;
}
/**
 * A reference from one resource to another.
 */
export interface Reference extends DataType {
  /**
   * This is generally not the same as the Resource.text of the referenced resource.  The purpose is to identify what's being referenced, not to fully describe it.
   */
  display?: string | undefined;
  _display?: Element | undefined;
  /**
   * When an identifier is provided in place of a reference, any system processing the reference will only be able to resolve the identifier to a reference if it understands the business context in which the identifier is used. Sometimes this is global (e.g. a national identifier) but often it is not. For this reason, none of the useful mechanisms described for working with references (e.g. chaining, includes) are possible, nor should servers be expected to be able resolve the reference. Servers may accept an identifier based reference untouched, resolve it, and/or reject it - see CapabilityStatement.rest.resource.referencePolicy.
   * When both an identifier and a literal reference are provided, the literal reference is preferred. Applications processing the resource are allowed - but not required - to check that the identifier matches the literal reference
   * Applications converting a logical reference to a literal reference may choose to leave the logical reference present, or remove it.
   * Reference is intended to point to a structure that can potentially be expressed as a FHIR resource, though there is no need for it to exist as an actual FHIR resource instance - except in as much as an application wishes to actual find the target of the reference. The content referred to be the identifier must meet the logical constraints implied by any limitations on what resource types are permitted for the reference.  For example, it would not be legitimate to send the identifier for a drug prescription if the type were Reference(Observation|DiagnosticReport).  One of the use-cases for Reference.identifier is the situation where no FHIR representation exists (where the type is Reference (Any).
   * This element only allows for a single identifier. In the case where additional identifers are required, use the [http://hl7.org/fhir/StructureDefinition/additionalIdentifier](http://hl7.org/fhir/extensions/StructureDefinition-additionalIdentifier.html) extension.
   */
  identifier?: Identifier | undefined;
  /**
   * Using absolute URLs provides a stable scalable approach suitable for a cloud/web context, while using relative/logical references provides a flexible approach suitable for use when trading across closed eco-system boundaries.   Absolute URLs do not need to point to a FHIR RESTful server, though this is the preferred approach. If the URL conforms to the structure "[type]/[id]" then it should be assumed that the reference is to a FHIR RESTful server.
   */
  reference?: string | undefined;
  _reference?: Element | undefined;
  /**
   * This element is used to indicate the type of  the target of the reference. This may be used which ever of the other elements are populated (or not). In some cases, the type of the target may be determined by inspection of the reference (e.g. a known RESTful URL) or by resolving the target of the reference.
   */
  type?: string | undefined;
  _type?: Element | undefined;
}
/**
 * Related artifacts such as additional documentation, justification, or bibliographic references.
 */
export interface RelatedArtifact extends DataType {
  /**
   * Additional structured information about citations should be captured as extensions.
   */
  citation?: string | undefined;
  _citation?: Element | undefined;
  /**
   * Provides additional classifiers of the related artifact.
   */
  classifier?: CodeableConcept[] | undefined;
  /**
   * A brief description of the document or knowledge resource being referenced, suitable for display to a consumer.
   */
  display?: string | undefined;
  _display?: Element | undefined;
  /**
   * The document being referenced, represented as an attachment. This is exclusive with the resource element.
   */
  document?: Attachment | undefined;
  /**
   * A short label that can be used to reference the citation from elsewhere in the containing artifact, such as a footnote index.
   */
  label?: string | undefined;
  _label?: Element | undefined;
  /**
   * The date of publication of the artifact being referred to.
   */
  publicationDate?: string | undefined;
  _publicationDate?: Element | undefined;
  /**
   * The publication status of the artifact being referred to.
   */
  publicationStatus?: ('draft' | 'active' | 'retired' | 'unknown') | undefined;
  _publicationStatus?: Element | undefined;
  /**
   * If the type is predecessor, this is a reference to the succeeding knowledge resource. If the type is successor, this is a reference to the prior knowledge resource.
   */
  resource?: string | undefined;
  _resource?: Element | undefined;
  /**
   * If both resource and resourceReference are present, they SHOULD be consistent and reference the same resource. Although relatedArtifact is intended to support references to definitional resources, there are cases where non-definitional resources can be definitional (such as Location where the kind is mode). Related artifacts SHOULD be used to reference definitional resources, and profiles SHOULD be used to make that explicit for particular use cases.
   */
  resourceReference?: Reference | undefined;
  /**
   * The presence of both sides of a relationship type (e.g. successor and predecessor) is required to support use cases where one side of a relationship is not represented in FHIR. However, this feature SHALL NOT be used to create bi-directional resource links in FHIR instances. Specifically, following the methodology of "new points to old" and "many points to one", when using related artifact elements to describe and reference FHIR resources, the type element SHALL be drawn from the fhir-related-artifact-type ValueSet.
   */
  type:
    | 'documentation'
    | 'justification'
    | 'citation'
    | 'predecessor'
    | 'successor'
    | 'derived-from'
    | 'depends-on'
    | 'composed-of'
    | 'part-of'
    | 'amends'
    | 'amended-with'
    | 'appends'
    | 'appended-with'
    | 'cites'
    | 'cited-by'
    | 'comments-on'
    | 'comment-in'
    | 'contains'
    | 'contained-in'
    | 'corrects'
    | 'correction-in'
    | 'replaces'
    | 'replaced-with'
    | 'retracts'
    | 'retracted-by'
    | 'signs'
    | 'similar-to'
    | 'supports'
    | 'supported-with'
    | 'transforms'
    | 'transformed-into'
    | 'transformed-with'
    | 'documents'
    | 'specification-of'
    | 'created-with'
    | 'cite-as';
  _type?: Element | undefined;
}
/**
 * A series of measurements taken by a device, with upper and lower limits. There may be more than one dimension in the data.
 */
export interface SampledData extends DataType {
  /**
   * The ConceptMap cannot define meanings for the codes 'E', 'U', or 'L' (nor 'e', 'u', or 'l').
   */
  codeMap?: string | undefined;
  _codeMap?: Element | undefined;
  /**
   * The data may be missing if it is omitted for summarization purposes. In general, data is required for any actual use of a SampledData.
   */
  data?: string | undefined;
  _data?: Element | undefined;
  /**
   * If there is more than one dimension, the code for the type of data will define the meaning of the dimensions (typically ECG data).
   */
  dimensions: number;
  /**
   * A correction factor that is applied to the sampled data points before they are added to the origin.
   */
  factor?: number | undefined;
  /**
   * This is usually a whole number.
   */
  interval?: number | undefined;
  /**
   * The measurement unit in which the sample interval is expressed.
   */
  intervalUnit: string;
  _intervalUnit?: Element | undefined;
  /**
   * The lower limit of detection of the measured points. This is needed if any of the data points have the value "L" (lower than detection limit).
   */
  lowerLimit?: number | undefined;
  /**
   * If offsets is present, the number of data points must be equal to the number of offsets mlutipled by the dimensions.
   */
  offsets?: string | undefined;
  _offsets?: Element | undefined;
  /**
   * The base quantity that a measured value of zero represents. In addition, this provides the units of the entire measurement series.
   */
  origin: Quantity;
  /**
   * The upper limit of detection of the measured points. This is needed if any of the data points have the value "U" (higher than detection limit).
   */
  upperLimit?: number | undefined;
}
/**
 * A signature along with supporting context. The signature may be a digital signature that is cryptographic in nature, or some other signature acceptable to the domain. This other signature may be as simple as a graphical image representing a hand-written signature, or a signature ceremony Different signature approaches have different utilities.
 */
export interface Signature extends DataType {
  /**
   * Where the signature type is an XML DigSig, the signed content is a FHIR Resource(s), the signature is of the XML form of the Resource(s) using  XML-Signature (XMLDIG) "Detached Signature" form.
   */
  data?: string | undefined;
  _data?: Element | undefined;
  /**
   * The party that can't sign. For example a child.
   */
  onBehalfOf?: Reference | undefined;
  /**
   * A mime type that indicates the technical format of the signature. Important mime types are application/signature+xml for X ML DigSig, application/jose for JWS, and image/* for a graphical image of a signature, etc.
   */
  sigFormat?: string | undefined;
  _sigFormat?: Element | undefined;
  /**
   * "xml", "json" and "ttl" are allowed, which describe the simple encodings described in the specification (and imply appropriate bundle support). Otherwise, mime types are legal here.
   */
  targetFormat?: string | undefined;
  _targetFormat?: Element | undefined;
  /**
   * Examples include attesting to: authorship, correct transcription, and witness of specific event. Also known as a &quot;Commitment Type Indication&quot;.
   */
  type?: Coding[] | undefined;
  /**
   * This should agree with the information in the signature.
   */
  when?: string | undefined;
  _when?: Element | undefined;
  /**
   * This should agree with the information in the signature.
   */
  who?: Reference | undefined;
}
/**
 * A set of rules that describe when the event is scheduled.
 */
export interface TimingRepeat extends Element {
  /**
   * Either a duration for the length of the timing schedule, a range of possible length, or outer bounds for start and/or end limits of the timing schedule.
   */
  boundsDuration?: Duration | undefined;
  /**
   * Either a duration for the length of the timing schedule, a range of possible length, or outer bounds for start and/or end limits of the timing schedule.
   */
  boundsRange?: Range | undefined;
  /**
   * Either a duration for the length of the timing schedule, a range of possible length, or outer bounds for start and/or end limits of the timing schedule.
   */
  boundsPeriod?: Period | undefined;
  /**
   * If you have both bounds and count, then this should be understood as within the bounds period, until count times happens.
   */
  count?: number | undefined;
  /**
   * If present, indicates that the count is a range - so to perform the action between [count] and [countMax] times.
   */
  countMax?: number | undefined;
  /**
   * If no days are specified, the action is assumed to happen every day as otherwise specified.
   */
  dayOfWeek?: ('mon' | 'tue' | 'wed' | 'thu' | 'fri' | 'sat' | 'sun')[] | undefined;
  _dayOfWeek?: Element[] | undefined;
  /**
   * For some events the duration is part of the definition of the event (e.g. IV infusions, where the duration is implicit in the specified quantity and rate). For others, it's part of the timing specification (e.g. exercise).
   */
  duration?: number | undefined;
  /**
   * For some events the duration is part of the definition of the event (e.g. IV infusions, where the duration is implicit in the specified quantity and rate). For others, it's part of the timing specification (e.g. exercise).
   */
  durationMax?: number | undefined;
  /**
   * The units of time for the duration, in UCUM units
   * Normal practice is to use the 'mo' code as a calendar month when calculating the next occurrence.
   */
  durationUnit?: ('s' | 'min' | 'h' | 'd' | 'wk' | 'mo' | 'a') | undefined;
  _durationUnit?: Element | undefined;
  /**
   * The number of times to repeat the action within the specified period. If frequencyMax is present, this element indicates the lower bound of the allowed range of the frequency.
   */
  frequency?: number | undefined;
  /**
   * If present, indicates that the frequency is a range - so to repeat between [frequency] and [frequencyMax] times within the period or period range.
   */
  frequencyMax?: number | undefined;
  /**
   * The number of minutes from the event. If the event code does not indicate whether the minutes is before or after the event, then the offset is assumed to be after the event.
   */
  offset?: number | undefined;
  /**
   * Indicates the duration of time over which repetitions are to occur; e.g. to express "3 times per day", 3 would be the frequency and "1 day" would be the period. If periodMax is present, this element indicates the lower bound of the allowed range of the period length.
   */
  period?: number | undefined;
  /**
   * If present, indicates that the period is a range from [period] to [periodMax], allowing expressing concepts such as "do this once every 3-5 days.
   */
  periodMax?: number | undefined;
  /**
   * The units of time for the period in UCUM units
   * Normal practice is to use the 'mo' code as a calendar month when calculating the next occurrence.
   */
  periodUnit?: ('s' | 'min' | 'h' | 'd' | 'wk' | 'mo' | 'a') | undefined;
  _periodUnit?: Element | undefined;
  /**
   * When time of day is specified, it is inferred that the action happens every day (as filtered by dayofWeek) on the specified times. If there's a timeOfDay, there cannot be a when, or vice versa.
   */
  timeOfDay?: string[] | undefined;
  _timeOfDay?: Element[] | undefined;
  /**
   * When more than one event is listed, the event is tied to the union of the specified events.
   */
  when?: string[] | undefined;
  _when?: Element[] | undefined;
}
/**
 * Specifies an event that may occur multiple times. Timing schedules are used to record when things are planned, expected or requested to occur. The most common usage is in dosage instructions for medications. They are also used when planning care of various kinds, and may be used for reporting the schedule to which past regular activities were carried out.
 */
export interface Timing extends BackboneType {
  /**
   * BID etc. are defined as 'at institutionally specified times'. For example, an institution may choose that BID is "always at 7am and 6pm".  If it is inappropriate for this choice to be made, the code BID should not be used. Instead, a distinct organization-specific code should be used in place of the HL7-defined BID code and/or a structured representation should be used (in this case, specifying the two event times).
   */
  code?: CodeableConcept | undefined;
  /**
   * Identifies specific times when the event occurs.
   */
  event?: string[] | undefined;
  _event?: Element[] | undefined;
  /**
   * A set of rules that describe when the event is scheduled.
   */
  repeat?: TimingRepeat | undefined;
}
/**
 * A description of a triggering event. Triggering events can be named events, data events, or periodic, as determined by the type element.
 */
export interface TriggerDefinition extends DataType {
  /**
   * A code that identifies the event.
   */
  code?: CodeableConcept | undefined;
  /**
   * This element can be only be specified for data type triggers and provides additional semantics for the trigger. The context available within the condition is based on the type of data event. For all events, the current resource will be available as context. In addition, for modification events, the previous resource will also be available. The expression may be inlined, or may be a simple absolute URI, which is a reference to a named expression within a logic library referenced by a library element or extension within the containing resource. If the expression is a FHIR Path expression, it evaluates in the context of a resource of one of the type identified in the data requirement, and may also refer to the variable %previous for delta comparisons on events of type data-changed, data-modified, and data-deleted which will always have the same type.
   */
  condition?: Expression | undefined;
  /**
   * This element shall be present for any data type trigger.
   */
  data?: DataRequirement[] | undefined;
  /**
   * An event name can be provided for all event types, but is required for named events. If a name is provided for a type other than named events, it is considered to be a shorthand for the semantics described by the formal description of the event.
   */
  name?: string | undefined;
  _name?: Element | undefined;
  /**
   * A reference to a SubscriptionTopic resource that defines the event. If this element is provided, no other information about the trigger definition may be supplied.
   */
  subscriptionTopic?: string | undefined;
  _subscriptionTopic?: Element | undefined;
  /**
   * The timing of the event (if this is a periodic trigger).
   */
  timingTiming?: Timing | undefined;
  /**
   * The timing of the event (if this is a periodic trigger).
   */
  timingReference?: Reference | undefined;
  /**
   * The timing of the event (if this is a periodic trigger).
   */
  timingDate?: string | undefined;
  _timingDate?: Element | undefined;
  /**
   * The timing of the event (if this is a periodic trigger).
   */
  timingDateTime?: string | undefined;
  _timingDateTime?: Element | undefined;
  /**
   * The type of triggering event.
   */
  type:
    | 'named-event'
    | 'periodic'
    | 'data-changed'
    | 'data-added'
    | 'data-modified'
    | 'data-removed'
    | 'data-accessed'
    | 'data-access-ended';
  _type?: Element | undefined;
}
/**
 * Specifies clinical/business/etc. metadata that can be used to retrieve, index and/or categorize an artifact. This metadata can either be specific to the applicable population (e.g., age category, DRG) or the specific context of care (e.g., venue, care setting, provider of care).
 */
export interface UsageContext extends DataType {
  /**
   * A code that identifies the type of context being specified by this usage context.
   */
  code: Coding;
  /**
   * A value that defines the context specified in this context of use. The interpretation of the value is defined by the code.
   */
  valueCodeableConcept?: CodeableConcept | undefined;
  /**
   * A value that defines the context specified in this context of use. The interpretation of the value is defined by the code.
   */
  valueQuantity?: Quantity | undefined;
  /**
   * A value that defines the context specified in this context of use. The interpretation of the value is defined by the code.
   */
  valueRange?: Range | undefined;
  /**
   * A value that defines the context specified in this context of use. The interpretation of the value is defined by the code.
   */
  valueReference?: Reference | undefined;
}

/**
 * This is the base resource type for everything.
 */
export interface Resource extends Base {
  /** Resource Type Name (for serialization) */
  readonly resourceType: string;
  /**
   * Within the context of the FHIR RESTful interactions, the resource has an id except for cases like the create and conditional update. Otherwise, the use of the resouce id depends on the given use case.
   */
  id?: string | undefined;
  _id?: Element | undefined;
  /**
   * Asserting this rule set restricts the content to be only understood by a limited set of trading partners. This inherently limits the usefulness of the data in the long term. However, the existing health eco-system is highly fractured, and not yet ready to define, collect, and exchange data in a generally computable sense. Wherever possible, implementers and/or specification writers should avoid using this element. Often, when used, the URL is a reference to an implementation guide that defines these special rules as part of its narrative along with other profiles, value sets, etc.
   */
  implicitRules?: string | undefined;
  _implicitRules?: Element | undefined;
  /**
   * Language is provided to support indexing and accessibility (typically, services such as text to speech use the language tag). The html language tag in the narrative applies  to the narrative. The language tag on the resource may be used to specify the language of other presentations generated from the data in the resource. Not all the content has to be in the base language. The Resource.language should not be assumed to apply to the narrative automatically. If a language is specified, it should it also be specified on the div element in the html (see rules in HTML5 for information about the relationship between xml:lang and the html lang attribute).
   */
  language?: string | undefined;
  _language?: Element | undefined;
  /**
   * The metadata about the resource. This is content that is maintained by the infrastructure. Changes to the content might not always be associated with version changes to the resource.
   */
  meta?: Meta | undefined;
}
/**
 * A resource that includes narrative, extensions, and contained resources.
 */
export interface DomainResource extends Resource {
  /** Resource Type Name (for serialization) */
  readonly resourceType: string;
  /**
   * This should never be done when the content can be identified properly, as once identification is lost, it is extremely difficult (and context dependent) to restore it again. Contained resources may have profiles and tags in their meta elements, but SHALL NOT have security labels.
   */
  contained?: FhirResource[] | undefined;
  /**
   * There can be no stigma associated with the use of extensions by any application, project, or standard - regardless of the institution or jurisdiction that uses or defines the extensions.  The use of extensions is what allows the FHIR specification to retain a core level of simplicity for everyone.
   */
  extension?: Extension[] | undefined;
  /**
   * There can be no stigma associated with the use of extensions by any application, project, or standard - regardless of the institution or jurisdiction that uses or defines the extensions.  The use of extensions is what allows the FHIR specification to retain a core level of simplicity for everyone.
   */
  modifierExtension?: Extension[] | undefined;
  /**
   * Contained resources do not have a narrative. Resources that are not contained SHOULD have a narrative. In some cases, a resource may only have text with little or no additional discrete data (as long as all minOccurs=1 elements are satisfied).  This may be necessary for data from legacy systems where information is captured as a "text blob" or where text is additionally entered raw or narrated and encoded information is added later.
   */
  text?: Narrative | undefined;
}

/**
 * Note that filters defined in code systems usually require custom code on the part of any terminology engine that will make them available for use in value set filters. For this reason, they are generally only seen in high value published terminologies.
 */
export interface CodeSystemFilter extends BackboneElement {
  /**
   * The code that identifies this filter when it is used as a filter in [ValueSet](valueset.html#).compose.include.filter.
   */
  code: string;
  _code?: Element | undefined;
  /**
   * A description of how or why the filter is used.
   */
  description?: string | undefined;
  _description?: Element | undefined;
  /**
   * A list of operators that can be used with the filter.
   */
  operator: (
    | '='
    | 'is-a'
    | 'descendent-of'
    | 'is-not-a'
    | 'regex'
    | 'in'
    | 'not-in'
    | 'generalizes'
    | 'child-of'
    | 'descendent-leaf'
    | 'exists'
  )[];
  _operator?: Element[] | undefined;
  /**
   * A description of what the value for the filter should be.
   */
  value: string;
  _value?: Element | undefined;
}
/**
 * Multiple occurrences of CodeSystem.concept.property may occur for a CodeSystem.property where     CodeSystem.concept.property.code is the same and CodeSystem.concept.property.value differs. For example: multiple designations for a single concept.
 */
export interface CodeSystemProperty extends BackboneElement {
  /**
   * A code that is used to identify the property. The code is used internally (in CodeSystem.concept.property.code) and also externally, such as in property filters.
   */
  code: string;
  _code?: Element | undefined;
  /**
   * A description of the property- why it is defined, and how its value might be used.
   */
  description?: string | undefined;
  _description?: Element | undefined;
  /**
   * The type of the property value. Properties of type "code" contain a code defined by the code system (e.g. a reference to another defined concept).
   */
  type: 'code' | 'Coding' | 'string' | 'integer' | 'boolean' | 'dateTime' | 'decimal';
  _type?: Element | undefined;
  /**
   * Reference to the formal meaning of the property. One possible source of meaning is the [Concept Properties](codesystem-concept-properties.html) code system.
   */
  uri?: string | undefined;
  _uri?: Element | undefined;
}
/**
 * Concepts have both a ```display``` and an array of ```designation```. The display is equivalent to a special designation with an implied ```designation.use``` of "primary code" and a language equal to the [Resource Language](resource.html#language).
 */
export interface CodeSystemConceptDesignation extends BackboneElement {
  /**
   * This was added rather than increasing the cardinality of .use to 0..* in order to maintain backward compatibility.
   */
  additionalUse?: Coding[] | undefined;
  /**
   * In the absence of a language, the resource language applies.
   */
  language?: string | undefined;
  _language?: Element | undefined;
  /**
   * If no use is provided, the designation can be assumed to be suitable for general display to a human user.
   */
  use?: Coding | undefined;
  /**
   * The text value for this designation.
   */
  value: string;
  _value?: Element | undefined;
}
/**
 * A property value for this concept.
 */
export interface CodeSystemConceptProperty extends BackboneElement {
  /**
   * A code that is a reference to CodeSystem.property.code.
   */
  code: string;
  _code?: Element | undefined;
  /**
   * The value of this property.
   */
  valueCode?: string | undefined;
  _valueCode?: Element | undefined;
  /**
   * The value of this property.
   */
  valueCoding?: Coding | undefined;
  /**
   * The value of this property.
   */
  valueString?: string | undefined;
  _valueString?: Element | undefined;
  /**
   * The value of this property.
   */
  valueInteger?: number | undefined;
  /**
   * The value of this property.
   */
  valueBoolean?: boolean | undefined;
  _valueBoolean?: Element | undefined;
  /**
   * The value of this property.
   */
  valueDateTime?: string | undefined;
  _valueDateTime?: Element | undefined;
  /**
   * The value of this property.
   */
  valueDecimal?: number | undefined;
}
/**
 * If this is empty, it means that the code system resource does not represent the content of the code system.
 */
export interface CodeSystemConcept extends BackboneElement {
  /**
   * A code - a text symbol - that uniquely identifies the concept within the code system.
   */
  code: string;
  _code?: Element | undefined;
  /**
   * Defines children of a concept to produce a hierarchy of concepts. The nature of the relationships is variable (is-a/contains/categorizes) - see hierarchyMeaning.
   */
  concept?: CodeSystemConcept[] | undefined;
  /**
   * The formal definition of the concept. The code system resource does not make formal definitions required, because of the prevalence of legacy systems. However, they are highly recommended, as without them there is no formal meaning associated with the concept.
   */
  definition?: string | undefined;
  _definition?: Element | undefined;
  /**
   * Concepts have both a ```display``` and an array of ```designation```. The display is equivalent to a special designation with an implied ```designation.use``` of "primary code" and a language equal to the [Resource Language](resource.html#language).
   */
  designation?: CodeSystemConceptDesignation[] | undefined;
  /**
   * A human readable string that is the recommended default way to present this concept to a user.
   */
  display?: string | undefined;
  _display?: Element | undefined;
  /**
   * A property value for this concept.
   */
  property?: CodeSystemConceptProperty[] | undefined;
}
/**
 * The CodeSystem resource is used to declare the existence of and describe a code system or code system supplement and its key properties, and optionally define a part or all of its content.
 */
export interface CodeSystem extends DomainResource {
  /** Resource Type Name (for serialization) */
  readonly resourceType: 'CodeSystem';
  /**
   * The 'date' element may be more recent than the approval date because of minor changes or editorial corrections.
   * See guidance around (not) making local changes to elements [here](canonicalresource.html#localization).
   */
  approvalDate?: string | undefined;
  _approvalDate?: Element | undefined;
  /**
   * An individiual or organization primarily involved in the creation and maintenance of the CodeSystem.
   */
  author?: ContactDetail[] | undefined;
  /**
   * If this value is missing, then it is not specified whether a code system is case sensitive or not. When the rule is not known, Postel's law should be followed: produce codes with the correct case, and accept codes in any case. This element is primarily provided to support validation software.
   */
  caseSensitive?: boolean | undefined;
  _caseSensitive?: Element | undefined;
  /**
   * Note that the code system resource does not define what the compositional grammar is, only whether or not there is one.
   */
  compositional?: boolean | undefined;
  _compositional?: Element | undefined;
  /**
   * If this is empty, it means that the code system resource does not represent the content of the code system.
   */
  concept?: CodeSystemConcept[] | undefined;
  /**
   * May be a web site, an email address, a telephone number, etc.
   * See guidance around (not) making local changes to elements [here](canonicalresource.html#localization).
   */
  contact?: ContactDetail[] | undefined;
  /**
   * The extent of the content of the code system (the concepts and codes it defines) are represented in this resource instance.
   */
  content: 'not-present' | 'example' | 'fragment' | 'complete' | 'supplement';
  _content?: Element | undefined;
  /**
   * ... Sometimes, the copyright differs between the code system and the codes that are included. The copyright statement should clearly differentiate between these when required.
   */
  copyright?: string | undefined;
  _copyright?: Element | undefined;
  /**
   * The (c) symbol should NOT be included in this string. It will be added by software when rendering the notation. Full details about licensing, restrictions, warrantees, etc. goes in the more general 'copyright' element.
   */
  copyrightLabel?: string | undefined;
  _copyrightLabel?: Element | undefined;
  /**
   * The count of concepts defined in this resource cannot be more than this value but may be less for several reasons - see the content element.
   */
  count?: number | undefined;
  /**
   * The date is often not tracked until the resource is published, but may be present on draft content. Note that this is not the same as the resource last-modified-date, since the resource may be a secondary representation of the code system. Additional specific dates may be added as extensions or be found by consulting Provenances associated with past versions of the resource.
   * See guidance around (not) making local changes to elements [here](canonicalresource.html#localization).
   */
  date?: string | undefined;
  _date?: Element | undefined;
  /**
   * This description can be used to capture details such as comments about misuse, instructions for clinical use and interpretation, literature references, examples from the paper world, etc. It is not a rendering of the code system as conveyed in the 'text' field of the resource itself. This item SHOULD be populated unless the information is available from context (e.g. the language of the code system is presumed to be the predominant language in the place the code system was created).
   */
  description?: string | undefined;
  _description?: Element | undefined;
  /**
   * An individual or organization primarily responsible for internal coherence of the CodeSystem.
   */
  editor?: ContactDetail[] | undefined;
  /**
   * The effective period for a CodeSystem  determines when the content is applicable for usage and is independent of publication and review dates. For example, a system intended to be used for the year 2016 might be published in 2015.
   * See guidance around (not) making local changes to elements [here](canonicalresource.html#localization).
   */
  effectivePeriod?: Period | undefined;
  /**
   * See guidance around (not) making local changes to elements [here](canonicalresource.html#localization).
   */
  endorser?: ContactDetail[] | undefined;
  /**
   * Allows filtering of code systems that are appropriate for use versus not.
   */
  experimental?: boolean | undefined;
  _experimental?: Element | undefined;
  /**
   * Note that filters defined in code systems usually require custom code on the part of any terminology engine that will make them available for use in value set filters. For this reason, they are generally only seen in high value published terminologies.
   */
  filter?: CodeSystemFilter[] | undefined;
  /**
   * Note that other representations might have a different hierarchy or none at all, and represent the information using properties.
   */
  hierarchyMeaning?: ('grouped-by' | 'is-a' | 'part-of' | 'classified-with') | undefined;
  _hierarchyMeaning?: Element | undefined;
  /**
   * Typically, this is used for identifiers that can go in an HL7 V3 II (instance identifier) data type, and can then identify this code system outside of FHIR, where it is not possible to use the logical URI.  Note that HL7 defines at least three identifiers for many of its code systems - the FHIR canonical URL, the OID and the V2 Table 0396 mnemonic code.
   */
  identifier?: Identifier[] | undefined;
  /**
   * It may be possible for the code system to be used in jurisdictions other than those for which it was originally designed or intended.
   * DEPRECATION NOTE: For consistency, implementations are encouraged to migrate to using the new 'jurisdiction' code in the useContext element.  (I.e. useContext.code indicating http://terminology.hl7.org/CodeSystem/usage-context-type#jurisdiction and useContext.valueCodeableConcept indicating the jurisdiction.)
   */
  jurisdiction?: CodeableConcept[] | undefined;
  /**
   * If specified, this date follows the original approval date.
   * See guidance around (not) making local changes to elements [here](canonicalresource.html#localization).
   */
  lastReviewDate?: string | undefined;
  _lastReviewDate?: Element | undefined;
  /**
   * The name is not expected to be globally unique. The name should be a simple alphanumeric type name to ensure that it is machine-processing friendly.
   */
  name?: string | undefined;
  _name?: Element | undefined;
  /**
   * Multiple occurrences of CodeSystem.concept.property may occur for a CodeSystem.property where     CodeSystem.concept.property.code is the same and CodeSystem.concept.property.value differs. For example: multiple designations for a single concept.
   */
  property?: CodeSystemProperty[] | undefined;
  /**
   * Usually an organization but may be an individual. The publisher (or steward) of the code system is the organization or individual primarily responsible for the maintenance and upkeep of the code system. This is not necessarily the same individual or organization that developed and initially authored the content. The publisher is the primary point of contact for questions or issues with the code system. This item SHOULD be populated unless the information is available from context.
   */
  publisher?: string | undefined;
  _publisher?: Element | undefined;
  /**
   * This element does not describe the usage of the code system. Instead, it provides traceability of ''why'' the resource is either needed or ''why'' it is defined as it is.  This may be used to point to source materials or specifications that drove the structure of this code system.
   */
  purpose?: string | undefined;
  _purpose?: Element | undefined;
  /**
   * Each related artifact is either an attachment, or a reference to another resource, but not both.
   */
  relatedArtifact?: RelatedArtifact[] | undefined;
  /**
   * See guidance around (not) making local changes to elements [here](canonicalresource.html#localization).
   */
  reviewer?: ContactDetail[] | undefined;
  /**
   * Allows filtering of code systems that are appropriate for use versus not.
   * See guidance around (not) making local changes to elements [here](canonicalresource.html#localization).
   */
  status: 'draft' | 'active' | 'retired' | 'unknown';
  _status?: Element | undefined;
  /**
   * The most common use of a code system supplement is to add additional language support.
   */
  supplements?: string | undefined;
  _supplements?: Element | undefined;
  /**
   * This name does not need to be machine-processing friendly and may contain punctuation, white-space, etc.
   */
  title?: string | undefined;
  _title?: Element | undefined;
  /**
   * DEPRECATION NOTE: For consistency, implementations are encouraged to migrate to using the new 'topic' code in the useContext element.  (I.e. useContext.code indicating http://terminology.hl7.org/CodeSystem/usage-context-type#topic and useContext.valueCodeableConcept indicating the topic)
   */
  topic?: CodeableConcept[] | undefined;
  /**
   * Can be a urn:uuid: or a urn:oid: but real http: addresses are preferred.  Multiple instances may share the same URL if they have a distinct version.
   * The determination of when to create a new version of a resource (same url, new version) vs. defining a new artifact is up to the author.  Considerations for making this decision are found in [Technical and Business Versions](resource.html#versions).
   * In some cases, the resource can no longer be found at the stated url, but the url itself cannot change. Implementations can use the [meta.source](resource.html#meta) element to indicate where the current master source of the resource can be found.
   */
  url?: string | undefined;
  _url?: Element | undefined;
  /**
   * When multiple useContexts are specified, there is no expectation that all or any of the contexts apply.
   */
  useContext?: UsageContext[] | undefined;
  /**
   * The definition of the value set SHALL include all codes from this code system, independent of concept status, and only codes from this code system. It SHALL be immutable, and operations SHOULD support validation of any allowed code compositions.
   */
  valueSet?: string | undefined;
  _valueSet?: Element | undefined;
  /**
   * There may be different code system instances that have the same identifier but different versions.  The version can be appended to the url in a reference to allow a reference to a particular business version of the code system with the format [url]|[version]. The version SHOULD NOT contain a '#' - see [Business Version](resource.html#bv-format).
   */
  version?: string | undefined;
  _version?: Element | undefined;
  /**
   * If set as a string, this is a FHIRPath expression that has two additional context variables passed in - %version1 and %version2 and will return a negative number if version1 is newer, a positive number if version2 and a 0 if the version ordering can't be successfully be determined.
   */
  versionAlgorithmString?: string | undefined;
  _versionAlgorithmString?: Element | undefined;
  /**
   * If set as a string, this is a FHIRPath expression that has two additional context variables passed in - %version1 and %version2 and will return a negative number if version1 is newer, a positive number if version2 and a 0 if the version ordering can't be successfully be determined.
   */
  versionAlgorithmCoding?: Coding | undefined;
  /**
   * Best practice is that code systems do not redefine concepts, or that if concepts are redefined, a new code system definition is created. But this is not always possible, so some code systems may be defined as 'versionNeeded'.
   * Most code systems occasionally refine the displays defined for concepts between versions. Contexts in which the concept display values are validated may require that the version be specified for some code systems irrespective of the value of this property.
   */
  versionNeeded?: boolean | undefined;
  _versionNeeded?: Element | undefined;
}

/**
 * An external specification that the content is mapped to.
 */
export interface StructureDefinitionMapping extends BackboneElement {
  /**
   * Comments about this mapping, including version notes, issues, scope limitations, and other important notes for usage.
   */
  comment?: string | undefined;
  _comment?: Element | undefined;
  /**
   * The specification is described once, with general comments, and then specific mappings are made that reference this declaration.
   */
  identity: string;
  _identity?: Element | undefined;
  /**
   * A name for the specification that is being mapped to.
   */
  name?: string | undefined;
  _name?: Element | undefined;
  /**
   * A formal identity for the specification being mapped to helps with identifying maps consistently.
   */
  uri?: string | undefined;
  _uri?: Element | undefined;
}
/**
 * Identifies the types of resource or data type elements to which the extension can be applied. For more guidance on using the 'context' element, see the [defining extensions page](defining-extensions.html#context).
 */
export interface StructureDefinitionContext extends BackboneElement {
  /**
   * An expression that defines where an extension can be used in resources.
   */
  expression: string;
  _expression?: Element | undefined;
  /**
   * Defines how to interpret the expression that defines what the context of the extension is.
   */
  type: 'fhirpath' | 'element' | 'extension';
  _type?: Element | undefined;
}
/**
 * A snapshot view is expressed in a standalone form that can be used and interpreted without considering the base StructureDefinition.
 */
export interface StructureDefinitionSnapshot extends BackboneElement {
  /**
   * Captures constraints on each element within the resource.
   */
  element: ElementDefinition[];
}
/**
 * A differential view is expressed relative to the base StructureDefinition - a statement of differences that it applies.
 */
export interface StructureDefinitionDifferential extends BackboneElement {
  /**
   * Captures constraints on each element within the resource.
   */
  element: ElementDefinition[];
}
/**
 * A definition of a FHIR structure. This resource is used to describe the underlying resources, data types defined in FHIR, and also for describing extensions and constraints on resources and data types.
 */
export interface StructureDefinition extends DomainResource {
  /** Resource Type Name (for serialization) */
  readonly resourceType: 'StructureDefinition';
  /**
   * Abstract Resources cannot be instantiated - a concrete sub-type must be used. Abstract datatypes and extensions cannot be used in an instance. For logical models, the exact implication of "abstract" will rest with the author, depending how the logical model is used. Flagging a constraint structure as abstract conveys design intent but makes no difference to how the structure definition is handled. Note that inline declared elements that are given the type "Element" in the StructureDefinition, but have children described, are anonymous concrete types that specialize Element.
   */
  abstract: boolean;
  _abstract?: Element | undefined;
  /**
   * If differential constraints are specified in this structure, they are applied to the base in a "differential" fashion. If there is no base, then the differential constraints cannot be provided (snapshot only). Differential structures are useful for the editing perspective, and snapshot structures are suitable for operational use. The FHIR Project provides a number of tools/services to populate snapshots from differential constraints. Logical Models have a base of "Base", "Element" or another logical model.
   */
  baseDefinition?: string | undefined;
  _baseDefinition?: Element | undefined;
  /**
   * May be a web site, an email address, a telephone number, etc.
   * See guidance around (not) making local changes to elements [here](canonicalresource.html#localization).
   */
  contact?: ContactDetail[] | undefined;
  /**
   * Identifies the types of resource or data type elements to which the extension can be applied. For more guidance on using the 'context' element, see the [defining extensions page](defining-extensions.html#context).
   */
  context?: StructureDefinitionContext[] | undefined;
  /**
   * The rules are only evaluated when the extension is present. When evaluating the invariant, the FHIRPath focus is the element that holds the extension, and %extension refers to the extension itself.
   */
  contextInvariant?: string[] | undefined;
  _contextInvariant?: Element[] | undefined;
  /**
   * ...
   */
  copyright?: string | undefined;
  _copyright?: Element | undefined;
  /**
   * The (c) symbol should NOT be included in this string. It will be added by software when rendering the notation. Full details about licensing, restrictions, warrantees, etc. goes in the more general 'copyright' element.
   */
  copyrightLabel?: string | undefined;
  _copyrightLabel?: Element | undefined;
  /**
   * The date is often not tracked until the resource is published, but may be present on draft content. Note that this is not the same as the resource last-modified-date, since the resource may be a secondary representation of the structure definition. Additional specific dates may be added as extensions or be found by consulting Provenances associated with past versions of the resource.
   * See guidance around (not) making local changes to elements [here](canonicalresource.html#localization).
   */
  date?: string | undefined;
  _date?: Element | undefined;
  /**
   * If the definition is a specialization, then it adds to the differential new elements and optionally additional rules to an existing concrete type, and the snapshot includes the inherited elements and rules.  If the definition is a constraint, then it cannot define new elements, it can only make new rules about existing content (see [Profiling Resources](profiling.html#resources)).
   */
  derivation?: ('specialization' | 'constraint') | undefined;
  _derivation?: Element | undefined;
  /**
   * This description can be used to capture details such as comments about misuse, instructions for clinical use and interpretation, literature references, examples from the paper world, etc. It is not a rendering of the structure definition as conveyed in the 'text' field of the resource itself. This item SHOULD be populated unless the information is available from context (e.g. the language of the structure definition is presumed to be the predominant language in the place the structure definition was created).
   */
  description?: string | undefined;
  _description?: Element | undefined;
  /**
   * A differential view is expressed relative to the base StructureDefinition - a statement of differences that it applies.
   */
  differential?: StructureDefinitionDifferential | undefined;
  /**
   * Allows filtering of structure definitions that are appropriate for use versus not.
   */
  experimental?: boolean | undefined;
  _experimental?: Element | undefined;
  /**
   * A StructureDefinition does not need to specify the target it applies to as StructureDefinitions will often be valid across multiple versions of FHIR. FHIR tooling can determine whether a StructureDefinition is consistent with a particular StructureDefinition if desired.
   */
  fhirVersion?: string | undefined;
  _fhirVersion?: Element | undefined;
  /**
   * Typically, this is used for identifiers that can go in an HL7 V3 II (instance identifier) data type, and can then identify this structure definition outside of FHIR, where it is not possible to use the logical URI.
   */
  identifier?: Identifier[] | undefined;
  /**
   * It may be possible for the structure definition to be used in jurisdictions other than those for which it was originally designed or intended.
   * DEPRECATION NOTE: For consistency, implementations are encouraged to migrate to using the new 'jurisdiction' code in the useContext element.  (I.e. useContext.code indicating http://terminology.hl7.org/CodeSystem/usage-context-type#jurisdiction and useContext.valueCodeableConcept indicating the jurisdiction.)
   */
  jurisdiction?: CodeableConcept[] | undefined;
  /**
   * Note that this element is deprecated. Use the [http://hl7.org/fhir/StructureDefinition/artifact-topic](http://hl7.org/fhir/extensions/StructureDefinition-artifact-topic.html) extension instead.
   */
  keyword?: Coding[] | undefined;
  /**
   * Defines the kind of structure that this definition is describing.
   */
  kind: 'primitive-type' | 'complex-type' | 'resource' | 'logical';
  _kind?: Element | undefined;
  /**
   * An external specification that the content is mapped to.
   */
  mapping?: StructureDefinitionMapping[] | undefined;
  /**
   * The name is not expected to be globally unique. The name should be a simple alphanumeric type name to ensure that it is machine-processing friendly.Some Examples:
   * - O2SatObservation
   * - PresentationReport
   * - Immunization2
   * - AcmeAdmissionRecordOld.
   */
  name: string;
  _name?: Element | undefined;
  /**
   * Usually an organization but may be an individual. The publisher (or steward) of the structure definition is the organization or individual primarily responsible for the maintenance and upkeep of the structure definition. This is not necessarily the same individual or organization that developed and initially authored the content. The publisher is the primary point of contact for questions or issues with the structure definition. This item SHOULD be populated unless the information is available from context.
   */
  publisher?: string | undefined;
  _publisher?: Element | undefined;
  /**
   * This element does not describe the usage of the structure definition. Instead, it provides traceability of ''why'' the resource is either needed or ''why'' it is defined as it is.  This may be used to point to source materials or specifications that drove the structure of this structure definition.
   */
  purpose?: string | undefined;
  _purpose?: Element | undefined;
  /**
   * A snapshot view is expressed in a standalone form that can be used and interpreted without considering the base StructureDefinition.
   */
  snapshot?: StructureDefinitionSnapshot | undefined;
  /**
   * Allows filtering of structure definitions that are appropriate for use versus not.
   * See guidance around (not) making local changes to elements [here](canonicalresource.html#localization).
   */
  status: 'draft' | 'active' | 'retired' | 'unknown';
  _status?: Element | undefined;
  /**
   * This name does not need to be machine-processing friendly and may contain punctuation, white-space, etc.Applications don't have to use this name but can always fall back to it. The title also corresponds to the label for the root element.
   */
  title?: string | undefined;
  _title?: Element | undefined;
  /**
   * Note that in the case of constraints, the type could be determined by chasing through the baseDefinition references until a type defining structure (derivation = specialization) is reached, or by looking at the path of the first element in the snapshot - if present - but providing the type directly makes for simpler tooling and indexing.
   * The type must match the elements defined in the differential and the snapshot. For all FHIR defined types, the path name of the element will start with the type name. For logical models, where the type SHALL be a fully specified URL, the type name SHOULD start with the final path segment of the type URL where required. E.g. If the type was "http://example.org/fhir/MyLogicalModelType", the type name should start with 'MyLogicalModelType'.
   */
  type: string;
  _type?: Element | undefined;
  /**
   * Can be a urn:uuid: or a urn:oid: but real http: addresses are preferred.  Multiple instances may share the same URL if they have a distinct version.
   * The determination of when to create a new version of a resource (same url, new version) vs. defining a new artifact is up to the author.  Considerations for making this decision are found in [Technical and Business Versions](resource.html#versions).
   * In some cases, the resource can no longer be found at the stated url, but the url itself cannot change. Implementations can use the [meta.source](resource.html#meta) element to indicate where the current master source of the resource can be found.
   */
  url: string;
  _url?: Element | undefined;
  /**
   * When multiple useContexts are specified, there is no expectation that all or any of the contexts apply.
   */
  useContext?: UsageContext[] | undefined;
  /**
   * There may be different structure definition instances that have the same identifier but different versions.  The version can be appended to the url in a reference to allow a reference to a particular business version of the structure definition with the format [url]|[version]. The version SHOULD NOT contain a '#' - see [Business Version](resource.html#bv-format).
   */
  version?: string | undefined;
  _version?: Element | undefined;
  /**
   * If set as a string, this is a FHIRPath expression that has two additional context variables passed in - %version1 and %version2 and will return a negative number if version1 is newer, a positive number if version2 and a 0 if the version ordering can't be successfully be determined.
   */
  versionAlgorithmString?: string | undefined;
  _versionAlgorithmString?: Element | undefined;
  /**
   * If set as a string, this is a FHIRPath expression that has two additional context variables passed in - %version1 and %version2 and will return a negative number if version1 is newer, a positive number if version2 and a 0 if the version ordering can't be successfully be determined.
   */
  versionAlgorithmCoding?: Coding | undefined;
}

/**
 * Concepts have both a ```display``` and an array of ```designation```. The display is equivalent to a special designation with an implied ```designation.use``` of "primary code" and a language equal to the [Resource Language](resource.html#language).
 */
export interface ValueSetComposeIncludeConceptDesignation extends BackboneElement {
  /**
   * This was added rather than increasing the cardinality of .use to 0..* in order to maintain backward compatibility.
   */
  additionalUse?: Coding[] | undefined;
  /**
   * In the absence of a language, the resource language applies.
   */
  language?: string | undefined;
  _language?: Element | undefined;
  /**
   * If no use is provided, the designation can be assumed to be suitable for general display to a human user.
   */
  use?: Coding | undefined;
  /**
   * The text value for this designation.
   */
  value: string;
  _value?: Element | undefined;
}
/**
 * The list of concepts is considered ordered, though the order might not have any particular significance. Typically, the order of an expansion follows that defined in the compose element.
 */
export interface ValueSetComposeIncludeConcept extends BackboneElement {
  /**
   * Expressions are allowed if defined by the underlying code system.
   */
  code: string;
  _code?: Element | undefined;
  /**
   * Concepts have both a ```display``` and an array of ```designation```. The display is equivalent to a special designation with an implied ```designation.use``` of "primary code" and a language equal to the [Resource Language](resource.html#language).
   */
  designation?: ValueSetComposeIncludeConceptDesignation[] | undefined;
  /**
   * The value set resource allows for an alternative display to be specified for when this concept is used in this particular value set. See notes in the value set narrative about the correct use of this element.
   */
  display?: string | undefined;
  _display?: Element | undefined;
}
/**
 * Selecting codes by specifying filters based on properties is only possible where the underlying code system defines appropriate properties. Note that in some cases, the underlying code system defines the logical concepts but not the literal codes for the concepts. In such cases, the literal definitions may be provided by a third party.
 */
export interface ValueSetComposeIncludeFilter extends BackboneElement {
  /**
   * In case filter.property represents a property of the system, the operation applies to the selected property. In case filter.property represents a filter of the system, the operation SHALL match one of the CodeSystem.filter.operator values.
   */
  op:
    | '='
    | 'is-a'
    | 'descendent-of'
    | 'is-not-a'
    | 'regex'
    | 'in'
    | 'not-in'
    | 'generalizes'
    | 'child-of'
    | 'descendent-leaf'
    | 'exists';
  _op?: Element | undefined;
  /**
   * A code that identifies a property or a filter defined in the code system.
   */
  property: string;
  _property?: Element | undefined;
  /**
   * Use regex matching with care - full regex matching on every SNOMED CT term is prohibitive, for example.
   */
  value: string;
  _value?: Element | undefined;
}
/**
 * All the conditions in an include must be true. If a system is listed, all the codes from the system are listed. If one or more filters are listed, all of the filters must apply. If one or more value sets are listed, the codes must be in all the value sets. E.g. each include is 'include all the codes that meet all these conditions'.
 */
export interface ValueSetComposeInclude extends BackboneElement {
  /**
   * The list of concepts is considered ordered, though the order might not have any particular significance. Typically, the order of an expansion follows that defined in the compose element.
   */
  concept?: ValueSetComposeIncludeConcept[] | undefined;
  /**
   * A copyright statement for the specific code system asserted by the containing ValueSet.compose.include element's system value (if the associated ValueSet.compose.include.version element is not present); or the code system and version combination (if the associated ValueSet.compose.include.version element is present).
   */
  copyright?: string | undefined;
  _copyright?: Element | undefined;
  /**
   * Selecting codes by specifying filters based on properties is only possible where the underlying code system defines appropriate properties. Note that in some cases, the underlying code system defines the logical concepts but not the literal codes for the concepts. In such cases, the literal definitions may be provided by a third party.
   */
  filter?: ValueSetComposeIncludeFilter[] | undefined;
  /**
   * If there are no codes or filters, the entire code system is included. Note that the set of codes that are included may contain abstract codes. See ''Coding.system'' for further documentation about the correct value for the system element.
   */
  system?: string | undefined;
  _system?: Element | undefined;
  /**
   * The value set URI is either a logical reference to a defined value set such as a [SNOMED CT reference set](https://terminology.hl7.org/SNOMEDCT.html), or a direct reference to a value set definition using ValueSet.url. The reference might not refer to an actual FHIR ValueSet resource; in this case, whatever is referred to is an implicit definition of a value set that needs to be clear about how versions are resolved.
   */
  valueSet?: string[] | undefined;
  _valueSet?: Element[] | undefined;
  /**
   * This is used when selecting the descendants of a concept - they may change between versions. If no version is specified, then the exact contents of the value set might not be known until a context of use binds it to a particular version. The special value '*' means all versions; It is at server discretion regarding expansions and which versions must be supported.
   */
  version?: string | undefined;
  _version?: Element | undefined;
}
/**
 * A set of criteria that define the contents of the value set by including or excluding codes selected from the specified code system(s) that the value set draws from. This is also known as the Content Logical Definition (CLD).
 */
export interface ValueSetCompose extends BackboneElement {
  /**
   * Usually this is used to selectively exclude codes that were included by subsumption in the inclusions. Any display names specified for the codes are ignored.
   */
  exclude?: ValueSetComposeInclude[] | undefined;
  /**
   * Note that in the FHIR terminology framework, "deprecated" does not mean inactive, but in some code systems, e.g. LOINC, "deprecated" does mean inactive. Code systems should define what codes are considered to be inactive. If this is not clearly defined (including in the FHIR code system resource), then all codes are assumed to be active.
   * The Value Set Definition specification defines an ActiveOnly element, which is the reverse of this element e.g. (ValueSet.compose.inactive=FALSE) is the same as (VSD.ActiveOnly=TRUE).
   */
  inactive?: boolean | undefined;
  _inactive?: Element | undefined;
  /**
   * All the conditions in an include must be true. If a system is listed, all the codes from the system are listed. If one or more filters are listed, all of the filters must apply. If one or more value sets are listed, the codes must be in all the value sets. E.g. each include is 'include all the codes that meet all these conditions'.
   */
  include: ValueSetComposeInclude[];
  /**
   * With a defined lockedDate the value set is considered "Locked". Otherwise, the value set may have different expansions as underlying code systems and/or value sets evolve.  The interpretation of lockedDate is often dependent on the context - e.g. a SNOMED CT derived value set with a lockedDate will have a different expansion in USA than in UK.  If a value set specifies a version for include and exclude statements, and also specifies a locked date, the specified versions need to be available that date, or the value set will not be usable.
   */
  lockedDate?: string | undefined;
  _lockedDate?: Element | undefined;
  /**
   * Note that property names can clash, so using a URI is recommended.
   */
  property?: string[] | undefined;
  _property?: Element[] | undefined;
}
/**
 * The server decides which parameters to include here, but at a minimum, the list SHOULD include all of the parameters that affect the $expand operation. If the expansion will be persisted all of these parameters SHALL be included. If the codeSystem on the server has a specified version then this version SHALL be provided as a parameter in the expansion (note that not all code systems have a version).
 */
export interface ValueSetExpansionParameter extends BackboneElement {
  /**
   * The names are assigned at the discretion of the server.
   */
  name: string;
  _name?: Element | undefined;
  /**
   * The value of the parameter.
   */
  valueString?: string | undefined;
  _valueString?: Element | undefined;
  /**
   * The value of the parameter.
   */
  valueBoolean?: boolean | undefined;
  _valueBoolean?: Element | undefined;
  /**
   * The value of the parameter.
   */
  valueInteger?: number | undefined;
  /**
   * The value of the parameter.
   */
  valueDecimal?: number | undefined;
  /**
   * The value of the parameter.
   */
  valueUri?: string | undefined;
  _valueUri?: Element | undefined;
  /**
   * The value of the parameter.
   */
  valueCode?: string | undefined;
  _valueCode?: Element | undefined;
  /**
   * The value of the parameter.
   */
  valueDateTime?: string | undefined;
  _valueDateTime?: Element | undefined;
}
/**
 * A property defines an additional slot through which additional information can be provided about a concept.
 */
export interface ValueSetExpansionProperty extends BackboneElement {
  /**
   * A code that is used to identify the property. The code is used in ValueSet.expansion.contains.property.code.
   */
  code: string;
  _code?: Element | undefined;
  /**
   * Reference to the formal meaning of the property. One possible source of meaning is the [Concept Properties](codesystem-concept-properties.html) code system.
   */
  uri?: string | undefined;
  _uri?: Element | undefined;
}
/**
 * A subproperty value for this concept.
 */
export interface ValueSetExpansionContainsPropertySubProperty extends BackboneElement {
  /**
   * A code that is a reference to ValueSet.expansion.property.code.
   */
  code: string;
  _code?: Element | undefined;
  /**
   * The value of this subproperty.
   */
  valueCode?: string | undefined;
  _valueCode?: Element | undefined;
  /**
   * The value of this subproperty.
   */
  valueCoding?: Coding | undefined;
  /**
   * The value of this subproperty.
   */
  valueString?: string | undefined;
  _valueString?: Element | undefined;
  /**
   * The value of this subproperty.
   */
  valueInteger?: number | undefined;
  /**
   * The value of this subproperty.
   */
  valueBoolean?: boolean | undefined;
  _valueBoolean?: Element | undefined;
  /**
   * The value of this subproperty.
   */
  valueDateTime?: string | undefined;
  _valueDateTime?: Element | undefined;
  /**
   * The value of this subproperty.
   */
  valueDecimal?: number | undefined;
}
/**
 * A property value for this concept.
 */
export interface ValueSetExpansionContainsProperty extends BackboneElement {
  /**
   * A code that is a reference to ValueSet.expansion.property.code.
   */
  code: string;
  _code?: Element | undefined;
  /**
   * A subproperty value for this concept.
   */
  subProperty?: ValueSetExpansionContainsPropertySubProperty[] | undefined;
  /**
   * The value of this property.
   */
  valueCode?: string | undefined;
  _valueCode?: Element | undefined;
  /**
   * The value of this property.
   */
  valueCoding?: Coding | undefined;
  /**
   * The value of this property.
   */
  valueString?: string | undefined;
  _valueString?: Element | undefined;
  /**
   * The value of this property.
   */
  valueInteger?: number | undefined;
  /**
   * The value of this property.
   */
  valueBoolean?: boolean | undefined;
  _valueBoolean?: Element | undefined;
  /**
   * The value of this property.
   */
  valueDateTime?: string | undefined;
  _valueDateTime?: Element | undefined;
  /**
   * The value of this property.
   */
  valueDecimal?: number | undefined;
}
/**
 * The codes that are contained in the value set expansion.
 */
export interface ValueSetExpansionContains extends BackboneElement {
  /**
   * This should not be understood to exclude its use for searching (e.g. by subsumption testing). The client should know whether it is appropriate for the user to select an abstract code or not.
   */
  abstract?: boolean | undefined;
  _abstract?: Element | undefined;
  /**
   * The code for this item in the expansion hierarchy. If this code is missing the entry in the hierarchy is a place holder (abstract) and does not represent a valid code in the value set.
   */
  code?: string | undefined;
  _code?: Element | undefined;
  /**
   * If the expansion uses this element, there is  no implication about the logical relationship between them, and the  structure cannot be used for logical inferencing. The structure  exists to provide navigational assistance for helping human users to  locate codes in the expansion.
   */
  contains?: ValueSetExpansionContains[] | undefined;
  /**
   * The designations provided must be based on the value set and code system definitions.
   */
  designation?: ValueSetComposeIncludeConceptDesignation[] | undefined;
  /**
   * The recommended display for this item in the expansion.
   */
  display?: string | undefined;
  _display?: Element | undefined;
  /**
   * This should only have a value if the concept is inactive.
   */
  inactive?: boolean | undefined;
  _inactive?: Element | undefined;
  /**
   * A property value for this concept.
   */
  property?: ValueSetExpansionContainsProperty[] | undefined;
  /**
   * An absolute URI which is the code system in which the code for this item in the expansion is defined.
   */
  system?: string | undefined;
  _system?: Element | undefined;
  /**
   * The exact value of the version string is specified by the system from which the code is derived.
   */
  version?: string | undefined;
  _version?: Element | undefined;
}
/**
 * Expansion is performed to produce a collection of codes that are ready to use for data entry or validation. Value set expansions are always considered to be stateless - they are a record of the set of codes in the value set at a point in time under a given set of conditions, and are not subject to ongoing maintenance.
 * Expansion.parameter is  a simplified list of parameters - a subset of the features of the [Parameters](parameters.html) resource.
 */
export interface ValueSetExpansion extends BackboneElement {
  /**
   * The codes that are contained in the value set expansion.
   */
  contains?: ValueSetExpansionContains[] | undefined;
  /**
   * Typically, this uri is a UUID (e.g. urn:uuid:8230ff20-c97a-4167-a59d-dc2cb9df16dd).
   */
  identifier?: string | undefined;
  _identifier?: Element | undefined;
  /**
   * Clients SHOULD use the next link, if present, to page through expansion results in preference to using the offset and count parameters. Due to the optional nature of the next link, its absence does not necessarily indicate that it is the last page of results. Instead, as the offset and count parameters SHALL be populated when paging, clients can reliably use the count/offset parameters to determine whether the whole expansion is returned.
   */
  next?: string | undefined;
  _next?: Element | undefined;
  /**
   * Paging only applies to flat expansions. If a filter is applied, the count is the number of concepts that matched the filter, not the number of concepts in an unfiltered view of the expansion.
   */
  offset?: number | undefined;
  /**
   * The server decides which parameters to include here, but at a minimum, the list SHOULD include all of the parameters that affect the $expand operation. If the expansion will be persisted all of these parameters SHALL be included. If the codeSystem on the server has a specified version then this version SHALL be provided as a parameter in the expansion (note that not all code systems have a version).
   */
  parameter?: ValueSetExpansionParameter[] | undefined;
  /**
   * A property defines an additional slot through which additional information can be provided about a concept.
   */
  property?: ValueSetExpansionProperty[] | undefined;
  /**
   * This SHOULD be a fully populated instant, but in some circumstances, value sets are expanded by hand, and the expansion is published without that precision.
   */
  timestamp: string;
  _timestamp?: Element | undefined;
  /**
   * Paging only applies to flat expansions.
   */
  total?: number | undefined;
}
/**
 * Description of the semantic space the Value Set Expansion is intended to cover and should further clarify the text in ValueSet.description.
 */
export interface ValueSetScope extends BackboneElement {
  /**
   * Criteria describing which concepts or codes should be excluded and why.
   */
  exclusionCriteria?: string | undefined;
  _exclusionCriteria?: Element | undefined;
  /**
   * Criteria describing which concepts or codes should be included and why.
   */
  inclusionCriteria?: string | undefined;
  _inclusionCriteria?: Element | undefined;
}
/**
 * A ValueSet resource instance specifies a set of codes drawn from one or more code systems, intended for use in a particular context. Value sets link between [CodeSystem](codesystem.html) definitions and their use in [coded elements](terminologies.html).
 */
export interface ValueSet extends DomainResource {
  /** Resource Type Name (for serialization) */
  readonly resourceType: 'ValueSet';
  /**
   * The 'date' element may be more recent than the approval date because of minor changes or editorial corrections.
   * See guidance around (not) making local changes to elements [here](canonicalresource.html#localization).
   */
  approvalDate?: string | undefined;
  _approvalDate?: Element | undefined;
  /**
   * An individiual or organization primarily involved in the creation and maintenance of the ValueSet.
   */
  author?: ContactDetail[] | undefined;
  /**
   * A set of criteria that define the contents of the value set by including or excluding codes selected from the specified code system(s) that the value set draws from. This is also known as the Content Logical Definition (CLD).
   */
  compose?: ValueSetCompose | undefined;
  /**
   * May be a web site, an email address, a telephone number, etc.
   * See guidance around (not) making local changes to elements [here](canonicalresource.html#localization).
   */
  contact?: ContactDetail[] | undefined;
  /**
   * Frequently, the copyright differs between the value set and the codes that are included. The copyright statement should clearly differentiate between these when required.
   */
  copyright?: string | undefined;
  _copyright?: Element | undefined;
  /**
   * The (c) symbol should NOT be included in this string. It will be added by software when rendering the notation. Full details about licensing, restrictions, warrantees, etc. goes in the more general 'copyright' element.
   */
  copyrightLabel?: string | undefined;
  _copyrightLabel?: Element | undefined;
  /**
   * Note that this is not the same as the meta.lastUpdated which is specific to an instance of a value set resource on a server.  Additional specific dates may be added as extensions or be found by consulting Provenances associated with past versions of the resource.
   * See guidance around (not) making local changes to elements [here](canonicalresource.html#localization).
   */
  date?: string | undefined;
  _date?: Element | undefined;
  /**
   * Description SHOULD contain instructions for clinical or administrative use and interpretation and information about misuse. Description SHOULD be populated unless the information is available from context. Description SHOULD be populated unless the value set is a contained resource (e.g. a value set defined solely in the context of a profile).
   */
  description?: string | undefined;
  _description?: Element | undefined;
  /**
   * An individual or organization primarily responsible for internal coherence of the ValueSet.
   */
  editor?: ContactDetail[] | undefined;
  /**
   * The effective period for a ValueSet determines when the content is applicable for usage and is independent of publication and review dates. For example, a valueset intended to be used for the year 2016 might be published in 2015.
   * See guidance around (not) making local changes to elements [here](canonicalresource.html#localization).
   */
  effectivePeriod?: Period | undefined;
  /**
   * See guidance around (not) making local changes to elements [here](canonicalresource.html#localization).
   */
  endorser?: ContactDetail[] | undefined;
  /**
   * Expansion is performed to produce a collection of codes that are ready to use for data entry or validation. Value set expansions are always considered to be stateless - they are a record of the set of codes in the value set at a point in time under a given set of conditions, and are not subject to ongoing maintenance.
   * Expansion.parameter is  a simplified list of parameters - a subset of the features of the [Parameters](parameters.html) resource.
   */
  expansion?: ValueSetExpansion | undefined;
  /**
   * Allows filtering of value sets that are appropriate for use versus not.
   */
  experimental?: boolean | undefined;
  _experimental?: Element | undefined;
  /**
   * Typically, this is used for identifiers that can go in an HL7 V3 II (instance identifier) data type, and can then identify this value set outside of FHIR, where it is not possible to use the logical URI.
   */
  identifier?: Identifier[] | undefined;
  /**
   * Normally immutability is set to 'false', which is the default assumption if it is not populated.  Note that the implication is that if this is set to 'true', there may be only one ValueSet version for this definition. Immutability tends to be set to 'true' in one of two cases: - Where the value set, by the nature of its usage, cannot change.  For example "All specializations of ACT in ActClassCode" - Where there's no safe way to express the "Purpose" such that someone else could safely make changes to the value set definition. Source workflow control must guarantee that the same URI always yields the same definition.
   */
  immutable?: boolean | undefined;
  _immutable?: Element | undefined;
  /**
   * It may be possible for the value set to be used in jurisdictions other than those for which it was originally designed or intended.
   * DEPRECATION NOTE: For consistency, implementations are encouraged to migrate to using the new 'jurisdiction' code in the useContext element.  (I.e. useContext.code indicating http://terminology.hl7.org/CodeSystem/usage-context-type#jurisdiction and useContext.valueCodeableConcept indicating the jurisdiction.)
   */
  jurisdiction?: CodeableConcept[] | undefined;
  /**
   * If specified, this date follows the original approval date.
   * See guidance around (not) making local changes to elements [here](canonicalresource.html#localization).
   */
  lastReviewDate?: string | undefined;
  _lastReviewDate?: Element | undefined;
  /**
   * The name is not expected to be globally unique. The name should be a simple alphanumeric type name to ensure that it is machine-processing friendly.A name should be provided unless the value set is a contained resource (e.g. an anonymous value set in a profile). Most registries will require a name.
   */
  name?: string | undefined;
  _name?: Element | undefined;
  /**
   * Usually an organization but may be an individual. This is not necessarily the same individual or organization that developed and initially authored the content. The publisher is the primary point of contact for questions or issues with the value set. This item SHOULD be populated unless the information is available from context.
   */
  publisher?: string | undefined;
  _publisher?: Element | undefined;
  /**
   * This element does not describe the usage of the value set. Instead, it provides traceability of ''why'' the resource is either needed or ''why'' it is defined as it is.  This may be used to point to source materials or specifications that drove the structure of this value set.
   */
  purpose?: string | undefined;
  _purpose?: Element | undefined;
  /**
   * Each related artifact is either an attachment, or a reference to another resource, but not both.
   */
  relatedArtifact?: RelatedArtifact[] | undefined;
  /**
   * See guidance around (not) making local changes to elements [here](canonicalresource.html#localization).
   */
  reviewer?: ContactDetail[] | undefined;
  /**
   * Description of the semantic space the Value Set Expansion is intended to cover and should further clarify the text in ValueSet.description.
   */
  scope?: ValueSetScope | undefined;
  /**
   * Allows filtering of value sets that are appropriate for use versus not.See also the [http://hl7.org/fhir/StructureDefinition/valueset-workflowStatusDescription](http://hl7.org/fhir/extensions/StructureDefinition-valueset-workflowStatusDescription.html) extension for additional status information related to the editorial process.
   * See guidance around (not) making local changes to elements [here](canonicalresource.html#localization).
   */
  status: 'draft' | 'active' | 'retired' | 'unknown';
  _status?: Element | undefined;
  /**
   * This name does not need to be machine-processing friendly and may contain punctuation, white-space, etc.
   */
  title?: string | undefined;
  _title?: Element | undefined;
  /**
   * DEPRECATION NOTE: For consistency, implementations are encouraged to migrate to using the new 'topic' code in the useContext element.  (I.e. useContext.code indicating http://terminology.hl7.org/CodeSystem/usage-context-type#topic and useContext.valueCodeableConcept indicating the topic)
   */
  topic?: CodeableConcept[] | undefined;
  /**
   * Can be a urn:uuid: or a urn:oid: but real http: addresses are preferred.  Multiple instances may share the same URL if they have a distinct version.
   * The determination of when to create a new version of a resource (same url, new version) vs. defining a new artifact is up to the author.  Considerations for making this decision are found in [Technical and Business Versions](resource.html#versions).
   * In some cases, the resource can no longer be found at the stated url, but the url itself cannot change. Implementations can use the [meta.source](resource.html#meta) element to indicate where the current master source of the resource can be found.
   */
  url?: string | undefined;
  _url?: Element | undefined;
  /**
   * When multiple useContexts are specified, there is no expectation that all or any of the contexts apply.
   */
  useContext?: UsageContext[] | undefined;
  /**
   * There may be different value set instances that have the same identifier but different versions.  The version can be appended to the url in a reference to allow a reference to a particular business version of the value set with the format [url]|[version]. The version SHOULD NOT contain a '#' - see [Business Version](resource.html#bv-format).
   */
  version?: string | undefined;
  _version?: Element | undefined;
  /**
   * If set as a string, this is a FHIRPath expression that has two additional context variables passed in - %version1 and %version2 and will return a negative number if version1 is newer, a positive number if version2 and a 0 if the version ordering can't be successfully be determined.
   */
  versionAlgorithmString?: string | undefined;
  _versionAlgorithmString?: Element | undefined;
  /**
   * If set as a string, this is a FHIRPath expression that has two additional context variables passed in - %version1 and %version2 and will return a negative number if version1 is newer, a positive number if version2 and a 0 if the version ordering can't be successfully be determined.
   */
  versionAlgorithmCoding?: Coding | undefined;
}

/**
 * Resource binding for generic use.
 */
export type FhirResource = CodeSystem | StructureDefinition | ValueSet;

/* eslint-enable @typescript-eslint/no-empty-object-type */
