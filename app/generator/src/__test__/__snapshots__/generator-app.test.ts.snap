// Jest Snapshot v1, https://jestjs.io/docs/snapshot-testing

exports[`src/generator-app unit test suite generator-app generate and write should generate and write all FHIR R4 artifacts from utest-cache FHIR cache 1`] = `
"/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated by the FHIR Data Model Generator.
 * DO NOT make any modifications!
 * 
 * index.ts Module
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @module Library Index
 */

export {
  Base,
  Element,
  BackboneElement,
  DataType,
  BackboneType,
  PrimitiveType,
  Resource,
  DomainResource,
  DateTimeUtil,
  Base64BinaryType,
  BooleanType,
  CanonicalType,
  CodeType,
  EnumCodeType,
  DateTimeType,
  DateType,
  DecimalType,
  FhirCodeDefinition,
  FhirError,
  IdType,
  InstantType,
  Integer64Type,
  IntegerType,
  InvalidCodeError,
  InvalidDateTimeError,
  InvalidTypeError,
  JsonError,
  MarkdownType,
  OidType,
  PositiveIntType,
  PrimitiveTypeError,
  StringType,
  TimeType,
  UnsignedIntType,
  UriType,
  UrlType,
  UuidType,
  XhtmlType,
} from '@paq-ts-fhir/fhir-core';
export type {
  IBase,
  IElement,
  IExtension,
  IBackboneElement,
  IDataType,
  IBackboneType,
  IPrimitiveType,
  IResource,
  IDomainResource,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  DateTypeImpl,
  DateTimeTypeImpl,
  InstantTypeImpl,
  fhirBase64Binary,
  fhirBoolean,
  fhirCanonical,
  fhirCode,
  fhirDateTime,
  fhirDate,
  fhirDecimal,
  fhirId,
  fhirInstant,
  fhirInteger64,
  fhirInteger,
  fhirMarkdown,
  fhirOid,
  fhirPositiveInt,
  fhirString,
  fhirTime,
  fhirUnsignedInt,
  fhirUri,
  fhirUrl,
  fhirUuid,
  fhirXhtml,
} from '@paq-ts-fhir/fhir-core';

export * from './code-systems/BundleTypeEnum';
export * from './code-systems/ContactPointSystemEnum';
export * from './code-systems/ContactPointUseEnum';
export * from './code-systems/DaysOfWeekEnum';
export * from './code-systems/HttpVerbEnum';
export * from './code-systems/IdentifierUseEnum';
export * from './code-systems/NarrativeStatusEnum';
export * from './code-systems/PublicationStatusEnum';
export * from './code-systems/ResourceTypesEnum';
export * from './code-systems/SearchComparatorEnum';
export * from './code-systems/SearchEntryModeEnum';
export * from './code-systems/SearchModifierCodeEnum';
export * from './code-systems/SearchParamTypeEnum';
export * from './complex-types/complex-datatypes';
export * from './resources/Bundle';
export * from './resources/PractitionerRole';
export * from './resources/SearchParameter';
export * from './resources/parsable-resource-map';
"
`;

exports[`src/generator-app unit test suite generator-app verify generated content should consistently create GeneratedContent[] 1`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator/src/__test__/test-out",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator/src/__test__/utest-cache",
    "pkgName": "utest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * ContactPointSystemEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/contact-point-system
 * CodeSystem.name: ContactPointSystem
 * CodeSystem.description: Telecommunications form for contact point.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: ContactPointSystemEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem ContactPointSystem](http://hl7.org/fhir/contact-point-system)
 */
export class ContactPointSystemEnum implements IFhirCodeEnum {
  public static readonly PHONE = new FhirCodeDefinition(
    'PHONE',
    'phone',
    'http://hl7.org/fhir/contact-point-system',
    'Phone',
    'The value is a telephone number used for voice calls. Use of full international numbers starting with + is recommended to enable automatic dialing support but not required.',
  );
  public static readonly FAX = new FhirCodeDefinition(
    'FAX',
    'fax',
    'http://hl7.org/fhir/contact-point-system',
    'Fax',
    'The value is a fax machine. Use of full international numbers starting with + is recommended to enable automatic dialing support but not required.',
  );
  public static readonly EMAIL = new FhirCodeDefinition(
    'EMAIL',
    'email',
    'http://hl7.org/fhir/contact-point-system',
    'Email',
    'The value is an email address.',
  );
  public static readonly PAGER = new FhirCodeDefinition(
    'PAGER',
    'pager',
    'http://hl7.org/fhir/contact-point-system',
    'Pager',
    'The value is a pager number. These may be local pager numbers that are only usable on a particular pager system.',
  );
  public static readonly URL = new FhirCodeDefinition(
    'URL',
    'url',
    'http://hl7.org/fhir/contact-point-system',
    'URL',
    'A contact that is not a phone, fax, pager or email address and is expressed as a URL.  This is intended for various institutional or personal contacts including web sites, blogs, Skype, Twitter, Facebook, etc. Do not use for email addresses.',
  );
  public static readonly SMS = new FhirCodeDefinition(
    'SMS',
    'sms',
    'http://hl7.org/fhir/contact-point-system',
    'SMS',
    'A contact that can be used for sending an sms message (e.g. mobile phones, some landlines).',
  );
  public static readonly OTHER = new FhirCodeDefinition(
    'OTHER',
    'other',
    'http://hl7.org/fhir/contact-point-system',
    'Other',
    'A contact that is not a phone, fax, page or email address and is not expressible as a URL.  E.g. Internal mail address.  This SHOULD NOT be used for contacts that are expressible as a URL (e.g. Skype, Twitter, Facebook, etc.)  Extensions may be used to distinguish "other" contact types.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      ContactPointSystemEnum.PHONE,
      ContactPointSystemEnum.FAX,
      ContactPointSystemEnum.EMAIL,
      ContactPointSystemEnum.PAGER,
      ContactPointSystemEnum.URL,
      ContactPointSystemEnum.SMS,
      ContactPointSystemEnum.OTHER,
      ContactPointSystemEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {@link InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (ContactPointSystemEnum.PHONE.code === code) {
      return ContactPointSystemEnum.PHONE;
    } else if (ContactPointSystemEnum.FAX.code === code) {
      return ContactPointSystemEnum.FAX;
    } else if (ContactPointSystemEnum.EMAIL.code === code) {
      return ContactPointSystemEnum.EMAIL;
    } else if (ContactPointSystemEnum.PAGER.code === code) {
      return ContactPointSystemEnum.PAGER;
    } else if (ContactPointSystemEnum.URL.code === code) {
      return ContactPointSystemEnum.URL;
    } else if (ContactPointSystemEnum.SMS.code === code) {
      return ContactPointSystemEnum.SMS;
    } else if (ContactPointSystemEnum.OTHER.code === code) {
      return ContactPointSystemEnum.OTHER;
    } else if (ContactPointSystemEnum.NULL.code === code) {
      return ContactPointSystemEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown ContactPointSystemEnum 'code' value '\${code}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "ContactPointSystemEnum",
}
`;

exports[`src/generator-app unit test suite generator-app verify generated content should consistently create GeneratedContent[] 2`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator/src/__test__/test-out",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator/src/__test__/utest-cache",
    "pkgName": "utest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * ContactPointUseEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/contact-point-use
 * CodeSystem.name: ContactPointUse
 * CodeSystem.description: Use of contact point.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: ContactPointUseEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem ContactPointUse](http://hl7.org/fhir/contact-point-use)
 */
export class ContactPointUseEnum implements IFhirCodeEnum {
  public static readonly HOME = new FhirCodeDefinition(
    'HOME',
    'home',
    'http://hl7.org/fhir/contact-point-use',
    'Home',
    'A communication contact point at a home; attempted contacts for business purposes might intrude privacy and chances are one will contact family or other household members instead of the person one wishes to call. Typically used with urgent cases, or if no other contacts are available.',
  );
  public static readonly WORK = new FhirCodeDefinition(
    'WORK',
    'work',
    'http://hl7.org/fhir/contact-point-use',
    'Work',
    'An office contact point. First choice for business related contacts during business hours.',
  );
  public static readonly TEMP = new FhirCodeDefinition(
    'TEMP',
    'temp',
    'http://hl7.org/fhir/contact-point-use',
    'Temp',
    'A temporary contact point. The period can provide more detailed information.',
  );
  public static readonly OLD = new FhirCodeDefinition(
    'OLD',
    'old',
    'http://hl7.org/fhir/contact-point-use',
    'Old',
    'This contact point is no longer in use (or was never correct, but retained for records).',
  );
  public static readonly MOBILE = new FhirCodeDefinition(
    'MOBILE',
    'mobile',
    'http://hl7.org/fhir/contact-point-use',
    'Mobile',
    'A telecommunication device that moves and stays with its owner. May have characteristics of all other use codes, suitable for urgent matters, not the first choice for routine business.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      ContactPointUseEnum.HOME,
      ContactPointUseEnum.WORK,
      ContactPointUseEnum.TEMP,
      ContactPointUseEnum.OLD,
      ContactPointUseEnum.MOBILE,
      ContactPointUseEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {@link InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (ContactPointUseEnum.HOME.code === code) {
      return ContactPointUseEnum.HOME;
    } else if (ContactPointUseEnum.WORK.code === code) {
      return ContactPointUseEnum.WORK;
    } else if (ContactPointUseEnum.TEMP.code === code) {
      return ContactPointUseEnum.TEMP;
    } else if (ContactPointUseEnum.OLD.code === code) {
      return ContactPointUseEnum.OLD;
    } else if (ContactPointUseEnum.MOBILE.code === code) {
      return ContactPointUseEnum.MOBILE;
    } else if (ContactPointUseEnum.NULL.code === code) {
      return ContactPointUseEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown ContactPointUseEnum 'code' value '\${code}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "ContactPointUseEnum",
}
`;

exports[`src/generator-app unit test suite generator-app verify generated content should consistently create GeneratedContent[] 3`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator/src/__test__/test-out",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator/src/__test__/utest-cache",
    "pkgName": "utest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * IdentifierUseEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/identifier-use
 * CodeSystem.name: IdentifierUse
 * CodeSystem.description: Identifies the purpose for this identifier, if known .
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: IdentifierUseEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem IdentifierUse](http://hl7.org/fhir/identifier-use)
 */
export class IdentifierUseEnum implements IFhirCodeEnum {
  public static readonly USUAL = new FhirCodeDefinition(
    'USUAL',
    'usual',
    'http://hl7.org/fhir/identifier-use',
    'Usual',
    'The identifier recommended for display and use in real-world interactions.',
  );
  public static readonly OFFICIAL = new FhirCodeDefinition(
    'OFFICIAL',
    'official',
    'http://hl7.org/fhir/identifier-use',
    'Official',
    'The identifier considered to be most trusted for the identification of this item. Sometimes also known as "primary" and "main". The determination of "official" is subjective and implementation guides often provide additional guidelines for use.',
  );
  public static readonly TEMP = new FhirCodeDefinition(
    'TEMP',
    'temp',
    'http://hl7.org/fhir/identifier-use',
    'Temp',
    'A temporary identifier.',
  );
  public static readonly SECONDARY = new FhirCodeDefinition(
    'SECONDARY',
    'secondary',
    'http://hl7.org/fhir/identifier-use',
    'Secondary',
    'An identifier that was assigned in secondary use - it serves to identify the object in a relative context, but cannot be consistently assigned to the same object again in a different context.',
  );
  public static readonly OLD = new FhirCodeDefinition(
    'OLD',
    'old',
    'http://hl7.org/fhir/identifier-use',
    'Old',
    'The identifier id no longer considered valid, but may be relevant for search purposes.  E.g. Changes to identifier schemes, account merges, etc.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      IdentifierUseEnum.USUAL,
      IdentifierUseEnum.OFFICIAL,
      IdentifierUseEnum.TEMP,
      IdentifierUseEnum.SECONDARY,
      IdentifierUseEnum.OLD,
      IdentifierUseEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {@link InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (IdentifierUseEnum.USUAL.code === code) {
      return IdentifierUseEnum.USUAL;
    } else if (IdentifierUseEnum.OFFICIAL.code === code) {
      return IdentifierUseEnum.OFFICIAL;
    } else if (IdentifierUseEnum.TEMP.code === code) {
      return IdentifierUseEnum.TEMP;
    } else if (IdentifierUseEnum.SECONDARY.code === code) {
      return IdentifierUseEnum.SECONDARY;
    } else if (IdentifierUseEnum.OLD.code === code) {
      return IdentifierUseEnum.OLD;
    } else if (IdentifierUseEnum.NULL.code === code) {
      return IdentifierUseEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown IdentifierUseEnum 'code' value '\${code}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "IdentifierUseEnum",
}
`;

exports[`src/generator-app unit test suite generator-app verify generated content should consistently create GeneratedContent[] 4`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator/src/__test__/test-out",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator/src/__test__/utest-cache",
    "pkgName": "utest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * NarrativeStatusEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/narrative-status
 * CodeSystem.name: NarrativeStatus
 * CodeSystem.description: The status of a resource narrative.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: NarrativeStatusEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem NarrativeStatus](http://hl7.org/fhir/narrative-status)
 */
export class NarrativeStatusEnum implements IFhirCodeEnum {
  public static readonly GENERATED = new FhirCodeDefinition(
    'GENERATED',
    'generated',
    'http://hl7.org/fhir/narrative-status',
    'Generated',
    'The contents of the narrative are entirely generated from the core elements in the content.',
  );
  public static readonly EXTENSIONS = new FhirCodeDefinition(
    'EXTENSIONS',
    'extensions',
    'http://hl7.org/fhir/narrative-status',
    'Extensions',
    'The contents of the narrative are entirely generated from the core elements in the content and some of the content is generated from extensions. The narrative SHALL reflect the impact of all modifier extensions.',
  );
  public static readonly ADDITIONAL = new FhirCodeDefinition(
    'ADDITIONAL',
    'additional',
    'http://hl7.org/fhir/narrative-status',
    'Additional',
    'The contents of the narrative may contain additional information not found in the structured data. Note that there is no computable way to determine what the extra information is, other than by human inspection.',
  );
  public static readonly EMPTY = new FhirCodeDefinition(
    'EMPTY',
    'empty',
    'http://hl7.org/fhir/narrative-status',
    'Empty',
    'The contents of the narrative are some equivalent of "No human-readable text provided in this case".',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      NarrativeStatusEnum.GENERATED,
      NarrativeStatusEnum.EXTENSIONS,
      NarrativeStatusEnum.ADDITIONAL,
      NarrativeStatusEnum.EMPTY,
      NarrativeStatusEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {@link InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (NarrativeStatusEnum.GENERATED.code === code) {
      return NarrativeStatusEnum.GENERATED;
    } else if (NarrativeStatusEnum.EXTENSIONS.code === code) {
      return NarrativeStatusEnum.EXTENSIONS;
    } else if (NarrativeStatusEnum.ADDITIONAL.code === code) {
      return NarrativeStatusEnum.ADDITIONAL;
    } else if (NarrativeStatusEnum.EMPTY.code === code) {
      return NarrativeStatusEnum.EMPTY;
    } else if (NarrativeStatusEnum.NULL.code === code) {
      return NarrativeStatusEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown NarrativeStatusEnum 'code' value '\${code}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "NarrativeStatusEnum",
}
`;

exports[`src/generator-app unit test suite generator-app verify generated content should consistently create GeneratedContent[] 5`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator/src/__test__/test-out",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator/src/__test__/utest-cache",
    "pkgName": "utest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * DaysOfWeekEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/days-of-week
 * CodeSystem.name: DaysOfWeek
 * CodeSystem.description: The days of the week.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: DaysOfWeekEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem DaysOfWeek](http://hl7.org/fhir/days-of-week)
 */
export class DaysOfWeekEnum implements IFhirCodeEnum {
  public static readonly MON = new FhirCodeDefinition(
    'MON',
    'mon',
    'http://hl7.org/fhir/days-of-week',
    'Monday',
    'Monday.',
  );
  public static readonly TUE = new FhirCodeDefinition(
    'TUE',
    'tue',
    'http://hl7.org/fhir/days-of-week',
    'Tuesday',
    'Tuesday.',
  );
  public static readonly WED = new FhirCodeDefinition(
    'WED',
    'wed',
    'http://hl7.org/fhir/days-of-week',
    'Wednesday',
    'Wednesday.',
  );
  public static readonly THU = new FhirCodeDefinition(
    'THU',
    'thu',
    'http://hl7.org/fhir/days-of-week',
    'Thursday',
    'Thursday.',
  );
  public static readonly FRI = new FhirCodeDefinition(
    'FRI',
    'fri',
    'http://hl7.org/fhir/days-of-week',
    'Friday',
    'Friday.',
  );
  public static readonly SAT = new FhirCodeDefinition(
    'SAT',
    'sat',
    'http://hl7.org/fhir/days-of-week',
    'Saturday',
    'Saturday.',
  );
  public static readonly SUN = new FhirCodeDefinition(
    'SUN',
    'sun',
    'http://hl7.org/fhir/days-of-week',
    'Sunday',
    'Sunday.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      DaysOfWeekEnum.MON,
      DaysOfWeekEnum.TUE,
      DaysOfWeekEnum.WED,
      DaysOfWeekEnum.THU,
      DaysOfWeekEnum.FRI,
      DaysOfWeekEnum.SAT,
      DaysOfWeekEnum.SUN,
      DaysOfWeekEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {@link InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (DaysOfWeekEnum.MON.code === code) {
      return DaysOfWeekEnum.MON;
    } else if (DaysOfWeekEnum.TUE.code === code) {
      return DaysOfWeekEnum.TUE;
    } else if (DaysOfWeekEnum.WED.code === code) {
      return DaysOfWeekEnum.WED;
    } else if (DaysOfWeekEnum.THU.code === code) {
      return DaysOfWeekEnum.THU;
    } else if (DaysOfWeekEnum.FRI.code === code) {
      return DaysOfWeekEnum.FRI;
    } else if (DaysOfWeekEnum.SAT.code === code) {
      return DaysOfWeekEnum.SAT;
    } else if (DaysOfWeekEnum.SUN.code === code) {
      return DaysOfWeekEnum.SUN;
    } else if (DaysOfWeekEnum.NULL.code === code) {
      return DaysOfWeekEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown DaysOfWeekEnum 'code' value '\${code}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "DaysOfWeekEnum",
}
`;

exports[`src/generator-app unit test suite generator-app verify generated content should consistently create GeneratedContent[] 6`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator/src/__test__/test-out",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator/src/__test__/utest-cache",
    "pkgName": "utest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * BundleTypeEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/bundle-type
 * CodeSystem.name: BundleType
 * CodeSystem.description: Indicates the purpose of a bundle - how it is intended to be used.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: BundleTypeEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem BundleType](http://hl7.org/fhir/bundle-type)
 */
export class BundleTypeEnum implements IFhirCodeEnum {
  public static readonly DOCUMENT = new FhirCodeDefinition(
    'DOCUMENT',
    'document',
    'http://hl7.org/fhir/bundle-type',
    'Document',
    'The bundle is a document. The first resource is a Composition.',
  );
  public static readonly MESSAGE = new FhirCodeDefinition(
    'MESSAGE',
    'message',
    'http://hl7.org/fhir/bundle-type',
    'Message',
    'The bundle is a message. The first resource is a MessageHeader.',
  );
  public static readonly TRANSACTION = new FhirCodeDefinition(
    'TRANSACTION',
    'transaction',
    'http://hl7.org/fhir/bundle-type',
    'Transaction',
    'The bundle is a transaction - intended to be processed by a server as an atomic commit.',
  );
  public static readonly TRANSACTION_RESPONSE = new FhirCodeDefinition(
    'TRANSACTION_RESPONSE',
    'transaction-response',
    'http://hl7.org/fhir/bundle-type',
    'Transaction Response',
    'The bundle is a transaction response. Because the response is a transaction response, the transaction has succeeded, and all responses are error free.',
  );
  public static readonly BATCH = new FhirCodeDefinition(
    'BATCH',
    'batch',
    'http://hl7.org/fhir/bundle-type',
    'Batch',
    'The bundle is a set of actions - intended to be processed by a server as a group of independent actions.',
  );
  public static readonly BATCH_RESPONSE = new FhirCodeDefinition(
    'BATCH_RESPONSE',
    'batch-response',
    'http://hl7.org/fhir/bundle-type',
    'Batch Response',
    'The bundle is a batch response. Note that as a batch, some responses may indicate failure and others success.',
  );
  public static readonly HISTORY = new FhirCodeDefinition(
    'HISTORY',
    'history',
    'http://hl7.org/fhir/bundle-type',
    'History List',
    'The bundle is a list of resources from a history interaction on a server.',
  );
  public static readonly SEARCHSET = new FhirCodeDefinition(
    'SEARCHSET',
    'searchset',
    'http://hl7.org/fhir/bundle-type',
    'Search Results',
    'The bundle is a list of resources returned as a result of a search/query interaction, operation, or message.',
  );
  public static readonly COLLECTION = new FhirCodeDefinition(
    'COLLECTION',
    'collection',
    'http://hl7.org/fhir/bundle-type',
    'Collection',
    'The bundle is a set of resources collected into a single package for ease of distribution that imposes no processing obligations or behavioral rules beyond persistence.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      BundleTypeEnum.DOCUMENT,
      BundleTypeEnum.MESSAGE,
      BundleTypeEnum.TRANSACTION,
      BundleTypeEnum.TRANSACTION_RESPONSE,
      BundleTypeEnum.BATCH,
      BundleTypeEnum.BATCH_RESPONSE,
      BundleTypeEnum.HISTORY,
      BundleTypeEnum.SEARCHSET,
      BundleTypeEnum.COLLECTION,
      BundleTypeEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {@link InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (BundleTypeEnum.DOCUMENT.code === code) {
      return BundleTypeEnum.DOCUMENT;
    } else if (BundleTypeEnum.MESSAGE.code === code) {
      return BundleTypeEnum.MESSAGE;
    } else if (BundleTypeEnum.TRANSACTION.code === code) {
      return BundleTypeEnum.TRANSACTION;
    } else if (BundleTypeEnum.TRANSACTION_RESPONSE.code === code) {
      return BundleTypeEnum.TRANSACTION_RESPONSE;
    } else if (BundleTypeEnum.BATCH.code === code) {
      return BundleTypeEnum.BATCH;
    } else if (BundleTypeEnum.BATCH_RESPONSE.code === code) {
      return BundleTypeEnum.BATCH_RESPONSE;
    } else if (BundleTypeEnum.HISTORY.code === code) {
      return BundleTypeEnum.HISTORY;
    } else if (BundleTypeEnum.SEARCHSET.code === code) {
      return BundleTypeEnum.SEARCHSET;
    } else if (BundleTypeEnum.COLLECTION.code === code) {
      return BundleTypeEnum.COLLECTION;
    } else if (BundleTypeEnum.NULL.code === code) {
      return BundleTypeEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown BundleTypeEnum 'code' value '\${code}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "BundleTypeEnum",
}
`;

exports[`src/generator-app unit test suite generator-app verify generated content should consistently create GeneratedContent[] 7`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator/src/__test__/test-out",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator/src/__test__/utest-cache",
    "pkgName": "utest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * SearchEntryModeEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/search-entry-mode
 * CodeSystem.name: SearchEntryMode
 * CodeSystem.description: Why an entry is in the result set - whether it\\'s included as a match or because of an _include requirement, or to convey information or warning information about the search process.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: SearchEntryModeEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem SearchEntryMode](http://hl7.org/fhir/search-entry-mode)
 */
export class SearchEntryModeEnum implements IFhirCodeEnum {
  public static readonly MATCH = new FhirCodeDefinition(
    'MATCH',
    'match',
    'http://hl7.org/fhir/search-entry-mode',
    'Match',
    'This resource matched the search specification.',
  );
  public static readonly INCLUDE = new FhirCodeDefinition(
    'INCLUDE',
    'include',
    'http://hl7.org/fhir/search-entry-mode',
    'Include',
    'This resource is returned because it is referred to from another resource in the search set.',
  );
  public static readonly OUTCOME = new FhirCodeDefinition(
    'OUTCOME',
    'outcome',
    'http://hl7.org/fhir/search-entry-mode',
    'Outcome',
    'An OperationOutcome that provides additional information about the processing of a search.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      SearchEntryModeEnum.MATCH,
      SearchEntryModeEnum.INCLUDE,
      SearchEntryModeEnum.OUTCOME,
      SearchEntryModeEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {@link InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (SearchEntryModeEnum.MATCH.code === code) {
      return SearchEntryModeEnum.MATCH;
    } else if (SearchEntryModeEnum.INCLUDE.code === code) {
      return SearchEntryModeEnum.INCLUDE;
    } else if (SearchEntryModeEnum.OUTCOME.code === code) {
      return SearchEntryModeEnum.OUTCOME;
    } else if (SearchEntryModeEnum.NULL.code === code) {
      return SearchEntryModeEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown SearchEntryModeEnum 'code' value '\${code}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "SearchEntryModeEnum",
}
`;

exports[`src/generator-app unit test suite generator-app verify generated content should consistently create GeneratedContent[] 8`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator/src/__test__/test-out",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator/src/__test__/utest-cache",
    "pkgName": "utest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * HttpVerbEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/http-verb
 * CodeSystem.name: HttpVerb
 * CodeSystem.description: HTTP verbs (in the HTTP command line). See [HTTP rfc](https://tools.ietf.org/html/rfc7231) for details.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: HttpVerbEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem HttpVerb](http://hl7.org/fhir/http-verb)
 */
export class HttpVerbEnum implements IFhirCodeEnum {
  public static readonly GET = new FhirCodeDefinition(
    'GET',
    'GET',
    'http://hl7.org/fhir/http-verb',
    'GET',
    'HTTP GET Command.',
  );
  public static readonly HEAD = new FhirCodeDefinition(
    'HEAD',
    'HEAD',
    'http://hl7.org/fhir/http-verb',
    'HEAD',
    'HTTP HEAD Command.',
  );
  public static readonly POST = new FhirCodeDefinition(
    'POST',
    'POST',
    'http://hl7.org/fhir/http-verb',
    'POST',
    'HTTP POST Command.',
  );
  public static readonly PUT = new FhirCodeDefinition(
    'PUT',
    'PUT',
    'http://hl7.org/fhir/http-verb',
    'PUT',
    'HTTP PUT Command.',
  );
  public static readonly DELETE = new FhirCodeDefinition(
    'DELETE',
    'DELETE',
    'http://hl7.org/fhir/http-verb',
    'DELETE',
    'HTTP DELETE Command.',
  );
  public static readonly PATCH = new FhirCodeDefinition(
    'PATCH',
    'PATCH',
    'http://hl7.org/fhir/http-verb',
    'PATCH',
    'HTTP PATCH Command.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      HttpVerbEnum.GET,
      HttpVerbEnum.HEAD,
      HttpVerbEnum.POST,
      HttpVerbEnum.PUT,
      HttpVerbEnum.DELETE,
      HttpVerbEnum.PATCH,
      HttpVerbEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {@link InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (HttpVerbEnum.GET.code === code) {
      return HttpVerbEnum.GET;
    } else if (HttpVerbEnum.HEAD.code === code) {
      return HttpVerbEnum.HEAD;
    } else if (HttpVerbEnum.POST.code === code) {
      return HttpVerbEnum.POST;
    } else if (HttpVerbEnum.PUT.code === code) {
      return HttpVerbEnum.PUT;
    } else if (HttpVerbEnum.DELETE.code === code) {
      return HttpVerbEnum.DELETE;
    } else if (HttpVerbEnum.PATCH.code === code) {
      return HttpVerbEnum.PATCH;
    } else if (HttpVerbEnum.NULL.code === code) {
      return HttpVerbEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown HttpVerbEnum 'code' value '\${code}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "HttpVerbEnum",
}
`;

exports[`src/generator-app unit test suite generator-app verify generated content should consistently create GeneratedContent[] 9`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator/src/__test__/test-out",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator/src/__test__/utest-cache",
    "pkgName": "utest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * PublicationStatusEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/publication-status
 * CodeSystem.name: PublicationStatus
 * CodeSystem.description: The lifecycle status of an artifact.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: PublicationStatusEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem PublicationStatus](http://hl7.org/fhir/publication-status)
 */
export class PublicationStatusEnum implements IFhirCodeEnum {
  public static readonly DRAFT = new FhirCodeDefinition(
    'DRAFT',
    'draft',
    'http://hl7.org/fhir/publication-status',
    'Draft',
    'This resource is still under development and is not yet considered to be ready for normal use.',
  );
  public static readonly ACTIVE = new FhirCodeDefinition(
    'ACTIVE',
    'active',
    'http://hl7.org/fhir/publication-status',
    'Active',
    'This resource is ready for normal use.',
  );
  public static readonly RETIRED = new FhirCodeDefinition(
    'RETIRED',
    'retired',
    'http://hl7.org/fhir/publication-status',
    'Retired',
    'This resource has been withdrawn or superseded and should no longer be used.',
  );
  public static readonly UNKNOWN = new FhirCodeDefinition(
    'UNKNOWN',
    'unknown',
    'http://hl7.org/fhir/publication-status',
    'Unknown',
    'The authoring system does not know which of the status values currently applies for this resource.  Note: This concept is not to be used for "other" - one of the listed statuses is presumed to apply, it\\'s just not known which one.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      PublicationStatusEnum.DRAFT,
      PublicationStatusEnum.ACTIVE,
      PublicationStatusEnum.RETIRED,
      PublicationStatusEnum.UNKNOWN,
      PublicationStatusEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {@link InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (PublicationStatusEnum.DRAFT.code === code) {
      return PublicationStatusEnum.DRAFT;
    } else if (PublicationStatusEnum.ACTIVE.code === code) {
      return PublicationStatusEnum.ACTIVE;
    } else if (PublicationStatusEnum.RETIRED.code === code) {
      return PublicationStatusEnum.RETIRED;
    } else if (PublicationStatusEnum.UNKNOWN.code === code) {
      return PublicationStatusEnum.UNKNOWN;
    } else if (PublicationStatusEnum.NULL.code === code) {
      return PublicationStatusEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown PublicationStatusEnum 'code' value '\${code}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "PublicationStatusEnum",
}
`;

exports[`src/generator-app unit test suite generator-app verify generated content should consistently create GeneratedContent[] 10`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator/src/__test__/test-out",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator/src/__test__/utest-cache",
    "pkgName": "utest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * ResourceTypesEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/resource-types
 * CodeSystem.name: ResourceTypes
 * CodeSystem.description: One of the resource types defined as part of this version of FHIR.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: ResourceTypesEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem ResourceTypes](http://hl7.org/fhir/resource-types)
 */
export class ResourceTypesEnum implements IFhirCodeEnum {
  public static readonly ACCOUNT = new FhirCodeDefinition(
    'ACCOUNT',
    'Account',
    'http://hl7.org/fhir/resource-types',
    'Account',
    'A financial tool for tracking value accrued for a particular purpose.  In the healthcare field, used to track charges for a patient, cost centers, etc.',
  );
  public static readonly ACTIVITY_DEFINITION = new FhirCodeDefinition(
    'ACTIVITY_DEFINITION',
    'ActivityDefinition',
    'http://hl7.org/fhir/resource-types',
    'ActivityDefinition',
    'This resource allows for the definition of some activity to be performed, independent of a particular patient, practitioner, or other performance context.',
  );
  public static readonly ADVERSE_EVENT = new FhirCodeDefinition(
    'ADVERSE_EVENT',
    'AdverseEvent',
    'http://hl7.org/fhir/resource-types',
    'AdverseEvent',
    'Actual or  potential/avoided event causing unintended physical injury resulting from or contributed to by medical care, a research study or other healthcare setting factors that requires additional monitoring, treatment, or hospitalization, or that results in death.',
  );
  public static readonly ALLERGY_INTOLERANCE = new FhirCodeDefinition(
    'ALLERGY_INTOLERANCE',
    'AllergyIntolerance',
    'http://hl7.org/fhir/resource-types',
    'AllergyIntolerance',
    'Risk of harmful or undesirable, physiological response which is unique to an individual and associated with exposure to a substance.',
  );
  public static readonly APPOINTMENT = new FhirCodeDefinition(
    'APPOINTMENT',
    'Appointment',
    'http://hl7.org/fhir/resource-types',
    'Appointment',
    'A booking of a healthcare event among patient(s), practitioner(s), related person(s) and/or device(s) for a specific date/time. This may result in one or more Encounter(s).',
  );
  public static readonly APPOINTMENT_RESPONSE = new FhirCodeDefinition(
    'APPOINTMENT_RESPONSE',
    'AppointmentResponse',
    'http://hl7.org/fhir/resource-types',
    'AppointmentResponse',
    'A reply to an appointment request for a patient and/or practitioner(s), such as a confirmation or rejection.',
  );
  public static readonly AUDIT_EVENT = new FhirCodeDefinition(
    'AUDIT_EVENT',
    'AuditEvent',
    'http://hl7.org/fhir/resource-types',
    'AuditEvent',
    'A record of an event made for purposes of maintaining a security log. Typical uses include detection of intrusion attempts and monitoring for inappropriate usage.',
  );
  public static readonly BASIC = new FhirCodeDefinition(
    'BASIC',
    'Basic',
    'http://hl7.org/fhir/resource-types',
    'Basic',
    'Basic is used for handling concepts not yet defined in FHIR, narrative-only resources that don\\'t map to an existing resource, and custom resources not appropriate for inclusion in the FHIR specification.',
  );
  public static readonly BINARY = new FhirCodeDefinition(
    'BINARY',
    'Binary',
    'http://hl7.org/fhir/resource-types',
    'Binary',
    'A resource that represents the data of a single raw artifact as digital content accessible in its native format.  A Binary resource can contain any content, whether text, image, pdf, zip archive, etc.',
  );
  public static readonly BIOLOGICALLY_DERIVED_PRODUCT = new FhirCodeDefinition(
    'BIOLOGICALLY_DERIVED_PRODUCT',
    'BiologicallyDerivedProduct',
    'http://hl7.org/fhir/resource-types',
    'BiologicallyDerivedProduct',
    'A material substance originating from a biological entity intended to be transplanted or infused into another (possibly the same) biological entity.',
  );
  public static readonly BODY_STRUCTURE = new FhirCodeDefinition(
    'BODY_STRUCTURE',
    'BodyStructure',
    'http://hl7.org/fhir/resource-types',
    'BodyStructure',
    'Record details about an anatomical structure.  This resource may be used when a coded concept does not provide the necessary detail needed for the use case.',
  );
  public static readonly BUNDLE = new FhirCodeDefinition(
    'BUNDLE',
    'Bundle',
    'http://hl7.org/fhir/resource-types',
    'Bundle',
    'A container for a collection of resources.',
  );
  public static readonly CAPABILITY_STATEMENT = new FhirCodeDefinition(
    'CAPABILITY_STATEMENT',
    'CapabilityStatement',
    'http://hl7.org/fhir/resource-types',
    'CapabilityStatement',
    'A Capability Statement documents a set of capabilities (behaviors) of a FHIR Server for a particular version of FHIR that may be used as a statement of actual server functionality or a statement of required or desired server implementation.',
  );
  public static readonly CARE_PLAN = new FhirCodeDefinition(
    'CARE_PLAN',
    'CarePlan',
    'http://hl7.org/fhir/resource-types',
    'CarePlan',
    'Describes the intention of how one or more practitioners intend to deliver care for a particular patient, group or community for a period of time, possibly limited to care for a specific condition or set of conditions.',
  );
  public static readonly CARE_TEAM = new FhirCodeDefinition(
    'CARE_TEAM',
    'CareTeam',
    'http://hl7.org/fhir/resource-types',
    'CareTeam',
    'The Care Team includes all the people and organizations who plan to participate in the coordination and delivery of care for a patient.',
  );
  public static readonly CATALOG_ENTRY = new FhirCodeDefinition(
    'CATALOG_ENTRY',
    'CatalogEntry',
    'http://hl7.org/fhir/resource-types',
    'CatalogEntry',
    'Catalog entries are wrappers that contextualize items included in a catalog.',
  );
  public static readonly CHARGE_ITEM = new FhirCodeDefinition(
    'CHARGE_ITEM',
    'ChargeItem',
    'http://hl7.org/fhir/resource-types',
    'ChargeItem',
    'The resource ChargeItem describes the provision of healthcare provider products for a certain patient, therefore referring not only to the product, but containing in addition details of the provision, like date, time, amounts and participating organizations and persons. Main Usage of the ChargeItem is to enable the billing process and internal cost allocation.',
  );
  public static readonly CHARGE_ITEM_DEFINITION = new FhirCodeDefinition(
    'CHARGE_ITEM_DEFINITION',
    'ChargeItemDefinition',
    'http://hl7.org/fhir/resource-types',
    'ChargeItemDefinition',
    'The ChargeItemDefinition resource provides the properties that apply to the (billing) codes necessary to calculate costs and prices. The properties may differ largely depending on type and realm, therefore this resource gives only a rough structure and requires profiling for each type of billing code system.',
  );
  public static readonly CLAIM = new FhirCodeDefinition(
    'CLAIM',
    'Claim',
    'http://hl7.org/fhir/resource-types',
    'Claim',
    'A provider issued list of professional services and products which have been provided, or are to be provided, to a patient which is sent to an insurer for reimbursement.',
  );
  public static readonly CLAIM_RESPONSE = new FhirCodeDefinition(
    'CLAIM_RESPONSE',
    'ClaimResponse',
    'http://hl7.org/fhir/resource-types',
    'ClaimResponse',
    'This resource provides the adjudication details from the processing of a Claim resource.',
  );
  public static readonly CLINICAL_IMPRESSION = new FhirCodeDefinition(
    'CLINICAL_IMPRESSION',
    'ClinicalImpression',
    'http://hl7.org/fhir/resource-types',
    'ClinicalImpression',
    'A record of a clinical assessment performed to determine what problem(s) may affect the patient and before planning the treatments or management strategies that are best to manage a patient\\'s condition. Assessments are often 1:1 with a clinical consultation / encounter,  but this varies greatly depending on the clinical workflow. This resource is called "ClinicalImpression" rather than "ClinicalAssessment" to avoid confusion with the recording of assessment tools such as Apgar score.',
  );
  public static readonly CODE_SYSTEM = new FhirCodeDefinition(
    'CODE_SYSTEM',
    'CodeSystem',
    'http://hl7.org/fhir/resource-types',
    'CodeSystem',
    'The CodeSystem resource is used to declare the existence of and describe a code system or code system supplement and its key properties, and optionally define a part or all of its content.',
  );
  public static readonly COMMUNICATION = new FhirCodeDefinition(
    'COMMUNICATION',
    'Communication',
    'http://hl7.org/fhir/resource-types',
    'Communication',
    'An occurrence of information being transmitted; e.g. an alert that was sent to a responsible provider, a public health agency that was notified about a reportable condition.',
  );
  public static readonly COMMUNICATION_REQUEST = new FhirCodeDefinition(
    'COMMUNICATION_REQUEST',
    'CommunicationRequest',
    'http://hl7.org/fhir/resource-types',
    'CommunicationRequest',
    'A request to convey information; e.g. the CDS system proposes that an alert be sent to a responsible provider, the CDS system proposes that the public health agency be notified about a reportable condition.',
  );
  public static readonly COMPARTMENT_DEFINITION = new FhirCodeDefinition(
    'COMPARTMENT_DEFINITION',
    'CompartmentDefinition',
    'http://hl7.org/fhir/resource-types',
    'CompartmentDefinition',
    'A compartment definition that defines how resources are accessed on a server.',
  );
  public static readonly COMPOSITION = new FhirCodeDefinition(
    'COMPOSITION',
    'Composition',
    'http://hl7.org/fhir/resource-types',
    'Composition',
    'A set of healthcare-related information that is assembled together into a single logical package that provides a single coherent statement of meaning, establishes its own context and that has clinical attestation with regard to who is making the statement. A Composition defines the structure and narrative content necessary for a document. However, a Composition alone does not constitute a document. Rather, the Composition must be the first entry in a Bundle where Bundle.type=document, and any other resources referenced from Composition must be included as subsequent entries in the Bundle (for example Patient, Practitioner, Encounter, etc.).',
  );
  public static readonly CONCEPT_MAP = new FhirCodeDefinition(
    'CONCEPT_MAP',
    'ConceptMap',
    'http://hl7.org/fhir/resource-types',
    'ConceptMap',
    'A statement of relationships from one set of concepts to one or more other concepts - either concepts in code systems, or data element/data element concepts, or classes in class models.',
  );
  public static readonly CONDITION = new FhirCodeDefinition(
    'CONDITION',
    'Condition',
    'http://hl7.org/fhir/resource-types',
    'Condition',
    'A clinical condition, problem, diagnosis, or other event, situation, issue, or clinical concept that has risen to a level of concern.',
  );
  public static readonly CONSENT = new FhirCodeDefinition(
    'CONSENT',
    'Consent',
    'http://hl7.org/fhir/resource-types',
    'Consent',
    'A record of a healthcare consumer\\'s  choices, which permits or denies identified recipient(s) or recipient role(s) to perform one or more actions within a given policy context, for specific purposes and periods of time.',
  );
  public static readonly CONTRACT = new FhirCodeDefinition(
    'CONTRACT',
    'Contract',
    'http://hl7.org/fhir/resource-types',
    'Contract',
    'Legally enforceable, formally recorded unilateral or bilateral directive i.e., a policy or agreement.',
  );
  public static readonly COVERAGE = new FhirCodeDefinition(
    'COVERAGE',
    'Coverage',
    'http://hl7.org/fhir/resource-types',
    'Coverage',
    'Financial instrument which may be used to reimburse or pay for health care products and services. Includes both insurance and self-payment.',
  );
  public static readonly COVERAGE_ELIGIBILITY_REQUEST = new FhirCodeDefinition(
    'COVERAGE_ELIGIBILITY_REQUEST',
    'CoverageEligibilityRequest',
    'http://hl7.org/fhir/resource-types',
    'CoverageEligibilityRequest',
    'The CoverageEligibilityRequest provides patient and insurance coverage information to an insurer for them to respond, in the form of an CoverageEligibilityResponse, with information regarding whether the stated coverage is valid and in-force and optionally to provide the insurance details of the policy.',
  );
  public static readonly COVERAGE_ELIGIBILITY_RESPONSE = new FhirCodeDefinition(
    'COVERAGE_ELIGIBILITY_RESPONSE',
    'CoverageEligibilityResponse',
    'http://hl7.org/fhir/resource-types',
    'CoverageEligibilityResponse',
    'This resource provides eligibility and plan details from the processing of an CoverageEligibilityRequest resource.',
  );
  public static readonly DETECTED_ISSUE = new FhirCodeDefinition(
    'DETECTED_ISSUE',
    'DetectedIssue',
    'http://hl7.org/fhir/resource-types',
    'DetectedIssue',
    'Indicates an actual or potential clinical issue with or between one or more active or proposed clinical actions for a patient; e.g. Drug-drug interaction, Ineffective treatment frequency, Procedure-condition conflict, etc.',
  );
  public static readonly DEVICE = new FhirCodeDefinition(
    'DEVICE',
    'Device',
    'http://hl7.org/fhir/resource-types',
    'Device',
    'A type of a manufactured item that is used in the provision of healthcare without being substantially changed through that activity. The device may be a medical or non-medical device.',
  );
  public static readonly DEVICE_DEFINITION = new FhirCodeDefinition(
    'DEVICE_DEFINITION',
    'DeviceDefinition',
    'http://hl7.org/fhir/resource-types',
    'DeviceDefinition',
    'The characteristics, operational status and capabilities of a medical-related component of a medical device.',
  );
  public static readonly DEVICE_METRIC = new FhirCodeDefinition(
    'DEVICE_METRIC',
    'DeviceMetric',
    'http://hl7.org/fhir/resource-types',
    'DeviceMetric',
    'Describes a measurement, calculation or setting capability of a medical device.',
  );
  public static readonly DEVICE_REQUEST = new FhirCodeDefinition(
    'DEVICE_REQUEST',
    'DeviceRequest',
    'http://hl7.org/fhir/resource-types',
    'DeviceRequest',
    'Represents a request for a patient to employ a medical device. The device may be an implantable device, or an external assistive device, such as a walker.',
  );
  public static readonly DEVICE_USE_STATEMENT = new FhirCodeDefinition(
    'DEVICE_USE_STATEMENT',
    'DeviceUseStatement',
    'http://hl7.org/fhir/resource-types',
    'DeviceUseStatement',
    'A record of a device being used by a patient where the record is the result of a report from the patient or another clinician.',
  );
  public static readonly DIAGNOSTIC_REPORT = new FhirCodeDefinition(
    'DIAGNOSTIC_REPORT',
    'DiagnosticReport',
    'http://hl7.org/fhir/resource-types',
    'DiagnosticReport',
    'The findings and interpretation of diagnostic  tests performed on patients, groups of patients, devices, and locations, and/or specimens derived from these. The report includes clinical context such as requesting and provider information, and some mix of atomic results, images, textual and coded interpretations, and formatted representation of diagnostic reports.',
  );
  public static readonly DOCUMENT_MANIFEST = new FhirCodeDefinition(
    'DOCUMENT_MANIFEST',
    'DocumentManifest',
    'http://hl7.org/fhir/resource-types',
    'DocumentManifest',
    'A collection of documents compiled for a purpose together with metadata that applies to the collection.',
  );
  public static readonly DOCUMENT_REFERENCE = new FhirCodeDefinition(
    'DOCUMENT_REFERENCE',
    'DocumentReference',
    'http://hl7.org/fhir/resource-types',
    'DocumentReference',
    'A reference to a document of any kind for any purpose. Provides metadata about the document so that the document can be discovered and managed. The scope of a document is any seralized object with a mime-type, so includes formal patient centric documents (CDA), cliical notes, scanned paper, and non-patient specific documents like policy text.',
  );
  public static readonly DOMAIN_RESOURCE = new FhirCodeDefinition(
    'DOMAIN_RESOURCE',
    'DomainResource',
    'http://hl7.org/fhir/resource-types',
    'DomainResource',
    'A resource that includes narrative, extensions, and contained resources.',
  );
  public static readonly EFFECT_EVIDENCE_SYNTHESIS = new FhirCodeDefinition(
    'EFFECT_EVIDENCE_SYNTHESIS',
    'EffectEvidenceSynthesis',
    'http://hl7.org/fhir/resource-types',
    'EffectEvidenceSynthesis',
    'The EffectEvidenceSynthesis resource describes the difference in an outcome between exposures states in a population where the effect estimate is derived from a combination of research studies.',
  );
  public static readonly ENCOUNTER = new FhirCodeDefinition(
    'ENCOUNTER',
    'Encounter',
    'http://hl7.org/fhir/resource-types',
    'Encounter',
    'An interaction between a patient and healthcare provider(s) for the purpose of providing healthcare service(s) or assessing the health status of a patient.',
  );
  public static readonly ENDPOINT = new FhirCodeDefinition(
    'ENDPOINT',
    'Endpoint',
    'http://hl7.org/fhir/resource-types',
    'Endpoint',
    'The technical details of an endpoint that can be used for electronic services, such as for web services providing XDS.b or a REST endpoint for another FHIR server. This may include any security context information.',
  );
  public static readonly ENROLLMENT_REQUEST = new FhirCodeDefinition(
    'ENROLLMENT_REQUEST',
    'EnrollmentRequest',
    'http://hl7.org/fhir/resource-types',
    'EnrollmentRequest',
    'This resource provides the insurance enrollment details to the insurer regarding a specified coverage.',
  );
  public static readonly ENROLLMENT_RESPONSE = new FhirCodeDefinition(
    'ENROLLMENT_RESPONSE',
    'EnrollmentResponse',
    'http://hl7.org/fhir/resource-types',
    'EnrollmentResponse',
    'This resource provides enrollment and plan details from the processing of an EnrollmentRequest resource.',
  );
  public static readonly EPISODE_OF_CARE = new FhirCodeDefinition(
    'EPISODE_OF_CARE',
    'EpisodeOfCare',
    'http://hl7.org/fhir/resource-types',
    'EpisodeOfCare',
    'An association between a patient and an organization / healthcare provider(s) during which time encounters may occur. The managing organization assumes a level of responsibility for the patient during this time.',
  );
  public static readonly EVENT_DEFINITION = new FhirCodeDefinition(
    'EVENT_DEFINITION',
    'EventDefinition',
    'http://hl7.org/fhir/resource-types',
    'EventDefinition',
    'The EventDefinition resource provides a reusable description of when a particular event can occur.',
  );
  public static readonly EVIDENCE = new FhirCodeDefinition(
    'EVIDENCE',
    'Evidence',
    'http://hl7.org/fhir/resource-types',
    'Evidence',
    'The Evidence resource describes the conditional state (population and any exposures being compared within the population) and outcome (if specified) that the knowledge (evidence, assertion, recommendation) is about.',
  );
  public static readonly EVIDENCE_VARIABLE = new FhirCodeDefinition(
    'EVIDENCE_VARIABLE',
    'EvidenceVariable',
    'http://hl7.org/fhir/resource-types',
    'EvidenceVariable',
    'The EvidenceVariable resource describes a "PICO" element that knowledge (evidence, assertion, recommendation) is about.',
  );
  public static readonly EXAMPLE_SCENARIO = new FhirCodeDefinition(
    'EXAMPLE_SCENARIO',
    'ExampleScenario',
    'http://hl7.org/fhir/resource-types',
    'ExampleScenario',
    'Example of workflow instance.',
  );
  public static readonly EXPLANATION_OF_BENEFIT = new FhirCodeDefinition(
    'EXPLANATION_OF_BENEFIT',
    'ExplanationOfBenefit',
    'http://hl7.org/fhir/resource-types',
    'ExplanationOfBenefit',
    'This resource provides: the claim details; adjudication details from the processing of a Claim; and optionally account balance information, for informing the subscriber of the benefits provided.',
  );
  public static readonly FAMILY_MEMBER_HISTORY = new FhirCodeDefinition(
    'FAMILY_MEMBER_HISTORY',
    'FamilyMemberHistory',
    'http://hl7.org/fhir/resource-types',
    'FamilyMemberHistory',
    'Significant health conditions for a person related to the patient relevant in the context of care for the patient.',
  );
  public static readonly FLAG = new FhirCodeDefinition(
    'FLAG',
    'Flag',
    'http://hl7.org/fhir/resource-types',
    'Flag',
    'Prospective warnings of potential issues when providing care to the patient.',
  );
  public static readonly GOAL = new FhirCodeDefinition(
    'GOAL',
    'Goal',
    'http://hl7.org/fhir/resource-types',
    'Goal',
    'Describes the intended objective(s) for a patient, group or organization care, for example, weight loss, restoring an activity of daily living, obtaining herd immunity via immunization, meeting a process improvement objective, etc.',
  );
  public static readonly GRAPH_DEFINITION = new FhirCodeDefinition(
    'GRAPH_DEFINITION',
    'GraphDefinition',
    'http://hl7.org/fhir/resource-types',
    'GraphDefinition',
    'A formal computable definition of a graph of resources - that is, a coherent set of resources that form a graph by following references. The Graph Definition resource defines a set and makes rules about the set.',
  );
  public static readonly GROUP = new FhirCodeDefinition(
    'GROUP',
    'Group',
    'http://hl7.org/fhir/resource-types',
    'Group',
    'Represents a defined collection of entities that may be discussed or acted upon collectively but which are not expected to act collectively, and are not formally or legally recognized; i.e. a collection of entities that isn\\'t an Organization.',
  );
  public static readonly GUIDANCE_RESPONSE = new FhirCodeDefinition(
    'GUIDANCE_RESPONSE',
    'GuidanceResponse',
    'http://hl7.org/fhir/resource-types',
    'GuidanceResponse',
    'A guidance response is the formal response to a guidance request, including any output parameters returned by the evaluation, as well as the description of any proposed actions to be taken.',
  );
  public static readonly HEALTHCARE_SERVICE = new FhirCodeDefinition(
    'HEALTHCARE_SERVICE',
    'HealthcareService',
    'http://hl7.org/fhir/resource-types',
    'HealthcareService',
    'The details of a healthcare service available at a location.',
  );
  public static readonly IMAGING_STUDY = new FhirCodeDefinition(
    'IMAGING_STUDY',
    'ImagingStudy',
    'http://hl7.org/fhir/resource-types',
    'ImagingStudy',
    'Representation of the content produced in a DICOM imaging study. A study comprises a set of series, each of which includes a set of Service-Object Pair Instances (SOP Instances - images or other data) acquired or produced in a common context.  A series is of only one modality (e.g. X-ray, CT, MR, ultrasound), but a study may have multiple series of different modalities.',
  );
  public static readonly IMMUNIZATION = new FhirCodeDefinition(
    'IMMUNIZATION',
    'Immunization',
    'http://hl7.org/fhir/resource-types',
    'Immunization',
    'Describes the event of a patient being administered a vaccine or a record of an immunization as reported by a patient, a clinician or another party.',
  );
  public static readonly IMMUNIZATION_EVALUATION = new FhirCodeDefinition(
    'IMMUNIZATION_EVALUATION',
    'ImmunizationEvaluation',
    'http://hl7.org/fhir/resource-types',
    'ImmunizationEvaluation',
    'Describes a comparison of an immunization event against published recommendations to determine if the administration is "valid" in relation to those  recommendations.',
  );
  public static readonly IMMUNIZATION_RECOMMENDATION = new FhirCodeDefinition(
    'IMMUNIZATION_RECOMMENDATION',
    'ImmunizationRecommendation',
    'http://hl7.org/fhir/resource-types',
    'ImmunizationRecommendation',
    'A patient\\'s point-in-time set of recommendations (i.e. forecasting) according to a published schedule with optional supporting justification.',
  );
  public static readonly IMPLEMENTATION_GUIDE = new FhirCodeDefinition(
    'IMPLEMENTATION_GUIDE',
    'ImplementationGuide',
    'http://hl7.org/fhir/resource-types',
    'ImplementationGuide',
    'A set of rules of how a particular interoperability or standards problem is solved - typically through the use of FHIR resources. This resource is used to gather all the parts of an implementation guide into a logical whole and to publish a computable definition of all the parts.',
  );
  public static readonly INSURANCE_PLAN = new FhirCodeDefinition(
    'INSURANCE_PLAN',
    'InsurancePlan',
    'http://hl7.org/fhir/resource-types',
    'InsurancePlan',
    'Details of a Health Insurance product/plan provided by an organization.',
  );
  public static readonly INVOICE = new FhirCodeDefinition(
    'INVOICE',
    'Invoice',
    'http://hl7.org/fhir/resource-types',
    'Invoice',
    'Invoice containing collected ChargeItems from an Account with calculated individual and total price for Billing purpose.',
  );
  public static readonly LIBRARY = new FhirCodeDefinition(
    'LIBRARY',
    'Library',
    'http://hl7.org/fhir/resource-types',
    'Library',
    'The Library resource is a general-purpose container for knowledge asset definitions. It can be used to describe and expose existing knowledge assets such as logic libraries and information model descriptions, as well as to describe a collection of knowledge assets.',
  );
  public static readonly LINKAGE = new FhirCodeDefinition(
    'LINKAGE',
    'Linkage',
    'http://hl7.org/fhir/resource-types',
    'Linkage',
    'Identifies two or more records (resource instances) that refer to the same real-world "occurrence".',
  );
  public static readonly LIST = new FhirCodeDefinition(
    'LIST',
    'List',
    'http://hl7.org/fhir/resource-types',
    'List',
    'A list is a curated collection of resources.',
  );
  public static readonly LOCATION = new FhirCodeDefinition(
    'LOCATION',
    'Location',
    'http://hl7.org/fhir/resource-types',
    'Location',
    'Details and position information for a physical place where services are provided and resources and participants may be stored, found, contained, or accommodated.',
  );
  public static readonly MEASURE = new FhirCodeDefinition(
    'MEASURE',
    'Measure',
    'http://hl7.org/fhir/resource-types',
    'Measure',
    'The Measure resource provides the definition of a quality measure.',
  );
  public static readonly MEASURE_REPORT = new FhirCodeDefinition(
    'MEASURE_REPORT',
    'MeasureReport',
    'http://hl7.org/fhir/resource-types',
    'MeasureReport',
    'The MeasureReport resource contains the results of the calculation of a measure; and optionally a reference to the resources involved in that calculation.',
  );
  public static readonly MEDIA = new FhirCodeDefinition(
    'MEDIA',
    'Media',
    'http://hl7.org/fhir/resource-types',
    'Media',
    'A photo, video, or audio recording acquired or used in healthcare. The actual content may be inline or provided by direct reference.',
  );
  public static readonly MEDICATION = new FhirCodeDefinition(
    'MEDICATION',
    'Medication',
    'http://hl7.org/fhir/resource-types',
    'Medication',
    'This resource is primarily used for the identification and definition of a medication for the purposes of prescribing, dispensing, and administering a medication as well as for making statements about medication use.',
  );
  public static readonly MEDICATION_ADMINISTRATION = new FhirCodeDefinition(
    'MEDICATION_ADMINISTRATION',
    'MedicationAdministration',
    'http://hl7.org/fhir/resource-types',
    'MedicationAdministration',
    'Describes the event of a patient consuming or otherwise being administered a medication.  This may be as simple as swallowing a tablet or it may be a long running infusion.  Related resources tie this event to the authorizing prescription, and the specific encounter between patient and health care practitioner.',
  );
  public static readonly MEDICATION_DISPENSE = new FhirCodeDefinition(
    'MEDICATION_DISPENSE',
    'MedicationDispense',
    'http://hl7.org/fhir/resource-types',
    'MedicationDispense',
    'Indicates that a medication product is to be or has been dispensed for a named person/patient.  This includes a description of the medication product (supply) provided and the instructions for administering the medication.  The medication dispense is the result of a pharmacy system responding to a medication order.',
  );
  public static readonly MEDICATION_KNOWLEDGE = new FhirCodeDefinition(
    'MEDICATION_KNOWLEDGE',
    'MedicationKnowledge',
    'http://hl7.org/fhir/resource-types',
    'MedicationKnowledge',
    'Information about a medication that is used to support knowledge.',
  );
  public static readonly MEDICATION_REQUEST = new FhirCodeDefinition(
    'MEDICATION_REQUEST',
    'MedicationRequest',
    'http://hl7.org/fhir/resource-types',
    'MedicationRequest',
    'An order or request for both supply of the medication and the instructions for administration of the medication to a patient. The resource is called "MedicationRequest" rather than "MedicationPrescription" or "MedicationOrder" to generalize the use across inpatient and outpatient settings, including care plans, etc., and to harmonize with workflow patterns.',
  );
  public static readonly MEDICATION_STATEMENT = new FhirCodeDefinition(
    'MEDICATION_STATEMENT',
    'MedicationStatement',
    'http://hl7.org/fhir/resource-types',
    'MedicationStatement',
    'A record of a medication that is being consumed by a patient.   A MedicationStatement may indicate that the patient may be taking the medication now or has taken the medication in the past or will be taking the medication in the future.  The source of this information can be the patient, significant other (such as a family member or spouse), or a clinician.  A common scenario where this information is captured is during the history taking process during a patient visit or stay.   The medication information may come from sources such as the patient\\'s memory, from a prescription bottle,  or from a list of medications the patient, clinician or other party maintains.  The primary difference between a medication statement and a medication administration is that the medication administration has complete administration information and is based on actual administration information from the person who administered the medication.  A medication statement is often, if not always, less specific.  There is no required date/time when the medication was administered, in fact we only know that a source has reported the patient is taking this medication, where details such as time, quantity, or rate or even medication product may be incomplete or missing or less precise.  As stated earlier, the medication statement information may come from the patient\\'s memory, from a prescription bottle or from a list of medications the patient, clinician or other party maintains.  Medication administration is more formal and is not missing detailed information.',
  );
  public static readonly MEDICINAL_PRODUCT = new FhirCodeDefinition(
    'MEDICINAL_PRODUCT',
    'MedicinalProduct',
    'http://hl7.org/fhir/resource-types',
    'MedicinalProduct',
    'Detailed definition of a medicinal product, typically for uses other than direct patient care (e.g. regulatory use).',
  );
  public static readonly MEDICINAL_PRODUCT_AUTHORIZATION = new FhirCodeDefinition(
    'MEDICINAL_PRODUCT_AUTHORIZATION',
    'MedicinalProductAuthorization',
    'http://hl7.org/fhir/resource-types',
    'MedicinalProductAuthorization',
    'The regulatory authorization of a medicinal product.',
  );
  public static readonly MEDICINAL_PRODUCT_CONTRAINDICATION = new FhirCodeDefinition(
    'MEDICINAL_PRODUCT_CONTRAINDICATION',
    'MedicinalProductContraindication',
    'http://hl7.org/fhir/resource-types',
    'MedicinalProductContraindication',
    'The clinical particulars - indications, contraindications etc. of a medicinal product, including for regulatory purposes.',
  );
  public static readonly MEDICINAL_PRODUCT_INDICATION = new FhirCodeDefinition(
    'MEDICINAL_PRODUCT_INDICATION',
    'MedicinalProductIndication',
    'http://hl7.org/fhir/resource-types',
    'MedicinalProductIndication',
    'Indication for the Medicinal Product.',
  );
  public static readonly MEDICINAL_PRODUCT_INGREDIENT = new FhirCodeDefinition(
    'MEDICINAL_PRODUCT_INGREDIENT',
    'MedicinalProductIngredient',
    'http://hl7.org/fhir/resource-types',
    'MedicinalProductIngredient',
    'An ingredient of a manufactured item or pharmaceutical product.',
  );
  public static readonly MEDICINAL_PRODUCT_INTERACTION = new FhirCodeDefinition(
    'MEDICINAL_PRODUCT_INTERACTION',
    'MedicinalProductInteraction',
    'http://hl7.org/fhir/resource-types',
    'MedicinalProductInteraction',
    'The interactions of the medicinal product with other medicinal products, or other forms of interactions.',
  );
  public static readonly MEDICINAL_PRODUCT_MANUFACTURED = new FhirCodeDefinition(
    'MEDICINAL_PRODUCT_MANUFACTURED',
    'MedicinalProductManufactured',
    'http://hl7.org/fhir/resource-types',
    'MedicinalProductManufactured',
    'The manufactured item as contained in the packaged medicinal product.',
  );
  public static readonly MEDICINAL_PRODUCT_PACKAGED = new FhirCodeDefinition(
    'MEDICINAL_PRODUCT_PACKAGED',
    'MedicinalProductPackaged',
    'http://hl7.org/fhir/resource-types',
    'MedicinalProductPackaged',
    'A medicinal product in a container or package.',
  );
  public static readonly MEDICINAL_PRODUCT_PHARMACEUTICAL = new FhirCodeDefinition(
    'MEDICINAL_PRODUCT_PHARMACEUTICAL',
    'MedicinalProductPharmaceutical',
    'http://hl7.org/fhir/resource-types',
    'MedicinalProductPharmaceutical',
    'A pharmaceutical product described in terms of its composition and dose form.',
  );
  public static readonly MEDICINAL_PRODUCT_UNDESIRABLE_EFFECT = new FhirCodeDefinition(
    'MEDICINAL_PRODUCT_UNDESIRABLE_EFFECT',
    'MedicinalProductUndesirableEffect',
    'http://hl7.org/fhir/resource-types',
    'MedicinalProductUndesirableEffect',
    'Describe the undesirable effects of the medicinal product.',
  );
  public static readonly MESSAGE_DEFINITION = new FhirCodeDefinition(
    'MESSAGE_DEFINITION',
    'MessageDefinition',
    'http://hl7.org/fhir/resource-types',
    'MessageDefinition',
    'Defines the characteristics of a message that can be shared between systems, including the type of event that initiates the message, the content to be transmitted and what response(s), if any, are permitted.',
  );
  public static readonly MESSAGE_HEADER = new FhirCodeDefinition(
    'MESSAGE_HEADER',
    'MessageHeader',
    'http://hl7.org/fhir/resource-types',
    'MessageHeader',
    'The header for a message exchange that is either requesting or responding to an action.  The reference(s) that are the subject of the action as well as other information related to the action are typically transmitted in a bundle in which the MessageHeader resource instance is the first resource in the bundle.',
  );
  public static readonly MOLECULAR_SEQUENCE = new FhirCodeDefinition(
    'MOLECULAR_SEQUENCE',
    'MolecularSequence',
    'http://hl7.org/fhir/resource-types',
    'MolecularSequence',
    'Raw data describing a biological sequence.',
  );
  public static readonly NAMING_SYSTEM = new FhirCodeDefinition(
    'NAMING_SYSTEM',
    'NamingSystem',
    'http://hl7.org/fhir/resource-types',
    'NamingSystem',
    'A curated namespace that issues unique symbols within that namespace for the identification of concepts, people, devices, etc.  Represents a "System" used within the Identifier and Coding data types.',
  );
  public static readonly NUTRITION_ORDER = new FhirCodeDefinition(
    'NUTRITION_ORDER',
    'NutritionOrder',
    'http://hl7.org/fhir/resource-types',
    'NutritionOrder',
    'A request to supply a diet, formula feeding (enteral) or oral nutritional supplement to a patient/resident.',
  );
  public static readonly OBSERVATION = new FhirCodeDefinition(
    'OBSERVATION',
    'Observation',
    'http://hl7.org/fhir/resource-types',
    'Observation',
    'Measurements and simple assertions made about a patient, device or other subject.',
  );
  public static readonly OBSERVATION_DEFINITION = new FhirCodeDefinition(
    'OBSERVATION_DEFINITION',
    'ObservationDefinition',
    'http://hl7.org/fhir/resource-types',
    'ObservationDefinition',
    'Set of definitional characteristics for a kind of observation or measurement produced or consumed by an orderable health care service.',
  );
  public static readonly OPERATION_DEFINITION = new FhirCodeDefinition(
    'OPERATION_DEFINITION',
    'OperationDefinition',
    'http://hl7.org/fhir/resource-types',
    'OperationDefinition',
    'A formal computable definition of an operation (on the RESTful interface) or a named query (using the search interaction).',
  );
  public static readonly OPERATION_OUTCOME = new FhirCodeDefinition(
    'OPERATION_OUTCOME',
    'OperationOutcome',
    'http://hl7.org/fhir/resource-types',
    'OperationOutcome',
    'A collection of error, warning, or information messages that result from a system action.',
  );
  public static readonly ORGANIZATION = new FhirCodeDefinition(
    'ORGANIZATION',
    'Organization',
    'http://hl7.org/fhir/resource-types',
    'Organization',
    'A formally or informally recognized grouping of people or organizations formed for the purpose of achieving some form of collective action.  Includes companies, institutions, corporations, departments, community groups, healthcare practice groups, payer/insurer, etc.',
  );
  public static readonly ORGANIZATION_AFFILIATION = new FhirCodeDefinition(
    'ORGANIZATION_AFFILIATION',
    'OrganizationAffiliation',
    'http://hl7.org/fhir/resource-types',
    'OrganizationAffiliation',
    'Defines an affiliation/assotiation/relationship between 2 distinct oganizations, that is not a part-of relationship/sub-division relationship.',
  );
  public static readonly PARAMETERS = new FhirCodeDefinition(
    'PARAMETERS',
    'Parameters',
    'http://hl7.org/fhir/resource-types',
    'Parameters',
    'This resource is a non-persisted resource used to pass information into and back from an [operation](https://hl7.org/fhir/operations.html). It has no other use, and there is no RESTful endpoint associated with it.',
  );
  public static readonly PATIENT = new FhirCodeDefinition(
    'PATIENT',
    'Patient',
    'http://hl7.org/fhir/resource-types',
    'Patient',
    'Demographics and other administrative information about an individual or animal receiving care or other health-related services.',
  );
  public static readonly PAYMENT_NOTICE = new FhirCodeDefinition(
    'PAYMENT_NOTICE',
    'PaymentNotice',
    'http://hl7.org/fhir/resource-types',
    'PaymentNotice',
    'This resource provides the status of the payment for goods and services rendered, and the request and response resource references.',
  );
  public static readonly PAYMENT_RECONCILIATION = new FhirCodeDefinition(
    'PAYMENT_RECONCILIATION',
    'PaymentReconciliation',
    'http://hl7.org/fhir/resource-types',
    'PaymentReconciliation',
    'This resource provides the details including amount of a payment and allocates the payment items being paid.',
  );
  public static readonly PERSON = new FhirCodeDefinition(
    'PERSON',
    'Person',
    'http://hl7.org/fhir/resource-types',
    'Person',
    'Demographics and administrative information about a person independent of a specific health-related context.',
  );
  public static readonly PLAN_DEFINITION = new FhirCodeDefinition(
    'PLAN_DEFINITION',
    'PlanDefinition',
    'http://hl7.org/fhir/resource-types',
    'PlanDefinition',
    'This resource allows for the definition of various types of plans as a sharable, consumable, and executable artifact. The resource is general enough to support the description of a broad range of clinical artifacts such as clinical decision support rules, order sets and protocols.',
  );
  public static readonly PRACTITIONER = new FhirCodeDefinition(
    'PRACTITIONER',
    'Practitioner',
    'http://hl7.org/fhir/resource-types',
    'Practitioner',
    'A person who is directly or indirectly involved in the provisioning of healthcare.',
  );
  public static readonly PRACTITIONER_ROLE = new FhirCodeDefinition(
    'PRACTITIONER_ROLE',
    'PractitionerRole',
    'http://hl7.org/fhir/resource-types',
    'PractitionerRole',
    'A specific set of Roles/Locations/specialties/services that a practitioner may perform at an organization for a period of time.',
  );
  public static readonly PROCEDURE = new FhirCodeDefinition(
    'PROCEDURE',
    'Procedure',
    'http://hl7.org/fhir/resource-types',
    'Procedure',
    'An action that is or was performed on or for a patient. This can be a physical intervention like an operation, or less invasive like long term services, counseling, or hypnotherapy.',
  );
  public static readonly PROVENANCE = new FhirCodeDefinition(
    'PROVENANCE',
    'Provenance',
    'http://hl7.org/fhir/resource-types',
    'Provenance',
    'Provenance of a resource is a record that describes entities and processes involved in producing and delivering or otherwise influencing that resource. Provenance provides a critical foundation for assessing authenticity, enabling trust, and allowing reproducibility. Provenance assertions are a form of contextual metadata and can themselves become important records with their own provenance. Provenance statement indicates clinical significance in terms of confidence in authenticity, reliability, and trustworthiness, integrity, and stage in lifecycle (e.g. Document Completion - has the artifact been legally authenticated), all of which may impact security, privacy, and trust policies.',
  );
  public static readonly QUESTIONNAIRE = new FhirCodeDefinition(
    'QUESTIONNAIRE',
    'Questionnaire',
    'http://hl7.org/fhir/resource-types',
    'Questionnaire',
    'A structured set of questions intended to guide the collection of answers from end-users. Questionnaires provide detailed control over order, presentation, phraseology and grouping to allow coherent, consistent data collection.',
  );
  public static readonly QUESTIONNAIRE_RESPONSE = new FhirCodeDefinition(
    'QUESTIONNAIRE_RESPONSE',
    'QuestionnaireResponse',
    'http://hl7.org/fhir/resource-types',
    'QuestionnaireResponse',
    'A structured set of questions and their answers. The questions are ordered and grouped into coherent subsets, corresponding to the structure of the grouping of the questionnaire being responded to.',
  );
  public static readonly RELATED_PERSON = new FhirCodeDefinition(
    'RELATED_PERSON',
    'RelatedPerson',
    'http://hl7.org/fhir/resource-types',
    'RelatedPerson',
    'Information about a person that is involved in the care for a patient, but who is not the target of healthcare, nor has a formal responsibility in the care process.',
  );
  public static readonly REQUEST_GROUP = new FhirCodeDefinition(
    'REQUEST_GROUP',
    'RequestGroup',
    'http://hl7.org/fhir/resource-types',
    'RequestGroup',
    'A group of related requests that can be used to capture intended activities that have inter-dependencies such as "give this medication after that one".',
  );
  public static readonly RESEARCH_DEFINITION = new FhirCodeDefinition(
    'RESEARCH_DEFINITION',
    'ResearchDefinition',
    'http://hl7.org/fhir/resource-types',
    'ResearchDefinition',
    'The ResearchDefinition resource describes the conditional state (population and any exposures being compared within the population) and outcome (if specified) that the knowledge (evidence, assertion, recommendation) is about.',
  );
  public static readonly RESEARCH_ELEMENT_DEFINITION = new FhirCodeDefinition(
    'RESEARCH_ELEMENT_DEFINITION',
    'ResearchElementDefinition',
    'http://hl7.org/fhir/resource-types',
    'ResearchElementDefinition',
    'The ResearchElementDefinition resource describes a "PICO" element that knowledge (evidence, assertion, recommendation) is about.',
  );
  public static readonly RESEARCH_STUDY = new FhirCodeDefinition(
    'RESEARCH_STUDY',
    'ResearchStudy',
    'http://hl7.org/fhir/resource-types',
    'ResearchStudy',
    'A process where a researcher or organization plans and then executes a series of steps intended to increase the field of healthcare-related knowledge.  This includes studies of safety, efficacy, comparative effectiveness and other information about medications, devices, therapies and other interventional and investigative techniques.  A ResearchStudy involves the gathering of information about human or animal subjects.',
  );
  public static readonly RESEARCH_SUBJECT = new FhirCodeDefinition(
    'RESEARCH_SUBJECT',
    'ResearchSubject',
    'http://hl7.org/fhir/resource-types',
    'ResearchSubject',
    'A physical entity which is the primary unit of operational and/or administrative interest in a study.',
  );
  public static readonly RESOURCE = new FhirCodeDefinition(
    'RESOURCE',
    'Resource',
    'http://hl7.org/fhir/resource-types',
    'Resource',
    'This is the base resource type for everything.',
  );
  public static readonly RISK_ASSESSMENT = new FhirCodeDefinition(
    'RISK_ASSESSMENT',
    'RiskAssessment',
    'http://hl7.org/fhir/resource-types',
    'RiskAssessment',
    'An assessment of the likely outcome(s) for a patient or other subject as well as the likelihood of each outcome.',
  );
  public static readonly RISK_EVIDENCE_SYNTHESIS = new FhirCodeDefinition(
    'RISK_EVIDENCE_SYNTHESIS',
    'RiskEvidenceSynthesis',
    'http://hl7.org/fhir/resource-types',
    'RiskEvidenceSynthesis',
    'The RiskEvidenceSynthesis resource describes the likelihood of an outcome in a population plus exposure state where the risk estimate is derived from a combination of research studies.',
  );
  public static readonly SCHEDULE = new FhirCodeDefinition(
    'SCHEDULE',
    'Schedule',
    'http://hl7.org/fhir/resource-types',
    'Schedule',
    'A container for slots of time that may be available for booking appointments.',
  );
  public static readonly SEARCH_PARAMETER = new FhirCodeDefinition(
    'SEARCH_PARAMETER',
    'SearchParameter',
    'http://hl7.org/fhir/resource-types',
    'SearchParameter',
    'A search parameter that defines a named search item that can be used to search/filter on a resource.',
  );
  public static readonly SERVICE_REQUEST = new FhirCodeDefinition(
    'SERVICE_REQUEST',
    'ServiceRequest',
    'http://hl7.org/fhir/resource-types',
    'ServiceRequest',
    'A record of a request for service such as diagnostic investigations, treatments, or operations to be performed.',
  );
  public static readonly SLOT = new FhirCodeDefinition(
    'SLOT',
    'Slot',
    'http://hl7.org/fhir/resource-types',
    'Slot',
    'A slot of time on a schedule that may be available for booking appointments.',
  );
  public static readonly SPECIMEN = new FhirCodeDefinition(
    'SPECIMEN',
    'Specimen',
    'http://hl7.org/fhir/resource-types',
    'Specimen',
    'A sample to be used for analysis.',
  );
  public static readonly SPECIMEN_DEFINITION = new FhirCodeDefinition(
    'SPECIMEN_DEFINITION',
    'SpecimenDefinition',
    'http://hl7.org/fhir/resource-types',
    'SpecimenDefinition',
    'A kind of specimen with associated set of requirements.',
  );
  public static readonly STRUCTURE_DEFINITION = new FhirCodeDefinition(
    'STRUCTURE_DEFINITION',
    'StructureDefinition',
    'http://hl7.org/fhir/resource-types',
    'StructureDefinition',
    'A definition of a FHIR structure. This resource is used to describe the underlying resources, data types defined in FHIR, and also for describing extensions and constraints on resources and data types.',
  );
  public static readonly STRUCTURE_MAP = new FhirCodeDefinition(
    'STRUCTURE_MAP',
    'StructureMap',
    'http://hl7.org/fhir/resource-types',
    'StructureMap',
    'A Map of relationships between 2 structures that can be used to transform data.',
  );
  public static readonly SUBSCRIPTION = new FhirCodeDefinition(
    'SUBSCRIPTION',
    'Subscription',
    'http://hl7.org/fhir/resource-types',
    'Subscription',
    'The subscription resource is used to define a push-based subscription from a server to another system. Once a subscription is registered with the server, the server checks every resource that is created or updated, and if the resource matches the given criteria, it sends a message on the defined "channel" so that another system can take an appropriate action.',
  );
  public static readonly SUBSTANCE = new FhirCodeDefinition(
    'SUBSTANCE',
    'Substance',
    'http://hl7.org/fhir/resource-types',
    'Substance',
    'A homogeneous material with a definite composition.',
  );
  public static readonly SUBSTANCE_NUCLEIC_ACID = new FhirCodeDefinition(
    'SUBSTANCE_NUCLEIC_ACID',
    'SubstanceNucleicAcid',
    'http://hl7.org/fhir/resource-types',
    'SubstanceNucleicAcid',
    'Nucleic acids are defined by three distinct elements: the base, sugar and linkage. Individual substance/moiety IDs will be created for each of these elements. The nucleotide sequence will be always entered in the 5\\'-3\\' direction.',
  );
  public static readonly SUBSTANCE_POLYMER = new FhirCodeDefinition(
    'SUBSTANCE_POLYMER',
    'SubstancePolymer',
    'http://hl7.org/fhir/resource-types',
    'SubstancePolymer',
    'Todo.',
  );
  public static readonly SUBSTANCE_PROTEIN = new FhirCodeDefinition(
    'SUBSTANCE_PROTEIN',
    'SubstanceProtein',
    'http://hl7.org/fhir/resource-types',
    'SubstanceProtein',
    'A SubstanceProtein is defined as a single unit of a linear amino acid sequence, or a combination of subunits that are either covalently linked or have a defined invariant stoichiometric relationship. This includes all synthetic, recombinant and purified SubstanceProteins of defined sequence, whether the use is therapeutic or prophylactic. This set of elements will be used to describe albumins, coagulation factors, cytokines, growth factors, peptide/SubstanceProtein hormones, enzymes, toxins, toxoids, recombinant vaccines, and immunomodulators.',
  );
  public static readonly SUBSTANCE_REFERENCE_INFORMATION = new FhirCodeDefinition(
    'SUBSTANCE_REFERENCE_INFORMATION',
    'SubstanceReferenceInformation',
    'http://hl7.org/fhir/resource-types',
    'SubstanceReferenceInformation',
    'Todo.',
  );
  public static readonly SUBSTANCE_SOURCE_MATERIAL = new FhirCodeDefinition(
    'SUBSTANCE_SOURCE_MATERIAL',
    'SubstanceSourceMaterial',
    'http://hl7.org/fhir/resource-types',
    'SubstanceSourceMaterial',
    'Source material shall capture information on the taxonomic and anatomical origins as well as the fraction of a material that can result in or can be modified to form a substance. This set of data elements shall be used to define polymer substances isolated from biological matrices. Taxonomic and anatomical origins shall be described using a controlled vocabulary as required. This information is captured for naturally derived polymers ( . starch) and structurally diverse substances. For Organisms belonging to the Kingdom Plantae the Substance level defines the fresh material of a single species or infraspecies, the Herbal Drug and the Herbal preparation. For Herbal preparations, the fraction information will be captured at the Substance information level and additional information for herbal extracts will be captured at the Specified Substance Group 1 information level. See for further explanation the Substance Class: Structurally Diverse and the herbal annex.',
  );
  public static readonly SUBSTANCE_SPECIFICATION = new FhirCodeDefinition(
    'SUBSTANCE_SPECIFICATION',
    'SubstanceSpecification',
    'http://hl7.org/fhir/resource-types',
    'SubstanceSpecification',
    'The detailed description of a substance, typically at a level beyond what is used for prescribing.',
  );
  public static readonly SUPPLY_DELIVERY = new FhirCodeDefinition(
    'SUPPLY_DELIVERY',
    'SupplyDelivery',
    'http://hl7.org/fhir/resource-types',
    'SupplyDelivery',
    'Record of delivery of what is supplied.',
  );
  public static readonly SUPPLY_REQUEST = new FhirCodeDefinition(
    'SUPPLY_REQUEST',
    'SupplyRequest',
    'http://hl7.org/fhir/resource-types',
    'SupplyRequest',
    'A record of a request for a medication, substance or device used in the healthcare setting.',
  );
  public static readonly TASK = new FhirCodeDefinition(
    'TASK',
    'Task',
    'http://hl7.org/fhir/resource-types',
    'Task',
    'A task to be performed.',
  );
  public static readonly TERMINOLOGY_CAPABILITIES = new FhirCodeDefinition(
    'TERMINOLOGY_CAPABILITIES',
    'TerminologyCapabilities',
    'http://hl7.org/fhir/resource-types',
    'TerminologyCapabilities',
    'A TerminologyCapabilities resource documents a set of capabilities (behaviors) of a FHIR Terminology Server that may be used as a statement of actual server functionality or a statement of required or desired server implementation.',
  );
  public static readonly TEST_REPORT = new FhirCodeDefinition(
    'TEST_REPORT',
    'TestReport',
    'http://hl7.org/fhir/resource-types',
    'TestReport',
    'A summary of information based on the results of executing a TestScript.',
  );
  public static readonly TEST_SCRIPT = new FhirCodeDefinition(
    'TEST_SCRIPT',
    'TestScript',
    'http://hl7.org/fhir/resource-types',
    'TestScript',
    'A structured set of tests against a FHIR server or client implementation to determine compliance against the FHIR specification.',
  );
  public static readonly VALUE_SET = new FhirCodeDefinition(
    'VALUE_SET',
    'ValueSet',
    'http://hl7.org/fhir/resource-types',
    'ValueSet',
    'A ValueSet resource instance specifies a set of codes drawn from one or more code systems, intended for use in a particular context. Value sets link between [[[CodeSystem]]] definitions and their use in [coded elements](https://hl7.org/fhir/terminologies.html).',
  );
  public static readonly VERIFICATION_RESULT = new FhirCodeDefinition(
    'VERIFICATION_RESULT',
    'VerificationResult',
    'http://hl7.org/fhir/resource-types',
    'VerificationResult',
    'Describes validation requirements, source(s), status and dates for one or more elements.',
  );
  public static readonly VISION_PRESCRIPTION = new FhirCodeDefinition(
    'VISION_PRESCRIPTION',
    'VisionPrescription',
    'http://hl7.org/fhir/resource-types',
    'VisionPrescription',
    'An authorization for the provision of glasses and/or contact lenses to a patient.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      ResourceTypesEnum.ACCOUNT,
      ResourceTypesEnum.ACTIVITY_DEFINITION,
      ResourceTypesEnum.ADVERSE_EVENT,
      ResourceTypesEnum.ALLERGY_INTOLERANCE,
      ResourceTypesEnum.APPOINTMENT,
      ResourceTypesEnum.APPOINTMENT_RESPONSE,
      ResourceTypesEnum.AUDIT_EVENT,
      ResourceTypesEnum.BASIC,
      ResourceTypesEnum.BINARY,
      ResourceTypesEnum.BIOLOGICALLY_DERIVED_PRODUCT,
      ResourceTypesEnum.BODY_STRUCTURE,
      ResourceTypesEnum.BUNDLE,
      ResourceTypesEnum.CAPABILITY_STATEMENT,
      ResourceTypesEnum.CARE_PLAN,
      ResourceTypesEnum.CARE_TEAM,
      ResourceTypesEnum.CATALOG_ENTRY,
      ResourceTypesEnum.CHARGE_ITEM,
      ResourceTypesEnum.CHARGE_ITEM_DEFINITION,
      ResourceTypesEnum.CLAIM,
      ResourceTypesEnum.CLAIM_RESPONSE,
      ResourceTypesEnum.CLINICAL_IMPRESSION,
      ResourceTypesEnum.CODE_SYSTEM,
      ResourceTypesEnum.COMMUNICATION,
      ResourceTypesEnum.COMMUNICATION_REQUEST,
      ResourceTypesEnum.COMPARTMENT_DEFINITION,
      ResourceTypesEnum.COMPOSITION,
      ResourceTypesEnum.CONCEPT_MAP,
      ResourceTypesEnum.CONDITION,
      ResourceTypesEnum.CONSENT,
      ResourceTypesEnum.CONTRACT,
      ResourceTypesEnum.COVERAGE,
      ResourceTypesEnum.COVERAGE_ELIGIBILITY_REQUEST,
      ResourceTypesEnum.COVERAGE_ELIGIBILITY_RESPONSE,
      ResourceTypesEnum.DETECTED_ISSUE,
      ResourceTypesEnum.DEVICE,
      ResourceTypesEnum.DEVICE_DEFINITION,
      ResourceTypesEnum.DEVICE_METRIC,
      ResourceTypesEnum.DEVICE_REQUEST,
      ResourceTypesEnum.DEVICE_USE_STATEMENT,
      ResourceTypesEnum.DIAGNOSTIC_REPORT,
      ResourceTypesEnum.DOCUMENT_MANIFEST,
      ResourceTypesEnum.DOCUMENT_REFERENCE,
      ResourceTypesEnum.DOMAIN_RESOURCE,
      ResourceTypesEnum.EFFECT_EVIDENCE_SYNTHESIS,
      ResourceTypesEnum.ENCOUNTER,
      ResourceTypesEnum.ENDPOINT,
      ResourceTypesEnum.ENROLLMENT_REQUEST,
      ResourceTypesEnum.ENROLLMENT_RESPONSE,
      ResourceTypesEnum.EPISODE_OF_CARE,
      ResourceTypesEnum.EVENT_DEFINITION,
      ResourceTypesEnum.EVIDENCE,
      ResourceTypesEnum.EVIDENCE_VARIABLE,
      ResourceTypesEnum.EXAMPLE_SCENARIO,
      ResourceTypesEnum.EXPLANATION_OF_BENEFIT,
      ResourceTypesEnum.FAMILY_MEMBER_HISTORY,
      ResourceTypesEnum.FLAG,
      ResourceTypesEnum.GOAL,
      ResourceTypesEnum.GRAPH_DEFINITION,
      ResourceTypesEnum.GROUP,
      ResourceTypesEnum.GUIDANCE_RESPONSE,
      ResourceTypesEnum.HEALTHCARE_SERVICE,
      ResourceTypesEnum.IMAGING_STUDY,
      ResourceTypesEnum.IMMUNIZATION,
      ResourceTypesEnum.IMMUNIZATION_EVALUATION,
      ResourceTypesEnum.IMMUNIZATION_RECOMMENDATION,
      ResourceTypesEnum.IMPLEMENTATION_GUIDE,
      ResourceTypesEnum.INSURANCE_PLAN,
      ResourceTypesEnum.INVOICE,
      ResourceTypesEnum.LIBRARY,
      ResourceTypesEnum.LINKAGE,
      ResourceTypesEnum.LIST,
      ResourceTypesEnum.LOCATION,
      ResourceTypesEnum.MEASURE,
      ResourceTypesEnum.MEASURE_REPORT,
      ResourceTypesEnum.MEDIA,
      ResourceTypesEnum.MEDICATION,
      ResourceTypesEnum.MEDICATION_ADMINISTRATION,
      ResourceTypesEnum.MEDICATION_DISPENSE,
      ResourceTypesEnum.MEDICATION_KNOWLEDGE,
      ResourceTypesEnum.MEDICATION_REQUEST,
      ResourceTypesEnum.MEDICATION_STATEMENT,
      ResourceTypesEnum.MEDICINAL_PRODUCT,
      ResourceTypesEnum.MEDICINAL_PRODUCT_AUTHORIZATION,
      ResourceTypesEnum.MEDICINAL_PRODUCT_CONTRAINDICATION,
      ResourceTypesEnum.MEDICINAL_PRODUCT_INDICATION,
      ResourceTypesEnum.MEDICINAL_PRODUCT_INGREDIENT,
      ResourceTypesEnum.MEDICINAL_PRODUCT_INTERACTION,
      ResourceTypesEnum.MEDICINAL_PRODUCT_MANUFACTURED,
      ResourceTypesEnum.MEDICINAL_PRODUCT_PACKAGED,
      ResourceTypesEnum.MEDICINAL_PRODUCT_PHARMACEUTICAL,
      ResourceTypesEnum.MEDICINAL_PRODUCT_UNDESIRABLE_EFFECT,
      ResourceTypesEnum.MESSAGE_DEFINITION,
      ResourceTypesEnum.MESSAGE_HEADER,
      ResourceTypesEnum.MOLECULAR_SEQUENCE,
      ResourceTypesEnum.NAMING_SYSTEM,
      ResourceTypesEnum.NUTRITION_ORDER,
      ResourceTypesEnum.OBSERVATION,
      ResourceTypesEnum.OBSERVATION_DEFINITION,
      ResourceTypesEnum.OPERATION_DEFINITION,
      ResourceTypesEnum.OPERATION_OUTCOME,
      ResourceTypesEnum.ORGANIZATION,
      ResourceTypesEnum.ORGANIZATION_AFFILIATION,
      ResourceTypesEnum.PARAMETERS,
      ResourceTypesEnum.PATIENT,
      ResourceTypesEnum.PAYMENT_NOTICE,
      ResourceTypesEnum.PAYMENT_RECONCILIATION,
      ResourceTypesEnum.PERSON,
      ResourceTypesEnum.PLAN_DEFINITION,
      ResourceTypesEnum.PRACTITIONER,
      ResourceTypesEnum.PRACTITIONER_ROLE,
      ResourceTypesEnum.PROCEDURE,
      ResourceTypesEnum.PROVENANCE,
      ResourceTypesEnum.QUESTIONNAIRE,
      ResourceTypesEnum.QUESTIONNAIRE_RESPONSE,
      ResourceTypesEnum.RELATED_PERSON,
      ResourceTypesEnum.REQUEST_GROUP,
      ResourceTypesEnum.RESEARCH_DEFINITION,
      ResourceTypesEnum.RESEARCH_ELEMENT_DEFINITION,
      ResourceTypesEnum.RESEARCH_STUDY,
      ResourceTypesEnum.RESEARCH_SUBJECT,
      ResourceTypesEnum.RESOURCE,
      ResourceTypesEnum.RISK_ASSESSMENT,
      ResourceTypesEnum.RISK_EVIDENCE_SYNTHESIS,
      ResourceTypesEnum.SCHEDULE,
      ResourceTypesEnum.SEARCH_PARAMETER,
      ResourceTypesEnum.SERVICE_REQUEST,
      ResourceTypesEnum.SLOT,
      ResourceTypesEnum.SPECIMEN,
      ResourceTypesEnum.SPECIMEN_DEFINITION,
      ResourceTypesEnum.STRUCTURE_DEFINITION,
      ResourceTypesEnum.STRUCTURE_MAP,
      ResourceTypesEnum.SUBSCRIPTION,
      ResourceTypesEnum.SUBSTANCE,
      ResourceTypesEnum.SUBSTANCE_NUCLEIC_ACID,
      ResourceTypesEnum.SUBSTANCE_POLYMER,
      ResourceTypesEnum.SUBSTANCE_PROTEIN,
      ResourceTypesEnum.SUBSTANCE_REFERENCE_INFORMATION,
      ResourceTypesEnum.SUBSTANCE_SOURCE_MATERIAL,
      ResourceTypesEnum.SUBSTANCE_SPECIFICATION,
      ResourceTypesEnum.SUPPLY_DELIVERY,
      ResourceTypesEnum.SUPPLY_REQUEST,
      ResourceTypesEnum.TASK,
      ResourceTypesEnum.TERMINOLOGY_CAPABILITIES,
      ResourceTypesEnum.TEST_REPORT,
      ResourceTypesEnum.TEST_SCRIPT,
      ResourceTypesEnum.VALUE_SET,
      ResourceTypesEnum.VERIFICATION_RESULT,
      ResourceTypesEnum.VISION_PRESCRIPTION,
      ResourceTypesEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {@link InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (ResourceTypesEnum.ACCOUNT.code === code) {
      return ResourceTypesEnum.ACCOUNT;
    } else if (ResourceTypesEnum.ACTIVITY_DEFINITION.code === code) {
      return ResourceTypesEnum.ACTIVITY_DEFINITION;
    } else if (ResourceTypesEnum.ADVERSE_EVENT.code === code) {
      return ResourceTypesEnum.ADVERSE_EVENT;
    } else if (ResourceTypesEnum.ALLERGY_INTOLERANCE.code === code) {
      return ResourceTypesEnum.ALLERGY_INTOLERANCE;
    } else if (ResourceTypesEnum.APPOINTMENT.code === code) {
      return ResourceTypesEnum.APPOINTMENT;
    } else if (ResourceTypesEnum.APPOINTMENT_RESPONSE.code === code) {
      return ResourceTypesEnum.APPOINTMENT_RESPONSE;
    } else if (ResourceTypesEnum.AUDIT_EVENT.code === code) {
      return ResourceTypesEnum.AUDIT_EVENT;
    } else if (ResourceTypesEnum.BASIC.code === code) {
      return ResourceTypesEnum.BASIC;
    } else if (ResourceTypesEnum.BINARY.code === code) {
      return ResourceTypesEnum.BINARY;
    } else if (ResourceTypesEnum.BIOLOGICALLY_DERIVED_PRODUCT.code === code) {
      return ResourceTypesEnum.BIOLOGICALLY_DERIVED_PRODUCT;
    } else if (ResourceTypesEnum.BODY_STRUCTURE.code === code) {
      return ResourceTypesEnum.BODY_STRUCTURE;
    } else if (ResourceTypesEnum.BUNDLE.code === code) {
      return ResourceTypesEnum.BUNDLE;
    } else if (ResourceTypesEnum.CAPABILITY_STATEMENT.code === code) {
      return ResourceTypesEnum.CAPABILITY_STATEMENT;
    } else if (ResourceTypesEnum.CARE_PLAN.code === code) {
      return ResourceTypesEnum.CARE_PLAN;
    } else if (ResourceTypesEnum.CARE_TEAM.code === code) {
      return ResourceTypesEnum.CARE_TEAM;
    } else if (ResourceTypesEnum.CATALOG_ENTRY.code === code) {
      return ResourceTypesEnum.CATALOG_ENTRY;
    } else if (ResourceTypesEnum.CHARGE_ITEM.code === code) {
      return ResourceTypesEnum.CHARGE_ITEM;
    } else if (ResourceTypesEnum.CHARGE_ITEM_DEFINITION.code === code) {
      return ResourceTypesEnum.CHARGE_ITEM_DEFINITION;
    } else if (ResourceTypesEnum.CLAIM.code === code) {
      return ResourceTypesEnum.CLAIM;
    } else if (ResourceTypesEnum.CLAIM_RESPONSE.code === code) {
      return ResourceTypesEnum.CLAIM_RESPONSE;
    } else if (ResourceTypesEnum.CLINICAL_IMPRESSION.code === code) {
      return ResourceTypesEnum.CLINICAL_IMPRESSION;
    } else if (ResourceTypesEnum.CODE_SYSTEM.code === code) {
      return ResourceTypesEnum.CODE_SYSTEM;
    } else if (ResourceTypesEnum.COMMUNICATION.code === code) {
      return ResourceTypesEnum.COMMUNICATION;
    } else if (ResourceTypesEnum.COMMUNICATION_REQUEST.code === code) {
      return ResourceTypesEnum.COMMUNICATION_REQUEST;
    } else if (ResourceTypesEnum.COMPARTMENT_DEFINITION.code === code) {
      return ResourceTypesEnum.COMPARTMENT_DEFINITION;
    } else if (ResourceTypesEnum.COMPOSITION.code === code) {
      return ResourceTypesEnum.COMPOSITION;
    } else if (ResourceTypesEnum.CONCEPT_MAP.code === code) {
      return ResourceTypesEnum.CONCEPT_MAP;
    } else if (ResourceTypesEnum.CONDITION.code === code) {
      return ResourceTypesEnum.CONDITION;
    } else if (ResourceTypesEnum.CONSENT.code === code) {
      return ResourceTypesEnum.CONSENT;
    } else if (ResourceTypesEnum.CONTRACT.code === code) {
      return ResourceTypesEnum.CONTRACT;
    } else if (ResourceTypesEnum.COVERAGE.code === code) {
      return ResourceTypesEnum.COVERAGE;
    } else if (ResourceTypesEnum.COVERAGE_ELIGIBILITY_REQUEST.code === code) {
      return ResourceTypesEnum.COVERAGE_ELIGIBILITY_REQUEST;
    } else if (ResourceTypesEnum.COVERAGE_ELIGIBILITY_RESPONSE.code === code) {
      return ResourceTypesEnum.COVERAGE_ELIGIBILITY_RESPONSE;
    } else if (ResourceTypesEnum.DETECTED_ISSUE.code === code) {
      return ResourceTypesEnum.DETECTED_ISSUE;
    } else if (ResourceTypesEnum.DEVICE.code === code) {
      return ResourceTypesEnum.DEVICE;
    } else if (ResourceTypesEnum.DEVICE_DEFINITION.code === code) {
      return ResourceTypesEnum.DEVICE_DEFINITION;
    } else if (ResourceTypesEnum.DEVICE_METRIC.code === code) {
      return ResourceTypesEnum.DEVICE_METRIC;
    } else if (ResourceTypesEnum.DEVICE_REQUEST.code === code) {
      return ResourceTypesEnum.DEVICE_REQUEST;
    } else if (ResourceTypesEnum.DEVICE_USE_STATEMENT.code === code) {
      return ResourceTypesEnum.DEVICE_USE_STATEMENT;
    } else if (ResourceTypesEnum.DIAGNOSTIC_REPORT.code === code) {
      return ResourceTypesEnum.DIAGNOSTIC_REPORT;
    } else if (ResourceTypesEnum.DOCUMENT_MANIFEST.code === code) {
      return ResourceTypesEnum.DOCUMENT_MANIFEST;
    } else if (ResourceTypesEnum.DOCUMENT_REFERENCE.code === code) {
      return ResourceTypesEnum.DOCUMENT_REFERENCE;
    } else if (ResourceTypesEnum.DOMAIN_RESOURCE.code === code) {
      return ResourceTypesEnum.DOMAIN_RESOURCE;
    } else if (ResourceTypesEnum.EFFECT_EVIDENCE_SYNTHESIS.code === code) {
      return ResourceTypesEnum.EFFECT_EVIDENCE_SYNTHESIS;
    } else if (ResourceTypesEnum.ENCOUNTER.code === code) {
      return ResourceTypesEnum.ENCOUNTER;
    } else if (ResourceTypesEnum.ENDPOINT.code === code) {
      return ResourceTypesEnum.ENDPOINT;
    } else if (ResourceTypesEnum.ENROLLMENT_REQUEST.code === code) {
      return ResourceTypesEnum.ENROLLMENT_REQUEST;
    } else if (ResourceTypesEnum.ENROLLMENT_RESPONSE.code === code) {
      return ResourceTypesEnum.ENROLLMENT_RESPONSE;
    } else if (ResourceTypesEnum.EPISODE_OF_CARE.code === code) {
      return ResourceTypesEnum.EPISODE_OF_CARE;
    } else if (ResourceTypesEnum.EVENT_DEFINITION.code === code) {
      return ResourceTypesEnum.EVENT_DEFINITION;
    } else if (ResourceTypesEnum.EVIDENCE.code === code) {
      return ResourceTypesEnum.EVIDENCE;
    } else if (ResourceTypesEnum.EVIDENCE_VARIABLE.code === code) {
      return ResourceTypesEnum.EVIDENCE_VARIABLE;
    } else if (ResourceTypesEnum.EXAMPLE_SCENARIO.code === code) {
      return ResourceTypesEnum.EXAMPLE_SCENARIO;
    } else if (ResourceTypesEnum.EXPLANATION_OF_BENEFIT.code === code) {
      return ResourceTypesEnum.EXPLANATION_OF_BENEFIT;
    } else if (ResourceTypesEnum.FAMILY_MEMBER_HISTORY.code === code) {
      return ResourceTypesEnum.FAMILY_MEMBER_HISTORY;
    } else if (ResourceTypesEnum.FLAG.code === code) {
      return ResourceTypesEnum.FLAG;
    } else if (ResourceTypesEnum.GOAL.code === code) {
      return ResourceTypesEnum.GOAL;
    } else if (ResourceTypesEnum.GRAPH_DEFINITION.code === code) {
      return ResourceTypesEnum.GRAPH_DEFINITION;
    } else if (ResourceTypesEnum.GROUP.code === code) {
      return ResourceTypesEnum.GROUP;
    } else if (ResourceTypesEnum.GUIDANCE_RESPONSE.code === code) {
      return ResourceTypesEnum.GUIDANCE_RESPONSE;
    } else if (ResourceTypesEnum.HEALTHCARE_SERVICE.code === code) {
      return ResourceTypesEnum.HEALTHCARE_SERVICE;
    } else if (ResourceTypesEnum.IMAGING_STUDY.code === code) {
      return ResourceTypesEnum.IMAGING_STUDY;
    } else if (ResourceTypesEnum.IMMUNIZATION.code === code) {
      return ResourceTypesEnum.IMMUNIZATION;
    } else if (ResourceTypesEnum.IMMUNIZATION_EVALUATION.code === code) {
      return ResourceTypesEnum.IMMUNIZATION_EVALUATION;
    } else if (ResourceTypesEnum.IMMUNIZATION_RECOMMENDATION.code === code) {
      return ResourceTypesEnum.IMMUNIZATION_RECOMMENDATION;
    } else if (ResourceTypesEnum.IMPLEMENTATION_GUIDE.code === code) {
      return ResourceTypesEnum.IMPLEMENTATION_GUIDE;
    } else if (ResourceTypesEnum.INSURANCE_PLAN.code === code) {
      return ResourceTypesEnum.INSURANCE_PLAN;
    } else if (ResourceTypesEnum.INVOICE.code === code) {
      return ResourceTypesEnum.INVOICE;
    } else if (ResourceTypesEnum.LIBRARY.code === code) {
      return ResourceTypesEnum.LIBRARY;
    } else if (ResourceTypesEnum.LINKAGE.code === code) {
      return ResourceTypesEnum.LINKAGE;
    } else if (ResourceTypesEnum.LIST.code === code) {
      return ResourceTypesEnum.LIST;
    } else if (ResourceTypesEnum.LOCATION.code === code) {
      return ResourceTypesEnum.LOCATION;
    } else if (ResourceTypesEnum.MEASURE.code === code) {
      return ResourceTypesEnum.MEASURE;
    } else if (ResourceTypesEnum.MEASURE_REPORT.code === code) {
      return ResourceTypesEnum.MEASURE_REPORT;
    } else if (ResourceTypesEnum.MEDIA.code === code) {
      return ResourceTypesEnum.MEDIA;
    } else if (ResourceTypesEnum.MEDICATION.code === code) {
      return ResourceTypesEnum.MEDICATION;
    } else if (ResourceTypesEnum.MEDICATION_ADMINISTRATION.code === code) {
      return ResourceTypesEnum.MEDICATION_ADMINISTRATION;
    } else if (ResourceTypesEnum.MEDICATION_DISPENSE.code === code) {
      return ResourceTypesEnum.MEDICATION_DISPENSE;
    } else if (ResourceTypesEnum.MEDICATION_KNOWLEDGE.code === code) {
      return ResourceTypesEnum.MEDICATION_KNOWLEDGE;
    } else if (ResourceTypesEnum.MEDICATION_REQUEST.code === code) {
      return ResourceTypesEnum.MEDICATION_REQUEST;
    } else if (ResourceTypesEnum.MEDICATION_STATEMENT.code === code) {
      return ResourceTypesEnum.MEDICATION_STATEMENT;
    } else if (ResourceTypesEnum.MEDICINAL_PRODUCT.code === code) {
      return ResourceTypesEnum.MEDICINAL_PRODUCT;
    } else if (ResourceTypesEnum.MEDICINAL_PRODUCT_AUTHORIZATION.code === code) {
      return ResourceTypesEnum.MEDICINAL_PRODUCT_AUTHORIZATION;
    } else if (ResourceTypesEnum.MEDICINAL_PRODUCT_CONTRAINDICATION.code === code) {
      return ResourceTypesEnum.MEDICINAL_PRODUCT_CONTRAINDICATION;
    } else if (ResourceTypesEnum.MEDICINAL_PRODUCT_INDICATION.code === code) {
      return ResourceTypesEnum.MEDICINAL_PRODUCT_INDICATION;
    } else if (ResourceTypesEnum.MEDICINAL_PRODUCT_INGREDIENT.code === code) {
      return ResourceTypesEnum.MEDICINAL_PRODUCT_INGREDIENT;
    } else if (ResourceTypesEnum.MEDICINAL_PRODUCT_INTERACTION.code === code) {
      return ResourceTypesEnum.MEDICINAL_PRODUCT_INTERACTION;
    } else if (ResourceTypesEnum.MEDICINAL_PRODUCT_MANUFACTURED.code === code) {
      return ResourceTypesEnum.MEDICINAL_PRODUCT_MANUFACTURED;
    } else if (ResourceTypesEnum.MEDICINAL_PRODUCT_PACKAGED.code === code) {
      return ResourceTypesEnum.MEDICINAL_PRODUCT_PACKAGED;
    } else if (ResourceTypesEnum.MEDICINAL_PRODUCT_PHARMACEUTICAL.code === code) {
      return ResourceTypesEnum.MEDICINAL_PRODUCT_PHARMACEUTICAL;
    } else if (ResourceTypesEnum.MEDICINAL_PRODUCT_UNDESIRABLE_EFFECT.code === code) {
      return ResourceTypesEnum.MEDICINAL_PRODUCT_UNDESIRABLE_EFFECT;
    } else if (ResourceTypesEnum.MESSAGE_DEFINITION.code === code) {
      return ResourceTypesEnum.MESSAGE_DEFINITION;
    } else if (ResourceTypesEnum.MESSAGE_HEADER.code === code) {
      return ResourceTypesEnum.MESSAGE_HEADER;
    } else if (ResourceTypesEnum.MOLECULAR_SEQUENCE.code === code) {
      return ResourceTypesEnum.MOLECULAR_SEQUENCE;
    } else if (ResourceTypesEnum.NAMING_SYSTEM.code === code) {
      return ResourceTypesEnum.NAMING_SYSTEM;
    } else if (ResourceTypesEnum.NUTRITION_ORDER.code === code) {
      return ResourceTypesEnum.NUTRITION_ORDER;
    } else if (ResourceTypesEnum.OBSERVATION.code === code) {
      return ResourceTypesEnum.OBSERVATION;
    } else if (ResourceTypesEnum.OBSERVATION_DEFINITION.code === code) {
      return ResourceTypesEnum.OBSERVATION_DEFINITION;
    } else if (ResourceTypesEnum.OPERATION_DEFINITION.code === code) {
      return ResourceTypesEnum.OPERATION_DEFINITION;
    } else if (ResourceTypesEnum.OPERATION_OUTCOME.code === code) {
      return ResourceTypesEnum.OPERATION_OUTCOME;
    } else if (ResourceTypesEnum.ORGANIZATION.code === code) {
      return ResourceTypesEnum.ORGANIZATION;
    } else if (ResourceTypesEnum.ORGANIZATION_AFFILIATION.code === code) {
      return ResourceTypesEnum.ORGANIZATION_AFFILIATION;
    } else if (ResourceTypesEnum.PARAMETERS.code === code) {
      return ResourceTypesEnum.PARAMETERS;
    } else if (ResourceTypesEnum.PATIENT.code === code) {
      return ResourceTypesEnum.PATIENT;
    } else if (ResourceTypesEnum.PAYMENT_NOTICE.code === code) {
      return ResourceTypesEnum.PAYMENT_NOTICE;
    } else if (ResourceTypesEnum.PAYMENT_RECONCILIATION.code === code) {
      return ResourceTypesEnum.PAYMENT_RECONCILIATION;
    } else if (ResourceTypesEnum.PERSON.code === code) {
      return ResourceTypesEnum.PERSON;
    } else if (ResourceTypesEnum.PLAN_DEFINITION.code === code) {
      return ResourceTypesEnum.PLAN_DEFINITION;
    } else if (ResourceTypesEnum.PRACTITIONER.code === code) {
      return ResourceTypesEnum.PRACTITIONER;
    } else if (ResourceTypesEnum.PRACTITIONER_ROLE.code === code) {
      return ResourceTypesEnum.PRACTITIONER_ROLE;
    } else if (ResourceTypesEnum.PROCEDURE.code === code) {
      return ResourceTypesEnum.PROCEDURE;
    } else if (ResourceTypesEnum.PROVENANCE.code === code) {
      return ResourceTypesEnum.PROVENANCE;
    } else if (ResourceTypesEnum.QUESTIONNAIRE.code === code) {
      return ResourceTypesEnum.QUESTIONNAIRE;
    } else if (ResourceTypesEnum.QUESTIONNAIRE_RESPONSE.code === code) {
      return ResourceTypesEnum.QUESTIONNAIRE_RESPONSE;
    } else if (ResourceTypesEnum.RELATED_PERSON.code === code) {
      return ResourceTypesEnum.RELATED_PERSON;
    } else if (ResourceTypesEnum.REQUEST_GROUP.code === code) {
      return ResourceTypesEnum.REQUEST_GROUP;
    } else if (ResourceTypesEnum.RESEARCH_DEFINITION.code === code) {
      return ResourceTypesEnum.RESEARCH_DEFINITION;
    } else if (ResourceTypesEnum.RESEARCH_ELEMENT_DEFINITION.code === code) {
      return ResourceTypesEnum.RESEARCH_ELEMENT_DEFINITION;
    } else if (ResourceTypesEnum.RESEARCH_STUDY.code === code) {
      return ResourceTypesEnum.RESEARCH_STUDY;
    } else if (ResourceTypesEnum.RESEARCH_SUBJECT.code === code) {
      return ResourceTypesEnum.RESEARCH_SUBJECT;
    } else if (ResourceTypesEnum.RESOURCE.code === code) {
      return ResourceTypesEnum.RESOURCE;
    } else if (ResourceTypesEnum.RISK_ASSESSMENT.code === code) {
      return ResourceTypesEnum.RISK_ASSESSMENT;
    } else if (ResourceTypesEnum.RISK_EVIDENCE_SYNTHESIS.code === code) {
      return ResourceTypesEnum.RISK_EVIDENCE_SYNTHESIS;
    } else if (ResourceTypesEnum.SCHEDULE.code === code) {
      return ResourceTypesEnum.SCHEDULE;
    } else if (ResourceTypesEnum.SEARCH_PARAMETER.code === code) {
      return ResourceTypesEnum.SEARCH_PARAMETER;
    } else if (ResourceTypesEnum.SERVICE_REQUEST.code === code) {
      return ResourceTypesEnum.SERVICE_REQUEST;
    } else if (ResourceTypesEnum.SLOT.code === code) {
      return ResourceTypesEnum.SLOT;
    } else if (ResourceTypesEnum.SPECIMEN.code === code) {
      return ResourceTypesEnum.SPECIMEN;
    } else if (ResourceTypesEnum.SPECIMEN_DEFINITION.code === code) {
      return ResourceTypesEnum.SPECIMEN_DEFINITION;
    } else if (ResourceTypesEnum.STRUCTURE_DEFINITION.code === code) {
      return ResourceTypesEnum.STRUCTURE_DEFINITION;
    } else if (ResourceTypesEnum.STRUCTURE_MAP.code === code) {
      return ResourceTypesEnum.STRUCTURE_MAP;
    } else if (ResourceTypesEnum.SUBSCRIPTION.code === code) {
      return ResourceTypesEnum.SUBSCRIPTION;
    } else if (ResourceTypesEnum.SUBSTANCE.code === code) {
      return ResourceTypesEnum.SUBSTANCE;
    } else if (ResourceTypesEnum.SUBSTANCE_NUCLEIC_ACID.code === code) {
      return ResourceTypesEnum.SUBSTANCE_NUCLEIC_ACID;
    } else if (ResourceTypesEnum.SUBSTANCE_POLYMER.code === code) {
      return ResourceTypesEnum.SUBSTANCE_POLYMER;
    } else if (ResourceTypesEnum.SUBSTANCE_PROTEIN.code === code) {
      return ResourceTypesEnum.SUBSTANCE_PROTEIN;
    } else if (ResourceTypesEnum.SUBSTANCE_REFERENCE_INFORMATION.code === code) {
      return ResourceTypesEnum.SUBSTANCE_REFERENCE_INFORMATION;
    } else if (ResourceTypesEnum.SUBSTANCE_SOURCE_MATERIAL.code === code) {
      return ResourceTypesEnum.SUBSTANCE_SOURCE_MATERIAL;
    } else if (ResourceTypesEnum.SUBSTANCE_SPECIFICATION.code === code) {
      return ResourceTypesEnum.SUBSTANCE_SPECIFICATION;
    } else if (ResourceTypesEnum.SUPPLY_DELIVERY.code === code) {
      return ResourceTypesEnum.SUPPLY_DELIVERY;
    } else if (ResourceTypesEnum.SUPPLY_REQUEST.code === code) {
      return ResourceTypesEnum.SUPPLY_REQUEST;
    } else if (ResourceTypesEnum.TASK.code === code) {
      return ResourceTypesEnum.TASK;
    } else if (ResourceTypesEnum.TERMINOLOGY_CAPABILITIES.code === code) {
      return ResourceTypesEnum.TERMINOLOGY_CAPABILITIES;
    } else if (ResourceTypesEnum.TEST_REPORT.code === code) {
      return ResourceTypesEnum.TEST_REPORT;
    } else if (ResourceTypesEnum.TEST_SCRIPT.code === code) {
      return ResourceTypesEnum.TEST_SCRIPT;
    } else if (ResourceTypesEnum.VALUE_SET.code === code) {
      return ResourceTypesEnum.VALUE_SET;
    } else if (ResourceTypesEnum.VERIFICATION_RESULT.code === code) {
      return ResourceTypesEnum.VERIFICATION_RESULT;
    } else if (ResourceTypesEnum.VISION_PRESCRIPTION.code === code) {
      return ResourceTypesEnum.VISION_PRESCRIPTION;
    } else if (ResourceTypesEnum.NULL.code === code) {
      return ResourceTypesEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown ResourceTypesEnum 'code' value '\${code}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "ResourceTypesEnum",
}
`;

exports[`src/generator-app unit test suite generator-app verify generated content should consistently create GeneratedContent[] 11`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator/src/__test__/test-out",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator/src/__test__/utest-cache",
    "pkgName": "utest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * SearchParamTypeEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/search-param-type
 * CodeSystem.name: SearchParamType
 * CodeSystem.description: Data types allowed to be used for search parameters.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: SearchParamTypeEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem SearchParamType](http://hl7.org/fhir/search-param-type)
 */
export class SearchParamTypeEnum implements IFhirCodeEnum {
  public static readonly NUMBER = new FhirCodeDefinition(
    'NUMBER',
    'number',
    'http://hl7.org/fhir/search-param-type',
    'Number',
    'Search parameter SHALL be a number (a whole number, or a decimal).',
  );
  public static readonly DATE = new FhirCodeDefinition(
    'DATE',
    'date',
    'http://hl7.org/fhir/search-param-type',
    'Date/DateTime',
    'Search parameter is on a date/time. The date format is the standard XML format, though other formats may be supported.',
  );
  public static readonly STRING = new FhirCodeDefinition(
    'STRING',
    'string',
    'http://hl7.org/fhir/search-param-type',
    'String',
    'Search parameter is a simple string, like a name part. Search is case-insensitive and accent-insensitive. May match just the start of a string. String parameters may contain spaces.',
  );
  public static readonly TOKEN = new FhirCodeDefinition(
    'TOKEN',
    'token',
    'http://hl7.org/fhir/search-param-type',
    'Token',
    'Search parameter on a coded element or identifier. May be used to search through the text, display, code and code/codesystem (for codes) and label, system and key (for identifier). Its value is either a string or a pair of namespace and value, separated by a "|", depending on the modifier used.',
  );
  public static readonly REFERENCE = new FhirCodeDefinition(
    'REFERENCE',
    'reference',
    'http://hl7.org/fhir/search-param-type',
    'Reference',
    'A reference to another resource (Reference or canonical).',
  );
  public static readonly COMPOSITE = new FhirCodeDefinition(
    'COMPOSITE',
    'composite',
    'http://hl7.org/fhir/search-param-type',
    'Composite',
    'A composite search parameter that combines a search on two values together.',
  );
  public static readonly QUANTITY = new FhirCodeDefinition(
    'QUANTITY',
    'quantity',
    'http://hl7.org/fhir/search-param-type',
    'Quantity',
    'A search parameter that searches on a quantity.',
  );
  public static readonly URI = new FhirCodeDefinition(
    'URI',
    'uri',
    'http://hl7.org/fhir/search-param-type',
    'URI',
    'A search parameter that searches on a URI (RFC 3986).',
  );
  public static readonly SPECIAL = new FhirCodeDefinition(
    'SPECIAL',
    'special',
    'http://hl7.org/fhir/search-param-type',
    'Special',
    'Special logic applies to this parameter per the description of the search parameter.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      SearchParamTypeEnum.NUMBER,
      SearchParamTypeEnum.DATE,
      SearchParamTypeEnum.STRING,
      SearchParamTypeEnum.TOKEN,
      SearchParamTypeEnum.REFERENCE,
      SearchParamTypeEnum.COMPOSITE,
      SearchParamTypeEnum.QUANTITY,
      SearchParamTypeEnum.URI,
      SearchParamTypeEnum.SPECIAL,
      SearchParamTypeEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {@link InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (SearchParamTypeEnum.NUMBER.code === code) {
      return SearchParamTypeEnum.NUMBER;
    } else if (SearchParamTypeEnum.DATE.code === code) {
      return SearchParamTypeEnum.DATE;
    } else if (SearchParamTypeEnum.STRING.code === code) {
      return SearchParamTypeEnum.STRING;
    } else if (SearchParamTypeEnum.TOKEN.code === code) {
      return SearchParamTypeEnum.TOKEN;
    } else if (SearchParamTypeEnum.REFERENCE.code === code) {
      return SearchParamTypeEnum.REFERENCE;
    } else if (SearchParamTypeEnum.COMPOSITE.code === code) {
      return SearchParamTypeEnum.COMPOSITE;
    } else if (SearchParamTypeEnum.QUANTITY.code === code) {
      return SearchParamTypeEnum.QUANTITY;
    } else if (SearchParamTypeEnum.URI.code === code) {
      return SearchParamTypeEnum.URI;
    } else if (SearchParamTypeEnum.SPECIAL.code === code) {
      return SearchParamTypeEnum.SPECIAL;
    } else if (SearchParamTypeEnum.NULL.code === code) {
      return SearchParamTypeEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown SearchParamTypeEnum 'code' value '\${code}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "SearchParamTypeEnum",
}
`;

exports[`src/generator-app unit test suite generator-app verify generated content should consistently create GeneratedContent[] 12`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator/src/__test__/test-out",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator/src/__test__/utest-cache",
    "pkgName": "utest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * SearchComparatorEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/search-comparator
 * CodeSystem.name: SearchComparator
 * CodeSystem.description: What Search Comparator Codes are supported in search.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: SearchComparatorEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem SearchComparator](http://hl7.org/fhir/search-comparator)
 */
export class SearchComparatorEnum implements IFhirCodeEnum {
  public static readonly EQ = new FhirCodeDefinition(
    'EQ',
    'eq',
    'http://hl7.org/fhir/search-comparator',
    'Equals',
    'the value for the parameter in the resource is equal to the provided value.',
  );
  public static readonly NE = new FhirCodeDefinition(
    'NE',
    'ne',
    'http://hl7.org/fhir/search-comparator',
    'Not Equals',
    'the value for the parameter in the resource is not equal to the provided value.',
  );
  public static readonly GT = new FhirCodeDefinition(
    'GT',
    'gt',
    'http://hl7.org/fhir/search-comparator',
    'Greater Than',
    'the value for the parameter in the resource is greater than the provided value.',
  );
  public static readonly LT = new FhirCodeDefinition(
    'LT',
    'lt',
    'http://hl7.org/fhir/search-comparator',
    'Less Than',
    'the value for the parameter in the resource is less than the provided value.',
  );
  public static readonly GE = new FhirCodeDefinition(
    'GE',
    'ge',
    'http://hl7.org/fhir/search-comparator',
    'Greater or Equals',
    'the value for the parameter in the resource is greater or equal to the provided value.',
  );
  public static readonly LE = new FhirCodeDefinition(
    'LE',
    'le',
    'http://hl7.org/fhir/search-comparator',
    'Less of Equal',
    'the value for the parameter in the resource is less or equal to the provided value.',
  );
  public static readonly SA = new FhirCodeDefinition(
    'SA',
    'sa',
    'http://hl7.org/fhir/search-comparator',
    'Starts After',
    'the value for the parameter in the resource starts after the provided value.',
  );
  public static readonly EB = new FhirCodeDefinition(
    'EB',
    'eb',
    'http://hl7.org/fhir/search-comparator',
    'Ends Before',
    'the value for the parameter in the resource ends before the provided value.',
  );
  public static readonly AP = new FhirCodeDefinition(
    'AP',
    'ap',
    'http://hl7.org/fhir/search-comparator',
    'Approximately',
    'the value for the parameter in the resource is approximately the same to the provided value.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      SearchComparatorEnum.EQ,
      SearchComparatorEnum.NE,
      SearchComparatorEnum.GT,
      SearchComparatorEnum.LT,
      SearchComparatorEnum.GE,
      SearchComparatorEnum.LE,
      SearchComparatorEnum.SA,
      SearchComparatorEnum.EB,
      SearchComparatorEnum.AP,
      SearchComparatorEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {@link InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (SearchComparatorEnum.EQ.code === code) {
      return SearchComparatorEnum.EQ;
    } else if (SearchComparatorEnum.NE.code === code) {
      return SearchComparatorEnum.NE;
    } else if (SearchComparatorEnum.GT.code === code) {
      return SearchComparatorEnum.GT;
    } else if (SearchComparatorEnum.LT.code === code) {
      return SearchComparatorEnum.LT;
    } else if (SearchComparatorEnum.GE.code === code) {
      return SearchComparatorEnum.GE;
    } else if (SearchComparatorEnum.LE.code === code) {
      return SearchComparatorEnum.LE;
    } else if (SearchComparatorEnum.SA.code === code) {
      return SearchComparatorEnum.SA;
    } else if (SearchComparatorEnum.EB.code === code) {
      return SearchComparatorEnum.EB;
    } else if (SearchComparatorEnum.AP.code === code) {
      return SearchComparatorEnum.AP;
    } else if (SearchComparatorEnum.NULL.code === code) {
      return SearchComparatorEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown SearchComparatorEnum 'code' value '\${code}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "SearchComparatorEnum",
}
`;

exports[`src/generator-app unit test suite generator-app verify generated content should consistently create GeneratedContent[] 13`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator/src/__test__/test-out",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator/src/__test__/utest-cache",
    "pkgName": "utest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * SearchModifierCodeEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/search-modifier-code
 * CodeSystem.name: SearchModifierCode
 * CodeSystem.description: A supported modifier for a search parameter.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: SearchModifierCodeEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem SearchModifierCode](http://hl7.org/fhir/search-modifier-code)
 */
export class SearchModifierCodeEnum implements IFhirCodeEnum {
  public static readonly MISSING = new FhirCodeDefinition(
    'MISSING',
    'missing',
    'http://hl7.org/fhir/search-modifier-code',
    'Missing',
    'The search parameter returns resources that have a value or not.',
  );
  public static readonly EXACT = new FhirCodeDefinition(
    'EXACT',
    'exact',
    'http://hl7.org/fhir/search-modifier-code',
    'Exact',
    'The search parameter returns resources that have a value that exactly matches the supplied parameter (the whole string, including casing and accents).',
  );
  public static readonly CONTAINS = new FhirCodeDefinition(
    'CONTAINS',
    'contains',
    'http://hl7.org/fhir/search-modifier-code',
    'Contains',
    'The search parameter returns resources that include the supplied parameter value anywhere within the field being searched.',
  );
  public static readonly NOT = new FhirCodeDefinition(
    'NOT',
    'not',
    'http://hl7.org/fhir/search-modifier-code',
    'Not',
    'The search parameter returns resources that do not contain a match.',
  );
  public static readonly TEXT = new FhirCodeDefinition(
    'TEXT',
    'text',
    'http://hl7.org/fhir/search-modifier-code',
    'Text',
    'The search parameter is processed as a string that searches text associated with the code/value - either CodeableConcept.text, Coding.display, or Identifier.type.text.',
  );
  public static readonly IN = new FhirCodeDefinition(
    'IN',
    'in',
    'http://hl7.org/fhir/search-modifier-code',
    'In',
    'The search parameter is a URI (relative or absolute) that identifies a value set, and the search parameter tests whether the coding is in the specified value set.',
  );
  public static readonly NOT_IN = new FhirCodeDefinition(
    'NOT_IN',
    'not-in',
    'http://hl7.org/fhir/search-modifier-code',
    'Not In',
    'The search parameter is a URI (relative or absolute) that identifies a value set, and the search parameter tests whether the coding is not in the specified value set.',
  );
  public static readonly BELOW = new FhirCodeDefinition(
    'BELOW',
    'below',
    'http://hl7.org/fhir/search-modifier-code',
    'Below',
    'The search parameter tests whether the value in a resource is subsumed by the specified value (is-a, or hierarchical relationships).',
  );
  public static readonly ABOVE = new FhirCodeDefinition(
    'ABOVE',
    'above',
    'http://hl7.org/fhir/search-modifier-code',
    'Above',
    'The search parameter tests whether the value in a resource subsumes the specified value (is-a, or hierarchical relationships).',
  );
  public static readonly TYPE = new FhirCodeDefinition(
    'TYPE',
    'type',
    'http://hl7.org/fhir/search-modifier-code',
    'Type',
    'The search parameter only applies to the Resource Type specified as a modifier (e.g. the modifier is not actually :type, but :Patient etc.).',
  );
  public static readonly IDENTIFIER = new FhirCodeDefinition(
    'IDENTIFIER',
    'identifier',
    'http://hl7.org/fhir/search-modifier-code',
    'Identifier',
    'The search parameter applies to the identifier on the resource, not the reference.',
  );
  public static readonly OF_TYPE = new FhirCodeDefinition(
    'OF_TYPE',
    'ofType',
    'http://hl7.org/fhir/search-modifier-code',
    'Of Type',
    'The search parameter has the format system|code|value, where the system and code refer to an Identifier.type.coding.system and .code, and match if any of the type codes match. All 3 parts must be present.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      SearchModifierCodeEnum.MISSING,
      SearchModifierCodeEnum.EXACT,
      SearchModifierCodeEnum.CONTAINS,
      SearchModifierCodeEnum.NOT,
      SearchModifierCodeEnum.TEXT,
      SearchModifierCodeEnum.IN,
      SearchModifierCodeEnum.NOT_IN,
      SearchModifierCodeEnum.BELOW,
      SearchModifierCodeEnum.ABOVE,
      SearchModifierCodeEnum.TYPE,
      SearchModifierCodeEnum.IDENTIFIER,
      SearchModifierCodeEnum.OF_TYPE,
      SearchModifierCodeEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {@link InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (SearchModifierCodeEnum.MISSING.code === code) {
      return SearchModifierCodeEnum.MISSING;
    } else if (SearchModifierCodeEnum.EXACT.code === code) {
      return SearchModifierCodeEnum.EXACT;
    } else if (SearchModifierCodeEnum.CONTAINS.code === code) {
      return SearchModifierCodeEnum.CONTAINS;
    } else if (SearchModifierCodeEnum.NOT.code === code) {
      return SearchModifierCodeEnum.NOT;
    } else if (SearchModifierCodeEnum.TEXT.code === code) {
      return SearchModifierCodeEnum.TEXT;
    } else if (SearchModifierCodeEnum.IN.code === code) {
      return SearchModifierCodeEnum.IN;
    } else if (SearchModifierCodeEnum.NOT_IN.code === code) {
      return SearchModifierCodeEnum.NOT_IN;
    } else if (SearchModifierCodeEnum.BELOW.code === code) {
      return SearchModifierCodeEnum.BELOW;
    } else if (SearchModifierCodeEnum.ABOVE.code === code) {
      return SearchModifierCodeEnum.ABOVE;
    } else if (SearchModifierCodeEnum.TYPE.code === code) {
      return SearchModifierCodeEnum.TYPE;
    } else if (SearchModifierCodeEnum.IDENTIFIER.code === code) {
      return SearchModifierCodeEnum.IDENTIFIER;
    } else if (SearchModifierCodeEnum.OF_TYPE.code === code) {
      return SearchModifierCodeEnum.OF_TYPE;
    } else if (SearchModifierCodeEnum.NULL.code === code) {
      return SearchModifierCodeEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown SearchModifierCodeEnum 'code' value '\${code}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "SearchModifierCodeEnum",
}
`;

exports[`src/generator-app unit test suite generator-app verify generated content should consistently create GeneratedContent[] 14`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator/src/__test__/test-out",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator/src/__test__/utest-cache",
    "pkgName": "utest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinitions for FHIR complex datatypes.
 * DO NOT make any modifications!
 *
 * Combined FHIR Complex Datatypes Module
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  BackboneType,
  Base64BinaryType,
  BooleanType,
  CanonicalType,
  ChoiceDataTypes,
  ChoiceDataTypesMeta,
  CodeType,
  CodeableConcept,
  Coding,
  DataType,
  DateTimeType,
  DateType,
  DecimalType,
  EnumCodeType,
  Extension as CoreExtension,
  FhirError,
  FhirParser,
  IBackboneType,
  IDataType,
  INSTANCE_EMPTY_ERROR_MSG,
  IdType,
  Identifier,
  InstantType,
  IntegerType,
  InvalidTypeError,
  JSON,
  MarkdownType,
  Meta,
  Narrative,
  OidType,
  ParsableDataType,
  Period,
  PositiveIntType,
  PrimitiveType,
  PrimitiveTypeJson,
  REQUIRED_PROPERTIES_DO_NOT_EXIST,
  REQUIRED_PROPERTIES_REQD_IN_JSON,
  Reference,
  ReferenceTargets,
  StringType,
  TimeType,
  UnsignedIntType,
  UriType,
  UrlType,
  UuidType,
  assertEnumCodeType,
  assertEnumCodeTypeList,
  assertFhirType,
  assertFhirTypeList,
  assertIsDefined,
  assertIsDefinedList,
  copyListValues,
  fhirBase64Binary,
  fhirBase64BinarySchema,
  fhirCode,
  fhirCodeSchema,
  fhirDateTime,
  fhirDateTimeSchema,
  fhirDecimal,
  fhirDecimalSchema,
  fhirInstant,
  fhirInstantSchema,
  fhirPositiveInt,
  fhirPositiveIntSchema,
  fhirString,
  fhirStringSchema,
  fhirTime,
  fhirTimeSchema,
  fhirUnsignedInt,
  fhirUnsignedIntSchema,
  fhirUri,
  fhirUriSchema,
  getPrimitiveTypeJson,
  getPrimitiveTypeListJson,
  isDefined,
  isDefinedList,
  isElementEmpty,
  isEmpty,
  parseFhirPrimitiveData,
  setFhirComplexJson,
  setFhirComplexListJson,
  setFhirPrimitiveJson,
  setFhirPrimitiveListJson,
  setPolymorphicValueJson,
} from '@paq-ts-fhir/fhir-core';
import { ContactPointSystemEnum } from '../code-systems/ContactPointSystemEnum';
import { ContactPointUseEnum } from '../code-systems/ContactPointUseEnum';
import { DaysOfWeekEnum } from '../code-systems/DaysOfWeekEnum';
import { PARSABLE_RESOURCE_MAP } from '../resources/parsable-resource-map';

// eslint-disable-next-line @typescript-eslint/no-explicit-any -- Symbol.metadata polyfill secret sauce for decorator metadata
(Symbol.metadata as any) ??= Symbol('Symbol.metadata');

// The fhir-core complex types must be exported from @paq-ts-fhir/fhir-core rather than using the generated complex types.
export { CodeableConcept, Coding, Identifier, Meta, Narrative, Period, Reference } from '@paq-ts-fhir/fhir-core';


/**
 * ContactPoint Class
 *
 * @remarks
 * Base StructureDefinition for ContactPoint Type: Details for all kinds of technology mediated contact points for a person or organization, including telephone, email, etc.
 *
 * Need to track phone, fax, mobile, sms numbers, email addresses, twitter tags, etc.
 *
 * **FHIR Specification**
 * - **Short:** Details of a Technology mediated contact point (phone, fax, email, etc.)
 * - **Definition:** Details for all kinds of technology mediated contact points for a person or organization, including telephone, email, etc.
 * - **FHIR Version:** 4.0.1
 *
 * @category Data Models: ComplexType
 * @see [FHIR ContactPoint](http://hl7.org/fhir/StructureDefinition/ContactPoint)
 */
/* istanbul ignore next */ export class ContactPoint extends DataType implements IDataType {
  constructor() {
    super();

    this.contactPointSystemEnum = new ContactPointSystemEnum();
    this.contactPointUseEnum = new ContactPointUseEnum();
  }

  /**
   * Parse the provided \`ContactPoint\` JSON to instantiate the ContactPoint data model.
   *
   * @param sourceJson - JSON representing FHIR \`ContactPoint\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to ContactPoint
   * @returns ContactPoint data model or undefined for \`ContactPoint\`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): ContactPoint | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'ContactPoint';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new ContactPoint();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'system';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setSystemElement(datatype);
    }

    fieldName = 'value';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setValueElement(datatype);
    }

    fieldName = 'use';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setUseElement(datatype);
    }

    fieldName = 'rank';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = fhirParser.parsePositiveIntType(dtJson, dtSiblingJson);
      instance.setRankElement(datatype);
    }

    fieldName = 'period';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Period | undefined = Period.parse(classJsonObj[fieldName]!, sourceField);
      instance.setPeriod(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: ContactPointSystem
   *
   * @see {@link ContactPointSystemEnum }
   */
  private readonly contactPointSystemEnum: ContactPointSystemEnum;

  /**
   * ContactPoint.system Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** phone | fax | email | pager | url | sms | other
   * - **Definition:** Telecommunications form for contact point - what communications system is required to make use of the contact.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link ContactPointSystemEnum }
   */
  private system?: EnumCodeType | undefined;

  /**
   * ContactPoint.value Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The actual contact point details
   * - **Definition:** The actual contact point details, in a form that is meaningful to the designated communication system (i.e. phone number or email address).
   * - **Comment:** Additional text data such as phone extension numbers, or notes about use of the contact are sometimes included in the value.
   * - **Requirements:** Need to support legacy numbers that are not in a tightly controlled format.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private value?: StringType | undefined;

  /**
   * FHIR CodeSystem: ContactPointUse
   *
   * @see {@link ContactPointUseEnum }
   */
  private readonly contactPointUseEnum: ContactPointUseEnum;

  /**
   * ContactPoint.use Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** home | work | temp | old | mobile - purpose of this contact point
   * - **Definition:** Identifies the purpose for the contact point.
   * - **Comment:** Applications can assume that a contact is current unless it explicitly says that it is temporary or old.
   * - **Requirements:** Need to track the way a person uses this contact, so a user can choose which is appropriate for their purpose.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** true
   * - **isModifierReason:** This is labeled as &quot;Is Modifier&quot; because applications should not mistake a temporary or old contact etc.for a current/permanent one
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link ContactPointUseEnum }
   */
  private use?: EnumCodeType | undefined;

  /**
   * ContactPoint.rank Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Specify preferred order of use (1 = highest)
   * - **Definition:** Specifies a preferred order in which to use a set of contacts. ContactPoints with lower rank values are more preferred than those with higher rank values.
   * - **Comment:** Note that rank does not necessarily follow the order in which the contacts are represented in the instance.
   * - **FHIR Type:** \`positiveInt\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private rank?: PositiveIntType | undefined;

  /**
   * ContactPoint.period Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Time period when the contact point was/is in use
   * - **Definition:** Time period when the contact point was/is in use.
   * - **FHIR Type:** \`Period\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private period?: Period | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`system\` property value as a EnumCodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link ContactPointSystemEnum }
   */
  public getSystemEnumType(): EnumCodeType | undefined {
    return this.system;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`system\` property.
   *
   * @param enumType - the \`system\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code values
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ContactPointSystemEnum }
   */
  public setSystemEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid ContactPoint.system';
      assertEnumCodeType<ContactPointSystemEnum>(enumType, ContactPointSystemEnum, errMsgPrefix);
      this.system = enumType;
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`system\` property exists and has a value; \`false\` otherwise
   */
  public hasSystemEnumType(): boolean {
    return isDefined<EnumCodeType>(this.system) && !this.system.isEmpty() && this.system.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`system\` property value as a CodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link ContactPointSystemEnum }
   */
  public getSystemElement(): CodeType | undefined {
    if (this.system === undefined) {
      return undefined;
    }
    return this.system as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`system\` property.
   *
   * @param element - the \`system\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ContactPointSystemEnum }
   */
  public setSystemElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid ContactPoint.system; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.system = new EnumCodeType(element, this.contactPointSystemEnum);
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`system\` property exists and has a value; \`false\` otherwise
   */
  public hasSystemElement(): boolean {
    return this.hasSystemEnumType();
  }

  /**
   * @returns the \`system\` property value as a fhirCode if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link ContactPointSystemEnum }
   */
  public getSystem(): fhirCode | undefined {
    if (this.system === undefined) {
      return undefined;
    }
    return this.system.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`system\` property.
   *
   * @param value - the \`system\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link ContactPointSystemEnum }
   */
  public setSystem(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid ContactPoint.system; Provided value is not an instance of fhirCode.\`;
      this.system = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.contactPointSystemEnum);
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`system\` property exists and has a value; \`false\` otherwise
   */
  public hasSystem(): boolean {
    return this.hasSystemEnumType();
  }

  /**
   * @returns the \`value\` property value as a StringType object if defined; else an empty StringType object
   */
  public getValueElement(): StringType {
    return this.value ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`value\` property.
   *
   * @param element - the \`value\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValueElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid ContactPoint.value; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.value = element;
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`value\` property exists and has a value; \`false\` otherwise
   */
  public hasValueElement(): boolean {
    return isDefined<StringType>(this.value) && !this.value.isEmpty();
  }

  /**
   * @returns the \`value\` property value as a fhirString if defined; else undefined
   */
  public getValue(): fhirString | undefined {
    return this.value?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`value\` property.
   *
   * @param value - the \`value\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValue(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid ContactPoint.value (\${String(value)})\`;
      this.value = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`value\` property exists and has a value; \`false\` otherwise
   */
  public hasValue(): boolean {
    return this.hasValueElement();
  }

  /**
   * @returns the \`use\` property value as a EnumCodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link ContactPointUseEnum }
   */
  public getUseEnumType(): EnumCodeType | undefined {
    return this.use;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`use\` property.
   *
   * @param enumType - the \`use\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code values
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ContactPointUseEnum }
   */
  public setUseEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid ContactPoint.use';
      assertEnumCodeType<ContactPointUseEnum>(enumType, ContactPointUseEnum, errMsgPrefix);
      this.use = enumType;
    } else {
      this.use = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`use\` property exists and has a value; \`false\` otherwise
   */
  public hasUseEnumType(): boolean {
    return isDefined<EnumCodeType>(this.use) && !this.use.isEmpty() && this.use.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`use\` property value as a CodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link ContactPointUseEnum }
   */
  public getUseElement(): CodeType | undefined {
    if (this.use === undefined) {
      return undefined;
    }
    return this.use as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`use\` property.
   *
   * @param element - the \`use\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ContactPointUseEnum }
   */
  public setUseElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid ContactPoint.use; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.use = new EnumCodeType(element, this.contactPointUseEnum);
    } else {
      this.use = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`use\` property exists and has a value; \`false\` otherwise
   */
  public hasUseElement(): boolean {
    return this.hasUseEnumType();
  }

  /**
   * @returns the \`use\` property value as a fhirCode if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link ContactPointUseEnum }
   */
  public getUse(): fhirCode | undefined {
    if (this.use === undefined) {
      return undefined;
    }
    return this.use.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`use\` property.
   *
   * @param value - the \`use\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link ContactPointUseEnum }
   */
  public setUse(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid ContactPoint.use; Provided value is not an instance of fhirCode.\`;
      this.use = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.contactPointUseEnum);
    } else {
      this.use = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`use\` property exists and has a value; \`false\` otherwise
   */
  public hasUse(): boolean {
    return this.hasUseEnumType();
  }

  /**
   * @returns the \`rank\` property value as a PositiveIntType object if defined; else an empty PositiveIntType object
   */
  public getRankElement(): PositiveIntType {
    return this.rank ?? new PositiveIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`rank\` property.
   *
   * @param element - the \`rank\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setRankElement(element: PositiveIntType | undefined): this {
    if (isDefined<PositiveIntType>(element)) {
      const optErrMsg = \`Invalid ContactPoint.rank; Provided element is not an instance of PositiveIntType.\`;
      assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
      this.rank = element;
    } else {
      this.rank = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`rank\` property exists and has a value; \`false\` otherwise
   */
  public hasRankElement(): boolean {
    return isDefined<PositiveIntType>(this.rank) && !this.rank.isEmpty();
  }

  /**
   * @returns the \`rank\` property value as a fhirPositiveInt if defined; else undefined
   */
  public getRank(): fhirPositiveInt | undefined {
    return this.rank?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`rank\` property.
   *
   * @param value - the \`rank\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setRank(value: fhirPositiveInt | undefined): this {
    if (isDefined<fhirPositiveInt>(value)) {
      const optErrMsg = \`Invalid ContactPoint.rank (\${String(value)})\`;
      this.rank = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    } else {
      this.rank = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`rank\` property exists and has a value; \`false\` otherwise
   */
  public hasRank(): boolean {
    return this.hasRankElement();
  }

  /**
   * @returns the \`period\` property value as a Period object if defined; else an empty Period object
   */
  public getPeriod(): Period {
    return this.period ?? new Period();
  }

  /**
   * Assigns the provided Period object value to the \`period\` property.
   *
   * @param value - the \`period\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setPeriod(value: Period | undefined): this {
    if (isDefined<Period>(value)) {
      const optErrMsg = \`Invalid ContactPoint.period; Provided element is not an instance of Period.\`;
      assertFhirType<Period>(value, Period, optErrMsg);
      this.period = value;
    } else {
      this.period = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`period\` property exists and has a value; \`false\` otherwise
   */
  public hasPeriod(): boolean {
    return isDefined<Period>(this.period) && !this.period.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'ContactPoint';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.system,
      this.value,
      this.use,
      this.rank,
      this.period,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): ContactPoint {
    const dest = new ContactPoint();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: ContactPoint): void {
    super.copyValues(dest);
    dest.system = this.system?.copy();
    dest.value = this.value?.copy();
    dest.use = this.use?.copy();
    dest.rank = this.rank?.copy();
    dest.period = this.period?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', \`UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasSystemElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getSystemElement()!, 'system', jsonObj);
    }

    if (this.hasValueElement()) {
      setFhirPrimitiveJson<fhirString>(this.getValueElement(), 'value', jsonObj);
    }

    if (this.hasUseElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getUseElement()!, 'use', jsonObj);
    }

    if (this.hasRankElement()) {
      setFhirPrimitiveJson<fhirPositiveInt>(this.getRankElement(), 'rank', jsonObj);
    }

    if (this.hasPeriod()) {
      setFhirComplexJson(this.getPeriod(), 'period', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * Duration Class
 *
 * @remarks
 * Base StructureDefinition for Duration Type: A length of time.
 *
 * **FHIR Specification**
 * - **Short:** A length of time
 * - **Definition:** A length of time.
 * - **Comment:** The context of use may frequently define what kind of quantity this is and therefore what kind of units can be used. The context of use may also restrict the values for the comparator.
 * - **FHIR Version:** 4.0.1
 *
 * @category Data Models: ComplexType
 * @see [FHIR Duration](http://hl7.org/fhir/StructureDefinition/Duration)
 */
/* istanbul ignore next */ export class Duration extends DataType implements IDataType {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`Duration\` JSON to instantiate the Duration data model.
   *
   * @param sourceJson - JSON representing FHIR \`Duration\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Duration
   * @returns Duration data model or undefined for \`Duration\`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Duration | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Duration';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Duration();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'value';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setValueElement(datatype);
    }

    fieldName = 'comparator';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setComparatorElement(datatype);
    }

    fieldName = 'unit';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setUnitElement(datatype);
    }

    fieldName = 'system';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = fhirParser.parseUriType(dtJson, dtSiblingJson);
      instance.setSystemElement(datatype);
    }

    fieldName = 'code';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setCodeElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Duration.value Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Numerical value (with implicit precision)
   * - **Definition:** The value of the measured amount. The value includes an implicit precision in the presentation of the value.
   * - **Comment:** The implicit precision in the value should always be honored. Monetary values have their own rules for handling precision (refer to standard accounting text books).
   * - **Requirements:** Precision is handled implicitly in almost all cases of measurement.
   * - **FHIR Type:** \`decimal\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private value?: DecimalType | undefined;

  /**
   * Duration.comparator Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** < | <= | >= | > - how to understand the value
   * - **Definition:** How the value should be understood and represented - whether the actual value is greater or less than the stated value due to measurement issues; e.g. if the comparator is "<" , then the real value is < stated value.
   * - **Requirements:** Need a framework for handling measures where the value is <5ug/L or >400mg/L due to the limitations of measuring methodology.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** true
   * - **isModifierReason:** This is labeled as &quot;Is Modifier&quot; because the comparator modifies the interpretation of the value significantly. If there is no comparator, then there is no modification of the value
   * - **isSummary:** true
   */
  private comparator?: CodeType | undefined;

  /**
   * Duration.unit Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Unit representation
   * - **Definition:** A human-readable form of the unit.
   * - **Requirements:** There are many representations for units of measure and in many contexts, particular representations are fixed and required. I.e. mcg for micrograms.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private unit?: StringType | undefined;

  /**
   * Duration.system Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** System that defines coded unit form
   * - **Definition:** The identification of the system that provides the coded form of the unit.
   * - **Requirements:** Need to know the system that defines the coded form of the unit.
   * - **FHIR Type:** \`uri\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private system?: UriType | undefined;

  /**
   * Duration.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Coded form of the unit
   * - **Definition:** A computer processable form of the unit in some unit representation system.
   * - **Comment:** The preferred system is UCUM, but SNOMED CT can also be used (for customary units) or ISO 4217 for currency.  The context of use may additionally require a code from a particular system.
   * - **Requirements:** Need a computable form of the unit that is fixed across all forms. UCUM provides this for quantities, but SNOMED CT provides many units of interest.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code?: CodeType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`value\` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getValueElement(): DecimalType {
    return this.value ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`value\` property.
   *
   * @param element - the \`value\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValueElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = \`Invalid Duration.value; Provided element is not an instance of DecimalType.\`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.value = element;
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`value\` property exists and has a value; \`false\` otherwise
   */
  public hasValueElement(): boolean {
    return isDefined<DecimalType>(this.value) && !this.value.isEmpty();
  }

  /**
   * @returns the \`value\` property value as a fhirDecimal if defined; else undefined
   */
  public getValue(): fhirDecimal | undefined {
    return this.value?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`value\` property.
   *
   * @param value - the \`value\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValue(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = \`Invalid Duration.value (\${String(value)})\`;
      this.value = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`value\` property exists and has a value; \`false\` otherwise
   */
  public hasValue(): boolean {
    return this.hasValueElement();
  }

  /**
   * @returns the \`comparator\` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getComparatorElement(): CodeType {
    return this.comparator ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`comparator\` property.
   *
   * @param element - the \`comparator\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setComparatorElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Duration.comparator; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.comparator = element;
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`comparator\` property exists and has a value; \`false\` otherwise
   */
  public hasComparatorElement(): boolean {
    return isDefined<CodeType>(this.comparator) && !this.comparator.isEmpty();
  }

  /**
   * @returns the \`comparator\` property value as a fhirCode if defined; else undefined
   */
  public getComparator(): fhirCode | undefined {
    return this.comparator?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`comparator\` property.
   *
   * @param value - the \`comparator\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setComparator(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Duration.comparator (\${String(value)})\`;
      this.comparator = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`comparator\` property exists and has a value; \`false\` otherwise
   */
  public hasComparator(): boolean {
    return this.hasComparatorElement();
  }

  /**
   * @returns the \`unit\` property value as a StringType object if defined; else an empty StringType object
   */
  public getUnitElement(): StringType {
    return this.unit ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`unit\` property.
   *
   * @param element - the \`unit\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUnitElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Duration.unit; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.unit = element;
    } else {
      this.unit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`unit\` property exists and has a value; \`false\` otherwise
   */
  public hasUnitElement(): boolean {
    return isDefined<StringType>(this.unit) && !this.unit.isEmpty();
  }

  /**
   * @returns the \`unit\` property value as a fhirString if defined; else undefined
   */
  public getUnit(): fhirString | undefined {
    return this.unit?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`unit\` property.
   *
   * @param value - the \`unit\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUnit(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Duration.unit (\${String(value)})\`;
      this.unit = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.unit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`unit\` property exists and has a value; \`false\` otherwise
   */
  public hasUnit(): boolean {
    return this.hasUnitElement();
  }

  /**
   * @returns the \`system\` property value as a UriType object if defined; else an empty UriType object
   */
  public getSystemElement(): UriType {
    return this.system ?? new UriType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`system\` property.
   *
   * @param element - the \`system\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSystemElement(element: UriType | undefined): this {
    if (isDefined<UriType>(element)) {
      const optErrMsg = \`Invalid Duration.system; Provided element is not an instance of UriType.\`;
      assertFhirType<UriType>(element, UriType, optErrMsg);
      this.system = element;
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`system\` property exists and has a value; \`false\` otherwise
   */
  public hasSystemElement(): boolean {
    return isDefined<UriType>(this.system) && !this.system.isEmpty();
  }

  /**
   * @returns the \`system\` property value as a fhirUri if defined; else undefined
   */
  public getSystem(): fhirUri | undefined {
    return this.system?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`system\` property.
   *
   * @param value - the \`system\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSystem(value: fhirUri | undefined): this {
    if (isDefined<fhirUri>(value)) {
      const optErrMsg = \`Invalid Duration.system (\${String(value)})\`;
      this.system = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`system\` property exists and has a value; \`false\` otherwise
   */
  public hasSystem(): boolean {
    return this.hasSystemElement();
  }

  /**
   * @returns the \`code\` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getCodeElement(): CodeType {
    return this.code ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`code\` property.
   *
   * @param element - the \`code\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCodeElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Duration.code; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.code = element;
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`code\` property exists and has a value; \`false\` otherwise
   */
  public hasCodeElement(): boolean {
    return isDefined<CodeType>(this.code) && !this.code.isEmpty();
  }

  /**
   * @returns the \`code\` property value as a fhirCode if defined; else undefined
   */
  public getCode(): fhirCode | undefined {
    return this.code?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`code\` property.
   *
   * @param value - the \`code\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCode(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Duration.code (\${String(value)})\`;
      this.code = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`code\` property exists and has a value; \`false\` otherwise
   */
  public hasCode(): boolean {
    return this.hasCodeElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Duration';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.value,
      this.comparator,
      this.unit,
      this.system,
      this.code,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Duration {
    const dest = new Duration();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Duration): void {
    super.copyValues(dest);
    dest.value = this.value?.copy();
    dest.comparator = this.comparator?.copy();
    dest.unit = this.unit?.copy();
    dest.system = this.system?.copy();
    dest.code = this.code?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', \`UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasValueElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getValueElement(), 'value', jsonObj);
    }

    if (this.hasComparatorElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getComparatorElement(), 'comparator', jsonObj);
    }

    if (this.hasUnitElement()) {
      setFhirPrimitiveJson<fhirString>(this.getUnitElement(), 'unit', jsonObj);
    }

    if (this.hasSystemElement()) {
      setFhirPrimitiveJson<fhirUri>(this.getSystemElement(), 'system', jsonObj);
    }

    if (this.hasCodeElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getCodeElement(), 'code', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * Extension Class
 *
 * @remarks
 * Base StructureDefinition for Extension Type: Optional Extension Element - found in all resources.
 *
 * The ability to add extensions in a structured way is what keeps FHIR resources simple.
 *
 * **FHIR Specification**
 * - **Short:** Optional Extensions Element
 * - **Definition:** Optional Extension Element - found in all resources.
 * - **FHIR Version:** 4.0.1
 *
 * @category Data Models: ComplexType
 * @see [FHIR Extension](http://hl7.org/fhir/StructureDefinition/Extension)
 */
/* istanbul ignore next */ export class Extension extends CoreExtension {
  constructor(url: fhirUri | null = null, value?: IDataType) {
    super(url, value);
  }

  // *** NOTE ***
  // Following "get"/"has" methods are added for each open data type - one pair of methods for each open data type

  /**
   * @returns the \`value\` property value as a Base64BinaryType object if defined; else undefined
   */
  public getValueBase64BinaryType(): Base64BinaryType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Base64BinaryType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected Base64BinaryType but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a Base64BinaryType and has a value; \`false\` otherwise
   */
  public hasValueBase64BinaryType(): boolean {
    return this.hasValue() && this.value instanceof Base64BinaryType;
  }

  /**
   * @returns the \`value\` property value as a BooleanType object if defined; else undefined
   */
  public getValueBooleanType(): BooleanType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof BooleanType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected BooleanType but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a BooleanType and has a value; \`false\` otherwise
   */
  public hasValueBooleanType(): boolean {
    return this.hasValue() && this.value instanceof BooleanType;
  }

  /**
   * @returns the \`value\` property value as a CanonicalType object if defined; else undefined
   */
  public getValueCanonicalType(): CanonicalType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof CanonicalType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected CanonicalType but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a CanonicalType and has a value; \`false\` otherwise
   */
  public hasValueCanonicalType(): boolean {
    return this.hasValue() && this.value instanceof CanonicalType;
  }

  /**
   * @returns the \`value\` property value as a CodeType object if defined; else undefined
   */
  public getValueCodeType(): CodeType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof CodeType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected CodeType but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a CodeType and has a value; \`false\` otherwise
   */
  public hasValueCodeType(): boolean {
    return this.hasValue() && this.value instanceof CodeType;
  }

  /**
   * @returns the \`value\` property value as a DateType object if defined; else undefined
   */
  public getValueDateType(): DateType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof DateType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected DateType but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a DateType and has a value; \`false\` otherwise
   */
  public hasValueDateType(): boolean {
    return this.hasValue() && this.value instanceof DateType;
  }

  /**
   * @returns the \`value\` property value as a DateTimeType object if defined; else undefined
   */
  public getValueDateTimeType(): DateTimeType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof DateTimeType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected DateTimeType but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a DateTimeType and has a value; \`false\` otherwise
   */
  public hasValueDateTimeType(): boolean {
    return this.hasValue() && this.value instanceof DateTimeType;
  }

  /**
   * @returns the \`value\` property value as a DecimalType object if defined; else undefined
   */
  public getValueDecimalType(): DecimalType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof DecimalType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected DecimalType but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a DecimalType and has a value; \`false\` otherwise
   */
  public hasValueDecimalType(): boolean {
    return this.hasValue() && this.value instanceof DecimalType;
  }

  /**
   * @returns the \`value\` property value as a IdType object if defined; else undefined
   */
  public getValueIdType(): IdType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof IdType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected IdType but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a IdType and has a value; \`false\` otherwise
   */
  public hasValueIdType(): boolean {
    return this.hasValue() && this.value instanceof IdType;
  }

  /**
   * @returns the \`value\` property value as a InstantType object if defined; else undefined
   */
  public getValueInstantType(): InstantType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof InstantType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected InstantType but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a InstantType and has a value; \`false\` otherwise
   */
  public hasValueInstantType(): boolean {
    return this.hasValue() && this.value instanceof InstantType;
  }

  /**
   * @returns the \`value\` property value as a IntegerType object if defined; else undefined
   */
  public getValueIntegerType(): IntegerType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof IntegerType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected IntegerType but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a IntegerType and has a value; \`false\` otherwise
   */
  public hasValueIntegerType(): boolean {
    return this.hasValue() && this.value instanceof IntegerType;
  }

  /**
   * @returns the \`value\` property value as a MarkdownType object if defined; else undefined
   */
  public getValueMarkdownType(): MarkdownType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof MarkdownType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected MarkdownType but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a MarkdownType and has a value; \`false\` otherwise
   */
  public hasValueMarkdownType(): boolean {
    return this.hasValue() && this.value instanceof MarkdownType;
  }

  /**
   * @returns the \`value\` property value as a OidType object if defined; else undefined
   */
  public getValueOidType(): OidType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof OidType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected OidType but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a OidType and has a value; \`false\` otherwise
   */
  public hasValueOidType(): boolean {
    return this.hasValue() && this.value instanceof OidType;
  }

  /**
   * @returns the \`value\` property value as a PositiveIntType object if defined; else undefined
   */
  public getValuePositiveIntType(): PositiveIntType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof PositiveIntType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected PositiveIntType but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a PositiveIntType and has a value; \`false\` otherwise
   */
  public hasValuePositiveIntType(): boolean {
    return this.hasValue() && this.value instanceof PositiveIntType;
  }

  /**
   * @returns the \`value\` property value as a StringType object if defined; else undefined
   */
  public getValueStringType(): StringType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof StringType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected StringType but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a StringType and has a value; \`false\` otherwise
   */
  public hasValueStringType(): boolean {
    return this.hasValue() && this.value instanceof StringType;
  }

  /**
   * @returns the \`value\` property value as a TimeType object if defined; else undefined
   */
  public getValueTimeType(): TimeType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof TimeType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected TimeType but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a TimeType and has a value; \`false\` otherwise
   */
  public hasValueTimeType(): boolean {
    return this.hasValue() && this.value instanceof TimeType;
  }

  /**
   * @returns the \`value\` property value as a UnsignedIntType object if defined; else undefined
   */
  public getValueUnsignedIntType(): UnsignedIntType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof UnsignedIntType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected UnsignedIntType but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a UnsignedIntType and has a value; \`false\` otherwise
   */
  public hasValueUnsignedIntType(): boolean {
    return this.hasValue() && this.value instanceof UnsignedIntType;
  }

  /**
   * @returns the \`value\` property value as a UriType object if defined; else undefined
   */
  public getValueUriType(): UriType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof UriType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected UriType but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a UriType and has a value; \`false\` otherwise
   */
  public hasValueUriType(): boolean {
    return this.hasValue() && this.value instanceof UriType;
  }

  /**
   * @returns the \`value\` property value as a UrlType object if defined; else undefined
   */
  public getValueUrlType(): UrlType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof UrlType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected UrlType but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a UrlType and has a value; \`false\` otherwise
   */
  public hasValueUrlType(): boolean {
    return this.hasValue() && this.value instanceof UrlType;
  }

  /**
   * @returns the \`value\` property value as a UuidType object if defined; else undefined
   */
  public getValueUuidType(): UuidType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof UuidType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected UuidType but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a UuidType and has a value; \`false\` otherwise
   */
  public hasValueUuidType(): boolean {
    return this.hasValue() && this.value instanceof UuidType;
  }

  /**
   * @returns the \`value\` property value as a Address object if defined; else undefined
   */
  public getValueAddress(): Address | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Address)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected Address but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a Address and has a value; \`false\` otherwise
   */
  public hasValueAddress(): boolean {
    return this.hasValue() && this.value instanceof Address;
  }

  /**
   * @returns the \`value\` property value as a Age object if defined; else undefined
   */
  public getValueAge(): Age | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Age)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected Age but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a Age and has a value; \`false\` otherwise
   */
  public hasValueAge(): boolean {
    return this.hasValue() && this.value instanceof Age;
  }

  /**
   * @returns the \`value\` property value as a Annotation object if defined; else undefined
   */
  public getValueAnnotation(): Annotation | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Annotation)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected Annotation but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a Annotation and has a value; \`false\` otherwise
   */
  public hasValueAnnotation(): boolean {
    return this.hasValue() && this.value instanceof Annotation;
  }

  /**
   * @returns the \`value\` property value as a Attachment object if defined; else undefined
   */
  public getValueAttachment(): Attachment | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Attachment)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected Attachment but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a Attachment and has a value; \`false\` otherwise
   */
  public hasValueAttachment(): boolean {
    return this.hasValue() && this.value instanceof Attachment;
  }

  /**
   * @returns the \`value\` property value as a CodeableConcept object if defined; else undefined
   */
  public getValueCodeableConcept(): CodeableConcept | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof CodeableConcept)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected CodeableConcept but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a CodeableConcept and has a value; \`false\` otherwise
   */
  public hasValueCodeableConcept(): boolean {
    return this.hasValue() && this.value instanceof CodeableConcept;
  }

  /**
   * @returns the \`value\` property value as a Coding object if defined; else undefined
   */
  public getValueCoding(): Coding | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Coding)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected Coding but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a Coding and has a value; \`false\` otherwise
   */
  public hasValueCoding(): boolean {
    return this.hasValue() && this.value instanceof Coding;
  }

  /**
   * @returns the \`value\` property value as a ContactPoint object if defined; else undefined
   */
  public getValueContactPoint(): ContactPoint | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof ContactPoint)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected ContactPoint but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a ContactPoint and has a value; \`false\` otherwise
   */
  public hasValueContactPoint(): boolean {
    return this.hasValue() && this.value instanceof ContactPoint;
  }

  /**
   * @returns the \`value\` property value as a Count object if defined; else undefined
   */
  public getValueCount(): Count | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Count)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected Count but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a Count and has a value; \`false\` otherwise
   */
  public hasValueCount(): boolean {
    return this.hasValue() && this.value instanceof Count;
  }

  /**
   * @returns the \`value\` property value as a Distance object if defined; else undefined
   */
  public getValueDistance(): Distance | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Distance)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected Distance but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a Distance and has a value; \`false\` otherwise
   */
  public hasValueDistance(): boolean {
    return this.hasValue() && this.value instanceof Distance;
  }

  /**
   * @returns the \`value\` property value as a Duration object if defined; else undefined
   */
  public getValueDuration(): Duration | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Duration)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected Duration but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a Duration and has a value; \`false\` otherwise
   */
  public hasValueDuration(): boolean {
    return this.hasValue() && this.value instanceof Duration;
  }

  /**
   * @returns the \`value\` property value as a HumanName object if defined; else undefined
   */
  public getValueHumanName(): HumanName | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof HumanName)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected HumanName but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a HumanName and has a value; \`false\` otherwise
   */
  public hasValueHumanName(): boolean {
    return this.hasValue() && this.value instanceof HumanName;
  }

  /**
   * @returns the \`value\` property value as a Identifier object if defined; else undefined
   */
  public getValueIdentifier(): Identifier | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Identifier)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected Identifier but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a Identifier and has a value; \`false\` otherwise
   */
  public hasValueIdentifier(): boolean {
    return this.hasValue() && this.value instanceof Identifier;
  }

  /**
   * @returns the \`value\` property value as a Money object if defined; else undefined
   */
  public getValueMoney(): Money | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Money)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected Money but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a Money and has a value; \`false\` otherwise
   */
  public hasValueMoney(): boolean {
    return this.hasValue() && this.value instanceof Money;
  }

  /**
   * @returns the \`value\` property value as a Period object if defined; else undefined
   */
  public getValuePeriod(): Period | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Period)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected Period but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a Period and has a value; \`false\` otherwise
   */
  public hasValuePeriod(): boolean {
    return this.hasValue() && this.value instanceof Period;
  }

  /**
   * @returns the \`value\` property value as a Quantity object if defined; else undefined
   */
  public getValueQuantity(): Quantity | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Quantity)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected Quantity but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a Quantity and has a value; \`false\` otherwise
   */
  public hasValueQuantity(): boolean {
    return this.hasValue() && this.value instanceof Quantity;
  }

  /**
   * @returns the \`value\` property value as a Range object if defined; else undefined
   */
  public getValueRange(): Range | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Range)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected Range but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a Range and has a value; \`false\` otherwise
   */
  public hasValueRange(): boolean {
    return this.hasValue() && this.value instanceof Range;
  }

  /**
   * @returns the \`value\` property value as a Ratio object if defined; else undefined
   */
  public getValueRatio(): Ratio | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Ratio)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected Ratio but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a Ratio and has a value; \`false\` otherwise
   */
  public hasValueRatio(): boolean {
    return this.hasValue() && this.value instanceof Ratio;
  }

  /**
   * @returns the \`value\` property value as a Reference object if defined; else undefined
   */
  public getValueReference(): Reference | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Reference)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected Reference but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a Reference and has a value; \`false\` otherwise
   */
  public hasValueReference(): boolean {
    return this.hasValue() && this.value instanceof Reference;
  }

  /**
   * @returns the \`value\` property value as a SampledData object if defined; else undefined
   */
  public getValueSampledData(): SampledData | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof SampledData)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected SampledData but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a SampledData and has a value; \`false\` otherwise
   */
  public hasValueSampledData(): boolean {
    return this.hasValue() && this.value instanceof SampledData;
  }

  /**
   * @returns the \`value\` property value as a Signature object if defined; else undefined
   */
  public getValueSignature(): Signature | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Signature)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected Signature but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a Signature and has a value; \`false\` otherwise
   */
  public hasValueSignature(): boolean {
    return this.hasValue() && this.value instanceof Signature;
  }

  /**
   * @returns the \`value\` property value as a Timing object if defined; else undefined
   */
  public getValueTiming(): Timing | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Timing)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected Timing but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a Timing and has a value; \`false\` otherwise
   */
  public hasValueTiming(): boolean {
    return this.hasValue() && this.value instanceof Timing;
  }

  /**
   * @returns the \`value\` property value as a ContactDetail object if defined; else undefined
   */
  public getValueContactDetail(): ContactDetail | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof ContactDetail)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected ContactDetail but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a ContactDetail and has a value; \`false\` otherwise
   */
  public hasValueContactDetail(): boolean {
    return this.hasValue() && this.value instanceof ContactDetail;
  }

  /**
   * @returns the \`value\` property value as a Contributor object if defined; else undefined
   */
  public getValueContributor(): Contributor | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Contributor)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected Contributor but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a Contributor and has a value; \`false\` otherwise
   */
  public hasValueContributor(): boolean {
    return this.hasValue() && this.value instanceof Contributor;
  }

  /**
   * @returns the \`value\` property value as a DataRequirement object if defined; else undefined
   */
  public getValueDataRequirement(): DataRequirement | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof DataRequirement)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected DataRequirement but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a DataRequirement and has a value; \`false\` otherwise
   */
  public hasValueDataRequirement(): boolean {
    return this.hasValue() && this.value instanceof DataRequirement;
  }

  /**
   * @returns the \`value\` property value as a Expression object if defined; else undefined
   */
  public getValueExpression(): Expression | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Expression)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected Expression but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a Expression and has a value; \`false\` otherwise
   */
  public hasValueExpression(): boolean {
    return this.hasValue() && this.value instanceof Expression;
  }

  /**
   * @returns the \`value\` property value as a ParameterDefinition object if defined; else undefined
   */
  public getValueParameterDefinition(): ParameterDefinition | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof ParameterDefinition)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected ParameterDefinition but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a ParameterDefinition and has a value; \`false\` otherwise
   */
  public hasValueParameterDefinition(): boolean {
    return this.hasValue() && this.value instanceof ParameterDefinition;
  }

  /**
   * @returns the \`value\` property value as a RelatedArtifact object if defined; else undefined
   */
  public getValueRelatedArtifact(): RelatedArtifact | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof RelatedArtifact)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected RelatedArtifact but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a RelatedArtifact and has a value; \`false\` otherwise
   */
  public hasValueRelatedArtifact(): boolean {
    return this.hasValue() && this.value instanceof RelatedArtifact;
  }

  /**
   * @returns the \`value\` property value as a TriggerDefinition object if defined; else undefined
   */
  public getValueTriggerDefinition(): TriggerDefinition | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof TriggerDefinition)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected TriggerDefinition but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a TriggerDefinition and has a value; \`false\` otherwise
   */
  public hasValueTriggerDefinition(): boolean {
    return this.hasValue() && this.value instanceof TriggerDefinition;
  }

  /**
   * @returns the \`value\` property value as a UsageContext object if defined; else undefined
   */
  public getValueUsageContext(): UsageContext | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof UsageContext)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected UsageContext but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a UsageContext and has a value; \`false\` otherwise
   */
  public hasValueUsageContext(): boolean {
    return this.hasValue() && this.value instanceof UsageContext;
  }

  /**
   * @returns the \`value\` property value as a Dosage object if defined; else undefined
   */
  public getValueDosage(): Dosage | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Dosage)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected Dosage but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a Dosage and has a value; \`false\` otherwise
   */
  public hasValueDosage(): boolean {
    return this.hasValue() && this.value instanceof Dosage;
  }

  /**
   * @returns the \`value\` property value as a Meta object if defined; else undefined
   */
  public getValueMeta(): Meta | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Meta)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected Meta but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a Meta and has a value; \`false\` otherwise
   */
  public hasValueMeta(): boolean {
    return this.hasValue() && this.value instanceof Meta;
  }
}

/**
 * Signature Class
 *
 * @remarks
 * Base StructureDefinition for Signature Type: A signature along with supporting context. The signature may be a digital signature that is cryptographic in nature, or some other signature acceptable to the domain. This other signature may be as simple as a graphical image representing a hand-written signature, or a signature ceremony Different signature approaches have different utilities.
 *
 * There are a number of places where content must be signed in healthcare.
 *
 * **FHIR Specification**
 * - **Short:** A Signature - XML DigSig, JWS, Graphical image of signature, etc.
 * - **Definition:** A signature along with supporting context. The signature may be a digital signature that is cryptographic in nature, or some other signature acceptable to the domain. This other signature may be as simple as a graphical image representing a hand-written signature, or a signature ceremony Different signature approaches have different utilities.
 * - **Comment:** The elements of the Signature Resource are for ease of access of these elements. For digital signatures (Xml DigSig, JWS), the non-repudiation proof comes from the Signature  validation, which includes validation of the referenced objects (e.g. Resources) (a.k.a., Content) in the XML-Signature Detached form.
 * - **FHIR Version:** 4.0.1
 *
 * @category Data Models: ComplexType
 * @see [FHIR Signature](http://hl7.org/fhir/StructureDefinition/Signature)
 */
/* istanbul ignore next */ export class Signature extends DataType implements IDataType {
  constructor(type_: Coding[] | null = null, when: InstantType | fhirInstant | null = null, who: Reference | null = null) {
    super();

    this.type_ = null;
    if (isDefinedList<Coding>(type_)) {
      this.setType(type_);
    }

    this.when = null;
    if (isDefined<InstantType | fhirInstant>(when)) {
      if (when instanceof PrimitiveType) {
        this.setWhenElement(when);
      } else {
        this.setWhen(when);
      }
    }

    this.who = null;
    if (isDefined<Reference>(who)) {
      this.setWho(who);
    }
  }

  /**
   * Parse the provided \`Signature\` JSON to instantiate the Signature data model.
   *
   * @param sourceJson - JSON representing FHIR \`Signature\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Signature
   * @returns Signature data model or undefined for \`Signature\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Signature | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Signature';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Signature();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'type';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Coding | undefined = Coding.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype === undefined) {
          missingReqdProperties.push(\`\${sourceField}[\${String(idx)}]\`);
        } else {
          instance.addType(datatype);
        }
      });
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'when';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: InstantType | undefined = fhirParser.parseInstantType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setWhenElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'who';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = Reference.parse(classJsonObj[fieldName]!, sourceField);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setWho(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'onBehalfOf';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = Reference.parse(classJsonObj[fieldName]!, sourceField);
      instance.setOnBehalfOf(datatype);
    }

    fieldName = 'targetFormat';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setTargetFormatElement(datatype);
    }

    fieldName = 'sigFormat';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setSigFormatElement(datatype);
    }

    fieldName = 'data';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: Base64BinaryType | undefined = fhirParser.parseBase64BinaryType(dtJson, dtSiblingJson);
      instance.setDataElement(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Signature.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Indication of the reason the entity signed the object(s)
   * - **Definition:** An indication of the reason that the entity signed this document. This may be explicitly included as part of the signature information and can be used when determining accountability for various actions concerning the document.
   * - **Comment:** Examples include attesting to: authorship, correct transcription, and witness of specific event. Also known as a &quot;Commitment Type Indication&quot;.
   * - **FHIR Type:** \`Coding\`
   * - **Cardinality:** 1..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private type_: Coding[] | null;

  /**
   * Signature.when Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** When the signature was created
   * - **Definition:** When the digital signature was signed.
   * - **Comment:** This should agree with the information in the signature.
   * - **FHIR Type:** \`instant\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private when: InstantType | null;

  /**
   * Signature.who Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Who signed
   * - **Definition:** A reference to an application-usable description of the identity that signed  (e.g. the signature used their private key).
   * - **Comment:** This should agree with the information in the signature.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Practitioner',
   *       'http://hl7.org/fhir/StructureDefinition/PractitionerRole',
   *       'http://hl7.org/fhir/StructureDefinition/RelatedPerson',
   *       'http://hl7.org/fhir/StructureDefinition/Patient',
   *       'http://hl7.org/fhir/StructureDefinition/Device',
   *       'http://hl7.org/fhir/StructureDefinition/Organization',
   *     ]
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private who: Reference | null;

  /**
   * Signature.onBehalfOf Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The party represented
   * - **Definition:** A reference to an application-usable description of the identity that is represented by the signature.
   * - **Comment:** The party that can\\'t sign. For example a child.
   * - **Requirements:** used when the signature is on behalf of a non-signer.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Practitioner',
   *       'http://hl7.org/fhir/StructureDefinition/PractitionerRole',
   *       'http://hl7.org/fhir/StructureDefinition/RelatedPerson',
   *       'http://hl7.org/fhir/StructureDefinition/Patient',
   *       'http://hl7.org/fhir/StructureDefinition/Device',
   *       'http://hl7.org/fhir/StructureDefinition/Organization',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private onBehalfOf?: Reference | undefined;

  /**
   * Signature.targetFormat Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The technical format of the signed resources
   * - **Definition:** A mime type that indicates the technical format of the target resources signed by the signature.
   * - **Comment:** "xml", "json" and "ttl" are allowed, which describe the simple encodings described in the specification (and imply appropriate bundle support). Otherwise, mime types are legal here.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private targetFormat?: CodeType | undefined;

  /**
   * Signature.sigFormat Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The technical format of the signature
   * - **Definition:** A mime type that indicates the technical format of the signature. Important mime types are application/signature+xml for X ML DigSig, application/jose for JWS, and image/* for a graphical image of a signature, etc.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private sigFormat?: CodeType | undefined;

  /**
   * Signature.data Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The actual signature content (XML DigSig. JWS, picture, etc.)
   * - **Definition:** The base64 encoding of the Signature content. When signature is not recorded electronically this element would be empty.
   * - **Comment:** Where the signature type is an XML DigSig, the signed content is a FHIR Resource(s), the signature is of the XML form of the Resource(s) using  XML-Signature (XMLDIG) "Detached Signature" form.
   * - **FHIR Type:** \`base64Binary\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private data?: Base64BinaryType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`type_\` property value as a Coding array
   */
  public getType(): Coding[] {
    return this.type_ ?? ([] as Coding[]);
  }

  /**
   * Assigns the provided Coding array value to the \`type_\` property.
   *
   * @param value - the \`type_\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setType(value: Coding[]): this {
    assertIsDefinedList<Coding>(value, \`Signature.type is required\`);
    const optErrMsg = \`Invalid Signature.type; Provided value array has an element that is not an instance of Coding.\`;
    assertFhirTypeList<Coding>(value, Coding, optErrMsg);
    this.type_ = value;
    return this;
  }

  /**
   * Add the provided Coding value to the \`type_\` array property.
   *
   * @param value - the \`type_\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addType(value: Coding | undefined): this {
    if (isDefined<Coding>(value)) {
      const optErrMsg = \`Invalid Signature.type; Provided element is not an instance of Coding.\`;
      assertFhirType<Coding>(value, Coding, optErrMsg);
      this.initType();
      this.type_?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasType(): boolean {
    return isDefinedList<Coding>(this.type_) && this.type_.some((item: Coding) => !item.isEmpty());
  }

  /**
   * Initialize the \`type_\` property
   */
  private initType(): void {
    if(!this.hasType()) {
      this.type_ = [] as Coding[];
    }
  }

  /**
   * @returns the \`when\` property value as a InstantType object if defined; else null
   */
  public getWhenElement(): InstantType | null {
    return this.when;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`when\` property.
   *
   * @param element - the \`when\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setWhenElement(element: InstantType): this {
    assertIsDefined<InstantType>(element, \`Signature.when is required\`);
    const optErrMsg = \`Invalid Signature.when; Provided value is not an instance of InstantType.\`;
    assertFhirType<InstantType>(element, InstantType, optErrMsg);
    this.when = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`when\` property exists and has a value; \`false\` otherwise
   */
  public hasWhenElement(): boolean {
    return isDefined<InstantType>(this.when) && !this.when.isEmpty();
  }

  /**
   * @returns the \`when\` property value as a fhirInstant if defined; else null
   */
  public getWhen(): fhirInstant | null {
    if (this.when?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.when.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`when\` property.
   *
   * @param value - the \`when\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setWhen(value: fhirInstant): this {
    assertIsDefined<fhirInstant>(value, \`Signature.when is required\`);
    const optErrMsg = \`Invalid Signature.when (\${String(value)})\`;
    this.when = new InstantType(parseFhirPrimitiveData(value, fhirInstantSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`when\` property exists and has a value; \`false\` otherwise
   */
  public hasWhen(): boolean {
    return this.hasWhenElement();
  }

  /**
   * @returns the \`who\` property value as a Reference object if defined; else null
   */
  public getWho(): Reference | null {
    return this.who;
  }

  /**
   * Assigns the provided Who object value to the \`who\` property.
   *
   * @decorator \`@ReferenceTargets('Signature.who', ['Practitioner','PractitionerRole','RelatedPerson','Patient','Device','Organization',])\`
   *
   * @param value - the \`who\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('Signature.who', [
    'Practitioner',
  
    'PractitionerRole',
  
    'RelatedPerson',
  
    'Patient',
  
    'Device',
  
    'Organization',
  ])
  public setWho(value: Reference): this {
    assertIsDefined<Reference>(value, \`Signature.who is required\`);
    // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
    this.who = value;
    return this;
  }

  /**
   * @returns \`true\` if the \`who\` property exists and has a value; \`false\` otherwise
   */
  public hasWho(): boolean {
    return isDefined<Reference>(this.who) && !this.who.isEmpty();
  }

  /**
   * @returns the \`onBehalfOf\` property value as a Reference object; else an empty Reference object
   */
  public getOnBehalfOf(): Reference {
    return this.onBehalfOf ?? new Reference();
  }

  /**
   * Assigns the provided OnBehalfOf object value to the \`onBehalfOf\` property.
   *
   * @decorator \`@ReferenceTargets('Signature.onBehalfOf', ['Practitioner','PractitionerRole','RelatedPerson','Patient','Device','Organization',])\`
   *
   * @param value - the \`onBehalfOf\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('Signature.onBehalfOf', [
    'Practitioner',
  
    'PractitionerRole',
  
    'RelatedPerson',
  
    'Patient',
  
    'Device',
  
    'Organization',
  ])
  public setOnBehalfOf(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.onBehalfOf = value;
    } else {
      this.onBehalfOf = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`onBehalfOf\` property exists and has a value; \`false\` otherwise
   */
  public hasOnBehalfOf(): boolean {
    return isDefined<Reference>(this.onBehalfOf) && !this.onBehalfOf.isEmpty();
  }

  /**
   * @returns the \`targetFormat\` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getTargetFormatElement(): CodeType {
    return this.targetFormat ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`targetFormat\` property.
   *
   * @param element - the \`targetFormat\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTargetFormatElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Signature.targetFormat; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.targetFormat = element;
    } else {
      this.targetFormat = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`targetFormat\` property exists and has a value; \`false\` otherwise
   */
  public hasTargetFormatElement(): boolean {
    return isDefined<CodeType>(this.targetFormat) && !this.targetFormat.isEmpty();
  }

  /**
   * @returns the \`targetFormat\` property value as a fhirCode if defined; else undefined
   */
  public getTargetFormat(): fhirCode | undefined {
    return this.targetFormat?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`targetFormat\` property.
   *
   * @param value - the \`targetFormat\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTargetFormat(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Signature.targetFormat (\${String(value)})\`;
      this.targetFormat = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.targetFormat = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`targetFormat\` property exists and has a value; \`false\` otherwise
   */
  public hasTargetFormat(): boolean {
    return this.hasTargetFormatElement();
  }

  /**
   * @returns the \`sigFormat\` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getSigFormatElement(): CodeType {
    return this.sigFormat ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`sigFormat\` property.
   *
   * @param element - the \`sigFormat\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSigFormatElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Signature.sigFormat; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.sigFormat = element;
    } else {
      this.sigFormat = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`sigFormat\` property exists and has a value; \`false\` otherwise
   */
  public hasSigFormatElement(): boolean {
    return isDefined<CodeType>(this.sigFormat) && !this.sigFormat.isEmpty();
  }

  /**
   * @returns the \`sigFormat\` property value as a fhirCode if defined; else undefined
   */
  public getSigFormat(): fhirCode | undefined {
    return this.sigFormat?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`sigFormat\` property.
   *
   * @param value - the \`sigFormat\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSigFormat(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Signature.sigFormat (\${String(value)})\`;
      this.sigFormat = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.sigFormat = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`sigFormat\` property exists and has a value; \`false\` otherwise
   */
  public hasSigFormat(): boolean {
    return this.hasSigFormatElement();
  }

  /**
   * @returns the \`data\` property value as a Base64BinaryType object if defined; else an empty Base64BinaryType object
   */
  public getDataElement(): Base64BinaryType {
    return this.data ?? new Base64BinaryType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`data\` property.
   *
   * @param element - the \`data\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDataElement(element: Base64BinaryType | undefined): this {
    if (isDefined<Base64BinaryType>(element)) {
      const optErrMsg = \`Invalid Signature.data; Provided element is not an instance of Base64BinaryType.\`;
      assertFhirType<Base64BinaryType>(element, Base64BinaryType, optErrMsg);
      this.data = element;
    } else {
      this.data = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`data\` property exists and has a value; \`false\` otherwise
   */
  public hasDataElement(): boolean {
    return isDefined<Base64BinaryType>(this.data) && !this.data.isEmpty();
  }

  /**
   * @returns the \`data\` property value as a fhirBase64Binary if defined; else undefined
   */
  public getData(): fhirBase64Binary | undefined {
    return this.data?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`data\` property.
   *
   * @param value - the \`data\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setData(value: fhirBase64Binary | undefined): this {
    if (isDefined<fhirBase64Binary>(value)) {
      const optErrMsg = \`Invalid Signature.data (\${String(value)})\`;
      this.data = new Base64BinaryType(parseFhirPrimitiveData(value, fhirBase64BinarySchema, optErrMsg));
    } else {
      this.data = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`data\` property exists and has a value; \`false\` otherwise
   */
  public hasData(): boolean {
    return this.hasDataElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Signature';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.type_,
      this.when,
      this.who,
      this.onBehalfOf,
      this.targetFormat,
      this.sigFormat,
      this.data,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Signature {
    const dest = new Signature();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Signature): void {
    super.copyValues(dest);
    const typeList = copyListValues<Coding>(this.type_);
    dest.type_ = typeList.length === 0 ? null : typeList;
    dest.when = this.when ? this.when.copy() : null;
    dest.who = this.who ? this.who.copy() : null;
    dest.onBehalfOf = this.onBehalfOf?.copy();
    dest.targetFormat = this.targetFormat?.copy();
    dest.sigFormat = this.sigFormat?.copy();
    dest.data = this.data?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', \`UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasType()) {
      setFhirComplexListJson(this.getType(), 'type', jsonObj);
    } else {
      missingReqdProperties.push(\`Signature.type\`);
    }

    if (this.hasWhenElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirInstant>(this.getWhenElement()!, 'when', jsonObj);
    } else {
      missingReqdProperties.push(\`Signature.when\`);
    }

    if (this.hasWho()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirComplexJson(this.getWho()!, 'who', jsonObj);
    } else {
      missingReqdProperties.push(\`Signature.who\`);
    }

    if (this.hasOnBehalfOf()) {
      setFhirComplexJson(this.getOnBehalfOf(), 'onBehalfOf', jsonObj);
    }

    if (this.hasTargetFormatElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getTargetFormatElement(), 'targetFormat', jsonObj);
    }

    if (this.hasSigFormatElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getSigFormatElement(), 'sigFormat', jsonObj);
    }

    if (this.hasDataElement()) {
      setFhirPrimitiveJson<fhirBase64Binary>(this.getDataElement(), 'data', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

/**
 * Timing Class
 *
 * @remarks
 * Base StructureDefinition for Timing Type: Specifies an event that may occur multiple times. Timing schedules are used to record when things are planned, expected or requested to occur. The most common usage is in dosage instructions for medications. They are also used when planning care of various kinds, and may be used for reporting the schedule to which past regular activities were carried out.
 *
 * Need to able to track proposed timing schedules. There are several different ways to do this: one or more specified times, a simple rules like three times a day, or  before/after meals.
 *
 * **FHIR Specification**
 * - **Short:** A timing schedule that specifies an event that may occur multiple times
 * - **Definition:** Specifies an event that may occur multiple times. Timing schedules are used to record when things are planned, expected or requested to occur. The most common usage is in dosage instructions for medications. They are also used when planning care of various kinds, and may be used for reporting the schedule to which past regular activities were carried out.
 * - **Comment:** Describes the occurrence of an event that may occur multiple times. Timing schedules are used for specifying when events are expected or requested to occur, and may also be used to represent the summary of a past or ongoing event.  For simplicity, the definitions of Timing components are expressed as \\'future\\' events, but such components can also be used to describe historic or ongoing events. A Timing schedule can be a list of events and/or criteria for when the event happens, which can be expressed in a structured form and/or as a code. When both event and a repeating specification are provided, the list of events should be understood as an interpretation of the information in the repeat structure.
 * - **FHIR Version:** 4.0.1
 *
 * @category Data Models: ComplexType
 * @see [FHIR Timing](http://hl7.org/fhir/StructureDefinition/Timing)
 */
export class Timing extends BackboneType implements IBackboneType {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`Timing\` JSON to instantiate the Timing data model.
   *
   * @param sourceJson - JSON representing FHIR \`Timing\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Timing
   * @returns Timing data model or undefined for \`Timing\`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Timing | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Timing';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Timing();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneTypeJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    

    fieldName = 'event';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: DateTimeType | undefined = fhirParser.parseDateTimeType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addEventElement(datatype);
        }
      });
    }

    fieldName = 'repeat';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: TimingRepeatComponent | undefined = TimingRepeatComponent.parse(classJsonObj[fieldName]!, sourceField);
      instance.setRepeat(datatype);
    }

    fieldName = 'code';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = CodeableConcept.parse(classJsonObj[fieldName]!, sourceField);
      instance.setCode(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Timing.event Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** When the event occurs
   * - **Definition:** Identifies specific times when the event occurs.
   * - **Requirements:** In a Medication Administration Record, for instance, you need to take a general specification, and turn it into a precise specification.
   * - **FHIR Type:** \`dateTime\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private event?: DateTimeType[] | undefined;

  /**
   * Timing.repeat Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** When the event is to occur
   * - **Definition:** A set of rules that describe when the event is scheduled.
   * - **Requirements:** Many timing schedules are determined by regular repetitions.
   * - **FHIR Type:** \`Element\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private repeat?: TimingRepeatComponent | undefined;

  /**
   * Timing.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** BID | TID | QID | AM | PM | QD | QOD | +
   * - **Definition:** A code for the timing schedule (or just text in code.text). Some codes such as BID are ubiquitous, but many institutions define their own additional codes. If a code is provided, the code is understood to be a complete statement of whatever is specified in the structured timing data, and either the code or the data may be used to interpret the Timing, with the exception that .repeat.bounds still applies over the code (and is not contained in the code).
   * - **Comment:** BID etc. are defined as \\'at institutionally specified times\\'. For example, an institution may choose that BID is "always at 7am and 6pm".  If it is inappropriate for this choice to be made, the code BID should not be used. Instead, a distinct organization-specific code should be used in place of the HL7-defined BID code and/or a structured representation should be used (in this case, specifying the two event times).
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code?: CodeableConcept | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`event\` property value as a DateTimeType array
   */
  public getEventElement(): DateTimeType[] {
    return this.event ?? ([] as DateTimeType[]);
  }

  /**
   * Assigns the provided DateTimeType array value to the \`event\` property.
   *
   * @param element - the \`event\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setEventElement(element: DateTimeType[] | undefined): this {
    if (isDefinedList<DateTimeType>(element)) {
      const optErrMsg = \`Invalid Timing.event; Provided value array has an element that is not an instance of DateTimeType.\`;
      assertFhirTypeList<DateTimeType>(element, DateTimeType, optErrMsg);
      this.event = element;
    } else {
      this.event = undefined;
    }
    return this;
  }

  /**
   * Add the provided DateTimeType value to the \`event\` array property.
   *
   * @param element - the \`event\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addEventElement(element: DateTimeType | undefined): this {
    if (isDefined<DateTimeType>(element)) {
      const optErrMsg = \`Invalid Timing.event; Provided element is not an instance of DateTimeType.\`;
      assertFhirType<DateTimeType>(element, DateTimeType, optErrMsg);
      this.initEvent();
      this.event?.push(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`event\` property exists and has a value; \`false\` otherwise
   */
  public hasEventElement(): boolean {
    return isDefinedList<DateTimeType>(this.event) && this.event.some((item: DateTimeType) => !item.isEmpty());
  }

  /**
   * @returns the \`event\` property value as a fhirDateTime array
   */
  public getEvent(): fhirDateTime[] {
    this.initEvent();
    const eventValues = [] as fhirDateTime[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.event!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        eventValues.push(value);
      }
    }
    return eventValues;
  }

  /**
   * Assigns the provided primitive value array to the \`event\` property.
   *
   * @param value - the \`event\` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setEvent(value: fhirDateTime[] | undefined): this {
    if (isDefinedList<fhirDateTime>(value)) {
      const eventElements = [] as DateTimeType[];
      for (const eventValue of value) {
        const optErrMsg = \`Invalid Timing.event array item (\${String(eventValue)})\`;
        const element = new DateTimeType(parseFhirPrimitiveData(eventValue, fhirDateTimeSchema, optErrMsg));
        eventElements.push(element);
      }
      this.event = eventElements;
    } else {
      this.event = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`event\` array property.
   *
   * @param value - the \`event\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addEvent(value: fhirDateTime | undefined): this {
    if (isDefined<fhirDateTime>(value)) {
      const optErrMsg = \`Invalid Timing.event array item (\${String(value)})\`;
      const element = new DateTimeType(parseFhirPrimitiveData(value, fhirDateTimeSchema, optErrMsg));
      this.initEvent();
      this.addEventElement(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`event\` property exists and has a value; \`false\` otherwise
   */
  public hasEvent(): boolean {
    return this.hasEventElement();
  }

  /**
   * Initialize the \`event\` property
   */
  private initEvent(): void {
    if (!this.hasEvent()) {
      this.event = [] as DateTimeType[];
    }
  }

  /**
   * @returns the \`repeat\` property value as a TimingRepeatComponent object if defined; else an empty TimingRepeatComponent object
   */
  public getRepeat(): TimingRepeatComponent {
    return this.repeat ?? new TimingRepeatComponent();
  }

  /**
   * Assigns the provided Repeat object value to the \`repeat\` property.
   *
   * @param value - the \`repeat\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setRepeat(value: TimingRepeatComponent | undefined): this {
    if (isDefined<TimingRepeatComponent>(value)) {
      const optErrMsg = \`Invalid Timing.repeat; Provided element is not an instance of TimingRepeatComponent.\`;
      assertFhirType<TimingRepeatComponent>(value, TimingRepeatComponent, optErrMsg);
      this.repeat = value;
    } else {
      this.repeat = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`repeat\` property exists and has a value; \`false\` otherwise
   */
  public hasRepeat(): boolean {
    return isDefined<TimingRepeatComponent>(this.repeat) && !this.repeat.isEmpty();
  }

  /**
   * @returns the \`code\` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getCode(): CodeableConcept {
    return this.code ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Code object value to the \`code\` property.
   *
   * @param value - the \`code\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setCode(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Timing.code; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.code = value;
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`code\` property exists and has a value; \`false\` otherwise
   */
  public hasCode(): boolean {
    return isDefined<CodeableConcept>(this.code) && !this.code.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Timing';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.event,
      this.repeat,
      this.code,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Timing {
    const dest = new Timing();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Timing): void {
    super.copyValues(dest);
    const eventList = copyListValues<DateTimeType>(this.event);
    dest.event = eventList.length === 0 ? undefined : eventList;
    dest.repeat = this.repeat?.copy();
    dest.code = this.code?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', \`UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasEvent()) {
      setFhirPrimitiveListJson(this.getEventElement(), 'event', jsonObj);
    }

    if (this.hasRepeat()) {
      setFhirComplexJson(this.getRepeat(), 'repeat', jsonObj);
    }

    if (this.hasCode()) {
      setFhirComplexJson(this.getCode(), 'code', jsonObj);
    }

    return jsonObj;
  }
}
/**
 * TimingRepeatComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** When the event is to occur
 * - **Definition:** A set of rules that describe when the event is scheduled.
 * - **Requirements:** Many timing schedules are determined by regular repetitions.
 *
 * @category Data Models: ComplexType
 * @see [FHIR Timing](http://hl7.org/fhir/StructureDefinition/Timing)
 */
export class TimingRepeatComponent extends DataType implements IDataType {
  constructor() {
    super();

    this.daysOfWeekEnum = new DaysOfWeekEnum();
  }

  /**
   * Parse the provided \`TimingRepeatComponent\` JSON to instantiate the TimingRepeatComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`TimingRepeatComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to TimingRepeatComponent
   * @returns TimingRepeatComponent data model or undefined for \`TimingRepeatComponent\`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): TimingRepeatComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'TimingRepeatComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new TimingRepeatComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const classMetadata: DecoratorMetadataObject | null = TimingRepeatComponent[Symbol.metadata];
    const errorMessage = \`DecoratorMetadataObject does not exist for TimingRepeatComponent\`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    fieldName = 'bounds[x]';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const bounds: IDataType | undefined = fhirParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setBounds(bounds);

    fieldName = 'count';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = fhirParser.parsePositiveIntType(dtJson, dtSiblingJson);
      instance.setCountElement(datatype);
    }

    fieldName = 'countMax';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = fhirParser.parsePositiveIntType(dtJson, dtSiblingJson);
      instance.setCountMaxElement(datatype);
    }

    fieldName = 'duration';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setDurationElement(datatype);
    }

    fieldName = 'durationMax';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setDurationMaxElement(datatype);
    }

    fieldName = 'durationUnit';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setDurationUnitElement(datatype);
    }

    fieldName = 'frequency';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = fhirParser.parsePositiveIntType(dtJson, dtSiblingJson);
      instance.setFrequencyElement(datatype);
    }

    fieldName = 'frequencyMax';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = fhirParser.parsePositiveIntType(dtJson, dtSiblingJson);
      instance.setFrequencyMaxElement(datatype);
    }

    fieldName = 'period';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setPeriodElement(datatype);
    }

    fieldName = 'periodMax';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setPeriodMaxElement(datatype);
    }

    fieldName = 'periodUnit';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setPeriodUnitElement(datatype);
    }

    fieldName = 'dayOfWeek';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: CodeType | undefined = fhirParser.parseCodeType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addDayOfWeekElement(datatype);
        }
      });
    }

    fieldName = 'timeOfDay';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: TimeType | undefined = fhirParser.parseTimeType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addTimeOfDayElement(datatype);
        }
      });
    }

    fieldName = 'when';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: CodeType | undefined = fhirParser.parseCodeType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addWhenElement(datatype);
        }
      });
    }

    fieldName = 'offset';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UnsignedIntType | undefined = fhirParser.parseUnsignedIntType(dtJson, dtSiblingJson);
      instance.setOffsetElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Timing.repeat.bounds[x] Element
   *
   * @decorator \`@ChoiceDataTypesMeta('Timing.repeat.bounds[x]', ['Duration','Range','Period',]\`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Length/Range of lengths, or (Start and/or end) limits
   * - **Definition:** Either a duration for the length of the timing schedule, a range of possible length, or outer bounds for start and/or end limits of the timing schedule.
   * - **FHIR Types:**
   *     'Duration',
   *     'Range',
   *     'Period',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('Timing.repeat.bounds[x]',[
    'Duration',
    'Range',
    'Period',
  ])
  private bounds?: IDataType | undefined;

  /**
   * Timing.repeat.count Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Number of times to repeat
   * - **Definition:** A total count of the desired number of repetitions across the duration of the entire timing specification. If countMax is present, this element indicates the lower bound of the allowed range of count values.
   * - **Comment:** If you have both bounds and count, then this should be understood as within the bounds period, until count times happens.
   * - **Requirements:** Repetitions may be limited by end time or total occurrences.
   * - **FHIR Type:** \`positiveInt\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private count?: PositiveIntType | undefined;

  /**
   * Timing.repeat.countMax Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Maximum number of times to repeat
   * - **Definition:** If present, indicates that the count is a range - so to perform the action between [count] and [countMax] times.
   * - **FHIR Type:** \`positiveInt\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private countMax?: PositiveIntType | undefined;

  /**
   * Timing.repeat.duration Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** How long when it happens
   * - **Definition:** How long this thing happens for when it happens. If durationMax is present, this element indicates the lower bound of the allowed range of the duration.
   * - **Comment:** For some events the duration is part of the definition of the event (e.g. IV infusions, where the duration is implicit in the specified quantity and rate). For others, it\\'s part of the timing specification (e.g. exercise).
   * - **Requirements:** Some activities are not instantaneous and need to be maintained for a period of time.
   * - **FHIR Type:** \`decimal\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private duration?: DecimalType | undefined;

  /**
   * Timing.repeat.durationMax Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** How long when it happens (Max)
   * - **Definition:** If present, indicates that the duration is a range - so to perform the action between [duration] and [durationMax] time length.
   * - **Comment:** For some events the duration is part of the definition of the event (e.g. IV infusions, where the duration is implicit in the specified quantity and rate). For others, it\\'s part of the timing specification (e.g. exercise).
   * - **Requirements:** Some activities are not instantaneous and need to be maintained for a period of time.
   * - **FHIR Type:** \`decimal\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private durationMax?: DecimalType | undefined;

  /**
   * Timing.repeat.durationUnit Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** s | min | h | d | wk | mo | a - unit of time (UCUM)
   * - **Definition:** The units of time for the duration, in UCUM units.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private durationUnit?: CodeType | undefined;

  /**
   * Timing.repeat.frequency Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Event occurs frequency times per period
   * - **Definition:** The number of times to repeat the action within the specified period. If frequencyMax is present, this element indicates the lower bound of the allowed range of the frequency.
   * - **FHIR Type:** \`positiveInt\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private frequency?: PositiveIntType | undefined;

  /**
   * Timing.repeat.frequencyMax Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Event occurs up to frequencyMax times per period
   * - **Definition:** If present, indicates that the frequency is a range - so to repeat between [frequency] and [frequencyMax] times within the period or period range.
   * - **FHIR Type:** \`positiveInt\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private frequencyMax?: PositiveIntType | undefined;

  /**
   * Timing.repeat.period Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Event occurs frequency times per period
   * - **Definition:** Indicates the duration of time over which repetitions are to occur; e.g. to express "3 times per day", 3 would be the frequency and "1 day" would be the period. If periodMax is present, this element indicates the lower bound of the allowed range of the period length.
   * - **FHIR Type:** \`decimal\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private period?: DecimalType | undefined;

  /**
   * Timing.repeat.periodMax Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Upper limit of period (3-4 hours)
   * - **Definition:** If present, indicates that the period is a range from [period] to [periodMax], allowing expressing concepts such as "do this once every 3-5 days.
   * - **FHIR Type:** \`decimal\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private periodMax?: DecimalType | undefined;

  /**
   * Timing.repeat.periodUnit Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** s | min | h | d | wk | mo | a - unit of time (UCUM)
   * - **Definition:** The units of time for the period in UCUM units.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private periodUnit?: CodeType | undefined;

  /**
   * FHIR CodeSystem: DaysOfWeek
   *
   * @see {@link DaysOfWeekEnum }
   */
  private readonly daysOfWeekEnum: DaysOfWeekEnum;

  /**
   * Timing.repeat.dayOfWeek Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** mon | tue | wed | thu | fri | sat | sun
   * - **Definition:** If one or more days of week is provided, then the action happens only on the specified day(s).
   * - **Comment:** If no days are specified, the action is assumed to happen every day as otherwise specified. The elements frequency and period cannot be used as well as dayOfWeek.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  private dayOfWeek?: EnumCodeType[] | undefined;

  /**
   * Timing.repeat.timeOfDay Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Time of day for action
   * - **Definition:** Specified time of day for action to take place.
   * - **Comment:** When time of day is specified, it is inferred that the action happens every day (as filtered by dayofWeek) on the specified times. The elements when, frequency and period cannot be used as well as timeOfDay.
   * - **FHIR Type:** \`time\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private timeOfDay?: TimeType[] | undefined;

  /**
   * Timing.repeat.when Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Code for time period of occurrence
   * - **Definition:** An approximate time period during the day, potentially linked to an event of daily living that indicates when the action should occur.
   * - **Comment:** When more than one event is listed, the event is tied to the union of the specified events.
   * - **Requirements:** Timings are frequently determined by occurrences such as waking, eating and sleep.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private when?: CodeType[] | undefined;

  /**
   * Timing.repeat.offset Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Minutes from event (before or after)
   * - **Definition:** The number of minutes from the event. If the event code does not indicate whether the minutes is before or after the event, then the offset is assumed to be after the event.
   * - **FHIR Type:** \`unsignedInt\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private offset?: UnsignedIntType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`bounds\` property value as a DataType object if defined; else undefined
   */
  public getBounds(): IDataType | undefined {
    return this.bounds;
  }

  /**
   * Assigns the provided DataType object value to the \`bounds\` property.
   *
   * @decorator \`@ChoiceDataTypes('Timing.repeat.bounds[x]')\`
   *
   * @param value - the \`bounds\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  @ChoiceDataTypes('Timing.repeat.bounds[x]')
  public setBounds(value: IDataType | undefined): this {
    if (isDefined<IDataType>(value)) {
      // assertFhirType<IDataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.bounds = value;
    } else {
      this.bounds = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`bounds\` property exists and has a value; \`false\` otherwise
   */
  public hasBounds(): boolean {
    return isDefined<IDataType>(this.bounds) && !this.bounds.isEmpty();
  }

  // *** NOTE ***
  // Following choice datatype-specific "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the \`bounds\` property value as a Duration object if defined; else undefined
   */
  public getBoundsDuration(): Duration | undefined {
    if (!isDefined<IDataType | undefined>(this.bounds)) {
      return undefined;
    }
    if (!(this.bounds instanceof Duration)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Timing.repeat.bounds[x]: Expected Duration but encountered \${this.bounds.fhirType()}\`,
      );
    }
    return this.bounds;
  }

  /**
   * @returns \`true\` if the \`bounds\` property exists as a Duration and has a value; \`false\` otherwise
   */
  public hasBoundsDuration(): boolean {
    return this.hasBounds() && this.bounds instanceof Duration;
  }

  /**
   * @returns the \`bounds\` property value as a Range object if defined; else undefined
   */
  public getBoundsRange(): Range | undefined {
    if (!isDefined<IDataType | undefined>(this.bounds)) {
      return undefined;
    }
    if (!(this.bounds instanceof Range)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Timing.repeat.bounds[x]: Expected Range but encountered \${this.bounds.fhirType()}\`,
      );
    }
    return this.bounds;
  }

  /**
   * @returns \`true\` if the \`bounds\` property exists as a Range and has a value; \`false\` otherwise
   */
  public hasBoundsRange(): boolean {
    return this.hasBounds() && this.bounds instanceof Range;
  }

  /**
   * @returns the \`bounds\` property value as a Period object if defined; else undefined
   */
  public getBoundsPeriod(): Period | undefined {
    if (!isDefined<IDataType | undefined>(this.bounds)) {
      return undefined;
    }
    if (!(this.bounds instanceof Period)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Timing.repeat.bounds[x]: Expected Period but encountered \${this.bounds.fhirType()}\`,
      );
    }
    return this.bounds;
  }

  /**
   * @returns \`true\` if the \`bounds\` property exists as a Period and has a value; \`false\` otherwise
   */
  public hasBoundsPeriod(): boolean {
    return this.hasBounds() && this.bounds instanceof Period;
  }

  // End of choice datatype-specific "get"/"has" methods

  /**
   * @returns the \`count\` property value as a PositiveIntType object if defined; else an empty PositiveIntType object
   */
  public getCountElement(): PositiveIntType {
    return this.count ?? new PositiveIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`count\` property.
   *
   * @param element - the \`count\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCountElement(element: PositiveIntType | undefined): this {
    if (isDefined<PositiveIntType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.count; Provided element is not an instance of PositiveIntType.\`;
      assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
      this.count = element;
    } else {
      this.count = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`count\` property exists and has a value; \`false\` otherwise
   */
  public hasCountElement(): boolean {
    return isDefined<PositiveIntType>(this.count) && !this.count.isEmpty();
  }

  /**
   * @returns the \`count\` property value as a fhirPositiveInt if defined; else undefined
   */
  public getCount(): fhirPositiveInt | undefined {
    return this.count?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`count\` property.
   *
   * @param value - the \`count\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCount(value: fhirPositiveInt | undefined): this {
    if (isDefined<fhirPositiveInt>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.count (\${String(value)})\`;
      this.count = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    } else {
      this.count = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`count\` property exists and has a value; \`false\` otherwise
   */
  public hasCount(): boolean {
    return this.hasCountElement();
  }

  /**
   * @returns the \`countMax\` property value as a PositiveIntType object if defined; else an empty PositiveIntType object
   */
  public getCountMaxElement(): PositiveIntType {
    return this.countMax ?? new PositiveIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`countMax\` property.
   *
   * @param element - the \`countMax\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCountMaxElement(element: PositiveIntType | undefined): this {
    if (isDefined<PositiveIntType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.countMax; Provided element is not an instance of PositiveIntType.\`;
      assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
      this.countMax = element;
    } else {
      this.countMax = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`countMax\` property exists and has a value; \`false\` otherwise
   */
  public hasCountMaxElement(): boolean {
    return isDefined<PositiveIntType>(this.countMax) && !this.countMax.isEmpty();
  }

  /**
   * @returns the \`countMax\` property value as a fhirPositiveInt if defined; else undefined
   */
  public getCountMax(): fhirPositiveInt | undefined {
    return this.countMax?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`countMax\` property.
   *
   * @param value - the \`countMax\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCountMax(value: fhirPositiveInt | undefined): this {
    if (isDefined<fhirPositiveInt>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.countMax (\${String(value)})\`;
      this.countMax = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    } else {
      this.countMax = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`countMax\` property exists and has a value; \`false\` otherwise
   */
  public hasCountMax(): boolean {
    return this.hasCountMaxElement();
  }

  /**
   * @returns the \`duration\` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getDurationElement(): DecimalType {
    return this.duration ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`duration\` property.
   *
   * @param element - the \`duration\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDurationElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.duration; Provided element is not an instance of DecimalType.\`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.duration = element;
    } else {
      this.duration = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`duration\` property exists and has a value; \`false\` otherwise
   */
  public hasDurationElement(): boolean {
    return isDefined<DecimalType>(this.duration) && !this.duration.isEmpty();
  }

  /**
   * @returns the \`duration\` property value as a fhirDecimal if defined; else undefined
   */
  public getDuration(): fhirDecimal | undefined {
    return this.duration?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`duration\` property.
   *
   * @param value - the \`duration\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDuration(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.duration (\${String(value)})\`;
      this.duration = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.duration = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`duration\` property exists and has a value; \`false\` otherwise
   */
  public hasDuration(): boolean {
    return this.hasDurationElement();
  }

  /**
   * @returns the \`durationMax\` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getDurationMaxElement(): DecimalType {
    return this.durationMax ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`durationMax\` property.
   *
   * @param element - the \`durationMax\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDurationMaxElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.durationMax; Provided element is not an instance of DecimalType.\`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.durationMax = element;
    } else {
      this.durationMax = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`durationMax\` property exists and has a value; \`false\` otherwise
   */
  public hasDurationMaxElement(): boolean {
    return isDefined<DecimalType>(this.durationMax) && !this.durationMax.isEmpty();
  }

  /**
   * @returns the \`durationMax\` property value as a fhirDecimal if defined; else undefined
   */
  public getDurationMax(): fhirDecimal | undefined {
    return this.durationMax?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`durationMax\` property.
   *
   * @param value - the \`durationMax\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDurationMax(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.durationMax (\${String(value)})\`;
      this.durationMax = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.durationMax = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`durationMax\` property exists and has a value; \`false\` otherwise
   */
  public hasDurationMax(): boolean {
    return this.hasDurationMaxElement();
  }

  /**
   * @returns the \`durationUnit\` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getDurationUnitElement(): CodeType {
    return this.durationUnit ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`durationUnit\` property.
   *
   * @param element - the \`durationUnit\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDurationUnitElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.durationUnit; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.durationUnit = element;
    } else {
      this.durationUnit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`durationUnit\` property exists and has a value; \`false\` otherwise
   */
  public hasDurationUnitElement(): boolean {
    return isDefined<CodeType>(this.durationUnit) && !this.durationUnit.isEmpty();
  }

  /**
   * @returns the \`durationUnit\` property value as a fhirCode if defined; else undefined
   */
  public getDurationUnit(): fhirCode | undefined {
    return this.durationUnit?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`durationUnit\` property.
   *
   * @param value - the \`durationUnit\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDurationUnit(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.durationUnit (\${String(value)})\`;
      this.durationUnit = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.durationUnit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`durationUnit\` property exists and has a value; \`false\` otherwise
   */
  public hasDurationUnit(): boolean {
    return this.hasDurationUnitElement();
  }

  /**
   * @returns the \`frequency\` property value as a PositiveIntType object if defined; else an empty PositiveIntType object
   */
  public getFrequencyElement(): PositiveIntType {
    return this.frequency ?? new PositiveIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`frequency\` property.
   *
   * @param element - the \`frequency\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setFrequencyElement(element: PositiveIntType | undefined): this {
    if (isDefined<PositiveIntType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.frequency; Provided element is not an instance of PositiveIntType.\`;
      assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
      this.frequency = element;
    } else {
      this.frequency = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`frequency\` property exists and has a value; \`false\` otherwise
   */
  public hasFrequencyElement(): boolean {
    return isDefined<PositiveIntType>(this.frequency) && !this.frequency.isEmpty();
  }

  /**
   * @returns the \`frequency\` property value as a fhirPositiveInt if defined; else undefined
   */
  public getFrequency(): fhirPositiveInt | undefined {
    return this.frequency?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`frequency\` property.
   *
   * @param value - the \`frequency\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setFrequency(value: fhirPositiveInt | undefined): this {
    if (isDefined<fhirPositiveInt>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.frequency (\${String(value)})\`;
      this.frequency = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    } else {
      this.frequency = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`frequency\` property exists and has a value; \`false\` otherwise
   */
  public hasFrequency(): boolean {
    return this.hasFrequencyElement();
  }

  /**
   * @returns the \`frequencyMax\` property value as a PositiveIntType object if defined; else an empty PositiveIntType object
   */
  public getFrequencyMaxElement(): PositiveIntType {
    return this.frequencyMax ?? new PositiveIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`frequencyMax\` property.
   *
   * @param element - the \`frequencyMax\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setFrequencyMaxElement(element: PositiveIntType | undefined): this {
    if (isDefined<PositiveIntType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.frequencyMax; Provided element is not an instance of PositiveIntType.\`;
      assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
      this.frequencyMax = element;
    } else {
      this.frequencyMax = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`frequencyMax\` property exists and has a value; \`false\` otherwise
   */
  public hasFrequencyMaxElement(): boolean {
    return isDefined<PositiveIntType>(this.frequencyMax) && !this.frequencyMax.isEmpty();
  }

  /**
   * @returns the \`frequencyMax\` property value as a fhirPositiveInt if defined; else undefined
   */
  public getFrequencyMax(): fhirPositiveInt | undefined {
    return this.frequencyMax?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`frequencyMax\` property.
   *
   * @param value - the \`frequencyMax\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setFrequencyMax(value: fhirPositiveInt | undefined): this {
    if (isDefined<fhirPositiveInt>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.frequencyMax (\${String(value)})\`;
      this.frequencyMax = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    } else {
      this.frequencyMax = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`frequencyMax\` property exists and has a value; \`false\` otherwise
   */
  public hasFrequencyMax(): boolean {
    return this.hasFrequencyMaxElement();
  }

  /**
   * @returns the \`period\` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getPeriodElement(): DecimalType {
    return this.period ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`period\` property.
   *
   * @param element - the \`period\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPeriodElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.period; Provided element is not an instance of DecimalType.\`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.period = element;
    } else {
      this.period = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`period\` property exists and has a value; \`false\` otherwise
   */
  public hasPeriodElement(): boolean {
    return isDefined<DecimalType>(this.period) && !this.period.isEmpty();
  }

  /**
   * @returns the \`period\` property value as a fhirDecimal if defined; else undefined
   */
  public getPeriod(): fhirDecimal | undefined {
    return this.period?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`period\` property.
   *
   * @param value - the \`period\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPeriod(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.period (\${String(value)})\`;
      this.period = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.period = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`period\` property exists and has a value; \`false\` otherwise
   */
  public hasPeriod(): boolean {
    return this.hasPeriodElement();
  }

  /**
   * @returns the \`periodMax\` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getPeriodMaxElement(): DecimalType {
    return this.periodMax ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`periodMax\` property.
   *
   * @param element - the \`periodMax\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPeriodMaxElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.periodMax; Provided element is not an instance of DecimalType.\`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.periodMax = element;
    } else {
      this.periodMax = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`periodMax\` property exists and has a value; \`false\` otherwise
   */
  public hasPeriodMaxElement(): boolean {
    return isDefined<DecimalType>(this.periodMax) && !this.periodMax.isEmpty();
  }

  /**
   * @returns the \`periodMax\` property value as a fhirDecimal if defined; else undefined
   */
  public getPeriodMax(): fhirDecimal | undefined {
    return this.periodMax?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`periodMax\` property.
   *
   * @param value - the \`periodMax\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPeriodMax(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.periodMax (\${String(value)})\`;
      this.periodMax = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.periodMax = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`periodMax\` property exists and has a value; \`false\` otherwise
   */
  public hasPeriodMax(): boolean {
    return this.hasPeriodMaxElement();
  }

  /**
   * @returns the \`periodUnit\` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getPeriodUnitElement(): CodeType {
    return this.periodUnit ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`periodUnit\` property.
   *
   * @param element - the \`periodUnit\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPeriodUnitElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.periodUnit; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.periodUnit = element;
    } else {
      this.periodUnit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`periodUnit\` property exists and has a value; \`false\` otherwise
   */
  public hasPeriodUnitElement(): boolean {
    return isDefined<CodeType>(this.periodUnit) && !this.periodUnit.isEmpty();
  }

  /**
   * @returns the \`periodUnit\` property value as a fhirCode if defined; else undefined
   */
  public getPeriodUnit(): fhirCode | undefined {
    return this.periodUnit?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`periodUnit\` property.
   *
   * @param value - the \`periodUnit\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPeriodUnit(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.periodUnit (\${String(value)})\`;
      this.periodUnit = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.periodUnit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`periodUnit\` property exists and has a value; \`false\` otherwise
   */
  public hasPeriodUnit(): boolean {
    return this.hasPeriodUnitElement();
  }

  /**
   * @returns the \`dayOfWeek\` property value as a EnumCodeType array
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public getDayOfWeekEnumType(): EnumCodeType[] {
    return this.dayOfWeek ?? ([] as EnumCodeType[]);
  }

  /**
   * Assigns the provided EnumCodeType array value to the \`dayOfWeek\` property.
   *
   * @param enumType - the \`dayOfWeek\` array value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public setDayOfWeekEnumType(enumType: EnumCodeType[] | undefined): this {
    if (isDefinedList<EnumCodeType>(enumType)) {
      const errMsgPrefix = \`Invalid Timing.repeat.dayOfWeek\`;
      assertEnumCodeTypeList<DaysOfWeekEnum>(enumType, DaysOfWeekEnum, errMsgPrefix);
      this.dayOfWeek = enumType;
    } else {
      this.dayOfWeek = undefined;
    }
    return this;
  }

  /**
   * Add the provided EnumCodeType value to the \`dayOfWeek\` array property.
   *
   * @param enumType - the \`dayOfWeek\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public addDayOfWeekEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = \`Invalid Timing.repeat.dayOfWeek\`;
      assertEnumCodeType<DaysOfWeekEnum>(enumType, DaysOfWeekEnum, errMsgPrefix);
      this.initDayOfWeek();
      this.dayOfWeek?.push(enumType);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`dayOfWeek\` property exists and has a value; \`false\` otherwise
   */
  public hasDayOfWeekEnumType(): boolean {
    return isDefinedList<EnumCodeType>(this.dayOfWeek) && this.dayOfWeek.some((item: EnumCodeType) => !item.isEmpty()) && this.dayOfWeek.every((item: EnumCodeType) => item.fhirCodeEnumeration.length > 0);
  }

  /**
   * @returns the \`dayOfWeek\` property value as a CodeType array
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public getDayOfWeekElement(): CodeType[] {
    if (this.dayOfWeek === undefined) {
      return [] as CodeType[];
    }
    return this.dayOfWeek as CodeType[];
  }

  /**
   * Assigns the provided PrimitiveType array value to the \`dayOfWeek\` property.
   *
   * @param element - the \`dayOfWeek\` array value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public setDayOfWeekElement(element: CodeType[] | undefined): this {
    if (isDefinedList<CodeType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.dayOfWeek; Provided element array has an element that is not an instance of CodeType.\`;
      assertFhirTypeList<CodeType>(element, CodeType, optErrMsg);
      const enumCodeTypes = [] as EnumCodeType[];
      element.forEach((type: CodeType) => {
        enumCodeTypes.push(new EnumCodeType(type, this.daysOfWeekEnum));
      });
      this.dayOfWeek = enumCodeTypes;
    } else {
      this.dayOfWeek = undefined;
    }
    return this;
  }

  /**
   * Add the provided PrimitiveType value to the \`dayOfWeek\` array property.
   *
   * @param element - the \`dayOfWeek\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public addDayOfWeekElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.dayOfWeek; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.initDayOfWeek();
      this.dayOfWeek?.push(new EnumCodeType(element, this.daysOfWeekEnum));
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`dayOfWeek\` property exists and has a value; \`false\` otherwise
   */
  public hasDayOfWeekElement(): boolean {
    return this.hasDayOfWeekEnumType();
  }

  /**
   * @returns the \`dayOfWeek\` property value as a fhirCode array
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public getDayOfWeek(): fhirCode[] {
    if (this.dayOfWeek === undefined) {
      return [] as fhirCode[];
    }
    const values = [] as fhirCode[];
    for (const item of this.dayOfWeek) {
      values.push(item.fhirCode.code);
    }
    return values;
  }

  /**
   * Assigns the provided primitive value array to the \`dayOfWeek\` property.
   *
   * @param value - the \`dayOfWeek\` value array
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public setDayOfWeek(value: fhirCode[] | undefined): this {
    if (isDefinedList<fhirCode>(value)) {
      const enumCodeTypes = [] as EnumCodeType[];
      const optErrMsg = \`Invalid Timing.repeat.dayOfWeek; Provided value is not an instance of fhirCode.\`;
      value.forEach((val: fhirCode) => {
        enumCodeTypes.push(new EnumCodeType(parseFhirPrimitiveData(val, fhirCodeSchema, optErrMsg), this.daysOfWeekEnum));
      });
      this.dayOfWeek = enumCodeTypes;
    } else {
      this.dayOfWeek = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`dayOfWeek\` array property.
   *
   * @param value - the \`dayOfWeek\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public addDayOfWeek(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      this.initDayOfWeek();
      const optErrMsg = \`Invalid Timing.repeat.dayOfWeek; Provided value is not an instance of fhirCode.\`;
      this.dayOfWeek?.push(new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.daysOfWeekEnum));
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`dayOfWeek\` property exists and has a value; \`false\` otherwise
   */
  public hasDayOfWeek(): boolean {
    return this.hasDayOfWeekEnumType();
  }

  /**
   * Initialize the dayOfWeek property
   */
  private initDayOfWeek(): void {
    if(!this.hasDayOfWeekEnumType()) {
      this.dayOfWeek = [] as EnumCodeType[];
    }
  }

  /**
   * @returns the \`timeOfDay\` property value as a TimeType array
   */
  public getTimeOfDayElement(): TimeType[] {
    return this.timeOfDay ?? ([] as TimeType[]);
  }

  /**
   * Assigns the provided TimeType array value to the \`timeOfDay\` property.
   *
   * @param element - the \`timeOfDay\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTimeOfDayElement(element: TimeType[] | undefined): this {
    if (isDefinedList<TimeType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.timeOfDay; Provided value array has an element that is not an instance of TimeType.\`;
      assertFhirTypeList<TimeType>(element, TimeType, optErrMsg);
      this.timeOfDay = element;
    } else {
      this.timeOfDay = undefined;
    }
    return this;
  }

  /**
   * Add the provided TimeType value to the \`timeOfDay\` array property.
   *
   * @param element - the \`timeOfDay\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addTimeOfDayElement(element: TimeType | undefined): this {
    if (isDefined<TimeType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.timeOfDay; Provided element is not an instance of TimeType.\`;
      assertFhirType<TimeType>(element, TimeType, optErrMsg);
      this.initTimeOfDay();
      this.timeOfDay?.push(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`timeOfDay\` property exists and has a value; \`false\` otherwise
   */
  public hasTimeOfDayElement(): boolean {
    return isDefinedList<TimeType>(this.timeOfDay) && this.timeOfDay.some((item: TimeType) => !item.isEmpty());
  }

  /**
   * @returns the \`timeOfDay\` property value as a fhirTime array
   */
  public getTimeOfDay(): fhirTime[] {
    this.initTimeOfDay();
    const timeOfDayValues = [] as fhirTime[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.timeOfDay!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        timeOfDayValues.push(value);
      }
    }
    return timeOfDayValues;
  }

  /**
   * Assigns the provided primitive value array to the \`timeOfDay\` property.
   *
   * @param value - the \`timeOfDay\` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTimeOfDay(value: fhirTime[] | undefined): this {
    if (isDefinedList<fhirTime>(value)) {
      const timeOfDayElements = [] as TimeType[];
      for (const timeOfDayValue of value) {
        const optErrMsg = \`Invalid Timing.repeat.timeOfDay array item (\${String(timeOfDayValue)})\`;
        const element = new TimeType(parseFhirPrimitiveData(timeOfDayValue, fhirTimeSchema, optErrMsg));
        timeOfDayElements.push(element);
      }
      this.timeOfDay = timeOfDayElements;
    } else {
      this.timeOfDay = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`timeOfDay\` array property.
   *
   * @param value - the \`timeOfDay\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addTimeOfDay(value: fhirTime | undefined): this {
    if (isDefined<fhirTime>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.timeOfDay array item (\${String(value)})\`;
      const element = new TimeType(parseFhirPrimitiveData(value, fhirTimeSchema, optErrMsg));
      this.initTimeOfDay();
      this.addTimeOfDayElement(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`timeOfDay\` property exists and has a value; \`false\` otherwise
   */
  public hasTimeOfDay(): boolean {
    return this.hasTimeOfDayElement();
  }

  /**
   * Initialize the \`timeOfDay\` property
   */
  private initTimeOfDay(): void {
    if (!this.hasTimeOfDay()) {
      this.timeOfDay = [] as TimeType[];
    }
  }

  /**
   * @returns the \`when\` property value as a CodeType array
   */
  public getWhenElement(): CodeType[] {
    return this.when ?? ([] as CodeType[]);
  }

  /**
   * Assigns the provided CodeType array value to the \`when\` property.
   *
   * @param element - the \`when\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setWhenElement(element: CodeType[] | undefined): this {
    if (isDefinedList<CodeType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.when; Provided value array has an element that is not an instance of CodeType.\`;
      assertFhirTypeList<CodeType>(element, CodeType, optErrMsg);
      this.when = element;
    } else {
      this.when = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeType value to the \`when\` array property.
   *
   * @param element - the \`when\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addWhenElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.when; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.initWhen();
      this.when?.push(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`when\` property exists and has a value; \`false\` otherwise
   */
  public hasWhenElement(): boolean {
    return isDefinedList<CodeType>(this.when) && this.when.some((item: CodeType) => !item.isEmpty());
  }

  /**
   * @returns the \`when\` property value as a fhirCode array
   */
  public getWhen(): fhirCode[] {
    this.initWhen();
    const whenValues = [] as fhirCode[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.when!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        whenValues.push(value);
      }
    }
    return whenValues;
  }

  /**
   * Assigns the provided primitive value array to the \`when\` property.
   *
   * @param value - the \`when\` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setWhen(value: fhirCode[] | undefined): this {
    if (isDefinedList<fhirCode>(value)) {
      const whenElements = [] as CodeType[];
      for (const whenValue of value) {
        const optErrMsg = \`Invalid Timing.repeat.when array item (\${String(whenValue)})\`;
        const element = new CodeType(parseFhirPrimitiveData(whenValue, fhirCodeSchema, optErrMsg));
        whenElements.push(element);
      }
      this.when = whenElements;
    } else {
      this.when = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`when\` array property.
   *
   * @param value - the \`when\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addWhen(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.when array item (\${String(value)})\`;
      const element = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
      this.initWhen();
      this.addWhenElement(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`when\` property exists and has a value; \`false\` otherwise
   */
  public hasWhen(): boolean {
    return this.hasWhenElement();
  }

  /**
   * Initialize the \`when\` property
   */
  private initWhen(): void {
    if (!this.hasWhen()) {
      this.when = [] as CodeType[];
    }
  }

  /**
   * @returns the \`offset\` property value as a UnsignedIntType object if defined; else an empty UnsignedIntType object
   */
  public getOffsetElement(): UnsignedIntType {
    return this.offset ?? new UnsignedIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`offset\` property.
   *
   * @param element - the \`offset\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setOffsetElement(element: UnsignedIntType | undefined): this {
    if (isDefined<UnsignedIntType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.offset; Provided element is not an instance of UnsignedIntType.\`;
      assertFhirType<UnsignedIntType>(element, UnsignedIntType, optErrMsg);
      this.offset = element;
    } else {
      this.offset = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`offset\` property exists and has a value; \`false\` otherwise
   */
  public hasOffsetElement(): boolean {
    return isDefined<UnsignedIntType>(this.offset) && !this.offset.isEmpty();
  }

  /**
   * @returns the \`offset\` property value as a fhirUnsignedInt if defined; else undefined
   */
  public getOffset(): fhirUnsignedInt | undefined {
    return this.offset?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`offset\` property.
   *
   * @param value - the \`offset\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setOffset(value: fhirUnsignedInt | undefined): this {
    if (isDefined<fhirUnsignedInt>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.offset (\${String(value)})\`;
      this.offset = new UnsignedIntType(parseFhirPrimitiveData(value, fhirUnsignedIntSchema, optErrMsg));
    } else {
      this.offset = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`offset\` property exists and has a value; \`false\` otherwise
   */
  public hasOffset(): boolean {
    return this.hasOffsetElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Timing.repeat';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.bounds,
      this.count,
      this.countMax,
      this.duration,
      this.durationMax,
      this.durationUnit,
      this.frequency,
      this.frequencyMax,
      this.period,
      this.periodMax,
      this.periodUnit,
      this.dayOfWeek,
      this.timeOfDay,
      this.when,
      this.offset,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): TimingRepeatComponent {
    const dest = new TimingRepeatComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: TimingRepeatComponent): void {
    super.copyValues(dest);
    dest.bounds = this.bounds?.copy() as IDataType;
    dest.count = this.count?.copy();
    dest.countMax = this.countMax?.copy();
    dest.duration = this.duration?.copy();
    dest.durationMax = this.durationMax?.copy();
    dest.durationUnit = this.durationUnit?.copy();
    dest.frequency = this.frequency?.copy();
    dest.frequencyMax = this.frequencyMax?.copy();
    dest.period = this.period?.copy();
    dest.periodMax = this.periodMax?.copy();
    dest.periodUnit = this.periodUnit?.copy();
    const dayOfWeekList = copyListValues<EnumCodeType>(this.dayOfWeek);
    dest.dayOfWeek = dayOfWeekList.length === 0 ? undefined : dayOfWeekList;
    const timeOfDayList = copyListValues<TimeType>(this.timeOfDay);
    dest.timeOfDay = timeOfDayList.length === 0 ? undefined : timeOfDayList;
    const whenList = copyListValues<CodeType>(this.when);
    dest.when = whenList.length === 0 ? undefined : whenList;
    dest.offset = this.offset?.copy();
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', \`UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasBounds()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getBounds()!, 'bounds', jsonObj);
    }

    if (this.hasCountElement()) {
      setFhirPrimitiveJson<fhirPositiveInt>(this.getCountElement(), 'count', jsonObj);
    }

    if (this.hasCountMaxElement()) {
      setFhirPrimitiveJson<fhirPositiveInt>(this.getCountMaxElement(), 'countMax', jsonObj);
    }

    if (this.hasDurationElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getDurationElement(), 'duration', jsonObj);
    }

    if (this.hasDurationMaxElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getDurationMaxElement(), 'durationMax', jsonObj);
    }

    if (this.hasDurationUnitElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getDurationUnitElement(), 'durationUnit', jsonObj);
    }

    if (this.hasFrequencyElement()) {
      setFhirPrimitiveJson<fhirPositiveInt>(this.getFrequencyElement(), 'frequency', jsonObj);
    }

    if (this.hasFrequencyMaxElement()) {
      setFhirPrimitiveJson<fhirPositiveInt>(this.getFrequencyMaxElement(), 'frequencyMax', jsonObj);
    }

    if (this.hasPeriodElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getPeriodElement(), 'period', jsonObj);
    }

    if (this.hasPeriodMaxElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getPeriodMaxElement(), 'periodMax', jsonObj);
    }

    if (this.hasPeriodUnitElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getPeriodUnitElement(), 'periodUnit', jsonObj);
    }

    if (this.hasDayOfWeekElement()) {
      setFhirPrimitiveListJson<fhirCode>(this.getDayOfWeekElement(), 'dayOfWeek', jsonObj);
    }

    if (this.hasTimeOfDay()) {
      setFhirPrimitiveListJson(this.getTimeOfDayElement(), 'timeOfDay', jsonObj);
    }

    if (this.hasWhen()) {
      setFhirPrimitiveListJson(this.getWhenElement(), 'when', jsonObj);
    }

    if (this.hasOffsetElement()) {
      setFhirPrimitiveJson<fhirUnsignedInt>(this.getOffsetElement(), 'offset', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * PARSABLE_DATATYPE_MAP
 *
 * @remarks
 * Map of all parsable DataTypes where the key is the name of the DataType and the value is its ParsableDataType<DataType> class.
 *
 * @internal
 */
export const PARSABLE_DATATYPE_MAP = new Map<string, ParsableDataType<DataType>>();
PARSABLE_DATATYPE_MAP.set('CodeableConcept', CodeableConcept);
PARSABLE_DATATYPE_MAP.set('Coding', Coding);
PARSABLE_DATATYPE_MAP.set('ContactPoint', ContactPoint);
PARSABLE_DATATYPE_MAP.set('Duration', Duration);
PARSABLE_DATATYPE_MAP.set('Identifier', Identifier);
PARSABLE_DATATYPE_MAP.set('Meta', Meta);
PARSABLE_DATATYPE_MAP.set('Narrative', Narrative);
PARSABLE_DATATYPE_MAP.set('Period', Period);
PARSABLE_DATATYPE_MAP.set('Reference', Reference);
PARSABLE_DATATYPE_MAP.set('Signature', Signature);
PARSABLE_DATATYPE_MAP.set('Timing', Timing);
",
  "fileExtension": "ts",
  "filename": "complex-datatypes",
}
`;

exports[`src/generator-app unit test suite generator-app verify generated content should consistently create GeneratedContent[] 15`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator/src/__test__/test-out",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator/src/__test__/utest-cache",
    "pkgName": "utest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "Resource",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * Bundle Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/Bundle
 * StructureDefinition.name: Bundle
 * StructureDefinition.description: A container for a collection of resources.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  BackboneElement,
  CodeType,
  DecimalType,
  EnumCodeType,
  FhirError,
  FhirParser,
  IBackboneElement,
  INSTANCE_EMPTY_ERROR_MSG,
  IResource,
  InstantType,
  JSON,
  PrimitiveType,
  REQUIRED_PROPERTIES_DO_NOT_EXIST,
  REQUIRED_PROPERTIES_REQD_IN_JSON,
  Resource,
  StringType,
  UnsignedIntType,
  UriType,
  assertEnumCodeType,
  assertFhirResourceType,
  assertFhirType,
  assertFhirTypeList,
  assertIsDefined,
  constructorCodeValueAsEnumCodeType,
  copyListValues,
  fhirCode,
  fhirCodeSchema,
  fhirDecimal,
  fhirDecimalSchema,
  fhirInstant,
  fhirInstantSchema,
  fhirString,
  fhirStringSchema,
  fhirUnsignedInt,
  fhirUnsignedIntSchema,
  fhirUri,
  fhirUriSchema,
  getPrimitiveTypeJson,
  isDefined,
  isDefinedList,
  isElementEmpty,
  isEmpty,
  parseFhirPrimitiveData,
  setFhirBackboneElementJson,
  setFhirBackboneElementListJson,
  setFhirComplexJson,
  setFhirPrimitiveJson,
  setFhirResourceJson,
} from '@paq-ts-fhir/fhir-core';
import { BundleTypeEnum } from '../code-systems/BundleTypeEnum';
import { HttpVerbEnum } from '../code-systems/HttpVerbEnum';
import { Identifier, PARSABLE_DATATYPE_MAP, Signature } from '../complex-types/complex-datatypes';
import { PARSABLE_RESOURCE_MAP } from './parsable-resource-map';
import { SearchEntryModeEnum } from '../code-systems/SearchEntryModeEnum';

/**
 * Bundle Class
 *
 * @remarks
 * A container for a collection of resources.
 *
 * **FHIR Specification**
 * - **Short:** Contains a collection of resources
 * - **Definition:** A container for a collection of resources.
 * - **FHIR Version:** 4.0.1
 *
 * @category Data Models: Resource
 * @see [FHIR Bundle](http://hl7.org/fhir/StructureDefinition/Bundle)
 */
export class Bundle extends Resource implements IResource {
  constructor(type_: EnumCodeType | CodeType | fhirCode | null = null) {
    super();

    this.bundleTypeEnum = new BundleTypeEnum();

    this.type_ = constructorCodeValueAsEnumCodeType<BundleTypeEnum>(
      type_,
      BundleTypeEnum,
      this.bundleTypeEnum,
      'Bundle.type',
    );
  }

  /**
   * Parse the provided \`Bundle\` JSON to instantiate the Bundle data model.
   *
   * @param sourceJson - JSON representing FHIR \`Bundle\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Bundle
   * @returns Bundle data model or undefined for \`Bundle\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static override parse(sourceJson: JSON.Value, optSourceField?: string): Bundle | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Bundle';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Bundle();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.verifyResourceType(classJsonObj, 'Bundle');
    fhirParser.processResourceJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'identifier';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Identifier | undefined = Identifier.parse(classJsonObj[fieldName]!, sourceField);
      instance.setIdentifier(datatype);
    }

    fieldName = 'type';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setTypeElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'timestamp';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: InstantType | undefined = fhirParser.parseInstantType(dtJson, dtSiblingJson);
      instance.setTimestampElement(datatype);
    }

    fieldName = 'total';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UnsignedIntType | undefined = fhirParser.parseUnsignedIntType(dtJson, dtSiblingJson);
      instance.setTotalElement(datatype);
    }

    fieldName = 'link';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const componentJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      componentJsonArray.forEach((componentJson: JSON.Value, idx) => {
        const component: BundleLinkComponent | undefined = BundleLinkComponent.parse(componentJson, \`\${sourceField}[\${String(idx)}]\`);
        if (component !== undefined) {
          instance.addLink(component);
        }
      });
    }

    fieldName = 'entry';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const componentJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      componentJsonArray.forEach((componentJson: JSON.Value, idx) => {
        const component: BundleEntryComponent | undefined = BundleEntryComponent.parse(componentJson, \`\${sourceField}[\${String(idx)}]\`);
        if (component !== undefined) {
          instance.addEntry(component);
        }
      });
    }

    fieldName = 'signature';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Signature | undefined = Signature.parse(classJsonObj[fieldName]!, sourceField);
      instance.setSignature(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Bundle.identifier Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Persistent identifier for the bundle
   * - **Definition:** A persistent identifier for the bundle that won\\'t change as a bundle is copied from server to server.
   * - **Comment:** Persistent identity generally only matters for batches of type Document, Message, and Collection. It would not normally be populated for search and history results and servers ignore Bundle.identifier when processing batches and transactions. For Documents  the .identifier SHALL be populated such that the .identifier is globally unique.
   * - **FHIR Type:** \`Identifier\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private identifier?: Identifier | undefined;

  /**
   * FHIR CodeSystem: BundleType
   *
   * @see {@link BundleTypeEnum }
   */
  private readonly bundleTypeEnum: BundleTypeEnum;

  /**
   * Bundle.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** document | message | transaction | transaction-response | batch | batch-response | history | searchset | collection
   * - **Definition:** Indicates the purpose of this bundle - how it is intended to be used.
   * - **Comment:** It\\'s possible to use a bundle for other purposes (e.g. a document can be accepted as a transaction). This is primarily defined so that there can be specific rules for some of the bundle types.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link BundleTypeEnum }
   */
  private type_: EnumCodeType | null;

  /**
   * Bundle.timestamp Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** When the bundle was assembled
   * - **Definition:** The date/time that the bundle was assembled - i.e. when the resources were placed in the bundle.
   * - **Comment:** For many bundles, the timestamp is equal to .meta.lastUpdated, because they are not stored (e.g. search results). When a bundle is placed in a persistent store, .meta.lastUpdated will be usually be changed by the server. When the bundle is a message, a middleware agent altering the message (even if not stored) SHOULD update .meta.lastUpdated. .timestamp is used to track the original time of the Bundle, and SHOULD be populated.   Usage: * document : the date the document was created. Note: the composition may predate the document, or be associated with multiple documents. The date of the composition - the authoring time - may be earlier than the document assembly time * message : the date that the content of the message was assembled. This date is not changed by middleware engines unless they add additional data that changes the meaning of the time of the message * history : the date that the history was assembled. This time would be used as the _since time to ask for subsequent updates * searchset : the time that the search set was assembled. Note that different pages MAY have different timestamps but need not. Having different timestamps does not imply that subsequent pages will represent or include changes made since the initial query * transaction | transaction-response | batch | batch-response | collection : no particular assigned meaning The timestamp value should be greater than the lastUpdated and other timestamps in the resources in the bundle, and it should be equal or earlier than the .meta.lastUpdated on the Bundle itself.
   * - **FHIR Type:** \`instant\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private timestamp?: InstantType | undefined;

  /**
   * Bundle.total Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** If search, the total number of matches
   * - **Definition:** If a set of search matches, this is the total number of entries of type \\'match\\' across all pages in the search.  It does not include search.mode = \\'include\\' or \\'outcome\\' entries and it does not provide a count of the number of entries in the Bundle.
   * - **Comment:** Only used if the bundle is a search result set. The total does not include resources such as OperationOutcome and included resources, only the total number of matching resources.
   * - **FHIR Type:** \`unsignedInt\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private total?: UnsignedIntType | undefined;

  /**
   * Bundle.link Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Links related to this Bundle
   * - **Definition:** A series of links that provide context to this bundle.
   * - **Comment:** Both Bundle.link and Bundle.entry.link are defined to support providing additional context when Bundles are used (e.g. [HATEOAS](http://en.wikipedia.org/wiki/HATEOAS)).  Bundle.entry.link corresponds to links found in the HTTP header if the resource in the entry was [read](https://hl7.org/fhir/http.html#read) directly. This specification defines some specific uses of Bundle.link for [searching](https://hl7.org/fhir/search.html#conformance) and [paging](https://hl7.org/fhir/http.html#paging), but no specific uses for Bundle.entry.link, and no defined function in a transaction - the meaning is implementation specific.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private link?: BundleLinkComponent[] | undefined;

  /**
   * Bundle.entry Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Entry in the bundle - will have a resource or information
   * - **Definition:** An entry in a bundle resource - will either contain a resource or information about a resource (transactions and history only).
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private entry?: BundleEntryComponent[] | undefined;

  /**
   * Bundle.signature Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Digital Signature
   * - **Definition:** Digital Signature - base64 encoded. XML-DSig or a JWT.
   * - **Comment:** The signature could be created by the "author" of the bundle or by the originating device.   Requirements around inclusion of a signature, verification of signatures and treatment of signed/non-signed bundles is implementation-environment specific.
   * - **Requirements:** A Signature holds an electronic representation of a signature and its supporting context in a FHIR accessible form. The signature may either be a cryptographic type (XML DigSig or a JWS), which is able to provide non-repudiation proof, or it may be a graphical image that represents a signature or a signature process. This element allows capturing signatures on documents, messages, transactions or even search responses, to support content-authentication, non-repudiation or other business cases. This is primarily relevant where the bundle may travel through multiple hops or via other mechanisms where HTTPS non-repudiation is insufficient.
   * - **FHIR Type:** \`Signature\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private signature?: Signature | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`identifier\` property value as a Identifier object if defined; else an empty Identifier object
   */
  public getIdentifier(): Identifier {
    return this.identifier ?? new Identifier();
  }

  /**
   * Assigns the provided Identifier object value to the \`identifier\` property.
   *
   * @param value - the \`identifier\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setIdentifier(value: Identifier | undefined): this {
    if (isDefined<Identifier>(value)) {
      const optErrMsg = \`Invalid Bundle.identifier; Provided element is not an instance of Identifier.\`;
      assertFhirType<Identifier>(value, Identifier, optErrMsg);
      this.identifier = value;
    } else {
      this.identifier = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`identifier\` property exists and has a value; \`false\` otherwise
   */
  public hasIdentifier(): boolean {
    return isDefined<Identifier>(this.identifier) && !this.identifier.isEmpty();
  }

  /**
   * @returns the \`type_\` property value as a EnumCodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link BundleTypeEnum }
   */
  public getTypeEnumType(): EnumCodeType | null {
    return this.type_;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`type_\` property.
   *
   * @param enumType - the \`type_\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link BundleTypeEnum }
   */
  public setTypeEnumType(enumType: EnumCodeType): this {
    assertIsDefined<EnumCodeType>(enumType, \`Bundle.type is required\`);
    const errMsgPrefix = \`Invalid Bundle.type\`;
    assertEnumCodeType<BundleTypeEnum>(enumType, BundleTypeEnum, errMsgPrefix);
    this.type_ = enumType;
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasTypeEnumType(): boolean {
    return isDefined<EnumCodeType>(this.type_) && !this.type_.isEmpty() && this.type_.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`type_\` property value as a CodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link BundleTypeEnum }
   */
  public getTypeElement(): CodeType | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_ as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`type_\` property.
   *
   * @param element - the \`type_\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link BundleTypeEnum }
   */
  public setTypeElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, \`Bundle.type is required\`);
    const optErrMsg = \`Invalid Bundle.type; Provided value is not an instance of CodeType.\`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.type_ = new EnumCodeType(element, this.bundleTypeEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasTypeElement(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the \`type_\` property value as a fhirCode if defined; else null
   *
   * @see CodeSystem Enumeration: {@link BundleTypeEnum }
   */
  public getType(): fhirCode | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`type_\` property.
   *
   * @param value - the \`type_\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link BundleTypeEnum }
   */
  public setType(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, \`Bundle.type is required\`);
    const optErrMsg = \`Invalid Bundle.type (\${String(value)})\`;
    this.type_ = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.bundleTypeEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasType(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the \`timestamp\` property value as a InstantType object if defined; else an empty InstantType object
   */
  public getTimestampElement(): InstantType {
    return this.timestamp ?? new InstantType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`timestamp\` property.
   *
   * @param element - the \`timestamp\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTimestampElement(element: InstantType | undefined): this {
    if (isDefined<InstantType>(element)) {
      const optErrMsg = \`Invalid Bundle.timestamp; Provided element is not an instance of InstantType.\`;
      assertFhirType<InstantType>(element, InstantType, optErrMsg);
      this.timestamp = element;
    } else {
      this.timestamp = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`timestamp\` property exists and has a value; \`false\` otherwise
   */
  public hasTimestampElement(): boolean {
    return isDefined<InstantType>(this.timestamp) && !this.timestamp.isEmpty();
  }

  /**
   * @returns the \`timestamp\` property value as a fhirInstant if defined; else undefined
   */
  public getTimestamp(): fhirInstant | undefined {
    return this.timestamp?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`timestamp\` property.
   *
   * @param value - the \`timestamp\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTimestamp(value: fhirInstant | undefined): this {
    if (isDefined<fhirInstant>(value)) {
      const optErrMsg = \`Invalid Bundle.timestamp (\${String(value)})\`;
      this.timestamp = new InstantType(parseFhirPrimitiveData(value, fhirInstantSchema, optErrMsg));
    } else {
      this.timestamp = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`timestamp\` property exists and has a value; \`false\` otherwise
   */
  public hasTimestamp(): boolean {
    return this.hasTimestampElement();
  }

  /**
   * @returns the \`total\` property value as a UnsignedIntType object if defined; else an empty UnsignedIntType object
   */
  public getTotalElement(): UnsignedIntType {
    return this.total ?? new UnsignedIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`total\` property.
   *
   * @param element - the \`total\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTotalElement(element: UnsignedIntType | undefined): this {
    if (isDefined<UnsignedIntType>(element)) {
      const optErrMsg = \`Invalid Bundle.total; Provided element is not an instance of UnsignedIntType.\`;
      assertFhirType<UnsignedIntType>(element, UnsignedIntType, optErrMsg);
      this.total = element;
    } else {
      this.total = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`total\` property exists and has a value; \`false\` otherwise
   */
  public hasTotalElement(): boolean {
    return isDefined<UnsignedIntType>(this.total) && !this.total.isEmpty();
  }

  /**
   * @returns the \`total\` property value as a fhirUnsignedInt if defined; else undefined
   */
  public getTotal(): fhirUnsignedInt | undefined {
    return this.total?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`total\` property.
   *
   * @param value - the \`total\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTotal(value: fhirUnsignedInt | undefined): this {
    if (isDefined<fhirUnsignedInt>(value)) {
      const optErrMsg = \`Invalid Bundle.total (\${String(value)})\`;
      this.total = new UnsignedIntType(parseFhirPrimitiveData(value, fhirUnsignedIntSchema, optErrMsg));
    } else {
      this.total = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`total\` property exists and has a value; \`false\` otherwise
   */
  public hasTotal(): boolean {
    return this.hasTotalElement();
  }

  /**
   * @returns the \`link\` property value as a BundleLinkComponent array
   */
  public getLink(): BundleLinkComponent[] {
    return this.link ?? ([] as BundleLinkComponent[]);
  }

  /**
   * Assigns the provided BundleLinkComponent array value to the \`link\` property.
   *
   * @param value - the \`link\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setLink(value: BundleLinkComponent[] | undefined): this {
    if (isDefinedList<BundleLinkComponent>(value)) {
      const optErrMsg = \`Invalid Bundle.link; Provided value array has an element that is not an instance of BundleLinkComponent.\`;
      assertFhirTypeList<BundleLinkComponent>(value, BundleLinkComponent, optErrMsg);
      this.link = value;
    } else {
      this.link = undefined;
    }
    return this;
  }

  /**
   * Add the provided BundleLinkComponent value to the \`link\` array property.
   *
   * @param value - the \`link\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addLink(value: BundleLinkComponent | undefined): this {
    if (isDefined<BundleLinkComponent>(value)) {
      const optErrMsg = \`Invalid Bundle.link; Provided element is not an instance of BundleLinkComponent.\`;
      assertFhirType<BundleLinkComponent>(value, BundleLinkComponent, optErrMsg);
      this.initLink();
      this.link?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`link\` property exists and has a value; \`false\` otherwise
   */
  public hasLink(): boolean {
    return isDefinedList<BundleLinkComponent>(this.link) && this.link.some((item: BundleLinkComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`link\` property
   */
  private initLink(): void {
    if(!this.hasLink()) {
      this.link = [] as BundleLinkComponent[];
    }
  }

  /**
   * @returns the \`entry\` property value as a BundleEntryComponent array
   */
  public getEntry(): BundleEntryComponent[] {
    return this.entry ?? ([] as BundleEntryComponent[]);
  }

  /**
   * Assigns the provided BundleEntryComponent array value to the \`entry\` property.
   *
   * @param value - the \`entry\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setEntry(value: BundleEntryComponent[] | undefined): this {
    if (isDefinedList<BundleEntryComponent>(value)) {
      const optErrMsg = \`Invalid Bundle.entry; Provided value array has an element that is not an instance of BundleEntryComponent.\`;
      assertFhirTypeList<BundleEntryComponent>(value, BundleEntryComponent, optErrMsg);
      this.entry = value;
    } else {
      this.entry = undefined;
    }
    return this;
  }

  /**
   * Add the provided BundleEntryComponent value to the \`entry\` array property.
   *
   * @param value - the \`entry\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addEntry(value: BundleEntryComponent | undefined): this {
    if (isDefined<BundleEntryComponent>(value)) {
      const optErrMsg = \`Invalid Bundle.entry; Provided element is not an instance of BundleEntryComponent.\`;
      assertFhirType<BundleEntryComponent>(value, BundleEntryComponent, optErrMsg);
      this.initEntry();
      this.entry?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`entry\` property exists and has a value; \`false\` otherwise
   */
  public hasEntry(): boolean {
    return isDefinedList<BundleEntryComponent>(this.entry) && this.entry.some((item: BundleEntryComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`entry\` property
   */
  private initEntry(): void {
    if(!this.hasEntry()) {
      this.entry = [] as BundleEntryComponent[];
    }
  }

  /**
   * @returns the \`signature\` property value as a Signature object if defined; else an empty Signature object
   */
  public getSignature(): Signature {
    return this.signature ?? new Signature();
  }

  /**
   * Assigns the provided Signature object value to the \`signature\` property.
   *
   * @param value - the \`signature\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setSignature(value: Signature | undefined): this {
    if (isDefined<Signature>(value)) {
      const optErrMsg = \`Invalid Bundle.signature; Provided element is not an instance of Signature.\`;
      assertFhirType<Signature>(value, Signature, optErrMsg);
      this.signature = value;
    } else {
      this.signature = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`signature\` property exists and has a value; \`false\` otherwise
   */
  public hasSignature(): boolean {
    return isDefined<Signature>(this.signature) && !this.signature.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Bundle';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.identifier,
      this.type_,
      this.timestamp,
      this.total,
      this.link,
      this.entry,
      this.signature,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Bundle {
    const dest = new Bundle();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Bundle): void {
    super.copyValues(dest);
    dest.identifier = this.identifier?.copy();
    dest.type_ = this.type_ ? this.type_.copy() : null;
    dest.timestamp = this.timestamp?.copy();
    dest.total = this.total?.copy();
    const linkList = copyListValues<BundleLinkComponent>(this.link);
    dest.link = linkList.length === 0 ? undefined : linkList;
    const entryList = copyListValues<BundleEntryComponent>(this.entry);
    dest.entry = entryList.length === 0 ? undefined : entryList;
    dest.signature = this.signature?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasIdentifier()) {
      setFhirComplexJson(this.getIdentifier(), 'identifier', jsonObj);
    }

    if (this.hasTypeElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getTypeElement()!, 'type', jsonObj);
    } else {
      missingReqdProperties.push(\`Bundle.type\`);
    }

    if (this.hasTimestampElement()) {
      setFhirPrimitiveJson<fhirInstant>(this.getTimestampElement(), 'timestamp', jsonObj);
    }

    if (this.hasTotalElement()) {
      setFhirPrimitiveJson<fhirUnsignedInt>(this.getTotalElement(), 'total', jsonObj);
    }

    if (this.hasLink()) {
      setFhirBackboneElementListJson(this.getLink(), 'link', jsonObj);
    }

    if (this.hasEntry()) {
      setFhirBackboneElementListJson(this.getEntry(), 'entry', jsonObj);
    }

    if (this.hasSignature()) {
      setFhirComplexJson(this.getSignature(), 'signature', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

/**
 * BundleLinkComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Links related to this Bundle
 * - **Definition:** A series of links that provide context to this bundle.
 * - **Comment:** Both Bundle.link and Bundle.entry.link are defined to support providing additional context when Bundles are used (e.g. [HATEOAS](http://en.wikipedia.org/wiki/HATEOAS)).  Bundle.entry.link corresponds to links found in the HTTP header if the resource in the entry was [read](https://hl7.org/fhir/http.html#read) directly. This specification defines some specific uses of Bundle.link for [searching](https://hl7.org/fhir/search.html#conformance) and [paging](https://hl7.org/fhir/http.html#paging), but no specific uses for Bundle.entry.link, and no defined function in a transaction - the meaning is implementation specific.
 *
 * @category Data Models: Resource
 * @see [FHIR Bundle](http://hl7.org/fhir/StructureDefinition/Bundle)
 */
export class BundleLinkComponent extends BackboneElement implements IBackboneElement {
  constructor(relation: StringType | fhirString | null = null, url: UriType | fhirUri | null = null) {
    super();

    this.relation = null;
    if (isDefined<StringType | fhirString>(relation)) {
      if (relation instanceof PrimitiveType) {
        this.setRelationElement(relation);
      } else {
        this.setRelation(relation);
      }
    }

    this.url = null;
    if (isDefined<UriType | fhirUri>(url)) {
      if (url instanceof PrimitiveType) {
        this.setUrlElement(url);
      } else {
        this.setUrl(url);
      }
    }
  }

  /**
   * Parse the provided \`BundleLinkComponent\` JSON to instantiate the BundleLinkComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`BundleLinkComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to BundleLinkComponent
   * @returns BundleLinkComponent data model or undefined for \`BundleLinkComponent\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): BundleLinkComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'BundleLinkComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new BundleLinkComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'relation';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setRelationElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'url';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = fhirParser.parseUriType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setUrlElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Bundle.link.relation Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** See http://www.iana.org/assignments/link-relations/link-relations.xhtml#link-relations-1
   * - **Definition:** A name which details the functional use for this link - see [http://www.iana.org/assignments/link-relations/link-relations.xhtml#link-relations-1](http://www.iana.org/assignments/link-relations/link-relations.xhtml#link-relations-1).
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private relation: StringType | null;

  /**
   * Bundle.link.url Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Reference details for the link
   * - **Definition:** The reference details for the link.
   * - **FHIR Type:** \`uri\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private url: UriType | null;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`relation\` property value as a StringType object if defined; else null
   */
  public getRelationElement(): StringType | null {
    return this.relation;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`relation\` property.
   *
   * @param element - the \`relation\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setRelationElement(element: StringType): this {
    assertIsDefined<StringType>(element, \`Bundle.link.relation is required\`);
    const optErrMsg = \`Invalid Bundle.link.relation; Provided value is not an instance of StringType.\`;
    assertFhirType<StringType>(element, StringType, optErrMsg);
    this.relation = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`relation\` property exists and has a value; \`false\` otherwise
   */
  public hasRelationElement(): boolean {
    return isDefined<StringType>(this.relation) && !this.relation.isEmpty();
  }

  /**
   * @returns the \`relation\` property value as a fhirString if defined; else null
   */
  public getRelation(): fhirString | null {
    if (this.relation?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.relation.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`relation\` property.
   *
   * @param value - the \`relation\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setRelation(value: fhirString): this {
    assertIsDefined<fhirString>(value, \`Bundle.link.relation is required\`);
    const optErrMsg = \`Invalid Bundle.link.relation (\${String(value)})\`;
    this.relation = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`relation\` property exists and has a value; \`false\` otherwise
   */
  public hasRelation(): boolean {
    return this.hasRelationElement();
  }

  /**
   * @returns the \`url\` property value as a UriType object if defined; else null
   */
  public getUrlElement(): UriType | null {
    return this.url;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`url\` property.
   *
   * @param element - the \`url\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUrlElement(element: UriType): this {
    assertIsDefined<UriType>(element, \`Bundle.link.url is required\`);
    const optErrMsg = \`Invalid Bundle.link.url; Provided value is not an instance of UriType.\`;
    assertFhirType<UriType>(element, UriType, optErrMsg);
    this.url = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`url\` property exists and has a value; \`false\` otherwise
   */
  public hasUrlElement(): boolean {
    return isDefined<UriType>(this.url) && !this.url.isEmpty();
  }

  /**
   * @returns the \`url\` property value as a fhirUri if defined; else null
   */
  public getUrl(): fhirUri | null {
    if (this.url?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.url.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`url\` property.
   *
   * @param value - the \`url\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUrl(value: fhirUri): this {
    assertIsDefined<fhirUri>(value, \`Bundle.link.url is required\`);
    const optErrMsg = \`Invalid Bundle.link.url (\${String(value)})\`;
    this.url = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`url\` property exists and has a value; \`false\` otherwise
   */
  public hasUrl(): boolean {
    return this.hasUrlElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Bundle.link';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.relation,
      this.url,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): BundleLinkComponent {
    const dest = new BundleLinkComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: BundleLinkComponent): void {
    super.copyValues(dest);
    dest.relation = this.relation ? this.relation.copy() : null;
    dest.url = this.url ? this.url.copy() : null;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasRelationElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirString>(this.getRelationElement()!, 'relation', jsonObj);
    } else {
      missingReqdProperties.push(\`Bundle.link.relation\`);
    }

    if (this.hasUrlElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirUri>(this.getUrlElement()!, 'url', jsonObj);
    } else {
      missingReqdProperties.push(\`Bundle.link.url\`);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
/**
 * BundleEntryComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Entry in the bundle - will have a resource or information
 * - **Definition:** An entry in a bundle resource - will either contain a resource or information about a resource (transactions and history only).
 *
 * @category Data Models: Resource
 * @see [FHIR Bundle](http://hl7.org/fhir/StructureDefinition/Bundle)
 */
export class BundleEntryComponent extends BackboneElement implements IBackboneElement {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`BundleEntryComponent\` JSON to instantiate the BundleEntryComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`BundleEntryComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to BundleEntryComponent
   * @returns BundleEntryComponent data model or undefined for \`BundleEntryComponent\`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): BundleEntryComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'BundleEntryComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new BundleEntryComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    

    fieldName = 'link';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const componentJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      componentJsonArray.forEach((componentJson: JSON.Value, idx) => {
        const component: BundleLinkComponent | undefined = BundleLinkComponent.parse(componentJson, \`\${sourceField}[\${String(idx)}]\`);
        if (component !== undefined) {
          instance.addLink(component);
        }
      });
    }

    fieldName = 'fullUrl';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = fhirParser.parseUriType(dtJson, dtSiblingJson);
      instance.setFullUrlElement(datatype);
    }

    fieldName = 'resource';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      const resource: IResource | undefined = fhirParser.parseInlineResource(classJsonObj[fieldName], sourceField);
      instance.setResource(resource);
    }

    fieldName = 'search';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const component: BundleEntrySearchComponent | undefined = BundleEntrySearchComponent.parse(classJsonObj[fieldName]!, sourceField);
      instance.setSearch(component);
    }

    fieldName = 'request';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const component: BundleEntryRequestComponent | undefined = BundleEntryRequestComponent.parse(classJsonObj[fieldName]!, sourceField);
      instance.setRequest(component);
    }

    fieldName = 'response';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const component: BundleEntryResponseComponent | undefined = BundleEntryResponseComponent.parse(classJsonObj[fieldName]!, sourceField);
      instance.setResponse(component);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Bundle.entry.link Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Links related to this entry
   * - **Definition:** A series of links that provide context to this entry.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private link?: BundleLinkComponent[] | undefined;

  /**
   * Bundle.entry.fullUrl Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** URI for resource (Absolute URL server address or URI for UUID/OID)
   * - **Definition:** The Absolute URL for the resource.  The fullUrl SHALL NOT disagree with the id in the resource - i.e. if the fullUrl is not a urn:uuid, the URL shall be version-independent URL consistent with the Resource.id. The fullUrl is a version independent reference to the resource. The fullUrl element SHALL have a value except that:  * fullUrl can be empty on a POST (although it does not need to when specifying a temporary id for reference in the bundle) * Results from operations might involve resources that are not identified.
   * - **Comment:** fullUrl might not be [unique in the context of a resource](https://hl7.org/fhir/bundle.html#bundle-unique). Note that since [FHIR resources do not need to be served through the FHIR API](https://hl7.org/fhir/references.html), the fullURL might be a URN or an absolute URL that does not end with the logical id of the resource (Resource.id). However, but if the fullUrl does look like a RESTful server URL (e.g. meets the [regex](https://hl7.org/fhir/references.html#regex), then the \\'id\\' portion of the fullUrl SHALL end with the Resource.id. Note that the fullUrl is not the same as the canonical URL - it\\'s an absolute url for an endpoint serving the resource (these will happen to have the same value on the canonical server for the resource with the canonical URL).
   * - **FHIR Type:** \`uri\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private fullUrl?: UriType | undefined;

  /**
   * Bundle.entry.resource Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A resource in the bundle
   * - **Definition:** The Resource for the entry. The purpose/meaning of the resource is determined by the Bundle.type.
   * - **FHIR Type:** \`Resource\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private resource?: IResource | undefined;

  /**
   * Bundle.entry.search Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Search related information
   * - **Definition:** Information about the search process that lead to the creation of this entry.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private search?: BundleEntrySearchComponent | undefined;

  /**
   * Bundle.entry.request Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Additional execution information (transaction/batch/history)
   * - **Definition:** Additional information about how this entry should be processed as part of a transaction or batch.  For history, it shows how the entry was processed to create the version contained in the entry.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private request?: BundleEntryRequestComponent | undefined;

  /**
   * Bundle.entry.response Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Results of execution (transaction/batch/history)
   * - **Definition:** Indicates the results of processing the corresponding \\'request\\' entry in the batch or transaction being responded to or what the results of an operation where when returning history.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private response?: BundleEntryResponseComponent | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`link\` property value as a BundleLinkComponent array
   */
  public getLink(): BundleLinkComponent[] {
    return this.link ?? ([] as BundleLinkComponent[]);
  }

  /**
   * Assigns the provided BundleLinkComponent array value to the \`link\` property.
   *
   * @param value - the \`link\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setLink(value: BundleLinkComponent[] | undefined): this {
    if (isDefinedList<BundleLinkComponent>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.link; Provided value array has an element that is not an instance of BundleLinkComponent.\`;
      assertFhirTypeList<BundleLinkComponent>(value, BundleLinkComponent, optErrMsg);
      this.link = value;
    } else {
      this.link = undefined;
    }
    return this;
  }

  /**
   * Add the provided BundleLinkComponent value to the \`link\` array property.
   *
   * @param value - the \`link\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addLink(value: BundleLinkComponent | undefined): this {
    if (isDefined<BundleLinkComponent>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.link; Provided element is not an instance of BundleLinkComponent.\`;
      assertFhirType<BundleLinkComponent>(value, BundleLinkComponent, optErrMsg);
      this.initLink();
      this.link?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`link\` property exists and has a value; \`false\` otherwise
   */
  public hasLink(): boolean {
    return isDefinedList<BundleLinkComponent>(this.link) && this.link.some((item: BundleLinkComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`link\` property
   */
  private initLink(): void {
    if(!this.hasLink()) {
      this.link = [] as BundleLinkComponent[];
    }
  }

  /**
   * @returns the \`fullUrl\` property value as a UriType object if defined; else an empty UriType object
   */
  public getFullUrlElement(): UriType {
    return this.fullUrl ?? new UriType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`fullUrl\` property.
   *
   * @param element - the \`fullUrl\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setFullUrlElement(element: UriType | undefined): this {
    if (isDefined<UriType>(element)) {
      const optErrMsg = \`Invalid Bundle.entry.fullUrl; Provided element is not an instance of UriType.\`;
      assertFhirType<UriType>(element, UriType, optErrMsg);
      this.fullUrl = element;
    } else {
      this.fullUrl = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`fullUrl\` property exists and has a value; \`false\` otherwise
   */
  public hasFullUrlElement(): boolean {
    return isDefined<UriType>(this.fullUrl) && !this.fullUrl.isEmpty();
  }

  /**
   * @returns the \`fullUrl\` property value as a fhirUri if defined; else undefined
   */
  public getFullUrl(): fhirUri | undefined {
    return this.fullUrl?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`fullUrl\` property.
   *
   * @param value - the \`fullUrl\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setFullUrl(value: fhirUri | undefined): this {
    if (isDefined<fhirUri>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.fullUrl (\${String(value)})\`;
      this.fullUrl = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    } else {
      this.fullUrl = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`fullUrl\` property exists and has a value; \`false\` otherwise
   */
  public hasFullUrl(): boolean {
    return this.hasFullUrlElement();
  }

  /**
   * @returns the \`resource\` property value as a Resource object if defined; else undefined
   */
  public getResource(): IResource | undefined {
    return this.resource;
  }

  /**
   * Assigns the provided Resource object value to the \`resource\` property.
   *
   * @param value - the \`resource\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid resource type
   */
  public setResource(value: IResource | undefined): this {
    if (isDefined<IResource>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.resource; Provided element is not an instance of Resource.\`;
      assertFhirResourceType(value, optErrMsg);
      this.resource = value;
    } else {
      this.resource = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`resource\` property exists and has a value; \`false\` otherwise
   */
  public hasResource(): boolean {
    return isDefined<IResource>(this.resource) && !this.resource.isEmpty();
  }

  /**
   * @returns the \`search\` property value as a BundleEntrySearchComponent object if defined; else an empty BundleEntrySearchComponent object
   */
  public getSearch(): BundleEntrySearchComponent {
    return this.search ?? new BundleEntrySearchComponent();
  }

  /**
   * Assigns the provided Search object value to the \`search\` property.
   *
   * @param value - the \`search\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setSearch(value: BundleEntrySearchComponent | undefined): this {
    if (isDefined<BundleEntrySearchComponent>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.search; Provided element is not an instance of BundleEntrySearchComponent.\`;
      assertFhirType<BundleEntrySearchComponent>(value, BundleEntrySearchComponent, optErrMsg);
      this.search = value;
    } else {
      this.search = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`search\` property exists and has a value; \`false\` otherwise
   */
  public hasSearch(): boolean {
    return isDefined<BundleEntrySearchComponent>(this.search) && !this.search.isEmpty();
  }

  /**
   * @returns the \`request\` property value as a BundleEntryRequestComponent object if defined; else an empty BundleEntryRequestComponent object
   */
  public getRequest(): BundleEntryRequestComponent {
    return this.request ?? new BundleEntryRequestComponent();
  }

  /**
   * Assigns the provided Request object value to the \`request\` property.
   *
   * @param value - the \`request\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setRequest(value: BundleEntryRequestComponent | undefined): this {
    if (isDefined<BundleEntryRequestComponent>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.request; Provided element is not an instance of BundleEntryRequestComponent.\`;
      assertFhirType<BundleEntryRequestComponent>(value, BundleEntryRequestComponent, optErrMsg);
      this.request = value;
    } else {
      this.request = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`request\` property exists and has a value; \`false\` otherwise
   */
  public hasRequest(): boolean {
    return isDefined<BundleEntryRequestComponent>(this.request) && !this.request.isEmpty();
  }

  /**
   * @returns the \`response\` property value as a BundleEntryResponseComponent object if defined; else an empty BundleEntryResponseComponent object
   */
  public getResponse(): BundleEntryResponseComponent {
    return this.response ?? new BundleEntryResponseComponent();
  }

  /**
   * Assigns the provided Response object value to the \`response\` property.
   *
   * @param value - the \`response\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setResponse(value: BundleEntryResponseComponent | undefined): this {
    if (isDefined<BundleEntryResponseComponent>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.response; Provided element is not an instance of BundleEntryResponseComponent.\`;
      assertFhirType<BundleEntryResponseComponent>(value, BundleEntryResponseComponent, optErrMsg);
      this.response = value;
    } else {
      this.response = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`response\` property exists and has a value; \`false\` otherwise
   */
  public hasResponse(): boolean {
    return isDefined<BundleEntryResponseComponent>(this.response) && !this.response.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Bundle.entry';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.link,
      this.fullUrl,
      this.resource,
      this.search,
      this.request,
      this.response,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): BundleEntryComponent {
    const dest = new BundleEntryComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: BundleEntryComponent): void {
    super.copyValues(dest);
    const linkList = copyListValues<BundleLinkComponent>(this.link);
    dest.link = linkList.length === 0 ? undefined : linkList;
    dest.fullUrl = this.fullUrl?.copy();
    dest.resource = this.resource?.copy() as IResource;
    dest.search = this.search?.copy();
    dest.request = this.request?.copy();
    dest.response = this.response?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasLink()) {
      setFhirBackboneElementListJson(this.getLink(), 'link', jsonObj);
    }

    if (this.hasFullUrlElement()) {
      setFhirPrimitiveJson<fhirUri>(this.getFullUrlElement(), 'fullUrl', jsonObj);
    }

    if (this.hasResource()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirResourceJson(this.getResource()!, 'resource', jsonObj);
    }

    if (this.hasSearch()) {
      setFhirBackboneElementJson(this.getSearch(), 'search', jsonObj);
    }

    if (this.hasRequest()) {
      setFhirBackboneElementJson(this.getRequest(), 'request', jsonObj);
    }

    if (this.hasResponse()) {
      setFhirBackboneElementJson(this.getResponse(), 'response', jsonObj);
    }

    return jsonObj;
  }
}
/**
 * BundleEntrySearchComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Search related information
 * - **Definition:** Information about the search process that lead to the creation of this entry.
 *
 * @category Data Models: Resource
 * @see [FHIR Bundle](http://hl7.org/fhir/StructureDefinition/Bundle)
 */
export class BundleEntrySearchComponent extends BackboneElement implements IBackboneElement {
  constructor() {
    super();

    this.searchEntryModeEnum = new SearchEntryModeEnum();
  }

  /**
   * Parse the provided \`BundleEntrySearchComponent\` JSON to instantiate the BundleEntrySearchComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`BundleEntrySearchComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to BundleEntrySearchComponent
   * @returns BundleEntrySearchComponent data model or undefined for \`BundleEntrySearchComponent\`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): BundleEntrySearchComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'BundleEntrySearchComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new BundleEntrySearchComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'mode';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setModeElement(datatype);
    }

    fieldName = 'score';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setScoreElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: SearchEntryMode
   *
   * @see {@link SearchEntryModeEnum }
   */
  private readonly searchEntryModeEnum: SearchEntryModeEnum;

  /**
   * Bundle.entry.search.mode Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** match | include | outcome - why this is in the result set
   * - **Definition:** Why this entry is in the result set - whether it\\'s included as a match or because of an _include requirement, or to convey information or warning information about the search process.
   * - **Comment:** There is only one mode. In some corner cases, a resource may be included because it is both a match and an include. In these circumstances, \\'match\\' takes precedence.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link SearchEntryModeEnum }
   */
  private mode?: EnumCodeType | undefined;

  /**
   * Bundle.entry.search.score Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Search ranking (between 0 and 1)
   * - **Definition:** When searching, the server\\'s search ranking score for the entry.
   * - **Comment:** Servers are not required to return a ranking score. 1 is most relevant, and 0 is least relevant. Often, search results are sorted by score, but the client may specify a different sort order. See [Patient Match](https://hl7.org/fhir/patient-operation-match.html) for the EMPI search which relates to this element.
   * - **FHIR Type:** \`decimal\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private score?: DecimalType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`mode\` property value as a EnumCodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link SearchEntryModeEnum }
   */
  public getModeEnumType(): EnumCodeType | undefined {
    return this.mode;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`mode\` property.
   *
   * @param enumType - the \`mode\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code values
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link SearchEntryModeEnum }
   */
  public setModeEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid Bundle.entry.search.mode';
      assertEnumCodeType<SearchEntryModeEnum>(enumType, SearchEntryModeEnum, errMsgPrefix);
      this.mode = enumType;
    } else {
      this.mode = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`mode\` property exists and has a value; \`false\` otherwise
   */
  public hasModeEnumType(): boolean {
    return isDefined<EnumCodeType>(this.mode) && !this.mode.isEmpty() && this.mode.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`mode\` property value as a CodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link SearchEntryModeEnum }
   */
  public getModeElement(): CodeType | undefined {
    if (this.mode === undefined) {
      return undefined;
    }
    return this.mode as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`mode\` property.
   *
   * @param element - the \`mode\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link SearchEntryModeEnum }
   */
  public setModeElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Bundle.entry.search.mode; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.mode = new EnumCodeType(element, this.searchEntryModeEnum);
    } else {
      this.mode = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`mode\` property exists and has a value; \`false\` otherwise
   */
  public hasModeElement(): boolean {
    return this.hasModeEnumType();
  }

  /**
   * @returns the \`mode\` property value as a fhirCode if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link SearchEntryModeEnum }
   */
  public getMode(): fhirCode | undefined {
    if (this.mode === undefined) {
      return undefined;
    }
    return this.mode.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`mode\` property.
   *
   * @param value - the \`mode\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link SearchEntryModeEnum }
   */
  public setMode(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.search.mode; Provided value is not an instance of fhirCode.\`;
      this.mode = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.searchEntryModeEnum);
    } else {
      this.mode = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`mode\` property exists and has a value; \`false\` otherwise
   */
  public hasMode(): boolean {
    return this.hasModeEnumType();
  }

  /**
   * @returns the \`score\` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getScoreElement(): DecimalType {
    return this.score ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`score\` property.
   *
   * @param element - the \`score\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setScoreElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = \`Invalid Bundle.entry.search.score; Provided element is not an instance of DecimalType.\`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.score = element;
    } else {
      this.score = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`score\` property exists and has a value; \`false\` otherwise
   */
  public hasScoreElement(): boolean {
    return isDefined<DecimalType>(this.score) && !this.score.isEmpty();
  }

  /**
   * @returns the \`score\` property value as a fhirDecimal if defined; else undefined
   */
  public getScore(): fhirDecimal | undefined {
    return this.score?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`score\` property.
   *
   * @param value - the \`score\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setScore(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.search.score (\${String(value)})\`;
      this.score = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.score = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`score\` property exists and has a value; \`false\` otherwise
   */
  public hasScore(): boolean {
    return this.hasScoreElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Bundle.entry.search';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.mode,
      this.score,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): BundleEntrySearchComponent {
    const dest = new BundleEntrySearchComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: BundleEntrySearchComponent): void {
    super.copyValues(dest);
    dest.mode = this.mode?.copy();
    dest.score = this.score?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasModeElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getModeElement()!, 'mode', jsonObj);
    }

    if (this.hasScoreElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getScoreElement(), 'score', jsonObj);
    }

    return jsonObj;
  }
}
/**
 * BundleEntryRequestComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Additional execution information (transaction/batch/history)
 * - **Definition:** Additional information about how this entry should be processed as part of a transaction or batch.  For history, it shows how the entry was processed to create the version contained in the entry.
 *
 * @category Data Models: Resource
 * @see [FHIR Bundle](http://hl7.org/fhir/StructureDefinition/Bundle)
 */
export class BundleEntryRequestComponent extends BackboneElement implements IBackboneElement {
  constructor(method: EnumCodeType | CodeType | fhirCode | null = null, url: UriType | fhirUri | null = null) {
    super();

    this.httpVerbEnum = new HttpVerbEnum();

    this.method = constructorCodeValueAsEnumCodeType<HttpVerbEnum>(
      method,
      HttpVerbEnum,
      this.httpVerbEnum,
      'Bundle.entry.request.method',
    );

    this.url = null;
    if (isDefined<UriType | fhirUri>(url)) {
      if (url instanceof PrimitiveType) {
        this.setUrlElement(url);
      } else {
        this.setUrl(url);
      }
    }
  }

  /**
   * Parse the provided \`BundleEntryRequestComponent\` JSON to instantiate the BundleEntryRequestComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`BundleEntryRequestComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to BundleEntryRequestComponent
   * @returns BundleEntryRequestComponent data model or undefined for \`BundleEntryRequestComponent\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): BundleEntryRequestComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'BundleEntryRequestComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new BundleEntryRequestComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'method';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setMethodElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'url';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = fhirParser.parseUriType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setUrlElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'ifNoneMatch';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setIfNoneMatchElement(datatype);
    }

    fieldName = 'ifModifiedSince';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: InstantType | undefined = fhirParser.parseInstantType(dtJson, dtSiblingJson);
      instance.setIfModifiedSinceElement(datatype);
    }

    fieldName = 'ifMatch';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setIfMatchElement(datatype);
    }

    fieldName = 'ifNoneExist';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setIfNoneExistElement(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: HttpVerb
   *
   * @see {@link HttpVerbEnum }
   */
  private readonly httpVerbEnum: HttpVerbEnum;

  /**
   * Bundle.entry.request.method Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** GET | HEAD | POST | PUT | DELETE | PATCH
   * - **Definition:** In a transaction or batch, this is the HTTP action to be executed for this entry. In a history bundle, this indicates the HTTP action that occurred.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link HttpVerbEnum }
   */
  private method: EnumCodeType | null;

  /**
   * Bundle.entry.request.url Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** URL for HTTP equivalent of this entry
   * - **Definition:** The URL for this entry, relative to the root (the address to which the request is posted).
   * - **Comment:** E.g. for a Patient Create, the method would be "POST" and the URL would be "Patient". For a Patient Update, the method would be PUT and the URL would be "Patient/[id]".
   * - **FHIR Type:** \`uri\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private url: UriType | null;

  /**
   * Bundle.entry.request.ifNoneMatch Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** For managing cache currency
   * - **Definition:** If the ETag values match, return a 304 Not Modified status. See the API documentation for ["Conditional Read"](https://hl7.org/fhir/http.html#cread).
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private ifNoneMatch?: StringType | undefined;

  /**
   * Bundle.entry.request.ifModifiedSince Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** For managing cache currency
   * - **Definition:** Only perform the operation if the last updated date matches. See the API documentation for ["Conditional Read"](https://hl7.org/fhir/http.html#cread).
   * - **FHIR Type:** \`instant\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private ifModifiedSince?: InstantType | undefined;

  /**
   * Bundle.entry.request.ifMatch Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** For managing update contention
   * - **Definition:** Only perform the operation if the Etag value matches. For more information, see the API section ["Managing Resource Contention"](https://hl7.org/fhir/http.html#concurrency).
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private ifMatch?: StringType | undefined;

  /**
   * Bundle.entry.request.ifNoneExist Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** For conditional creates
   * - **Definition:** Instruct the server not to perform the create if a specified resource already exists. For further information, see the API documentation for ["Conditional Create"](https://hl7.org/fhir/http.html#ccreate). This is just the query portion of the URL - what follows the "?" (not including the "?").
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private ifNoneExist?: StringType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`method\` property value as a EnumCodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link HttpVerbEnum }
   */
  public getMethodEnumType(): EnumCodeType | null {
    return this.method;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`method\` property.
   *
   * @param enumType - the \`method\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link HttpVerbEnum }
   */
  public setMethodEnumType(enumType: EnumCodeType): this {
    assertIsDefined<EnumCodeType>(enumType, \`Bundle.entry.request.method is required\`);
    const errMsgPrefix = \`Invalid Bundle.entry.request.method\`;
    assertEnumCodeType<HttpVerbEnum>(enumType, HttpVerbEnum, errMsgPrefix);
    this.method = enumType;
    return this;
  }

  /**
   * @returns \`true\` if the \`method\` property exists and has a value; \`false\` otherwise
   */
  public hasMethodEnumType(): boolean {
    return isDefined<EnumCodeType>(this.method) && !this.method.isEmpty() && this.method.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`method\` property value as a CodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link HttpVerbEnum }
   */
  public getMethodElement(): CodeType | null {
    if (this.method === null) {
      return null;
    }
    return this.method as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`method\` property.
   *
   * @param element - the \`method\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link HttpVerbEnum }
   */
  public setMethodElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, \`Bundle.entry.request.method is required\`);
    const optErrMsg = \`Invalid Bundle.entry.request.method; Provided value is not an instance of CodeType.\`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.method = new EnumCodeType(element, this.httpVerbEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`method\` property exists and has a value; \`false\` otherwise
   */
  public hasMethodElement(): boolean {
    return this.hasMethodEnumType();
  }

  /**
   * @returns the \`method\` property value as a fhirCode if defined; else null
   *
   * @see CodeSystem Enumeration: {@link HttpVerbEnum }
   */
  public getMethod(): fhirCode | null {
    if (this.method === null) {
      return null;
    }
    return this.method.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`method\` property.
   *
   * @param value - the \`method\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link HttpVerbEnum }
   */
  public setMethod(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, \`Bundle.entry.request.method is required\`);
    const optErrMsg = \`Invalid Bundle.entry.request.method (\${String(value)})\`;
    this.method = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.httpVerbEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`method\` property exists and has a value; \`false\` otherwise
   */
  public hasMethod(): boolean {
    return this.hasMethodEnumType();
  }

  /**
   * @returns the \`url\` property value as a UriType object if defined; else null
   */
  public getUrlElement(): UriType | null {
    return this.url;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`url\` property.
   *
   * @param element - the \`url\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUrlElement(element: UriType): this {
    assertIsDefined<UriType>(element, \`Bundle.entry.request.url is required\`);
    const optErrMsg = \`Invalid Bundle.entry.request.url; Provided value is not an instance of UriType.\`;
    assertFhirType<UriType>(element, UriType, optErrMsg);
    this.url = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`url\` property exists and has a value; \`false\` otherwise
   */
  public hasUrlElement(): boolean {
    return isDefined<UriType>(this.url) && !this.url.isEmpty();
  }

  /**
   * @returns the \`url\` property value as a fhirUri if defined; else null
   */
  public getUrl(): fhirUri | null {
    if (this.url?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.url.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`url\` property.
   *
   * @param value - the \`url\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUrl(value: fhirUri): this {
    assertIsDefined<fhirUri>(value, \`Bundle.entry.request.url is required\`);
    const optErrMsg = \`Invalid Bundle.entry.request.url (\${String(value)})\`;
    this.url = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`url\` property exists and has a value; \`false\` otherwise
   */
  public hasUrl(): boolean {
    return this.hasUrlElement();
  }

  /**
   * @returns the \`ifNoneMatch\` property value as a StringType object if defined; else an empty StringType object
   */
  public getIfNoneMatchElement(): StringType {
    return this.ifNoneMatch ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`ifNoneMatch\` property.
   *
   * @param element - the \`ifNoneMatch\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setIfNoneMatchElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Bundle.entry.request.ifNoneMatch; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.ifNoneMatch = element;
    } else {
      this.ifNoneMatch = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`ifNoneMatch\` property exists and has a value; \`false\` otherwise
   */
  public hasIfNoneMatchElement(): boolean {
    return isDefined<StringType>(this.ifNoneMatch) && !this.ifNoneMatch.isEmpty();
  }

  /**
   * @returns the \`ifNoneMatch\` property value as a fhirString if defined; else undefined
   */
  public getIfNoneMatch(): fhirString | undefined {
    return this.ifNoneMatch?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`ifNoneMatch\` property.
   *
   * @param value - the \`ifNoneMatch\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setIfNoneMatch(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.request.ifNoneMatch (\${String(value)})\`;
      this.ifNoneMatch = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.ifNoneMatch = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`ifNoneMatch\` property exists and has a value; \`false\` otherwise
   */
  public hasIfNoneMatch(): boolean {
    return this.hasIfNoneMatchElement();
  }

  /**
   * @returns the \`ifModifiedSince\` property value as a InstantType object if defined; else an empty InstantType object
   */
  public getIfModifiedSinceElement(): InstantType {
    return this.ifModifiedSince ?? new InstantType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`ifModifiedSince\` property.
   *
   * @param element - the \`ifModifiedSince\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setIfModifiedSinceElement(element: InstantType | undefined): this {
    if (isDefined<InstantType>(element)) {
      const optErrMsg = \`Invalid Bundle.entry.request.ifModifiedSince; Provided element is not an instance of InstantType.\`;
      assertFhirType<InstantType>(element, InstantType, optErrMsg);
      this.ifModifiedSince = element;
    } else {
      this.ifModifiedSince = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`ifModifiedSince\` property exists and has a value; \`false\` otherwise
   */
  public hasIfModifiedSinceElement(): boolean {
    return isDefined<InstantType>(this.ifModifiedSince) && !this.ifModifiedSince.isEmpty();
  }

  /**
   * @returns the \`ifModifiedSince\` property value as a fhirInstant if defined; else undefined
   */
  public getIfModifiedSince(): fhirInstant | undefined {
    return this.ifModifiedSince?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`ifModifiedSince\` property.
   *
   * @param value - the \`ifModifiedSince\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setIfModifiedSince(value: fhirInstant | undefined): this {
    if (isDefined<fhirInstant>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.request.ifModifiedSince (\${String(value)})\`;
      this.ifModifiedSince = new InstantType(parseFhirPrimitiveData(value, fhirInstantSchema, optErrMsg));
    } else {
      this.ifModifiedSince = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`ifModifiedSince\` property exists and has a value; \`false\` otherwise
   */
  public hasIfModifiedSince(): boolean {
    return this.hasIfModifiedSinceElement();
  }

  /**
   * @returns the \`ifMatch\` property value as a StringType object if defined; else an empty StringType object
   */
  public getIfMatchElement(): StringType {
    return this.ifMatch ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`ifMatch\` property.
   *
   * @param element - the \`ifMatch\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setIfMatchElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Bundle.entry.request.ifMatch; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.ifMatch = element;
    } else {
      this.ifMatch = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`ifMatch\` property exists and has a value; \`false\` otherwise
   */
  public hasIfMatchElement(): boolean {
    return isDefined<StringType>(this.ifMatch) && !this.ifMatch.isEmpty();
  }

  /**
   * @returns the \`ifMatch\` property value as a fhirString if defined; else undefined
   */
  public getIfMatch(): fhirString | undefined {
    return this.ifMatch?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`ifMatch\` property.
   *
   * @param value - the \`ifMatch\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setIfMatch(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.request.ifMatch (\${String(value)})\`;
      this.ifMatch = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.ifMatch = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`ifMatch\` property exists and has a value; \`false\` otherwise
   */
  public hasIfMatch(): boolean {
    return this.hasIfMatchElement();
  }

  /**
   * @returns the \`ifNoneExist\` property value as a StringType object if defined; else an empty StringType object
   */
  public getIfNoneExistElement(): StringType {
    return this.ifNoneExist ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`ifNoneExist\` property.
   *
   * @param element - the \`ifNoneExist\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setIfNoneExistElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Bundle.entry.request.ifNoneExist; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.ifNoneExist = element;
    } else {
      this.ifNoneExist = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`ifNoneExist\` property exists and has a value; \`false\` otherwise
   */
  public hasIfNoneExistElement(): boolean {
    return isDefined<StringType>(this.ifNoneExist) && !this.ifNoneExist.isEmpty();
  }

  /**
   * @returns the \`ifNoneExist\` property value as a fhirString if defined; else undefined
   */
  public getIfNoneExist(): fhirString | undefined {
    return this.ifNoneExist?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`ifNoneExist\` property.
   *
   * @param value - the \`ifNoneExist\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setIfNoneExist(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.request.ifNoneExist (\${String(value)})\`;
      this.ifNoneExist = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.ifNoneExist = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`ifNoneExist\` property exists and has a value; \`false\` otherwise
   */
  public hasIfNoneExist(): boolean {
    return this.hasIfNoneExistElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Bundle.entry.request';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.method,
      this.url,
      this.ifNoneMatch,
      this.ifModifiedSince,
      this.ifMatch,
      this.ifNoneExist,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): BundleEntryRequestComponent {
    const dest = new BundleEntryRequestComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: BundleEntryRequestComponent): void {
    super.copyValues(dest);
    dest.method = this.method ? this.method.copy() : null;
    dest.url = this.url ? this.url.copy() : null;
    dest.ifNoneMatch = this.ifNoneMatch?.copy();
    dest.ifModifiedSince = this.ifModifiedSince?.copy();
    dest.ifMatch = this.ifMatch?.copy();
    dest.ifNoneExist = this.ifNoneExist?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasMethodElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getMethodElement()!, 'method', jsonObj);
    } else {
      missingReqdProperties.push(\`Bundle.entry.request.method\`);
    }

    if (this.hasUrlElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirUri>(this.getUrlElement()!, 'url', jsonObj);
    } else {
      missingReqdProperties.push(\`Bundle.entry.request.url\`);
    }

    if (this.hasIfNoneMatchElement()) {
      setFhirPrimitiveJson<fhirString>(this.getIfNoneMatchElement(), 'ifNoneMatch', jsonObj);
    }

    if (this.hasIfModifiedSinceElement()) {
      setFhirPrimitiveJson<fhirInstant>(this.getIfModifiedSinceElement(), 'ifModifiedSince', jsonObj);
    }

    if (this.hasIfMatchElement()) {
      setFhirPrimitiveJson<fhirString>(this.getIfMatchElement(), 'ifMatch', jsonObj);
    }

    if (this.hasIfNoneExistElement()) {
      setFhirPrimitiveJson<fhirString>(this.getIfNoneExistElement(), 'ifNoneExist', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
/**
 * BundleEntryResponseComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Results of execution (transaction/batch/history)
 * - **Definition:** Indicates the results of processing the corresponding \\'request\\' entry in the batch or transaction being responded to or what the results of an operation where when returning history.
 *
 * @category Data Models: Resource
 * @see [FHIR Bundle](http://hl7.org/fhir/StructureDefinition/Bundle)
 */
export class BundleEntryResponseComponent extends BackboneElement implements IBackboneElement {
  constructor(status: StringType | fhirString | null = null) {
    super();

    this.status = null;
    if (isDefined<StringType | fhirString>(status)) {
      if (status instanceof PrimitiveType) {
        this.setStatusElement(status);
      } else {
        this.setStatus(status);
      }
    }
  }

  /**
   * Parse the provided \`BundleEntryResponseComponent\` JSON to instantiate the BundleEntryResponseComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`BundleEntryResponseComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to BundleEntryResponseComponent
   * @returns BundleEntryResponseComponent data model or undefined for \`BundleEntryResponseComponent\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): BundleEntryResponseComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'BundleEntryResponseComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new BundleEntryResponseComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'status';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setStatusElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'location';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = fhirParser.parseUriType(dtJson, dtSiblingJson);
      instance.setLocationElement(datatype);
    }

    fieldName = 'etag';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setEtagElement(datatype);
    }

    fieldName = 'lastModified';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: InstantType | undefined = fhirParser.parseInstantType(dtJson, dtSiblingJson);
      instance.setLastModifiedElement(datatype);
    }

    fieldName = 'outcome';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      const outcome: IResource | undefined = fhirParser.parseInlineResource(classJsonObj[fieldName], sourceField);
      instance.setOutcome(outcome);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Bundle.entry.response.status Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Status response code (text optional)
   * - **Definition:** The status code returned by processing this entry. The status SHALL start with a 3 digit HTTP code (e.g. 404) and may contain the standard HTTP description associated with the status code.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private status: StringType | null;

  /**
   * Bundle.entry.response.location Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The location (if the operation returns a location)
   * - **Definition:** The location header created by processing this operation, populated if the operation returns a location.
   * - **FHIR Type:** \`uri\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private location?: UriType | undefined;

  /**
   * Bundle.entry.response.etag Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The Etag for the resource (if relevant)
   * - **Definition:** The Etag for the resource, if the operation for the entry produced a versioned resource (see [Resource Metadata and Versioning](https://hl7.org/fhir/http.html#versioning) and [Managing Resource Contention](https://hl7.org/fhir/http.html#concurrency)).
   * - **Comment:** Etags match the Resource.meta.versionId. The ETag has to match the version id in the header if a resource is included.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private etag?: StringType | undefined;

  /**
   * Bundle.entry.response.lastModified Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Server\\'s date time modified
   * - **Definition:** The date/time that the resource was modified on the server.
   * - **Comment:** This has to match the same time in the meta header (meta.lastUpdated) if a resource is included.
   * - **FHIR Type:** \`instant\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private lastModified?: InstantType | undefined;

  /**
   * Bundle.entry.response.outcome Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** OperationOutcome with hints and warnings (for batch/transaction)
   * - **Definition:** An OperationOutcome containing hints and warnings produced as part of processing this entry in a batch or transaction.
   * - **Comment:** For a POST/PUT operation, this is the equivalent outcome that would be returned for prefer = operationoutcome - except that the resource is always returned whether or not the outcome is returned. This outcome is not used for error responses in batch/transaction, only for hints and warnings. In a batch operation, the error will be in Bundle.entry.response, and for transaction, there will be a single OperationOutcome instead of a bundle in the case of an error.
   * - **FHIR Type:** \`Resource\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private outcome?: IResource | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`status\` property value as a StringType object if defined; else null
   */
  public getStatusElement(): StringType | null {
    return this.status;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`status\` property.
   *
   * @param element - the \`status\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setStatusElement(element: StringType): this {
    assertIsDefined<StringType>(element, \`Bundle.entry.response.status is required\`);
    const optErrMsg = \`Invalid Bundle.entry.response.status; Provided value is not an instance of StringType.\`;
    assertFhirType<StringType>(element, StringType, optErrMsg);
    this.status = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`status\` property exists and has a value; \`false\` otherwise
   */
  public hasStatusElement(): boolean {
    return isDefined<StringType>(this.status) && !this.status.isEmpty();
  }

  /**
   * @returns the \`status\` property value as a fhirString if defined; else null
   */
  public getStatus(): fhirString | null {
    if (this.status?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.status.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`status\` property.
   *
   * @param value - the \`status\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setStatus(value: fhirString): this {
    assertIsDefined<fhirString>(value, \`Bundle.entry.response.status is required\`);
    const optErrMsg = \`Invalid Bundle.entry.response.status (\${String(value)})\`;
    this.status = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`status\` property exists and has a value; \`false\` otherwise
   */
  public hasStatus(): boolean {
    return this.hasStatusElement();
  }

  /**
   * @returns the \`location\` property value as a UriType object if defined; else an empty UriType object
   */
  public getLocationElement(): UriType {
    return this.location ?? new UriType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`location\` property.
   *
   * @param element - the \`location\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLocationElement(element: UriType | undefined): this {
    if (isDefined<UriType>(element)) {
      const optErrMsg = \`Invalid Bundle.entry.response.location; Provided element is not an instance of UriType.\`;
      assertFhirType<UriType>(element, UriType, optErrMsg);
      this.location = element;
    } else {
      this.location = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`location\` property exists and has a value; \`false\` otherwise
   */
  public hasLocationElement(): boolean {
    return isDefined<UriType>(this.location) && !this.location.isEmpty();
  }

  /**
   * @returns the \`location\` property value as a fhirUri if defined; else undefined
   */
  public getLocation(): fhirUri | undefined {
    return this.location?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`location\` property.
   *
   * @param value - the \`location\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLocation(value: fhirUri | undefined): this {
    if (isDefined<fhirUri>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.response.location (\${String(value)})\`;
      this.location = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    } else {
      this.location = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`location\` property exists and has a value; \`false\` otherwise
   */
  public hasLocation(): boolean {
    return this.hasLocationElement();
  }

  /**
   * @returns the \`etag\` property value as a StringType object if defined; else an empty StringType object
   */
  public getEtagElement(): StringType {
    return this.etag ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`etag\` property.
   *
   * @param element - the \`etag\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setEtagElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Bundle.entry.response.etag; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.etag = element;
    } else {
      this.etag = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`etag\` property exists and has a value; \`false\` otherwise
   */
  public hasEtagElement(): boolean {
    return isDefined<StringType>(this.etag) && !this.etag.isEmpty();
  }

  /**
   * @returns the \`etag\` property value as a fhirString if defined; else undefined
   */
  public getEtag(): fhirString | undefined {
    return this.etag?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`etag\` property.
   *
   * @param value - the \`etag\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setEtag(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.response.etag (\${String(value)})\`;
      this.etag = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.etag = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`etag\` property exists and has a value; \`false\` otherwise
   */
  public hasEtag(): boolean {
    return this.hasEtagElement();
  }

  /**
   * @returns the \`lastModified\` property value as a InstantType object if defined; else an empty InstantType object
   */
  public getLastModifiedElement(): InstantType {
    return this.lastModified ?? new InstantType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`lastModified\` property.
   *
   * @param element - the \`lastModified\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLastModifiedElement(element: InstantType | undefined): this {
    if (isDefined<InstantType>(element)) {
      const optErrMsg = \`Invalid Bundle.entry.response.lastModified; Provided element is not an instance of InstantType.\`;
      assertFhirType<InstantType>(element, InstantType, optErrMsg);
      this.lastModified = element;
    } else {
      this.lastModified = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`lastModified\` property exists and has a value; \`false\` otherwise
   */
  public hasLastModifiedElement(): boolean {
    return isDefined<InstantType>(this.lastModified) && !this.lastModified.isEmpty();
  }

  /**
   * @returns the \`lastModified\` property value as a fhirInstant if defined; else undefined
   */
  public getLastModified(): fhirInstant | undefined {
    return this.lastModified?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`lastModified\` property.
   *
   * @param value - the \`lastModified\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLastModified(value: fhirInstant | undefined): this {
    if (isDefined<fhirInstant>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.response.lastModified (\${String(value)})\`;
      this.lastModified = new InstantType(parseFhirPrimitiveData(value, fhirInstantSchema, optErrMsg));
    } else {
      this.lastModified = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`lastModified\` property exists and has a value; \`false\` otherwise
   */
  public hasLastModified(): boolean {
    return this.hasLastModifiedElement();
  }

  /**
   * @returns the \`outcome\` property value as a Resource object if defined; else undefined
   */
  public getOutcome(): IResource | undefined {
    return this.outcome;
  }

  /**
   * Assigns the provided Resource object value to the \`outcome\` property.
   *
   * @param value - the \`outcome\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid resource type
   */
  public setOutcome(value: IResource | undefined): this {
    if (isDefined<IResource>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.response.outcome; Provided element is not an instance of Resource.\`;
      assertFhirResourceType(value, optErrMsg);
      this.outcome = value;
    } else {
      this.outcome = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`outcome\` property exists and has a value; \`false\` otherwise
   */
  public hasOutcome(): boolean {
    return isDefined<IResource>(this.outcome) && !this.outcome.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Bundle.entry.response';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.status,
      this.location,
      this.etag,
      this.lastModified,
      this.outcome,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): BundleEntryResponseComponent {
    const dest = new BundleEntryResponseComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: BundleEntryResponseComponent): void {
    super.copyValues(dest);
    dest.status = this.status ? this.status.copy() : null;
    dest.location = this.location?.copy();
    dest.etag = this.etag?.copy();
    dest.lastModified = this.lastModified?.copy();
    dest.outcome = this.outcome?.copy() as IResource;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasStatusElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirString>(this.getStatusElement()!, 'status', jsonObj);
    } else {
      missingReqdProperties.push(\`Bundle.entry.response.status\`);
    }

    if (this.hasLocationElement()) {
      setFhirPrimitiveJson<fhirUri>(this.getLocationElement(), 'location', jsonObj);
    }

    if (this.hasEtagElement()) {
      setFhirPrimitiveJson<fhirString>(this.getEtagElement(), 'etag', jsonObj);
    }

    if (this.hasLastModifiedElement()) {
      setFhirPrimitiveJson<fhirInstant>(this.getLastModifiedElement(), 'lastModified', jsonObj);
    }

    if (this.hasOutcome()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirResourceJson(this.getOutcome()!, 'outcome', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
",
  "fileExtension": "ts",
  "filename": "Bundle",
}
`;

exports[`src/generator-app unit test suite generator-app verify generated content should consistently create GeneratedContent[] 16`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator/src/__test__/test-out",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator/src/__test__/utest-cache",
    "pkgName": "utest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "Resource",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * PractitionerRole Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/PractitionerRole
 * StructureDefinition.name: PractitionerRole
 * StructureDefinition.description: A specific set of Roles/Locations/specialties/services that a practitioner may perform at an organization for a period of time.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  BackboneElement,
  BooleanType,
  CodeType,
  DomainResource,
  EnumCodeType,
  FhirError,
  FhirParser,
  IBackboneElement,
  IDomainResource,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  PrimitiveType,
  PrimitiveTypeJson,
  REQUIRED_PROPERTIES_DO_NOT_EXIST,
  REQUIRED_PROPERTIES_REQD_IN_JSON,
  ReferenceTargets,
  StringType,
  TimeType,
  assertEnumCodeType,
  assertEnumCodeTypeList,
  assertFhirType,
  assertFhirTypeList,
  assertIsDefined,
  copyListValues,
  fhirBoolean,
  fhirBooleanSchema,
  fhirCode,
  fhirCodeSchema,
  fhirString,
  fhirStringSchema,
  fhirTime,
  fhirTimeSchema,
  getPrimitiveTypeJson,
  getPrimitiveTypeListJson,
  isDefined,
  isDefinedList,
  isElementEmpty,
  isEmpty,
  parseFhirPrimitiveData,
  setFhirBackboneElementListJson,
  setFhirComplexJson,
  setFhirComplexListJson,
  setFhirPrimitiveJson,
  setFhirPrimitiveListJson,
} from '@paq-ts-fhir/fhir-core';
import { CodeableConcept, ContactPoint, Identifier, PARSABLE_DATATYPE_MAP, Period, Reference } from '../complex-types/complex-datatypes';
import { DaysOfWeekEnum } from '../code-systems/DaysOfWeekEnum';
import { PARSABLE_RESOURCE_MAP } from './parsable-resource-map';

/**
 * PractitionerRole Class
 *
 * @remarks
 * A specific set of Roles/Locations/specialties/services that a practitioner may perform at an organization for a period of time.
 *
 * Need to track services that a healthcare provider is able to provide at an organization\\'s location, and the services that they can perform there.
 *
 * **FHIR Specification**
 * - **Short:** Roles/organizations the practitioner is associated with
 * - **Definition:** A specific set of Roles/Locations/specialties/services that a practitioner may perform at an organization for a period of time.
 * - **FHIR Version:** 4.0.1
 *
 * @category Data Models: Resource
 * @see [FHIR PractitionerRole](http://hl7.org/fhir/StructureDefinition/PractitionerRole)
 */
export class PractitionerRole extends DomainResource implements IDomainResource {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`PractitionerRole\` JSON to instantiate the PractitionerRole data model.
   *
   * @param sourceJson - JSON representing FHIR \`PractitionerRole\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to PractitionerRole
   * @returns PractitionerRole data model or undefined for \`PractitionerRole\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static override parse(sourceJson: JSON.Value, optSourceField?: string): PractitionerRole | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'PractitionerRole';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new PractitionerRole();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.verifyResourceType(classJsonObj, 'PractitionerRole');
    fhirParser.processDomainResourceJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'identifier';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Identifier | undefined = Identifier.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addIdentifier(datatype);
        }
      });
    }

    fieldName = 'active';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'boolean';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: BooleanType | undefined = fhirParser.parseBooleanType(dtJson, dtSiblingJson);
      instance.setActiveElement(datatype);
    }

    fieldName = 'period';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Period | undefined = Period.parse(classJsonObj[fieldName]!, sourceField);
      instance.setPeriod(datatype);
    }

    fieldName = 'practitioner';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = Reference.parse(classJsonObj[fieldName]!, sourceField);
      instance.setPractitioner(datatype);
    }

    fieldName = 'organization';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = Reference.parse(classJsonObj[fieldName]!, sourceField);
      instance.setOrganization(datatype);
    }

    fieldName = 'code';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: CodeableConcept | undefined = CodeableConcept.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addCode(datatype);
        }
      });
    }

    fieldName = 'specialty';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: CodeableConcept | undefined = CodeableConcept.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addSpecialty(datatype);
        }
      });
    }

    fieldName = 'location';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Reference | undefined = Reference.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addLocation(datatype);
        }
      });
  }

    fieldName = 'healthcareService';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Reference | undefined = Reference.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addHealthcareService(datatype);
        }
      });
  }

    fieldName = 'telecom';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: ContactPoint | undefined = ContactPoint.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addTelecom(datatype);
        }
      });
    }

    fieldName = 'availableTime';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const componentJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      componentJsonArray.forEach((componentJson: JSON.Value, idx) => {
        const component: PractitionerRoleAvailableTimeComponent | undefined = PractitionerRoleAvailableTimeComponent.parse(componentJson, \`\${sourceField}[\${String(idx)}]\`);
        if (component !== undefined) {
          instance.addAvailableTime(component);
        }
      });
    }

    fieldName = 'notAvailable';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const componentJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      componentJsonArray.forEach((componentJson: JSON.Value, idx) => {
        const component: PractitionerRoleNotAvailableComponent | undefined = PractitionerRoleNotAvailableComponent.parse(componentJson, \`\${sourceField}[\${String(idx)}]\`);
        if (component !== undefined) {
          instance.addNotAvailable(component);
        }
      });
    }

    fieldName = 'availabilityExceptions';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setAvailabilityExceptionsElement(datatype);
    }

    fieldName = 'endpoint';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Reference | undefined = Reference.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addEndpoint(datatype);
        }
      });
  }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * PractitionerRole.identifier Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Business Identifiers that are specific to a role/location
   * - **Definition:** Business Identifiers that are specific to a role/location.
   * - **Requirements:** Often, specific identities are assigned for the agent.
   * - **FHIR Type:** \`Identifier\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private identifier?: Identifier[] | undefined;

  /**
   * PractitionerRole.active Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Whether this practitioner role record is in active use
   * - **Definition:** Whether this practitioner role record is in active use.
   * - **Comment:** If this value is false, you may refer to the period to see when the role was in active use. If there is no period specified, no inference can be made about when it was active.
   * - **Requirements:** Need to be able to mark a practitioner role record as not to be used because it was created in error, or otherwise no longer in active use.
   * - **FHIR Type:** \`boolean\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private active?: BooleanType | undefined;

  /**
   * PractitionerRole.period Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The period during which the practitioner is authorized to perform in these role(s)
   * - **Definition:** The period during which the person is authorized to act as a practitioner in these role(s) for the organization.
   * - **Requirements:** Even after the agencies is revoked, the fact that it existed must still be recorded.
   * - **FHIR Type:** \`Period\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private period?: Period | undefined;

  /**
   * PractitionerRole.practitioner Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Practitioner that is able to provide the defined services for the organization
   * - **Definition:** Practitioner that is able to provide the defined services for the organization.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Practitioner',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private practitioner?: Reference | undefined;

  /**
   * PractitionerRole.organization Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Organization where the roles are available
   * - **Definition:** The organization where the Practitioner performs the roles associated.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Organization',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private organization?: Reference | undefined;

  /**
   * PractitionerRole.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Roles which this practitioner may perform
   * - **Definition:** Roles which this practitioner is authorized to perform for the organization.
   * - **Comment:** A person may have more than one role.
   * - **Requirements:** Need to know what authority the practitioner has - what can they do?
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code?: CodeableConcept[] | undefined;

  /**
   * PractitionerRole.specialty Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Specific specialty of the practitioner
   * - **Definition:** Specific specialty of the practitioner.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private specialty?: CodeableConcept[] | undefined;

  /**
   * PractitionerRole.location Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The location(s) at which this practitioner provides care
   * - **Definition:** The location(s) at which this practitioner provides care.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Location',
   *     ]
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private location?: Reference[] | undefined;

  /**
   * PractitionerRole.healthcareService Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The list of healthcare services that this worker provides for this role\\'s Organization/Location(s)
   * - **Definition:** The list of healthcare services that this worker provides for this role\\'s Organization/Location(s).
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/HealthcareService',
   *     ]
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private healthcareService?: Reference[] | undefined;

  /**
   * PractitionerRole.telecom Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Contact details that are specific to the role/location/service
   * - **Definition:** Contact details that are specific to the role/location/service.
   * - **Requirements:** Often practitioners have a dedicated line for each location (or service) that they work at, and need to be able to define separate contact details for each of these.
   * - **FHIR Type:** \`ContactPoint\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private telecom?: ContactPoint[] | undefined;

  /**
   * PractitionerRole.availableTime Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Times the Service Site is available
   * - **Definition:** A collection of times the practitioner is available or performing this role at the location and/or healthcareservice.
   * - **Comment:** More detailed availability information may be provided in associated Schedule/Slot resources.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private availableTime?: PractitionerRoleAvailableTimeComponent[] | undefined;

  /**
   * PractitionerRole.notAvailable Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Not available during this time due to provided reason
   * - **Definition:** The practitioner is not available or performing this role during this period of time due to the provided reason.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private notAvailable?: PractitionerRoleNotAvailableComponent[] | undefined;

  /**
   * PractitionerRole.availabilityExceptions Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Description of availability exceptions
   * - **Definition:** A description of site availability exceptions, e.g. public holiday availability. Succinctly describing all possible exceptions to normal site availability as details in the available Times and not available Times.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private availabilityExceptions?: StringType | undefined;

  /**
   * PractitionerRole.endpoint Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Technical endpoints providing access to services operated for the practitioner with this role
   * - **Definition:** Technical endpoints providing access to services operated for the practitioner with this role.
   * - **Requirements:** Organizations have multiple systems that provide various services and ,ay also be different for practitioners too. So the endpoint satisfies the need to be able to define the technical connection details for how to connect to them, and for what purpose.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Endpoint',
   *     ]
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private endpoint?: Reference[] | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`identifier\` property value as a Identifier array
   */
  public getIdentifier(): Identifier[] {
    return this.identifier ?? ([] as Identifier[]);
  }

  /**
   * Assigns the provided Identifier array value to the \`identifier\` property.
   *
   * @param value - the \`identifier\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setIdentifier(value: Identifier[] | undefined): this {
    if (isDefinedList<Identifier>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.identifier; Provided value array has an element that is not an instance of Identifier.\`;
      assertFhirTypeList<Identifier>(value, Identifier, optErrMsg);
      this.identifier = value;
    } else {
      this.identifier = undefined;
    }
    return this;
  }

  /**
   * Add the provided Identifier value to the \`identifier\` array property.
   *
   * @param value - the \`identifier\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addIdentifier(value: Identifier | undefined): this {
    if (isDefined<Identifier>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.identifier; Provided element is not an instance of Identifier.\`;
      assertFhirType<Identifier>(value, Identifier, optErrMsg);
      this.initIdentifier();
      this.identifier?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`identifier\` property exists and has a value; \`false\` otherwise
   */
  public hasIdentifier(): boolean {
    return isDefinedList<Identifier>(this.identifier) && this.identifier.some((item: Identifier) => !item.isEmpty());
  }

  /**
   * Initialize the \`identifier\` property
   */
  private initIdentifier(): void {
    if(!this.hasIdentifier()) {
      this.identifier = [] as Identifier[];
    }
  }

  /**
   * @returns the \`active\` property value as a BooleanType object if defined; else an empty BooleanType object
   */
  public getActiveElement(): BooleanType {
    return this.active ?? new BooleanType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`active\` property.
   *
   * @param element - the \`active\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setActiveElement(element: BooleanType | undefined): this {
    if (isDefined<BooleanType>(element)) {
      const optErrMsg = \`Invalid PractitionerRole.active; Provided element is not an instance of BooleanType.\`;
      assertFhirType<BooleanType>(element, BooleanType, optErrMsg);
      this.active = element;
    } else {
      this.active = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`active\` property exists and has a value; \`false\` otherwise
   */
  public hasActiveElement(): boolean {
    return isDefined<BooleanType>(this.active) && !this.active.isEmpty();
  }

  /**
   * @returns the \`active\` property value as a fhirBoolean if defined; else undefined
   */
  public getActive(): fhirBoolean | undefined {
    return this.active?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`active\` property.
   *
   * @param value - the \`active\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setActive(value: fhirBoolean | undefined): this {
    if (isDefined<fhirBoolean>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.active (\${String(value)})\`;
      this.active = new BooleanType(parseFhirPrimitiveData(value, fhirBooleanSchema, optErrMsg));
    } else {
      this.active = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`active\` property exists and has a value; \`false\` otherwise
   */
  public hasActive(): boolean {
    return this.hasActiveElement();
  }

  /**
   * @returns the \`period\` property value as a Period object if defined; else an empty Period object
   */
  public getPeriod(): Period {
    return this.period ?? new Period();
  }

  /**
   * Assigns the provided Period object value to the \`period\` property.
   *
   * @param value - the \`period\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setPeriod(value: Period | undefined): this {
    if (isDefined<Period>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.period; Provided element is not an instance of Period.\`;
      assertFhirType<Period>(value, Period, optErrMsg);
      this.period = value;
    } else {
      this.period = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`period\` property exists and has a value; \`false\` otherwise
   */
  public hasPeriod(): boolean {
    return isDefined<Period>(this.period) && !this.period.isEmpty();
  }

  /**
   * @returns the \`practitioner\` property value as a Reference object; else an empty Reference object
   */
  public getPractitioner(): Reference {
    return this.practitioner ?? new Reference();
  }

  /**
   * Assigns the provided Practitioner object value to the \`practitioner\` property.
   *
   * @decorator \`@ReferenceTargets('PractitionerRole.practitioner', ['Practitioner',])\`
   *
   * @param value - the \`practitioner\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('PractitionerRole.practitioner', [
    'Practitioner',
  ])
  public setPractitioner(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.practitioner = value;
    } else {
      this.practitioner = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`practitioner\` property exists and has a value; \`false\` otherwise
   */
  public hasPractitioner(): boolean {
    return isDefined<Reference>(this.practitioner) && !this.practitioner.isEmpty();
  }

  /**
   * @returns the \`organization\` property value as a Reference object; else an empty Reference object
   */
  public getOrganization(): Reference {
    return this.organization ?? new Reference();
  }

  /**
   * Assigns the provided Organization object value to the \`organization\` property.
   *
   * @decorator \`@ReferenceTargets('PractitionerRole.organization', ['Organization',])\`
   *
   * @param value - the \`organization\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('PractitionerRole.organization', [
    'Organization',
  ])
  public setOrganization(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.organization = value;
    } else {
      this.organization = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`organization\` property exists and has a value; \`false\` otherwise
   */
  public hasOrganization(): boolean {
    return isDefined<Reference>(this.organization) && !this.organization.isEmpty();
  }

  /**
   * @returns the \`code\` property value as a CodeableConcept array
   */
  public getCode(): CodeableConcept[] {
    return this.code ?? ([] as CodeableConcept[]);
  }

  /**
   * Assigns the provided CodeableConcept array value to the \`code\` property.
   *
   * @param value - the \`code\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setCode(value: CodeableConcept[] | undefined): this {
    if (isDefinedList<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.code; Provided value array has an element that is not an instance of CodeableConcept.\`;
      assertFhirTypeList<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.code = value;
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeableConcept value to the \`code\` array property.
   *
   * @param value - the \`code\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addCode(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.code; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.initCode();
      this.code?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`code\` property exists and has a value; \`false\` otherwise
   */
  public hasCode(): boolean {
    return isDefinedList<CodeableConcept>(this.code) && this.code.some((item: CodeableConcept) => !item.isEmpty());
  }

  /**
   * Initialize the \`code\` property
   */
  private initCode(): void {
    if(!this.hasCode()) {
      this.code = [] as CodeableConcept[];
    }
  }

  /**
   * @returns the \`specialty\` property value as a CodeableConcept array
   */
  public getSpecialty(): CodeableConcept[] {
    return this.specialty ?? ([] as CodeableConcept[]);
  }

  /**
   * Assigns the provided CodeableConcept array value to the \`specialty\` property.
   *
   * @param value - the \`specialty\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setSpecialty(value: CodeableConcept[] | undefined): this {
    if (isDefinedList<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.specialty; Provided value array has an element that is not an instance of CodeableConcept.\`;
      assertFhirTypeList<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.specialty = value;
    } else {
      this.specialty = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeableConcept value to the \`specialty\` array property.
   *
   * @param value - the \`specialty\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addSpecialty(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.specialty; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.initSpecialty();
      this.specialty?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`specialty\` property exists and has a value; \`false\` otherwise
   */
  public hasSpecialty(): boolean {
    return isDefinedList<CodeableConcept>(this.specialty) && this.specialty.some((item: CodeableConcept) => !item.isEmpty());
  }

  /**
   * Initialize the \`specialty\` property
   */
  private initSpecialty(): void {
    if(!this.hasSpecialty()) {
      this.specialty = [] as CodeableConcept[];
    }
  }

  /**
   * @returns the \`location\` property value as a Reference array
   */
  public getLocation(): Reference[] {
    return this.location ?? ([] as Reference[]);
  }

  /**
   * Assigns the provided Reference array value to the \`location\` property.
   *
   * @decorator \`@ReferenceTargets('PractitionerRole.location', ['Location',])\`
   *
   * @param value - the \`location\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('PractitionerRole.location', [
    'Location',
  ])
  public setLocation(value: Reference[] | undefined): this {
    if (isDefinedList<Reference>(value)) {
      // assertFhirTypeList<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.location = value;
    } else {
      this.location = undefined;
    }
    return this;
  }

  /**
   * Add the provided Reference value to the \`location\` array property.
   *
   * @decorator \`@ReferenceTargets('PractitionerRole.location', ['Location',])\`
   *
   * @param value - the \`location\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('PractitionerRole.location', [
    'Location',
  ])
  public addLocation(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.initLocation();
      this.location?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`location\` property exists and has a value; \`false\` otherwise
   */
  public hasLocation(): boolean {
    return isDefinedList<Reference>(this.location) && this.location.some((item: Reference) => !item.isEmpty());
  }

  /**
   * Initialize the \`location\` property
   */
  private initLocation(): void {
    if (!this.hasLocation()) {
      this.location = [] as Reference[];
    }
  }

  /**
   * @returns the \`healthcareService\` property value as a Reference array
   */
  public getHealthcareService(): Reference[] {
    return this.healthcareService ?? ([] as Reference[]);
  }

  /**
   * Assigns the provided Reference array value to the \`healthcareService\` property.
   *
   * @decorator \`@ReferenceTargets('PractitionerRole.healthcareService', ['HealthcareService',])\`
   *
   * @param value - the \`healthcareService\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('PractitionerRole.healthcareService', [
    'HealthcareService',
  ])
  public setHealthcareService(value: Reference[] | undefined): this {
    if (isDefinedList<Reference>(value)) {
      // assertFhirTypeList<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.healthcareService = value;
    } else {
      this.healthcareService = undefined;
    }
    return this;
  }

  /**
   * Add the provided Reference value to the \`healthcareService\` array property.
   *
   * @decorator \`@ReferenceTargets('PractitionerRole.healthcareService', ['HealthcareService',])\`
   *
   * @param value - the \`healthcareService\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('PractitionerRole.healthcareService', [
    'HealthcareService',
  ])
  public addHealthcareService(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.initHealthcareService();
      this.healthcareService?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`healthcareService\` property exists and has a value; \`false\` otherwise
   */
  public hasHealthcareService(): boolean {
    return isDefinedList<Reference>(this.healthcareService) && this.healthcareService.some((item: Reference) => !item.isEmpty());
  }

  /**
   * Initialize the \`healthcareService\` property
   */
  private initHealthcareService(): void {
    if (!this.hasHealthcareService()) {
      this.healthcareService = [] as Reference[];
    }
  }

  /**
   * @returns the \`telecom\` property value as a ContactPoint array
   */
  public getTelecom(): ContactPoint[] {
    return this.telecom ?? ([] as ContactPoint[]);
  }

  /**
   * Assigns the provided ContactPoint array value to the \`telecom\` property.
   *
   * @param value - the \`telecom\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setTelecom(value: ContactPoint[] | undefined): this {
    if (isDefinedList<ContactPoint>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.telecom; Provided value array has an element that is not an instance of ContactPoint.\`;
      assertFhirTypeList<ContactPoint>(value, ContactPoint, optErrMsg);
      this.telecom = value;
    } else {
      this.telecom = undefined;
    }
    return this;
  }

  /**
   * Add the provided ContactPoint value to the \`telecom\` array property.
   *
   * @param value - the \`telecom\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addTelecom(value: ContactPoint | undefined): this {
    if (isDefined<ContactPoint>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.telecom; Provided element is not an instance of ContactPoint.\`;
      assertFhirType<ContactPoint>(value, ContactPoint, optErrMsg);
      this.initTelecom();
      this.telecom?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`telecom\` property exists and has a value; \`false\` otherwise
   */
  public hasTelecom(): boolean {
    return isDefinedList<ContactPoint>(this.telecom) && this.telecom.some((item: ContactPoint) => !item.isEmpty());
  }

  /**
   * Initialize the \`telecom\` property
   */
  private initTelecom(): void {
    if(!this.hasTelecom()) {
      this.telecom = [] as ContactPoint[];
    }
  }

  /**
   * @returns the \`availableTime\` property value as a PractitionerRoleAvailableTimeComponent array
   */
  public getAvailableTime(): PractitionerRoleAvailableTimeComponent[] {
    return this.availableTime ?? ([] as PractitionerRoleAvailableTimeComponent[]);
  }

  /**
   * Assigns the provided PractitionerRoleAvailableTimeComponent array value to the \`availableTime\` property.
   *
   * @param value - the \`availableTime\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setAvailableTime(value: PractitionerRoleAvailableTimeComponent[] | undefined): this {
    if (isDefinedList<PractitionerRoleAvailableTimeComponent>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.availableTime; Provided value array has an element that is not an instance of PractitionerRoleAvailableTimeComponent.\`;
      assertFhirTypeList<PractitionerRoleAvailableTimeComponent>(value, PractitionerRoleAvailableTimeComponent, optErrMsg);
      this.availableTime = value;
    } else {
      this.availableTime = undefined;
    }
    return this;
  }

  /**
   * Add the provided PractitionerRoleAvailableTimeComponent value to the \`availableTime\` array property.
   *
   * @param value - the \`availableTime\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addAvailableTime(value: PractitionerRoleAvailableTimeComponent | undefined): this {
    if (isDefined<PractitionerRoleAvailableTimeComponent>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.availableTime; Provided element is not an instance of PractitionerRoleAvailableTimeComponent.\`;
      assertFhirType<PractitionerRoleAvailableTimeComponent>(value, PractitionerRoleAvailableTimeComponent, optErrMsg);
      this.initAvailableTime();
      this.availableTime?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`availableTime\` property exists and has a value; \`false\` otherwise
   */
  public hasAvailableTime(): boolean {
    return isDefinedList<PractitionerRoleAvailableTimeComponent>(this.availableTime) && this.availableTime.some((item: PractitionerRoleAvailableTimeComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`availableTime\` property
   */
  private initAvailableTime(): void {
    if(!this.hasAvailableTime()) {
      this.availableTime = [] as PractitionerRoleAvailableTimeComponent[];
    }
  }

  /**
   * @returns the \`notAvailable\` property value as a PractitionerRoleNotAvailableComponent array
   */
  public getNotAvailable(): PractitionerRoleNotAvailableComponent[] {
    return this.notAvailable ?? ([] as PractitionerRoleNotAvailableComponent[]);
  }

  /**
   * Assigns the provided PractitionerRoleNotAvailableComponent array value to the \`notAvailable\` property.
   *
   * @param value - the \`notAvailable\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setNotAvailable(value: PractitionerRoleNotAvailableComponent[] | undefined): this {
    if (isDefinedList<PractitionerRoleNotAvailableComponent>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.notAvailable; Provided value array has an element that is not an instance of PractitionerRoleNotAvailableComponent.\`;
      assertFhirTypeList<PractitionerRoleNotAvailableComponent>(value, PractitionerRoleNotAvailableComponent, optErrMsg);
      this.notAvailable = value;
    } else {
      this.notAvailable = undefined;
    }
    return this;
  }

  /**
   * Add the provided PractitionerRoleNotAvailableComponent value to the \`notAvailable\` array property.
   *
   * @param value - the \`notAvailable\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addNotAvailable(value: PractitionerRoleNotAvailableComponent | undefined): this {
    if (isDefined<PractitionerRoleNotAvailableComponent>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.notAvailable; Provided element is not an instance of PractitionerRoleNotAvailableComponent.\`;
      assertFhirType<PractitionerRoleNotAvailableComponent>(value, PractitionerRoleNotAvailableComponent, optErrMsg);
      this.initNotAvailable();
      this.notAvailable?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`notAvailable\` property exists and has a value; \`false\` otherwise
   */
  public hasNotAvailable(): boolean {
    return isDefinedList<PractitionerRoleNotAvailableComponent>(this.notAvailable) && this.notAvailable.some((item: PractitionerRoleNotAvailableComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`notAvailable\` property
   */
  private initNotAvailable(): void {
    if(!this.hasNotAvailable()) {
      this.notAvailable = [] as PractitionerRoleNotAvailableComponent[];
    }
  }

  /**
   * @returns the \`availabilityExceptions\` property value as a StringType object if defined; else an empty StringType object
   */
  public getAvailabilityExceptionsElement(): StringType {
    return this.availabilityExceptions ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`availabilityExceptions\` property.
   *
   * @param element - the \`availabilityExceptions\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAvailabilityExceptionsElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid PractitionerRole.availabilityExceptions; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.availabilityExceptions = element;
    } else {
      this.availabilityExceptions = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`availabilityExceptions\` property exists and has a value; \`false\` otherwise
   */
  public hasAvailabilityExceptionsElement(): boolean {
    return isDefined<StringType>(this.availabilityExceptions) && !this.availabilityExceptions.isEmpty();
  }

  /**
   * @returns the \`availabilityExceptions\` property value as a fhirString if defined; else undefined
   */
  public getAvailabilityExceptions(): fhirString | undefined {
    return this.availabilityExceptions?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`availabilityExceptions\` property.
   *
   * @param value - the \`availabilityExceptions\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAvailabilityExceptions(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.availabilityExceptions (\${String(value)})\`;
      this.availabilityExceptions = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.availabilityExceptions = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`availabilityExceptions\` property exists and has a value; \`false\` otherwise
   */
  public hasAvailabilityExceptions(): boolean {
    return this.hasAvailabilityExceptionsElement();
  }

  /**
   * @returns the \`endpoint\` property value as a Reference array
   */
  public getEndpoint(): Reference[] {
    return this.endpoint ?? ([] as Reference[]);
  }

  /**
   * Assigns the provided Reference array value to the \`endpoint\` property.
   *
   * @decorator \`@ReferenceTargets('PractitionerRole.endpoint', ['Endpoint',])\`
   *
   * @param value - the \`endpoint\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('PractitionerRole.endpoint', [
    'Endpoint',
  ])
  public setEndpoint(value: Reference[] | undefined): this {
    if (isDefinedList<Reference>(value)) {
      // assertFhirTypeList<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.endpoint = value;
    } else {
      this.endpoint = undefined;
    }
    return this;
  }

  /**
   * Add the provided Reference value to the \`endpoint\` array property.
   *
   * @decorator \`@ReferenceTargets('PractitionerRole.endpoint', ['Endpoint',])\`
   *
   * @param value - the \`endpoint\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('PractitionerRole.endpoint', [
    'Endpoint',
  ])
  public addEndpoint(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.initEndpoint();
      this.endpoint?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`endpoint\` property exists and has a value; \`false\` otherwise
   */
  public hasEndpoint(): boolean {
    return isDefinedList<Reference>(this.endpoint) && this.endpoint.some((item: Reference) => !item.isEmpty());
  }

  /**
   * Initialize the \`endpoint\` property
   */
  private initEndpoint(): void {
    if (!this.hasEndpoint()) {
      this.endpoint = [] as Reference[];
    }
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'PractitionerRole';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.identifier,
      this.active,
      this.period,
      this.practitioner,
      this.organization,
      this.code,
      this.specialty,
      this.location,
      this.healthcareService,
      this.telecom,
      this.availableTime,
      this.notAvailable,
      this.availabilityExceptions,
      this.endpoint,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): PractitionerRole {
    const dest = new PractitionerRole();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: PractitionerRole): void {
    super.copyValues(dest);
    const identifierList = copyListValues<Identifier>(this.identifier);
    dest.identifier = identifierList.length === 0 ? undefined : identifierList;
    dest.active = this.active?.copy();
    dest.period = this.period?.copy();
    dest.practitioner = this.practitioner?.copy();
    dest.organization = this.organization?.copy();
    const codeList = copyListValues<CodeableConcept>(this.code);
    dest.code = codeList.length === 0 ? undefined : codeList;
    const specialtyList = copyListValues<CodeableConcept>(this.specialty);
    dest.specialty = specialtyList.length === 0 ? undefined : specialtyList;
    const locationList = copyListValues<Reference>(this.location);
    dest.location = locationList.length === 0 ? undefined : locationList;
    const healthcareServiceList = copyListValues<Reference>(this.healthcareService);
    dest.healthcareService = healthcareServiceList.length === 0 ? undefined : healthcareServiceList;
    const telecomList = copyListValues<ContactPoint>(this.telecom);
    dest.telecom = telecomList.length === 0 ? undefined : telecomList;
    const availableTimeList = copyListValues<PractitionerRoleAvailableTimeComponent>(this.availableTime);
    dest.availableTime = availableTimeList.length === 0 ? undefined : availableTimeList;
    const notAvailableList = copyListValues<PractitionerRoleNotAvailableComponent>(this.notAvailable);
    dest.notAvailable = notAvailableList.length === 0 ? undefined : notAvailableList;
    dest.availabilityExceptions = this.availabilityExceptions?.copy();
    const endpointList = copyListValues<Reference>(this.endpoint);
    dest.endpoint = endpointList.length === 0 ? undefined : endpointList;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasIdentifier()) {
      setFhirComplexListJson(this.getIdentifier(), 'identifier', jsonObj);
    }

    if (this.hasActiveElement()) {
      setFhirPrimitiveJson<fhirBoolean>(this.getActiveElement(), 'active', jsonObj);
    }

    if (this.hasPeriod()) {
      setFhirComplexJson(this.getPeriod(), 'period', jsonObj);
    }

    if (this.hasPractitioner()) {
      setFhirComplexJson(this.getPractitioner(), 'practitioner', jsonObj);
    }

    if (this.hasOrganization()) {
      setFhirComplexJson(this.getOrganization(), 'organization', jsonObj);
    }

    if (this.hasCode()) {
      setFhirComplexListJson(this.getCode(), 'code', jsonObj);
    }

    if (this.hasSpecialty()) {
      setFhirComplexListJson(this.getSpecialty(), 'specialty', jsonObj);
    }

    if (this.hasLocation()) {
      setFhirComplexListJson(this.getLocation(), 'location', jsonObj);
    }

    if (this.hasHealthcareService()) {
      setFhirComplexListJson(this.getHealthcareService(), 'healthcareService', jsonObj);
    }

    if (this.hasTelecom()) {
      setFhirComplexListJson(this.getTelecom(), 'telecom', jsonObj);
    }

    if (this.hasAvailableTime()) {
      setFhirBackboneElementListJson(this.getAvailableTime(), 'availableTime', jsonObj);
    }

    if (this.hasNotAvailable()) {
      setFhirBackboneElementListJson(this.getNotAvailable(), 'notAvailable', jsonObj);
    }

    if (this.hasAvailabilityExceptionsElement()) {
      setFhirPrimitiveJson<fhirString>(this.getAvailabilityExceptionsElement(), 'availabilityExceptions', jsonObj);
    }

    if (this.hasEndpoint()) {
      setFhirComplexListJson(this.getEndpoint(), 'endpoint', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * PractitionerRoleAvailableTimeComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Times the Service Site is available
 * - **Definition:** A collection of times the practitioner is available or performing this role at the location and/or healthcareservice.
 * - **Comment:** More detailed availability information may be provided in associated Schedule/Slot resources.
 *
 * @category Data Models: Resource
 * @see [FHIR PractitionerRole](http://hl7.org/fhir/StructureDefinition/PractitionerRole)
 */
export class PractitionerRoleAvailableTimeComponent extends BackboneElement implements IBackboneElement {
  constructor() {
    super();

    this.daysOfWeekEnum = new DaysOfWeekEnum();
  }

  /**
   * Parse the provided \`PractitionerRoleAvailableTimeComponent\` JSON to instantiate the PractitionerRoleAvailableTimeComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`PractitionerRoleAvailableTimeComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to PractitionerRoleAvailableTimeComponent
   * @returns PractitionerRoleAvailableTimeComponent data model or undefined for \`PractitionerRoleAvailableTimeComponent\`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): PractitionerRoleAvailableTimeComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'PractitionerRoleAvailableTimeComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new PractitionerRoleAvailableTimeComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'daysOfWeek';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: CodeType | undefined = fhirParser.parseCodeType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addDaysOfWeekElement(datatype);
        }
      });
    }

    fieldName = 'allDay';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'boolean';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: BooleanType | undefined = fhirParser.parseBooleanType(dtJson, dtSiblingJson);
      instance.setAllDayElement(datatype);
    }

    fieldName = 'availableStartTime';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: TimeType | undefined = fhirParser.parseTimeType(dtJson, dtSiblingJson);
      instance.setAvailableStartTimeElement(datatype);
    }

    fieldName = 'availableEndTime';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: TimeType | undefined = fhirParser.parseTimeType(dtJson, dtSiblingJson);
      instance.setAvailableEndTimeElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: DaysOfWeek
   *
   * @see {@link DaysOfWeekEnum }
   */
  private readonly daysOfWeekEnum: DaysOfWeekEnum;

  /**
   * PractitionerRole.availableTime.daysOfWeek Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** mon | tue | wed | thu | fri | sat | sun
   * - **Definition:** Indicates which days of the week are available between the start and end Times.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  private daysOfWeek?: EnumCodeType[] | undefined;

  /**
   * PractitionerRole.availableTime.allDay Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Always available? e.g. 24 hour service
   * - **Definition:** Is this always available? (hence times are irrelevant) e.g. 24 hour service.
   * - **FHIR Type:** \`boolean\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private allDay?: BooleanType | undefined;

  /**
   * PractitionerRole.availableTime.availableStartTime Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Opening time of day (ignored if allDay = true)
   * - **Definition:** The opening time of day. Note: If the AllDay flag is set, then this time is ignored.
   * - **Comment:** The timezone is expected to be for where this HealthcareService is provided at.
   * - **FHIR Type:** \`time\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private availableStartTime?: TimeType | undefined;

  /**
   * PractitionerRole.availableTime.availableEndTime Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Closing time of day (ignored if allDay = true)
   * - **Definition:** The closing time of day. Note: If the AllDay flag is set, then this time is ignored.
   * - **Comment:** The timezone is expected to be for where this HealthcareService is provided at.
   * - **FHIR Type:** \`time\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private availableEndTime?: TimeType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`daysOfWeek\` property value as a EnumCodeType array
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public getDaysOfWeekEnumType(): EnumCodeType[] {
    return this.daysOfWeek ?? ([] as EnumCodeType[]);
  }

  /**
   * Assigns the provided EnumCodeType array value to the \`daysOfWeek\` property.
   *
   * @param enumType - the \`daysOfWeek\` array value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public setDaysOfWeekEnumType(enumType: EnumCodeType[] | undefined): this {
    if (isDefinedList<EnumCodeType>(enumType)) {
      const errMsgPrefix = \`Invalid PractitionerRole.availableTime.daysOfWeek\`;
      assertEnumCodeTypeList<DaysOfWeekEnum>(enumType, DaysOfWeekEnum, errMsgPrefix);
      this.daysOfWeek = enumType;
    } else {
      this.daysOfWeek = undefined;
    }
    return this;
  }

  /**
   * Add the provided EnumCodeType value to the \`daysOfWeek\` array property.
   *
   * @param enumType - the \`daysOfWeek\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public addDaysOfWeekEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = \`Invalid PractitionerRole.availableTime.daysOfWeek\`;
      assertEnumCodeType<DaysOfWeekEnum>(enumType, DaysOfWeekEnum, errMsgPrefix);
      this.initDaysOfWeek();
      this.daysOfWeek?.push(enumType);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`daysOfWeek\` property exists and has a value; \`false\` otherwise
   */
  public hasDaysOfWeekEnumType(): boolean {
    return isDefinedList<EnumCodeType>(this.daysOfWeek) && this.daysOfWeek.some((item: EnumCodeType) => !item.isEmpty()) && this.daysOfWeek.every((item: EnumCodeType) => item.fhirCodeEnumeration.length > 0);
  }

  /**
   * @returns the \`daysOfWeek\` property value as a CodeType array
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public getDaysOfWeekElement(): CodeType[] {
    if (this.daysOfWeek === undefined) {
      return [] as CodeType[];
    }
    return this.daysOfWeek as CodeType[];
  }

  /**
   * Assigns the provided PrimitiveType array value to the \`daysOfWeek\` property.
   *
   * @param element - the \`daysOfWeek\` array value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public setDaysOfWeekElement(element: CodeType[] | undefined): this {
    if (isDefinedList<CodeType>(element)) {
      const optErrMsg = \`Invalid PractitionerRole.availableTime.daysOfWeek; Provided element array has an element that is not an instance of CodeType.\`;
      assertFhirTypeList<CodeType>(element, CodeType, optErrMsg);
      const enumCodeTypes = [] as EnumCodeType[];
      element.forEach((type: CodeType) => {
        enumCodeTypes.push(new EnumCodeType(type, this.daysOfWeekEnum));
      });
      this.daysOfWeek = enumCodeTypes;
    } else {
      this.daysOfWeek = undefined;
    }
    return this;
  }

  /**
   * Add the provided PrimitiveType value to the \`daysOfWeek\` array property.
   *
   * @param element - the \`daysOfWeek\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public addDaysOfWeekElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid PractitionerRole.availableTime.daysOfWeek; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.initDaysOfWeek();
      this.daysOfWeek?.push(new EnumCodeType(element, this.daysOfWeekEnum));
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`daysOfWeek\` property exists and has a value; \`false\` otherwise
   */
  public hasDaysOfWeekElement(): boolean {
    return this.hasDaysOfWeekEnumType();
  }

  /**
   * @returns the \`daysOfWeek\` property value as a fhirCode array
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public getDaysOfWeek(): fhirCode[] {
    if (this.daysOfWeek === undefined) {
      return [] as fhirCode[];
    }
    const values = [] as fhirCode[];
    for (const item of this.daysOfWeek) {
      values.push(item.fhirCode.code);
    }
    return values;
  }

  /**
   * Assigns the provided primitive value array to the \`daysOfWeek\` property.
   *
   * @param value - the \`daysOfWeek\` value array
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public setDaysOfWeek(value: fhirCode[] | undefined): this {
    if (isDefinedList<fhirCode>(value)) {
      const enumCodeTypes = [] as EnumCodeType[];
      const optErrMsg = \`Invalid PractitionerRole.availableTime.daysOfWeek; Provided value is not an instance of fhirCode.\`;
      value.forEach((val: fhirCode) => {
        enumCodeTypes.push(new EnumCodeType(parseFhirPrimitiveData(val, fhirCodeSchema, optErrMsg), this.daysOfWeekEnum));
      });
      this.daysOfWeek = enumCodeTypes;
    } else {
      this.daysOfWeek = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`daysOfWeek\` array property.
   *
   * @param value - the \`daysOfWeek\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public addDaysOfWeek(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      this.initDaysOfWeek();
      const optErrMsg = \`Invalid PractitionerRole.availableTime.daysOfWeek; Provided value is not an instance of fhirCode.\`;
      this.daysOfWeek?.push(new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.daysOfWeekEnum));
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`daysOfWeek\` property exists and has a value; \`false\` otherwise
   */
  public hasDaysOfWeek(): boolean {
    return this.hasDaysOfWeekEnumType();
  }

  /**
   * Initialize the daysOfWeek property
   */
  private initDaysOfWeek(): void {
    if(!this.hasDaysOfWeekEnumType()) {
      this.daysOfWeek = [] as EnumCodeType[];
    }
  }

  /**
   * @returns the \`allDay\` property value as a BooleanType object if defined; else an empty BooleanType object
   */
  public getAllDayElement(): BooleanType {
    return this.allDay ?? new BooleanType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`allDay\` property.
   *
   * @param element - the \`allDay\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAllDayElement(element: BooleanType | undefined): this {
    if (isDefined<BooleanType>(element)) {
      const optErrMsg = \`Invalid PractitionerRole.availableTime.allDay; Provided element is not an instance of BooleanType.\`;
      assertFhirType<BooleanType>(element, BooleanType, optErrMsg);
      this.allDay = element;
    } else {
      this.allDay = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`allDay\` property exists and has a value; \`false\` otherwise
   */
  public hasAllDayElement(): boolean {
    return isDefined<BooleanType>(this.allDay) && !this.allDay.isEmpty();
  }

  /**
   * @returns the \`allDay\` property value as a fhirBoolean if defined; else undefined
   */
  public getAllDay(): fhirBoolean | undefined {
    return this.allDay?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`allDay\` property.
   *
   * @param value - the \`allDay\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAllDay(value: fhirBoolean | undefined): this {
    if (isDefined<fhirBoolean>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.availableTime.allDay (\${String(value)})\`;
      this.allDay = new BooleanType(parseFhirPrimitiveData(value, fhirBooleanSchema, optErrMsg));
    } else {
      this.allDay = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`allDay\` property exists and has a value; \`false\` otherwise
   */
  public hasAllDay(): boolean {
    return this.hasAllDayElement();
  }

  /**
   * @returns the \`availableStartTime\` property value as a TimeType object if defined; else an empty TimeType object
   */
  public getAvailableStartTimeElement(): TimeType {
    return this.availableStartTime ?? new TimeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`availableStartTime\` property.
   *
   * @param element - the \`availableStartTime\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAvailableStartTimeElement(element: TimeType | undefined): this {
    if (isDefined<TimeType>(element)) {
      const optErrMsg = \`Invalid PractitionerRole.availableTime.availableStartTime; Provided element is not an instance of TimeType.\`;
      assertFhirType<TimeType>(element, TimeType, optErrMsg);
      this.availableStartTime = element;
    } else {
      this.availableStartTime = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`availableStartTime\` property exists and has a value; \`false\` otherwise
   */
  public hasAvailableStartTimeElement(): boolean {
    return isDefined<TimeType>(this.availableStartTime) && !this.availableStartTime.isEmpty();
  }

  /**
   * @returns the \`availableStartTime\` property value as a fhirTime if defined; else undefined
   */
  public getAvailableStartTime(): fhirTime | undefined {
    return this.availableStartTime?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`availableStartTime\` property.
   *
   * @param value - the \`availableStartTime\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAvailableStartTime(value: fhirTime | undefined): this {
    if (isDefined<fhirTime>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.availableTime.availableStartTime (\${String(value)})\`;
      this.availableStartTime = new TimeType(parseFhirPrimitiveData(value, fhirTimeSchema, optErrMsg));
    } else {
      this.availableStartTime = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`availableStartTime\` property exists and has a value; \`false\` otherwise
   */
  public hasAvailableStartTime(): boolean {
    return this.hasAvailableStartTimeElement();
  }

  /**
   * @returns the \`availableEndTime\` property value as a TimeType object if defined; else an empty TimeType object
   */
  public getAvailableEndTimeElement(): TimeType {
    return this.availableEndTime ?? new TimeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`availableEndTime\` property.
   *
   * @param element - the \`availableEndTime\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAvailableEndTimeElement(element: TimeType | undefined): this {
    if (isDefined<TimeType>(element)) {
      const optErrMsg = \`Invalid PractitionerRole.availableTime.availableEndTime; Provided element is not an instance of TimeType.\`;
      assertFhirType<TimeType>(element, TimeType, optErrMsg);
      this.availableEndTime = element;
    } else {
      this.availableEndTime = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`availableEndTime\` property exists and has a value; \`false\` otherwise
   */
  public hasAvailableEndTimeElement(): boolean {
    return isDefined<TimeType>(this.availableEndTime) && !this.availableEndTime.isEmpty();
  }

  /**
   * @returns the \`availableEndTime\` property value as a fhirTime if defined; else undefined
   */
  public getAvailableEndTime(): fhirTime | undefined {
    return this.availableEndTime?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`availableEndTime\` property.
   *
   * @param value - the \`availableEndTime\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAvailableEndTime(value: fhirTime | undefined): this {
    if (isDefined<fhirTime>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.availableTime.availableEndTime (\${String(value)})\`;
      this.availableEndTime = new TimeType(parseFhirPrimitiveData(value, fhirTimeSchema, optErrMsg));
    } else {
      this.availableEndTime = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`availableEndTime\` property exists and has a value; \`false\` otherwise
   */
  public hasAvailableEndTime(): boolean {
    return this.hasAvailableEndTimeElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'PractitionerRole.availableTime';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.daysOfWeek,
      this.allDay,
      this.availableStartTime,
      this.availableEndTime,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): PractitionerRoleAvailableTimeComponent {
    const dest = new PractitionerRoleAvailableTimeComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: PractitionerRoleAvailableTimeComponent): void {
    super.copyValues(dest);
    const daysOfWeekList = copyListValues<EnumCodeType>(this.daysOfWeek);
    dest.daysOfWeek = daysOfWeekList.length === 0 ? undefined : daysOfWeekList;
    dest.allDay = this.allDay?.copy();
    dest.availableStartTime = this.availableStartTime?.copy();
    dest.availableEndTime = this.availableEndTime?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasDaysOfWeekElement()) {
      setFhirPrimitiveListJson<fhirCode>(this.getDaysOfWeekElement(), 'daysOfWeek', jsonObj);
    }

    if (this.hasAllDayElement()) {
      setFhirPrimitiveJson<fhirBoolean>(this.getAllDayElement(), 'allDay', jsonObj);
    }

    if (this.hasAvailableStartTimeElement()) {
      setFhirPrimitiveJson<fhirTime>(this.getAvailableStartTimeElement(), 'availableStartTime', jsonObj);
    }

    if (this.hasAvailableEndTimeElement()) {
      setFhirPrimitiveJson<fhirTime>(this.getAvailableEndTimeElement(), 'availableEndTime', jsonObj);
    }

    return jsonObj;
  }
}
/**
 * PractitionerRoleNotAvailableComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Not available during this time due to provided reason
 * - **Definition:** The practitioner is not available or performing this role during this period of time due to the provided reason.
 *
 * @category Data Models: Resource
 * @see [FHIR PractitionerRole](http://hl7.org/fhir/StructureDefinition/PractitionerRole)
 */
export class PractitionerRoleNotAvailableComponent extends BackboneElement implements IBackboneElement {
  constructor(description: StringType | fhirString | null = null) {
    super();

    this.description = null;
    if (isDefined<StringType | fhirString>(description)) {
      if (description instanceof PrimitiveType) {
        this.setDescriptionElement(description);
      } else {
        this.setDescription(description);
      }
    }
  }

  /**
   * Parse the provided \`PractitionerRoleNotAvailableComponent\` JSON to instantiate the PractitionerRoleNotAvailableComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`PractitionerRoleNotAvailableComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to PractitionerRoleNotAvailableComponent
   * @returns PractitionerRoleNotAvailableComponent data model or undefined for \`PractitionerRoleNotAvailableComponent\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): PractitionerRoleNotAvailableComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'PractitionerRoleNotAvailableComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new PractitionerRoleNotAvailableComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    

    const missingReqdProperties: string[] = [];

    fieldName = 'description';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setDescriptionElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'during';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Period | undefined = Period.parse(classJsonObj[fieldName]!, sourceField);
      instance.setDuring(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * PractitionerRole.notAvailable.description Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Reason presented to the user explaining why time not available
   * - **Definition:** The reason that can be presented to the user as to why this time is not available.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private description: StringType | null;

  /**
   * PractitionerRole.notAvailable.during Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Service not available from this date
   * - **Definition:** Service is not available (seasonally or for a public holiday) from this date.
   * - **FHIR Type:** \`Period\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private during?: Period | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`description\` property value as a StringType object if defined; else null
   */
  public getDescriptionElement(): StringType | null {
    return this.description;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`description\` property.
   *
   * @param element - the \`description\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDescriptionElement(element: StringType): this {
    assertIsDefined<StringType>(element, \`PractitionerRole.notAvailable.description is required\`);
    const optErrMsg = \`Invalid PractitionerRole.notAvailable.description; Provided value is not an instance of StringType.\`;
    assertFhirType<StringType>(element, StringType, optErrMsg);
    this.description = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`description\` property exists and has a value; \`false\` otherwise
   */
  public hasDescriptionElement(): boolean {
    return isDefined<StringType>(this.description) && !this.description.isEmpty();
  }

  /**
   * @returns the \`description\` property value as a fhirString if defined; else null
   */
  public getDescription(): fhirString | null {
    if (this.description?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.description.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`description\` property.
   *
   * @param value - the \`description\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDescription(value: fhirString): this {
    assertIsDefined<fhirString>(value, \`PractitionerRole.notAvailable.description is required\`);
    const optErrMsg = \`Invalid PractitionerRole.notAvailable.description (\${String(value)})\`;
    this.description = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`description\` property exists and has a value; \`false\` otherwise
   */
  public hasDescription(): boolean {
    return this.hasDescriptionElement();
  }

  /**
   * @returns the \`during\` property value as a Period object if defined; else an empty Period object
   */
  public getDuring(): Period {
    return this.during ?? new Period();
  }

  /**
   * Assigns the provided During object value to the \`during\` property.
   *
   * @param value - the \`during\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setDuring(value: Period | undefined): this {
    if (isDefined<Period>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.notAvailable.during; Provided element is not an instance of Period.\`;
      assertFhirType<Period>(value, Period, optErrMsg);
      this.during = value;
    } else {
      this.during = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`during\` property exists and has a value; \`false\` otherwise
   */
  public hasDuring(): boolean {
    return isDefined<Period>(this.during) && !this.during.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'PractitionerRole.notAvailable';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.description,
      this.during,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): PractitionerRoleNotAvailableComponent {
    const dest = new PractitionerRoleNotAvailableComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: PractitionerRoleNotAvailableComponent): void {
    super.copyValues(dest);
    dest.description = this.description ? this.description.copy() : null;
    dest.during = this.during?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasDescriptionElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirString>(this.getDescriptionElement()!, 'description', jsonObj);
    } else {
      missingReqdProperties.push(\`PractitionerRole.notAvailable.description\`);
    }

    if (this.hasDuring()) {
      setFhirComplexJson(this.getDuring(), 'during', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
",
  "fileExtension": "ts",
  "filename": "PractitionerRole",
}
`;

exports[`src/generator-app unit test suite generator-app verify generated content should consistently create GeneratedContent[] 17`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator/src/__test__/test-out",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator/src/__test__/utest-cache",
    "pkgName": "utest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "Resource",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * SearchParameter Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/SearchParameter
 * StructureDefinition.name: SearchParameter
 * StructureDefinition.description: A search parameter that defines a named search item that can be used to search/filter on a resource.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  BackboneElement,
  BooleanType,
  CanonicalType,
  CodeType,
  DateTimeType,
  DomainResource,
  EnumCodeType,
  FhirError,
  FhirParser,
  IBackboneElement,
  IDomainResource,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  MarkdownType,
  PrimitiveType,
  PrimitiveTypeJson,
  REQUIRED_PROPERTIES_DO_NOT_EXIST,
  REQUIRED_PROPERTIES_REQD_IN_JSON,
  StringType,
  UriType,
  assertEnumCodeType,
  assertEnumCodeTypeList,
  assertFhirType,
  assertFhirTypeList,
  assertIsDefined,
  assertIsDefinedList,
  constructorCodeValueAsEnumCodeType,
  constructorCodeValueAsEnumCodeTypeList,
  copyListValues,
  fhirBoolean,
  fhirBooleanSchema,
  fhirCanonical,
  fhirCanonicalSchema,
  fhirCode,
  fhirCodeSchema,
  fhirDateTime,
  fhirDateTimeSchema,
  fhirMarkdown,
  fhirMarkdownSchema,
  fhirString,
  fhirStringSchema,
  fhirUri,
  fhirUriSchema,
  getPrimitiveTypeJson,
  getPrimitiveTypeListJson,
  isDefined,
  isDefinedList,
  isElementEmpty,
  isEmpty,
  parseFhirPrimitiveData,
  setFhirBackboneElementListJson,
  setFhirComplexListJson,
  setFhirPrimitiveJson,
  setFhirPrimitiveListJson,
} from '@paq-ts-fhir/fhir-core';
import { CodeableConcept, ContactDetail, PARSABLE_DATATYPE_MAP, UsageContext } from '../complex-types/complex-datatypes';
import { PARSABLE_RESOURCE_MAP } from './parsable-resource-map';
import { PublicationStatusEnum } from '../code-systems/PublicationStatusEnum';
import { ResourceTypesEnum } from '../code-systems/ResourceTypesEnum';
import { SearchComparatorEnum } from '../code-systems/SearchComparatorEnum';
import { SearchModifierCodeEnum } from '../code-systems/SearchModifierCodeEnum';
import { SearchParamTypeEnum } from '../code-systems/SearchParamTypeEnum';

/**
 * SearchParameter Class
 *
 * @remarks
 * A search parameter that defines a named search item that can be used to search/filter on a resource.
 *
 * **FHIR Specification**
 * - **Short:** Search parameter for a resource
 * - **Definition:** A search parameter that defines a named search item that can be used to search/filter on a resource.
 * - **Comment:** In FHIR, search is not performed directly on a resource (by XML or JSON path), but on a named parameter that maps into the resource content.
 * - **FHIR Version:** 4.0.1
 *
 * @category Data Models: Resource
 * @see [FHIR SearchParameter](http://hl7.org/fhir/StructureDefinition/SearchParameter)
 */
export class SearchParameter extends DomainResource implements IDomainResource {
  constructor(url: UriType | fhirUri | null = null, name: StringType | fhirString | null = null, status: EnumCodeType | CodeType | fhirCode | null = null, description: MarkdownType | fhirMarkdown | null = null, code: CodeType | fhirCode | null = null, base: EnumCodeType[] | CodeType[] | fhirCode[] | null = null, type_: EnumCodeType | CodeType | fhirCode | null = null) {
    super();

    this.publicationStatusEnum = new PublicationStatusEnum();
    this.resourceTypesEnum = new ResourceTypesEnum();
    this.searchParamTypeEnum = new SearchParamTypeEnum();
    this.searchComparatorEnum = new SearchComparatorEnum();
    this.searchModifierCodeEnum = new SearchModifierCodeEnum();

    this.url = null;
    if (isDefined<UriType | fhirUri>(url)) {
      if (url instanceof PrimitiveType) {
        this.setUrlElement(url);
      } else {
        this.setUrl(url);
      }
    }

    this.name = null;
    if (isDefined<StringType | fhirString>(name)) {
      if (name instanceof PrimitiveType) {
        this.setNameElement(name);
      } else {
        this.setName(name);
      }
    }

    this.status = constructorCodeValueAsEnumCodeType<PublicationStatusEnum>(
      status,
      PublicationStatusEnum,
      this.publicationStatusEnum,
      'SearchParameter.status',
    );

    this.description = null;
    if (isDefined<MarkdownType | fhirMarkdown>(description)) {
      if (description instanceof PrimitiveType) {
        this.setDescriptionElement(description);
      } else {
        this.setDescription(description);
      }
    }

    this.code = null;
    if (isDefined<CodeType | fhirCode>(code)) {
      if (code instanceof PrimitiveType) {
        this.setCodeElement(code);
      } else {
        this.setCode(code);
      }
    }

    this.base = constructorCodeValueAsEnumCodeTypeList<ResourceTypesEnum>(
      base,
      ResourceTypesEnum,
      this.resourceTypesEnum,
      'SearchParameter.base',
    );

    this.type_ = constructorCodeValueAsEnumCodeType<SearchParamTypeEnum>(
      type_,
      SearchParamTypeEnum,
      this.searchParamTypeEnum,
      'SearchParameter.type',
    );
  }

  /**
   * Parse the provided \`SearchParameter\` JSON to instantiate the SearchParameter data model.
   *
   * @param sourceJson - JSON representing FHIR \`SearchParameter\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to SearchParameter
   * @returns SearchParameter data model or undefined for \`SearchParameter\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static override parse(sourceJson: JSON.Value, optSourceField?: string): SearchParameter | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'SearchParameter';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new SearchParameter();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.verifyResourceType(classJsonObj, 'SearchParameter');
    fhirParser.processDomainResourceJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'url';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = fhirParser.parseUriType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setUrlElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'version';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setVersionElement(datatype);
    }

    fieldName = 'name';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setNameElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'derivedFrom';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CanonicalType | undefined = fhirParser.parseCanonicalType(dtJson, dtSiblingJson);
      instance.setDerivedFromElement(datatype);
    }

    fieldName = 'status';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setStatusElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'experimental';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'boolean';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: BooleanType | undefined = fhirParser.parseBooleanType(dtJson, dtSiblingJson);
      instance.setExperimentalElement(datatype);
    }

    fieldName = 'date';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DateTimeType | undefined = fhirParser.parseDateTimeType(dtJson, dtSiblingJson);
      instance.setDateElement(datatype);
    }

    fieldName = 'publisher';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setPublisherElement(datatype);
    }

    fieldName = 'contact';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: ContactDetail | undefined = ContactDetail.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addContact(datatype);
        }
      });
    }

    fieldName = 'description';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: MarkdownType | undefined = fhirParser.parseMarkdownType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setDescriptionElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'useContext';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: UsageContext | undefined = UsageContext.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addUseContext(datatype);
        }
      });
    }

    fieldName = 'jurisdiction';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: CodeableConcept | undefined = CodeableConcept.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addJurisdiction(datatype);
        }
      });
    }

    fieldName = 'purpose';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: MarkdownType | undefined = fhirParser.parseMarkdownType(dtJson, dtSiblingJson);
      instance.setPurposeElement(datatype);
    }

    fieldName = 'code';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setCodeElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'base';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson, idx) => {
        const datatype: CodeType | undefined = fhirParser.parseCodeType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype === undefined) {
          missingReqdProperties.push(\`\${sourceField}[\${String(idx)}]\`);
        } else {
          instance.addBaseElement(datatype);
        }
      });
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'type';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setTypeElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'expression';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setExpressionElement(datatype);
    }

    fieldName = 'xpath';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setXpathElement(datatype);
    }

    fieldName = 'xpathUsage';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setXpathUsageElement(datatype);
    }

    fieldName = 'target';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: CodeType | undefined = fhirParser.parseCodeType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addTargetElement(datatype);
        }
      });
    }

    fieldName = 'multipleOr';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'boolean';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: BooleanType | undefined = fhirParser.parseBooleanType(dtJson, dtSiblingJson);
      instance.setMultipleOrElement(datatype);
    }

    fieldName = 'multipleAnd';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'boolean';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: BooleanType | undefined = fhirParser.parseBooleanType(dtJson, dtSiblingJson);
      instance.setMultipleAndElement(datatype);
    }

    fieldName = 'comparator';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: CodeType | undefined = fhirParser.parseCodeType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addComparatorElement(datatype);
        }
      });
    }

    fieldName = 'modifier';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: CodeType | undefined = fhirParser.parseCodeType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addModifierElement(datatype);
        }
      });
    }

    fieldName = 'chain';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: StringType | undefined = fhirParser.parseStringType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addChainElement(datatype);
        }
      });
    }

    fieldName = 'component';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const componentJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      componentJsonArray.forEach((componentJson: JSON.Value, idx) => {
        const component: SearchParameterComponentComponent | undefined = SearchParameterComponentComponent.parse(componentJson, \`\${sourceField}[\${String(idx)}]\`);
        if (component !== undefined) {
          instance.addComponent(component);
        }
      });
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * SearchParameter.url Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Canonical identifier for this search parameter, represented as a URI (globally unique)
   * - **Definition:** An absolute URI that is used to identify this search parameter when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this search parameter is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the search parameter is stored on different servers.
   * - **Comment:** Can be a urn:uuid: or a urn:oid: but real http: addresses are preferred.  Multiple instances may share the same URL if they have a distinct version. The determination of when to create a new version of a resource (same url, new version) vs. defining a new artifact is up to the author.  Considerations for making this decision are found in [Technical and Business Versions](https://hl7.org/fhir/resource.html#versions).  In some cases, the resource can no longer be found at the stated url, but the url itself cannot change. Implementations can use the [meta.source](https://hl7.org/fhir/resource.html#meta) element to indicate where the current master source of the resource can be found.
   * - **Requirements:** Allows the search parameter to be referenced by a single globally unique identifier. To allow referencing and reusing search parameter definitions under other names on operational systems (in case of name clash).
   * - **FHIR Type:** \`uri\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private url: UriType | null;

  /**
   * SearchParameter.version Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Business version of the search parameter
   * - **Definition:** The identifier that is used to identify this version of the search parameter when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the search parameter author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
   * - **Comment:** There may be different search parameter instances that have the same identifier but different versions.  The version can be appended to the url in a reference to allow a reference to a particular business version of the search parameter with the format [url]|[version].
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private version?: StringType | undefined;

  /**
   * SearchParameter.name Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Name for this search parameter (computer friendly)
   * - **Definition:** A natural language name identifying the search parameter. This name should be usable as an identifier for the module by machine processing applications such as code generation.
   * - **Comment:** The name is not expected to be globally unique. The name should be a simple alphanumeric type name to ensure that it is machine-processing friendly.
   * - **Requirements:** Support human navigation and code generation.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private name: StringType | null;

  /**
   * SearchParameter.derivedFrom Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Original definition for the search parameter
   * - **Definition:** Where this search parameter is originally defined. If a derivedFrom is provided, then the details in the search parameter must be consistent with the definition from which it is defined. i.e. the parameter should have the same meaning, and (usually) the functionality should be a proper subset of the underlying search parameter.
   * - **Comment:** The intent of this is that a server can designate that it provides support for a search parameter defined in the specification itself (e.g.  [\`value-quantity\`](http://hl7.org/fhir/SearchParameter/Observation-value-quantity), but detail how it is supported by the server.
   * - **FHIR Type:** \`canonical\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/SearchParameter',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private derivedFrom?: CanonicalType | undefined;

  /**
   * FHIR CodeSystem: PublicationStatus
   *
   * @see {@link PublicationStatusEnum }
   */
  private readonly publicationStatusEnum: PublicationStatusEnum;

  /**
   * SearchParameter.status Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** draft | active | retired | unknown
   * - **Definition:** The status of this search parameter. Enables tracking the life-cycle of the content.
   * - **Comment:** Allows filtering of search parameters that are appropriate for use versus not.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 1..1
   * - **isModifier:** true
   * - **isModifierReason:** This is labeled as &quot;Is Modifier&quot; because applications should not use a retired {{title}} without due consideration
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link PublicationStatusEnum }
   */
  private status: EnumCodeType | null;

  /**
   * SearchParameter.experimental Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** For testing purposes, not real usage
   * - **Definition:** A Boolean value to indicate that this search parameter is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
   * - **Comment:** Allows filtering of search parameters that are appropriate for use versus not.
   * - **Requirements:** Enables experimental content to be developed following the same lifecycle that would be used for a production-level search parameter.
   * - **FHIR Type:** \`boolean\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private experimental?: BooleanType | undefined;

  /**
   * SearchParameter.date Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Date last changed
   * - **Definition:** The date  (and optionally time) when the search parameter was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the search parameter changes.
   * - **Comment:** Note that this is not the same as the resource last-modified-date, since the resource may be a secondary representation of the search parameter. Additional specific dates may be added as extensions or be found by consulting Provenances associated with past versions of the resource.
   * - **FHIR Type:** \`dateTime\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private date?: DateTimeType | undefined;

  /**
   * SearchParameter.publisher Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Name of the publisher (organization or individual)
   * - **Definition:** The name of the organization or individual that published the search parameter.
   * - **Comment:** Usually an organization but may be an individual. The publisher (or steward) of the search parameter is the organization or individual primarily responsible for the maintenance and upkeep of the search parameter. This is not necessarily the same individual or organization that developed and initially authored the content. The publisher is the primary point of contact for questions or issues with the search parameter. This item SHOULD be populated unless the information is available from context.
   * - **Requirements:** Helps establish the "authority/credibility" of the search parameter.  May also allow for contact.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private publisher?: StringType | undefined;

  /**
   * SearchParameter.contact Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Contact details for the publisher
   * - **Definition:** Contact details to assist a user in finding and communicating with the publisher.
   * - **Comment:** May be a web site, an email address, a telephone number, etc.
   * - **FHIR Type:** \`ContactDetail\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private contact?: ContactDetail[] | undefined;

  /**
   * SearchParameter.description Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Natural language description of the search parameter
   * - **Definition:** And how it used.
   * - **Comment:** This description can be used to capture details such as why the search parameter was built, comments about misuse, instructions for clinical use and interpretation, literature references, examples from the paper world, etc. It is not a rendering of the search parameter as conveyed in the \\'text\\' field of the resource itself. This item SHOULD be populated unless the information is available from context (e.g. the language of the search parameter is presumed to be the predominant language in the place the search parameter was created).
   * - **FHIR Type:** \`markdown\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private description: MarkdownType | null;

  /**
   * SearchParameter.useContext Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The context that the content is intended to support
   * - **Definition:** The content was developed with a focus and intent of supporting the contexts that are listed. These contexts may be general categories (gender, age, ...) or may be references to specific programs (insurance plans, studies, ...) and may be used to assist with indexing and searching for appropriate search parameter instances.
   * - **Comment:** When multiple useContexts are specified, there is no expectation that all or any of the contexts apply.
   * - **Requirements:** Assist in searching for appropriate content.
   * - **FHIR Type:** \`UsageContext\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private useContext?: UsageContext[] | undefined;

  /**
   * SearchParameter.jurisdiction Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Intended jurisdiction for search parameter (if applicable)
   * - **Definition:** A legal or geographic region in which the search parameter is intended to be used.
   * - **Comment:** It may be possible for the search parameter to be used in jurisdictions other than those for which it was originally designed or intended.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private jurisdiction?: CodeableConcept[] | undefined;

  /**
   * SearchParameter.purpose Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Why this search parameter is defined
   * - **Definition:** Explanation of why this search parameter is needed and why it has been designed as it has.
   * - **Comment:** This element does not describe the usage of the search parameter. Instead, it provides traceability of \\'\\'why\\'\\' the resource is either needed or \\'\\'why\\'\\' it is defined as it is.  This may be used to point to source materials or specifications that drove the structure of this search parameter.
   * - **FHIR Type:** \`markdown\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private purpose?: MarkdownType | undefined;

  /**
   * SearchParameter.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Code used in URL
   * - **Definition:** The code used in the URL or the parameter name in a parameters resource for this search parameter.
   * - **Comment:** For maximum compatibility, use only lowercase ASCII characters.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code: CodeType | null;

  /**
   * FHIR CodeSystem: ResourceTypes
   *
   * @see {@link ResourceTypesEnum }
   */
  private readonly resourceTypesEnum: ResourceTypesEnum;

  /**
   * SearchParameter.base Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The resource type(s) this search parameter applies to
   * - **Definition:** The base resource type(s) that this search parameter can be used against.
   * - **Comment:** A search parameter must always apply to at least one resource type. When search parameters apply to more than one resource type, they can be used against any of the listed resource types, or in a cross-type search (see [Cross Resource Search](https://hl7.org/fhir/http.html#xres-search)).
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 1..*
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link ResourceTypesEnum }
   */
  private base: EnumCodeType[] | null;

  /**
   * FHIR CodeSystem: SearchParamType
   *
   * @see {@link SearchParamTypeEnum }
   */
  private readonly searchParamTypeEnum: SearchParamTypeEnum;

  /**
   * SearchParameter.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** number | date | string | token | reference | composite | quantity | uri | special
   * - **Definition:** The type of value that a search parameter may contain, and how the content is interpreted.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link SearchParamTypeEnum }
   */
  private type_: EnumCodeType | null;

  /**
   * SearchParameter.expression Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** FHIRPath expression that extracts the values
   * - **Definition:** A FHIRPath expression that returns a set of elements for the search parameter.
   * - **Comment:** Note that the elements returned by the expression are sometimes complex elements where logic is required to determine quite how to handle them; e.g. CodeableConcepts may contain text and/or multiple codings, where the codings themselves contain a code and a system. For composite search parameters, the outcome of the expression must a collection of base elements from which the composites are derived.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private expression?: StringType | undefined;

  /**
   * SearchParameter.xpath Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** XPath that extracts the values
   * - **Definition:** An XPath expression that returns a set of elements for the search parameter.
   * - **Comment:** Note that the elements returned by the XPath are sometimes complex elements where logic is required to determine quite how to handle them; e.g. CodeableConcepts may contain text and/or multiple codings, where the codings themselves contain a code and a system.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private xpath?: StringType | undefined;

  /**
   * SearchParameter.xpathUsage Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** normal | phonetic | nearby | distance | other
   * - **Definition:** How the search parameter relates to the set of elements returned by evaluating the xpath query.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private xpathUsage?: CodeType | undefined;

  /**
   * SearchParameter.target Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Types of resource (if a resource reference)
   * - **Definition:** Types of resource (if a resource is referenced).
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   *
   * @see CodeSystem Enumeration: {@link ResourceTypesEnum }
   */
  private target?: EnumCodeType[] | undefined;

  /**
   * SearchParameter.multipleOr Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Allow multiple values per parameter (or)
   * - **Definition:** Whether multiple values are allowed for each time the parameter exists. Values are separated by commas, and the parameter matches if any of the values match.
   * - **FHIR Type:** \`boolean\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private multipleOr?: BooleanType | undefined;

  /**
   * SearchParameter.multipleAnd Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Allow multiple parameters (and)
   * - **Definition:** Whether multiple parameters are allowed - e.g. more than one parameter with the same name. The search matches if all the parameters match.
   * - **FHIR Type:** \`boolean\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private multipleAnd?: BooleanType | undefined;

  /**
   * FHIR CodeSystem: SearchComparator
   *
   * @see {@link SearchComparatorEnum }
   */
  private readonly searchComparatorEnum: SearchComparatorEnum;

  /**
   * SearchParameter.comparator Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** eq | ne | gt | lt | ge | le | sa | eb | ap
   * - **Definition:** Comparators supported for the search parameter.
   * - **Comment:** If no comparators are listed, clients should not expect servers to support any comparators.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   *
   * @see CodeSystem Enumeration: {@link SearchComparatorEnum }
   */
  private comparator?: EnumCodeType[] | undefined;

  /**
   * FHIR CodeSystem: SearchModifierCode
   *
   * @see {@link SearchModifierCodeEnum }
   */
  private readonly searchModifierCodeEnum: SearchModifierCodeEnum;

  /**
   * SearchParameter.modifier Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** missing | exact | contains | not | text | in | not-in | below | above | type | identifier | ofType
   * - **Definition:** A modifier supported for the search parameter.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   *
   * @see CodeSystem Enumeration: {@link SearchModifierCodeEnum }
   */
  private modifier?: EnumCodeType[] | undefined;

  /**
   * SearchParameter.chain Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Chained names supported
   * - **Definition:** Contains the names of any search parameters which may be chained to the containing search parameter. Chained parameters may be added to search parameters of type reference and specify that resources will only be returned if they contain a reference to a resource which matches the chained parameter value. Values for this field should be drawn from SearchParameter.code for a parameter on the target resource type.
   * - **Comment:** Systems are not required to list all the chain names they support, but if they don\\'t list them, clients might not know to use them.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private chain?: StringType[] | undefined;

  /**
   * SearchParameter.component Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** For Composite resources to define the parts
   * - **Definition:** Used to define the parts of a composite search parameter.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private component?: SearchParameterComponentComponent[] | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`url\` property value as a UriType object if defined; else null
   */
  public getUrlElement(): UriType | null {
    return this.url;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`url\` property.
   *
   * @param element - the \`url\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUrlElement(element: UriType): this {
    assertIsDefined<UriType>(element, \`SearchParameter.url is required\`);
    const optErrMsg = \`Invalid SearchParameter.url; Provided value is not an instance of UriType.\`;
    assertFhirType<UriType>(element, UriType, optErrMsg);
    this.url = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`url\` property exists and has a value; \`false\` otherwise
   */
  public hasUrlElement(): boolean {
    return isDefined<UriType>(this.url) && !this.url.isEmpty();
  }

  /**
   * @returns the \`url\` property value as a fhirUri if defined; else null
   */
  public getUrl(): fhirUri | null {
    if (this.url?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.url.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`url\` property.
   *
   * @param value - the \`url\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUrl(value: fhirUri): this {
    assertIsDefined<fhirUri>(value, \`SearchParameter.url is required\`);
    const optErrMsg = \`Invalid SearchParameter.url (\${String(value)})\`;
    this.url = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`url\` property exists and has a value; \`false\` otherwise
   */
  public hasUrl(): boolean {
    return this.hasUrlElement();
  }

  /**
   * @returns the \`version\` property value as a StringType object if defined; else an empty StringType object
   */
  public getVersionElement(): StringType {
    return this.version ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`version\` property.
   *
   * @param element - the \`version\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setVersionElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid SearchParameter.version; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.version = element;
    } else {
      this.version = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`version\` property exists and has a value; \`false\` otherwise
   */
  public hasVersionElement(): boolean {
    return isDefined<StringType>(this.version) && !this.version.isEmpty();
  }

  /**
   * @returns the \`version\` property value as a fhirString if defined; else undefined
   */
  public getVersion(): fhirString | undefined {
    return this.version?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`version\` property.
   *
   * @param value - the \`version\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setVersion(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid SearchParameter.version (\${String(value)})\`;
      this.version = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.version = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`version\` property exists and has a value; \`false\` otherwise
   */
  public hasVersion(): boolean {
    return this.hasVersionElement();
  }

  /**
   * @returns the \`name\` property value as a StringType object if defined; else null
   */
  public getNameElement(): StringType | null {
    return this.name;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`name\` property.
   *
   * @param element - the \`name\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setNameElement(element: StringType): this {
    assertIsDefined<StringType>(element, \`SearchParameter.name is required\`);
    const optErrMsg = \`Invalid SearchParameter.name; Provided value is not an instance of StringType.\`;
    assertFhirType<StringType>(element, StringType, optErrMsg);
    this.name = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`name\` property exists and has a value; \`false\` otherwise
   */
  public hasNameElement(): boolean {
    return isDefined<StringType>(this.name) && !this.name.isEmpty();
  }

  /**
   * @returns the \`name\` property value as a fhirString if defined; else null
   */
  public getName(): fhirString | null {
    if (this.name?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.name.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`name\` property.
   *
   * @param value - the \`name\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setName(value: fhirString): this {
    assertIsDefined<fhirString>(value, \`SearchParameter.name is required\`);
    const optErrMsg = \`Invalid SearchParameter.name (\${String(value)})\`;
    this.name = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`name\` property exists and has a value; \`false\` otherwise
   */
  public hasName(): boolean {
    return this.hasNameElement();
  }

  /**
   * @returns the \`derivedFrom\` property value as a CanonicalType object if defined; else an empty CanonicalType object
   */
  public getDerivedFromElement(): CanonicalType {
    return this.derivedFrom ?? new CanonicalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`derivedFrom\` property.
   *
   * @param element - the \`derivedFrom\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDerivedFromElement(element: CanonicalType | undefined): this {
    if (isDefined<CanonicalType>(element)) {
      const optErrMsg = \`Invalid SearchParameter.derivedFrom; Provided element is not an instance of CanonicalType.\`;
      assertFhirType<CanonicalType>(element, CanonicalType, optErrMsg);
      this.derivedFrom = element;
    } else {
      this.derivedFrom = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`derivedFrom\` property exists and has a value; \`false\` otherwise
   */
  public hasDerivedFromElement(): boolean {
    return isDefined<CanonicalType>(this.derivedFrom) && !this.derivedFrom.isEmpty();
  }

  /**
   * @returns the \`derivedFrom\` property value as a fhirCanonical if defined; else undefined
   */
  public getDerivedFrom(): fhirCanonical | undefined {
    return this.derivedFrom?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`derivedFrom\` property.
   *
   * @param value - the \`derivedFrom\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDerivedFrom(value: fhirCanonical | undefined): this {
    if (isDefined<fhirCanonical>(value)) {
      const optErrMsg = \`Invalid SearchParameter.derivedFrom (\${String(value)})\`;
      this.derivedFrom = new CanonicalType(parseFhirPrimitiveData(value, fhirCanonicalSchema, optErrMsg));
    } else {
      this.derivedFrom = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`derivedFrom\` property exists and has a value; \`false\` otherwise
   */
  public hasDerivedFrom(): boolean {
    return this.hasDerivedFromElement();
  }

  /**
   * @returns the \`status\` property value as a EnumCodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link PublicationStatusEnum }
   */
  public getStatusEnumType(): EnumCodeType | null {
    return this.status;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`status\` property.
   *
   * @param enumType - the \`status\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link PublicationStatusEnum }
   */
  public setStatusEnumType(enumType: EnumCodeType): this {
    assertIsDefined<EnumCodeType>(enumType, \`SearchParameter.status is required\`);
    const errMsgPrefix = \`Invalid SearchParameter.status\`;
    assertEnumCodeType<PublicationStatusEnum>(enumType, PublicationStatusEnum, errMsgPrefix);
    this.status = enumType;
    return this;
  }

  /**
   * @returns \`true\` if the \`status\` property exists and has a value; \`false\` otherwise
   */
  public hasStatusEnumType(): boolean {
    return isDefined<EnumCodeType>(this.status) && !this.status.isEmpty() && this.status.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`status\` property value as a CodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link PublicationStatusEnum }
   */
  public getStatusElement(): CodeType | null {
    if (this.status === null) {
      return null;
    }
    return this.status as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`status\` property.
   *
   * @param element - the \`status\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link PublicationStatusEnum }
   */
  public setStatusElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, \`SearchParameter.status is required\`);
    const optErrMsg = \`Invalid SearchParameter.status; Provided value is not an instance of CodeType.\`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.status = new EnumCodeType(element, this.publicationStatusEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`status\` property exists and has a value; \`false\` otherwise
   */
  public hasStatusElement(): boolean {
    return this.hasStatusEnumType();
  }

  /**
   * @returns the \`status\` property value as a fhirCode if defined; else null
   *
   * @see CodeSystem Enumeration: {@link PublicationStatusEnum }
   */
  public getStatus(): fhirCode | null {
    if (this.status === null) {
      return null;
    }
    return this.status.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`status\` property.
   *
   * @param value - the \`status\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link PublicationStatusEnum }
   */
  public setStatus(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, \`SearchParameter.status is required\`);
    const optErrMsg = \`Invalid SearchParameter.status (\${String(value)})\`;
    this.status = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.publicationStatusEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`status\` property exists and has a value; \`false\` otherwise
   */
  public hasStatus(): boolean {
    return this.hasStatusEnumType();
  }

  /**
   * @returns the \`experimental\` property value as a BooleanType object if defined; else an empty BooleanType object
   */
  public getExperimentalElement(): BooleanType {
    return this.experimental ?? new BooleanType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`experimental\` property.
   *
   * @param element - the \`experimental\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setExperimentalElement(element: BooleanType | undefined): this {
    if (isDefined<BooleanType>(element)) {
      const optErrMsg = \`Invalid SearchParameter.experimental; Provided element is not an instance of BooleanType.\`;
      assertFhirType<BooleanType>(element, BooleanType, optErrMsg);
      this.experimental = element;
    } else {
      this.experimental = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`experimental\` property exists and has a value; \`false\` otherwise
   */
  public hasExperimentalElement(): boolean {
    return isDefined<BooleanType>(this.experimental) && !this.experimental.isEmpty();
  }

  /**
   * @returns the \`experimental\` property value as a fhirBoolean if defined; else undefined
   */
  public getExperimental(): fhirBoolean | undefined {
    return this.experimental?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`experimental\` property.
   *
   * @param value - the \`experimental\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setExperimental(value: fhirBoolean | undefined): this {
    if (isDefined<fhirBoolean>(value)) {
      const optErrMsg = \`Invalid SearchParameter.experimental (\${String(value)})\`;
      this.experimental = new BooleanType(parseFhirPrimitiveData(value, fhirBooleanSchema, optErrMsg));
    } else {
      this.experimental = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`experimental\` property exists and has a value; \`false\` otherwise
   */
  public hasExperimental(): boolean {
    return this.hasExperimentalElement();
  }

  /**
   * @returns the \`date\` property value as a DateTimeType object if defined; else an empty DateTimeType object
   */
  public getDateElement(): DateTimeType {
    return this.date ?? new DateTimeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`date\` property.
   *
   * @param element - the \`date\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDateElement(element: DateTimeType | undefined): this {
    if (isDefined<DateTimeType>(element)) {
      const optErrMsg = \`Invalid SearchParameter.date; Provided element is not an instance of DateTimeType.\`;
      assertFhirType<DateTimeType>(element, DateTimeType, optErrMsg);
      this.date = element;
    } else {
      this.date = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`date\` property exists and has a value; \`false\` otherwise
   */
  public hasDateElement(): boolean {
    return isDefined<DateTimeType>(this.date) && !this.date.isEmpty();
  }

  /**
   * @returns the \`date\` property value as a fhirDateTime if defined; else undefined
   */
  public getDate(): fhirDateTime | undefined {
    return this.date?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`date\` property.
   *
   * @param value - the \`date\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDate(value: fhirDateTime | undefined): this {
    if (isDefined<fhirDateTime>(value)) {
      const optErrMsg = \`Invalid SearchParameter.date (\${String(value)})\`;
      this.date = new DateTimeType(parseFhirPrimitiveData(value, fhirDateTimeSchema, optErrMsg));
    } else {
      this.date = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`date\` property exists and has a value; \`false\` otherwise
   */
  public hasDate(): boolean {
    return this.hasDateElement();
  }

  /**
   * @returns the \`publisher\` property value as a StringType object if defined; else an empty StringType object
   */
  public getPublisherElement(): StringType {
    return this.publisher ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`publisher\` property.
   *
   * @param element - the \`publisher\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPublisherElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid SearchParameter.publisher; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.publisher = element;
    } else {
      this.publisher = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`publisher\` property exists and has a value; \`false\` otherwise
   */
  public hasPublisherElement(): boolean {
    return isDefined<StringType>(this.publisher) && !this.publisher.isEmpty();
  }

  /**
   * @returns the \`publisher\` property value as a fhirString if defined; else undefined
   */
  public getPublisher(): fhirString | undefined {
    return this.publisher?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`publisher\` property.
   *
   * @param value - the \`publisher\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPublisher(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid SearchParameter.publisher (\${String(value)})\`;
      this.publisher = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.publisher = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`publisher\` property exists and has a value; \`false\` otherwise
   */
  public hasPublisher(): boolean {
    return this.hasPublisherElement();
  }

  /**
   * @returns the \`contact\` property value as a ContactDetail array
   */
  public getContact(): ContactDetail[] {
    return this.contact ?? ([] as ContactDetail[]);
  }

  /**
   * Assigns the provided ContactDetail array value to the \`contact\` property.
   *
   * @param value - the \`contact\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setContact(value: ContactDetail[] | undefined): this {
    if (isDefinedList<ContactDetail>(value)) {
      const optErrMsg = \`Invalid SearchParameter.contact; Provided value array has an element that is not an instance of ContactDetail.\`;
      assertFhirTypeList<ContactDetail>(value, ContactDetail, optErrMsg);
      this.contact = value;
    } else {
      this.contact = undefined;
    }
    return this;
  }

  /**
   * Add the provided ContactDetail value to the \`contact\` array property.
   *
   * @param value - the \`contact\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addContact(value: ContactDetail | undefined): this {
    if (isDefined<ContactDetail>(value)) {
      const optErrMsg = \`Invalid SearchParameter.contact; Provided element is not an instance of ContactDetail.\`;
      assertFhirType<ContactDetail>(value, ContactDetail, optErrMsg);
      this.initContact();
      this.contact?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`contact\` property exists and has a value; \`false\` otherwise
   */
  public hasContact(): boolean {
    return isDefinedList<ContactDetail>(this.contact) && this.contact.some((item: ContactDetail) => !item.isEmpty());
  }

  /**
   * Initialize the \`contact\` property
   */
  private initContact(): void {
    if(!this.hasContact()) {
      this.contact = [] as ContactDetail[];
    }
  }

  /**
   * @returns the \`description\` property value as a MarkdownType object if defined; else null
   */
  public getDescriptionElement(): MarkdownType | null {
    return this.description;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`description\` property.
   *
   * @param element - the \`description\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDescriptionElement(element: MarkdownType): this {
    assertIsDefined<MarkdownType>(element, \`SearchParameter.description is required\`);
    const optErrMsg = \`Invalid SearchParameter.description; Provided value is not an instance of MarkdownType.\`;
    assertFhirType<MarkdownType>(element, MarkdownType, optErrMsg);
    this.description = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`description\` property exists and has a value; \`false\` otherwise
   */
  public hasDescriptionElement(): boolean {
    return isDefined<MarkdownType>(this.description) && !this.description.isEmpty();
  }

  /**
   * @returns the \`description\` property value as a fhirMarkdown if defined; else null
   */
  public getDescription(): fhirMarkdown | null {
    if (this.description?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.description.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`description\` property.
   *
   * @param value - the \`description\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDescription(value: fhirMarkdown): this {
    assertIsDefined<fhirMarkdown>(value, \`SearchParameter.description is required\`);
    const optErrMsg = \`Invalid SearchParameter.description (\${String(value)})\`;
    this.description = new MarkdownType(parseFhirPrimitiveData(value, fhirMarkdownSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`description\` property exists and has a value; \`false\` otherwise
   */
  public hasDescription(): boolean {
    return this.hasDescriptionElement();
  }

  /**
   * @returns the \`useContext\` property value as a UsageContext array
   */
  public getUseContext(): UsageContext[] {
    return this.useContext ?? ([] as UsageContext[]);
  }

  /**
   * Assigns the provided UsageContext array value to the \`useContext\` property.
   *
   * @param value - the \`useContext\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setUseContext(value: UsageContext[] | undefined): this {
    if (isDefinedList<UsageContext>(value)) {
      const optErrMsg = \`Invalid SearchParameter.useContext; Provided value array has an element that is not an instance of UsageContext.\`;
      assertFhirTypeList<UsageContext>(value, UsageContext, optErrMsg);
      this.useContext = value;
    } else {
      this.useContext = undefined;
    }
    return this;
  }

  /**
   * Add the provided UsageContext value to the \`useContext\` array property.
   *
   * @param value - the \`useContext\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addUseContext(value: UsageContext | undefined): this {
    if (isDefined<UsageContext>(value)) {
      const optErrMsg = \`Invalid SearchParameter.useContext; Provided element is not an instance of UsageContext.\`;
      assertFhirType<UsageContext>(value, UsageContext, optErrMsg);
      this.initUseContext();
      this.useContext?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`useContext\` property exists and has a value; \`false\` otherwise
   */
  public hasUseContext(): boolean {
    return isDefinedList<UsageContext>(this.useContext) && this.useContext.some((item: UsageContext) => !item.isEmpty());
  }

  /**
   * Initialize the \`useContext\` property
   */
  private initUseContext(): void {
    if(!this.hasUseContext()) {
      this.useContext = [] as UsageContext[];
    }
  }

  /**
   * @returns the \`jurisdiction\` property value as a CodeableConcept array
   */
  public getJurisdiction(): CodeableConcept[] {
    return this.jurisdiction ?? ([] as CodeableConcept[]);
  }

  /**
   * Assigns the provided CodeableConcept array value to the \`jurisdiction\` property.
   *
   * @param value - the \`jurisdiction\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setJurisdiction(value: CodeableConcept[] | undefined): this {
    if (isDefinedList<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid SearchParameter.jurisdiction; Provided value array has an element that is not an instance of CodeableConcept.\`;
      assertFhirTypeList<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.jurisdiction = value;
    } else {
      this.jurisdiction = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeableConcept value to the \`jurisdiction\` array property.
   *
   * @param value - the \`jurisdiction\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addJurisdiction(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid SearchParameter.jurisdiction; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.initJurisdiction();
      this.jurisdiction?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`jurisdiction\` property exists and has a value; \`false\` otherwise
   */
  public hasJurisdiction(): boolean {
    return isDefinedList<CodeableConcept>(this.jurisdiction) && this.jurisdiction.some((item: CodeableConcept) => !item.isEmpty());
  }

  /**
   * Initialize the \`jurisdiction\` property
   */
  private initJurisdiction(): void {
    if(!this.hasJurisdiction()) {
      this.jurisdiction = [] as CodeableConcept[];
    }
  }

  /**
   * @returns the \`purpose\` property value as a MarkdownType object if defined; else an empty MarkdownType object
   */
  public getPurposeElement(): MarkdownType {
    return this.purpose ?? new MarkdownType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`purpose\` property.
   *
   * @param element - the \`purpose\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPurposeElement(element: MarkdownType | undefined): this {
    if (isDefined<MarkdownType>(element)) {
      const optErrMsg = \`Invalid SearchParameter.purpose; Provided element is not an instance of MarkdownType.\`;
      assertFhirType<MarkdownType>(element, MarkdownType, optErrMsg);
      this.purpose = element;
    } else {
      this.purpose = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`purpose\` property exists and has a value; \`false\` otherwise
   */
  public hasPurposeElement(): boolean {
    return isDefined<MarkdownType>(this.purpose) && !this.purpose.isEmpty();
  }

  /**
   * @returns the \`purpose\` property value as a fhirMarkdown if defined; else undefined
   */
  public getPurpose(): fhirMarkdown | undefined {
    return this.purpose?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`purpose\` property.
   *
   * @param value - the \`purpose\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPurpose(value: fhirMarkdown | undefined): this {
    if (isDefined<fhirMarkdown>(value)) {
      const optErrMsg = \`Invalid SearchParameter.purpose (\${String(value)})\`;
      this.purpose = new MarkdownType(parseFhirPrimitiveData(value, fhirMarkdownSchema, optErrMsg));
    } else {
      this.purpose = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`purpose\` property exists and has a value; \`false\` otherwise
   */
  public hasPurpose(): boolean {
    return this.hasPurposeElement();
  }

  /**
   * @returns the \`code\` property value as a CodeType object if defined; else null
   */
  public getCodeElement(): CodeType | null {
    return this.code;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`code\` property.
   *
   * @param element - the \`code\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCodeElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, \`SearchParameter.code is required\`);
    const optErrMsg = \`Invalid SearchParameter.code; Provided value is not an instance of CodeType.\`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.code = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`code\` property exists and has a value; \`false\` otherwise
   */
  public hasCodeElement(): boolean {
    return isDefined<CodeType>(this.code) && !this.code.isEmpty();
  }

  /**
   * @returns the \`code\` property value as a fhirCode if defined; else null
   */
  public getCode(): fhirCode | null {
    if (this.code?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.code.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`code\` property.
   *
   * @param value - the \`code\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCode(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, \`SearchParameter.code is required\`);
    const optErrMsg = \`Invalid SearchParameter.code (\${String(value)})\`;
    this.code = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`code\` property exists and has a value; \`false\` otherwise
   */
  public hasCode(): boolean {
    return this.hasCodeElement();
  }

  /**
   * @returns the \`base\` property value as a EnumCodeType array
   *
   * @see CodeSystem Enumeration: {@link ResourceTypesEnum }
   */
  public getBaseEnumType(): EnumCodeType[] {
    return this.base ?? ([] as EnumCodeType[]);
  }

  /**
   * Assigns the provided EnumCodeType array value to the \`base\` property.
   *
   * @param enumType - the \`base\` array value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ResourceTypesEnum }
   */
  public setBaseEnumType(enumType: EnumCodeType[]): this {
    assertIsDefinedList<EnumCodeType>(enumType, \`SearchParameter.base is required\`);
    const errMsgPrefix = \`Invalid SearchParameter.base\`;
    assertEnumCodeTypeList<ResourceTypesEnum>(enumType, ResourceTypesEnum, errMsgPrefix);
    this.base = enumType;
    return this;
  }

  /**
   * Add the provided EnumCodeType value to the \`base\` array property.
   *
   * @param enumType - the \`base\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ResourceTypesEnum }
   */
  public addBaseEnumType(enumType: EnumCodeType): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = \`Invalid SearchParameter.base\`;
      assertEnumCodeType<ResourceTypesEnum>(enumType, ResourceTypesEnum, errMsgPrefix);
      this.initBase();
      this.base?.push(enumType);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`base\` property exists and has a value; \`false\` otherwise
   */
  public hasBaseEnumType(): boolean {
    return isDefinedList<EnumCodeType>(this.base) && this.base.some((item: EnumCodeType) => !item.isEmpty()) && this.base.every((item: EnumCodeType) => item.fhirCodeEnumeration.length > 0);
  }

  /**
   * @returns the \`base\` property value as a CodeType array
   *
   * @see CodeSystem Enumeration: {@link ResourceTypesEnum }
   */
  public getBaseElement(): CodeType[] {
    if (this.base === null) {
      return [] as CodeType[];
    }
    return this.base as CodeType[];
  }

  /**
   * Assigns the provided PrimitiveType array value to the \`base\` property.
   *
   * @param element - the \`base\` array value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ResourceTypesEnum }
   */
  public setBaseElement(element: CodeType[]): this {
    assertIsDefinedList<CodeType>(element, \`SearchParameter.base is required\`);
    const optErrMsg = \`Invalid SearchParameter.base; Provided element array has an element that is not an instance of CodeType.\`;
    assertFhirTypeList<CodeType>(element, CodeType, optErrMsg);
    const enumCodeTypes = [] as EnumCodeType[];
    element.forEach((type: CodeType) => {
      enumCodeTypes.push(new EnumCodeType(type, this.resourceTypesEnum));
    });
    this.base = enumCodeTypes;
    return this;
  }

  /**
   * Add the provided PrimitiveType value to the \`base\` array property.
   *
   * @param element - the \`base\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ResourceTypesEnum }
   */
  public addBaseElement(element: CodeType): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid SearchParameter.base; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.initBase();
      this.base?.push(new EnumCodeType(element, this.resourceTypesEnum));
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`base\` property exists and has a value; \`false\` otherwise
   */
  public hasBaseElement(): boolean {
    return this.hasBaseEnumType();
  }

  /**
   * @returns the \`base\` property value as a fhirCode array
   *
   * @see CodeSystem Enumeration: {@link ResourceTypesEnum }
   */
  public getBase(): fhirCode[] {
    if (this.base === null) {
      return [] as fhirCode[];
    }
    const values = [] as fhirCode[];
    for (const item of this.base) {
      values.push(item.fhirCode.code);
    }
    return values;
  }

  /**
   * Assigns the provided primitive value array to the \`base\` property.
   *
   * @param value - the \`base\` value array
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link ResourceTypesEnum }
   */
  public setBase(value: fhirCode[]): this {
    assertIsDefinedList<fhirCode>(value, \`SearchParameter.base is required\`);
    const enumCodeTypes = [] as EnumCodeType[];
    const optErrMsg = \`Invalid SearchParameter.base; Provided value is not an instance of fhirCode.\`;
    value.forEach((val: fhirCode) => {
      enumCodeTypes.push(new EnumCodeType(parseFhirPrimitiveData(val, fhirCodeSchema, optErrMsg), this.resourceTypesEnum));
    });
    this.base = enumCodeTypes;
    return this;
  }

  /**
   * Add the provided primitive value to the \`base\` array property.
   *
   * @param value - the \`base\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link ResourceTypesEnum }
   */
  public addBase(value: fhirCode): this {
    if (isDefined<fhirCode>(value)) {
      this.initBase();
      const optErrMsg = \`Invalid SearchParameter.base; Provided value is not an instance of fhirCode.\`;
      this.base?.push(new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.resourceTypesEnum));
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`base\` property exists and has a value; \`false\` otherwise
   */
  public hasBase(): boolean {
    return this.hasBaseEnumType();
  }

  /**
   * Initialize the base property
   */
  private initBase(): void {
    if(!this.hasBaseEnumType()) {
      this.base = [] as EnumCodeType[];
    }
  }

  /**
   * @returns the \`type_\` property value as a EnumCodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link SearchParamTypeEnum }
   */
  public getTypeEnumType(): EnumCodeType | null {
    return this.type_;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`type_\` property.
   *
   * @param enumType - the \`type_\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link SearchParamTypeEnum }
   */
  public setTypeEnumType(enumType: EnumCodeType): this {
    assertIsDefined<EnumCodeType>(enumType, \`SearchParameter.type is required\`);
    const errMsgPrefix = \`Invalid SearchParameter.type\`;
    assertEnumCodeType<SearchParamTypeEnum>(enumType, SearchParamTypeEnum, errMsgPrefix);
    this.type_ = enumType;
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasTypeEnumType(): boolean {
    return isDefined<EnumCodeType>(this.type_) && !this.type_.isEmpty() && this.type_.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`type_\` property value as a CodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link SearchParamTypeEnum }
   */
  public getTypeElement(): CodeType | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_ as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`type_\` property.
   *
   * @param element - the \`type_\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link SearchParamTypeEnum }
   */
  public setTypeElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, \`SearchParameter.type is required\`);
    const optErrMsg = \`Invalid SearchParameter.type; Provided value is not an instance of CodeType.\`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.type_ = new EnumCodeType(element, this.searchParamTypeEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasTypeElement(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the \`type_\` property value as a fhirCode if defined; else null
   *
   * @see CodeSystem Enumeration: {@link SearchParamTypeEnum }
   */
  public getType(): fhirCode | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`type_\` property.
   *
   * @param value - the \`type_\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link SearchParamTypeEnum }
   */
  public setType(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, \`SearchParameter.type is required\`);
    const optErrMsg = \`Invalid SearchParameter.type (\${String(value)})\`;
    this.type_ = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.searchParamTypeEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasType(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the \`expression\` property value as a StringType object if defined; else an empty StringType object
   */
  public getExpressionElement(): StringType {
    return this.expression ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`expression\` property.
   *
   * @param element - the \`expression\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setExpressionElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid SearchParameter.expression; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.expression = element;
    } else {
      this.expression = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`expression\` property exists and has a value; \`false\` otherwise
   */
  public hasExpressionElement(): boolean {
    return isDefined<StringType>(this.expression) && !this.expression.isEmpty();
  }

  /**
   * @returns the \`expression\` property value as a fhirString if defined; else undefined
   */
  public getExpression(): fhirString | undefined {
    return this.expression?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`expression\` property.
   *
   * @param value - the \`expression\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setExpression(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid SearchParameter.expression (\${String(value)})\`;
      this.expression = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.expression = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`expression\` property exists and has a value; \`false\` otherwise
   */
  public hasExpression(): boolean {
    return this.hasExpressionElement();
  }

  /**
   * @returns the \`xpath\` property value as a StringType object if defined; else an empty StringType object
   */
  public getXpathElement(): StringType {
    return this.xpath ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`xpath\` property.
   *
   * @param element - the \`xpath\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setXpathElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid SearchParameter.xpath; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.xpath = element;
    } else {
      this.xpath = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`xpath\` property exists and has a value; \`false\` otherwise
   */
  public hasXpathElement(): boolean {
    return isDefined<StringType>(this.xpath) && !this.xpath.isEmpty();
  }

  /**
   * @returns the \`xpath\` property value as a fhirString if defined; else undefined
   */
  public getXpath(): fhirString | undefined {
    return this.xpath?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`xpath\` property.
   *
   * @param value - the \`xpath\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setXpath(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid SearchParameter.xpath (\${String(value)})\`;
      this.xpath = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.xpath = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`xpath\` property exists and has a value; \`false\` otherwise
   */
  public hasXpath(): boolean {
    return this.hasXpathElement();
  }

  /**
   * @returns the \`xpathUsage\` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getXpathUsageElement(): CodeType {
    return this.xpathUsage ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`xpathUsage\` property.
   *
   * @param element - the \`xpathUsage\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setXpathUsageElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid SearchParameter.xpathUsage; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.xpathUsage = element;
    } else {
      this.xpathUsage = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`xpathUsage\` property exists and has a value; \`false\` otherwise
   */
  public hasXpathUsageElement(): boolean {
    return isDefined<CodeType>(this.xpathUsage) && !this.xpathUsage.isEmpty();
  }

  /**
   * @returns the \`xpathUsage\` property value as a fhirCode if defined; else undefined
   */
  public getXpathUsage(): fhirCode | undefined {
    return this.xpathUsage?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`xpathUsage\` property.
   *
   * @param value - the \`xpathUsage\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setXpathUsage(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid SearchParameter.xpathUsage (\${String(value)})\`;
      this.xpathUsage = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.xpathUsage = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`xpathUsage\` property exists and has a value; \`false\` otherwise
   */
  public hasXpathUsage(): boolean {
    return this.hasXpathUsageElement();
  }

  /**
   * @returns the \`target\` property value as a EnumCodeType array
   *
   * @see CodeSystem Enumeration: {@link ResourceTypesEnum }
   */
  public getTargetEnumType(): EnumCodeType[] {
    return this.target ?? ([] as EnumCodeType[]);
  }

  /**
   * Assigns the provided EnumCodeType array value to the \`target\` property.
   *
   * @param enumType - the \`target\` array value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ResourceTypesEnum }
   */
  public setTargetEnumType(enumType: EnumCodeType[] | undefined): this {
    if (isDefinedList<EnumCodeType>(enumType)) {
      const errMsgPrefix = \`Invalid SearchParameter.target\`;
      assertEnumCodeTypeList<ResourceTypesEnum>(enumType, ResourceTypesEnum, errMsgPrefix);
      this.target = enumType;
    } else {
      this.target = undefined;
    }
    return this;
  }

  /**
   * Add the provided EnumCodeType value to the \`target\` array property.
   *
   * @param enumType - the \`target\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   *
   * @see CodeSystem Enumeration: {@link ResourceTypesEnum }
   */
  public addTargetEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = \`Invalid SearchParameter.target\`;
      assertEnumCodeType<ResourceTypesEnum>(enumType, ResourceTypesEnum, errMsgPrefix);
      this.initTarget();
      this.target?.push(enumType);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`target\` property exists and has a value; \`false\` otherwise
   */
  public hasTargetEnumType(): boolean {
    return isDefinedList<EnumCodeType>(this.target) && this.target.some((item: EnumCodeType) => !item.isEmpty()) && this.target.every((item: EnumCodeType) => item.fhirCodeEnumeration.length > 0);
  }

  /**
   * @returns the \`target\` property value as a CodeType array
   *
   * @see CodeSystem Enumeration: {@link ResourceTypesEnum }
   */
  public getTargetElement(): CodeType[] {
    if (this.target === undefined) {
      return [] as CodeType[];
    }
    return this.target as CodeType[];
  }

  /**
   * Assigns the provided PrimitiveType array value to the \`target\` property.
   *
   * @param element - the \`target\` array value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ResourceTypesEnum }
   */
  public setTargetElement(element: CodeType[] | undefined): this {
    if (isDefinedList<CodeType>(element)) {
      const optErrMsg = \`Invalid SearchParameter.target; Provided element array has an element that is not an instance of CodeType.\`;
      assertFhirTypeList<CodeType>(element, CodeType, optErrMsg);
      const enumCodeTypes = [] as EnumCodeType[];
      element.forEach((type: CodeType) => {
        enumCodeTypes.push(new EnumCodeType(type, this.resourceTypesEnum));
      });
      this.target = enumCodeTypes;
    } else {
      this.target = undefined;
    }
    return this;
  }

  /**
   * Add the provided PrimitiveType value to the \`target\` array property.
   *
   * @param element - the \`target\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ResourceTypesEnum }
   */
  public addTargetElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid SearchParameter.target; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.initTarget();
      this.target?.push(new EnumCodeType(element, this.resourceTypesEnum));
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`target\` property exists and has a value; \`false\` otherwise
   */
  public hasTargetElement(): boolean {
    return this.hasTargetEnumType();
  }

  /**
   * @returns the \`target\` property value as a fhirCode array
   *
   * @see CodeSystem Enumeration: {@link ResourceTypesEnum }
   */
  public getTarget(): fhirCode[] {
    if (this.target === undefined) {
      return [] as fhirCode[];
    }
    const values = [] as fhirCode[];
    for (const item of this.target) {
      values.push(item.fhirCode.code);
    }
    return values;
  }

  /**
   * Assigns the provided primitive value array to the \`target\` property.
   *
   * @param value - the \`target\` value array
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link ResourceTypesEnum }
   */
  public setTarget(value: fhirCode[] | undefined): this {
    if (isDefinedList<fhirCode>(value)) {
      const enumCodeTypes = [] as EnumCodeType[];
      const optErrMsg = \`Invalid SearchParameter.target; Provided value is not an instance of fhirCode.\`;
      value.forEach((val: fhirCode) => {
        enumCodeTypes.push(new EnumCodeType(parseFhirPrimitiveData(val, fhirCodeSchema, optErrMsg), this.resourceTypesEnum));
      });
      this.target = enumCodeTypes;
    } else {
      this.target = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`target\` array property.
   *
   * @param value - the \`target\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link ResourceTypesEnum }
   */
  public addTarget(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      this.initTarget();
      const optErrMsg = \`Invalid SearchParameter.target; Provided value is not an instance of fhirCode.\`;
      this.target?.push(new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.resourceTypesEnum));
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`target\` property exists and has a value; \`false\` otherwise
   */
  public hasTarget(): boolean {
    return this.hasTargetEnumType();
  }

  /**
   * Initialize the target property
   */
  private initTarget(): void {
    if(!this.hasTargetEnumType()) {
      this.target = [] as EnumCodeType[];
    }
  }

  /**
   * @returns the \`multipleOr\` property value as a BooleanType object if defined; else an empty BooleanType object
   */
  public getMultipleOrElement(): BooleanType {
    return this.multipleOr ?? new BooleanType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`multipleOr\` property.
   *
   * @param element - the \`multipleOr\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMultipleOrElement(element: BooleanType | undefined): this {
    if (isDefined<BooleanType>(element)) {
      const optErrMsg = \`Invalid SearchParameter.multipleOr; Provided element is not an instance of BooleanType.\`;
      assertFhirType<BooleanType>(element, BooleanType, optErrMsg);
      this.multipleOr = element;
    } else {
      this.multipleOr = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`multipleOr\` property exists and has a value; \`false\` otherwise
   */
  public hasMultipleOrElement(): boolean {
    return isDefined<BooleanType>(this.multipleOr) && !this.multipleOr.isEmpty();
  }

  /**
   * @returns the \`multipleOr\` property value as a fhirBoolean if defined; else undefined
   */
  public getMultipleOr(): fhirBoolean | undefined {
    return this.multipleOr?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`multipleOr\` property.
   *
   * @param value - the \`multipleOr\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMultipleOr(value: fhirBoolean | undefined): this {
    if (isDefined<fhirBoolean>(value)) {
      const optErrMsg = \`Invalid SearchParameter.multipleOr (\${String(value)})\`;
      this.multipleOr = new BooleanType(parseFhirPrimitiveData(value, fhirBooleanSchema, optErrMsg));
    } else {
      this.multipleOr = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`multipleOr\` property exists and has a value; \`false\` otherwise
   */
  public hasMultipleOr(): boolean {
    return this.hasMultipleOrElement();
  }

  /**
   * @returns the \`multipleAnd\` property value as a BooleanType object if defined; else an empty BooleanType object
   */
  public getMultipleAndElement(): BooleanType {
    return this.multipleAnd ?? new BooleanType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`multipleAnd\` property.
   *
   * @param element - the \`multipleAnd\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMultipleAndElement(element: BooleanType | undefined): this {
    if (isDefined<BooleanType>(element)) {
      const optErrMsg = \`Invalid SearchParameter.multipleAnd; Provided element is not an instance of BooleanType.\`;
      assertFhirType<BooleanType>(element, BooleanType, optErrMsg);
      this.multipleAnd = element;
    } else {
      this.multipleAnd = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`multipleAnd\` property exists and has a value; \`false\` otherwise
   */
  public hasMultipleAndElement(): boolean {
    return isDefined<BooleanType>(this.multipleAnd) && !this.multipleAnd.isEmpty();
  }

  /**
   * @returns the \`multipleAnd\` property value as a fhirBoolean if defined; else undefined
   */
  public getMultipleAnd(): fhirBoolean | undefined {
    return this.multipleAnd?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`multipleAnd\` property.
   *
   * @param value - the \`multipleAnd\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMultipleAnd(value: fhirBoolean | undefined): this {
    if (isDefined<fhirBoolean>(value)) {
      const optErrMsg = \`Invalid SearchParameter.multipleAnd (\${String(value)})\`;
      this.multipleAnd = new BooleanType(parseFhirPrimitiveData(value, fhirBooleanSchema, optErrMsg));
    } else {
      this.multipleAnd = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`multipleAnd\` property exists and has a value; \`false\` otherwise
   */
  public hasMultipleAnd(): boolean {
    return this.hasMultipleAndElement();
  }

  /**
   * @returns the \`comparator\` property value as a EnumCodeType array
   *
   * @see CodeSystem Enumeration: {@link SearchComparatorEnum }
   */
  public getComparatorEnumType(): EnumCodeType[] {
    return this.comparator ?? ([] as EnumCodeType[]);
  }

  /**
   * Assigns the provided EnumCodeType array value to the \`comparator\` property.
   *
   * @param enumType - the \`comparator\` array value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link SearchComparatorEnum }
   */
  public setComparatorEnumType(enumType: EnumCodeType[] | undefined): this {
    if (isDefinedList<EnumCodeType>(enumType)) {
      const errMsgPrefix = \`Invalid SearchParameter.comparator\`;
      assertEnumCodeTypeList<SearchComparatorEnum>(enumType, SearchComparatorEnum, errMsgPrefix);
      this.comparator = enumType;
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * Add the provided EnumCodeType value to the \`comparator\` array property.
   *
   * @param enumType - the \`comparator\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   *
   * @see CodeSystem Enumeration: {@link SearchComparatorEnum }
   */
  public addComparatorEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = \`Invalid SearchParameter.comparator\`;
      assertEnumCodeType<SearchComparatorEnum>(enumType, SearchComparatorEnum, errMsgPrefix);
      this.initComparator();
      this.comparator?.push(enumType);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`comparator\` property exists and has a value; \`false\` otherwise
   */
  public hasComparatorEnumType(): boolean {
    return isDefinedList<EnumCodeType>(this.comparator) && this.comparator.some((item: EnumCodeType) => !item.isEmpty()) && this.comparator.every((item: EnumCodeType) => item.fhirCodeEnumeration.length > 0);
  }

  /**
   * @returns the \`comparator\` property value as a CodeType array
   *
   * @see CodeSystem Enumeration: {@link SearchComparatorEnum }
   */
  public getComparatorElement(): CodeType[] {
    if (this.comparator === undefined) {
      return [] as CodeType[];
    }
    return this.comparator as CodeType[];
  }

  /**
   * Assigns the provided PrimitiveType array value to the \`comparator\` property.
   *
   * @param element - the \`comparator\` array value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link SearchComparatorEnum }
   */
  public setComparatorElement(element: CodeType[] | undefined): this {
    if (isDefinedList<CodeType>(element)) {
      const optErrMsg = \`Invalid SearchParameter.comparator; Provided element array has an element that is not an instance of CodeType.\`;
      assertFhirTypeList<CodeType>(element, CodeType, optErrMsg);
      const enumCodeTypes = [] as EnumCodeType[];
      element.forEach((type: CodeType) => {
        enumCodeTypes.push(new EnumCodeType(type, this.searchComparatorEnum));
      });
      this.comparator = enumCodeTypes;
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * Add the provided PrimitiveType value to the \`comparator\` array property.
   *
   * @param element - the \`comparator\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link SearchComparatorEnum }
   */
  public addComparatorElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid SearchParameter.comparator; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.initComparator();
      this.comparator?.push(new EnumCodeType(element, this.searchComparatorEnum));
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`comparator\` property exists and has a value; \`false\` otherwise
   */
  public hasComparatorElement(): boolean {
    return this.hasComparatorEnumType();
  }

  /**
   * @returns the \`comparator\` property value as a fhirCode array
   *
   * @see CodeSystem Enumeration: {@link SearchComparatorEnum }
   */
  public getComparator(): fhirCode[] {
    if (this.comparator === undefined) {
      return [] as fhirCode[];
    }
    const values = [] as fhirCode[];
    for (const item of this.comparator) {
      values.push(item.fhirCode.code);
    }
    return values;
  }

  /**
   * Assigns the provided primitive value array to the \`comparator\` property.
   *
   * @param value - the \`comparator\` value array
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link SearchComparatorEnum }
   */
  public setComparator(value: fhirCode[] | undefined): this {
    if (isDefinedList<fhirCode>(value)) {
      const enumCodeTypes = [] as EnumCodeType[];
      const optErrMsg = \`Invalid SearchParameter.comparator; Provided value is not an instance of fhirCode.\`;
      value.forEach((val: fhirCode) => {
        enumCodeTypes.push(new EnumCodeType(parseFhirPrimitiveData(val, fhirCodeSchema, optErrMsg), this.searchComparatorEnum));
      });
      this.comparator = enumCodeTypes;
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`comparator\` array property.
   *
   * @param value - the \`comparator\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link SearchComparatorEnum }
   */
  public addComparator(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      this.initComparator();
      const optErrMsg = \`Invalid SearchParameter.comparator; Provided value is not an instance of fhirCode.\`;
      this.comparator?.push(new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.searchComparatorEnum));
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`comparator\` property exists and has a value; \`false\` otherwise
   */
  public hasComparator(): boolean {
    return this.hasComparatorEnumType();
  }

  /**
   * Initialize the comparator property
   */
  private initComparator(): void {
    if(!this.hasComparatorEnumType()) {
      this.comparator = [] as EnumCodeType[];
    }
  }

  /**
   * @returns the \`modifier\` property value as a EnumCodeType array
   *
   * @see CodeSystem Enumeration: {@link SearchModifierCodeEnum }
   */
  public getModifierEnumType(): EnumCodeType[] {
    return this.modifier ?? ([] as EnumCodeType[]);
  }

  /**
   * Assigns the provided EnumCodeType array value to the \`modifier\` property.
   *
   * @param enumType - the \`modifier\` array value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link SearchModifierCodeEnum }
   */
  public setModifierEnumType(enumType: EnumCodeType[] | undefined): this {
    if (isDefinedList<EnumCodeType>(enumType)) {
      const errMsgPrefix = \`Invalid SearchParameter.modifier\`;
      assertEnumCodeTypeList<SearchModifierCodeEnum>(enumType, SearchModifierCodeEnum, errMsgPrefix);
      this.modifier = enumType;
    } else {
      this.modifier = undefined;
    }
    return this;
  }

  /**
   * Add the provided EnumCodeType value to the \`modifier\` array property.
   *
   * @param enumType - the \`modifier\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   *
   * @see CodeSystem Enumeration: {@link SearchModifierCodeEnum }
   */
  public addModifierEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = \`Invalid SearchParameter.modifier\`;
      assertEnumCodeType<SearchModifierCodeEnum>(enumType, SearchModifierCodeEnum, errMsgPrefix);
      this.initModifier();
      this.modifier?.push(enumType);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`modifier\` property exists and has a value; \`false\` otherwise
   */
  public hasModifierEnumType(): boolean {
    return isDefinedList<EnumCodeType>(this.modifier) && this.modifier.some((item: EnumCodeType) => !item.isEmpty()) && this.modifier.every((item: EnumCodeType) => item.fhirCodeEnumeration.length > 0);
  }

  /**
   * @returns the \`modifier\` property value as a CodeType array
   *
   * @see CodeSystem Enumeration: {@link SearchModifierCodeEnum }
   */
  public getModifierElement(): CodeType[] {
    if (this.modifier === undefined) {
      return [] as CodeType[];
    }
    return this.modifier as CodeType[];
  }

  /**
   * Assigns the provided PrimitiveType array value to the \`modifier\` property.
   *
   * @param element - the \`modifier\` array value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link SearchModifierCodeEnum }
   */
  public setModifierElement(element: CodeType[] | undefined): this {
    if (isDefinedList<CodeType>(element)) {
      const optErrMsg = \`Invalid SearchParameter.modifier; Provided element array has an element that is not an instance of CodeType.\`;
      assertFhirTypeList<CodeType>(element, CodeType, optErrMsg);
      const enumCodeTypes = [] as EnumCodeType[];
      element.forEach((type: CodeType) => {
        enumCodeTypes.push(new EnumCodeType(type, this.searchModifierCodeEnum));
      });
      this.modifier = enumCodeTypes;
    } else {
      this.modifier = undefined;
    }
    return this;
  }

  /**
   * Add the provided PrimitiveType value to the \`modifier\` array property.
   *
   * @param element - the \`modifier\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link SearchModifierCodeEnum }
   */
  public addModifierElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid SearchParameter.modifier; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.initModifier();
      this.modifier?.push(new EnumCodeType(element, this.searchModifierCodeEnum));
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`modifier\` property exists and has a value; \`false\` otherwise
   */
  public hasModifierElement(): boolean {
    return this.hasModifierEnumType();
  }

  /**
   * @returns the \`modifier\` property value as a fhirCode array
   *
   * @see CodeSystem Enumeration: {@link SearchModifierCodeEnum }
   */
  public getModifier(): fhirCode[] {
    if (this.modifier === undefined) {
      return [] as fhirCode[];
    }
    const values = [] as fhirCode[];
    for (const item of this.modifier) {
      values.push(item.fhirCode.code);
    }
    return values;
  }

  /**
   * Assigns the provided primitive value array to the \`modifier\` property.
   *
   * @param value - the \`modifier\` value array
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link SearchModifierCodeEnum }
   */
  public setModifier(value: fhirCode[] | undefined): this {
    if (isDefinedList<fhirCode>(value)) {
      const enumCodeTypes = [] as EnumCodeType[];
      const optErrMsg = \`Invalid SearchParameter.modifier; Provided value is not an instance of fhirCode.\`;
      value.forEach((val: fhirCode) => {
        enumCodeTypes.push(new EnumCodeType(parseFhirPrimitiveData(val, fhirCodeSchema, optErrMsg), this.searchModifierCodeEnum));
      });
      this.modifier = enumCodeTypes;
    } else {
      this.modifier = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`modifier\` array property.
   *
   * @param value - the \`modifier\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link SearchModifierCodeEnum }
   */
  public addModifier(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      this.initModifier();
      const optErrMsg = \`Invalid SearchParameter.modifier; Provided value is not an instance of fhirCode.\`;
      this.modifier?.push(new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.searchModifierCodeEnum));
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`modifier\` property exists and has a value; \`false\` otherwise
   */
  public hasModifier(): boolean {
    return this.hasModifierEnumType();
  }

  /**
   * Initialize the modifier property
   */
  private initModifier(): void {
    if(!this.hasModifierEnumType()) {
      this.modifier = [] as EnumCodeType[];
    }
  }

  /**
   * @returns the \`chain\` property value as a StringType array
   */
  public getChainElement(): StringType[] {
    return this.chain ?? ([] as StringType[]);
  }

  /**
   * Assigns the provided StringType array value to the \`chain\` property.
   *
   * @param element - the \`chain\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setChainElement(element: StringType[] | undefined): this {
    if (isDefinedList<StringType>(element)) {
      const optErrMsg = \`Invalid SearchParameter.chain; Provided value array has an element that is not an instance of StringType.\`;
      assertFhirTypeList<StringType>(element, StringType, optErrMsg);
      this.chain = element;
    } else {
      this.chain = undefined;
    }
    return this;
  }

  /**
   * Add the provided StringType value to the \`chain\` array property.
   *
   * @param element - the \`chain\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addChainElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid SearchParameter.chain; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.initChain();
      this.chain?.push(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`chain\` property exists and has a value; \`false\` otherwise
   */
  public hasChainElement(): boolean {
    return isDefinedList<StringType>(this.chain) && this.chain.some((item: StringType) => !item.isEmpty());
  }

  /**
   * @returns the \`chain\` property value as a fhirString array
   */
  public getChain(): fhirString[] {
    this.initChain();
    const chainValues = [] as fhirString[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.chain!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        chainValues.push(value);
      }
    }
    return chainValues;
  }

  /**
   * Assigns the provided primitive value array to the \`chain\` property.
   *
   * @param value - the \`chain\` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setChain(value: fhirString[] | undefined): this {
    if (isDefinedList<fhirString>(value)) {
      const chainElements = [] as StringType[];
      for (const chainValue of value) {
        const optErrMsg = \`Invalid SearchParameter.chain array item (\${String(chainValue)})\`;
        const element = new StringType(parseFhirPrimitiveData(chainValue, fhirStringSchema, optErrMsg));
        chainElements.push(element);
      }
      this.chain = chainElements;
    } else {
      this.chain = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`chain\` array property.
   *
   * @param value - the \`chain\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addChain(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid SearchParameter.chain array item (\${String(value)})\`;
      const element = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
      this.initChain();
      this.addChainElement(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`chain\` property exists and has a value; \`false\` otherwise
   */
  public hasChain(): boolean {
    return this.hasChainElement();
  }

  /**
   * Initialize the \`chain\` property
   */
  private initChain(): void {
    if (!this.hasChain()) {
      this.chain = [] as StringType[];
    }
  }

  /**
   * @returns the \`component\` property value as a SearchParameterComponentComponent array
   */
  public getComponent(): SearchParameterComponentComponent[] {
    return this.component ?? ([] as SearchParameterComponentComponent[]);
  }

  /**
   * Assigns the provided SearchParameterComponentComponent array value to the \`component\` property.
   *
   * @param value - the \`component\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setComponent(value: SearchParameterComponentComponent[] | undefined): this {
    if (isDefinedList<SearchParameterComponentComponent>(value)) {
      const optErrMsg = \`Invalid SearchParameter.component; Provided value array has an element that is not an instance of SearchParameterComponentComponent.\`;
      assertFhirTypeList<SearchParameterComponentComponent>(value, SearchParameterComponentComponent, optErrMsg);
      this.component = value;
    } else {
      this.component = undefined;
    }
    return this;
  }

  /**
   * Add the provided SearchParameterComponentComponent value to the \`component\` array property.
   *
   * @param value - the \`component\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addComponent(value: SearchParameterComponentComponent | undefined): this {
    if (isDefined<SearchParameterComponentComponent>(value)) {
      const optErrMsg = \`Invalid SearchParameter.component; Provided element is not an instance of SearchParameterComponentComponent.\`;
      assertFhirType<SearchParameterComponentComponent>(value, SearchParameterComponentComponent, optErrMsg);
      this.initComponent();
      this.component?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`component\` property exists and has a value; \`false\` otherwise
   */
  public hasComponent(): boolean {
    return isDefinedList<SearchParameterComponentComponent>(this.component) && this.component.some((item: SearchParameterComponentComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`component\` property
   */
  private initComponent(): void {
    if(!this.hasComponent()) {
      this.component = [] as SearchParameterComponentComponent[];
    }
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'SearchParameter';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.url,
      this.version,
      this.name,
      this.derivedFrom,
      this.status,
      this.experimental,
      this.date,
      this.publisher,
      this.contact,
      this.description,
      this.useContext,
      this.jurisdiction,
      this.purpose,
      this.code,
      this.base,
      this.type_,
      this.expression,
      this.xpath,
      this.xpathUsage,
      this.target,
      this.multipleOr,
      this.multipleAnd,
      this.comparator,
      this.modifier,
      this.chain,
      this.component,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): SearchParameter {
    const dest = new SearchParameter();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: SearchParameter): void {
    super.copyValues(dest);
    dest.url = this.url ? this.url.copy() : null;
    dest.version = this.version?.copy();
    dest.name = this.name ? this.name.copy() : null;
    dest.derivedFrom = this.derivedFrom?.copy();
    dest.status = this.status ? this.status.copy() : null;
    dest.experimental = this.experimental?.copy();
    dest.date = this.date?.copy();
    dest.publisher = this.publisher?.copy();
    const contactList = copyListValues<ContactDetail>(this.contact);
    dest.contact = contactList.length === 0 ? undefined : contactList;
    dest.description = this.description ? this.description.copy() : null;
    const useContextList = copyListValues<UsageContext>(this.useContext);
    dest.useContext = useContextList.length === 0 ? undefined : useContextList;
    const jurisdictionList = copyListValues<CodeableConcept>(this.jurisdiction);
    dest.jurisdiction = jurisdictionList.length === 0 ? undefined : jurisdictionList;
    dest.purpose = this.purpose?.copy();
    dest.code = this.code ? this.code.copy() : null;
    const baseList = copyListValues<EnumCodeType>(this.base);
    dest.base = baseList.length === 0 ? null : baseList;
    dest.type_ = this.type_ ? this.type_.copy() : null;
    dest.expression = this.expression?.copy();
    dest.xpath = this.xpath?.copy();
    dest.xpathUsage = this.xpathUsage?.copy();
    const targetList = copyListValues<EnumCodeType>(this.target);
    dest.target = targetList.length === 0 ? undefined : targetList;
    dest.multipleOr = this.multipleOr?.copy();
    dest.multipleAnd = this.multipleAnd?.copy();
    const comparatorList = copyListValues<EnumCodeType>(this.comparator);
    dest.comparator = comparatorList.length === 0 ? undefined : comparatorList;
    const modifierList = copyListValues<EnumCodeType>(this.modifier);
    dest.modifier = modifierList.length === 0 ? undefined : modifierList;
    const chainList = copyListValues<StringType>(this.chain);
    dest.chain = chainList.length === 0 ? undefined : chainList;
    const componentList = copyListValues<SearchParameterComponentComponent>(this.component);
    dest.component = componentList.length === 0 ? undefined : componentList;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasUrlElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirUri>(this.getUrlElement()!, 'url', jsonObj);
    } else {
      missingReqdProperties.push(\`SearchParameter.url\`);
    }

    if (this.hasVersionElement()) {
      setFhirPrimitiveJson<fhirString>(this.getVersionElement(), 'version', jsonObj);
    }

    if (this.hasNameElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirString>(this.getNameElement()!, 'name', jsonObj);
    } else {
      missingReqdProperties.push(\`SearchParameter.name\`);
    }

    if (this.hasDerivedFromElement()) {
      setFhirPrimitiveJson<fhirCanonical>(this.getDerivedFromElement(), 'derivedFrom', jsonObj);
    }

    if (this.hasStatusElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getStatusElement()!, 'status', jsonObj);
    } else {
      missingReqdProperties.push(\`SearchParameter.status\`);
    }

    if (this.hasExperimentalElement()) {
      setFhirPrimitiveJson<fhirBoolean>(this.getExperimentalElement(), 'experimental', jsonObj);
    }

    if (this.hasDateElement()) {
      setFhirPrimitiveJson<fhirDateTime>(this.getDateElement(), 'date', jsonObj);
    }

    if (this.hasPublisherElement()) {
      setFhirPrimitiveJson<fhirString>(this.getPublisherElement(), 'publisher', jsonObj);
    }

    if (this.hasContact()) {
      setFhirComplexListJson(this.getContact(), 'contact', jsonObj);
    }

    if (this.hasDescriptionElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirMarkdown>(this.getDescriptionElement()!, 'description', jsonObj);
    } else {
      missingReqdProperties.push(\`SearchParameter.description\`);
    }

    if (this.hasUseContext()) {
      setFhirComplexListJson(this.getUseContext(), 'useContext', jsonObj);
    }

    if (this.hasJurisdiction()) {
      setFhirComplexListJson(this.getJurisdiction(), 'jurisdiction', jsonObj);
    }

    if (this.hasPurposeElement()) {
      setFhirPrimitiveJson<fhirMarkdown>(this.getPurposeElement(), 'purpose', jsonObj);
    }

    if (this.hasCodeElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getCodeElement()!, 'code', jsonObj);
    } else {
      missingReqdProperties.push(\`SearchParameter.code\`);
    }

    if (this.hasBaseElement()) {
      setFhirPrimitiveListJson<fhirCode>(this.getBaseElement(), 'base', jsonObj);
    } else {
      missingReqdProperties.push(\`SearchParameter.base\`);
    }

    if (this.hasTypeElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getTypeElement()!, 'type', jsonObj);
    } else {
      missingReqdProperties.push(\`SearchParameter.type\`);
    }

    if (this.hasExpressionElement()) {
      setFhirPrimitiveJson<fhirString>(this.getExpressionElement(), 'expression', jsonObj);
    }

    if (this.hasXpathElement()) {
      setFhirPrimitiveJson<fhirString>(this.getXpathElement(), 'xpath', jsonObj);
    }

    if (this.hasXpathUsageElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getXpathUsageElement(), 'xpathUsage', jsonObj);
    }

    if (this.hasTargetElement()) {
      setFhirPrimitiveListJson<fhirCode>(this.getTargetElement(), 'target', jsonObj);
    }

    if (this.hasMultipleOrElement()) {
      setFhirPrimitiveJson<fhirBoolean>(this.getMultipleOrElement(), 'multipleOr', jsonObj);
    }

    if (this.hasMultipleAndElement()) {
      setFhirPrimitiveJson<fhirBoolean>(this.getMultipleAndElement(), 'multipleAnd', jsonObj);
    }

    if (this.hasComparatorElement()) {
      setFhirPrimitiveListJson<fhirCode>(this.getComparatorElement(), 'comparator', jsonObj);
    }

    if (this.hasModifierElement()) {
      setFhirPrimitiveListJson<fhirCode>(this.getModifierElement(), 'modifier', jsonObj);
    }

    if (this.hasChain()) {
      setFhirPrimitiveListJson(this.getChainElement(), 'chain', jsonObj);
    }

    if (this.hasComponent()) {
      setFhirBackboneElementListJson(this.getComponent(), 'component', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

/**
 * SearchParameterComponentComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** For Composite resources to define the parts
 * - **Definition:** Used to define the parts of a composite search parameter.
 *
 * @category Data Models: Resource
 * @see [FHIR SearchParameter](http://hl7.org/fhir/StructureDefinition/SearchParameter)
 */
export class SearchParameterComponentComponent extends BackboneElement implements IBackboneElement {
  constructor(definition: CanonicalType | fhirCanonical | null = null, expression: StringType | fhirString | null = null) {
    super();

    this.definition = null;
    if (isDefined<CanonicalType | fhirCanonical>(definition)) {
      if (definition instanceof PrimitiveType) {
        this.setDefinitionElement(definition);
      } else {
        this.setDefinition(definition);
      }
    }

    this.expression = null;
    if (isDefined<StringType | fhirString>(expression)) {
      if (expression instanceof PrimitiveType) {
        this.setExpressionElement(expression);
      } else {
        this.setExpression(expression);
      }
    }
  }

  /**
   * Parse the provided \`SearchParameterComponentComponent\` JSON to instantiate the SearchParameterComponentComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`SearchParameterComponentComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to SearchParameterComponentComponent
   * @returns SearchParameterComponentComponent data model or undefined for \`SearchParameterComponentComponent\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): SearchParameterComponentComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'SearchParameterComponentComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new SearchParameterComponentComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'definition';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CanonicalType | undefined = fhirParser.parseCanonicalType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setDefinitionElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'expression';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setExpressionElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * SearchParameter.component.definition Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Defines how the part works
   * - **Definition:** The definition of the search parameter that describes this part.
   * - **FHIR Type:** \`canonical\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/SearchParameter',
   *     ]
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private definition: CanonicalType | null;

  /**
   * SearchParameter.component.expression Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Subexpression relative to main expression
   * - **Definition:** A sub-expression that defines how to extract values for this component from the output of the main SearchParameter.expression.
   * - **Comment:** This expression overrides the expression in the definition and extracts the index values from the outcome of the composite expression.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private expression: StringType | null;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`definition\` property value as a CanonicalType object if defined; else null
   */
  public getDefinitionElement(): CanonicalType | null {
    return this.definition;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`definition\` property.
   *
   * @param element - the \`definition\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDefinitionElement(element: CanonicalType): this {
    assertIsDefined<CanonicalType>(element, \`SearchParameter.component.definition is required\`);
    const optErrMsg = \`Invalid SearchParameter.component.definition; Provided value is not an instance of CanonicalType.\`;
    assertFhirType<CanonicalType>(element, CanonicalType, optErrMsg);
    this.definition = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`definition\` property exists and has a value; \`false\` otherwise
   */
  public hasDefinitionElement(): boolean {
    return isDefined<CanonicalType>(this.definition) && !this.definition.isEmpty();
  }

  /**
   * @returns the \`definition\` property value as a fhirCanonical if defined; else null
   */
  public getDefinition(): fhirCanonical | null {
    if (this.definition?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.definition.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`definition\` property.
   *
   * @param value - the \`definition\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDefinition(value: fhirCanonical): this {
    assertIsDefined<fhirCanonical>(value, \`SearchParameter.component.definition is required\`);
    const optErrMsg = \`Invalid SearchParameter.component.definition (\${String(value)})\`;
    this.definition = new CanonicalType(parseFhirPrimitiveData(value, fhirCanonicalSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`definition\` property exists and has a value; \`false\` otherwise
   */
  public hasDefinition(): boolean {
    return this.hasDefinitionElement();
  }

  /**
   * @returns the \`expression\` property value as a StringType object if defined; else null
   */
  public getExpressionElement(): StringType | null {
    return this.expression;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`expression\` property.
   *
   * @param element - the \`expression\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setExpressionElement(element: StringType): this {
    assertIsDefined<StringType>(element, \`SearchParameter.component.expression is required\`);
    const optErrMsg = \`Invalid SearchParameter.component.expression; Provided value is not an instance of StringType.\`;
    assertFhirType<StringType>(element, StringType, optErrMsg);
    this.expression = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`expression\` property exists and has a value; \`false\` otherwise
   */
  public hasExpressionElement(): boolean {
    return isDefined<StringType>(this.expression) && !this.expression.isEmpty();
  }

  /**
   * @returns the \`expression\` property value as a fhirString if defined; else null
   */
  public getExpression(): fhirString | null {
    if (this.expression?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.expression.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`expression\` property.
   *
   * @param value - the \`expression\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setExpression(value: fhirString): this {
    assertIsDefined<fhirString>(value, \`SearchParameter.component.expression is required\`);
    const optErrMsg = \`Invalid SearchParameter.component.expression (\${String(value)})\`;
    this.expression = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`expression\` property exists and has a value; \`false\` otherwise
   */
  public hasExpression(): boolean {
    return this.hasExpressionElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'SearchParameter.component';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.definition,
      this.expression,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): SearchParameterComponentComponent {
    const dest = new SearchParameterComponentComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: SearchParameterComponentComponent): void {
    super.copyValues(dest);
    dest.definition = this.definition ? this.definition.copy() : null;
    dest.expression = this.expression ? this.expression.copy() : null;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasDefinitionElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCanonical>(this.getDefinitionElement()!, 'definition', jsonObj);
    } else {
      missingReqdProperties.push(\`SearchParameter.component.definition\`);
    }

    if (this.hasExpressionElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirString>(this.getExpressionElement()!, 'expression', jsonObj);
    } else {
      missingReqdProperties.push(\`SearchParameter.component.expression\`);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
",
  "fileExtension": "ts",
  "filename": "SearchParameter",
}
`;

exports[`src/generator-app unit test suite generator-app verify generated content should consistently create GeneratedContent[] 18`] = `
{
  "fhirCoreImports": Set {
    "import { Resource, ParsableResource } from '@paq-ts-fhir/fhir-core';",
  },
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator/src/__test__/test-out",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator/src/__test__/utest-cache",
    "pkgName": "utest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "Resource",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated by the FHIR Data Model Generator.
 * DO NOT make any modifications!
 * 
 * parsable-resource-map.ts Module
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { Resource, ParsableResource } from '@paq-ts-fhir/fhir-core';
import { Bundle } from './Bundle';
import { PractitionerRole } from './PractitionerRole';
import { SearchParameter } from './SearchParameter';

/**
 * PARSABLE_RESOURCE_MAP
 *
 * @remarks
 * Map of all parsable Resources where the key is the name of the Resource and the value is its ParsableResource<Resource> class.
 *
 * @internal
 */
export const PARSABLE_RESOURCE_MAP = new Map<string, ParsableResource<Resource>>();
PARSABLE_RESOURCE_MAP.set('Bundle', Bundle);
PARSABLE_RESOURCE_MAP.set('PractitionerRole', PractitionerRole);
PARSABLE_RESOURCE_MAP.set('SearchParameter', SearchParameter);
",
  "fileExtension": "ts",
  "filename": "parsable-resource-map",
  "generatedImports": Set {
    "import { Bundle } from './Bundle';",
    "import { PractitionerRole } from './PractitionerRole';",
    "import { SearchParameter } from './SearchParameter';",
  },
}
`;
