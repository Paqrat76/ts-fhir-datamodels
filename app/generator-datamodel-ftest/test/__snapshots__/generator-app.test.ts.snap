// Jest Snapshot v1, https://jestjs.io/docs/snapshot-testing

exports[`generator-datamodel-ftest Functional Test Suite generator-app generate and write should generate and write all FHIR R4 artifacts from ftest-cache FHIR cache 1`] = `
"/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated by the FHIR Data Model Generator.
 * DO NOT make any modifications!
 * 
 * index.ts Module
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @module Library Index
 */

export {
  Base,
  Element,
  BackboneElement,
  DataType,
  BackboneType,
  PrimitiveType,
  Resource,
  DomainResource,
  DateTimeUtil,
  Base64BinaryType,
  BooleanType,
  CanonicalType,
  CodeType,
  EnumCodeType,
  DateTimeType,
  DateType,
  DecimalType,
  FhirCodeDefinition,
  FhirError,
  IdType,
  InstantType,
  Integer64Type,
  IntegerType,
  InvalidCodeError,
  InvalidDateTimeError,
  InvalidTypeError,
  JsonError,
  MarkdownType,
  OidType,
  PositiveIntType,
  PrimitiveTypeError,
  StringType,
  TimeType,
  UnsignedIntType,
  UriType,
  UrlType,
  UuidType,
  XhtmlType,
} from '@paq-ts-fhir/fhir-core';
export type {
  IBase,
  IElement,
  IExtension,
  IBackboneElement,
  IDataType,
  IBackboneType,
  IPrimitiveType,
  IResource,
  IDomainResource,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  DateTypeImpl,
  DateTimeTypeImpl,
  InstantTypeImpl,
  fhirBase64Binary,
  fhirBoolean,
  fhirCanonical,
  fhirCode,
  fhirDateTime,
  fhirDate,
  fhirDecimal,
  fhirId,
  fhirInstant,
  fhirInteger64,
  fhirInteger,
  fhirMarkdown,
  fhirOid,
  fhirPositiveInt,
  fhirString,
  fhirTime,
  fhirUnsignedInt,
  fhirUri,
  fhirUrl,
  fhirUuid,
  fhirXhtml,
} from '@paq-ts-fhir/fhir-core';

export * from './code-systems/AddressTypeEnum';
export * from './code-systems/AddressUseEnum';
export * from './code-systems/AdministrativeGenderEnum';
export * from './code-systems/BundleTypeEnum';
export * from './code-systems/ConsentStateCodesEnum';
export * from './code-systems/ContactPointSystemEnum';
export * from './code-systems/ContactPointUseEnum';
export * from './code-systems/ContributorTypeEnum';
export * from './code-systems/DaysOfWeekEnum';
export * from './code-systems/DeviceNametypeEnum';
export * from './code-systems/DeviceStatusEnum';
export * from './code-systems/EndpointStatusEnum';
export * from './code-systems/HttpVerbEnum';
export * from './code-systems/IdentifierUseEnum';
export * from './code-systems/LinkTypeEnum';
export * from './code-systems/LocationModeEnum';
export * from './code-systems/LocationStatusEnum';
export * from './code-systems/NameUseEnum';
export * from './code-systems/NarrativeStatusEnum';
export * from './code-systems/OperationParameterUseEnum';
export * from './code-systems/QuantityComparatorEnum';
export * from './code-systems/RelatedArtifactTypeEnum';
export * from './code-systems/SearchEntryModeEnum';
export * from './code-systems/SortDirectionEnum';
export * from './code-systems/TaskCodeEnum';
export * from './code-systems/TaskStatusEnum';
export * from './code-systems/TriggerTypeEnum';
export * from './code-systems/UdiEntryTypeEnum';
export * from './complex-types/complex-datatypes';
export * from './resources/Bundle';
export * from './resources/Device';
export * from './resources/DeviceDefinition';
export * from './resources/Endpoint';
export * from './resources/HealthcareService';
export * from './resources/Location';
export * from './resources/Organization';
export * from './resources/Patient';
export * from './resources/Practitioner';
export * from './resources/PractitionerRole';
export * from './resources/RelatedPerson';
export * from './resources/SimplePersonModel';
export * from './resources/TestModel';
export * from './resources/parsable-resource-map';
"
`;

exports[`generator-datamodel-ftest Functional Test Suite generator-app verify generated content should consistently create GeneratedContent[] 1`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/src",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/test/ftest-cache",
    "pkgName": "ftest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * AddressUseEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/address-use
 * CodeSystem.name: AddressUse
 * CodeSystem.description: The use of an address.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: AddressUseEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem AddressUse](http://hl7.org/fhir/address-use)
 */
export class AddressUseEnum implements IFhirCodeEnum {
  public static readonly HOME = new FhirCodeDefinition(
    'HOME',
    'home',
    'http://hl7.org/fhir/address-use',
    'Home',
    'A communication address at a home.',
  );
  public static readonly WORK = new FhirCodeDefinition(
    'WORK',
    'work',
    'http://hl7.org/fhir/address-use',
    'Work',
    'An office address. First choice for business related contacts during business hours.',
  );
  public static readonly TEMP = new FhirCodeDefinition(
    'TEMP',
    'temp',
    'http://hl7.org/fhir/address-use',
    'Temporary',
    'A temporary address. The period can provide more detailed information.',
  );
  public static readonly OLD = new FhirCodeDefinition(
    'OLD',
    'old',
    'http://hl7.org/fhir/address-use',
    'Old / Incorrect',
    'This address is no longer in use (or was never correct but retained for records).',
  );
  public static readonly BILLING = new FhirCodeDefinition(
    'BILLING',
    'billing',
    'http://hl7.org/fhir/address-use',
    'Billing',
    'An address to be used to send bills, invoices, receipts etc.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      AddressUseEnum.HOME,
      AddressUseEnum.WORK,
      AddressUseEnum.TEMP,
      AddressUseEnum.OLD,
      AddressUseEnum.BILLING,
      AddressUseEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {@link InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (AddressUseEnum.HOME.code === code) {
      return AddressUseEnum.HOME;
    } else if (AddressUseEnum.WORK.code === code) {
      return AddressUseEnum.WORK;
    } else if (AddressUseEnum.TEMP.code === code) {
      return AddressUseEnum.TEMP;
    } else if (AddressUseEnum.OLD.code === code) {
      return AddressUseEnum.OLD;
    } else if (AddressUseEnum.BILLING.code === code) {
      return AddressUseEnum.BILLING;
    } else if (AddressUseEnum.NULL.code === code) {
      return AddressUseEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown AddressUseEnum 'code' value '\${code}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "AddressUseEnum",
}
`;

exports[`generator-datamodel-ftest Functional Test Suite generator-app verify generated content should consistently create GeneratedContent[] 2`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/src",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/test/ftest-cache",
    "pkgName": "ftest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * AddressTypeEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/address-type
 * CodeSystem.name: AddressType
 * CodeSystem.description: The type of an address (physical / postal).
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: AddressTypeEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem AddressType](http://hl7.org/fhir/address-type)
 */
export class AddressTypeEnum implements IFhirCodeEnum {
  public static readonly POSTAL = new FhirCodeDefinition(
    'POSTAL',
    'postal',
    'http://hl7.org/fhir/address-type',
    'Postal',
    'Mailing addresses - PO Boxes and care-of addresses.',
  );
  public static readonly PHYSICAL = new FhirCodeDefinition(
    'PHYSICAL',
    'physical',
    'http://hl7.org/fhir/address-type',
    'Physical',
    'A physical address that can be visited.',
  );
  public static readonly BOTH = new FhirCodeDefinition(
    'BOTH',
    'both',
    'http://hl7.org/fhir/address-type',
    'Postal & Physical',
    'An address that is both physical and postal.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      AddressTypeEnum.POSTAL,
      AddressTypeEnum.PHYSICAL,
      AddressTypeEnum.BOTH,
      AddressTypeEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {@link InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (AddressTypeEnum.POSTAL.code === code) {
      return AddressTypeEnum.POSTAL;
    } else if (AddressTypeEnum.PHYSICAL.code === code) {
      return AddressTypeEnum.PHYSICAL;
    } else if (AddressTypeEnum.BOTH.code === code) {
      return AddressTypeEnum.BOTH;
    } else if (AddressTypeEnum.NULL.code === code) {
      return AddressTypeEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown AddressTypeEnum 'code' value '\${code}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "AddressTypeEnum",
}
`;

exports[`generator-datamodel-ftest Functional Test Suite generator-app verify generated content should consistently create GeneratedContent[] 3`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/src",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/test/ftest-cache",
    "pkgName": "ftest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * QuantityComparatorEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/quantity-comparator
 * CodeSystem.name: QuantityComparator
 * CodeSystem.description: How the Quantity should be understood and represented.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: QuantityComparatorEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem QuantityComparator](http://hl7.org/fhir/quantity-comparator)
 */
export class QuantityComparatorEnum implements IFhirCodeEnum {
  public static readonly LESS_THAN = new FhirCodeDefinition(
    'LESS_THAN',
    '<',
    'http://hl7.org/fhir/quantity-comparator',
    'Less than',
    'The actual value is less than the given value.',
  );
  public static readonly LESS_THAN_OR_EQUAL_TO = new FhirCodeDefinition(
    'LESS_THAN_OR_EQUAL_TO',
    '<=',
    'http://hl7.org/fhir/quantity-comparator',
    'Less or Equal to',
    'The actual value is less than or equal to the given value.',
  );
  public static readonly GREATER_THAN_OR_EQUAL_TO = new FhirCodeDefinition(
    'GREATER_THAN_OR_EQUAL_TO',
    '>=',
    'http://hl7.org/fhir/quantity-comparator',
    'Greater or Equal to',
    'The actual value is greater than or equal to the given value.',
  );
  public static readonly GREATER_THAN = new FhirCodeDefinition(
    'GREATER_THAN',
    '>',
    'http://hl7.org/fhir/quantity-comparator',
    'Greater than',
    'The actual value is greater than the given value.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      QuantityComparatorEnum.LESS_THAN,
      QuantityComparatorEnum.LESS_THAN_OR_EQUAL_TO,
      QuantityComparatorEnum.GREATER_THAN_OR_EQUAL_TO,
      QuantityComparatorEnum.GREATER_THAN,
      QuantityComparatorEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {@link InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (QuantityComparatorEnum.LESS_THAN.code === code) {
      return QuantityComparatorEnum.LESS_THAN;
    } else if (QuantityComparatorEnum.LESS_THAN_OR_EQUAL_TO.code === code) {
      return QuantityComparatorEnum.LESS_THAN_OR_EQUAL_TO;
    } else if (QuantityComparatorEnum.GREATER_THAN_OR_EQUAL_TO.code === code) {
      return QuantityComparatorEnum.GREATER_THAN_OR_EQUAL_TO;
    } else if (QuantityComparatorEnum.GREATER_THAN.code === code) {
      return QuantityComparatorEnum.GREATER_THAN;
    } else if (QuantityComparatorEnum.NULL.code === code) {
      return QuantityComparatorEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown QuantityComparatorEnum 'code' value '\${code}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "QuantityComparatorEnum",
}
`;

exports[`generator-datamodel-ftest Functional Test Suite generator-app verify generated content should consistently create GeneratedContent[] 4`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/src",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/test/ftest-cache",
    "pkgName": "ftest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * ContactPointSystemEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/contact-point-system
 * CodeSystem.name: ContactPointSystem
 * CodeSystem.description: Telecommunications form for contact point.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: ContactPointSystemEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem ContactPointSystem](http://hl7.org/fhir/contact-point-system)
 */
export class ContactPointSystemEnum implements IFhirCodeEnum {
  public static readonly PHONE = new FhirCodeDefinition(
    'PHONE',
    'phone',
    'http://hl7.org/fhir/contact-point-system',
    'Phone',
    'The value is a telephone number used for voice calls. Use of full international numbers starting with + is recommended to enable automatic dialing support but not required.',
  );
  public static readonly FAX = new FhirCodeDefinition(
    'FAX',
    'fax',
    'http://hl7.org/fhir/contact-point-system',
    'Fax',
    'The value is a fax machine. Use of full international numbers starting with + is recommended to enable automatic dialing support but not required.',
  );
  public static readonly EMAIL = new FhirCodeDefinition(
    'EMAIL',
    'email',
    'http://hl7.org/fhir/contact-point-system',
    'Email',
    'The value is an email address.',
  );
  public static readonly PAGER = new FhirCodeDefinition(
    'PAGER',
    'pager',
    'http://hl7.org/fhir/contact-point-system',
    'Pager',
    'The value is a pager number. These may be local pager numbers that are only usable on a particular pager system.',
  );
  public static readonly URL = new FhirCodeDefinition(
    'URL',
    'url',
    'http://hl7.org/fhir/contact-point-system',
    'URL',
    'A contact that is not a phone, fax, pager or email address and is expressed as a URL.  This is intended for various institutional or personal contacts including web sites, blogs, Skype, Twitter, Facebook, etc. Do not use for email addresses.',
  );
  public static readonly SMS = new FhirCodeDefinition(
    'SMS',
    'sms',
    'http://hl7.org/fhir/contact-point-system',
    'SMS',
    'A contact that can be used for sending an sms message (e.g. mobile phones, some landlines).',
  );
  public static readonly OTHER = new FhirCodeDefinition(
    'OTHER',
    'other',
    'http://hl7.org/fhir/contact-point-system',
    'Other',
    'A contact that is not a phone, fax, page or email address and is not expressible as a URL.  E.g. Internal mail address.  This SHOULD NOT be used for contacts that are expressible as a URL (e.g. Skype, Twitter, Facebook, etc.)  Extensions may be used to distinguish "other" contact types.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      ContactPointSystemEnum.PHONE,
      ContactPointSystemEnum.FAX,
      ContactPointSystemEnum.EMAIL,
      ContactPointSystemEnum.PAGER,
      ContactPointSystemEnum.URL,
      ContactPointSystemEnum.SMS,
      ContactPointSystemEnum.OTHER,
      ContactPointSystemEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {@link InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (ContactPointSystemEnum.PHONE.code === code) {
      return ContactPointSystemEnum.PHONE;
    } else if (ContactPointSystemEnum.FAX.code === code) {
      return ContactPointSystemEnum.FAX;
    } else if (ContactPointSystemEnum.EMAIL.code === code) {
      return ContactPointSystemEnum.EMAIL;
    } else if (ContactPointSystemEnum.PAGER.code === code) {
      return ContactPointSystemEnum.PAGER;
    } else if (ContactPointSystemEnum.URL.code === code) {
      return ContactPointSystemEnum.URL;
    } else if (ContactPointSystemEnum.SMS.code === code) {
      return ContactPointSystemEnum.SMS;
    } else if (ContactPointSystemEnum.OTHER.code === code) {
      return ContactPointSystemEnum.OTHER;
    } else if (ContactPointSystemEnum.NULL.code === code) {
      return ContactPointSystemEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown ContactPointSystemEnum 'code' value '\${code}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "ContactPointSystemEnum",
}
`;

exports[`generator-datamodel-ftest Functional Test Suite generator-app verify generated content should consistently create GeneratedContent[] 5`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/src",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/test/ftest-cache",
    "pkgName": "ftest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * ContactPointUseEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/contact-point-use
 * CodeSystem.name: ContactPointUse
 * CodeSystem.description: Use of contact point.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: ContactPointUseEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem ContactPointUse](http://hl7.org/fhir/contact-point-use)
 */
export class ContactPointUseEnum implements IFhirCodeEnum {
  public static readonly HOME = new FhirCodeDefinition(
    'HOME',
    'home',
    'http://hl7.org/fhir/contact-point-use',
    'Home',
    'A communication contact point at a home; attempted contacts for business purposes might intrude privacy and chances are one will contact family or other household members instead of the person one wishes to call. Typically used with urgent cases, or if no other contacts are available.',
  );
  public static readonly WORK = new FhirCodeDefinition(
    'WORK',
    'work',
    'http://hl7.org/fhir/contact-point-use',
    'Work',
    'An office contact point. First choice for business related contacts during business hours.',
  );
  public static readonly TEMP = new FhirCodeDefinition(
    'TEMP',
    'temp',
    'http://hl7.org/fhir/contact-point-use',
    'Temp',
    'A temporary contact point. The period can provide more detailed information.',
  );
  public static readonly OLD = new FhirCodeDefinition(
    'OLD',
    'old',
    'http://hl7.org/fhir/contact-point-use',
    'Old',
    'This contact point is no longer in use (or was never correct, but retained for records).',
  );
  public static readonly MOBILE = new FhirCodeDefinition(
    'MOBILE',
    'mobile',
    'http://hl7.org/fhir/contact-point-use',
    'Mobile',
    'A telecommunication device that moves and stays with its owner. May have characteristics of all other use codes, suitable for urgent matters, not the first choice for routine business.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      ContactPointUseEnum.HOME,
      ContactPointUseEnum.WORK,
      ContactPointUseEnum.TEMP,
      ContactPointUseEnum.OLD,
      ContactPointUseEnum.MOBILE,
      ContactPointUseEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {@link InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (ContactPointUseEnum.HOME.code === code) {
      return ContactPointUseEnum.HOME;
    } else if (ContactPointUseEnum.WORK.code === code) {
      return ContactPointUseEnum.WORK;
    } else if (ContactPointUseEnum.TEMP.code === code) {
      return ContactPointUseEnum.TEMP;
    } else if (ContactPointUseEnum.OLD.code === code) {
      return ContactPointUseEnum.OLD;
    } else if (ContactPointUseEnum.MOBILE.code === code) {
      return ContactPointUseEnum.MOBILE;
    } else if (ContactPointUseEnum.NULL.code === code) {
      return ContactPointUseEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown ContactPointUseEnum 'code' value '\${code}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "ContactPointUseEnum",
}
`;

exports[`generator-datamodel-ftest Functional Test Suite generator-app verify generated content should consistently create GeneratedContent[] 6`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/src",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/test/ftest-cache",
    "pkgName": "ftest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * ContributorTypeEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/contributor-type
 * CodeSystem.name: ContributorType
 * CodeSystem.description: The type of contributor.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: ContributorTypeEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem ContributorType](http://hl7.org/fhir/contributor-type)
 */
export class ContributorTypeEnum implements IFhirCodeEnum {
  public static readonly AUTHOR = new FhirCodeDefinition(
    'AUTHOR',
    'author',
    'http://hl7.org/fhir/contributor-type',
    'Author',
    'An author of the content of the module.',
  );
  public static readonly EDITOR = new FhirCodeDefinition(
    'EDITOR',
    'editor',
    'http://hl7.org/fhir/contributor-type',
    'Editor',
    'An editor of the content of the module.',
  );
  public static readonly REVIEWER = new FhirCodeDefinition(
    'REVIEWER',
    'reviewer',
    'http://hl7.org/fhir/contributor-type',
    'Reviewer',
    'A reviewer of the content of the module.',
  );
  public static readonly ENDORSER = new FhirCodeDefinition(
    'ENDORSER',
    'endorser',
    'http://hl7.org/fhir/contributor-type',
    'Endorser',
    'An endorser of the content of the module.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      ContributorTypeEnum.AUTHOR,
      ContributorTypeEnum.EDITOR,
      ContributorTypeEnum.REVIEWER,
      ContributorTypeEnum.ENDORSER,
      ContributorTypeEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {@link InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (ContributorTypeEnum.AUTHOR.code === code) {
      return ContributorTypeEnum.AUTHOR;
    } else if (ContributorTypeEnum.EDITOR.code === code) {
      return ContributorTypeEnum.EDITOR;
    } else if (ContributorTypeEnum.REVIEWER.code === code) {
      return ContributorTypeEnum.REVIEWER;
    } else if (ContributorTypeEnum.ENDORSER.code === code) {
      return ContributorTypeEnum.ENDORSER;
    } else if (ContributorTypeEnum.NULL.code === code) {
      return ContributorTypeEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown ContributorTypeEnum 'code' value '\${code}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "ContributorTypeEnum",
}
`;

exports[`generator-datamodel-ftest Functional Test Suite generator-app verify generated content should consistently create GeneratedContent[] 7`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/src",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/test/ftest-cache",
    "pkgName": "ftest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * SortDirectionEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/sort-direction
 * CodeSystem.name: SortDirection
 * CodeSystem.description: The possible sort directions, ascending or descending.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: SortDirectionEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem SortDirection](http://hl7.org/fhir/sort-direction)
 */
export class SortDirectionEnum implements IFhirCodeEnum {
  public static readonly ASCENDING = new FhirCodeDefinition(
    'ASCENDING',
    'ascending',
    'http://hl7.org/fhir/sort-direction',
    'Ascending',
    'Sort by the value ascending, so that lower values appear first.',
  );
  public static readonly DESCENDING = new FhirCodeDefinition(
    'DESCENDING',
    'descending',
    'http://hl7.org/fhir/sort-direction',
    'Descending',
    'Sort by the value descending, so that lower values appear last.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      SortDirectionEnum.ASCENDING,
      SortDirectionEnum.DESCENDING,
      SortDirectionEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {@link InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (SortDirectionEnum.ASCENDING.code === code) {
      return SortDirectionEnum.ASCENDING;
    } else if (SortDirectionEnum.DESCENDING.code === code) {
      return SortDirectionEnum.DESCENDING;
    } else if (SortDirectionEnum.NULL.code === code) {
      return SortDirectionEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown SortDirectionEnum 'code' value '\${code}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "SortDirectionEnum",
}
`;

exports[`generator-datamodel-ftest Functional Test Suite generator-app verify generated content should consistently create GeneratedContent[] 8`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/src",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/test/ftest-cache",
    "pkgName": "ftest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * NameUseEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/name-use
 * CodeSystem.name: NameUse
 * CodeSystem.description: The use of a human name.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: NameUseEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem NameUse](http://hl7.org/fhir/name-use)
 */
export class NameUseEnum implements IFhirCodeEnum {
  public static readonly USUAL = new FhirCodeDefinition(
    'USUAL',
    'usual',
    'http://hl7.org/fhir/name-use',
    'Usual',
    'Known as/conventional/the one you normally use.',
  );
  public static readonly OFFICIAL = new FhirCodeDefinition(
    'OFFICIAL',
    'official',
    'http://hl7.org/fhir/name-use',
    'Official',
    'The formal name as registered in an official (government) registry, but which name might not be commonly used. May be called "legal name".',
  );
  public static readonly TEMP = new FhirCodeDefinition(
    'TEMP',
    'temp',
    'http://hl7.org/fhir/name-use',
    'Temp',
    'A temporary name. Name.period can provide more detailed information. This may also be used for temporary names assigned at birth or in emergency situations.',
  );
  public static readonly NICKNAME = new FhirCodeDefinition(
    'NICKNAME',
    'nickname',
    'http://hl7.org/fhir/name-use',
    'Nickname',
    'A name that is used to address the person in an informal manner, but is not part of their formal or usual name.',
  );
  public static readonly ANONYMOUS = new FhirCodeDefinition(
    'ANONYMOUS',
    'anonymous',
    'http://hl7.org/fhir/name-use',
    'Anonymous',
    'Anonymous assigned name, alias, or pseudonym (used to protect a person\\'s identity for privacy reasons).',
  );
  public static readonly OLD = new FhirCodeDefinition(
    'OLD',
    'old',
    'http://hl7.org/fhir/name-use',
    'Old',
    'This name is no longer in use (or was never correct, but retained for records).',
  );
  public static readonly MAIDEN = new FhirCodeDefinition(
    'MAIDEN',
    'maiden',
    'http://hl7.org/fhir/name-use',
    'Name changed for Marriage',
    'A name used prior to changing name because of marriage. This name use is for use by applications that collect and store names that were used prior to a marriage. Marriage naming customs vary greatly around the world, and are constantly changing. This term is not gender specific. The use of this term does not imply any particular history for a person\\'s name.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      NameUseEnum.USUAL,
      NameUseEnum.OFFICIAL,
      NameUseEnum.TEMP,
      NameUseEnum.NICKNAME,
      NameUseEnum.ANONYMOUS,
      NameUseEnum.OLD,
      NameUseEnum.MAIDEN,
      NameUseEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {@link InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (NameUseEnum.USUAL.code === code) {
      return NameUseEnum.USUAL;
    } else if (NameUseEnum.OFFICIAL.code === code) {
      return NameUseEnum.OFFICIAL;
    } else if (NameUseEnum.TEMP.code === code) {
      return NameUseEnum.TEMP;
    } else if (NameUseEnum.NICKNAME.code === code) {
      return NameUseEnum.NICKNAME;
    } else if (NameUseEnum.ANONYMOUS.code === code) {
      return NameUseEnum.ANONYMOUS;
    } else if (NameUseEnum.OLD.code === code) {
      return NameUseEnum.OLD;
    } else if (NameUseEnum.MAIDEN.code === code) {
      return NameUseEnum.MAIDEN;
    } else if (NameUseEnum.NULL.code === code) {
      return NameUseEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown NameUseEnum 'code' value '\${code}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "NameUseEnum",
}
`;

exports[`generator-datamodel-ftest Functional Test Suite generator-app verify generated content should consistently create GeneratedContent[] 9`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/src",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/test/ftest-cache",
    "pkgName": "ftest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * IdentifierUseEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/identifier-use
 * CodeSystem.name: IdentifierUse
 * CodeSystem.description: Identifies the purpose for this identifier, if known .
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: IdentifierUseEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem IdentifierUse](http://hl7.org/fhir/identifier-use)
 */
export class IdentifierUseEnum implements IFhirCodeEnum {
  public static readonly USUAL = new FhirCodeDefinition(
    'USUAL',
    'usual',
    'http://hl7.org/fhir/identifier-use',
    'Usual',
    'The identifier recommended for display and use in real-world interactions.',
  );
  public static readonly OFFICIAL = new FhirCodeDefinition(
    'OFFICIAL',
    'official',
    'http://hl7.org/fhir/identifier-use',
    'Official',
    'The identifier considered to be most trusted for the identification of this item. Sometimes also known as "primary" and "main". The determination of "official" is subjective and implementation guides often provide additional guidelines for use.',
  );
  public static readonly TEMP = new FhirCodeDefinition(
    'TEMP',
    'temp',
    'http://hl7.org/fhir/identifier-use',
    'Temp',
    'A temporary identifier.',
  );
  public static readonly SECONDARY = new FhirCodeDefinition(
    'SECONDARY',
    'secondary',
    'http://hl7.org/fhir/identifier-use',
    'Secondary',
    'An identifier that was assigned in secondary use - it serves to identify the object in a relative context, but cannot be consistently assigned to the same object again in a different context.',
  );
  public static readonly OLD = new FhirCodeDefinition(
    'OLD',
    'old',
    'http://hl7.org/fhir/identifier-use',
    'Old',
    'The identifier id no longer considered valid, but may be relevant for search purposes.  E.g. Changes to identifier schemes, account merges, etc.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      IdentifierUseEnum.USUAL,
      IdentifierUseEnum.OFFICIAL,
      IdentifierUseEnum.TEMP,
      IdentifierUseEnum.SECONDARY,
      IdentifierUseEnum.OLD,
      IdentifierUseEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {@link InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (IdentifierUseEnum.USUAL.code === code) {
      return IdentifierUseEnum.USUAL;
    } else if (IdentifierUseEnum.OFFICIAL.code === code) {
      return IdentifierUseEnum.OFFICIAL;
    } else if (IdentifierUseEnum.TEMP.code === code) {
      return IdentifierUseEnum.TEMP;
    } else if (IdentifierUseEnum.SECONDARY.code === code) {
      return IdentifierUseEnum.SECONDARY;
    } else if (IdentifierUseEnum.OLD.code === code) {
      return IdentifierUseEnum.OLD;
    } else if (IdentifierUseEnum.NULL.code === code) {
      return IdentifierUseEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown IdentifierUseEnum 'code' value '\${code}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "IdentifierUseEnum",
}
`;

exports[`generator-datamodel-ftest Functional Test Suite generator-app verify generated content should consistently create GeneratedContent[] 10`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/src",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/test/ftest-cache",
    "pkgName": "ftest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * NarrativeStatusEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/narrative-status
 * CodeSystem.name: NarrativeStatus
 * CodeSystem.description: The status of a resource narrative.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: NarrativeStatusEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem NarrativeStatus](http://hl7.org/fhir/narrative-status)
 */
export class NarrativeStatusEnum implements IFhirCodeEnum {
  public static readonly GENERATED = new FhirCodeDefinition(
    'GENERATED',
    'generated',
    'http://hl7.org/fhir/narrative-status',
    'Generated',
    'The contents of the narrative are entirely generated from the core elements in the content.',
  );
  public static readonly EXTENSIONS = new FhirCodeDefinition(
    'EXTENSIONS',
    'extensions',
    'http://hl7.org/fhir/narrative-status',
    'Extensions',
    'The contents of the narrative are entirely generated from the core elements in the content and some of the content is generated from extensions. The narrative SHALL reflect the impact of all modifier extensions.',
  );
  public static readonly ADDITIONAL = new FhirCodeDefinition(
    'ADDITIONAL',
    'additional',
    'http://hl7.org/fhir/narrative-status',
    'Additional',
    'The contents of the narrative may contain additional information not found in the structured data. Note that there is no computable way to determine what the extra information is, other than by human inspection.',
  );
  public static readonly EMPTY = new FhirCodeDefinition(
    'EMPTY',
    'empty',
    'http://hl7.org/fhir/narrative-status',
    'Empty',
    'The contents of the narrative are some equivalent of "No human-readable text provided in this case".',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      NarrativeStatusEnum.GENERATED,
      NarrativeStatusEnum.EXTENSIONS,
      NarrativeStatusEnum.ADDITIONAL,
      NarrativeStatusEnum.EMPTY,
      NarrativeStatusEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {@link InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (NarrativeStatusEnum.GENERATED.code === code) {
      return NarrativeStatusEnum.GENERATED;
    } else if (NarrativeStatusEnum.EXTENSIONS.code === code) {
      return NarrativeStatusEnum.EXTENSIONS;
    } else if (NarrativeStatusEnum.ADDITIONAL.code === code) {
      return NarrativeStatusEnum.ADDITIONAL;
    } else if (NarrativeStatusEnum.EMPTY.code === code) {
      return NarrativeStatusEnum.EMPTY;
    } else if (NarrativeStatusEnum.NULL.code === code) {
      return NarrativeStatusEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown NarrativeStatusEnum 'code' value '\${code}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "NarrativeStatusEnum",
}
`;

exports[`generator-datamodel-ftest Functional Test Suite generator-app verify generated content should consistently create GeneratedContent[] 11`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/src",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/test/ftest-cache",
    "pkgName": "ftest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * OperationParameterUseEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/operation-parameter-use
 * CodeSystem.name: OperationParameterUse
 * CodeSystem.description: Whether an operation parameter is an input or an output parameter.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: OperationParameterUseEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem OperationParameterUse](http://hl7.org/fhir/operation-parameter-use)
 */
export class OperationParameterUseEnum implements IFhirCodeEnum {
  public static readonly IN = new FhirCodeDefinition(
    'IN',
    'in',
    'http://hl7.org/fhir/operation-parameter-use',
    'In',
    'This is an input parameter.',
  );
  public static readonly OUT = new FhirCodeDefinition(
    'OUT',
    'out',
    'http://hl7.org/fhir/operation-parameter-use',
    'Out',
    'This is an output parameter.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      OperationParameterUseEnum.IN,
      OperationParameterUseEnum.OUT,
      OperationParameterUseEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {@link InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (OperationParameterUseEnum.IN.code === code) {
      return OperationParameterUseEnum.IN;
    } else if (OperationParameterUseEnum.OUT.code === code) {
      return OperationParameterUseEnum.OUT;
    } else if (OperationParameterUseEnum.NULL.code === code) {
      return OperationParameterUseEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown OperationParameterUseEnum 'code' value '\${code}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "OperationParameterUseEnum",
}
`;

exports[`generator-datamodel-ftest Functional Test Suite generator-app verify generated content should consistently create GeneratedContent[] 12`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/src",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/test/ftest-cache",
    "pkgName": "ftest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * RelatedArtifactTypeEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/related-artifact-type
 * CodeSystem.name: RelatedArtifactType
 * CodeSystem.description: The type of relationship to the related artifact.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: RelatedArtifactTypeEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem RelatedArtifactType](http://hl7.org/fhir/related-artifact-type)
 */
export class RelatedArtifactTypeEnum implements IFhirCodeEnum {
  public static readonly DOCUMENTATION = new FhirCodeDefinition(
    'DOCUMENTATION',
    'documentation',
    'http://hl7.org/fhir/related-artifact-type',
    'Documentation',
    'Additional documentation for the knowledge resource. This would include additional instructions on usage as well as additional information on clinical context or appropriateness.',
  );
  public static readonly JUSTIFICATION = new FhirCodeDefinition(
    'JUSTIFICATION',
    'justification',
    'http://hl7.org/fhir/related-artifact-type',
    'Justification',
    'A summary of the justification for the knowledge resource including supporting evidence, relevant guidelines, or other clinically important information. This information is intended to provide a way to make the justification for the knowledge resource available to the consumer of interventions or results produced by the knowledge resource.',
  );
  public static readonly CITATION = new FhirCodeDefinition(
    'CITATION',
    'citation',
    'http://hl7.org/fhir/related-artifact-type',
    'Citation',
    'Bibliographic citation for papers, references, or other relevant material for the knowledge resource. This is intended to allow for citation of related material, but that was not necessarily specifically prepared in connection with this knowledge resource.',
  );
  public static readonly PREDECESSOR = new FhirCodeDefinition(
    'PREDECESSOR',
    'predecessor',
    'http://hl7.org/fhir/related-artifact-type',
    'Predecessor',
    'The previous version of the knowledge resource.',
  );
  public static readonly SUCCESSOR = new FhirCodeDefinition(
    'SUCCESSOR',
    'successor',
    'http://hl7.org/fhir/related-artifact-type',
    'Successor',
    'The next version of the knowledge resource.',
  );
  public static readonly DERIVED_FROM = new FhirCodeDefinition(
    'DERIVED_FROM',
    'derived-from',
    'http://hl7.org/fhir/related-artifact-type',
    'Derived From',
    'The knowledge resource is derived from the related artifact. This is intended to capture the relationship in which a particular knowledge resource is based on the content of another artifact, but is modified to capture either a different set of overall requirements, or a more specific set of requirements such as those involved in a particular institution or clinical setting.',
  );
  public static readonly DEPENDS_ON = new FhirCodeDefinition(
    'DEPENDS_ON',
    'depends-on',
    'http://hl7.org/fhir/related-artifact-type',
    'Depends On',
    'The knowledge resource depends on the given related artifact.',
  );
  public static readonly COMPOSED_OF = new FhirCodeDefinition(
    'COMPOSED_OF',
    'composed-of',
    'http://hl7.org/fhir/related-artifact-type',
    'Composed Of',
    'The knowledge resource is composed of the given related artifact.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      RelatedArtifactTypeEnum.DOCUMENTATION,
      RelatedArtifactTypeEnum.JUSTIFICATION,
      RelatedArtifactTypeEnum.CITATION,
      RelatedArtifactTypeEnum.PREDECESSOR,
      RelatedArtifactTypeEnum.SUCCESSOR,
      RelatedArtifactTypeEnum.DERIVED_FROM,
      RelatedArtifactTypeEnum.DEPENDS_ON,
      RelatedArtifactTypeEnum.COMPOSED_OF,
      RelatedArtifactTypeEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {@link InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (RelatedArtifactTypeEnum.DOCUMENTATION.code === code) {
      return RelatedArtifactTypeEnum.DOCUMENTATION;
    } else if (RelatedArtifactTypeEnum.JUSTIFICATION.code === code) {
      return RelatedArtifactTypeEnum.JUSTIFICATION;
    } else if (RelatedArtifactTypeEnum.CITATION.code === code) {
      return RelatedArtifactTypeEnum.CITATION;
    } else if (RelatedArtifactTypeEnum.PREDECESSOR.code === code) {
      return RelatedArtifactTypeEnum.PREDECESSOR;
    } else if (RelatedArtifactTypeEnum.SUCCESSOR.code === code) {
      return RelatedArtifactTypeEnum.SUCCESSOR;
    } else if (RelatedArtifactTypeEnum.DERIVED_FROM.code === code) {
      return RelatedArtifactTypeEnum.DERIVED_FROM;
    } else if (RelatedArtifactTypeEnum.DEPENDS_ON.code === code) {
      return RelatedArtifactTypeEnum.DEPENDS_ON;
    } else if (RelatedArtifactTypeEnum.COMPOSED_OF.code === code) {
      return RelatedArtifactTypeEnum.COMPOSED_OF;
    } else if (RelatedArtifactTypeEnum.NULL.code === code) {
      return RelatedArtifactTypeEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown RelatedArtifactTypeEnum 'code' value '\${code}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "RelatedArtifactTypeEnum",
}
`;

exports[`generator-datamodel-ftest Functional Test Suite generator-app verify generated content should consistently create GeneratedContent[] 13`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/src",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/test/ftest-cache",
    "pkgName": "ftest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * DaysOfWeekEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/days-of-week
 * CodeSystem.name: DaysOfWeek
 * CodeSystem.description: The days of the week.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: DaysOfWeekEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem DaysOfWeek](http://hl7.org/fhir/days-of-week)
 */
export class DaysOfWeekEnum implements IFhirCodeEnum {
  public static readonly MON = new FhirCodeDefinition(
    'MON',
    'mon',
    'http://hl7.org/fhir/days-of-week',
    'Monday',
    'Monday.',
  );
  public static readonly TUE = new FhirCodeDefinition(
    'TUE',
    'tue',
    'http://hl7.org/fhir/days-of-week',
    'Tuesday',
    'Tuesday.',
  );
  public static readonly WED = new FhirCodeDefinition(
    'WED',
    'wed',
    'http://hl7.org/fhir/days-of-week',
    'Wednesday',
    'Wednesday.',
  );
  public static readonly THU = new FhirCodeDefinition(
    'THU',
    'thu',
    'http://hl7.org/fhir/days-of-week',
    'Thursday',
    'Thursday.',
  );
  public static readonly FRI = new FhirCodeDefinition(
    'FRI',
    'fri',
    'http://hl7.org/fhir/days-of-week',
    'Friday',
    'Friday.',
  );
  public static readonly SAT = new FhirCodeDefinition(
    'SAT',
    'sat',
    'http://hl7.org/fhir/days-of-week',
    'Saturday',
    'Saturday.',
  );
  public static readonly SUN = new FhirCodeDefinition(
    'SUN',
    'sun',
    'http://hl7.org/fhir/days-of-week',
    'Sunday',
    'Sunday.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      DaysOfWeekEnum.MON,
      DaysOfWeekEnum.TUE,
      DaysOfWeekEnum.WED,
      DaysOfWeekEnum.THU,
      DaysOfWeekEnum.FRI,
      DaysOfWeekEnum.SAT,
      DaysOfWeekEnum.SUN,
      DaysOfWeekEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {@link InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (DaysOfWeekEnum.MON.code === code) {
      return DaysOfWeekEnum.MON;
    } else if (DaysOfWeekEnum.TUE.code === code) {
      return DaysOfWeekEnum.TUE;
    } else if (DaysOfWeekEnum.WED.code === code) {
      return DaysOfWeekEnum.WED;
    } else if (DaysOfWeekEnum.THU.code === code) {
      return DaysOfWeekEnum.THU;
    } else if (DaysOfWeekEnum.FRI.code === code) {
      return DaysOfWeekEnum.FRI;
    } else if (DaysOfWeekEnum.SAT.code === code) {
      return DaysOfWeekEnum.SAT;
    } else if (DaysOfWeekEnum.SUN.code === code) {
      return DaysOfWeekEnum.SUN;
    } else if (DaysOfWeekEnum.NULL.code === code) {
      return DaysOfWeekEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown DaysOfWeekEnum 'code' value '\${code}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "DaysOfWeekEnum",
}
`;

exports[`generator-datamodel-ftest Functional Test Suite generator-app verify generated content should consistently create GeneratedContent[] 14`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/src",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/test/ftest-cache",
    "pkgName": "ftest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * TriggerTypeEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/trigger-type
 * CodeSystem.name: TriggerType
 * CodeSystem.description: The type of trigger.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: TriggerTypeEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem TriggerType](http://hl7.org/fhir/trigger-type)
 */
export class TriggerTypeEnum implements IFhirCodeEnum {
  public static readonly NAMED_EVENT = new FhirCodeDefinition(
    'NAMED_EVENT',
    'named-event',
    'http://hl7.org/fhir/trigger-type',
    'Named Event',
    'The trigger occurs in response to a specific named event, and no other information about the trigger is specified. Named events are completely pre-coordinated, and the formal semantics of the trigger are not provided.',
  );
  public static readonly PERIODIC = new FhirCodeDefinition(
    'PERIODIC',
    'periodic',
    'http://hl7.org/fhir/trigger-type',
    'Periodic',
    'The trigger occurs at a specific time or periodically as described by a timing or schedule. A periodic event cannot have any data elements, but may have a name assigned as a shorthand for the event.',
  );
  public static readonly DATA_CHANGED = new FhirCodeDefinition(
    'DATA_CHANGED',
    'data-changed',
    'http://hl7.org/fhir/trigger-type',
    'Data Changed',
    'The trigger occurs whenever data of a particular type is changed in any way, either added, modified, or removed.',
  );
  public static readonly DATA_ADDED = new FhirCodeDefinition(
    'DATA_ADDED',
    'data-added',
    'http://hl7.org/fhir/trigger-type',
    'Data Added',
    'The trigger occurs whenever data of a particular type is added.',
  );
  public static readonly DATA_MODIFIED = new FhirCodeDefinition(
    'DATA_MODIFIED',
    'data-modified',
    'http://hl7.org/fhir/trigger-type',
    'Data Updated',
    'The trigger occurs whenever data of a particular type is modified.',
  );
  public static readonly DATA_REMOVED = new FhirCodeDefinition(
    'DATA_REMOVED',
    'data-removed',
    'http://hl7.org/fhir/trigger-type',
    'Data Removed',
    'The trigger occurs whenever data of a particular type is removed.',
  );
  public static readonly DATA_ACCESSED = new FhirCodeDefinition(
    'DATA_ACCESSED',
    'data-accessed',
    'http://hl7.org/fhir/trigger-type',
    'Data Accessed',
    'The trigger occurs whenever data of a particular type is accessed.',
  );
  public static readonly DATA_ACCESS_ENDED = new FhirCodeDefinition(
    'DATA_ACCESS_ENDED',
    'data-access-ended',
    'http://hl7.org/fhir/trigger-type',
    'Data Access Ended',
    'The trigger occurs whenever access to data of a particular type is completed.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      TriggerTypeEnum.NAMED_EVENT,
      TriggerTypeEnum.PERIODIC,
      TriggerTypeEnum.DATA_CHANGED,
      TriggerTypeEnum.DATA_ADDED,
      TriggerTypeEnum.DATA_MODIFIED,
      TriggerTypeEnum.DATA_REMOVED,
      TriggerTypeEnum.DATA_ACCESSED,
      TriggerTypeEnum.DATA_ACCESS_ENDED,
      TriggerTypeEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {@link InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (TriggerTypeEnum.NAMED_EVENT.code === code) {
      return TriggerTypeEnum.NAMED_EVENT;
    } else if (TriggerTypeEnum.PERIODIC.code === code) {
      return TriggerTypeEnum.PERIODIC;
    } else if (TriggerTypeEnum.DATA_CHANGED.code === code) {
      return TriggerTypeEnum.DATA_CHANGED;
    } else if (TriggerTypeEnum.DATA_ADDED.code === code) {
      return TriggerTypeEnum.DATA_ADDED;
    } else if (TriggerTypeEnum.DATA_MODIFIED.code === code) {
      return TriggerTypeEnum.DATA_MODIFIED;
    } else if (TriggerTypeEnum.DATA_REMOVED.code === code) {
      return TriggerTypeEnum.DATA_REMOVED;
    } else if (TriggerTypeEnum.DATA_ACCESSED.code === code) {
      return TriggerTypeEnum.DATA_ACCESSED;
    } else if (TriggerTypeEnum.DATA_ACCESS_ENDED.code === code) {
      return TriggerTypeEnum.DATA_ACCESS_ENDED;
    } else if (TriggerTypeEnum.NULL.code === code) {
      return TriggerTypeEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown TriggerTypeEnum 'code' value '\${code}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "TriggerTypeEnum",
}
`;

exports[`generator-datamodel-ftest Functional Test Suite generator-app verify generated content should consistently create GeneratedContent[] 15`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/src",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/test/ftest-cache",
    "pkgName": "ftest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * BundleTypeEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/bundle-type
 * CodeSystem.name: BundleType
 * CodeSystem.description: Indicates the purpose of a bundle - how it is intended to be used.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: BundleTypeEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem BundleType](http://hl7.org/fhir/bundle-type)
 */
export class BundleTypeEnum implements IFhirCodeEnum {
  public static readonly DOCUMENT = new FhirCodeDefinition(
    'DOCUMENT',
    'document',
    'http://hl7.org/fhir/bundle-type',
    'Document',
    'The bundle is a document. The first resource is a Composition.',
  );
  public static readonly MESSAGE = new FhirCodeDefinition(
    'MESSAGE',
    'message',
    'http://hl7.org/fhir/bundle-type',
    'Message',
    'The bundle is a message. The first resource is a MessageHeader.',
  );
  public static readonly TRANSACTION = new FhirCodeDefinition(
    'TRANSACTION',
    'transaction',
    'http://hl7.org/fhir/bundle-type',
    'Transaction',
    'The bundle is a transaction - intended to be processed by a server as an atomic commit.',
  );
  public static readonly TRANSACTION_RESPONSE = new FhirCodeDefinition(
    'TRANSACTION_RESPONSE',
    'transaction-response',
    'http://hl7.org/fhir/bundle-type',
    'Transaction Response',
    'The bundle is a transaction response. Because the response is a transaction response, the transaction has succeeded, and all responses are error free.',
  );
  public static readonly BATCH = new FhirCodeDefinition(
    'BATCH',
    'batch',
    'http://hl7.org/fhir/bundle-type',
    'Batch',
    'The bundle is a set of actions - intended to be processed by a server as a group of independent actions.',
  );
  public static readonly BATCH_RESPONSE = new FhirCodeDefinition(
    'BATCH_RESPONSE',
    'batch-response',
    'http://hl7.org/fhir/bundle-type',
    'Batch Response',
    'The bundle is a batch response. Note that as a batch, some responses may indicate failure and others success.',
  );
  public static readonly HISTORY = new FhirCodeDefinition(
    'HISTORY',
    'history',
    'http://hl7.org/fhir/bundle-type',
    'History List',
    'The bundle is a list of resources from a history interaction on a server.',
  );
  public static readonly SEARCHSET = new FhirCodeDefinition(
    'SEARCHSET',
    'searchset',
    'http://hl7.org/fhir/bundle-type',
    'Search Results',
    'The bundle is a list of resources returned as a result of a search/query interaction, operation, or message.',
  );
  public static readonly COLLECTION = new FhirCodeDefinition(
    'COLLECTION',
    'collection',
    'http://hl7.org/fhir/bundle-type',
    'Collection',
    'The bundle is a set of resources collected into a single package for ease of distribution that imposes no processing obligations or behavioral rules beyond persistence.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      BundleTypeEnum.DOCUMENT,
      BundleTypeEnum.MESSAGE,
      BundleTypeEnum.TRANSACTION,
      BundleTypeEnum.TRANSACTION_RESPONSE,
      BundleTypeEnum.BATCH,
      BundleTypeEnum.BATCH_RESPONSE,
      BundleTypeEnum.HISTORY,
      BundleTypeEnum.SEARCHSET,
      BundleTypeEnum.COLLECTION,
      BundleTypeEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {@link InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (BundleTypeEnum.DOCUMENT.code === code) {
      return BundleTypeEnum.DOCUMENT;
    } else if (BundleTypeEnum.MESSAGE.code === code) {
      return BundleTypeEnum.MESSAGE;
    } else if (BundleTypeEnum.TRANSACTION.code === code) {
      return BundleTypeEnum.TRANSACTION;
    } else if (BundleTypeEnum.TRANSACTION_RESPONSE.code === code) {
      return BundleTypeEnum.TRANSACTION_RESPONSE;
    } else if (BundleTypeEnum.BATCH.code === code) {
      return BundleTypeEnum.BATCH;
    } else if (BundleTypeEnum.BATCH_RESPONSE.code === code) {
      return BundleTypeEnum.BATCH_RESPONSE;
    } else if (BundleTypeEnum.HISTORY.code === code) {
      return BundleTypeEnum.HISTORY;
    } else if (BundleTypeEnum.SEARCHSET.code === code) {
      return BundleTypeEnum.SEARCHSET;
    } else if (BundleTypeEnum.COLLECTION.code === code) {
      return BundleTypeEnum.COLLECTION;
    } else if (BundleTypeEnum.NULL.code === code) {
      return BundleTypeEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown BundleTypeEnum 'code' value '\${code}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "BundleTypeEnum",
}
`;

exports[`generator-datamodel-ftest Functional Test Suite generator-app verify generated content should consistently create GeneratedContent[] 16`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/src",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/test/ftest-cache",
    "pkgName": "ftest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * SearchEntryModeEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/search-entry-mode
 * CodeSystem.name: SearchEntryMode
 * CodeSystem.description: Why an entry is in the result set - whether it\\'s included as a match or because of an _include requirement, or to convey information or warning information about the search process.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: SearchEntryModeEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem SearchEntryMode](http://hl7.org/fhir/search-entry-mode)
 */
export class SearchEntryModeEnum implements IFhirCodeEnum {
  public static readonly MATCH = new FhirCodeDefinition(
    'MATCH',
    'match',
    'http://hl7.org/fhir/search-entry-mode',
    'Match',
    'This resource matched the search specification.',
  );
  public static readonly INCLUDE = new FhirCodeDefinition(
    'INCLUDE',
    'include',
    'http://hl7.org/fhir/search-entry-mode',
    'Include',
    'This resource is returned because it is referred to from another resource in the search set.',
  );
  public static readonly OUTCOME = new FhirCodeDefinition(
    'OUTCOME',
    'outcome',
    'http://hl7.org/fhir/search-entry-mode',
    'Outcome',
    'An OperationOutcome that provides additional information about the processing of a search.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      SearchEntryModeEnum.MATCH,
      SearchEntryModeEnum.INCLUDE,
      SearchEntryModeEnum.OUTCOME,
      SearchEntryModeEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {@link InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (SearchEntryModeEnum.MATCH.code === code) {
      return SearchEntryModeEnum.MATCH;
    } else if (SearchEntryModeEnum.INCLUDE.code === code) {
      return SearchEntryModeEnum.INCLUDE;
    } else if (SearchEntryModeEnum.OUTCOME.code === code) {
      return SearchEntryModeEnum.OUTCOME;
    } else if (SearchEntryModeEnum.NULL.code === code) {
      return SearchEntryModeEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown SearchEntryModeEnum 'code' value '\${code}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "SearchEntryModeEnum",
}
`;

exports[`generator-datamodel-ftest Functional Test Suite generator-app verify generated content should consistently create GeneratedContent[] 17`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/src",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/test/ftest-cache",
    "pkgName": "ftest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * HttpVerbEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/http-verb
 * CodeSystem.name: HttpVerb
 * CodeSystem.description: HTTP verbs (in the HTTP command line). See [HTTP rfc](https://tools.ietf.org/html/rfc7231) for details.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: HttpVerbEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem HttpVerb](http://hl7.org/fhir/http-verb)
 */
export class HttpVerbEnum implements IFhirCodeEnum {
  public static readonly GET = new FhirCodeDefinition(
    'GET',
    'GET',
    'http://hl7.org/fhir/http-verb',
    'GET',
    'HTTP GET Command.',
  );
  public static readonly HEAD = new FhirCodeDefinition(
    'HEAD',
    'HEAD',
    'http://hl7.org/fhir/http-verb',
    'HEAD',
    'HTTP HEAD Command.',
  );
  public static readonly POST = new FhirCodeDefinition(
    'POST',
    'POST',
    'http://hl7.org/fhir/http-verb',
    'POST',
    'HTTP POST Command.',
  );
  public static readonly PUT = new FhirCodeDefinition(
    'PUT',
    'PUT',
    'http://hl7.org/fhir/http-verb',
    'PUT',
    'HTTP PUT Command.',
  );
  public static readonly DELETE = new FhirCodeDefinition(
    'DELETE',
    'DELETE',
    'http://hl7.org/fhir/http-verb',
    'DELETE',
    'HTTP DELETE Command.',
  );
  public static readonly PATCH = new FhirCodeDefinition(
    'PATCH',
    'PATCH',
    'http://hl7.org/fhir/http-verb',
    'PATCH',
    'HTTP PATCH Command.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      HttpVerbEnum.GET,
      HttpVerbEnum.HEAD,
      HttpVerbEnum.POST,
      HttpVerbEnum.PUT,
      HttpVerbEnum.DELETE,
      HttpVerbEnum.PATCH,
      HttpVerbEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {@link InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (HttpVerbEnum.GET.code === code) {
      return HttpVerbEnum.GET;
    } else if (HttpVerbEnum.HEAD.code === code) {
      return HttpVerbEnum.HEAD;
    } else if (HttpVerbEnum.POST.code === code) {
      return HttpVerbEnum.POST;
    } else if (HttpVerbEnum.PUT.code === code) {
      return HttpVerbEnum.PUT;
    } else if (HttpVerbEnum.DELETE.code === code) {
      return HttpVerbEnum.DELETE;
    } else if (HttpVerbEnum.PATCH.code === code) {
      return HttpVerbEnum.PATCH;
    } else if (HttpVerbEnum.NULL.code === code) {
      return HttpVerbEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown HttpVerbEnum 'code' value '\${code}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "HttpVerbEnum",
}
`;

exports[`generator-datamodel-ftest Functional Test Suite generator-app verify generated content should consistently create GeneratedContent[] 18`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/src",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/test/ftest-cache",
    "pkgName": "ftest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * UdiEntryTypeEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/udi-entry-type
 * CodeSystem.name: UdiEntryType
 * CodeSystem.description: Codes to identify how UDI data was entered.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: UdiEntryTypeEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem UdiEntryType](http://hl7.org/fhir/udi-entry-type)
 */
export class UdiEntryTypeEnum implements IFhirCodeEnum {
  public static readonly BARCODE = new FhirCodeDefinition(
    'BARCODE',
    'barcode',
    'http://hl7.org/fhir/udi-entry-type',
    'Barcode',
    'a barcodescanner captured the data from the device label.',
  );
  public static readonly RFID = new FhirCodeDefinition(
    'RFID',
    'rfid',
    'http://hl7.org/fhir/udi-entry-type',
    'RFID',
    'An RFID chip reader captured the data from the device label.',
  );
  public static readonly MANUAL = new FhirCodeDefinition(
    'MANUAL',
    'manual',
    'http://hl7.org/fhir/udi-entry-type',
    'Manual',
    'The data was read from the label by a person and manually entered. (e.g.  via a keyboard).',
  );
  public static readonly CARD = new FhirCodeDefinition(
    'CARD',
    'card',
    'http://hl7.org/fhir/udi-entry-type',
    'Card',
    'The data originated from a patient\\'s implant card and was read by an operator.',
  );
  public static readonly SELF_REPORTED = new FhirCodeDefinition(
    'SELF_REPORTED',
    'self-reported',
    'http://hl7.org/fhir/udi-entry-type',
    'Self Reported',
    'The data originated from a patient source and was not directly scanned or read from a label or card.',
  );
  public static readonly UNKNOWN = new FhirCodeDefinition(
    'UNKNOWN',
    'unknown',
    'http://hl7.org/fhir/udi-entry-type',
    'Unknown',
    'The method of data capture has not been determined.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      UdiEntryTypeEnum.BARCODE,
      UdiEntryTypeEnum.RFID,
      UdiEntryTypeEnum.MANUAL,
      UdiEntryTypeEnum.CARD,
      UdiEntryTypeEnum.SELF_REPORTED,
      UdiEntryTypeEnum.UNKNOWN,
      UdiEntryTypeEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {@link InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (UdiEntryTypeEnum.BARCODE.code === code) {
      return UdiEntryTypeEnum.BARCODE;
    } else if (UdiEntryTypeEnum.RFID.code === code) {
      return UdiEntryTypeEnum.RFID;
    } else if (UdiEntryTypeEnum.MANUAL.code === code) {
      return UdiEntryTypeEnum.MANUAL;
    } else if (UdiEntryTypeEnum.CARD.code === code) {
      return UdiEntryTypeEnum.CARD;
    } else if (UdiEntryTypeEnum.SELF_REPORTED.code === code) {
      return UdiEntryTypeEnum.SELF_REPORTED;
    } else if (UdiEntryTypeEnum.UNKNOWN.code === code) {
      return UdiEntryTypeEnum.UNKNOWN;
    } else if (UdiEntryTypeEnum.NULL.code === code) {
      return UdiEntryTypeEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown UdiEntryTypeEnum 'code' value '\${code}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "UdiEntryTypeEnum",
}
`;

exports[`generator-datamodel-ftest Functional Test Suite generator-app verify generated content should consistently create GeneratedContent[] 19`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/src",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/test/ftest-cache",
    "pkgName": "ftest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * DeviceStatusEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/device-status
 * CodeSystem.name: DeviceStatus
 * CodeSystem.description: The availability status of the device.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: DeviceStatusEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem DeviceStatus](http://hl7.org/fhir/device-status)
 */
export class DeviceStatusEnum implements IFhirCodeEnum {
  public static readonly ACTIVE = new FhirCodeDefinition(
    'ACTIVE',
    'active',
    'http://hl7.org/fhir/device-status',
    'Active',
    'The device is available for use.  Note: For *implanted devices*  this means that the device is implanted in the patient.',
  );
  public static readonly INACTIVE = new FhirCodeDefinition(
    'INACTIVE',
    'inactive',
    'http://hl7.org/fhir/device-status',
    'Inactive',
    'The device is no longer available for use (e.g. lost, expired, damaged).  Note: For *implanted devices*  this means that the device has been removed from the patient.',
  );
  public static readonly ENTERED_IN_ERROR = new FhirCodeDefinition(
    'ENTERED_IN_ERROR',
    'entered-in-error',
    'http://hl7.org/fhir/device-status',
    'Entered in Error',
    'The device was entered in error and voided.',
  );
  public static readonly UNKNOWN = new FhirCodeDefinition(
    'UNKNOWN',
    'unknown',
    'http://hl7.org/fhir/device-status',
    'Unknown',
    'The status of the device has not been determined.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      DeviceStatusEnum.ACTIVE,
      DeviceStatusEnum.INACTIVE,
      DeviceStatusEnum.ENTERED_IN_ERROR,
      DeviceStatusEnum.UNKNOWN,
      DeviceStatusEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {@link InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (DeviceStatusEnum.ACTIVE.code === code) {
      return DeviceStatusEnum.ACTIVE;
    } else if (DeviceStatusEnum.INACTIVE.code === code) {
      return DeviceStatusEnum.INACTIVE;
    } else if (DeviceStatusEnum.ENTERED_IN_ERROR.code === code) {
      return DeviceStatusEnum.ENTERED_IN_ERROR;
    } else if (DeviceStatusEnum.UNKNOWN.code === code) {
      return DeviceStatusEnum.UNKNOWN;
    } else if (DeviceStatusEnum.NULL.code === code) {
      return DeviceStatusEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown DeviceStatusEnum 'code' value '\${code}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "DeviceStatusEnum",
}
`;

exports[`generator-datamodel-ftest Functional Test Suite generator-app verify generated content should consistently create GeneratedContent[] 20`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/src",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/test/ftest-cache",
    "pkgName": "ftest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * DeviceNametypeEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/device-nametype
 * CodeSystem.name: DeviceNametype
 * CodeSystem.description: The type of name the device is referred by.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: DeviceNametypeEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem DeviceNametype](http://hl7.org/fhir/device-nametype)
 */
export class DeviceNametypeEnum implements IFhirCodeEnum {
  public static readonly UDI_LABEL_NAME = new FhirCodeDefinition(
    'UDI_LABEL_NAME',
    'udi-label-name',
    'http://hl7.org/fhir/device-nametype',
    'UDI Label name',
    'UDI Label name.',
  );
  public static readonly USER_FRIENDLY_NAME = new FhirCodeDefinition(
    'USER_FRIENDLY_NAME',
    'user-friendly-name',
    'http://hl7.org/fhir/device-nametype',
    'User Friendly name',
    'User Friendly name.',
  );
  public static readonly PATIENT_REPORTED_NAME = new FhirCodeDefinition(
    'PATIENT_REPORTED_NAME',
    'patient-reported-name',
    'http://hl7.org/fhir/device-nametype',
    'Patient Reported name',
    'Patient Reported name.',
  );
  public static readonly MANUFACTURER_NAME = new FhirCodeDefinition(
    'MANUFACTURER_NAME',
    'manufacturer-name',
    'http://hl7.org/fhir/device-nametype',
    'Manufacturer name',
    'Manufacturer name.',
  );
  public static readonly MODEL_NAME = new FhirCodeDefinition(
    'MODEL_NAME',
    'model-name',
    'http://hl7.org/fhir/device-nametype',
    'Model name',
    'Model name.',
  );
  public static readonly OTHER = new FhirCodeDefinition(
    'OTHER',
    'other',
    'http://hl7.org/fhir/device-nametype',
    'other',
    'other.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      DeviceNametypeEnum.UDI_LABEL_NAME,
      DeviceNametypeEnum.USER_FRIENDLY_NAME,
      DeviceNametypeEnum.PATIENT_REPORTED_NAME,
      DeviceNametypeEnum.MANUFACTURER_NAME,
      DeviceNametypeEnum.MODEL_NAME,
      DeviceNametypeEnum.OTHER,
      DeviceNametypeEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {@link InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (DeviceNametypeEnum.UDI_LABEL_NAME.code === code) {
      return DeviceNametypeEnum.UDI_LABEL_NAME;
    } else if (DeviceNametypeEnum.USER_FRIENDLY_NAME.code === code) {
      return DeviceNametypeEnum.USER_FRIENDLY_NAME;
    } else if (DeviceNametypeEnum.PATIENT_REPORTED_NAME.code === code) {
      return DeviceNametypeEnum.PATIENT_REPORTED_NAME;
    } else if (DeviceNametypeEnum.MANUFACTURER_NAME.code === code) {
      return DeviceNametypeEnum.MANUFACTURER_NAME;
    } else if (DeviceNametypeEnum.MODEL_NAME.code === code) {
      return DeviceNametypeEnum.MODEL_NAME;
    } else if (DeviceNametypeEnum.OTHER.code === code) {
      return DeviceNametypeEnum.OTHER;
    } else if (DeviceNametypeEnum.NULL.code === code) {
      return DeviceNametypeEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown DeviceNametypeEnum 'code' value '\${code}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "DeviceNametypeEnum",
}
`;

exports[`generator-datamodel-ftest Functional Test Suite generator-app verify generated content should consistently create GeneratedContent[] 21`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/src",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/test/ftest-cache",
    "pkgName": "ftest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * EndpointStatusEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/endpoint-status
 * CodeSystem.name: EndpointStatus
 * CodeSystem.description: The status of the endpoint.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: EndpointStatusEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem EndpointStatus](http://hl7.org/fhir/endpoint-status)
 */
export class EndpointStatusEnum implements IFhirCodeEnum {
  public static readonly ACTIVE = new FhirCodeDefinition(
    'ACTIVE',
    'active',
    'http://hl7.org/fhir/endpoint-status',
    'Active',
    'This endpoint is expected to be active and can be used.',
  );
  public static readonly SUSPENDED = new FhirCodeDefinition(
    'SUSPENDED',
    'suspended',
    'http://hl7.org/fhir/endpoint-status',
    'Suspended',
    'This endpoint is temporarily unavailable.',
  );
  public static readonly ERROR = new FhirCodeDefinition(
    'ERROR',
    'error',
    'http://hl7.org/fhir/endpoint-status',
    'Error',
    'This endpoint has exceeded connectivity thresholds and is considered in an error state and should no longer be attempted to connect to until corrective action is taken.',
  );
  public static readonly OFF = new FhirCodeDefinition(
    'OFF',
    'off',
    'http://hl7.org/fhir/endpoint-status',
    'Off',
    'This endpoint is no longer to be used.',
  );
  public static readonly ENTERED_IN_ERROR = new FhirCodeDefinition(
    'ENTERED_IN_ERROR',
    'entered-in-error',
    'http://hl7.org/fhir/endpoint-status',
    'Entered in error',
    'This instance should not have been part of this patient\\'s medical record.',
  );
  public static readonly TEST = new FhirCodeDefinition(
    'TEST',
    'test',
    'http://hl7.org/fhir/endpoint-status',
    'Test',
    'This endpoint is not intended for production usage.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      EndpointStatusEnum.ACTIVE,
      EndpointStatusEnum.SUSPENDED,
      EndpointStatusEnum.ERROR,
      EndpointStatusEnum.OFF,
      EndpointStatusEnum.ENTERED_IN_ERROR,
      EndpointStatusEnum.TEST,
      EndpointStatusEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {@link InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (EndpointStatusEnum.ACTIVE.code === code) {
      return EndpointStatusEnum.ACTIVE;
    } else if (EndpointStatusEnum.SUSPENDED.code === code) {
      return EndpointStatusEnum.SUSPENDED;
    } else if (EndpointStatusEnum.ERROR.code === code) {
      return EndpointStatusEnum.ERROR;
    } else if (EndpointStatusEnum.OFF.code === code) {
      return EndpointStatusEnum.OFF;
    } else if (EndpointStatusEnum.ENTERED_IN_ERROR.code === code) {
      return EndpointStatusEnum.ENTERED_IN_ERROR;
    } else if (EndpointStatusEnum.TEST.code === code) {
      return EndpointStatusEnum.TEST;
    } else if (EndpointStatusEnum.NULL.code === code) {
      return EndpointStatusEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown EndpointStatusEnum 'code' value '\${code}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "EndpointStatusEnum",
}
`;

exports[`generator-datamodel-ftest Functional Test Suite generator-app verify generated content should consistently create GeneratedContent[] 22`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/src",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/test/ftest-cache",
    "pkgName": "ftest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * LocationStatusEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/location-status
 * CodeSystem.name: LocationStatus
 * CodeSystem.description: Indicates whether the location is still in use.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: LocationStatusEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem LocationStatus](http://hl7.org/fhir/location-status)
 */
export class LocationStatusEnum implements IFhirCodeEnum {
  public static readonly ACTIVE = new FhirCodeDefinition(
    'ACTIVE',
    'active',
    'http://hl7.org/fhir/location-status',
    'Active',
    'The location is operational.',
  );
  public static readonly SUSPENDED = new FhirCodeDefinition(
    'SUSPENDED',
    'suspended',
    'http://hl7.org/fhir/location-status',
    'Suspended',
    'The location is temporarily closed.',
  );
  public static readonly INACTIVE = new FhirCodeDefinition(
    'INACTIVE',
    'inactive',
    'http://hl7.org/fhir/location-status',
    'Inactive',
    'The location is no longer used.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      LocationStatusEnum.ACTIVE,
      LocationStatusEnum.SUSPENDED,
      LocationStatusEnum.INACTIVE,
      LocationStatusEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {@link InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (LocationStatusEnum.ACTIVE.code === code) {
      return LocationStatusEnum.ACTIVE;
    } else if (LocationStatusEnum.SUSPENDED.code === code) {
      return LocationStatusEnum.SUSPENDED;
    } else if (LocationStatusEnum.INACTIVE.code === code) {
      return LocationStatusEnum.INACTIVE;
    } else if (LocationStatusEnum.NULL.code === code) {
      return LocationStatusEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown LocationStatusEnum 'code' value '\${code}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "LocationStatusEnum",
}
`;

exports[`generator-datamodel-ftest Functional Test Suite generator-app verify generated content should consistently create GeneratedContent[] 23`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/src",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/test/ftest-cache",
    "pkgName": "ftest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * LocationModeEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/location-mode
 * CodeSystem.name: LocationMode
 * CodeSystem.description: Indicates whether a resource instance represents a specific location or a class of locations.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: LocationModeEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem LocationMode](http://hl7.org/fhir/location-mode)
 */
export class LocationModeEnum implements IFhirCodeEnum {
  public static readonly INSTANCE = new FhirCodeDefinition(
    'INSTANCE',
    'instance',
    'http://hl7.org/fhir/location-mode',
    'Instance',
    'The Location resource represents a specific instance of a location (e.g. Operating Theatre 1A).',
  );
  public static readonly KIND = new FhirCodeDefinition(
    'KIND',
    'kind',
    'http://hl7.org/fhir/location-mode',
    'Kind',
    'The Location represents a class of locations (e.g. Any Operating Theatre) although this class of locations could be constrained within a specific boundary (such as organization, or parent location, address etc.).',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      LocationModeEnum.INSTANCE,
      LocationModeEnum.KIND,
      LocationModeEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {@link InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (LocationModeEnum.INSTANCE.code === code) {
      return LocationModeEnum.INSTANCE;
    } else if (LocationModeEnum.KIND.code === code) {
      return LocationModeEnum.KIND;
    } else if (LocationModeEnum.NULL.code === code) {
      return LocationModeEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown LocationModeEnum 'code' value '\${code}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "LocationModeEnum",
}
`;

exports[`generator-datamodel-ftest Functional Test Suite generator-app verify generated content should consistently create GeneratedContent[] 24`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/src",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/test/ftest-cache",
    "pkgName": "ftest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * AdministrativeGenderEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/administrative-gender
 * CodeSystem.name: AdministrativeGender
 * CodeSystem.description: The gender of a person used for administrative purposes.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: AdministrativeGenderEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem AdministrativeGender](http://hl7.org/fhir/administrative-gender)
 */
export class AdministrativeGenderEnum implements IFhirCodeEnum {
  public static readonly MALE = new FhirCodeDefinition(
    'MALE',
    'male',
    'http://hl7.org/fhir/administrative-gender',
    'Male',
    'Male.',
  );
  public static readonly FEMALE = new FhirCodeDefinition(
    'FEMALE',
    'female',
    'http://hl7.org/fhir/administrative-gender',
    'Female',
    'Female.',
  );
  public static readonly OTHER = new FhirCodeDefinition(
    'OTHER',
    'other',
    'http://hl7.org/fhir/administrative-gender',
    'Other',
    'Other.',
  );
  public static readonly UNKNOWN = new FhirCodeDefinition(
    'UNKNOWN',
    'unknown',
    'http://hl7.org/fhir/administrative-gender',
    'Unknown',
    'Unknown.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      AdministrativeGenderEnum.MALE,
      AdministrativeGenderEnum.FEMALE,
      AdministrativeGenderEnum.OTHER,
      AdministrativeGenderEnum.UNKNOWN,
      AdministrativeGenderEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {@link InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (AdministrativeGenderEnum.MALE.code === code) {
      return AdministrativeGenderEnum.MALE;
    } else if (AdministrativeGenderEnum.FEMALE.code === code) {
      return AdministrativeGenderEnum.FEMALE;
    } else if (AdministrativeGenderEnum.OTHER.code === code) {
      return AdministrativeGenderEnum.OTHER;
    } else if (AdministrativeGenderEnum.UNKNOWN.code === code) {
      return AdministrativeGenderEnum.UNKNOWN;
    } else if (AdministrativeGenderEnum.NULL.code === code) {
      return AdministrativeGenderEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown AdministrativeGenderEnum 'code' value '\${code}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "AdministrativeGenderEnum",
}
`;

exports[`generator-datamodel-ftest Functional Test Suite generator-app verify generated content should consistently create GeneratedContent[] 25`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/src",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/test/ftest-cache",
    "pkgName": "ftest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * LinkTypeEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/link-type
 * CodeSystem.name: LinkType
 * CodeSystem.description: The type of link between this patient resource and another patient resource.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: LinkTypeEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem LinkType](http://hl7.org/fhir/link-type)
 */
export class LinkTypeEnum implements IFhirCodeEnum {
  public static readonly REPLACED_BY = new FhirCodeDefinition(
    'REPLACED_BY',
    'replaced-by',
    'http://hl7.org/fhir/link-type',
    'Replaced-by',
    'The patient resource containing this link must no longer be used. The link points forward to another patient resource that must be used in lieu of the patient resource that contains this link.',
  );
  public static readonly REPLACES = new FhirCodeDefinition(
    'REPLACES',
    'replaces',
    'http://hl7.org/fhir/link-type',
    'Replaces',
    'The patient resource containing this link is the current active patient record. The link points back to an inactive patient resource that has been merged into this resource, and should be consulted to retrieve additional referenced information.',
  );
  public static readonly REFER = new FhirCodeDefinition(
    'REFER',
    'refer',
    'http://hl7.org/fhir/link-type',
    'Refer',
    'The patient resource containing this link is in use and valid but not considered the main source of information about a patient. The link points forward to another patient resource that should be consulted to retrieve additional patient information.',
  );
  public static readonly SEEALSO = new FhirCodeDefinition(
    'SEEALSO',
    'seealso',
    'http://hl7.org/fhir/link-type',
    'See also',
    'The patient resource containing this link is in use and valid, but points to another patient resource that is known to contain data about the same person. Data in this resource might overlap or contradict information found in the other patient resource. This link does not indicate any relative importance of the resources concerned, and both should be regarded as equally valid.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      LinkTypeEnum.REPLACED_BY,
      LinkTypeEnum.REPLACES,
      LinkTypeEnum.REFER,
      LinkTypeEnum.SEEALSO,
      LinkTypeEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {@link InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (LinkTypeEnum.REPLACED_BY.code === code) {
      return LinkTypeEnum.REPLACED_BY;
    } else if (LinkTypeEnum.REPLACES.code === code) {
      return LinkTypeEnum.REPLACES;
    } else if (LinkTypeEnum.REFER.code === code) {
      return LinkTypeEnum.REFER;
    } else if (LinkTypeEnum.SEEALSO.code === code) {
      return LinkTypeEnum.SEEALSO;
    } else if (LinkTypeEnum.NULL.code === code) {
      return LinkTypeEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown LinkTypeEnum 'code' value '\${code}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "LinkTypeEnum",
}
`;

exports[`generator-datamodel-ftest Functional Test Suite generator-app verify generated content should consistently create GeneratedContent[] 26`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/src",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/test/ftest-cache",
    "pkgName": "ftest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * TaskCodeEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/CodeSystem/task-code
 * CodeSystem.name: TaskCode
 * CodeSystem.description: Codes indicating the type of action that is expected to be performed
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: TaskCodeEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem TaskCode](http://hl7.org/fhir/CodeSystem/task-code)
 */
export class TaskCodeEnum implements IFhirCodeEnum {
  public static readonly APPROVE = new FhirCodeDefinition(
    'APPROVE',
    'approve',
    'http://hl7.org/fhir/CodeSystem/task-code',
    'Activate/approve the focal resource',
    'Take what actions are needed to transition the focus resource from \\'draft\\' to \\'active\\' or \\'in-progress\\', as appropriate for the resource type.  This may involve additing additional content, approval, validation, etc.',
  );
  public static readonly FULFILL = new FhirCodeDefinition(
    'FULFILL',
    'fulfill',
    'http://hl7.org/fhir/CodeSystem/task-code',
    'Fulfill the focal request',
    'Act to perform the actions defined in the focus request.  This might result in a \\'more assertive\\' request (order for a plan or proposal, filler order for a placer order), but is intend to eventually result in events.  The degree of fulfillment requested might be limited by Task.restriction.',
  );
  public static readonly ABORT = new FhirCodeDefinition(
    'ABORT',
    'abort',
    'http://hl7.org/fhir/CodeSystem/task-code',
    'Mark the focal resource as no longer active',
    'Abort, cancel or withdraw the focal resource, as appropriate for the type of resource.',
  );
  public static readonly REPLACE = new FhirCodeDefinition(
    'REPLACE',
    'replace',
    'http://hl7.org/fhir/CodeSystem/task-code',
    'Replace the focal resource with the input resource',
    'Replace the focal resource with the specified input resource',
  );
  public static readonly CHANGE = new FhirCodeDefinition(
    'CHANGE',
    'change',
    'http://hl7.org/fhir/CodeSystem/task-code',
    'Change the focal resource',
    'Update the focal resource of the owning system to reflect the content specified as the Task.focus',
  );
  public static readonly SUSPEND = new FhirCodeDefinition(
    'SUSPEND',
    'suspend',
    'http://hl7.org/fhir/CodeSystem/task-code',
    'Suspend the focal resource',
    'Transition the focal resource from \\'active\\' or \\'in-progress\\' to \\'suspended\\'',
  );
  public static readonly RESUME = new FhirCodeDefinition(
    'RESUME',
    'resume',
    'http://hl7.org/fhir/CodeSystem/task-code',
    'Re-activate the focal resource',
    'Transition the focal resource from \\'suspended\\' to \\'active\\' or \\'in-progress\\' as appropriate for the resource type.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      TaskCodeEnum.APPROVE,
      TaskCodeEnum.FULFILL,
      TaskCodeEnum.ABORT,
      TaskCodeEnum.REPLACE,
      TaskCodeEnum.CHANGE,
      TaskCodeEnum.SUSPEND,
      TaskCodeEnum.RESUME,
      TaskCodeEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {@link InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (TaskCodeEnum.APPROVE.code === code) {
      return TaskCodeEnum.APPROVE;
    } else if (TaskCodeEnum.FULFILL.code === code) {
      return TaskCodeEnum.FULFILL;
    } else if (TaskCodeEnum.ABORT.code === code) {
      return TaskCodeEnum.ABORT;
    } else if (TaskCodeEnum.REPLACE.code === code) {
      return TaskCodeEnum.REPLACE;
    } else if (TaskCodeEnum.CHANGE.code === code) {
      return TaskCodeEnum.CHANGE;
    } else if (TaskCodeEnum.SUSPEND.code === code) {
      return TaskCodeEnum.SUSPEND;
    } else if (TaskCodeEnum.RESUME.code === code) {
      return TaskCodeEnum.RESUME;
    } else if (TaskCodeEnum.NULL.code === code) {
      return TaskCodeEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown TaskCodeEnum 'code' value '\${code}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "TaskCodeEnum",
}
`;

exports[`generator-datamodel-ftest Functional Test Suite generator-app verify generated content should consistently create GeneratedContent[] 27`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/src",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/test/ftest-cache",
    "pkgName": "ftest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * TaskStatusEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/task-status
 * CodeSystem.name: TaskStatus
 * CodeSystem.description: The current status of the task.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: TaskStatusEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem TaskStatus](http://hl7.org/fhir/task-status)
 */
export class TaskStatusEnum implements IFhirCodeEnum {
  public static readonly DRAFT = new FhirCodeDefinition(
    'DRAFT',
    'draft',
    'http://hl7.org/fhir/task-status',
    'Draft',
    'The task is not yet ready to be acted upon.',
  );
  public static readonly REQUESTED = new FhirCodeDefinition(
    'REQUESTED',
    'requested',
    'http://hl7.org/fhir/task-status',
    'Requested',
    'The task is ready to be acted upon and action is sought.',
  );
  public static readonly RECEIVED = new FhirCodeDefinition(
    'RECEIVED',
    'received',
    'http://hl7.org/fhir/task-status',
    'Received',
    'A potential performer has claimed ownership of the task and is evaluating whether to perform it.',
  );
  public static readonly ACCEPTED = new FhirCodeDefinition(
    'ACCEPTED',
    'accepted',
    'http://hl7.org/fhir/task-status',
    'Accepted',
    'The potential performer has agreed to execute the task but has not yet started work.',
  );
  public static readonly REJECTED = new FhirCodeDefinition(
    'REJECTED',
    'rejected',
    'http://hl7.org/fhir/task-status',
    'Rejected',
    'The potential performer who claimed ownership of the task has decided not to execute it prior to performing any action.',
  );
  public static readonly READY = new FhirCodeDefinition(
    'READY',
    'ready',
    'http://hl7.org/fhir/task-status',
    'Ready',
    'The task is ready to be performed, but no action has yet been taken.  Used in place of requested/received/accepted/rejected when request assignment and acceptance is a given.',
  );
  public static readonly CANCELLED = new FhirCodeDefinition(
    'CANCELLED',
    'cancelled',
    'http://hl7.org/fhir/task-status',
    'Cancelled',
    'The task was not completed.',
  );
  public static readonly IN_PROGRESS = new FhirCodeDefinition(
    'IN_PROGRESS',
    'in-progress',
    'http://hl7.org/fhir/task-status',
    'In Progress',
    'The task has been started but is not yet complete.',
  );
  public static readonly ON_HOLD = new FhirCodeDefinition(
    'ON_HOLD',
    'on-hold',
    'http://hl7.org/fhir/task-status',
    'On Hold',
    'The task has been started but work has been paused.',
  );
  public static readonly FAILED = new FhirCodeDefinition(
    'FAILED',
    'failed',
    'http://hl7.org/fhir/task-status',
    'Failed',
    'The task was attempted but could not be completed due to some error.',
  );
  public static readonly COMPLETED = new FhirCodeDefinition(
    'COMPLETED',
    'completed',
    'http://hl7.org/fhir/task-status',
    'Completed',
    'The task has been completed.',
  );
  public static readonly ENTERED_IN_ERROR = new FhirCodeDefinition(
    'ENTERED_IN_ERROR',
    'entered-in-error',
    'http://hl7.org/fhir/task-status',
    'Entered in Error',
    'The task should never have existed and is retained only because of the possibility it may have used.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      TaskStatusEnum.DRAFT,
      TaskStatusEnum.REQUESTED,
      TaskStatusEnum.RECEIVED,
      TaskStatusEnum.ACCEPTED,
      TaskStatusEnum.REJECTED,
      TaskStatusEnum.READY,
      TaskStatusEnum.CANCELLED,
      TaskStatusEnum.IN_PROGRESS,
      TaskStatusEnum.ON_HOLD,
      TaskStatusEnum.FAILED,
      TaskStatusEnum.COMPLETED,
      TaskStatusEnum.ENTERED_IN_ERROR,
      TaskStatusEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {@link InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (TaskStatusEnum.DRAFT.code === code) {
      return TaskStatusEnum.DRAFT;
    } else if (TaskStatusEnum.REQUESTED.code === code) {
      return TaskStatusEnum.REQUESTED;
    } else if (TaskStatusEnum.RECEIVED.code === code) {
      return TaskStatusEnum.RECEIVED;
    } else if (TaskStatusEnum.ACCEPTED.code === code) {
      return TaskStatusEnum.ACCEPTED;
    } else if (TaskStatusEnum.REJECTED.code === code) {
      return TaskStatusEnum.REJECTED;
    } else if (TaskStatusEnum.READY.code === code) {
      return TaskStatusEnum.READY;
    } else if (TaskStatusEnum.CANCELLED.code === code) {
      return TaskStatusEnum.CANCELLED;
    } else if (TaskStatusEnum.IN_PROGRESS.code === code) {
      return TaskStatusEnum.IN_PROGRESS;
    } else if (TaskStatusEnum.ON_HOLD.code === code) {
      return TaskStatusEnum.ON_HOLD;
    } else if (TaskStatusEnum.FAILED.code === code) {
      return TaskStatusEnum.FAILED;
    } else if (TaskStatusEnum.COMPLETED.code === code) {
      return TaskStatusEnum.COMPLETED;
    } else if (TaskStatusEnum.ENTERED_IN_ERROR.code === code) {
      return TaskStatusEnum.ENTERED_IN_ERROR;
    } else if (TaskStatusEnum.NULL.code === code) {
      return TaskStatusEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown TaskStatusEnum 'code' value '\${code}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "TaskStatusEnum",
}
`;

exports[`generator-datamodel-ftest Functional Test Suite generator-app verify generated content should consistently create GeneratedContent[] 28`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/src",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/test/ftest-cache",
    "pkgName": "ftest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "CodeSystem",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR CodeSystem definition.
 * DO NOT make any modifications!
 *
 * ConsentStateCodesEnum Module
 *
 * CodeSystem.url: http://hl7.org/fhir/consent-state-codes
 * CodeSystem.name: ConsentStateCodes
 * CodeSystem.description: Indicates the state of the consent.
 * CodeSystem.version: 4.0.1
 * CodeSystem.caseSensitive: true
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import {
  fhirCode,
  FhirCodeDefinition,
  IFhirCodeDefinition,
  IFhirCodeEnum,
  InvalidCodeError,
} from '@paq-ts-fhir/fhir-core';

/**
 * FHIR CodeSystem: ConsentStateCodesEnum
 *
 * @remarks
 * This class is a "pseudo-enumeration" of code values having FHIR code properties.
 *
 * @category CodeSystems
 * @see [FHIR CodeSystem ConsentStateCodes](http://hl7.org/fhir/consent-state-codes)
 */
export class ConsentStateCodesEnum implements IFhirCodeEnum {
  public static readonly DRAFT = new FhirCodeDefinition(
    'DRAFT',
    'draft',
    'http://hl7.org/fhir/consent-state-codes',
    'Pending',
    'The consent is in development or awaiting use but is not yet intended to be acted upon.',
  );
  public static readonly PROPOSED = new FhirCodeDefinition(
    'PROPOSED',
    'proposed',
    'http://hl7.org/fhir/consent-state-codes',
    'Proposed',
    'The consent has been proposed but not yet agreed to by all parties. The negotiation stage.',
  );
  public static readonly ACTIVE = new FhirCodeDefinition(
    'ACTIVE',
    'active',
    'http://hl7.org/fhir/consent-state-codes',
    'Active',
    'The consent is to be followed and enforced.',
  );
  public static readonly REJECTED = new FhirCodeDefinition(
    'REJECTED',
    'rejected',
    'http://hl7.org/fhir/consent-state-codes',
    'Rejected',
    'The consent has been rejected by one or more of the parties.',
  );
  public static readonly INACTIVE = new FhirCodeDefinition(
    'INACTIVE',
    'inactive',
    'http://hl7.org/fhir/consent-state-codes',
    'Inactive',
    'The consent is terminated or replaced.',
  );
  public static readonly ENTERED_IN_ERROR = new FhirCodeDefinition(
    'ENTERED_IN_ERROR',
    'entered-in-error',
    'http://hl7.org/fhir/consent-state-codes',
    'Entered in Error',
    'The consent was created wrongly (e.g. wrong patient) and should be ignored.',
  );

  // NULL added to help check for non-existent value
  public static readonly NULL = new FhirCodeDefinition('NULL', \`null\`);

  /**
   * @returns an IFhirCodeDefinition[] containing the enumeration of code system code definitions
   */
  values(): IFhirCodeDefinition[] {
    return [
      ConsentStateCodesEnum.DRAFT,
      ConsentStateCodesEnum.PROPOSED,
      ConsentStateCodesEnum.ACTIVE,
      ConsentStateCodesEnum.REJECTED,
      ConsentStateCodesEnum.INACTIVE,
      ConsentStateCodesEnum.ENTERED_IN_ERROR,
      ConsentStateCodesEnum.NULL
    ];
  }

  /**
   * Converts a given FHIR code into its corresponding FHIR code definition.
   *
   * @param {fhirCode | undefined} code - The FHIR code to be converted. If undefined, an error will be thrown.
   * @returns {IFhirCodeDefinition} The FHIR code definition corresponding to the provided code.
   * @throws {@link InvalidCodeError} for undefined or invalid code value
   */
  fromCode(code: fhirCode | undefined): IFhirCodeDefinition {
    if (code === undefined) {
      throw new InvalidCodeError(\`The provided 'code' value is undefined\`);
    } else if (ConsentStateCodesEnum.DRAFT.code === code) {
      return ConsentStateCodesEnum.DRAFT;
    } else if (ConsentStateCodesEnum.PROPOSED.code === code) {
      return ConsentStateCodesEnum.PROPOSED;
    } else if (ConsentStateCodesEnum.ACTIVE.code === code) {
      return ConsentStateCodesEnum.ACTIVE;
    } else if (ConsentStateCodesEnum.REJECTED.code === code) {
      return ConsentStateCodesEnum.REJECTED;
    } else if (ConsentStateCodesEnum.INACTIVE.code === code) {
      return ConsentStateCodesEnum.INACTIVE;
    } else if (ConsentStateCodesEnum.ENTERED_IN_ERROR.code === code) {
      return ConsentStateCodesEnum.ENTERED_IN_ERROR;
    } else if (ConsentStateCodesEnum.NULL.code === code) {
      return ConsentStateCodesEnum.NULL;
    } else {
      throw new InvalidCodeError(\`Unknown ConsentStateCodesEnum 'code' value '\${code}'\`);
    }
  }
}
",
  "fileExtension": "ts",
  "filename": "ConsentStateCodesEnum",
}
`;

exports[`generator-datamodel-ftest Functional Test Suite generator-app verify generated content should consistently create GeneratedContent[] 29`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/src",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/test/ftest-cache",
    "pkgName": "ftest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "ComplexType",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinitions for FHIR complex datatypes.
 * DO NOT make any modifications!
 *
 * Combined FHIR Complex Datatypes Module
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  BackboneType,
  Base64BinaryType,
  BooleanType,
  CanonicalType,
  ChoiceDataTypes,
  ChoiceDataTypesMeta,
  CodeType,
  CodeableConcept,
  Coding,
  DataType,
  DateTimeType,
  DateType,
  DecimalType,
  EnumCodeType,
  Extension as CoreExtension,
  FhirError,
  FhirParser,
  IBackboneType,
  IDataType,
  INSTANCE_EMPTY_ERROR_MSG,
  IdType,
  Identifier,
  InstantType,
  Integer64Type,
  IntegerType,
  InvalidTypeError,
  JSON,
  MarkdownType,
  Meta,
  Narrative,
  OidType,
  ParsableDataType,
  Period,
  PositiveIntType,
  PrimitiveType,
  PrimitiveTypeJson,
  REQUIRED_PROPERTIES_DO_NOT_EXIST,
  REQUIRED_PROPERTIES_REQD_IN_JSON,
  Reference,
  ReferenceTargets,
  StringType,
  TimeType,
  UnsignedIntType,
  UriType,
  UrlType,
  UuidType,
  assertEnumCodeType,
  assertEnumCodeTypeList,
  assertFhirType,
  assertFhirTypeList,
  assertIsDefined,
  assertIsDefinedList,
  constructorCodeValueAsEnumCodeType,
  copyListValues,
  fhirBase64Binary,
  fhirBase64BinarySchema,
  fhirCanonical,
  fhirCanonicalSchema,
  fhirCode,
  fhirCodeSchema,
  fhirDateTime,
  fhirDateTimeSchema,
  fhirDecimal,
  fhirDecimalSchema,
  fhirId,
  fhirIdSchema,
  fhirInstant,
  fhirInstantSchema,
  fhirInteger,
  fhirInteger64,
  fhirInteger64Schema,
  fhirIntegerSchema,
  fhirMarkdown,
  fhirMarkdownSchema,
  fhirPositiveInt,
  fhirPositiveIntSchema,
  fhirString,
  fhirStringSchema,
  fhirTime,
  fhirTimeSchema,
  fhirUnsignedInt,
  fhirUnsignedIntSchema,
  fhirUri,
  fhirUriSchema,
  fhirUrl,
  fhirUrlSchema,
  getPrimitiveTypeJson,
  getPrimitiveTypeListJson,
  isDefined,
  isDefinedList,
  isElementEmpty,
  isEmpty,
  parseFhirPrimitiveData,
  setFhirComplexJson,
  setFhirComplexListJson,
  setFhirPrimitiveJson,
  setFhirPrimitiveListJson,
  setPolymorphicValueJson,
} from '@paq-ts-fhir/fhir-core';
import { AddressTypeEnum } from '../code-systems/AddressTypeEnum';
import { AddressUseEnum } from '../code-systems/AddressUseEnum';
import { ContactPointSystemEnum } from '../code-systems/ContactPointSystemEnum';
import { ContactPointUseEnum } from '../code-systems/ContactPointUseEnum';
import { ContributorTypeEnum } from '../code-systems/ContributorTypeEnum';
import { DaysOfWeekEnum } from '../code-systems/DaysOfWeekEnum';
import { NameUseEnum } from '../code-systems/NameUseEnum';
import { OperationParameterUseEnum } from '../code-systems/OperationParameterUseEnum';
import { PARSABLE_RESOURCE_MAP } from '../resources/parsable-resource-map';
import { QuantityComparatorEnum } from '../code-systems/QuantityComparatorEnum';
import { RelatedArtifactTypeEnum } from '../code-systems/RelatedArtifactTypeEnum';
import { SortDirectionEnum } from '../code-systems/SortDirectionEnum';
import { TriggerTypeEnum } from '../code-systems/TriggerTypeEnum';

// eslint-disable-next-line @typescript-eslint/no-explicit-any -- Symbol.metadata polyfill secret sauce for decorator metadata
(Symbol.metadata as any) ??= Symbol('Symbol.metadata');

// The fhir-core complex types must be exported from @paq-ts-fhir/fhir-core rather than using the generated complex types.
export { CodeableConcept, Coding, Identifier, Meta, Narrative, Period, Reference } from '@paq-ts-fhir/fhir-core';


/**
 * Address Class
 *
 * @remarks
 * Base StructureDefinition for Address Type: An address expressed using postal conventions (as opposed to GPS or other location definition formats).  This data type may be used to convey addresses for use in delivering mail as well as for visiting locations which might not be valid for mail delivery.  There are a variety of postal address formats defined around the world.
 *
 * Need to be able to record postal addresses, along with notes about their use.
 *
 * **FHIR Specification**
 * - **Short:** An address expressed using postal conventions (as opposed to GPS or other location definition formats)
 * - **Definition:** An address expressed using postal conventions (as opposed to GPS or other location definition formats).  This data type may be used to convey addresses for use in delivering mail as well as for visiting locations which might not be valid for mail delivery.  There are a variety of postal address formats defined around the world.
 * - **Comment:** Note: address is intended to describe postal addresses for administrative purposes, not to describe absolute geographical coordinates.  Postal addresses are often used as proxies for physical locations (also see the [Location](https://hl7.org/fhir/location.html#) resource).
 * - **FHIR Version:** 4.0.1
 *
 * @category Data Models: ComplexType
 * @see [FHIR Address](http://hl7.org/fhir/StructureDefinition/Address)
 */
/* istanbul ignore next */ export class Address extends DataType implements IDataType {
  constructor() {
    super();

    this.addressUseEnum = new AddressUseEnum();
    this.addressTypeEnum = new AddressTypeEnum();
  }

  /**
   * Parse the provided \`Address\` JSON to instantiate the Address data model.
   *
   * @param sourceJson - JSON representing FHIR \`Address\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Address
   * @returns Address data model or undefined for \`Address\`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Address | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Address';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Address();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'use';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setUseElement(datatype);
    }

    fieldName = 'type';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setTypeElement(datatype);
    }

    fieldName = 'text';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setTextElement(datatype);
    }

    fieldName = 'line';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: StringType | undefined = fhirParser.parseStringType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addLineElement(datatype);
        }
      });
    }

    fieldName = 'city';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setCityElement(datatype);
    }

    fieldName = 'district';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setDistrictElement(datatype);
    }

    fieldName = 'state';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setStateElement(datatype);
    }

    fieldName = 'postalCode';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setPostalCodeElement(datatype);
    }

    fieldName = 'country';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setCountryElement(datatype);
    }

    fieldName = 'period';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Period | undefined = Period.parse(classJsonObj[fieldName]!, sourceField);
      instance.setPeriod(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: AddressUse
   *
   * @see {@link AddressUseEnum }
   */
  private readonly addressUseEnum: AddressUseEnum;

  /**
   * Address.use Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** home | work | temp | old | billing - purpose of this address
   * - **Definition:** The purpose of this address.
   * - **Comment:** Applications can assume that an address is current unless it explicitly says that it is temporary or old.
   * - **Requirements:** Allows an appropriate address to be chosen from a list of many.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** true
   * - **isModifierReason:** This is labeled as &quot;Is Modifier&quot; because applications should not mistake a temporary or old address etc.for a current/permanent one
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link AddressUseEnum }
   */
  private use?: EnumCodeType | undefined;

  /**
   * FHIR CodeSystem: AddressType
   *
   * @see {@link AddressTypeEnum }
   */
  private readonly addressTypeEnum: AddressTypeEnum;

  /**
   * Address.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** postal | physical | both
   * - **Definition:** Distinguishes between physical addresses (those you can visit) and mailing addresses (e.g. PO Boxes and care-of addresses). Most addresses are both.
   * - **Comment:** The definition of Address states that "address is intended to describe postal addresses, not physical locations". However, many applications track whether an address has a dual purpose of being a location that can be visited as well as being a valid delivery destination, and Postal addresses are often used as proxies for physical locations (also see the [Location](https://hl7.org/fhir/location.html#) resource).
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link AddressTypeEnum }
   */
  private type_?: EnumCodeType | undefined;

  /**
   * Address.text Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Text representation of the address
   * - **Definition:** Specifies the entire address as it should be displayed e.g. on a postal label. This may be provided instead of or as well as the specific parts.
   * - **Comment:** Can provide both a text representation and parts. Applications updating an address SHALL ensure that  when both text and parts are present,  no content is included in the text that isn\\'t found in a part.
   * - **Requirements:** A renderable, unencoded form.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private text?: StringType | undefined;

  /**
   * Address.line Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Street name, number, direction & P.O. Box etc.
   * - **Definition:** This component contains the house number, apartment number, street name, street direction,  P.O. Box number, delivery hints, and similar address information.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private line?: StringType[] | undefined;

  /**
   * Address.city Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Name of city, town etc.
   * - **Definition:** The name of the city, town, suburb, village or other community or delivery center.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private city?: StringType | undefined;

  /**
   * Address.district Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** District name (aka county)
   * - **Definition:** The name of the administrative area (county).
   * - **Comment:** District is sometimes known as county, but in some regions \\'county\\' is used in place of city (municipality), so county name should be conveyed in city instead.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private district?: StringType | undefined;

  /**
   * Address.state Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Sub-unit of country (abbreviations ok)
   * - **Definition:** Sub-unit of a country with limited sovereignty in a federally organized country. A code may be used if codes are in common use (e.g. US 2 letter state codes).
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private state?: StringType | undefined;

  /**
   * Address.postalCode Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Postal code for area
   * - **Definition:** A postal code designating a region defined by the postal service.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private postalCode?: StringType | undefined;

  /**
   * Address.country Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Country (e.g. can be ISO 3166 2 or 3 letter code)
   * - **Definition:** Country - a nation as commonly understood or generally accepted.
   * - **Comment:** ISO 3166 3 letter codes can be used in place of a human readable country name.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private country?: StringType | undefined;

  /**
   * Address.period Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Time period when address was/is in use
   * - **Definition:** Time period when address was/is in use.
   * - **Requirements:** Allows addresses to be placed in historical context.
   * - **FHIR Type:** \`Period\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private period?: Period | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`use\` property value as a EnumCodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link AddressUseEnum }
   */
  public getUseEnumType(): EnumCodeType | undefined {
    return this.use;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`use\` property.
   *
   * @param enumType - the \`use\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code values
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link AddressUseEnum }
   */
  public setUseEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid Address.use';
      assertEnumCodeType<AddressUseEnum>(enumType, AddressUseEnum, errMsgPrefix);
      this.use = enumType;
    } else {
      this.use = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`use\` property exists and has a value; \`false\` otherwise
   */
  public hasUseEnumType(): boolean {
    return isDefined<EnumCodeType>(this.use) && !this.use.isEmpty() && this.use.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`use\` property value as a CodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link AddressUseEnum }
   */
  public getUseElement(): CodeType | undefined {
    if (this.use === undefined) {
      return undefined;
    }
    return this.use as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`use\` property.
   *
   * @param element - the \`use\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link AddressUseEnum }
   */
  public setUseElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Address.use; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.use = new EnumCodeType(element, this.addressUseEnum);
    } else {
      this.use = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`use\` property exists and has a value; \`false\` otherwise
   */
  public hasUseElement(): boolean {
    return this.hasUseEnumType();
  }

  /**
   * @returns the \`use\` property value as a fhirCode if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link AddressUseEnum }
   */
  public getUse(): fhirCode | undefined {
    if (this.use === undefined) {
      return undefined;
    }
    return this.use.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`use\` property.
   *
   * @param value - the \`use\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link AddressUseEnum }
   */
  public setUse(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Address.use; Provided value is not an instance of fhirCode.\`;
      this.use = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.addressUseEnum);
    } else {
      this.use = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`use\` property exists and has a value; \`false\` otherwise
   */
  public hasUse(): boolean {
    return this.hasUseEnumType();
  }

  /**
   * @returns the \`type_\` property value as a EnumCodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link AddressTypeEnum }
   */
  public getTypeEnumType(): EnumCodeType | undefined {
    return this.type_;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`type_\` property.
   *
   * @param enumType - the \`type_\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code values
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link AddressTypeEnum }
   */
  public setTypeEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid Address.type';
      assertEnumCodeType<AddressTypeEnum>(enumType, AddressTypeEnum, errMsgPrefix);
      this.type_ = enumType;
    } else {
      this.type_ = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasTypeEnumType(): boolean {
    return isDefined<EnumCodeType>(this.type_) && !this.type_.isEmpty() && this.type_.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`type_\` property value as a CodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link AddressTypeEnum }
   */
  public getTypeElement(): CodeType | undefined {
    if (this.type_ === undefined) {
      return undefined;
    }
    return this.type_ as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`type_\` property.
   *
   * @param element - the \`type_\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link AddressTypeEnum }
   */
  public setTypeElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Address.type; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.type_ = new EnumCodeType(element, this.addressTypeEnum);
    } else {
      this.type_ = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasTypeElement(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the \`type_\` property value as a fhirCode if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link AddressTypeEnum }
   */
  public getType(): fhirCode | undefined {
    if (this.type_ === undefined) {
      return undefined;
    }
    return this.type_.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`type_\` property.
   *
   * @param value - the \`type_\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link AddressTypeEnum }
   */
  public setType(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Address.type; Provided value is not an instance of fhirCode.\`;
      this.type_ = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.addressTypeEnum);
    } else {
      this.type_ = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasType(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the \`text\` property value as a StringType object if defined; else an empty StringType object
   */
  public getTextElement(): StringType {
    return this.text ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`text\` property.
   *
   * @param element - the \`text\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTextElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Address.text; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.text = element;
    } else {
      this.text = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`text\` property exists and has a value; \`false\` otherwise
   */
  public hasTextElement(): boolean {
    return isDefined<StringType>(this.text) && !this.text.isEmpty();
  }

  /**
   * @returns the \`text\` property value as a fhirString if defined; else undefined
   */
  public getText(): fhirString | undefined {
    return this.text?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`text\` property.
   *
   * @param value - the \`text\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setText(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Address.text (\${String(value)})\`;
      this.text = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.text = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`text\` property exists and has a value; \`false\` otherwise
   */
  public hasText(): boolean {
    return this.hasTextElement();
  }

  /**
   * @returns the \`line\` property value as a StringType array
   */
  public getLineElement(): StringType[] {
    return this.line ?? ([] as StringType[]);
  }

  /**
   * Assigns the provided StringType array value to the \`line\` property.
   *
   * @param element - the \`line\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLineElement(element: StringType[] | undefined): this {
    if (isDefinedList<StringType>(element)) {
      const optErrMsg = \`Invalid Address.line; Provided value array has an element that is not an instance of StringType.\`;
      assertFhirTypeList<StringType>(element, StringType, optErrMsg);
      this.line = element;
    } else {
      this.line = undefined;
    }
    return this;
  }

  /**
   * Add the provided StringType value to the \`line\` array property.
   *
   * @param element - the \`line\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addLineElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Address.line; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.initLine();
      this.line?.push(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`line\` property exists and has a value; \`false\` otherwise
   */
  public hasLineElement(): boolean {
    return isDefinedList<StringType>(this.line) && this.line.some((item: StringType) => !item.isEmpty());
  }

  /**
   * @returns the \`line\` property value as a fhirString array
   */
  public getLine(): fhirString[] {
    this.initLine();
    const lineValues = [] as fhirString[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.line!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        lineValues.push(value);
      }
    }
    return lineValues;
  }

  /**
   * Assigns the provided primitive value array to the \`line\` property.
   *
   * @param value - the \`line\` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLine(value: fhirString[] | undefined): this {
    if (isDefinedList<fhirString>(value)) {
      const lineElements = [] as StringType[];
      for (const lineValue of value) {
        const optErrMsg = \`Invalid Address.line array item (\${String(lineValue)})\`;
        const element = new StringType(parseFhirPrimitiveData(lineValue, fhirStringSchema, optErrMsg));
        lineElements.push(element);
      }
      this.line = lineElements;
    } else {
      this.line = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`line\` array property.
   *
   * @param value - the \`line\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addLine(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Address.line array item (\${String(value)})\`;
      const element = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
      this.initLine();
      this.addLineElement(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`line\` property exists and has a value; \`false\` otherwise
   */
  public hasLine(): boolean {
    return this.hasLineElement();
  }

  /**
   * Initialize the \`line\` property
   */
  private initLine(): void {
    if (!this.hasLine()) {
      this.line = [] as StringType[];
    }
  }

  /**
   * @returns the \`city\` property value as a StringType object if defined; else an empty StringType object
   */
  public getCityElement(): StringType {
    return this.city ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`city\` property.
   *
   * @param element - the \`city\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCityElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Address.city; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.city = element;
    } else {
      this.city = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`city\` property exists and has a value; \`false\` otherwise
   */
  public hasCityElement(): boolean {
    return isDefined<StringType>(this.city) && !this.city.isEmpty();
  }

  /**
   * @returns the \`city\` property value as a fhirString if defined; else undefined
   */
  public getCity(): fhirString | undefined {
    return this.city?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`city\` property.
   *
   * @param value - the \`city\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCity(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Address.city (\${String(value)})\`;
      this.city = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.city = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`city\` property exists and has a value; \`false\` otherwise
   */
  public hasCity(): boolean {
    return this.hasCityElement();
  }

  /**
   * @returns the \`district\` property value as a StringType object if defined; else an empty StringType object
   */
  public getDistrictElement(): StringType {
    return this.district ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`district\` property.
   *
   * @param element - the \`district\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDistrictElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Address.district; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.district = element;
    } else {
      this.district = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`district\` property exists and has a value; \`false\` otherwise
   */
  public hasDistrictElement(): boolean {
    return isDefined<StringType>(this.district) && !this.district.isEmpty();
  }

  /**
   * @returns the \`district\` property value as a fhirString if defined; else undefined
   */
  public getDistrict(): fhirString | undefined {
    return this.district?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`district\` property.
   *
   * @param value - the \`district\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDistrict(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Address.district (\${String(value)})\`;
      this.district = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.district = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`district\` property exists and has a value; \`false\` otherwise
   */
  public hasDistrict(): boolean {
    return this.hasDistrictElement();
  }

  /**
   * @returns the \`state\` property value as a StringType object if defined; else an empty StringType object
   */
  public getStateElement(): StringType {
    return this.state ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`state\` property.
   *
   * @param element - the \`state\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setStateElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Address.state; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.state = element;
    } else {
      this.state = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`state\` property exists and has a value; \`false\` otherwise
   */
  public hasStateElement(): boolean {
    return isDefined<StringType>(this.state) && !this.state.isEmpty();
  }

  /**
   * @returns the \`state\` property value as a fhirString if defined; else undefined
   */
  public getState(): fhirString | undefined {
    return this.state?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`state\` property.
   *
   * @param value - the \`state\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setState(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Address.state (\${String(value)})\`;
      this.state = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.state = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`state\` property exists and has a value; \`false\` otherwise
   */
  public hasState(): boolean {
    return this.hasStateElement();
  }

  /**
   * @returns the \`postalCode\` property value as a StringType object if defined; else an empty StringType object
   */
  public getPostalCodeElement(): StringType {
    return this.postalCode ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`postalCode\` property.
   *
   * @param element - the \`postalCode\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPostalCodeElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Address.postalCode; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.postalCode = element;
    } else {
      this.postalCode = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`postalCode\` property exists and has a value; \`false\` otherwise
   */
  public hasPostalCodeElement(): boolean {
    return isDefined<StringType>(this.postalCode) && !this.postalCode.isEmpty();
  }

  /**
   * @returns the \`postalCode\` property value as a fhirString if defined; else undefined
   */
  public getPostalCode(): fhirString | undefined {
    return this.postalCode?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`postalCode\` property.
   *
   * @param value - the \`postalCode\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPostalCode(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Address.postalCode (\${String(value)})\`;
      this.postalCode = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.postalCode = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`postalCode\` property exists and has a value; \`false\` otherwise
   */
  public hasPostalCode(): boolean {
    return this.hasPostalCodeElement();
  }

  /**
   * @returns the \`country\` property value as a StringType object if defined; else an empty StringType object
   */
  public getCountryElement(): StringType {
    return this.country ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`country\` property.
   *
   * @param element - the \`country\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCountryElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Address.country; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.country = element;
    } else {
      this.country = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`country\` property exists and has a value; \`false\` otherwise
   */
  public hasCountryElement(): boolean {
    return isDefined<StringType>(this.country) && !this.country.isEmpty();
  }

  /**
   * @returns the \`country\` property value as a fhirString if defined; else undefined
   */
  public getCountry(): fhirString | undefined {
    return this.country?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`country\` property.
   *
   * @param value - the \`country\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCountry(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Address.country (\${String(value)})\`;
      this.country = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.country = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`country\` property exists and has a value; \`false\` otherwise
   */
  public hasCountry(): boolean {
    return this.hasCountryElement();
  }

  /**
   * @returns the \`period\` property value as a Period object if defined; else an empty Period object
   */
  public getPeriod(): Period {
    return this.period ?? new Period();
  }

  /**
   * Assigns the provided Period object value to the \`period\` property.
   *
   * @param value - the \`period\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setPeriod(value: Period | undefined): this {
    if (isDefined<Period>(value)) {
      const optErrMsg = \`Invalid Address.period; Provided element is not an instance of Period.\`;
      assertFhirType<Period>(value, Period, optErrMsg);
      this.period = value;
    } else {
      this.period = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`period\` property exists and has a value; \`false\` otherwise
   */
  public hasPeriod(): boolean {
    return isDefined<Period>(this.period) && !this.period.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Address';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.use,
      this.type_,
      this.text,
      this.line,
      this.city,
      this.district,
      this.state,
      this.postalCode,
      this.country,
      this.period,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Address {
    const dest = new Address();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Address): void {
    super.copyValues(dest);
    dest.use = this.use?.copy();
    dest.type_ = this.type_?.copy();
    dest.text = this.text?.copy();
    const lineList = copyListValues<StringType>(this.line);
    dest.line = lineList.length === 0 ? undefined : lineList;
    dest.city = this.city?.copy();
    dest.district = this.district?.copy();
    dest.state = this.state?.copy();
    dest.postalCode = this.postalCode?.copy();
    dest.country = this.country?.copy();
    dest.period = this.period?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', \`UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasUseElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getUseElement()!, 'use', jsonObj);
    }

    if (this.hasTypeElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getTypeElement()!, 'type', jsonObj);
    }

    if (this.hasTextElement()) {
      setFhirPrimitiveJson<fhirString>(this.getTextElement(), 'text', jsonObj);
    }

    if (this.hasLine()) {
      setFhirPrimitiveListJson(this.getLineElement(), 'line', jsonObj);
    }

    if (this.hasCityElement()) {
      setFhirPrimitiveJson<fhirString>(this.getCityElement(), 'city', jsonObj);
    }

    if (this.hasDistrictElement()) {
      setFhirPrimitiveJson<fhirString>(this.getDistrictElement(), 'district', jsonObj);
    }

    if (this.hasStateElement()) {
      setFhirPrimitiveJson<fhirString>(this.getStateElement(), 'state', jsonObj);
    }

    if (this.hasPostalCodeElement()) {
      setFhirPrimitiveJson<fhirString>(this.getPostalCodeElement(), 'postalCode', jsonObj);
    }

    if (this.hasCountryElement()) {
      setFhirPrimitiveJson<fhirString>(this.getCountryElement(), 'country', jsonObj);
    }

    if (this.hasPeriod()) {
      setFhirComplexJson(this.getPeriod(), 'period', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * Age Class
 *
 * @remarks
 * Base StructureDefinition for Age Type: A duration of time during which an organism (or a process) has existed.
 *
 * **FHIR Specification**
 * - **Short:** A duration of time during which an organism (or a process) has existed
 * - **Definition:** A duration of time during which an organism (or a process) has existed.
 * - **Comment:** The context of use may frequently define what kind of quantity this is and therefore what kind of units can be used. The context of use may also restrict the values for the comparator.
 * - **FHIR Version:** 4.0.1
 *
 * @category Data Models: ComplexType
 * @see [FHIR Age](http://hl7.org/fhir/StructureDefinition/Age)
 */
/* istanbul ignore next */ export class Age extends DataType implements IDataType {
  constructor() {
    super();

    this.quantityComparatorEnum = new QuantityComparatorEnum();
  }

  /**
   * Parse the provided \`Age\` JSON to instantiate the Age data model.
   *
   * @param sourceJson - JSON representing FHIR \`Age\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Age
   * @returns Age data model or undefined for \`Age\`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Age | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Age';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Age();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'value';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setValueElement(datatype);
    }

    fieldName = 'comparator';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setComparatorElement(datatype);
    }

    fieldName = 'unit';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setUnitElement(datatype);
    }

    fieldName = 'system';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = fhirParser.parseUriType(dtJson, dtSiblingJson);
      instance.setSystemElement(datatype);
    }

    fieldName = 'code';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setCodeElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Age.value Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Numerical value (with implicit precision)
   * - **Definition:** The value of the measured amount. The value includes an implicit precision in the presentation of the value.
   * - **Comment:** The implicit precision in the value should always be honored. Monetary values have their own rules for handling precision (refer to standard accounting text books).
   * - **Requirements:** Precision is handled implicitly in almost all cases of measurement.
   * - **FHIR Type:** \`decimal\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private value?: DecimalType | undefined;

  /**
   * FHIR CodeSystem: QuantityComparator
   *
   * @see {@link QuantityComparatorEnum }
   */
  private readonly quantityComparatorEnum: QuantityComparatorEnum;

  /**
   * Age.comparator Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** < | <= | >= | > - how to understand the value
   * - **Definition:** How the value should be understood and represented - whether the actual value is greater or less than the stated value due to measurement issues; e.g. if the comparator is "<" , then the real value is < stated value.
   * - **Requirements:** Need a framework for handling measures where the value is <5ug/L or >400mg/L due to the limitations of measuring methodology.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** true
   * - **isModifierReason:** This is labeled as &quot;Is Modifier&quot; because the comparator modifies the interpretation of the value significantly. If there is no comparator, then there is no modification of the value
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  private comparator?: EnumCodeType | undefined;

  /**
   * Age.unit Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Unit representation
   * - **Definition:** A human-readable form of the unit.
   * - **Requirements:** There are many representations for units of measure and in many contexts, particular representations are fixed and required. I.e. mcg for micrograms.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private unit?: StringType | undefined;

  /**
   * Age.system Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** System that defines coded unit form
   * - **Definition:** The identification of the system that provides the coded form of the unit.
   * - **Requirements:** Need to know the system that defines the coded form of the unit.
   * - **FHIR Type:** \`uri\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private system?: UriType | undefined;

  /**
   * Age.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Coded form of the unit
   * - **Definition:** A computer processable form of the unit in some unit representation system.
   * - **Comment:** The preferred system is UCUM, but SNOMED CT can also be used (for customary units) or ISO 4217 for currency.  The context of use may additionally require a code from a particular system.
   * - **Requirements:** Need a computable form of the unit that is fixed across all forms. UCUM provides this for quantities, but SNOMED CT provides many units of interest.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code?: CodeType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`value\` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getValueElement(): DecimalType {
    return this.value ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`value\` property.
   *
   * @param element - the \`value\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValueElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = \`Invalid Age.value; Provided element is not an instance of DecimalType.\`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.value = element;
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`value\` property exists and has a value; \`false\` otherwise
   */
  public hasValueElement(): boolean {
    return isDefined<DecimalType>(this.value) && !this.value.isEmpty();
  }

  /**
   * @returns the \`value\` property value as a fhirDecimal if defined; else undefined
   */
  public getValue(): fhirDecimal | undefined {
    return this.value?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`value\` property.
   *
   * @param value - the \`value\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValue(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = \`Invalid Age.value (\${String(value)})\`;
      this.value = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`value\` property exists and has a value; \`false\` otherwise
   */
  public hasValue(): boolean {
    return this.hasValueElement();
  }

  /**
   * @returns the \`comparator\` property value as a EnumCodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public getComparatorEnumType(): EnumCodeType | undefined {
    return this.comparator;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`comparator\` property.
   *
   * @param enumType - the \`comparator\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code values
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public setComparatorEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid Age.comparator';
      assertEnumCodeType<QuantityComparatorEnum>(enumType, QuantityComparatorEnum, errMsgPrefix);
      this.comparator = enumType;
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`comparator\` property exists and has a value; \`false\` otherwise
   */
  public hasComparatorEnumType(): boolean {
    return isDefined<EnumCodeType>(this.comparator) && !this.comparator.isEmpty() && this.comparator.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`comparator\` property value as a CodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public getComparatorElement(): CodeType | undefined {
    if (this.comparator === undefined) {
      return undefined;
    }
    return this.comparator as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`comparator\` property.
   *
   * @param element - the \`comparator\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public setComparatorElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Age.comparator; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.comparator = new EnumCodeType(element, this.quantityComparatorEnum);
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`comparator\` property exists and has a value; \`false\` otherwise
   */
  public hasComparatorElement(): boolean {
    return this.hasComparatorEnumType();
  }

  /**
   * @returns the \`comparator\` property value as a fhirCode if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public getComparator(): fhirCode | undefined {
    if (this.comparator === undefined) {
      return undefined;
    }
    return this.comparator.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`comparator\` property.
   *
   * @param value - the \`comparator\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public setComparator(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Age.comparator; Provided value is not an instance of fhirCode.\`;
      this.comparator = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.quantityComparatorEnum);
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`comparator\` property exists and has a value; \`false\` otherwise
   */
  public hasComparator(): boolean {
    return this.hasComparatorEnumType();
  }

  /**
   * @returns the \`unit\` property value as a StringType object if defined; else an empty StringType object
   */
  public getUnitElement(): StringType {
    return this.unit ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`unit\` property.
   *
   * @param element - the \`unit\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUnitElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Age.unit; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.unit = element;
    } else {
      this.unit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`unit\` property exists and has a value; \`false\` otherwise
   */
  public hasUnitElement(): boolean {
    return isDefined<StringType>(this.unit) && !this.unit.isEmpty();
  }

  /**
   * @returns the \`unit\` property value as a fhirString if defined; else undefined
   */
  public getUnit(): fhirString | undefined {
    return this.unit?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`unit\` property.
   *
   * @param value - the \`unit\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUnit(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Age.unit (\${String(value)})\`;
      this.unit = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.unit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`unit\` property exists and has a value; \`false\` otherwise
   */
  public hasUnit(): boolean {
    return this.hasUnitElement();
  }

  /**
   * @returns the \`system\` property value as a UriType object if defined; else an empty UriType object
   */
  public getSystemElement(): UriType {
    return this.system ?? new UriType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`system\` property.
   *
   * @param element - the \`system\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSystemElement(element: UriType | undefined): this {
    if (isDefined<UriType>(element)) {
      const optErrMsg = \`Invalid Age.system; Provided element is not an instance of UriType.\`;
      assertFhirType<UriType>(element, UriType, optErrMsg);
      this.system = element;
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`system\` property exists and has a value; \`false\` otherwise
   */
  public hasSystemElement(): boolean {
    return isDefined<UriType>(this.system) && !this.system.isEmpty();
  }

  /**
   * @returns the \`system\` property value as a fhirUri if defined; else undefined
   */
  public getSystem(): fhirUri | undefined {
    return this.system?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`system\` property.
   *
   * @param value - the \`system\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSystem(value: fhirUri | undefined): this {
    if (isDefined<fhirUri>(value)) {
      const optErrMsg = \`Invalid Age.system (\${String(value)})\`;
      this.system = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`system\` property exists and has a value; \`false\` otherwise
   */
  public hasSystem(): boolean {
    return this.hasSystemElement();
  }

  /**
   * @returns the \`code\` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getCodeElement(): CodeType {
    return this.code ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`code\` property.
   *
   * @param element - the \`code\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCodeElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Age.code; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.code = element;
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`code\` property exists and has a value; \`false\` otherwise
   */
  public hasCodeElement(): boolean {
    return isDefined<CodeType>(this.code) && !this.code.isEmpty();
  }

  /**
   * @returns the \`code\` property value as a fhirCode if defined; else undefined
   */
  public getCode(): fhirCode | undefined {
    return this.code?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`code\` property.
   *
   * @param value - the \`code\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCode(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Age.code (\${String(value)})\`;
      this.code = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`code\` property exists and has a value; \`false\` otherwise
   */
  public hasCode(): boolean {
    return this.hasCodeElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Age';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.value,
      this.comparator,
      this.unit,
      this.system,
      this.code,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Age {
    const dest = new Age();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Age): void {
    super.copyValues(dest);
    dest.value = this.value?.copy();
    dest.comparator = this.comparator?.copy();
    dest.unit = this.unit?.copy();
    dest.system = this.system?.copy();
    dest.code = this.code?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', \`UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasValueElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getValueElement(), 'value', jsonObj);
    }

    if (this.hasComparatorElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getComparatorElement()!, 'comparator', jsonObj);
    }

    if (this.hasUnitElement()) {
      setFhirPrimitiveJson<fhirString>(this.getUnitElement(), 'unit', jsonObj);
    }

    if (this.hasSystemElement()) {
      setFhirPrimitiveJson<fhirUri>(this.getSystemElement(), 'system', jsonObj);
    }

    if (this.hasCodeElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getCodeElement(), 'code', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * Annotation Class
 *
 * @remarks
 * Base StructureDefinition for Annotation Type: A  text note which also  contains information about who made the statement and when.
 *
 * **FHIR Specification**
 * - **Short:** Text node with attribution
 * - **Definition:** A  text note which also  contains information about who made the statement and when.
 * - **Comment:** For systems that do not have structured annotations, they can simply communicate a single annotation with no author or time.  This element may need to be included in narrative because of the potential for modifying information.  *Annotations SHOULD NOT* be used to communicate "modifying" information that could be computable. (This is a SHOULD because enforcing user behavior is nearly impossible).
 * - **FHIR Version:** 4.0.1
 *
 * @category Data Models: ComplexType
 * @see [FHIR Annotation](http://hl7.org/fhir/StructureDefinition/Annotation)
 */
/* istanbul ignore next */ export class Annotation extends DataType implements IDataType {
  constructor(text: MarkdownType | fhirMarkdown | null = null) {
    super();

    this.text = null;
    if (isDefined<MarkdownType | fhirMarkdown>(text)) {
      if (text instanceof PrimitiveType) {
        this.setTextElement(text);
      } else {
        this.setText(text);
      }
    }
  }

  /**
   * Parse the provided \`Annotation\` JSON to instantiate the Annotation data model.
   *
   * @param sourceJson - JSON representing FHIR \`Annotation\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Annotation
   * @returns Annotation data model or undefined for \`Annotation\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Annotation | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Annotation';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Annotation();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const classMetadata: DecoratorMetadataObject | null = Annotation[Symbol.metadata];
    const errorMessage = \`DecoratorMetadataObject does not exist for Annotation\`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    const missingReqdProperties: string[] = [];

    fieldName = 'author[x]';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const author: IDataType | undefined = fhirParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setAuthor(author);

    fieldName = 'time';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DateTimeType | undefined = fhirParser.parseDateTimeType(dtJson, dtSiblingJson);
      instance.setTimeElement(datatype);
    }

    fieldName = 'text';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: MarkdownType | undefined = fhirParser.parseMarkdownType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setTextElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Annotation.author[x] Element
   *
   * @decorator \`@ChoiceDataTypesMeta('Annotation.author[x]', ['Reference','string',]\`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Individual responsible for the annotation
   * - **Definition:** The individual responsible for making the annotation.
   * - **Comment:** Organization is used when there\\'s no need for specific attribution as to who made the comment.
   * - **FHIR Types:**
   *     'Reference',
   *     'string',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('Annotation.author[x]',[
    'Reference',
    'string',
  ])
  private author?: IDataType | undefined;

  /**
   * Annotation.time Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** When the annotation was made
   * - **Definition:** Indicates when this particular annotation was made.
   * - **FHIR Type:** \`dateTime\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private time?: DateTimeType | undefined;

  /**
   * Annotation.text Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The annotation  - text content (as markdown)
   * - **Definition:** The text of the annotation in markdown format.
   * - **FHIR Type:** \`markdown\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private text: MarkdownType | null;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`author\` property value as a DataType object if defined; else undefined
   */
  public getAuthor(): IDataType | undefined {
    return this.author;
  }

  /**
   * Assigns the provided DataType object value to the \`author\` property.
   *
   * @decorator \`@ChoiceDataTypes('Annotation.author[x]')\`
   *
   * @param value - the \`author\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  @ChoiceDataTypes('Annotation.author[x]')
  public setAuthor(value: IDataType | undefined): this {
    if (isDefined<IDataType>(value)) {
      // assertFhirType<IDataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.author = value;
    } else {
      this.author = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`author\` property exists and has a value; \`false\` otherwise
   */
  public hasAuthor(): boolean {
    return isDefined<IDataType>(this.author) && !this.author.isEmpty();
  }

  // *** NOTE ***
  // Following choice datatype-specific "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the \`author\` property value as a Reference object if defined; else undefined
   */
  public getAuthorReference(): Reference | undefined {
    if (!isDefined<IDataType | undefined>(this.author)) {
      return undefined;
    }
    if (!(this.author instanceof Reference)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Annotation.author[x]: Expected Reference but encountered \${this.author.fhirType()}\`,
      );
    }
    return this.author;
  }

  /**
   * @returns \`true\` if the \`author\` property exists as a Reference and has a value; \`false\` otherwise
   */
  public hasAuthorReference(): boolean {
    return this.hasAuthor() && this.author instanceof Reference;
  }

  /**
   * @returns the \`author\` property value as a StringType object if defined; else undefined
   */
  public getAuthorStringType(): StringType | undefined {
    if (!isDefined<IDataType | undefined>(this.author)) {
      return undefined;
    }
    if (!(this.author instanceof StringType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Annotation.author[x]: Expected StringType but encountered \${this.author.fhirType()}\`,
      );
    }
    return this.author;
  }

  /**
   * @returns \`true\` if the \`author\` property exists as a StringType and has a value; \`false\` otherwise
   */
  public hasAuthorStringType(): boolean {
    return this.hasAuthor() && this.author instanceof StringType;
  }

  // End of choice datatype-specific "get"/"has" methods

  /**
   * @returns the \`time\` property value as a DateTimeType object if defined; else an empty DateTimeType object
   */
  public getTimeElement(): DateTimeType {
    return this.time ?? new DateTimeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`time\` property.
   *
   * @param element - the \`time\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTimeElement(element: DateTimeType | undefined): this {
    if (isDefined<DateTimeType>(element)) {
      const optErrMsg = \`Invalid Annotation.time; Provided element is not an instance of DateTimeType.\`;
      assertFhirType<DateTimeType>(element, DateTimeType, optErrMsg);
      this.time = element;
    } else {
      this.time = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`time\` property exists and has a value; \`false\` otherwise
   */
  public hasTimeElement(): boolean {
    return isDefined<DateTimeType>(this.time) && !this.time.isEmpty();
  }

  /**
   * @returns the \`time\` property value as a fhirDateTime if defined; else undefined
   */
  public getTime(): fhirDateTime | undefined {
    return this.time?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`time\` property.
   *
   * @param value - the \`time\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTime(value: fhirDateTime | undefined): this {
    if (isDefined<fhirDateTime>(value)) {
      const optErrMsg = \`Invalid Annotation.time (\${String(value)})\`;
      this.time = new DateTimeType(parseFhirPrimitiveData(value, fhirDateTimeSchema, optErrMsg));
    } else {
      this.time = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`time\` property exists and has a value; \`false\` otherwise
   */
  public hasTime(): boolean {
    return this.hasTimeElement();
  }

  /**
   * @returns the \`text\` property value as a MarkdownType object if defined; else null
   */
  public getTextElement(): MarkdownType | null {
    return this.text;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`text\` property.
   *
   * @param element - the \`text\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTextElement(element: MarkdownType): this {
    assertIsDefined<MarkdownType>(element, \`Annotation.text is required\`);
    const optErrMsg = \`Invalid Annotation.text; Provided value is not an instance of MarkdownType.\`;
    assertFhirType<MarkdownType>(element, MarkdownType, optErrMsg);
    this.text = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`text\` property exists and has a value; \`false\` otherwise
   */
  public hasTextElement(): boolean {
    return isDefined<MarkdownType>(this.text) && !this.text.isEmpty();
  }

  /**
   * @returns the \`text\` property value as a fhirMarkdown if defined; else null
   */
  public getText(): fhirMarkdown | null {
    if (this.text?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.text.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`text\` property.
   *
   * @param value - the \`text\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setText(value: fhirMarkdown): this {
    assertIsDefined<fhirMarkdown>(value, \`Annotation.text is required\`);
    const optErrMsg = \`Invalid Annotation.text (\${String(value)})\`;
    this.text = new MarkdownType(parseFhirPrimitiveData(value, fhirMarkdownSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`text\` property exists and has a value; \`false\` otherwise
   */
  public hasText(): boolean {
    return this.hasTextElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Annotation';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.author,
      this.time,
      this.text,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Annotation {
    const dest = new Annotation();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Annotation): void {
    super.copyValues(dest);
    dest.author = this.author?.copy() as IDataType;
    dest.time = this.time?.copy();
    dest.text = this.text ? this.text.copy() : null;
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', \`UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasAuthor()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getAuthor()!, 'author', jsonObj);
    }

    if (this.hasTimeElement()) {
      setFhirPrimitiveJson<fhirDateTime>(this.getTimeElement(), 'time', jsonObj);
    }

    if (this.hasTextElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirMarkdown>(this.getTextElement()!, 'text', jsonObj);
    } else {
      missingReqdProperties.push(\`Annotation.text\`);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

/**
 * Attachment Class
 *
 * @remarks
 * Attachment Type: For referring to data content defined in other formats.
 *
 * Many models need to include data defined in other specifications that is complex and opaque to the healthcare model. This includes documents, media recordings, structured data, etc.
 *
 * **FHIR Specification**
 * - **Short:** Content in a format defined elsewhere
 * - **Definition:** For referring to data content defined in other formats.
 * - **Comment:** When providing a summary view (for example with Observation.value[x]) Attachment should be represented with a brief display text such as "Signed Procedure Consent".
 * - **FHIR Version:** 5.0.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR Attachment](http://hl7.org/fhir/StructureDefinition/Attachment)
 */
/* istanbul ignore next */ export class Attachment extends DataType implements IDataType {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`Attachment\` JSON to instantiate the Attachment data model.
   *
   * @param sourceJson - JSON representing FHIR \`Attachment\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Attachment
   * @returns Attachment data model or undefined for \`Attachment\`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Attachment | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Attachment';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Attachment();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'contentType';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setContentTypeElement(datatype);
    }

    fieldName = 'language';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setLanguageElement(datatype);
    }

    fieldName = 'data';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: Base64BinaryType | undefined = fhirParser.parseBase64BinaryType(dtJson, dtSiblingJson);
      instance.setDataElement(datatype);
    }

    fieldName = 'url';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UrlType | undefined = fhirParser.parseUrlType(dtJson, dtSiblingJson);
      instance.setUrlElement(datatype);
    }

    fieldName = 'size';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: Integer64Type | undefined = fhirParser.parseInteger64Type(dtJson, dtSiblingJson);
      instance.setSizeElement(datatype);
    }

    fieldName = 'hash';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: Base64BinaryType | undefined = fhirParser.parseBase64BinaryType(dtJson, dtSiblingJson);
      instance.setHashElement(datatype);
    }

    fieldName = 'title';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setTitleElement(datatype);
    }

    fieldName = 'creation';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DateTimeType | undefined = fhirParser.parseDateTimeType(dtJson, dtSiblingJson);
      instance.setCreationElement(datatype);
    }

    fieldName = 'height';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = fhirParser.parsePositiveIntType(dtJson, dtSiblingJson);
      instance.setHeightElement(datatype);
    }

    fieldName = 'width';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = fhirParser.parsePositiveIntType(dtJson, dtSiblingJson);
      instance.setWidthElement(datatype);
    }

    fieldName = 'frames';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = fhirParser.parsePositiveIntType(dtJson, dtSiblingJson);
      instance.setFramesElement(datatype);
    }

    fieldName = 'duration';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setDurationElement(datatype);
    }

    fieldName = 'pages';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = fhirParser.parsePositiveIntType(dtJson, dtSiblingJson);
      instance.setPagesElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Attachment.contentType Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Mime type of the content, with charset etc.
   * - **Definition:** Identifies the type of the data in the attachment and allows a method to be chosen to interpret or render the data. Includes mime type parameters such as charset where appropriate.
   * - **Requirements:** Processors of the data need to be able to know how to interpret the data.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private contentType?: CodeType | undefined;

  /**
   * Attachment.language Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Human language of the content (BCP-47)
   * - **Definition:** The human language of the content. The value can be any valid value according to BCP 47.
   * - **Requirements:** Users need to be able to choose between the languages in a set of attachments.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private language?: CodeType | undefined;

  /**
   * Attachment.data Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Data inline, base64ed
   * - **Definition:** The actual data of the attachment - a sequence of bytes, base64 encoded.
   * - **Comment:** The base64-encoded data SHALL be expressed in the same character set as the base resource XML or JSON.
   * - **Requirements:** The data needs to able to be transmitted inline.
   * - **FHIR Type:** \`base64Binary\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private data?: Base64BinaryType | undefined;

  /**
   * Attachment.url Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Uri where the data can be found
   * - **Definition:** A location where the data can be accessed.
   * - **Comment:** If both data and url are provided, the url SHALL point to the same content as the data contains. Urls may be relative references or may reference transient locations such as a wrapping envelope using cid: though this has ramifications for using signatures. Relative URLs are interpreted relative to the service url, like a resource reference, rather than relative to the resource itself. If a URL is provided, it SHALL resolve to actual data.
   * - **Requirements:** The data needs to be transmitted by reference.
   * - **FHIR Type:** \`url\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private url?: UrlType | undefined;

  /**
   * Attachment.size Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Number of bytes of content (if url provided)
   * - **Definition:** The number of bytes of data that make up this attachment (before base64 encoding, if that is done).
   * - **Comment:** The number of bytes is redundant if the data is provided as a base64binary, but is useful if the data is provided as a url reference.
   * - **Requirements:** Representing the size allows applications to determine whether they should fetch the content automatically in advance, or refuse to fetch it at all.
   * - **FHIR Type:** \`integer64\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private size?: Integer64Type | undefined;

  /**
   * Attachment.hash Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Hash of the data (sha-1, base64ed)
   * - **Definition:** The calculated hash of the data using SHA-1. Represented using base64.
   * - **Comment:** The hash is calculated on the data prior to base64 encoding, if the data is based64 encoded. The hash is not intended to support digital signatures. Where protection against malicious threats a digital signature should be considered, see [Provenance.signature](https://hl7.org/fhir/provenance-definitions.html#Provenance.signature) for mechanism to protect a resource with a digital signature.
   * - **Requirements:** Included so that applications can verify that the contents of a location have not changed due to technical failures (e.g., storage rot, transport glitch, incorrect version).
   * - **FHIR Type:** \`base64Binary\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private hash?: Base64BinaryType | undefined;

  /**
   * Attachment.title Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Label to display in place of the data
   * - **Definition:** A label or set of text to display in place of the data.
   * - **Comment:** May sometimes be derived from the source filename.
   * - **Requirements:** Applications need a label to display to a human user in place of the actual data if the data cannot be rendered or perceived by the viewer.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private title?: StringType | undefined;

  /**
   * Attachment.creation Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Date attachment was first created
   * - **Definition:** The date that the attachment was first created.
   * - **Requirements:** This is often tracked as an integrity issue for use of the attachment.
   * - **FHIR Type:** \`dateTime\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private creation?: DateTimeType | undefined;

  /**
   * Attachment.height Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Height of the image in pixels (photo/video)
   * - **Definition:** Height of the image in pixels (photo/video).
   * - **FHIR Type:** \`positiveInt\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private height?: PositiveIntType | undefined;

  /**
   * Attachment.width Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Width of the image in pixels (photo/video)
   * - **Definition:** Width of the image in pixels (photo/video).
   * - **FHIR Type:** \`positiveInt\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private width?: PositiveIntType | undefined;

  /**
   * Attachment.frames Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Number of frames if > 1 (photo)
   * - **Definition:** The number of frames in a photo. This is used with a multi-page fax, or an imaging acquisition context that takes multiple slices in a single image, or an animated gif. If there is more than one frame, this SHALL have a value in order to alert interface software that a multi-frame capable rendering widget is required.
   * - **Comment:** if the number of frames is not supplied, the value may be unknown. Applications should not assume that there is only one frame unless it is explicitly stated.
   * - **FHIR Type:** \`positiveInt\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private frames?: PositiveIntType | undefined;

  /**
   * Attachment.duration Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Length in seconds (audio / video)
   * - **Definition:** The duration of the recording in seconds - for audio and video.
   * - **Comment:** The duration might differ from occurrencePeriod if recording was paused.
   * - **FHIR Type:** \`decimal\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private duration?: DecimalType | undefined;

  /**
   * Attachment.pages Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Number of printed pages
   * - **Definition:** The number of pages when printed.
   * - **FHIR Type:** \`positiveInt\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private pages?: PositiveIntType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`contentType\` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getContentTypeElement(): CodeType {
    return this.contentType ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`contentType\` property.
   *
   * @param element - the \`contentType\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setContentTypeElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Attachment.contentType; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.contentType = element;
    } else {
      this.contentType = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`contentType\` property exists and has a value; \`false\` otherwise
   */
  public hasContentTypeElement(): boolean {
    return isDefined<CodeType>(this.contentType) && !this.contentType.isEmpty();
  }

  /**
   * @returns the \`contentType\` property value as a fhirCode if defined; else undefined
   */
  public getContentType(): fhirCode | undefined {
    return this.contentType?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`contentType\` property.
   *
   * @param value - the \`contentType\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setContentType(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Attachment.contentType (\${String(value)})\`;
      this.contentType = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.contentType = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`contentType\` property exists and has a value; \`false\` otherwise
   */
  public hasContentType(): boolean {
    return this.hasContentTypeElement();
  }

  /**
   * @returns the \`language\` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getLanguageElement(): CodeType {
    return this.language ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`language\` property.
   *
   * @param element - the \`language\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLanguageElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Attachment.language; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.language = element;
    } else {
      this.language = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`language\` property exists and has a value; \`false\` otherwise
   */
  public hasLanguageElement(): boolean {
    return isDefined<CodeType>(this.language) && !this.language.isEmpty();
  }

  /**
   * @returns the \`language\` property value as a fhirCode if defined; else undefined
   */
  public getLanguage(): fhirCode | undefined {
    return this.language?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`language\` property.
   *
   * @param value - the \`language\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLanguage(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Attachment.language (\${String(value)})\`;
      this.language = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.language = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`language\` property exists and has a value; \`false\` otherwise
   */
  public hasLanguage(): boolean {
    return this.hasLanguageElement();
  }

  /**
   * @returns the \`data\` property value as a Base64BinaryType object if defined; else an empty Base64BinaryType object
   */
  public getDataElement(): Base64BinaryType {
    return this.data ?? new Base64BinaryType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`data\` property.
   *
   * @param element - the \`data\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDataElement(element: Base64BinaryType | undefined): this {
    if (isDefined<Base64BinaryType>(element)) {
      const optErrMsg = \`Invalid Attachment.data; Provided element is not an instance of Base64BinaryType.\`;
      assertFhirType<Base64BinaryType>(element, Base64BinaryType, optErrMsg);
      this.data = element;
    } else {
      this.data = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`data\` property exists and has a value; \`false\` otherwise
   */
  public hasDataElement(): boolean {
    return isDefined<Base64BinaryType>(this.data) && !this.data.isEmpty();
  }

  /**
   * @returns the \`data\` property value as a fhirBase64Binary if defined; else undefined
   */
  public getData(): fhirBase64Binary | undefined {
    return this.data?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`data\` property.
   *
   * @param value - the \`data\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setData(value: fhirBase64Binary | undefined): this {
    if (isDefined<fhirBase64Binary>(value)) {
      const optErrMsg = \`Invalid Attachment.data (\${String(value)})\`;
      this.data = new Base64BinaryType(parseFhirPrimitiveData(value, fhirBase64BinarySchema, optErrMsg));
    } else {
      this.data = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`data\` property exists and has a value; \`false\` otherwise
   */
  public hasData(): boolean {
    return this.hasDataElement();
  }

  /**
   * @returns the \`url\` property value as a UrlType object if defined; else an empty UrlType object
   */
  public getUrlElement(): UrlType {
    return this.url ?? new UrlType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`url\` property.
   *
   * @param element - the \`url\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUrlElement(element: UrlType | undefined): this {
    if (isDefined<UrlType>(element)) {
      const optErrMsg = \`Invalid Attachment.url; Provided element is not an instance of UrlType.\`;
      assertFhirType<UrlType>(element, UrlType, optErrMsg);
      this.url = element;
    } else {
      this.url = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`url\` property exists and has a value; \`false\` otherwise
   */
  public hasUrlElement(): boolean {
    return isDefined<UrlType>(this.url) && !this.url.isEmpty();
  }

  /**
   * @returns the \`url\` property value as a fhirUrl if defined; else undefined
   */
  public getUrl(): fhirUrl | undefined {
    return this.url?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`url\` property.
   *
   * @param value - the \`url\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUrl(value: fhirUrl | undefined): this {
    if (isDefined<fhirUrl>(value)) {
      const optErrMsg = \`Invalid Attachment.url (\${String(value)})\`;
      this.url = new UrlType(parseFhirPrimitiveData(value, fhirUrlSchema, optErrMsg));
    } else {
      this.url = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`url\` property exists and has a value; \`false\` otherwise
   */
  public hasUrl(): boolean {
    return this.hasUrlElement();
  }

  /**
   * @returns the \`size\` property value as a Integer64Type object if defined; else an empty Integer64Type object
   */
  public getSizeElement(): Integer64Type {
    return this.size ?? new Integer64Type();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`size\` property.
   *
   * @param element - the \`size\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSizeElement(element: Integer64Type | undefined): this {
    if (isDefined<Integer64Type>(element)) {
      const optErrMsg = \`Invalid Attachment.size; Provided element is not an instance of Integer64Type.\`;
      assertFhirType<Integer64Type>(element, Integer64Type, optErrMsg);
      this.size = element;
    } else {
      this.size = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`size\` property exists and has a value; \`false\` otherwise
   */
  public hasSizeElement(): boolean {
    return isDefined<Integer64Type>(this.size) && !this.size.isEmpty();
  }

  /**
   * @returns the \`size\` property value as a fhirInteger64 if defined; else undefined
   */
  public getSize(): fhirInteger64 | undefined {
    return this.size?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`size\` property.
   *
   * @param value - the \`size\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSize(value: fhirInteger64 | undefined): this {
    if (isDefined<fhirInteger64>(value)) {
      const optErrMsg = \`Invalid Attachment.size (\${String(value)})\`;
      this.size = new Integer64Type(parseFhirPrimitiveData(value, fhirInteger64Schema, optErrMsg));
    } else {
      this.size = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`size\` property exists and has a value; \`false\` otherwise
   */
  public hasSize(): boolean {
    return this.hasSizeElement();
  }

  /**
   * @returns the \`hash\` property value as a Base64BinaryType object if defined; else an empty Base64BinaryType object
   */
  public getHashElement(): Base64BinaryType {
    return this.hash ?? new Base64BinaryType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`hash\` property.
   *
   * @param element - the \`hash\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setHashElement(element: Base64BinaryType | undefined): this {
    if (isDefined<Base64BinaryType>(element)) {
      const optErrMsg = \`Invalid Attachment.hash; Provided element is not an instance of Base64BinaryType.\`;
      assertFhirType<Base64BinaryType>(element, Base64BinaryType, optErrMsg);
      this.hash = element;
    } else {
      this.hash = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`hash\` property exists and has a value; \`false\` otherwise
   */
  public hasHashElement(): boolean {
    return isDefined<Base64BinaryType>(this.hash) && !this.hash.isEmpty();
  }

  /**
   * @returns the \`hash\` property value as a fhirBase64Binary if defined; else undefined
   */
  public getHash(): fhirBase64Binary | undefined {
    return this.hash?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`hash\` property.
   *
   * @param value - the \`hash\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setHash(value: fhirBase64Binary | undefined): this {
    if (isDefined<fhirBase64Binary>(value)) {
      const optErrMsg = \`Invalid Attachment.hash (\${String(value)})\`;
      this.hash = new Base64BinaryType(parseFhirPrimitiveData(value, fhirBase64BinarySchema, optErrMsg));
    } else {
      this.hash = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`hash\` property exists and has a value; \`false\` otherwise
   */
  public hasHash(): boolean {
    return this.hasHashElement();
  }

  /**
   * @returns the \`title\` property value as a StringType object if defined; else an empty StringType object
   */
  public getTitleElement(): StringType {
    return this.title ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`title\` property.
   *
   * @param element - the \`title\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTitleElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Attachment.title; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.title = element;
    } else {
      this.title = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`title\` property exists and has a value; \`false\` otherwise
   */
  public hasTitleElement(): boolean {
    return isDefined<StringType>(this.title) && !this.title.isEmpty();
  }

  /**
   * @returns the \`title\` property value as a fhirString if defined; else undefined
   */
  public getTitle(): fhirString | undefined {
    return this.title?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`title\` property.
   *
   * @param value - the \`title\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTitle(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Attachment.title (\${String(value)})\`;
      this.title = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.title = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`title\` property exists and has a value; \`false\` otherwise
   */
  public hasTitle(): boolean {
    return this.hasTitleElement();
  }

  /**
   * @returns the \`creation\` property value as a DateTimeType object if defined; else an empty DateTimeType object
   */
  public getCreationElement(): DateTimeType {
    return this.creation ?? new DateTimeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`creation\` property.
   *
   * @param element - the \`creation\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCreationElement(element: DateTimeType | undefined): this {
    if (isDefined<DateTimeType>(element)) {
      const optErrMsg = \`Invalid Attachment.creation; Provided element is not an instance of DateTimeType.\`;
      assertFhirType<DateTimeType>(element, DateTimeType, optErrMsg);
      this.creation = element;
    } else {
      this.creation = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`creation\` property exists and has a value; \`false\` otherwise
   */
  public hasCreationElement(): boolean {
    return isDefined<DateTimeType>(this.creation) && !this.creation.isEmpty();
  }

  /**
   * @returns the \`creation\` property value as a fhirDateTime if defined; else undefined
   */
  public getCreation(): fhirDateTime | undefined {
    return this.creation?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`creation\` property.
   *
   * @param value - the \`creation\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCreation(value: fhirDateTime | undefined): this {
    if (isDefined<fhirDateTime>(value)) {
      const optErrMsg = \`Invalid Attachment.creation (\${String(value)})\`;
      this.creation = new DateTimeType(parseFhirPrimitiveData(value, fhirDateTimeSchema, optErrMsg));
    } else {
      this.creation = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`creation\` property exists and has a value; \`false\` otherwise
   */
  public hasCreation(): boolean {
    return this.hasCreationElement();
  }

  /**
   * @returns the \`height\` property value as a PositiveIntType object if defined; else an empty PositiveIntType object
   */
  public getHeightElement(): PositiveIntType {
    return this.height ?? new PositiveIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`height\` property.
   *
   * @param element - the \`height\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setHeightElement(element: PositiveIntType | undefined): this {
    if (isDefined<PositiveIntType>(element)) {
      const optErrMsg = \`Invalid Attachment.height; Provided element is not an instance of PositiveIntType.\`;
      assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
      this.height = element;
    } else {
      this.height = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`height\` property exists and has a value; \`false\` otherwise
   */
  public hasHeightElement(): boolean {
    return isDefined<PositiveIntType>(this.height) && !this.height.isEmpty();
  }

  /**
   * @returns the \`height\` property value as a fhirPositiveInt if defined; else undefined
   */
  public getHeight(): fhirPositiveInt | undefined {
    return this.height?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`height\` property.
   *
   * @param value - the \`height\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setHeight(value: fhirPositiveInt | undefined): this {
    if (isDefined<fhirPositiveInt>(value)) {
      const optErrMsg = \`Invalid Attachment.height (\${String(value)})\`;
      this.height = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    } else {
      this.height = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`height\` property exists and has a value; \`false\` otherwise
   */
  public hasHeight(): boolean {
    return this.hasHeightElement();
  }

  /**
   * @returns the \`width\` property value as a PositiveIntType object if defined; else an empty PositiveIntType object
   */
  public getWidthElement(): PositiveIntType {
    return this.width ?? new PositiveIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`width\` property.
   *
   * @param element - the \`width\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setWidthElement(element: PositiveIntType | undefined): this {
    if (isDefined<PositiveIntType>(element)) {
      const optErrMsg = \`Invalid Attachment.width; Provided element is not an instance of PositiveIntType.\`;
      assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
      this.width = element;
    } else {
      this.width = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`width\` property exists and has a value; \`false\` otherwise
   */
  public hasWidthElement(): boolean {
    return isDefined<PositiveIntType>(this.width) && !this.width.isEmpty();
  }

  /**
   * @returns the \`width\` property value as a fhirPositiveInt if defined; else undefined
   */
  public getWidth(): fhirPositiveInt | undefined {
    return this.width?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`width\` property.
   *
   * @param value - the \`width\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setWidth(value: fhirPositiveInt | undefined): this {
    if (isDefined<fhirPositiveInt>(value)) {
      const optErrMsg = \`Invalid Attachment.width (\${String(value)})\`;
      this.width = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    } else {
      this.width = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`width\` property exists and has a value; \`false\` otherwise
   */
  public hasWidth(): boolean {
    return this.hasWidthElement();
  }

  /**
   * @returns the \`frames\` property value as a PositiveIntType object if defined; else an empty PositiveIntType object
   */
  public getFramesElement(): PositiveIntType {
    return this.frames ?? new PositiveIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`frames\` property.
   *
   * @param element - the \`frames\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setFramesElement(element: PositiveIntType | undefined): this {
    if (isDefined<PositiveIntType>(element)) {
      const optErrMsg = \`Invalid Attachment.frames; Provided element is not an instance of PositiveIntType.\`;
      assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
      this.frames = element;
    } else {
      this.frames = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`frames\` property exists and has a value; \`false\` otherwise
   */
  public hasFramesElement(): boolean {
    return isDefined<PositiveIntType>(this.frames) && !this.frames.isEmpty();
  }

  /**
   * @returns the \`frames\` property value as a fhirPositiveInt if defined; else undefined
   */
  public getFrames(): fhirPositiveInt | undefined {
    return this.frames?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`frames\` property.
   *
   * @param value - the \`frames\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setFrames(value: fhirPositiveInt | undefined): this {
    if (isDefined<fhirPositiveInt>(value)) {
      const optErrMsg = \`Invalid Attachment.frames (\${String(value)})\`;
      this.frames = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    } else {
      this.frames = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`frames\` property exists and has a value; \`false\` otherwise
   */
  public hasFrames(): boolean {
    return this.hasFramesElement();
  }

  /**
   * @returns the \`duration\` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getDurationElement(): DecimalType {
    return this.duration ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`duration\` property.
   *
   * @param element - the \`duration\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDurationElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = \`Invalid Attachment.duration; Provided element is not an instance of DecimalType.\`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.duration = element;
    } else {
      this.duration = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`duration\` property exists and has a value; \`false\` otherwise
   */
  public hasDurationElement(): boolean {
    return isDefined<DecimalType>(this.duration) && !this.duration.isEmpty();
  }

  /**
   * @returns the \`duration\` property value as a fhirDecimal if defined; else undefined
   */
  public getDuration(): fhirDecimal | undefined {
    return this.duration?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`duration\` property.
   *
   * @param value - the \`duration\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDuration(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = \`Invalid Attachment.duration (\${String(value)})\`;
      this.duration = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.duration = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`duration\` property exists and has a value; \`false\` otherwise
   */
  public hasDuration(): boolean {
    return this.hasDurationElement();
  }

  /**
   * @returns the \`pages\` property value as a PositiveIntType object if defined; else an empty PositiveIntType object
   */
  public getPagesElement(): PositiveIntType {
    return this.pages ?? new PositiveIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`pages\` property.
   *
   * @param element - the \`pages\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPagesElement(element: PositiveIntType | undefined): this {
    if (isDefined<PositiveIntType>(element)) {
      const optErrMsg = \`Invalid Attachment.pages; Provided element is not an instance of PositiveIntType.\`;
      assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
      this.pages = element;
    } else {
      this.pages = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`pages\` property exists and has a value; \`false\` otherwise
   */
  public hasPagesElement(): boolean {
    return isDefined<PositiveIntType>(this.pages) && !this.pages.isEmpty();
  }

  /**
   * @returns the \`pages\` property value as a fhirPositiveInt if defined; else undefined
   */
  public getPages(): fhirPositiveInt | undefined {
    return this.pages?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`pages\` property.
   *
   * @param value - the \`pages\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPages(value: fhirPositiveInt | undefined): this {
    if (isDefined<fhirPositiveInt>(value)) {
      const optErrMsg = \`Invalid Attachment.pages (\${String(value)})\`;
      this.pages = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    } else {
      this.pages = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`pages\` property exists and has a value; \`false\` otherwise
   */
  public hasPages(): boolean {
    return this.hasPagesElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Attachment';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.contentType,
      this.language,
      this.data,
      this.url,
      this.size,
      this.hash,
      this.title,
      this.creation,
      this.height,
      this.width,
      this.frames,
      this.duration,
      this.pages,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Attachment {
    const dest = new Attachment();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Attachment): void {
    super.copyValues(dest);
    dest.contentType = this.contentType?.copy();
    dest.language = this.language?.copy();
    dest.data = this.data?.copy();
    dest.url = this.url?.copy();
    dest.size = this.size?.copy();
    dest.hash = this.hash?.copy();
    dest.title = this.title?.copy();
    dest.creation = this.creation?.copy();
    dest.height = this.height?.copy();
    dest.width = this.width?.copy();
    dest.frames = this.frames?.copy();
    dest.duration = this.duration?.copy();
    dest.pages = this.pages?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', \`UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasContentTypeElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getContentTypeElement(), 'contentType', jsonObj);
    }

    if (this.hasLanguageElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getLanguageElement(), 'language', jsonObj);
    }

    if (this.hasDataElement()) {
      setFhirPrimitiveJson<fhirBase64Binary>(this.getDataElement(), 'data', jsonObj);
    }

    if (this.hasUrlElement()) {
      setFhirPrimitiveJson<fhirUrl>(this.getUrlElement(), 'url', jsonObj);
    }

    if (this.hasSizeElement()) {
      setFhirPrimitiveJson<fhirInteger64>(this.getSizeElement(), 'size', jsonObj);
    }

    if (this.hasHashElement()) {
      setFhirPrimitiveJson<fhirBase64Binary>(this.getHashElement(), 'hash', jsonObj);
    }

    if (this.hasTitleElement()) {
      setFhirPrimitiveJson<fhirString>(this.getTitleElement(), 'title', jsonObj);
    }

    if (this.hasCreationElement()) {
      setFhirPrimitiveJson<fhirDateTime>(this.getCreationElement(), 'creation', jsonObj);
    }

    if (this.hasHeightElement()) {
      setFhirPrimitiveJson<fhirPositiveInt>(this.getHeightElement(), 'height', jsonObj);
    }

    if (this.hasWidthElement()) {
      setFhirPrimitiveJson<fhirPositiveInt>(this.getWidthElement(), 'width', jsonObj);
    }

    if (this.hasFramesElement()) {
      setFhirPrimitiveJson<fhirPositiveInt>(this.getFramesElement(), 'frames', jsonObj);
    }

    if (this.hasDurationElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getDurationElement(), 'duration', jsonObj);
    }

    if (this.hasPagesElement()) {
      setFhirPrimitiveJson<fhirPositiveInt>(this.getPagesElement(), 'pages', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * ContactDetail Class
 *
 * @remarks
 * Base StructureDefinition for ContactDetail Type: Specifies contact information for a person or organization.
 *
 * Need to track contact information in the same way across multiple resources.
 *
 * **FHIR Specification**
 * - **Short:** Contact information
 * - **Definition:** Specifies contact information for a person or organization.
 * - **FHIR Version:** 4.0.1
 *
 * @category Data Models: ComplexType
 * @see [FHIR ContactDetail](http://hl7.org/fhir/StructureDefinition/ContactDetail)
 */
/* istanbul ignore next */ export class ContactDetail extends DataType implements IDataType {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`ContactDetail\` JSON to instantiate the ContactDetail data model.
   *
   * @param sourceJson - JSON representing FHIR \`ContactDetail\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to ContactDetail
   * @returns ContactDetail data model or undefined for \`ContactDetail\`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): ContactDetail | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'ContactDetail';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new ContactDetail();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    

    fieldName = 'name';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setNameElement(datatype);
    }

    fieldName = 'telecom';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: ContactPoint | undefined = ContactPoint.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addTelecom(datatype);
        }
      });
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * ContactDetail.name Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Name of an individual to contact
   * - **Definition:** The name of an individual to contact.
   * - **Comment:** If there is no named individual, the telecom information is for the organization as a whole.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private name?: StringType | undefined;

  /**
   * ContactDetail.telecom Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Contact details for individual or organization
   * - **Definition:** The contact details for the individual (if a name was provided) or the organization.
   * - **FHIR Type:** \`ContactPoint\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private telecom?: ContactPoint[] | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`name\` property value as a StringType object if defined; else an empty StringType object
   */
  public getNameElement(): StringType {
    return this.name ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`name\` property.
   *
   * @param element - the \`name\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setNameElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid ContactDetail.name; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.name = element;
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`name\` property exists and has a value; \`false\` otherwise
   */
  public hasNameElement(): boolean {
    return isDefined<StringType>(this.name) && !this.name.isEmpty();
  }

  /**
   * @returns the \`name\` property value as a fhirString if defined; else undefined
   */
  public getName(): fhirString | undefined {
    return this.name?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`name\` property.
   *
   * @param value - the \`name\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setName(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid ContactDetail.name (\${String(value)})\`;
      this.name = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`name\` property exists and has a value; \`false\` otherwise
   */
  public hasName(): boolean {
    return this.hasNameElement();
  }

  /**
   * @returns the \`telecom\` property value as a ContactPoint array
   */
  public getTelecom(): ContactPoint[] {
    return this.telecom ?? ([] as ContactPoint[]);
  }

  /**
   * Assigns the provided ContactPoint array value to the \`telecom\` property.
   *
   * @param value - the \`telecom\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setTelecom(value: ContactPoint[] | undefined): this {
    if (isDefinedList<ContactPoint>(value)) {
      const optErrMsg = \`Invalid ContactDetail.telecom; Provided value array has an element that is not an instance of ContactPoint.\`;
      assertFhirTypeList<ContactPoint>(value, ContactPoint, optErrMsg);
      this.telecom = value;
    } else {
      this.telecom = undefined;
    }
    return this;
  }

  /**
   * Add the provided ContactPoint value to the \`telecom\` array property.
   *
   * @param value - the \`telecom\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addTelecom(value: ContactPoint | undefined): this {
    if (isDefined<ContactPoint>(value)) {
      const optErrMsg = \`Invalid ContactDetail.telecom; Provided element is not an instance of ContactPoint.\`;
      assertFhirType<ContactPoint>(value, ContactPoint, optErrMsg);
      this.initTelecom();
      this.telecom?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`telecom\` property exists and has a value; \`false\` otherwise
   */
  public hasTelecom(): boolean {
    return isDefinedList<ContactPoint>(this.telecom) && this.telecom.some((item: ContactPoint) => !item.isEmpty());
  }

  /**
   * Initialize the \`telecom\` property
   */
  private initTelecom(): void {
    if(!this.hasTelecom()) {
      this.telecom = [] as ContactPoint[];
    }
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'ContactDetail';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.name,
      this.telecom,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): ContactDetail {
    const dest = new ContactDetail();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: ContactDetail): void {
    super.copyValues(dest);
    dest.name = this.name?.copy();
    const telecomList = copyListValues<ContactPoint>(this.telecom);
    dest.telecom = telecomList.length === 0 ? undefined : telecomList;
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', \`UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasNameElement()) {
      setFhirPrimitiveJson<fhirString>(this.getNameElement(), 'name', jsonObj);
    }

    if (this.hasTelecom()) {
      setFhirComplexListJson(this.getTelecom(), 'telecom', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * ContactPoint Class
 *
 * @remarks
 * ContactPoint Type: Details for all kinds of technology mediated contact points for a person or organization, including telephone, email, etc.
 *
 * Need to track phone, fax, mobile, sms numbers, email addresses, twitter tags, etc.
 *
 * **FHIR Specification**
 * - **Short:** Details of a Technology mediated contact point (phone, fax, email, etc.)
 * - **Definition:** Details for all kinds of technology mediated contact points for a person or organization, including telephone, email, etc.
 * - **FHIR Version:** 5.0.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR ContactPoint](http://hl7.org/fhir/StructureDefinition/ContactPoint)
 */
/* istanbul ignore next */ export class ContactPoint extends DataType implements IDataType {
  constructor() {
    super();

    this.contactPointSystemEnum = new ContactPointSystemEnum();
    this.contactPointUseEnum = new ContactPointUseEnum();
  }

  /**
   * Parse the provided \`ContactPoint\` JSON to instantiate the ContactPoint data model.
   *
   * @param sourceJson - JSON representing FHIR \`ContactPoint\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to ContactPoint
   * @returns ContactPoint data model or undefined for \`ContactPoint\`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): ContactPoint | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'ContactPoint';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new ContactPoint();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'system';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setSystemElement(datatype);
    }

    fieldName = 'value';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setValueElement(datatype);
    }

    fieldName = 'use';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setUseElement(datatype);
    }

    fieldName = 'rank';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = fhirParser.parsePositiveIntType(dtJson, dtSiblingJson);
      instance.setRankElement(datatype);
    }

    fieldName = 'period';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Period | undefined = Period.parse(classJsonObj[fieldName]!, sourceField);
      instance.setPeriod(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: ContactPointSystem
   *
   * @see {@link ContactPointSystemEnum }
   */
  private readonly contactPointSystemEnum: ContactPointSystemEnum;

  /**
   * ContactPoint.system Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** phone | fax | email | pager | url | sms | other
   * - **Definition:** Telecommunications form for contact point - what communications system is required to make use of the contact.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link ContactPointSystemEnum }
   */
  private system?: EnumCodeType | undefined;

  /**
   * ContactPoint.value Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The actual contact point details
   * - **Definition:** The actual contact point details, in a form that is meaningful to the designated communication system (i.e. phone number or email address).
   * - **Comment:** Additional text data such as phone extension numbers, or notes about use of the contact are sometimes included in the value.
   * - **Requirements:** Need to support legacy numbers that are not in a tightly controlled format.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private value?: StringType | undefined;

  /**
   * FHIR CodeSystem: ContactPointUse
   *
   * @see {@link ContactPointUseEnum }
   */
  private readonly contactPointUseEnum: ContactPointUseEnum;

  /**
   * ContactPoint.use Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** home | work | temp | old | mobile - purpose of this contact point
   * - **Definition:** Identifies the purpose for the contact point.
   * - **Comment:** Applications can assume that a contact is current unless it explicitly says that it is temporary or old.
   * - **Requirements:** Need to track the way a person uses this contact, so a user can choose which is appropriate for their purpose.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** true
   * - **isModifierReason:** This is labeled as &quot;Is Modifier&quot; because applications should not mistake a temporary or old contact etc.for a current/permanent one
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link ContactPointUseEnum }
   */
  private use?: EnumCodeType | undefined;

  /**
   * ContactPoint.rank Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Specify preferred order of use (1 = highest)
   * - **Definition:** Specifies a preferred order in which to use a set of contacts. ContactPoints with lower rank values are more preferred than those with higher rank values.
   * - **Comment:** Note that rank does not necessarily follow the order in which the contacts are represented in the instance. Ranks need not be unique.  E.g. it\\'s possible to have multiple contacts with rank=1.  If the ranks have different systems or uses, this would be interpreted to mean "X is my most preferred phone number, Y is my most preferred email address" or "X is my preferred home email and Y is my preferred work email".  If the system and use for equally-ranked contacts are the same, then the level of preference is equivalent for both repetitions.  Ranks need not be sequential and not all repetitions must have a rank.  For example, it\\'s possible to have 4 contacts with ranks of 2, 5 and two with no rank specified.  That would be interpreted to mean the first is preferred over the second and no preference stated for the remaining contacts.
   * - **FHIR Type:** \`positiveInt\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private rank?: PositiveIntType | undefined;

  /**
   * ContactPoint.period Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Time period when the contact point was/is in use
   * - **Definition:** Time period when the contact point was/is in use.
   * - **FHIR Type:** \`Period\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private period?: Period | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`system\` property value as a EnumCodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link ContactPointSystemEnum }
   */
  public getSystemEnumType(): EnumCodeType | undefined {
    return this.system;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`system\` property.
   *
   * @param enumType - the \`system\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code values
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ContactPointSystemEnum }
   */
  public setSystemEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid ContactPoint.system';
      assertEnumCodeType<ContactPointSystemEnum>(enumType, ContactPointSystemEnum, errMsgPrefix);
      this.system = enumType;
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`system\` property exists and has a value; \`false\` otherwise
   */
  public hasSystemEnumType(): boolean {
    return isDefined<EnumCodeType>(this.system) && !this.system.isEmpty() && this.system.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`system\` property value as a CodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link ContactPointSystemEnum }
   */
  public getSystemElement(): CodeType | undefined {
    if (this.system === undefined) {
      return undefined;
    }
    return this.system as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`system\` property.
   *
   * @param element - the \`system\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ContactPointSystemEnum }
   */
  public setSystemElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid ContactPoint.system; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.system = new EnumCodeType(element, this.contactPointSystemEnum);
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`system\` property exists and has a value; \`false\` otherwise
   */
  public hasSystemElement(): boolean {
    return this.hasSystemEnumType();
  }

  /**
   * @returns the \`system\` property value as a fhirCode if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link ContactPointSystemEnum }
   */
  public getSystem(): fhirCode | undefined {
    if (this.system === undefined) {
      return undefined;
    }
    return this.system.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`system\` property.
   *
   * @param value - the \`system\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link ContactPointSystemEnum }
   */
  public setSystem(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid ContactPoint.system; Provided value is not an instance of fhirCode.\`;
      this.system = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.contactPointSystemEnum);
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`system\` property exists and has a value; \`false\` otherwise
   */
  public hasSystem(): boolean {
    return this.hasSystemEnumType();
  }

  /**
   * @returns the \`value\` property value as a StringType object if defined; else an empty StringType object
   */
  public getValueElement(): StringType {
    return this.value ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`value\` property.
   *
   * @param element - the \`value\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValueElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid ContactPoint.value; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.value = element;
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`value\` property exists and has a value; \`false\` otherwise
   */
  public hasValueElement(): boolean {
    return isDefined<StringType>(this.value) && !this.value.isEmpty();
  }

  /**
   * @returns the \`value\` property value as a fhirString if defined; else undefined
   */
  public getValue(): fhirString | undefined {
    return this.value?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`value\` property.
   *
   * @param value - the \`value\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValue(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid ContactPoint.value (\${String(value)})\`;
      this.value = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`value\` property exists and has a value; \`false\` otherwise
   */
  public hasValue(): boolean {
    return this.hasValueElement();
  }

  /**
   * @returns the \`use\` property value as a EnumCodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link ContactPointUseEnum }
   */
  public getUseEnumType(): EnumCodeType | undefined {
    return this.use;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`use\` property.
   *
   * @param enumType - the \`use\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code values
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ContactPointUseEnum }
   */
  public setUseEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid ContactPoint.use';
      assertEnumCodeType<ContactPointUseEnum>(enumType, ContactPointUseEnum, errMsgPrefix);
      this.use = enumType;
    } else {
      this.use = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`use\` property exists and has a value; \`false\` otherwise
   */
  public hasUseEnumType(): boolean {
    return isDefined<EnumCodeType>(this.use) && !this.use.isEmpty() && this.use.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`use\` property value as a CodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link ContactPointUseEnum }
   */
  public getUseElement(): CodeType | undefined {
    if (this.use === undefined) {
      return undefined;
    }
    return this.use as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`use\` property.
   *
   * @param element - the \`use\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ContactPointUseEnum }
   */
  public setUseElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid ContactPoint.use; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.use = new EnumCodeType(element, this.contactPointUseEnum);
    } else {
      this.use = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`use\` property exists and has a value; \`false\` otherwise
   */
  public hasUseElement(): boolean {
    return this.hasUseEnumType();
  }

  /**
   * @returns the \`use\` property value as a fhirCode if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link ContactPointUseEnum }
   */
  public getUse(): fhirCode | undefined {
    if (this.use === undefined) {
      return undefined;
    }
    return this.use.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`use\` property.
   *
   * @param value - the \`use\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link ContactPointUseEnum }
   */
  public setUse(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid ContactPoint.use; Provided value is not an instance of fhirCode.\`;
      this.use = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.contactPointUseEnum);
    } else {
      this.use = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`use\` property exists and has a value; \`false\` otherwise
   */
  public hasUse(): boolean {
    return this.hasUseEnumType();
  }

  /**
   * @returns the \`rank\` property value as a PositiveIntType object if defined; else an empty PositiveIntType object
   */
  public getRankElement(): PositiveIntType {
    return this.rank ?? new PositiveIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`rank\` property.
   *
   * @param element - the \`rank\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setRankElement(element: PositiveIntType | undefined): this {
    if (isDefined<PositiveIntType>(element)) {
      const optErrMsg = \`Invalid ContactPoint.rank; Provided element is not an instance of PositiveIntType.\`;
      assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
      this.rank = element;
    } else {
      this.rank = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`rank\` property exists and has a value; \`false\` otherwise
   */
  public hasRankElement(): boolean {
    return isDefined<PositiveIntType>(this.rank) && !this.rank.isEmpty();
  }

  /**
   * @returns the \`rank\` property value as a fhirPositiveInt if defined; else undefined
   */
  public getRank(): fhirPositiveInt | undefined {
    return this.rank?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`rank\` property.
   *
   * @param value - the \`rank\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setRank(value: fhirPositiveInt | undefined): this {
    if (isDefined<fhirPositiveInt>(value)) {
      const optErrMsg = \`Invalid ContactPoint.rank (\${String(value)})\`;
      this.rank = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    } else {
      this.rank = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`rank\` property exists and has a value; \`false\` otherwise
   */
  public hasRank(): boolean {
    return this.hasRankElement();
  }

  /**
   * @returns the \`period\` property value as a Period object if defined; else an empty Period object
   */
  public getPeriod(): Period {
    return this.period ?? new Period();
  }

  /**
   * Assigns the provided Period object value to the \`period\` property.
   *
   * @param value - the \`period\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setPeriod(value: Period | undefined): this {
    if (isDefined<Period>(value)) {
      const optErrMsg = \`Invalid ContactPoint.period; Provided element is not an instance of Period.\`;
      assertFhirType<Period>(value, Period, optErrMsg);
      this.period = value;
    } else {
      this.period = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`period\` property exists and has a value; \`false\` otherwise
   */
  public hasPeriod(): boolean {
    return isDefined<Period>(this.period) && !this.period.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'ContactPoint';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.system,
      this.value,
      this.use,
      this.rank,
      this.period,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): ContactPoint {
    const dest = new ContactPoint();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: ContactPoint): void {
    super.copyValues(dest);
    dest.system = this.system?.copy();
    dest.value = this.value?.copy();
    dest.use = this.use?.copy();
    dest.rank = this.rank?.copy();
    dest.period = this.period?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', \`UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasSystemElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getSystemElement()!, 'system', jsonObj);
    }

    if (this.hasValueElement()) {
      setFhirPrimitiveJson<fhirString>(this.getValueElement(), 'value', jsonObj);
    }

    if (this.hasUseElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getUseElement()!, 'use', jsonObj);
    }

    if (this.hasRankElement()) {
      setFhirPrimitiveJson<fhirPositiveInt>(this.getRankElement(), 'rank', jsonObj);
    }

    if (this.hasPeriod()) {
      setFhirComplexJson(this.getPeriod(), 'period', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * Contributor Class
 *
 * @remarks
 * Base StructureDefinition for Contributor Type: A contributor to the content of a knowledge asset, including authors, editors, reviewers, and endorsers.
 *
 * Need to track contributor information in the same way across multiple resources.
 *
 * **FHIR Specification**
 * - **Short:** Contributor information
 * - **Definition:** A contributor to the content of a knowledge asset, including authors, editors, reviewers, and endorsers.
 * - **FHIR Version:** 4.0.1
 *
 * @category Data Models: ComplexType
 * @see [FHIR Contributor](http://hl7.org/fhir/StructureDefinition/Contributor)
 */
/* istanbul ignore next */ export class Contributor extends DataType implements IDataType {
  constructor(type_: EnumCodeType | CodeType | fhirCode | null = null, name: StringType | fhirString | null = null) {
    super();

    this.contributorTypeEnum = new ContributorTypeEnum();

    this.type_ = constructorCodeValueAsEnumCodeType<ContributorTypeEnum>(
      type_,
      ContributorTypeEnum,
      this.contributorTypeEnum,
      'Contributor.type',
    );

    this.name = null;
    if (isDefined<StringType | fhirString>(name)) {
      if (name instanceof PrimitiveType) {
        this.setNameElement(name);
      } else {
        this.setName(name);
      }
    }
  }

  /**
   * Parse the provided \`Contributor\` JSON to instantiate the Contributor data model.
   *
   * @param sourceJson - JSON representing FHIR \`Contributor\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Contributor
   * @returns Contributor data model or undefined for \`Contributor\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Contributor | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Contributor';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Contributor();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'type';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setTypeElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'name';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setNameElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'contact';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: ContactDetail | undefined = ContactDetail.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addContact(datatype);
        }
      });
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: ContributorType
   *
   * @see {@link ContributorTypeEnum }
   */
  private readonly contributorTypeEnum: ContributorTypeEnum;

  /**
   * Contributor.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** author | editor | reviewer | endorser
   * - **Definition:** The type of contributor.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link ContributorTypeEnum }
   */
  private type_: EnumCodeType | null;

  /**
   * Contributor.name Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Who contributed the content
   * - **Definition:** The name of the individual or organization responsible for the contribution.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private name: StringType | null;

  /**
   * Contributor.contact Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Contact details of the contributor
   * - **Definition:** Contact details to assist a user in finding and communicating with the contributor.
   * - **FHIR Type:** \`ContactDetail\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private contact?: ContactDetail[] | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`type_\` property value as a EnumCodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link ContributorTypeEnum }
   */
  public getTypeEnumType(): EnumCodeType | null {
    return this.type_;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`type_\` property.
   *
   * @param enumType - the \`type_\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ContributorTypeEnum }
   */
  public setTypeEnumType(enumType: EnumCodeType): this {
    assertIsDefined<EnumCodeType>(enumType, \`Contributor.type is required\`);
    const errMsgPrefix = \`Invalid Contributor.type\`;
    assertEnumCodeType<ContributorTypeEnum>(enumType, ContributorTypeEnum, errMsgPrefix);
    this.type_ = enumType;
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasTypeEnumType(): boolean {
    return isDefined<EnumCodeType>(this.type_) && !this.type_.isEmpty() && this.type_.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`type_\` property value as a CodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link ContributorTypeEnum }
   */
  public getTypeElement(): CodeType | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_ as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`type_\` property.
   *
   * @param element - the \`type_\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ContributorTypeEnum }
   */
  public setTypeElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, \`Contributor.type is required\`);
    const optErrMsg = \`Invalid Contributor.type; Provided value is not an instance of CodeType.\`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.type_ = new EnumCodeType(element, this.contributorTypeEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasTypeElement(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the \`type_\` property value as a fhirCode if defined; else null
   *
   * @see CodeSystem Enumeration: {@link ContributorTypeEnum }
   */
  public getType(): fhirCode | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`type_\` property.
   *
   * @param value - the \`type_\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link ContributorTypeEnum }
   */
  public setType(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, \`Contributor.type is required\`);
    const optErrMsg = \`Invalid Contributor.type (\${String(value)})\`;
    this.type_ = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.contributorTypeEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasType(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the \`name\` property value as a StringType object if defined; else null
   */
  public getNameElement(): StringType | null {
    return this.name;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`name\` property.
   *
   * @param element - the \`name\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setNameElement(element: StringType): this {
    assertIsDefined<StringType>(element, \`Contributor.name is required\`);
    const optErrMsg = \`Invalid Contributor.name; Provided value is not an instance of StringType.\`;
    assertFhirType<StringType>(element, StringType, optErrMsg);
    this.name = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`name\` property exists and has a value; \`false\` otherwise
   */
  public hasNameElement(): boolean {
    return isDefined<StringType>(this.name) && !this.name.isEmpty();
  }

  /**
   * @returns the \`name\` property value as a fhirString if defined; else null
   */
  public getName(): fhirString | null {
    if (this.name?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.name.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`name\` property.
   *
   * @param value - the \`name\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setName(value: fhirString): this {
    assertIsDefined<fhirString>(value, \`Contributor.name is required\`);
    const optErrMsg = \`Invalid Contributor.name (\${String(value)})\`;
    this.name = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`name\` property exists and has a value; \`false\` otherwise
   */
  public hasName(): boolean {
    return this.hasNameElement();
  }

  /**
   * @returns the \`contact\` property value as a ContactDetail array
   */
  public getContact(): ContactDetail[] {
    return this.contact ?? ([] as ContactDetail[]);
  }

  /**
   * Assigns the provided ContactDetail array value to the \`contact\` property.
   *
   * @param value - the \`contact\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setContact(value: ContactDetail[] | undefined): this {
    if (isDefinedList<ContactDetail>(value)) {
      const optErrMsg = \`Invalid Contributor.contact; Provided value array has an element that is not an instance of ContactDetail.\`;
      assertFhirTypeList<ContactDetail>(value, ContactDetail, optErrMsg);
      this.contact = value;
    } else {
      this.contact = undefined;
    }
    return this;
  }

  /**
   * Add the provided ContactDetail value to the \`contact\` array property.
   *
   * @param value - the \`contact\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addContact(value: ContactDetail | undefined): this {
    if (isDefined<ContactDetail>(value)) {
      const optErrMsg = \`Invalid Contributor.contact; Provided element is not an instance of ContactDetail.\`;
      assertFhirType<ContactDetail>(value, ContactDetail, optErrMsg);
      this.initContact();
      this.contact?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`contact\` property exists and has a value; \`false\` otherwise
   */
  public hasContact(): boolean {
    return isDefinedList<ContactDetail>(this.contact) && this.contact.some((item: ContactDetail) => !item.isEmpty());
  }

  /**
   * Initialize the \`contact\` property
   */
  private initContact(): void {
    if(!this.hasContact()) {
      this.contact = [] as ContactDetail[];
    }
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Contributor';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.type_,
      this.name,
      this.contact,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Contributor {
    const dest = new Contributor();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Contributor): void {
    super.copyValues(dest);
    dest.type_ = this.type_ ? this.type_.copy() : null;
    dest.name = this.name ? this.name.copy() : null;
    const contactList = copyListValues<ContactDetail>(this.contact);
    dest.contact = contactList.length === 0 ? undefined : contactList;
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', \`UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasTypeElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getTypeElement()!, 'type', jsonObj);
    } else {
      missingReqdProperties.push(\`Contributor.type\`);
    }

    if (this.hasNameElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirString>(this.getNameElement()!, 'name', jsonObj);
    } else {
      missingReqdProperties.push(\`Contributor.name\`);
    }

    if (this.hasContact()) {
      setFhirComplexListJson(this.getContact(), 'contact', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

/**
 * Count Class
 *
 * @remarks
 * Base StructureDefinition for Count Type: A measured amount (or an amount that can potentially be measured). Note that measured amounts include amounts that are not precisely quantified, including amounts involving arbitrary units and floating currencies.
 *
 * Need to able to capture all sorts of measured values, even if the measured value are not precisely quantified. Values include exact measures such as 3.51g, customary units such as 3 tablets, and currencies such as $100.32USD.
 *
 * **FHIR Specification**
 * - **Short:** A measured or measurable amount
 * - **Definition:** A measured amount (or an amount that can potentially be measured). Note that measured amounts include amounts that are not precisely quantified, including amounts involving arbitrary units and floating currencies.
 * - **Comment:** The context of use may frequently define what kind of quantity this is and therefore what kind of units can be used. The context of use may also restrict the values for the comparator.
 * - **FHIR Version:** 4.0.1
 *
 * @category Data Models: ComplexType
 * @see [FHIR Count](http://hl7.org/fhir/StructureDefinition/Count)
 */
/* istanbul ignore next */ export class Count extends DataType implements IDataType {
  constructor() {
    super();

    this.quantityComparatorEnum = new QuantityComparatorEnum();
  }

  /**
   * Parse the provided \`Count\` JSON to instantiate the Count data model.
   *
   * @param sourceJson - JSON representing FHIR \`Count\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Count
   * @returns Count data model or undefined for \`Count\`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Count | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Count';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Count();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'value';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setValueElement(datatype);
    }

    fieldName = 'comparator';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setComparatorElement(datatype);
    }

    fieldName = 'unit';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setUnitElement(datatype);
    }

    fieldName = 'system';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = fhirParser.parseUriType(dtJson, dtSiblingJson);
      instance.setSystemElement(datatype);
    }

    fieldName = 'code';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setCodeElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Count.value Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Numerical value (with implicit precision)
   * - **Definition:** The value of the measured amount. The value includes an implicit precision in the presentation of the value.
   * - **Comment:** The implicit precision in the value should always be honored. Monetary values have their own rules for handling precision (refer to standard accounting text books).
   * - **Requirements:** Precision is handled implicitly in almost all cases of measurement.
   * - **FHIR Type:** \`decimal\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private value?: DecimalType | undefined;

  /**
   * FHIR CodeSystem: QuantityComparator
   *
   * @see {@link QuantityComparatorEnum }
   */
  private readonly quantityComparatorEnum: QuantityComparatorEnum;

  /**
   * Count.comparator Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** < | <= | >= | > - how to understand the value
   * - **Definition:** How the value should be understood and represented - whether the actual value is greater or less than the stated value due to measurement issues; e.g. if the comparator is "<" , then the real value is < stated value.
   * - **Requirements:** Need a framework for handling measures where the value is <5ug/L or >400mg/L due to the limitations of measuring methodology.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** true
   * - **isModifierReason:** This is labeled as &quot;Is Modifier&quot; because the comparator modifies the interpretation of the value significantly. If there is no comparator, then there is no modification of the value
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  private comparator?: EnumCodeType | undefined;

  /**
   * Count.unit Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Unit representation
   * - **Definition:** A human-readable form of the unit.
   * - **Requirements:** There are many representations for units of measure and in many contexts, particular representations are fixed and required. I.e. mcg for micrograms.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private unit?: StringType | undefined;

  /**
   * Count.system Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** System that defines coded unit form
   * - **Definition:** The identification of the system that provides the coded form of the unit.
   * - **Requirements:** Need to know the system that defines the coded form of the unit.
   * - **FHIR Type:** \`uri\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private system?: UriType | undefined;

  /**
   * Count.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Coded form of the unit
   * - **Definition:** A computer processable form of the unit in some unit representation system.
   * - **Comment:** The preferred system is UCUM, but SNOMED CT can also be used (for customary units) or ISO 4217 for currency.  The context of use may additionally require a code from a particular system.
   * - **Requirements:** Need a computable form of the unit that is fixed across all forms. UCUM provides this for quantities, but SNOMED CT provides many units of interest.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code?: CodeType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`value\` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getValueElement(): DecimalType {
    return this.value ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`value\` property.
   *
   * @param element - the \`value\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValueElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = \`Invalid Count.value; Provided element is not an instance of DecimalType.\`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.value = element;
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`value\` property exists and has a value; \`false\` otherwise
   */
  public hasValueElement(): boolean {
    return isDefined<DecimalType>(this.value) && !this.value.isEmpty();
  }

  /**
   * @returns the \`value\` property value as a fhirDecimal if defined; else undefined
   */
  public getValue(): fhirDecimal | undefined {
    return this.value?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`value\` property.
   *
   * @param value - the \`value\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValue(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = \`Invalid Count.value (\${String(value)})\`;
      this.value = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`value\` property exists and has a value; \`false\` otherwise
   */
  public hasValue(): boolean {
    return this.hasValueElement();
  }

  /**
   * @returns the \`comparator\` property value as a EnumCodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public getComparatorEnumType(): EnumCodeType | undefined {
    return this.comparator;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`comparator\` property.
   *
   * @param enumType - the \`comparator\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code values
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public setComparatorEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid Count.comparator';
      assertEnumCodeType<QuantityComparatorEnum>(enumType, QuantityComparatorEnum, errMsgPrefix);
      this.comparator = enumType;
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`comparator\` property exists and has a value; \`false\` otherwise
   */
  public hasComparatorEnumType(): boolean {
    return isDefined<EnumCodeType>(this.comparator) && !this.comparator.isEmpty() && this.comparator.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`comparator\` property value as a CodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public getComparatorElement(): CodeType | undefined {
    if (this.comparator === undefined) {
      return undefined;
    }
    return this.comparator as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`comparator\` property.
   *
   * @param element - the \`comparator\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public setComparatorElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Count.comparator; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.comparator = new EnumCodeType(element, this.quantityComparatorEnum);
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`comparator\` property exists and has a value; \`false\` otherwise
   */
  public hasComparatorElement(): boolean {
    return this.hasComparatorEnumType();
  }

  /**
   * @returns the \`comparator\` property value as a fhirCode if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public getComparator(): fhirCode | undefined {
    if (this.comparator === undefined) {
      return undefined;
    }
    return this.comparator.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`comparator\` property.
   *
   * @param value - the \`comparator\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public setComparator(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Count.comparator; Provided value is not an instance of fhirCode.\`;
      this.comparator = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.quantityComparatorEnum);
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`comparator\` property exists and has a value; \`false\` otherwise
   */
  public hasComparator(): boolean {
    return this.hasComparatorEnumType();
  }

  /**
   * @returns the \`unit\` property value as a StringType object if defined; else an empty StringType object
   */
  public getUnitElement(): StringType {
    return this.unit ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`unit\` property.
   *
   * @param element - the \`unit\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUnitElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Count.unit; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.unit = element;
    } else {
      this.unit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`unit\` property exists and has a value; \`false\` otherwise
   */
  public hasUnitElement(): boolean {
    return isDefined<StringType>(this.unit) && !this.unit.isEmpty();
  }

  /**
   * @returns the \`unit\` property value as a fhirString if defined; else undefined
   */
  public getUnit(): fhirString | undefined {
    return this.unit?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`unit\` property.
   *
   * @param value - the \`unit\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUnit(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Count.unit (\${String(value)})\`;
      this.unit = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.unit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`unit\` property exists and has a value; \`false\` otherwise
   */
  public hasUnit(): boolean {
    return this.hasUnitElement();
  }

  /**
   * @returns the \`system\` property value as a UriType object if defined; else an empty UriType object
   */
  public getSystemElement(): UriType {
    return this.system ?? new UriType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`system\` property.
   *
   * @param element - the \`system\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSystemElement(element: UriType | undefined): this {
    if (isDefined<UriType>(element)) {
      const optErrMsg = \`Invalid Count.system; Provided element is not an instance of UriType.\`;
      assertFhirType<UriType>(element, UriType, optErrMsg);
      this.system = element;
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`system\` property exists and has a value; \`false\` otherwise
   */
  public hasSystemElement(): boolean {
    return isDefined<UriType>(this.system) && !this.system.isEmpty();
  }

  /**
   * @returns the \`system\` property value as a fhirUri if defined; else undefined
   */
  public getSystem(): fhirUri | undefined {
    return this.system?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`system\` property.
   *
   * @param value - the \`system\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSystem(value: fhirUri | undefined): this {
    if (isDefined<fhirUri>(value)) {
      const optErrMsg = \`Invalid Count.system (\${String(value)})\`;
      this.system = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`system\` property exists and has a value; \`false\` otherwise
   */
  public hasSystem(): boolean {
    return this.hasSystemElement();
  }

  /**
   * @returns the \`code\` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getCodeElement(): CodeType {
    return this.code ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`code\` property.
   *
   * @param element - the \`code\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCodeElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Count.code; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.code = element;
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`code\` property exists and has a value; \`false\` otherwise
   */
  public hasCodeElement(): boolean {
    return isDefined<CodeType>(this.code) && !this.code.isEmpty();
  }

  /**
   * @returns the \`code\` property value as a fhirCode if defined; else undefined
   */
  public getCode(): fhirCode | undefined {
    return this.code?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`code\` property.
   *
   * @param value - the \`code\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCode(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Count.code (\${String(value)})\`;
      this.code = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`code\` property exists and has a value; \`false\` otherwise
   */
  public hasCode(): boolean {
    return this.hasCodeElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Count';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.value,
      this.comparator,
      this.unit,
      this.system,
      this.code,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Count {
    const dest = new Count();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Count): void {
    super.copyValues(dest);
    dest.value = this.value?.copy();
    dest.comparator = this.comparator?.copy();
    dest.unit = this.unit?.copy();
    dest.system = this.system?.copy();
    dest.code = this.code?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', \`UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasValueElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getValueElement(), 'value', jsonObj);
    }

    if (this.hasComparatorElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getComparatorElement()!, 'comparator', jsonObj);
    }

    if (this.hasUnitElement()) {
      setFhirPrimitiveJson<fhirString>(this.getUnitElement(), 'unit', jsonObj);
    }

    if (this.hasSystemElement()) {
      setFhirPrimitiveJson<fhirUri>(this.getSystemElement(), 'system', jsonObj);
    }

    if (this.hasCodeElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getCodeElement(), 'code', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * DataRequirement Class
 *
 * @remarks
 * Base StructureDefinition for DataRequirement Type: Describes a required data item for evaluation in terms of the type of data, and optional code or date-based filters of the data.
 *
 * **FHIR Specification**
 * - **Short:** Describes a required data item
 * - **Definition:** Describes a required data item for evaluation in terms of the type of data, and optional code or date-based filters of the data.
 * - **FHIR Version:** 4.0.1
 *
 * @category Data Models: ComplexType
 * @see [FHIR DataRequirement](http://hl7.org/fhir/StructureDefinition/DataRequirement)
 */
/* istanbul ignore next */ export class DataRequirement extends DataType implements IDataType {
  constructor(type_: CodeType | fhirCode | null = null) {
    super();

    this.type_ = null;
    if (isDefined<CodeType | fhirCode>(type_)) {
      if (type_ instanceof PrimitiveType) {
        this.setTypeElement(type_);
      } else {
        this.setType(type_);
      }
    }
  }

  /**
   * Parse the provided \`DataRequirement\` JSON to instantiate the DataRequirement data model.
   *
   * @param sourceJson - JSON representing FHIR \`DataRequirement\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to DataRequirement
   * @returns DataRequirement data model or undefined for \`DataRequirement\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): DataRequirement | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'DataRequirement';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new DataRequirement();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const classMetadata: DecoratorMetadataObject | null = DataRequirement[Symbol.metadata];
    const errorMessage = \`DecoratorMetadataObject does not exist for DataRequirement\`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    const missingReqdProperties: string[] = [];

    fieldName = 'type';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setTypeElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'profile';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: CanonicalType | undefined = fhirParser.parseCanonicalType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addProfileElement(datatype);
        }
      });
    }

    fieldName = 'subject[x]';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const subject: IDataType | undefined = fhirParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setSubject(subject);

    fieldName = 'mustSupport';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: StringType | undefined = fhirParser.parseStringType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addMustSupportElement(datatype);
        }
      });
    }

    fieldName = 'codeFilter';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: DataRequirementCodeFilterComponent | undefined = DataRequirementCodeFilterComponent.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addCodeFilter(datatype);
        }
      });
    }

    fieldName = 'dateFilter';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: DataRequirementDateFilterComponent | undefined = DataRequirementDateFilterComponent.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addDateFilter(datatype);
        }
      });
    }

    fieldName = 'limit';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = fhirParser.parsePositiveIntType(dtJson, dtSiblingJson);
      instance.setLimitElement(datatype);
    }

    fieldName = 'sort';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: DataRequirementSortComponent | undefined = DataRequirementSortComponent.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addSort(datatype);
        }
      });
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * DataRequirement.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The type of the required data
   * - **Definition:** The type of the required data, specified as the type name of a resource. For profiles, this value is set to the type of the base resource of the profile.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private type_: CodeType | null;

  /**
   * DataRequirement.profile Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The profile of the required data
   * - **Definition:** The profile of the required data, specified as the uri of the profile definition.
   * - **FHIR Type:** \`canonical\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/StructureDefinition',
   *     ]
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private profile?: CanonicalType[] | undefined;

  /**
   * DataRequirement.subject[x] Element
   *
   * @decorator \`@ChoiceDataTypesMeta('DataRequirement.subject[x]', ['CodeableConcept','Reference',]\`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** E.g. Patient, Practitioner, RelatedPerson, Organization, Location, Device
   * - **Definition:** The intended subjects of the data requirement. If this element is not provided, a Patient subject is assumed.
   * - **Comment:** The subject of a data requirement is critical, as the data being specified is determined with respect to a particular subject. This corresponds roughly to the notion of a Compartment in that it limits what data is available based on its relationship to the subject. In CQL, this corresponds to the context declaration.
   * - **FHIR Types:**
   *     'CodeableConcept',
   *     'Reference',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('DataRequirement.subject[x]',[
    'CodeableConcept',
    'Reference',
  ])
  private subject?: IDataType | undefined;

  /**
   * DataRequirement.mustSupport Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Indicates specific structure elements that are referenced by the knowledge module
   * - **Definition:** Indicates that specific elements of the type are referenced by the knowledge module and must be supported by the consumer in order to obtain an effective evaluation. This does not mean that a value is required for this element, only that the consuming system must understand the element and be able to provide values for it if they are available.  The value of mustSupport SHALL be a FHIRPath resolveable on the type of the DataRequirement. The path SHALL consist only of identifiers, constant indexers, and .resolve() (see the [Simple FHIRPath Profile](https://hl7.org/fhir/fhirpath.html#simple) for full details).
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private mustSupport?: StringType[] | undefined;

  /**
   * DataRequirement.codeFilter Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** What codes are expected
   * - **Definition:** Code filters specify additional constraints on the data, specifying the value set of interest for a particular element of the data. Each code filter defines an additional constraint on the data, i.e. code filters are AND\\'ed, not OR\\'ed.
   * - **FHIR Type:** \`Element\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private codeFilter?: DataRequirementCodeFilterComponent[] | undefined;

  /**
   * DataRequirement.dateFilter Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** What dates/date ranges are expected
   * - **Definition:** Date filters specify additional constraints on the data in terms of the applicable date range for specific elements. Each date filter specifies an additional constraint on the data, i.e. date filters are AND\\'ed, not OR\\'ed.
   * - **FHIR Type:** \`Element\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private dateFilter?: DataRequirementDateFilterComponent[] | undefined;

  /**
   * DataRequirement.limit Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Number of results
   * - **Definition:** Specifies a maximum number of results that are required (uses the _count search parameter).
   * - **Comment:** This element can be used in combination with the sort element to specify quota requirements such as "the most recent 5" or "the highest 5".
   * - **Requirements:** Enables the requirement "most recent 5 results" to be expressed.
   * - **FHIR Type:** \`positiveInt\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private limit?: PositiveIntType | undefined;

  /**
   * DataRequirement.sort Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Order of the results
   * - **Definition:** Specifies the order of the results to be returned.
   * - **Comment:** This element can be used in combination with the sort element to specify quota requirements such as "the most recent 5" or "the highest 5". When multiple sorts are specified, they are applied in the order they appear in the resource.
   * - **Requirements:** Enables the requirement "most recent 5 results" to be expressed.
   * - **FHIR Type:** \`Element\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private sort?: DataRequirementSortComponent[] | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`type_\` property value as a CodeType object if defined; else null
   */
  public getTypeElement(): CodeType | null {
    return this.type_;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`type_\` property.
   *
   * @param element - the \`type_\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTypeElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, \`DataRequirement.type is required\`);
    const optErrMsg = \`Invalid DataRequirement.type; Provided value is not an instance of CodeType.\`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.type_ = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasTypeElement(): boolean {
    return isDefined<CodeType>(this.type_) && !this.type_.isEmpty();
  }

  /**
   * @returns the \`type_\` property value as a fhirCode if defined; else null
   */
  public getType(): fhirCode | null {
    if (this.type_?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.type_.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`type_\` property.
   *
   * @param value - the \`type_\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setType(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, \`DataRequirement.type is required\`);
    const optErrMsg = \`Invalid DataRequirement.type (\${String(value)})\`;
    this.type_ = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasType(): boolean {
    return this.hasTypeElement();
  }

  /**
   * @returns the \`profile\` property value as a CanonicalType array
   */
  public getProfileElement(): CanonicalType[] {
    return this.profile ?? ([] as CanonicalType[]);
  }

  /**
   * Assigns the provided CanonicalType array value to the \`profile\` property.
   *
   * @param element - the \`profile\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setProfileElement(element: CanonicalType[] | undefined): this {
    if (isDefinedList<CanonicalType>(element)) {
      const optErrMsg = \`Invalid DataRequirement.profile; Provided value array has an element that is not an instance of CanonicalType.\`;
      assertFhirTypeList<CanonicalType>(element, CanonicalType, optErrMsg);
      this.profile = element;
    } else {
      this.profile = undefined;
    }
    return this;
  }

  /**
   * Add the provided CanonicalType value to the \`profile\` array property.
   *
   * @param element - the \`profile\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addProfileElement(element: CanonicalType | undefined): this {
    if (isDefined<CanonicalType>(element)) {
      const optErrMsg = \`Invalid DataRequirement.profile; Provided element is not an instance of CanonicalType.\`;
      assertFhirType<CanonicalType>(element, CanonicalType, optErrMsg);
      this.initProfile();
      this.profile?.push(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`profile\` property exists and has a value; \`false\` otherwise
   */
  public hasProfileElement(): boolean {
    return isDefinedList<CanonicalType>(this.profile) && this.profile.some((item: CanonicalType) => !item.isEmpty());
  }

  /**
   * @returns the \`profile\` property value as a fhirCanonical array
   */
  public getProfile(): fhirCanonical[] {
    this.initProfile();
    const profileValues = [] as fhirCanonical[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.profile!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        profileValues.push(value);
      }
    }
    return profileValues;
  }

  /**
   * Assigns the provided primitive value array to the \`profile\` property.
   *
   * @param value - the \`profile\` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setProfile(value: fhirCanonical[] | undefined): this {
    if (isDefinedList<fhirCanonical>(value)) {
      const profileElements = [] as CanonicalType[];
      for (const profileValue of value) {
        const optErrMsg = \`Invalid DataRequirement.profile array item (\${String(profileValue)})\`;
        const element = new CanonicalType(parseFhirPrimitiveData(profileValue, fhirCanonicalSchema, optErrMsg));
        profileElements.push(element);
      }
      this.profile = profileElements;
    } else {
      this.profile = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`profile\` array property.
   *
   * @param value - the \`profile\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addProfile(value: fhirCanonical | undefined): this {
    if (isDefined<fhirCanonical>(value)) {
      const optErrMsg = \`Invalid DataRequirement.profile array item (\${String(value)})\`;
      const element = new CanonicalType(parseFhirPrimitiveData(value, fhirCanonicalSchema, optErrMsg));
      this.initProfile();
      this.addProfileElement(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`profile\` property exists and has a value; \`false\` otherwise
   */
  public hasProfile(): boolean {
    return this.hasProfileElement();
  }

  /**
   * Initialize the \`profile\` property
   */
  private initProfile(): void {
    if (!this.hasProfile()) {
      this.profile = [] as CanonicalType[];
    }
  }

  /**
   * @returns the \`subject\` property value as a DataType object if defined; else undefined
   */
  public getSubject(): IDataType | undefined {
    return this.subject;
  }

  /**
   * Assigns the provided DataType object value to the \`subject\` property.
   *
   * @decorator \`@ChoiceDataTypes('DataRequirement.subject[x]')\`
   *
   * @param value - the \`subject\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  @ChoiceDataTypes('DataRequirement.subject[x]')
  public setSubject(value: IDataType | undefined): this {
    if (isDefined<IDataType>(value)) {
      // assertFhirType<IDataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.subject = value;
    } else {
      this.subject = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`subject\` property exists and has a value; \`false\` otherwise
   */
  public hasSubject(): boolean {
    return isDefined<IDataType>(this.subject) && !this.subject.isEmpty();
  }

  // *** NOTE ***
  // Following choice datatype-specific "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the \`subject\` property value as a CodeableConcept object if defined; else undefined
   */
  public getSubjectCodeableConcept(): CodeableConcept | undefined {
    if (!isDefined<IDataType | undefined>(this.subject)) {
      return undefined;
    }
    if (!(this.subject instanceof CodeableConcept)) {
      throw new InvalidTypeError(
        \`DataType mismatch for DataRequirement.subject[x]: Expected CodeableConcept but encountered \${this.subject.fhirType()}\`,
      );
    }
    return this.subject;
  }

  /**
   * @returns \`true\` if the \`subject\` property exists as a CodeableConcept and has a value; \`false\` otherwise
   */
  public hasSubjectCodeableConcept(): boolean {
    return this.hasSubject() && this.subject instanceof CodeableConcept;
  }

  /**
   * @returns the \`subject\` property value as a Reference object if defined; else undefined
   */
  public getSubjectReference(): Reference | undefined {
    if (!isDefined<IDataType | undefined>(this.subject)) {
      return undefined;
    }
    if (!(this.subject instanceof Reference)) {
      throw new InvalidTypeError(
        \`DataType mismatch for DataRequirement.subject[x]: Expected Reference but encountered \${this.subject.fhirType()}\`,
      );
    }
    return this.subject;
  }

  /**
   * @returns \`true\` if the \`subject\` property exists as a Reference and has a value; \`false\` otherwise
   */
  public hasSubjectReference(): boolean {
    return this.hasSubject() && this.subject instanceof Reference;
  }

  // End of choice datatype-specific "get"/"has" methods

  /**
   * @returns the \`mustSupport\` property value as a StringType array
   */
  public getMustSupportElement(): StringType[] {
    return this.mustSupport ?? ([] as StringType[]);
  }

  /**
   * Assigns the provided StringType array value to the \`mustSupport\` property.
   *
   * @param element - the \`mustSupport\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMustSupportElement(element: StringType[] | undefined): this {
    if (isDefinedList<StringType>(element)) {
      const optErrMsg = \`Invalid DataRequirement.mustSupport; Provided value array has an element that is not an instance of StringType.\`;
      assertFhirTypeList<StringType>(element, StringType, optErrMsg);
      this.mustSupport = element;
    } else {
      this.mustSupport = undefined;
    }
    return this;
  }

  /**
   * Add the provided StringType value to the \`mustSupport\` array property.
   *
   * @param element - the \`mustSupport\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addMustSupportElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid DataRequirement.mustSupport; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.initMustSupport();
      this.mustSupport?.push(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`mustSupport\` property exists and has a value; \`false\` otherwise
   */
  public hasMustSupportElement(): boolean {
    return isDefinedList<StringType>(this.mustSupport) && this.mustSupport.some((item: StringType) => !item.isEmpty());
  }

  /**
   * @returns the \`mustSupport\` property value as a fhirString array
   */
  public getMustSupport(): fhirString[] {
    this.initMustSupport();
    const mustSupportValues = [] as fhirString[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.mustSupport!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        mustSupportValues.push(value);
      }
    }
    return mustSupportValues;
  }

  /**
   * Assigns the provided primitive value array to the \`mustSupport\` property.
   *
   * @param value - the \`mustSupport\` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMustSupport(value: fhirString[] | undefined): this {
    if (isDefinedList<fhirString>(value)) {
      const mustSupportElements = [] as StringType[];
      for (const mustSupportValue of value) {
        const optErrMsg = \`Invalid DataRequirement.mustSupport array item (\${String(mustSupportValue)})\`;
        const element = new StringType(parseFhirPrimitiveData(mustSupportValue, fhirStringSchema, optErrMsg));
        mustSupportElements.push(element);
      }
      this.mustSupport = mustSupportElements;
    } else {
      this.mustSupport = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`mustSupport\` array property.
   *
   * @param value - the \`mustSupport\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addMustSupport(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid DataRequirement.mustSupport array item (\${String(value)})\`;
      const element = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
      this.initMustSupport();
      this.addMustSupportElement(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`mustSupport\` property exists and has a value; \`false\` otherwise
   */
  public hasMustSupport(): boolean {
    return this.hasMustSupportElement();
  }

  /**
   * Initialize the \`mustSupport\` property
   */
  private initMustSupport(): void {
    if (!this.hasMustSupport()) {
      this.mustSupport = [] as StringType[];
    }
  }

  /**
   * @returns the \`codeFilter\` property value as a DataRequirementCodeFilterComponent array
   */
  public getCodeFilter(): DataRequirementCodeFilterComponent[] {
    return this.codeFilter ?? ([] as DataRequirementCodeFilterComponent[]);
  }

  /**
   * Assigns the provided DataRequirementCodeFilterComponent array value to the \`codeFilter\` property.
   *
   * @param value - the \`codeFilter\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setCodeFilter(value: DataRequirementCodeFilterComponent[] | undefined): this {
    if (isDefinedList<DataRequirementCodeFilterComponent>(value)) {
      const optErrMsg = \`Invalid DataRequirement.codeFilter; Provided value array has an element that is not an instance of DataRequirementCodeFilterComponent.\`;
      assertFhirTypeList<DataRequirementCodeFilterComponent>(value, DataRequirementCodeFilterComponent, optErrMsg);
      this.codeFilter = value;
    } else {
      this.codeFilter = undefined;
    }
    return this;
  }

  /**
   * Add the provided DataRequirementCodeFilterComponent value to the \`codeFilter\` array property.
   *
   * @param value - the \`codeFilter\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addCodeFilter(value: DataRequirementCodeFilterComponent | undefined): this {
    if (isDefined<DataRequirementCodeFilterComponent>(value)) {
      const optErrMsg = \`Invalid DataRequirement.codeFilter; Provided element is not an instance of DataRequirementCodeFilterComponent.\`;
      assertFhirType<DataRequirementCodeFilterComponent>(value, DataRequirementCodeFilterComponent, optErrMsg);
      this.initCodeFilter();
      this.codeFilter?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`codeFilter\` property exists and has a value; \`false\` otherwise
   */
  public hasCodeFilter(): boolean {
    return isDefinedList<DataRequirementCodeFilterComponent>(this.codeFilter) && this.codeFilter.some((item: DataRequirementCodeFilterComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`codeFilter\` property
   */
  private initCodeFilter(): void {
    if(!this.hasCodeFilter()) {
      this.codeFilter = [] as DataRequirementCodeFilterComponent[];
    }
  }

  /**
   * @returns the \`dateFilter\` property value as a DataRequirementDateFilterComponent array
   */
  public getDateFilter(): DataRequirementDateFilterComponent[] {
    return this.dateFilter ?? ([] as DataRequirementDateFilterComponent[]);
  }

  /**
   * Assigns the provided DataRequirementDateFilterComponent array value to the \`dateFilter\` property.
   *
   * @param value - the \`dateFilter\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setDateFilter(value: DataRequirementDateFilterComponent[] | undefined): this {
    if (isDefinedList<DataRequirementDateFilterComponent>(value)) {
      const optErrMsg = \`Invalid DataRequirement.dateFilter; Provided value array has an element that is not an instance of DataRequirementDateFilterComponent.\`;
      assertFhirTypeList<DataRequirementDateFilterComponent>(value, DataRequirementDateFilterComponent, optErrMsg);
      this.dateFilter = value;
    } else {
      this.dateFilter = undefined;
    }
    return this;
  }

  /**
   * Add the provided DataRequirementDateFilterComponent value to the \`dateFilter\` array property.
   *
   * @param value - the \`dateFilter\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addDateFilter(value: DataRequirementDateFilterComponent | undefined): this {
    if (isDefined<DataRequirementDateFilterComponent>(value)) {
      const optErrMsg = \`Invalid DataRequirement.dateFilter; Provided element is not an instance of DataRequirementDateFilterComponent.\`;
      assertFhirType<DataRequirementDateFilterComponent>(value, DataRequirementDateFilterComponent, optErrMsg);
      this.initDateFilter();
      this.dateFilter?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`dateFilter\` property exists and has a value; \`false\` otherwise
   */
  public hasDateFilter(): boolean {
    return isDefinedList<DataRequirementDateFilterComponent>(this.dateFilter) && this.dateFilter.some((item: DataRequirementDateFilterComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`dateFilter\` property
   */
  private initDateFilter(): void {
    if(!this.hasDateFilter()) {
      this.dateFilter = [] as DataRequirementDateFilterComponent[];
    }
  }

  /**
   * @returns the \`limit\` property value as a PositiveIntType object if defined; else an empty PositiveIntType object
   */
  public getLimitElement(): PositiveIntType {
    return this.limit ?? new PositiveIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`limit\` property.
   *
   * @param element - the \`limit\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLimitElement(element: PositiveIntType | undefined): this {
    if (isDefined<PositiveIntType>(element)) {
      const optErrMsg = \`Invalid DataRequirement.limit; Provided element is not an instance of PositiveIntType.\`;
      assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
      this.limit = element;
    } else {
      this.limit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`limit\` property exists and has a value; \`false\` otherwise
   */
  public hasLimitElement(): boolean {
    return isDefined<PositiveIntType>(this.limit) && !this.limit.isEmpty();
  }

  /**
   * @returns the \`limit\` property value as a fhirPositiveInt if defined; else undefined
   */
  public getLimit(): fhirPositiveInt | undefined {
    return this.limit?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`limit\` property.
   *
   * @param value - the \`limit\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLimit(value: fhirPositiveInt | undefined): this {
    if (isDefined<fhirPositiveInt>(value)) {
      const optErrMsg = \`Invalid DataRequirement.limit (\${String(value)})\`;
      this.limit = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    } else {
      this.limit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`limit\` property exists and has a value; \`false\` otherwise
   */
  public hasLimit(): boolean {
    return this.hasLimitElement();
  }

  /**
   * @returns the \`sort\` property value as a DataRequirementSortComponent array
   */
  public getSort(): DataRequirementSortComponent[] {
    return this.sort ?? ([] as DataRequirementSortComponent[]);
  }

  /**
   * Assigns the provided DataRequirementSortComponent array value to the \`sort\` property.
   *
   * @param value - the \`sort\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setSort(value: DataRequirementSortComponent[] | undefined): this {
    if (isDefinedList<DataRequirementSortComponent>(value)) {
      const optErrMsg = \`Invalid DataRequirement.sort; Provided value array has an element that is not an instance of DataRequirementSortComponent.\`;
      assertFhirTypeList<DataRequirementSortComponent>(value, DataRequirementSortComponent, optErrMsg);
      this.sort = value;
    } else {
      this.sort = undefined;
    }
    return this;
  }

  /**
   * Add the provided DataRequirementSortComponent value to the \`sort\` array property.
   *
   * @param value - the \`sort\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addSort(value: DataRequirementSortComponent | undefined): this {
    if (isDefined<DataRequirementSortComponent>(value)) {
      const optErrMsg = \`Invalid DataRequirement.sort; Provided element is not an instance of DataRequirementSortComponent.\`;
      assertFhirType<DataRequirementSortComponent>(value, DataRequirementSortComponent, optErrMsg);
      this.initSort();
      this.sort?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`sort\` property exists and has a value; \`false\` otherwise
   */
  public hasSort(): boolean {
    return isDefinedList<DataRequirementSortComponent>(this.sort) && this.sort.some((item: DataRequirementSortComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`sort\` property
   */
  private initSort(): void {
    if(!this.hasSort()) {
      this.sort = [] as DataRequirementSortComponent[];
    }
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'DataRequirement';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.type_,
      this.profile,
      this.subject,
      this.mustSupport,
      this.codeFilter,
      this.dateFilter,
      this.limit,
      this.sort,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): DataRequirement {
    const dest = new DataRequirement();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: DataRequirement): void {
    super.copyValues(dest);
    dest.type_ = this.type_ ? this.type_.copy() : null;
    const profileList = copyListValues<CanonicalType>(this.profile);
    dest.profile = profileList.length === 0 ? undefined : profileList;
    dest.subject = this.subject?.copy() as IDataType;
    const mustSupportList = copyListValues<StringType>(this.mustSupport);
    dest.mustSupport = mustSupportList.length === 0 ? undefined : mustSupportList;
    const codeFilterList = copyListValues<DataRequirementCodeFilterComponent>(this.codeFilter);
    dest.codeFilter = codeFilterList.length === 0 ? undefined : codeFilterList;
    const dateFilterList = copyListValues<DataRequirementDateFilterComponent>(this.dateFilter);
    dest.dateFilter = dateFilterList.length === 0 ? undefined : dateFilterList;
    dest.limit = this.limit?.copy();
    const sortList = copyListValues<DataRequirementSortComponent>(this.sort);
    dest.sort = sortList.length === 0 ? undefined : sortList;
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', \`UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasTypeElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getTypeElement()!, 'type', jsonObj);
    } else {
      missingReqdProperties.push(\`DataRequirement.type\`);
    }

    if (this.hasProfile()) {
      setFhirPrimitiveListJson(this.getProfileElement(), 'profile', jsonObj);
    }

    if (this.hasSubject()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getSubject()!, 'subject', jsonObj);
    }

    if (this.hasMustSupport()) {
      setFhirPrimitiveListJson(this.getMustSupportElement(), 'mustSupport', jsonObj);
    }

    if (this.hasCodeFilter()) {
      setFhirComplexListJson(this.getCodeFilter(), 'codeFilter', jsonObj);
    }

    if (this.hasDateFilter()) {
      setFhirComplexListJson(this.getDateFilter(), 'dateFilter', jsonObj);
    }

    if (this.hasLimitElement()) {
      setFhirPrimitiveJson<fhirPositiveInt>(this.getLimitElement(), 'limit', jsonObj);
    }

    if (this.hasSort()) {
      setFhirComplexListJson(this.getSort(), 'sort', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
/**
 * DataRequirementCodeFilterComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** What codes are expected
 * - **Definition:** Code filters specify additional constraints on the data, specifying the value set of interest for a particular element of the data. Each code filter defines an additional constraint on the data, i.e. code filters are AND\\'ed, not OR\\'ed.
 *
 * @category Data Models: ComplexType
 * @see [FHIR DataRequirement](http://hl7.org/fhir/StructureDefinition/DataRequirement)
 */
/* istanbul ignore next */ export class DataRequirementCodeFilterComponent extends DataType implements IDataType {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`DataRequirementCodeFilterComponent\` JSON to instantiate the DataRequirementCodeFilterComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`DataRequirementCodeFilterComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to DataRequirementCodeFilterComponent
   * @returns DataRequirementCodeFilterComponent data model or undefined for \`DataRequirementCodeFilterComponent\`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): DataRequirementCodeFilterComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'DataRequirementCodeFilterComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new DataRequirementCodeFilterComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'path';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setPathElement(datatype);
    }

    fieldName = 'searchParam';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setSearchParamElement(datatype);
    }

    fieldName = 'valueSet';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CanonicalType | undefined = fhirParser.parseCanonicalType(dtJson, dtSiblingJson);
      instance.setValueSetElement(datatype);
    }

    fieldName = 'code';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Coding | undefined = Coding.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addCode(datatype);
        }
      });
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * DataRequirement.codeFilter.path Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A code-valued attribute to filter on
   * - **Definition:** The code-valued attribute of the filter. The specified path SHALL be a FHIRPath resolveable on the specified type of the DataRequirement, and SHALL consist only of identifiers, constant indexers, and .resolve(). The path is allowed to contain qualifiers (.) to traverse sub-elements, as well as indexers ([x]) to traverse multiple-cardinality sub-elements (see the [Simple FHIRPath Profile](https://hl7.org/fhir/fhirpath.html#simple) for full details). Note that the index must be an integer constant. The path must resolve to an element of type code, Coding, or CodeableConcept.
   * - **Comment:** The path attribute contains a [Simple FHIRPath Subset](https://hl7.org/fhir/fhirpath.html#simple) that allows path traversal, but not calculation.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private path?: StringType | undefined;

  /**
   * DataRequirement.codeFilter.searchParam Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A coded (token) parameter to search on
   * - **Definition:** A token parameter that refers to a search parameter defined on the specified type of the DataRequirement, and which searches on elements of type code, Coding, or CodeableConcept.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private searchParam?: StringType | undefined;

  /**
   * DataRequirement.codeFilter.valueSet Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Valueset for the filter
   * - **Definition:** The valueset for the code filter. The valueSet and code elements are additive. If valueSet is specified, the filter will return only those data items for which the value of the code-valued element specified in the path is a member of the specified valueset.
   * - **FHIR Type:** \`canonical\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/ValueSet',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private valueSet?: CanonicalType | undefined;

  /**
   * DataRequirement.codeFilter.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** What code is expected
   * - **Definition:** The codes for the code filter. If values are given, the filter will return only those data items for which the code-valued attribute specified by the path has a value that is one of the specified codes. If codes are specified in addition to a value set, the filter returns items matching a code in the value set or one of the specified codes.
   * - **FHIR Type:** \`Coding\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code?: Coding[] | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`path\` property value as a StringType object if defined; else an empty StringType object
   */
  public getPathElement(): StringType {
    return this.path ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`path\` property.
   *
   * @param element - the \`path\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPathElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid DataRequirement.codeFilter.path; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.path = element;
    } else {
      this.path = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`path\` property exists and has a value; \`false\` otherwise
   */
  public hasPathElement(): boolean {
    return isDefined<StringType>(this.path) && !this.path.isEmpty();
  }

  /**
   * @returns the \`path\` property value as a fhirString if defined; else undefined
   */
  public getPath(): fhirString | undefined {
    return this.path?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`path\` property.
   *
   * @param value - the \`path\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPath(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid DataRequirement.codeFilter.path (\${String(value)})\`;
      this.path = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.path = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`path\` property exists and has a value; \`false\` otherwise
   */
  public hasPath(): boolean {
    return this.hasPathElement();
  }

  /**
   * @returns the \`searchParam\` property value as a StringType object if defined; else an empty StringType object
   */
  public getSearchParamElement(): StringType {
    return this.searchParam ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`searchParam\` property.
   *
   * @param element - the \`searchParam\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSearchParamElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid DataRequirement.codeFilter.searchParam; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.searchParam = element;
    } else {
      this.searchParam = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`searchParam\` property exists and has a value; \`false\` otherwise
   */
  public hasSearchParamElement(): boolean {
    return isDefined<StringType>(this.searchParam) && !this.searchParam.isEmpty();
  }

  /**
   * @returns the \`searchParam\` property value as a fhirString if defined; else undefined
   */
  public getSearchParam(): fhirString | undefined {
    return this.searchParam?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`searchParam\` property.
   *
   * @param value - the \`searchParam\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSearchParam(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid DataRequirement.codeFilter.searchParam (\${String(value)})\`;
      this.searchParam = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.searchParam = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`searchParam\` property exists and has a value; \`false\` otherwise
   */
  public hasSearchParam(): boolean {
    return this.hasSearchParamElement();
  }

  /**
   * @returns the \`valueSet\` property value as a CanonicalType object if defined; else an empty CanonicalType object
   */
  public getValueSetElement(): CanonicalType {
    return this.valueSet ?? new CanonicalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`valueSet\` property.
   *
   * @param element - the \`valueSet\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValueSetElement(element: CanonicalType | undefined): this {
    if (isDefined<CanonicalType>(element)) {
      const optErrMsg = \`Invalid DataRequirement.codeFilter.valueSet; Provided element is not an instance of CanonicalType.\`;
      assertFhirType<CanonicalType>(element, CanonicalType, optErrMsg);
      this.valueSet = element;
    } else {
      this.valueSet = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`valueSet\` property exists and has a value; \`false\` otherwise
   */
  public hasValueSetElement(): boolean {
    return isDefined<CanonicalType>(this.valueSet) && !this.valueSet.isEmpty();
  }

  /**
   * @returns the \`valueSet\` property value as a fhirCanonical if defined; else undefined
   */
  public getValueSet(): fhirCanonical | undefined {
    return this.valueSet?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`valueSet\` property.
   *
   * @param value - the \`valueSet\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValueSet(value: fhirCanonical | undefined): this {
    if (isDefined<fhirCanonical>(value)) {
      const optErrMsg = \`Invalid DataRequirement.codeFilter.valueSet (\${String(value)})\`;
      this.valueSet = new CanonicalType(parseFhirPrimitiveData(value, fhirCanonicalSchema, optErrMsg));
    } else {
      this.valueSet = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`valueSet\` property exists and has a value; \`false\` otherwise
   */
  public hasValueSet(): boolean {
    return this.hasValueSetElement();
  }

  /**
   * @returns the \`code\` property value as a Coding array
   */
  public getCode(): Coding[] {
    return this.code ?? ([] as Coding[]);
  }

  /**
   * Assigns the provided Coding array value to the \`code\` property.
   *
   * @param value - the \`code\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setCode(value: Coding[] | undefined): this {
    if (isDefinedList<Coding>(value)) {
      const optErrMsg = \`Invalid DataRequirement.codeFilter.code; Provided value array has an element that is not an instance of Coding.\`;
      assertFhirTypeList<Coding>(value, Coding, optErrMsg);
      this.code = value;
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * Add the provided Coding value to the \`code\` array property.
   *
   * @param value - the \`code\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addCode(value: Coding | undefined): this {
    if (isDefined<Coding>(value)) {
      const optErrMsg = \`Invalid DataRequirement.codeFilter.code; Provided element is not an instance of Coding.\`;
      assertFhirType<Coding>(value, Coding, optErrMsg);
      this.initCode();
      this.code?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`code\` property exists and has a value; \`false\` otherwise
   */
  public hasCode(): boolean {
    return isDefinedList<Coding>(this.code) && this.code.some((item: Coding) => !item.isEmpty());
  }

  /**
   * Initialize the \`code\` property
   */
  private initCode(): void {
    if(!this.hasCode()) {
      this.code = [] as Coding[];
    }
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'DataRequirement.codeFilter';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.path,
      this.searchParam,
      this.valueSet,
      this.code,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): DataRequirementCodeFilterComponent {
    const dest = new DataRequirementCodeFilterComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: DataRequirementCodeFilterComponent): void {
    super.copyValues(dest);
    dest.path = this.path?.copy();
    dest.searchParam = this.searchParam?.copy();
    dest.valueSet = this.valueSet?.copy();
    const codeList = copyListValues<Coding>(this.code);
    dest.code = codeList.length === 0 ? undefined : codeList;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', \`UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasPathElement()) {
      setFhirPrimitiveJson<fhirString>(this.getPathElement(), 'path', jsonObj);
    }

    if (this.hasSearchParamElement()) {
      setFhirPrimitiveJson<fhirString>(this.getSearchParamElement(), 'searchParam', jsonObj);
    }

    if (this.hasValueSetElement()) {
      setFhirPrimitiveJson<fhirCanonical>(this.getValueSetElement(), 'valueSet', jsonObj);
    }

    if (this.hasCode()) {
      setFhirComplexListJson(this.getCode(), 'code', jsonObj);
    }

    return jsonObj;
  }
}
/**
 * DataRequirementDateFilterComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** What dates/date ranges are expected
 * - **Definition:** Date filters specify additional constraints on the data in terms of the applicable date range for specific elements. Each date filter specifies an additional constraint on the data, i.e. date filters are AND\\'ed, not OR\\'ed.
 *
 * @category Data Models: ComplexType
 * @see [FHIR DataRequirement](http://hl7.org/fhir/StructureDefinition/DataRequirement)
 */
/* istanbul ignore next */ export class DataRequirementDateFilterComponent extends DataType implements IDataType {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`DataRequirementDateFilterComponent\` JSON to instantiate the DataRequirementDateFilterComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`DataRequirementDateFilterComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to DataRequirementDateFilterComponent
   * @returns DataRequirementDateFilterComponent data model or undefined for \`DataRequirementDateFilterComponent\`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): DataRequirementDateFilterComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'DataRequirementDateFilterComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new DataRequirementDateFilterComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const classMetadata: DecoratorMetadataObject | null = DataRequirementDateFilterComponent[Symbol.metadata];
    const errorMessage = \`DecoratorMetadataObject does not exist for DataRequirementDateFilterComponent\`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    fieldName = 'path';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setPathElement(datatype);
    }

    fieldName = 'searchParam';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setSearchParamElement(datatype);
    }

    fieldName = 'value[x]';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const value: IDataType | undefined = fhirParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setValue(value);

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * DataRequirement.dateFilter.path Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A date-valued attribute to filter on
   * - **Definition:** The date-valued attribute of the filter. The specified path SHALL be a FHIRPath resolveable on the specified type of the DataRequirement, and SHALL consist only of identifiers, constant indexers, and .resolve(). The path is allowed to contain qualifiers (.) to traverse sub-elements, as well as indexers ([x]) to traverse multiple-cardinality sub-elements (see the [Simple FHIRPath Profile](https://hl7.org/fhir/fhirpath.html#simple) for full details). Note that the index must be an integer constant. The path must resolve to an element of type date, dateTime, Period, Schedule, or Timing.
   * - **Comment:** The path attribute contains a [Simple FHIR Subset](https://hl7.org/fhir/fhirpath.html#simple) that allows path traversal, but not calculation.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private path?: StringType | undefined;

  /**
   * DataRequirement.dateFilter.searchParam Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A date valued parameter to search on
   * - **Definition:** A date parameter that refers to a search parameter defined on the specified type of the DataRequirement, and which searches on elements of type date, dateTime, Period, Schedule, or Timing.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private searchParam?: StringType | undefined;

  /**
   * DataRequirement.dateFilter.value[x] Element
   *
   * @decorator \`@ChoiceDataTypesMeta('DataRequirement.dateFilter.value[x]', ['dateTime','Period','Duration',]\`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The value of the filter, as a Period, DateTime, or Duration value
   * - **Definition:** The value of the filter. If period is specified, the filter will return only those data items that fall within the bounds determined by the Period, inclusive of the period boundaries. If dateTime is specified, the filter will return only those data items that are equal to the specified dateTime. If a Duration is specified, the filter will return only those data items that fall within Duration before now.
   * - **FHIR Types:**
   *     'dateTime',
   *     'Period',
   *     'Duration',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('DataRequirement.dateFilter.value[x]',[
    'dateTime',
    'Period',
    'Duration',
  ])
  private value?: IDataType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`path\` property value as a StringType object if defined; else an empty StringType object
   */
  public getPathElement(): StringType {
    return this.path ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`path\` property.
   *
   * @param element - the \`path\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPathElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid DataRequirement.dateFilter.path; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.path = element;
    } else {
      this.path = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`path\` property exists and has a value; \`false\` otherwise
   */
  public hasPathElement(): boolean {
    return isDefined<StringType>(this.path) && !this.path.isEmpty();
  }

  /**
   * @returns the \`path\` property value as a fhirString if defined; else undefined
   */
  public getPath(): fhirString | undefined {
    return this.path?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`path\` property.
   *
   * @param value - the \`path\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPath(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid DataRequirement.dateFilter.path (\${String(value)})\`;
      this.path = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.path = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`path\` property exists and has a value; \`false\` otherwise
   */
  public hasPath(): boolean {
    return this.hasPathElement();
  }

  /**
   * @returns the \`searchParam\` property value as a StringType object if defined; else an empty StringType object
   */
  public getSearchParamElement(): StringType {
    return this.searchParam ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`searchParam\` property.
   *
   * @param element - the \`searchParam\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSearchParamElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid DataRequirement.dateFilter.searchParam; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.searchParam = element;
    } else {
      this.searchParam = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`searchParam\` property exists and has a value; \`false\` otherwise
   */
  public hasSearchParamElement(): boolean {
    return isDefined<StringType>(this.searchParam) && !this.searchParam.isEmpty();
  }

  /**
   * @returns the \`searchParam\` property value as a fhirString if defined; else undefined
   */
  public getSearchParam(): fhirString | undefined {
    return this.searchParam?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`searchParam\` property.
   *
   * @param value - the \`searchParam\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSearchParam(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid DataRequirement.dateFilter.searchParam (\${String(value)})\`;
      this.searchParam = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.searchParam = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`searchParam\` property exists and has a value; \`false\` otherwise
   */
  public hasSearchParam(): boolean {
    return this.hasSearchParamElement();
  }

  /**
   * @returns the \`value\` property value as a DataType object if defined; else undefined
   */
  public getValue(): IDataType | undefined {
    return this.value;
  }

  /**
   * Assigns the provided DataType object value to the \`value\` property.
   *
   * @decorator \`@ChoiceDataTypes('DataRequirement.dateFilter.value[x]')\`
   *
   * @param value - the \`value\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  @ChoiceDataTypes('DataRequirement.dateFilter.value[x]')
  public setValue(value: IDataType | undefined): this {
    if (isDefined<IDataType>(value)) {
      // assertFhirType<IDataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.value = value;
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`value\` property exists and has a value; \`false\` otherwise
   */
  public hasValue(): boolean {
    return isDefined<IDataType>(this.value) && !this.value.isEmpty();
  }

  // *** NOTE ***
  // Following choice datatype-specific "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the \`value\` property value as a DateTimeType object if defined; else undefined
   */
  public getValueDateTimeType(): DateTimeType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof DateTimeType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for DataRequirement.dateFilter.value[x]: Expected DateTimeType but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a DateTimeType and has a value; \`false\` otherwise
   */
  public hasValueDateTimeType(): boolean {
    return this.hasValue() && this.value instanceof DateTimeType;
  }

  /**
   * @returns the \`value\` property value as a Period object if defined; else undefined
   */
  public getValuePeriod(): Period | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Period)) {
      throw new InvalidTypeError(
        \`DataType mismatch for DataRequirement.dateFilter.value[x]: Expected Period but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a Period and has a value; \`false\` otherwise
   */
  public hasValuePeriod(): boolean {
    return this.hasValue() && this.value instanceof Period;
  }

  /**
   * @returns the \`value\` property value as a Duration object if defined; else undefined
   */
  public getValueDuration(): Duration | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Duration)) {
      throw new InvalidTypeError(
        \`DataType mismatch for DataRequirement.dateFilter.value[x]: Expected Duration but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a Duration and has a value; \`false\` otherwise
   */
  public hasValueDuration(): boolean {
    return this.hasValue() && this.value instanceof Duration;
  }

  // End of choice datatype-specific "get"/"has" methods

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'DataRequirement.dateFilter';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.path,
      this.searchParam,
      this.value,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): DataRequirementDateFilterComponent {
    const dest = new DataRequirementDateFilterComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: DataRequirementDateFilterComponent): void {
    super.copyValues(dest);
    dest.path = this.path?.copy();
    dest.searchParam = this.searchParam?.copy();
    dest.value = this.value?.copy() as IDataType;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', \`UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasPathElement()) {
      setFhirPrimitiveJson<fhirString>(this.getPathElement(), 'path', jsonObj);
    }

    if (this.hasSearchParamElement()) {
      setFhirPrimitiveJson<fhirString>(this.getSearchParamElement(), 'searchParam', jsonObj);
    }

    if (this.hasValue()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getValue()!, 'value', jsonObj);
    }

    return jsonObj;
  }
}
/**
 * DataRequirementSortComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Order of the results
 * - **Definition:** Specifies the order of the results to be returned.
 * - **Comment:** This element can be used in combination with the sort element to specify quota requirements such as "the most recent 5" or "the highest 5". When multiple sorts are specified, they are applied in the order they appear in the resource.
 * - **Requirements:** Enables the requirement "most recent 5 results" to be expressed.
 *
 * @category Data Models: ComplexType
 * @see [FHIR DataRequirement](http://hl7.org/fhir/StructureDefinition/DataRequirement)
 */
/* istanbul ignore next */ export class DataRequirementSortComponent extends DataType implements IDataType {
  constructor(path: StringType | fhirString | null = null, direction: EnumCodeType | CodeType | fhirCode | null = null) {
    super();

    this.sortDirectionEnum = new SortDirectionEnum();

    this.path = null;
    if (isDefined<StringType | fhirString>(path)) {
      if (path instanceof PrimitiveType) {
        this.setPathElement(path);
      } else {
        this.setPath(path);
      }
    }

    this.direction = constructorCodeValueAsEnumCodeType<SortDirectionEnum>(
      direction,
      SortDirectionEnum,
      this.sortDirectionEnum,
      'DataRequirement.sort.direction',
    );
  }

  /**
   * Parse the provided \`DataRequirementSortComponent\` JSON to instantiate the DataRequirementSortComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`DataRequirementSortComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to DataRequirementSortComponent
   * @returns DataRequirementSortComponent data model or undefined for \`DataRequirementSortComponent\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): DataRequirementSortComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'DataRequirementSortComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new DataRequirementSortComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'path';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setPathElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'direction';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setDirectionElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * DataRequirement.sort.path Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The name of the attribute to perform the sort
   * - **Definition:** The attribute of the sort. The specified path must be resolvable from the type of the required data. The path is allowed to contain qualifiers (.) to traverse sub-elements, as well as indexers ([x]) to traverse multiple-cardinality sub-elements. Note that the index must be an integer constant.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private path: StringType | null;

  /**
   * FHIR CodeSystem: SortDirection
   *
   * @see {@link SortDirectionEnum }
   */
  private readonly sortDirectionEnum: SortDirectionEnum;

  /**
   * DataRequirement.sort.direction Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** ascending | descending
   * - **Definition:** The direction of the sort, ascending or descending.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link SortDirectionEnum }
   */
  private direction: EnumCodeType | null;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`path\` property value as a StringType object if defined; else null
   */
  public getPathElement(): StringType | null {
    return this.path;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`path\` property.
   *
   * @param element - the \`path\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPathElement(element: StringType): this {
    assertIsDefined<StringType>(element, \`DataRequirement.sort.path is required\`);
    const optErrMsg = \`Invalid DataRequirement.sort.path; Provided value is not an instance of StringType.\`;
    assertFhirType<StringType>(element, StringType, optErrMsg);
    this.path = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`path\` property exists and has a value; \`false\` otherwise
   */
  public hasPathElement(): boolean {
    return isDefined<StringType>(this.path) && !this.path.isEmpty();
  }

  /**
   * @returns the \`path\` property value as a fhirString if defined; else null
   */
  public getPath(): fhirString | null {
    if (this.path?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.path.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`path\` property.
   *
   * @param value - the \`path\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPath(value: fhirString): this {
    assertIsDefined<fhirString>(value, \`DataRequirement.sort.path is required\`);
    const optErrMsg = \`Invalid DataRequirement.sort.path (\${String(value)})\`;
    this.path = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`path\` property exists and has a value; \`false\` otherwise
   */
  public hasPath(): boolean {
    return this.hasPathElement();
  }

  /**
   * @returns the \`direction\` property value as a EnumCodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link SortDirectionEnum }
   */
  public getDirectionEnumType(): EnumCodeType | null {
    return this.direction;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`direction\` property.
   *
   * @param enumType - the \`direction\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link SortDirectionEnum }
   */
  public setDirectionEnumType(enumType: EnumCodeType): this {
    assertIsDefined<EnumCodeType>(enumType, \`DataRequirement.sort.direction is required\`);
    const errMsgPrefix = \`Invalid DataRequirement.sort.direction\`;
    assertEnumCodeType<SortDirectionEnum>(enumType, SortDirectionEnum, errMsgPrefix);
    this.direction = enumType;
    return this;
  }

  /**
   * @returns \`true\` if the \`direction\` property exists and has a value; \`false\` otherwise
   */
  public hasDirectionEnumType(): boolean {
    return isDefined<EnumCodeType>(this.direction) && !this.direction.isEmpty() && this.direction.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`direction\` property value as a CodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link SortDirectionEnum }
   */
  public getDirectionElement(): CodeType | null {
    if (this.direction === null) {
      return null;
    }
    return this.direction as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`direction\` property.
   *
   * @param element - the \`direction\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link SortDirectionEnum }
   */
  public setDirectionElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, \`DataRequirement.sort.direction is required\`);
    const optErrMsg = \`Invalid DataRequirement.sort.direction; Provided value is not an instance of CodeType.\`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.direction = new EnumCodeType(element, this.sortDirectionEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`direction\` property exists and has a value; \`false\` otherwise
   */
  public hasDirectionElement(): boolean {
    return this.hasDirectionEnumType();
  }

  /**
   * @returns the \`direction\` property value as a fhirCode if defined; else null
   *
   * @see CodeSystem Enumeration: {@link SortDirectionEnum }
   */
  public getDirection(): fhirCode | null {
    if (this.direction === null) {
      return null;
    }
    return this.direction.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`direction\` property.
   *
   * @param value - the \`direction\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link SortDirectionEnum }
   */
  public setDirection(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, \`DataRequirement.sort.direction is required\`);
    const optErrMsg = \`Invalid DataRequirement.sort.direction (\${String(value)})\`;
    this.direction = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.sortDirectionEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`direction\` property exists and has a value; \`false\` otherwise
   */
  public hasDirection(): boolean {
    return this.hasDirectionEnumType();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'DataRequirement.sort';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.path,
      this.direction,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): DataRequirementSortComponent {
    const dest = new DataRequirementSortComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: DataRequirementSortComponent): void {
    super.copyValues(dest);
    dest.path = this.path ? this.path.copy() : null;
    dest.direction = this.direction ? this.direction.copy() : null;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', \`UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasPathElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirString>(this.getPathElement()!, 'path', jsonObj);
    } else {
      missingReqdProperties.push(\`DataRequirement.sort.path\`);
    }

    if (this.hasDirectionElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getDirectionElement()!, 'direction', jsonObj);
    } else {
      missingReqdProperties.push(\`DataRequirement.sort.direction\`);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

/**
 * Distance Class
 *
 * @remarks
 * Base StructureDefinition for Distance Type: A length - a value with a unit that is a physical distance.
 *
 * **FHIR Specification**
 * - **Short:** A length - a value with a unit that is a physical distance
 * - **Definition:** A length - a value with a unit that is a physical distance.
 * - **Comment:** The context of use may frequently define what kind of quantity this is and therefore what kind of units can be used. The context of use may also restrict the values for the comparator.
 * - **FHIR Version:** 4.0.1
 *
 * @category Data Models: ComplexType
 * @see [FHIR Distance](http://hl7.org/fhir/StructureDefinition/Distance)
 */
/* istanbul ignore next */ export class Distance extends DataType implements IDataType {
  constructor() {
    super();

    this.quantityComparatorEnum = new QuantityComparatorEnum();
  }

  /**
   * Parse the provided \`Distance\` JSON to instantiate the Distance data model.
   *
   * @param sourceJson - JSON representing FHIR \`Distance\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Distance
   * @returns Distance data model or undefined for \`Distance\`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Distance | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Distance';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Distance();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'value';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setValueElement(datatype);
    }

    fieldName = 'comparator';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setComparatorElement(datatype);
    }

    fieldName = 'unit';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setUnitElement(datatype);
    }

    fieldName = 'system';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = fhirParser.parseUriType(dtJson, dtSiblingJson);
      instance.setSystemElement(datatype);
    }

    fieldName = 'code';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setCodeElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Distance.value Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Numerical value (with implicit precision)
   * - **Definition:** The value of the measured amount. The value includes an implicit precision in the presentation of the value.
   * - **Comment:** The implicit precision in the value should always be honored. Monetary values have their own rules for handling precision (refer to standard accounting text books).
   * - **Requirements:** Precision is handled implicitly in almost all cases of measurement.
   * - **FHIR Type:** \`decimal\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private value?: DecimalType | undefined;

  /**
   * FHIR CodeSystem: QuantityComparator
   *
   * @see {@link QuantityComparatorEnum }
   */
  private readonly quantityComparatorEnum: QuantityComparatorEnum;

  /**
   * Distance.comparator Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** < | <= | >= | > - how to understand the value
   * - **Definition:** How the value should be understood and represented - whether the actual value is greater or less than the stated value due to measurement issues; e.g. if the comparator is "<" , then the real value is < stated value.
   * - **Requirements:** Need a framework for handling measures where the value is <5ug/L or >400mg/L due to the limitations of measuring methodology.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** true
   * - **isModifierReason:** This is labeled as &quot;Is Modifier&quot; because the comparator modifies the interpretation of the value significantly. If there is no comparator, then there is no modification of the value
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  private comparator?: EnumCodeType | undefined;

  /**
   * Distance.unit Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Unit representation
   * - **Definition:** A human-readable form of the unit.
   * - **Requirements:** There are many representations for units of measure and in many contexts, particular representations are fixed and required. I.e. mcg for micrograms.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private unit?: StringType | undefined;

  /**
   * Distance.system Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** System that defines coded unit form
   * - **Definition:** The identification of the system that provides the coded form of the unit.
   * - **Requirements:** Need to know the system that defines the coded form of the unit.
   * - **FHIR Type:** \`uri\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private system?: UriType | undefined;

  /**
   * Distance.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Coded form of the unit
   * - **Definition:** A computer processable form of the unit in some unit representation system.
   * - **Comment:** The preferred system is UCUM, but SNOMED CT can also be used (for customary units) or ISO 4217 for currency.  The context of use may additionally require a code from a particular system.
   * - **Requirements:** Need a computable form of the unit that is fixed across all forms. UCUM provides this for quantities, but SNOMED CT provides many units of interest.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code?: CodeType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`value\` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getValueElement(): DecimalType {
    return this.value ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`value\` property.
   *
   * @param element - the \`value\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValueElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = \`Invalid Distance.value; Provided element is not an instance of DecimalType.\`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.value = element;
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`value\` property exists and has a value; \`false\` otherwise
   */
  public hasValueElement(): boolean {
    return isDefined<DecimalType>(this.value) && !this.value.isEmpty();
  }

  /**
   * @returns the \`value\` property value as a fhirDecimal if defined; else undefined
   */
  public getValue(): fhirDecimal | undefined {
    return this.value?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`value\` property.
   *
   * @param value - the \`value\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValue(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = \`Invalid Distance.value (\${String(value)})\`;
      this.value = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`value\` property exists and has a value; \`false\` otherwise
   */
  public hasValue(): boolean {
    return this.hasValueElement();
  }

  /**
   * @returns the \`comparator\` property value as a EnumCodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public getComparatorEnumType(): EnumCodeType | undefined {
    return this.comparator;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`comparator\` property.
   *
   * @param enumType - the \`comparator\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code values
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public setComparatorEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid Distance.comparator';
      assertEnumCodeType<QuantityComparatorEnum>(enumType, QuantityComparatorEnum, errMsgPrefix);
      this.comparator = enumType;
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`comparator\` property exists and has a value; \`false\` otherwise
   */
  public hasComparatorEnumType(): boolean {
    return isDefined<EnumCodeType>(this.comparator) && !this.comparator.isEmpty() && this.comparator.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`comparator\` property value as a CodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public getComparatorElement(): CodeType | undefined {
    if (this.comparator === undefined) {
      return undefined;
    }
    return this.comparator as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`comparator\` property.
   *
   * @param element - the \`comparator\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public setComparatorElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Distance.comparator; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.comparator = new EnumCodeType(element, this.quantityComparatorEnum);
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`comparator\` property exists and has a value; \`false\` otherwise
   */
  public hasComparatorElement(): boolean {
    return this.hasComparatorEnumType();
  }

  /**
   * @returns the \`comparator\` property value as a fhirCode if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public getComparator(): fhirCode | undefined {
    if (this.comparator === undefined) {
      return undefined;
    }
    return this.comparator.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`comparator\` property.
   *
   * @param value - the \`comparator\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public setComparator(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Distance.comparator; Provided value is not an instance of fhirCode.\`;
      this.comparator = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.quantityComparatorEnum);
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`comparator\` property exists and has a value; \`false\` otherwise
   */
  public hasComparator(): boolean {
    return this.hasComparatorEnumType();
  }

  /**
   * @returns the \`unit\` property value as a StringType object if defined; else an empty StringType object
   */
  public getUnitElement(): StringType {
    return this.unit ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`unit\` property.
   *
   * @param element - the \`unit\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUnitElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Distance.unit; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.unit = element;
    } else {
      this.unit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`unit\` property exists and has a value; \`false\` otherwise
   */
  public hasUnitElement(): boolean {
    return isDefined<StringType>(this.unit) && !this.unit.isEmpty();
  }

  /**
   * @returns the \`unit\` property value as a fhirString if defined; else undefined
   */
  public getUnit(): fhirString | undefined {
    return this.unit?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`unit\` property.
   *
   * @param value - the \`unit\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUnit(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Distance.unit (\${String(value)})\`;
      this.unit = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.unit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`unit\` property exists and has a value; \`false\` otherwise
   */
  public hasUnit(): boolean {
    return this.hasUnitElement();
  }

  /**
   * @returns the \`system\` property value as a UriType object if defined; else an empty UriType object
   */
  public getSystemElement(): UriType {
    return this.system ?? new UriType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`system\` property.
   *
   * @param element - the \`system\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSystemElement(element: UriType | undefined): this {
    if (isDefined<UriType>(element)) {
      const optErrMsg = \`Invalid Distance.system; Provided element is not an instance of UriType.\`;
      assertFhirType<UriType>(element, UriType, optErrMsg);
      this.system = element;
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`system\` property exists and has a value; \`false\` otherwise
   */
  public hasSystemElement(): boolean {
    return isDefined<UriType>(this.system) && !this.system.isEmpty();
  }

  /**
   * @returns the \`system\` property value as a fhirUri if defined; else undefined
   */
  public getSystem(): fhirUri | undefined {
    return this.system?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`system\` property.
   *
   * @param value - the \`system\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSystem(value: fhirUri | undefined): this {
    if (isDefined<fhirUri>(value)) {
      const optErrMsg = \`Invalid Distance.system (\${String(value)})\`;
      this.system = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`system\` property exists and has a value; \`false\` otherwise
   */
  public hasSystem(): boolean {
    return this.hasSystemElement();
  }

  /**
   * @returns the \`code\` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getCodeElement(): CodeType {
    return this.code ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`code\` property.
   *
   * @param element - the \`code\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCodeElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Distance.code; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.code = element;
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`code\` property exists and has a value; \`false\` otherwise
   */
  public hasCodeElement(): boolean {
    return isDefined<CodeType>(this.code) && !this.code.isEmpty();
  }

  /**
   * @returns the \`code\` property value as a fhirCode if defined; else undefined
   */
  public getCode(): fhirCode | undefined {
    return this.code?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`code\` property.
   *
   * @param value - the \`code\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCode(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Distance.code (\${String(value)})\`;
      this.code = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`code\` property exists and has a value; \`false\` otherwise
   */
  public hasCode(): boolean {
    return this.hasCodeElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Distance';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.value,
      this.comparator,
      this.unit,
      this.system,
      this.code,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Distance {
    const dest = new Distance();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Distance): void {
    super.copyValues(dest);
    dest.value = this.value?.copy();
    dest.comparator = this.comparator?.copy();
    dest.unit = this.unit?.copy();
    dest.system = this.system?.copy();
    dest.code = this.code?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', \`UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasValueElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getValueElement(), 'value', jsonObj);
    }

    if (this.hasComparatorElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getComparatorElement()!, 'comparator', jsonObj);
    }

    if (this.hasUnitElement()) {
      setFhirPrimitiveJson<fhirString>(this.getUnitElement(), 'unit', jsonObj);
    }

    if (this.hasSystemElement()) {
      setFhirPrimitiveJson<fhirUri>(this.getSystemElement(), 'system', jsonObj);
    }

    if (this.hasCodeElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getCodeElement(), 'code', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * Dosage Class
 *
 * @remarks
 * Base StructureDefinition for Dosage Type: Indicates how the medication is/was taken or should be taken by the patient.
 *
 * **FHIR Specification**
 * - **Short:** How the medication is/was taken or should be taken
 * - **Definition:** Indicates how the medication is/was taken or should be taken by the patient.
 * - **FHIR Version:** 4.0.1
 *
 * @category Data Models: ComplexType
 * @see [FHIR Dosage](http://hl7.org/fhir/StructureDefinition/Dosage)
 */
/* istanbul ignore next */ export class Dosage extends BackboneType implements IBackboneType {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`Dosage\` JSON to instantiate the Dosage data model.
   *
   * @param sourceJson - JSON representing FHIR \`Dosage\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Dosage
   * @returns Dosage data model or undefined for \`Dosage\`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Dosage | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Dosage';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Dosage();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneTypeJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const classMetadata: DecoratorMetadataObject | null = Dosage[Symbol.metadata];
    const errorMessage = \`DecoratorMetadataObject does not exist for Dosage\`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    fieldName = 'sequence';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: IntegerType | undefined = fhirParser.parseIntegerType(dtJson, dtSiblingJson);
      instance.setSequenceElement(datatype);
    }

    fieldName = 'text';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setTextElement(datatype);
    }

    fieldName = 'additionalInstruction';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: CodeableConcept | undefined = CodeableConcept.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addAdditionalInstruction(datatype);
        }
      });
    }

    fieldName = 'patientInstruction';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setPatientInstructionElement(datatype);
    }

    fieldName = 'timing';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Timing | undefined = Timing.parse(classJsonObj[fieldName]!, sourceField);
      instance.setTiming(datatype);
    }

    fieldName = 'asNeeded[x]';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const asNeeded: IDataType | undefined = fhirParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setAsNeeded(asNeeded);

    fieldName = 'site';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = CodeableConcept.parse(classJsonObj[fieldName]!, sourceField);
      instance.setSite(datatype);
    }

    fieldName = 'route';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = CodeableConcept.parse(classJsonObj[fieldName]!, sourceField);
      instance.setRoute(datatype);
    }

    fieldName = 'method';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = CodeableConcept.parse(classJsonObj[fieldName]!, sourceField);
      instance.setMethod(datatype);
    }

    fieldName = 'doseAndRate';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: DosageDoseAndRateComponent | undefined = DosageDoseAndRateComponent.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addDoseAndRate(datatype);
        }
      });
    }

    fieldName = 'maxDosePerPeriod';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Ratio | undefined = Ratio.parse(classJsonObj[fieldName]!, sourceField);
      instance.setMaxDosePerPeriod(datatype);
    }

    fieldName = 'maxDosePerAdministration';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = Quantity.parse(classJsonObj[fieldName]!, sourceField);
      instance.setMaxDosePerAdministration(datatype);
    }

    fieldName = 'maxDosePerLifetime';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = Quantity.parse(classJsonObj[fieldName]!, sourceField);
      instance.setMaxDosePerLifetime(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Dosage.sequence Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The order of the dosage instructions
   * - **Definition:** Indicates the order in which the dosage instructions should be applied or interpreted.
   * - **Requirements:** If the sequence number of multiple Dosages is the same, then it is implied that the instructions are to be treated as concurrent.  If the sequence number is different, then the Dosages are intended to be sequential.
   * - **FHIR Type:** \`integer\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private sequence?: IntegerType | undefined;

  /**
   * Dosage.text Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Free text dosage instructions e.g. SIG
   * - **Definition:** Free text dosage instructions e.g. SIG.
   * - **Requirements:** Free text dosage instructions can be used for cases where the instructions are too complex to code.  The content of this attribute does not include the name or description of the medication. When coded instructions are present, the free text instructions may still be present for display to humans taking or administering the medication. It is expected that the text instructions will always be populated.  If the dosage.timing attribute is also populated, then the dosage.text should reflect the same information as the timing.  Additional information about administration or preparation of the medication should be included as text.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private text?: StringType | undefined;

  /**
   * Dosage.additionalInstruction Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Supplemental instruction or warnings to the patient - e.g. "with meals", "may cause drowsiness"
   * - **Definition:** Supplemental instructions to the patient on how to take the medication  (e.g. "with meals" or"take half to one hour before food") or warnings for the patient about the medication (e.g. "may cause drowsiness" or "avoid exposure of skin to direct sunlight or sunlamps").
   * - **Comment:** Information about administration or preparation of the medication (e.g. "infuse as rapidly as possibly via intraperitoneal port" or "immediately following drug x") should be populated in dosage.text.
   * - **Requirements:** Additional instruction is intended to be coded, but where no code exists, the element could include text.  For example, "Swallow with plenty of water" which might or might not be coded.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private additionalInstruction?: CodeableConcept[] | undefined;

  /**
   * Dosage.patientInstruction Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Patient or consumer oriented instructions
   * - **Definition:** Instructions in terms that are understood by the patient or consumer.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private patientInstruction?: StringType | undefined;

  /**
   * Dosage.timing Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** When medication should be administered
   * - **Definition:** When medication should be administered.
   * - **Comment:** This attribute might not always be populated while the Dosage.text is expected to be populated.  If both are populated, then the Dosage.text should reflect the content of the Dosage.timing.
   * - **Requirements:** The timing schedule for giving the medication to the patient. This  data type allows many different expressions. For example: "Every 8 hours"; "Three times a day"; "1/2 an hour before breakfast for 10 days from 23-Dec 2011:"; "15 Oct 2013, 17 Oct 2013 and 1 Nov 2013".  Sometimes, a rate can imply duration when expressed as total volume / duration (e.g.  500mL/2 hours implies a duration of 2 hours).  However, when rate doesn\\'t imply duration (e.g. 250mL/hour), then the timing.repeat.duration is needed to convey the infuse over time period.
   * - **FHIR Type:** \`Timing\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private timing?: Timing | undefined;

  /**
   * Dosage.asNeeded[x] Element
   *
   * @decorator \`@ChoiceDataTypesMeta('Dosage.asNeeded[x]', ['boolean','CodeableConcept',]\`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Take "as needed" (for x)
   * - **Definition:** Indicates whether the Medication is only taken when needed within a specific dosing schedule (Boolean option), or it indicates the precondition for taking the Medication (CodeableConcept).
   * - **Comment:** Can express "as needed" without a reason by setting the Boolean = True.  In this case the CodeableConcept is not populated.  Or you can express "as needed" with a reason by including the CodeableConcept.  In this case the Boolean is assumed to be True.  If you set the Boolean to False, then the dose is given according to the schedule and is not "prn" or "as needed".
   * - **FHIR Types:**
   *     'boolean',
   *     'CodeableConcept',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('Dosage.asNeeded[x]',[
    'boolean',
    'CodeableConcept',
  ])
  private asNeeded?: IDataType | undefined;

  /**
   * Dosage.site Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Body site to administer to
   * - **Definition:** Body site to administer to.
   * - **Comment:** If the use case requires attributes from the BodySite resource (e.g. to identify and track separately) then use the standard extension [bodySite](https://hl7.org/fhir/extension-bodysite.html).  May be a summary code, or a reference to a very precise definition of the location, or both.
   * - **Requirements:** A coded specification of the anatomic site where the medication first enters the body.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private site?: CodeableConcept | undefined;

  /**
   * Dosage.route Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** How drug should enter body
   * - **Definition:** How drug should enter body.
   * - **Requirements:** A code specifying the route or physiological path of administration of a therapeutic agent into or onto a patient\\'s body.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private route?: CodeableConcept | undefined;

  /**
   * Dosage.method Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Technique for administering medication
   * - **Definition:** Technique for administering medication.
   * - **Comment:** Terminologies used often pre-coordinate this term with the route and or form of administration.
   * - **Requirements:** A coded value indicating the method by which the medication is introduced into or onto the body. Most commonly used for injections.  For examples, Slow Push; Deep IV.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private method?: CodeableConcept | undefined;

  /**
   * Dosage.doseAndRate Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Amount of medication administered
   * - **Definition:** The amount of medication administered.
   * - **FHIR Type:** \`Element\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private doseAndRate?: DosageDoseAndRateComponent[] | undefined;

  /**
   * Dosage.maxDosePerPeriod Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Upper limit on medication per unit of time
   * - **Definition:** Upper limit on medication per unit of time.
   * - **Comment:** This is intended for use as an adjunct to the dosage when there is an upper cap.  For example "2 tablets every 4 hours to a maximum of 8/day".
   * - **Requirements:** The maximum total quantity of a therapeutic substance that may be administered to a subject over the period of time.  For example, 1000mg in 24 hours.
   * - **FHIR Type:** \`Ratio\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private maxDosePerPeriod?: Ratio | undefined;

  /**
   * Dosage.maxDosePerAdministration Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Upper limit on medication per administration
   * - **Definition:** Upper limit on medication per administration.
   * - **Comment:** This is intended for use as an adjunct to the dosage when there is an upper cap.  For example, a body surface area related dose with a maximum amount, such as 1.5 mg/m2 (maximum 2 mg) IV over 5 - 10 minutes would have doseQuantity of 1.5 mg/m2 and maxDosePerAdministration of 2 mg.
   * - **Requirements:** The maximum total quantity of a therapeutic substance that may be administered to a subject per administration.
   * - **FHIR Type:** \`Quantity\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private maxDosePerAdministration?: Quantity | undefined;

  /**
   * Dosage.maxDosePerLifetime Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Upper limit on medication per lifetime of the patient
   * - **Definition:** Upper limit on medication per lifetime of the patient.
   * - **Requirements:** The maximum total quantity of a therapeutic substance that may be administered per lifetime of the subject.
   * - **FHIR Type:** \`Quantity\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private maxDosePerLifetime?: Quantity | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`sequence\` property value as a IntegerType object if defined; else an empty IntegerType object
   */
  public getSequenceElement(): IntegerType {
    return this.sequence ?? new IntegerType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`sequence\` property.
   *
   * @param element - the \`sequence\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSequenceElement(element: IntegerType | undefined): this {
    if (isDefined<IntegerType>(element)) {
      const optErrMsg = \`Invalid Dosage.sequence; Provided element is not an instance of IntegerType.\`;
      assertFhirType<IntegerType>(element, IntegerType, optErrMsg);
      this.sequence = element;
    } else {
      this.sequence = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`sequence\` property exists and has a value; \`false\` otherwise
   */
  public hasSequenceElement(): boolean {
    return isDefined<IntegerType>(this.sequence) && !this.sequence.isEmpty();
  }

  /**
   * @returns the \`sequence\` property value as a fhirInteger if defined; else undefined
   */
  public getSequence(): fhirInteger | undefined {
    return this.sequence?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`sequence\` property.
   *
   * @param value - the \`sequence\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSequence(value: fhirInteger | undefined): this {
    if (isDefined<fhirInteger>(value)) {
      const optErrMsg = \`Invalid Dosage.sequence (\${String(value)})\`;
      this.sequence = new IntegerType(parseFhirPrimitiveData(value, fhirIntegerSchema, optErrMsg));
    } else {
      this.sequence = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`sequence\` property exists and has a value; \`false\` otherwise
   */
  public hasSequence(): boolean {
    return this.hasSequenceElement();
  }

  /**
   * @returns the \`text\` property value as a StringType object if defined; else an empty StringType object
   */
  public getTextElement(): StringType {
    return this.text ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`text\` property.
   *
   * @param element - the \`text\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTextElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Dosage.text; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.text = element;
    } else {
      this.text = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`text\` property exists and has a value; \`false\` otherwise
   */
  public hasTextElement(): boolean {
    return isDefined<StringType>(this.text) && !this.text.isEmpty();
  }

  /**
   * @returns the \`text\` property value as a fhirString if defined; else undefined
   */
  public getText(): fhirString | undefined {
    return this.text?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`text\` property.
   *
   * @param value - the \`text\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setText(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Dosage.text (\${String(value)})\`;
      this.text = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.text = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`text\` property exists and has a value; \`false\` otherwise
   */
  public hasText(): boolean {
    return this.hasTextElement();
  }

  /**
   * @returns the \`additionalInstruction\` property value as a CodeableConcept array
   */
  public getAdditionalInstruction(): CodeableConcept[] {
    return this.additionalInstruction ?? ([] as CodeableConcept[]);
  }

  /**
   * Assigns the provided CodeableConcept array value to the \`additionalInstruction\` property.
   *
   * @param value - the \`additionalInstruction\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setAdditionalInstruction(value: CodeableConcept[] | undefined): this {
    if (isDefinedList<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Dosage.additionalInstruction; Provided value array has an element that is not an instance of CodeableConcept.\`;
      assertFhirTypeList<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.additionalInstruction = value;
    } else {
      this.additionalInstruction = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeableConcept value to the \`additionalInstruction\` array property.
   *
   * @param value - the \`additionalInstruction\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addAdditionalInstruction(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Dosage.additionalInstruction; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.initAdditionalInstruction();
      this.additionalInstruction?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`additionalInstruction\` property exists and has a value; \`false\` otherwise
   */
  public hasAdditionalInstruction(): boolean {
    return isDefinedList<CodeableConcept>(this.additionalInstruction) && this.additionalInstruction.some((item: CodeableConcept) => !item.isEmpty());
  }

  /**
   * Initialize the \`additionalInstruction\` property
   */
  private initAdditionalInstruction(): void {
    if(!this.hasAdditionalInstruction()) {
      this.additionalInstruction = [] as CodeableConcept[];
    }
  }

  /**
   * @returns the \`patientInstruction\` property value as a StringType object if defined; else an empty StringType object
   */
  public getPatientInstructionElement(): StringType {
    return this.patientInstruction ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`patientInstruction\` property.
   *
   * @param element - the \`patientInstruction\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPatientInstructionElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Dosage.patientInstruction; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.patientInstruction = element;
    } else {
      this.patientInstruction = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`patientInstruction\` property exists and has a value; \`false\` otherwise
   */
  public hasPatientInstructionElement(): boolean {
    return isDefined<StringType>(this.patientInstruction) && !this.patientInstruction.isEmpty();
  }

  /**
   * @returns the \`patientInstruction\` property value as a fhirString if defined; else undefined
   */
  public getPatientInstruction(): fhirString | undefined {
    return this.patientInstruction?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`patientInstruction\` property.
   *
   * @param value - the \`patientInstruction\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPatientInstruction(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Dosage.patientInstruction (\${String(value)})\`;
      this.patientInstruction = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.patientInstruction = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`patientInstruction\` property exists and has a value; \`false\` otherwise
   */
  public hasPatientInstruction(): boolean {
    return this.hasPatientInstructionElement();
  }

  /**
   * @returns the \`timing\` property value as a Timing object if defined; else an empty Timing object
   */
  public getTiming(): Timing {
    return this.timing ?? new Timing();
  }

  /**
   * Assigns the provided Timing object value to the \`timing\` property.
   *
   * @param value - the \`timing\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setTiming(value: Timing | undefined): this {
    if (isDefined<Timing>(value)) {
      const optErrMsg = \`Invalid Dosage.timing; Provided element is not an instance of Timing.\`;
      assertFhirType<Timing>(value, Timing, optErrMsg);
      this.timing = value;
    } else {
      this.timing = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`timing\` property exists and has a value; \`false\` otherwise
   */
  public hasTiming(): boolean {
    return isDefined<Timing>(this.timing) && !this.timing.isEmpty();
  }

  /**
   * @returns the \`asNeeded\` property value as a DataType object if defined; else undefined
   */
  public getAsNeeded(): IDataType | undefined {
    return this.asNeeded;
  }

  /**
   * Assigns the provided DataType object value to the \`asNeeded\` property.
   *
   * @decorator \`@ChoiceDataTypes('Dosage.asNeeded[x]')\`
   *
   * @param value - the \`asNeeded\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  @ChoiceDataTypes('Dosage.asNeeded[x]')
  public setAsNeeded(value: IDataType | undefined): this {
    if (isDefined<IDataType>(value)) {
      // assertFhirType<IDataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.asNeeded = value;
    } else {
      this.asNeeded = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`asNeeded\` property exists and has a value; \`false\` otherwise
   */
  public hasAsNeeded(): boolean {
    return isDefined<IDataType>(this.asNeeded) && !this.asNeeded.isEmpty();
  }

  // *** NOTE ***
  // Following choice datatype-specific "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the \`asNeeded\` property value as a BooleanType object if defined; else undefined
   */
  public getAsNeededBooleanType(): BooleanType | undefined {
    if (!isDefined<IDataType | undefined>(this.asNeeded)) {
      return undefined;
    }
    if (!(this.asNeeded instanceof BooleanType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Dosage.asNeeded[x]: Expected BooleanType but encountered \${this.asNeeded.fhirType()}\`,
      );
    }
    return this.asNeeded;
  }

  /**
   * @returns \`true\` if the \`asNeeded\` property exists as a BooleanType and has a value; \`false\` otherwise
   */
  public hasAsNeededBooleanType(): boolean {
    return this.hasAsNeeded() && this.asNeeded instanceof BooleanType;
  }

  /**
   * @returns the \`asNeeded\` property value as a CodeableConcept object if defined; else undefined
   */
  public getAsNeededCodeableConcept(): CodeableConcept | undefined {
    if (!isDefined<IDataType | undefined>(this.asNeeded)) {
      return undefined;
    }
    if (!(this.asNeeded instanceof CodeableConcept)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Dosage.asNeeded[x]: Expected CodeableConcept but encountered \${this.asNeeded.fhirType()}\`,
      );
    }
    return this.asNeeded;
  }

  /**
   * @returns \`true\` if the \`asNeeded\` property exists as a CodeableConcept and has a value; \`false\` otherwise
   */
  public hasAsNeededCodeableConcept(): boolean {
    return this.hasAsNeeded() && this.asNeeded instanceof CodeableConcept;
  }

  // End of choice datatype-specific "get"/"has" methods

  /**
   * @returns the \`site\` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getSite(): CodeableConcept {
    return this.site ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Site object value to the \`site\` property.
   *
   * @param value - the \`site\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setSite(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Dosage.site; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.site = value;
    } else {
      this.site = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`site\` property exists and has a value; \`false\` otherwise
   */
  public hasSite(): boolean {
    return isDefined<CodeableConcept>(this.site) && !this.site.isEmpty();
  }

  /**
   * @returns the \`route\` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getRoute(): CodeableConcept {
    return this.route ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Route object value to the \`route\` property.
   *
   * @param value - the \`route\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setRoute(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Dosage.route; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.route = value;
    } else {
      this.route = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`route\` property exists and has a value; \`false\` otherwise
   */
  public hasRoute(): boolean {
    return isDefined<CodeableConcept>(this.route) && !this.route.isEmpty();
  }

  /**
   * @returns the \`method\` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getMethod(): CodeableConcept {
    return this.method ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Method object value to the \`method\` property.
   *
   * @param value - the \`method\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setMethod(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Dosage.method; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.method = value;
    } else {
      this.method = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`method\` property exists and has a value; \`false\` otherwise
   */
  public hasMethod(): boolean {
    return isDefined<CodeableConcept>(this.method) && !this.method.isEmpty();
  }

  /**
   * @returns the \`doseAndRate\` property value as a DosageDoseAndRateComponent array
   */
  public getDoseAndRate(): DosageDoseAndRateComponent[] {
    return this.doseAndRate ?? ([] as DosageDoseAndRateComponent[]);
  }

  /**
   * Assigns the provided DosageDoseAndRateComponent array value to the \`doseAndRate\` property.
   *
   * @param value - the \`doseAndRate\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setDoseAndRate(value: DosageDoseAndRateComponent[] | undefined): this {
    if (isDefinedList<DosageDoseAndRateComponent>(value)) {
      const optErrMsg = \`Invalid Dosage.doseAndRate; Provided value array has an element that is not an instance of DosageDoseAndRateComponent.\`;
      assertFhirTypeList<DosageDoseAndRateComponent>(value, DosageDoseAndRateComponent, optErrMsg);
      this.doseAndRate = value;
    } else {
      this.doseAndRate = undefined;
    }
    return this;
  }

  /**
   * Add the provided DosageDoseAndRateComponent value to the \`doseAndRate\` array property.
   *
   * @param value - the \`doseAndRate\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addDoseAndRate(value: DosageDoseAndRateComponent | undefined): this {
    if (isDefined<DosageDoseAndRateComponent>(value)) {
      const optErrMsg = \`Invalid Dosage.doseAndRate; Provided element is not an instance of DosageDoseAndRateComponent.\`;
      assertFhirType<DosageDoseAndRateComponent>(value, DosageDoseAndRateComponent, optErrMsg);
      this.initDoseAndRate();
      this.doseAndRate?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`doseAndRate\` property exists and has a value; \`false\` otherwise
   */
  public hasDoseAndRate(): boolean {
    return isDefinedList<DosageDoseAndRateComponent>(this.doseAndRate) && this.doseAndRate.some((item: DosageDoseAndRateComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`doseAndRate\` property
   */
  private initDoseAndRate(): void {
    if(!this.hasDoseAndRate()) {
      this.doseAndRate = [] as DosageDoseAndRateComponent[];
    }
  }

  /**
   * @returns the \`maxDosePerPeriod\` property value as a Ratio object if defined; else an empty Ratio object
   */
  public getMaxDosePerPeriod(): Ratio {
    return this.maxDosePerPeriod ?? new Ratio();
  }

  /**
   * Assigns the provided MaxDosePerPeriod object value to the \`maxDosePerPeriod\` property.
   *
   * @param value - the \`maxDosePerPeriod\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setMaxDosePerPeriod(value: Ratio | undefined): this {
    if (isDefined<Ratio>(value)) {
      const optErrMsg = \`Invalid Dosage.maxDosePerPeriod; Provided element is not an instance of Ratio.\`;
      assertFhirType<Ratio>(value, Ratio, optErrMsg);
      this.maxDosePerPeriod = value;
    } else {
      this.maxDosePerPeriod = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`maxDosePerPeriod\` property exists and has a value; \`false\` otherwise
   */
  public hasMaxDosePerPeriod(): boolean {
    return isDefined<Ratio>(this.maxDosePerPeriod) && !this.maxDosePerPeriod.isEmpty();
  }

  /**
   * @returns the \`maxDosePerAdministration\` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getMaxDosePerAdministration(): Quantity {
    return this.maxDosePerAdministration ?? new Quantity();
  }

  /**
   * Assigns the provided MaxDosePerAdministration object value to the \`maxDosePerAdministration\` property.
   *
   * @param value - the \`maxDosePerAdministration\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setMaxDosePerAdministration(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = \`Invalid Dosage.maxDosePerAdministration; Provided element is not an instance of Quantity.\`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.maxDosePerAdministration = value;
    } else {
      this.maxDosePerAdministration = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`maxDosePerAdministration\` property exists and has a value; \`false\` otherwise
   */
  public hasMaxDosePerAdministration(): boolean {
    return isDefined<Quantity>(this.maxDosePerAdministration) && !this.maxDosePerAdministration.isEmpty();
  }

  /**
   * @returns the \`maxDosePerLifetime\` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getMaxDosePerLifetime(): Quantity {
    return this.maxDosePerLifetime ?? new Quantity();
  }

  /**
   * Assigns the provided MaxDosePerLifetime object value to the \`maxDosePerLifetime\` property.
   *
   * @param value - the \`maxDosePerLifetime\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setMaxDosePerLifetime(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = \`Invalid Dosage.maxDosePerLifetime; Provided element is not an instance of Quantity.\`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.maxDosePerLifetime = value;
    } else {
      this.maxDosePerLifetime = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`maxDosePerLifetime\` property exists and has a value; \`false\` otherwise
   */
  public hasMaxDosePerLifetime(): boolean {
    return isDefined<Quantity>(this.maxDosePerLifetime) && !this.maxDosePerLifetime.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Dosage';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.sequence,
      this.text,
      this.additionalInstruction,
      this.patientInstruction,
      this.timing,
      this.asNeeded,
      this.site,
      this.route,
      this.method,
      this.doseAndRate,
      this.maxDosePerPeriod,
      this.maxDosePerAdministration,
      this.maxDosePerLifetime,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Dosage {
    const dest = new Dosage();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Dosage): void {
    super.copyValues(dest);
    dest.sequence = this.sequence?.copy();
    dest.text = this.text?.copy();
    const additionalInstructionList = copyListValues<CodeableConcept>(this.additionalInstruction);
    dest.additionalInstruction = additionalInstructionList.length === 0 ? undefined : additionalInstructionList;
    dest.patientInstruction = this.patientInstruction?.copy();
    dest.timing = this.timing?.copy();
    dest.asNeeded = this.asNeeded?.copy() as IDataType;
    dest.site = this.site?.copy();
    dest.route = this.route?.copy();
    dest.method = this.method?.copy();
    const doseAndRateList = copyListValues<DosageDoseAndRateComponent>(this.doseAndRate);
    dest.doseAndRate = doseAndRateList.length === 0 ? undefined : doseAndRateList;
    dest.maxDosePerPeriod = this.maxDosePerPeriod?.copy();
    dest.maxDosePerAdministration = this.maxDosePerAdministration?.copy();
    dest.maxDosePerLifetime = this.maxDosePerLifetime?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', \`UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasSequenceElement()) {
      setFhirPrimitiveJson<fhirInteger>(this.getSequenceElement(), 'sequence', jsonObj);
    }

    if (this.hasTextElement()) {
      setFhirPrimitiveJson<fhirString>(this.getTextElement(), 'text', jsonObj);
    }

    if (this.hasAdditionalInstruction()) {
      setFhirComplexListJson(this.getAdditionalInstruction(), 'additionalInstruction', jsonObj);
    }

    if (this.hasPatientInstructionElement()) {
      setFhirPrimitiveJson<fhirString>(this.getPatientInstructionElement(), 'patientInstruction', jsonObj);
    }

    if (this.hasTiming()) {
      setFhirComplexJson(this.getTiming(), 'timing', jsonObj);
    }

    if (this.hasAsNeeded()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getAsNeeded()!, 'asNeeded', jsonObj);
    }

    if (this.hasSite()) {
      setFhirComplexJson(this.getSite(), 'site', jsonObj);
    }

    if (this.hasRoute()) {
      setFhirComplexJson(this.getRoute(), 'route', jsonObj);
    }

    if (this.hasMethod()) {
      setFhirComplexJson(this.getMethod(), 'method', jsonObj);
    }

    if (this.hasDoseAndRate()) {
      setFhirComplexListJson(this.getDoseAndRate(), 'doseAndRate', jsonObj);
    }

    if (this.hasMaxDosePerPeriod()) {
      setFhirComplexJson(this.getMaxDosePerPeriod(), 'maxDosePerPeriod', jsonObj);
    }

    if (this.hasMaxDosePerAdministration()) {
      setFhirComplexJson(this.getMaxDosePerAdministration(), 'maxDosePerAdministration', jsonObj);
    }

    if (this.hasMaxDosePerLifetime()) {
      setFhirComplexJson(this.getMaxDosePerLifetime(), 'maxDosePerLifetime', jsonObj);
    }

    return jsonObj;
  }
}
/**
 * DosageDoseAndRateComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Amount of medication administered
 * - **Definition:** The amount of medication administered.
 *
 * @category Data Models: ComplexType
 * @see [FHIR Dosage](http://hl7.org/fhir/StructureDefinition/Dosage)
 */
/* istanbul ignore next */ export class DosageDoseAndRateComponent extends DataType implements IDataType {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`DosageDoseAndRateComponent\` JSON to instantiate the DosageDoseAndRateComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`DosageDoseAndRateComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to DosageDoseAndRateComponent
   * @returns DosageDoseAndRateComponent data model or undefined for \`DosageDoseAndRateComponent\`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): DosageDoseAndRateComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'DosageDoseAndRateComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new DosageDoseAndRateComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';

    const classMetadata: DecoratorMetadataObject | null = DosageDoseAndRateComponent[Symbol.metadata];
    const errorMessage = \`DecoratorMetadataObject does not exist for DosageDoseAndRateComponent\`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    fieldName = 'type';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = CodeableConcept.parse(classJsonObj[fieldName]!, sourceField);
      instance.setType(datatype);
    }

    fieldName = 'dose[x]';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const dose: IDataType | undefined = fhirParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setDose(dose);

    fieldName = 'rate[x]';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const rate: IDataType | undefined = fhirParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setRate(rate);

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Dosage.doseAndRate.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The kind of dose or rate specified
   * - **Definition:** The kind of dose or rate specified, for example, ordered or calculated.
   * - **Requirements:** If the type is not populated, assume to be "ordered".
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private type_?: CodeableConcept | undefined;

  /**
   * Dosage.doseAndRate.dose[x] Element
   *
   * @decorator \`@ChoiceDataTypesMeta('Dosage.doseAndRate.dose[x]', ['Range','Quantity',]\`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Amount of medication per dose
   * - **Definition:** Amount of medication per dose.
   * - **Comment:** Note that this specifies the quantity of the specified medication, not the quantity for each active ingredient(s). Each ingredient amount can be communicated in the Medication resource. For example, if one wants to communicate that a tablet was 375 mg, where the dose was one tablet, you can use the Medication resource to document that the tablet was comprised of 375 mg of drug XYZ. Alternatively if the dose was 375 mg, then you may only need to use the Medication resource to indicate this was a tablet. If the example were an IV such as dopamine and you wanted to communicate that 400mg of dopamine was mixed in 500 ml of some IV solution, then this would all be communicated in the Medication resource. If the administration is not intended to be instantaneous (rate is present or timing has a duration), this can be specified to convey the total amount to be administered over the period of time as indicated by the schedule e.g. 500 ml in dose, with timing used to convey that this should be done over 4 hours.
   * - **Requirements:** The amount of therapeutic or other substance given at one administration event.
   * - **FHIR Types:**
   *     'Range',
   *     'Quantity',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('Dosage.doseAndRate.dose[x]',[
    'Range',
    'Quantity',
  ])
  private dose?: IDataType | undefined;

  /**
   * Dosage.doseAndRate.rate[x] Element
   *
   * @decorator \`@ChoiceDataTypesMeta('Dosage.doseAndRate.rate[x]', ['Ratio','Range','Quantity',]\`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Amount of medication per unit of time
   * - **Definition:** Amount of medication per unit of time.
   * - **Comment:** It is possible to supply both a rate and a doseQuantity to provide full details about how the medication is to be administered and supplied. If the rate is intended to change over time, depending on local rules/regulations, each change should be captured as a new version of the MedicationRequest with an updated rate, or captured with a new MedicationRequest with the new rate. It is possible to specify a rate over time (for example, 100 ml/hour) using either the rateRatio and rateQuantity.  The rateQuantity approach requires systems to have the capability to parse UCUM grammer where ml/hour is included rather than a specific ratio where the time is specified as the denominator.  Where a rate such as 500ml over 2 hours is specified, the use of rateRatio may be more semantically correct than specifying using a rateQuantity of 250 mg/hour.
   * - **Requirements:** Identifies the speed with which the medication was or will be introduced into the patient. Typically the rate for an infusion e.g. 100 ml per 1 hour or 100 ml/hr.  May also be expressed as a rate per unit of time e.g. 500 ml per 2 hours.   Other examples: 200 mcg/min or 200 mcg/1 minute; 1 liter/8 hours.  Sometimes, a rate can imply duration when expressed as total volume / duration (e.g.  500mL/2 hours implies a duration of 2 hours).  However, when rate doesn\\'t imply duration (e.g. 250mL/hour), then the timing.repeat.duration is needed to convey the infuse over time period.
   * - **FHIR Types:**
   *     'Ratio',
   *     'Range',
   *     'Quantity',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('Dosage.doseAndRate.rate[x]',[
    'Ratio',
    'Range',
    'Quantity',
  ])
  private rate?: IDataType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`type_\` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getType(): CodeableConcept {
    return this.type_ ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Type object value to the \`type_\` property.
   *
   * @param value - the \`type_\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setType(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Dosage.doseAndRate.type; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.type_ = value;
    } else {
      this.type_ = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasType(): boolean {
    return isDefined<CodeableConcept>(this.type_) && !this.type_.isEmpty();
  }

  /**
   * @returns the \`dose\` property value as a DataType object if defined; else undefined
   */
  public getDose(): IDataType | undefined {
    return this.dose;
  }

  /**
   * Assigns the provided DataType object value to the \`dose\` property.
   *
   * @decorator \`@ChoiceDataTypes('Dosage.doseAndRate.dose[x]')\`
   *
   * @param value - the \`dose\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  @ChoiceDataTypes('Dosage.doseAndRate.dose[x]')
  public setDose(value: IDataType | undefined): this {
    if (isDefined<IDataType>(value)) {
      // assertFhirType<IDataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.dose = value;
    } else {
      this.dose = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`dose\` property exists and has a value; \`false\` otherwise
   */
  public hasDose(): boolean {
    return isDefined<IDataType>(this.dose) && !this.dose.isEmpty();
  }

  // *** NOTE ***
  // Following choice datatype-specific "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the \`dose\` property value as a Range object if defined; else undefined
   */
  public getDoseRange(): Range | undefined {
    if (!isDefined<IDataType | undefined>(this.dose)) {
      return undefined;
    }
    if (!(this.dose instanceof Range)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Dosage.doseAndRate.dose[x]: Expected Range but encountered \${this.dose.fhirType()}\`,
      );
    }
    return this.dose;
  }

  /**
   * @returns \`true\` if the \`dose\` property exists as a Range and has a value; \`false\` otherwise
   */
  public hasDoseRange(): boolean {
    return this.hasDose() && this.dose instanceof Range;
  }

  /**
   * @returns the \`dose\` property value as a Quantity object if defined; else undefined
   */
  public getDoseQuantity(): Quantity | undefined {
    if (!isDefined<IDataType | undefined>(this.dose)) {
      return undefined;
    }
    if (!(this.dose instanceof Quantity)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Dosage.doseAndRate.dose[x]: Expected Quantity but encountered \${this.dose.fhirType()}\`,
      );
    }
    return this.dose;
  }

  /**
   * @returns \`true\` if the \`dose\` property exists as a Quantity and has a value; \`false\` otherwise
   */
  public hasDoseQuantity(): boolean {
    return this.hasDose() && this.dose instanceof Quantity;
  }

  // End of choice datatype-specific "get"/"has" methods

  /**
   * @returns the \`rate\` property value as a DataType object if defined; else undefined
   */
  public getRate(): IDataType | undefined {
    return this.rate;
  }

  /**
   * Assigns the provided DataType object value to the \`rate\` property.
   *
   * @decorator \`@ChoiceDataTypes('Dosage.doseAndRate.rate[x]')\`
   *
   * @param value - the \`rate\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  @ChoiceDataTypes('Dosage.doseAndRate.rate[x]')
  public setRate(value: IDataType | undefined): this {
    if (isDefined<IDataType>(value)) {
      // assertFhirType<IDataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.rate = value;
    } else {
      this.rate = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`rate\` property exists and has a value; \`false\` otherwise
   */
  public hasRate(): boolean {
    return isDefined<IDataType>(this.rate) && !this.rate.isEmpty();
  }

  // *** NOTE ***
  // Following choice datatype-specific "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the \`rate\` property value as a Ratio object if defined; else undefined
   */
  public getRateRatio(): Ratio | undefined {
    if (!isDefined<IDataType | undefined>(this.rate)) {
      return undefined;
    }
    if (!(this.rate instanceof Ratio)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Dosage.doseAndRate.rate[x]: Expected Ratio but encountered \${this.rate.fhirType()}\`,
      );
    }
    return this.rate;
  }

  /**
   * @returns \`true\` if the \`rate\` property exists as a Ratio and has a value; \`false\` otherwise
   */
  public hasRateRatio(): boolean {
    return this.hasRate() && this.rate instanceof Ratio;
  }

  /**
   * @returns the \`rate\` property value as a Range object if defined; else undefined
   */
  public getRateRange(): Range | undefined {
    if (!isDefined<IDataType | undefined>(this.rate)) {
      return undefined;
    }
    if (!(this.rate instanceof Range)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Dosage.doseAndRate.rate[x]: Expected Range but encountered \${this.rate.fhirType()}\`,
      );
    }
    return this.rate;
  }

  /**
   * @returns \`true\` if the \`rate\` property exists as a Range and has a value; \`false\` otherwise
   */
  public hasRateRange(): boolean {
    return this.hasRate() && this.rate instanceof Range;
  }

  /**
   * @returns the \`rate\` property value as a Quantity object if defined; else undefined
   */
  public getRateQuantity(): Quantity | undefined {
    if (!isDefined<IDataType | undefined>(this.rate)) {
      return undefined;
    }
    if (!(this.rate instanceof Quantity)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Dosage.doseAndRate.rate[x]: Expected Quantity but encountered \${this.rate.fhirType()}\`,
      );
    }
    return this.rate;
  }

  /**
   * @returns \`true\` if the \`rate\` property exists as a Quantity and has a value; \`false\` otherwise
   */
  public hasRateQuantity(): boolean {
    return this.hasRate() && this.rate instanceof Quantity;
  }

  // End of choice datatype-specific "get"/"has" methods

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Dosage.doseAndRate';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.type_,
      this.dose,
      this.rate,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): DosageDoseAndRateComponent {
    const dest = new DosageDoseAndRateComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: DosageDoseAndRateComponent): void {
    super.copyValues(dest);
    dest.type_ = this.type_?.copy();
    dest.dose = this.dose?.copy() as IDataType;
    dest.rate = this.rate?.copy() as IDataType;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', \`UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasType()) {
      setFhirComplexJson(this.getType(), 'type', jsonObj);
    }

    if (this.hasDose()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getDose()!, 'dose', jsonObj);
    }

    if (this.hasRate()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getRate()!, 'rate', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * Duration Class
 *
 * @remarks
 * Base StructureDefinition for Duration Type: A length of time.
 *
 * **FHIR Specification**
 * - **Short:** A length of time
 * - **Definition:** A length of time.
 * - **Comment:** The context of use may frequently define what kind of quantity this is and therefore what kind of units can be used. The context of use may also restrict the values for the comparator.
 * - **FHIR Version:** 4.0.1
 *
 * @category Data Models: ComplexType
 * @see [FHIR Duration](http://hl7.org/fhir/StructureDefinition/Duration)
 */
/* istanbul ignore next */ export class Duration extends DataType implements IDataType {
  constructor() {
    super();

    this.quantityComparatorEnum = new QuantityComparatorEnum();
  }

  /**
   * Parse the provided \`Duration\` JSON to instantiate the Duration data model.
   *
   * @param sourceJson - JSON representing FHIR \`Duration\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Duration
   * @returns Duration data model or undefined for \`Duration\`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Duration | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Duration';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Duration();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'value';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setValueElement(datatype);
    }

    fieldName = 'comparator';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setComparatorElement(datatype);
    }

    fieldName = 'unit';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setUnitElement(datatype);
    }

    fieldName = 'system';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = fhirParser.parseUriType(dtJson, dtSiblingJson);
      instance.setSystemElement(datatype);
    }

    fieldName = 'code';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setCodeElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Duration.value Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Numerical value (with implicit precision)
   * - **Definition:** The value of the measured amount. The value includes an implicit precision in the presentation of the value.
   * - **Comment:** The implicit precision in the value should always be honored. Monetary values have their own rules for handling precision (refer to standard accounting text books).
   * - **Requirements:** Precision is handled implicitly in almost all cases of measurement.
   * - **FHIR Type:** \`decimal\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private value?: DecimalType | undefined;

  /**
   * FHIR CodeSystem: QuantityComparator
   *
   * @see {@link QuantityComparatorEnum }
   */
  private readonly quantityComparatorEnum: QuantityComparatorEnum;

  /**
   * Duration.comparator Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** < | <= | >= | > - how to understand the value
   * - **Definition:** How the value should be understood and represented - whether the actual value is greater or less than the stated value due to measurement issues; e.g. if the comparator is "<" , then the real value is < stated value.
   * - **Requirements:** Need a framework for handling measures where the value is <5ug/L or >400mg/L due to the limitations of measuring methodology.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** true
   * - **isModifierReason:** This is labeled as &quot;Is Modifier&quot; because the comparator modifies the interpretation of the value significantly. If there is no comparator, then there is no modification of the value
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  private comparator?: EnumCodeType | undefined;

  /**
   * Duration.unit Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Unit representation
   * - **Definition:** A human-readable form of the unit.
   * - **Requirements:** There are many representations for units of measure and in many contexts, particular representations are fixed and required. I.e. mcg for micrograms.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private unit?: StringType | undefined;

  /**
   * Duration.system Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** System that defines coded unit form
   * - **Definition:** The identification of the system that provides the coded form of the unit.
   * - **Requirements:** Need to know the system that defines the coded form of the unit.
   * - **FHIR Type:** \`uri\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private system?: UriType | undefined;

  /**
   * Duration.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Coded form of the unit
   * - **Definition:** A computer processable form of the unit in some unit representation system.
   * - **Comment:** The preferred system is UCUM, but SNOMED CT can also be used (for customary units) or ISO 4217 for currency.  The context of use may additionally require a code from a particular system.
   * - **Requirements:** Need a computable form of the unit that is fixed across all forms. UCUM provides this for quantities, but SNOMED CT provides many units of interest.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code?: CodeType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`value\` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getValueElement(): DecimalType {
    return this.value ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`value\` property.
   *
   * @param element - the \`value\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValueElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = \`Invalid Duration.value; Provided element is not an instance of DecimalType.\`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.value = element;
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`value\` property exists and has a value; \`false\` otherwise
   */
  public hasValueElement(): boolean {
    return isDefined<DecimalType>(this.value) && !this.value.isEmpty();
  }

  /**
   * @returns the \`value\` property value as a fhirDecimal if defined; else undefined
   */
  public getValue(): fhirDecimal | undefined {
    return this.value?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`value\` property.
   *
   * @param value - the \`value\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValue(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = \`Invalid Duration.value (\${String(value)})\`;
      this.value = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`value\` property exists and has a value; \`false\` otherwise
   */
  public hasValue(): boolean {
    return this.hasValueElement();
  }

  /**
   * @returns the \`comparator\` property value as a EnumCodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public getComparatorEnumType(): EnumCodeType | undefined {
    return this.comparator;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`comparator\` property.
   *
   * @param enumType - the \`comparator\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code values
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public setComparatorEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid Duration.comparator';
      assertEnumCodeType<QuantityComparatorEnum>(enumType, QuantityComparatorEnum, errMsgPrefix);
      this.comparator = enumType;
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`comparator\` property exists and has a value; \`false\` otherwise
   */
  public hasComparatorEnumType(): boolean {
    return isDefined<EnumCodeType>(this.comparator) && !this.comparator.isEmpty() && this.comparator.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`comparator\` property value as a CodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public getComparatorElement(): CodeType | undefined {
    if (this.comparator === undefined) {
      return undefined;
    }
    return this.comparator as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`comparator\` property.
   *
   * @param element - the \`comparator\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public setComparatorElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Duration.comparator; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.comparator = new EnumCodeType(element, this.quantityComparatorEnum);
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`comparator\` property exists and has a value; \`false\` otherwise
   */
  public hasComparatorElement(): boolean {
    return this.hasComparatorEnumType();
  }

  /**
   * @returns the \`comparator\` property value as a fhirCode if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public getComparator(): fhirCode | undefined {
    if (this.comparator === undefined) {
      return undefined;
    }
    return this.comparator.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`comparator\` property.
   *
   * @param value - the \`comparator\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public setComparator(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Duration.comparator; Provided value is not an instance of fhirCode.\`;
      this.comparator = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.quantityComparatorEnum);
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`comparator\` property exists and has a value; \`false\` otherwise
   */
  public hasComparator(): boolean {
    return this.hasComparatorEnumType();
  }

  /**
   * @returns the \`unit\` property value as a StringType object if defined; else an empty StringType object
   */
  public getUnitElement(): StringType {
    return this.unit ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`unit\` property.
   *
   * @param element - the \`unit\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUnitElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Duration.unit; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.unit = element;
    } else {
      this.unit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`unit\` property exists and has a value; \`false\` otherwise
   */
  public hasUnitElement(): boolean {
    return isDefined<StringType>(this.unit) && !this.unit.isEmpty();
  }

  /**
   * @returns the \`unit\` property value as a fhirString if defined; else undefined
   */
  public getUnit(): fhirString | undefined {
    return this.unit?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`unit\` property.
   *
   * @param value - the \`unit\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUnit(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Duration.unit (\${String(value)})\`;
      this.unit = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.unit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`unit\` property exists and has a value; \`false\` otherwise
   */
  public hasUnit(): boolean {
    return this.hasUnitElement();
  }

  /**
   * @returns the \`system\` property value as a UriType object if defined; else an empty UriType object
   */
  public getSystemElement(): UriType {
    return this.system ?? new UriType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`system\` property.
   *
   * @param element - the \`system\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSystemElement(element: UriType | undefined): this {
    if (isDefined<UriType>(element)) {
      const optErrMsg = \`Invalid Duration.system; Provided element is not an instance of UriType.\`;
      assertFhirType<UriType>(element, UriType, optErrMsg);
      this.system = element;
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`system\` property exists and has a value; \`false\` otherwise
   */
  public hasSystemElement(): boolean {
    return isDefined<UriType>(this.system) && !this.system.isEmpty();
  }

  /**
   * @returns the \`system\` property value as a fhirUri if defined; else undefined
   */
  public getSystem(): fhirUri | undefined {
    return this.system?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`system\` property.
   *
   * @param value - the \`system\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSystem(value: fhirUri | undefined): this {
    if (isDefined<fhirUri>(value)) {
      const optErrMsg = \`Invalid Duration.system (\${String(value)})\`;
      this.system = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`system\` property exists and has a value; \`false\` otherwise
   */
  public hasSystem(): boolean {
    return this.hasSystemElement();
  }

  /**
   * @returns the \`code\` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getCodeElement(): CodeType {
    return this.code ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`code\` property.
   *
   * @param element - the \`code\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCodeElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Duration.code; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.code = element;
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`code\` property exists and has a value; \`false\` otherwise
   */
  public hasCodeElement(): boolean {
    return isDefined<CodeType>(this.code) && !this.code.isEmpty();
  }

  /**
   * @returns the \`code\` property value as a fhirCode if defined; else undefined
   */
  public getCode(): fhirCode | undefined {
    return this.code?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`code\` property.
   *
   * @param value - the \`code\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCode(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Duration.code (\${String(value)})\`;
      this.code = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`code\` property exists and has a value; \`false\` otherwise
   */
  public hasCode(): boolean {
    return this.hasCodeElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Duration';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.value,
      this.comparator,
      this.unit,
      this.system,
      this.code,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Duration {
    const dest = new Duration();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Duration): void {
    super.copyValues(dest);
    dest.value = this.value?.copy();
    dest.comparator = this.comparator?.copy();
    dest.unit = this.unit?.copy();
    dest.system = this.system?.copy();
    dest.code = this.code?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', \`UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasValueElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getValueElement(), 'value', jsonObj);
    }

    if (this.hasComparatorElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getComparatorElement()!, 'comparator', jsonObj);
    }

    if (this.hasUnitElement()) {
      setFhirPrimitiveJson<fhirString>(this.getUnitElement(), 'unit', jsonObj);
    }

    if (this.hasSystemElement()) {
      setFhirPrimitiveJson<fhirUri>(this.getSystemElement(), 'system', jsonObj);
    }

    if (this.hasCodeElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getCodeElement(), 'code', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * Expression Class
 *
 * @remarks
 * Base StructureDefinition for Expression Type: A expression that is evaluated in a specified context and returns a value. The context of use of the expression must specify the context in which the expression is evaluated, and how the result of the expression is used.
 *
 * **FHIR Specification**
 * - **Short:** An expression that can be used to generate a value
 * - **Definition:** A expression that is evaluated in a specified context and returns a value. The context of use of the expression must specify the context in which the expression is evaluated, and how the result of the expression is used.
 * - **FHIR Version:** 4.0.1
 *
 * @category Data Models: ComplexType
 * @see [FHIR Expression](http://hl7.org/fhir/StructureDefinition/Expression)
 */
/* istanbul ignore next */ export class Expression extends DataType implements IDataType {
  constructor(language: CodeType | fhirCode | null = null) {
    super();

    this.language = null;
    if (isDefined<CodeType | fhirCode>(language)) {
      if (language instanceof PrimitiveType) {
        this.setLanguageElement(language);
      } else {
        this.setLanguage(language);
      }
    }
  }

  /**
   * Parse the provided \`Expression\` JSON to instantiate the Expression data model.
   *
   * @param sourceJson - JSON representing FHIR \`Expression\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Expression
   * @returns Expression data model or undefined for \`Expression\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Expression | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Expression';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Expression();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'description';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setDescriptionElement(datatype);
    }

    fieldName = 'name';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: IdType | undefined = fhirParser.parseIdType(dtJson, dtSiblingJson);
      instance.setNameElement(datatype);
    }

    fieldName = 'language';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setLanguageElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'expression';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setExpressionElement(datatype);
    }

    fieldName = 'reference';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = fhirParser.parseUriType(dtJson, dtSiblingJson);
      instance.setReferenceElement(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Expression.description Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Natural language description of the condition
   * - **Definition:** A brief, natural language description of the condition that effectively communicates the intended semantics.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private description?: StringType | undefined;

  /**
   * Expression.name Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Short name assigned to expression for reuse
   * - **Definition:** A short name assigned to the expression to allow for multiple reuse of the expression in the context where it is defined.
   * - **FHIR Type:** \`id\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private name?: IdType | undefined;

  /**
   * Expression.language Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** text/cql | text/fhirpath | application/x-fhir-query | etc.
   * - **Definition:** The media type of the language for the expression.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private language: CodeType | null;

  /**
   * Expression.expression Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Expression in specified language
   * - **Definition:** An expression in the specified language that returns a value.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private expression?: StringType | undefined;

  /**
   * Expression.reference Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Where the expression is found
   * - **Definition:** A URI that defines where the expression is found.
   * - **Comment:** If both a reference and an expression is found, the reference SHALL point to the same expression.
   * - **FHIR Type:** \`uri\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private reference?: UriType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`description\` property value as a StringType object if defined; else an empty StringType object
   */
  public getDescriptionElement(): StringType {
    return this.description ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`description\` property.
   *
   * @param element - the \`description\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDescriptionElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Expression.description; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.description = element;
    } else {
      this.description = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`description\` property exists and has a value; \`false\` otherwise
   */
  public hasDescriptionElement(): boolean {
    return isDefined<StringType>(this.description) && !this.description.isEmpty();
  }

  /**
   * @returns the \`description\` property value as a fhirString if defined; else undefined
   */
  public getDescription(): fhirString | undefined {
    return this.description?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`description\` property.
   *
   * @param value - the \`description\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDescription(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Expression.description (\${String(value)})\`;
      this.description = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.description = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`description\` property exists and has a value; \`false\` otherwise
   */
  public hasDescription(): boolean {
    return this.hasDescriptionElement();
  }

  /**
   * @returns the \`name\` property value as a IdType object if defined; else an empty IdType object
   */
  public getNameElement(): IdType {
    return this.name ?? new IdType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`name\` property.
   *
   * @param element - the \`name\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setNameElement(element: IdType | undefined): this {
    if (isDefined<IdType>(element)) {
      const optErrMsg = \`Invalid Expression.name; Provided element is not an instance of IdType.\`;
      assertFhirType<IdType>(element, IdType, optErrMsg);
      this.name = element;
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`name\` property exists and has a value; \`false\` otherwise
   */
  public hasNameElement(): boolean {
    return isDefined<IdType>(this.name) && !this.name.isEmpty();
  }

  /**
   * @returns the \`name\` property value as a fhirId if defined; else undefined
   */
  public getName(): fhirId | undefined {
    return this.name?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`name\` property.
   *
   * @param value - the \`name\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setName(value: fhirId | undefined): this {
    if (isDefined<fhirId>(value)) {
      const optErrMsg = \`Invalid Expression.name (\${String(value)})\`;
      this.name = new IdType(parseFhirPrimitiveData(value, fhirIdSchema, optErrMsg));
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`name\` property exists and has a value; \`false\` otherwise
   */
  public hasName(): boolean {
    return this.hasNameElement();
  }

  /**
   * @returns the \`language\` property value as a CodeType object if defined; else null
   */
  public getLanguageElement(): CodeType | null {
    return this.language;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`language\` property.
   *
   * @param element - the \`language\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLanguageElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, \`Expression.language is required\`);
    const optErrMsg = \`Invalid Expression.language; Provided value is not an instance of CodeType.\`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.language = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`language\` property exists and has a value; \`false\` otherwise
   */
  public hasLanguageElement(): boolean {
    return isDefined<CodeType>(this.language) && !this.language.isEmpty();
  }

  /**
   * @returns the \`language\` property value as a fhirCode if defined; else null
   */
  public getLanguage(): fhirCode | null {
    if (this.language?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.language.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`language\` property.
   *
   * @param value - the \`language\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLanguage(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, \`Expression.language is required\`);
    const optErrMsg = \`Invalid Expression.language (\${String(value)})\`;
    this.language = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`language\` property exists and has a value; \`false\` otherwise
   */
  public hasLanguage(): boolean {
    return this.hasLanguageElement();
  }

  /**
   * @returns the \`expression\` property value as a StringType object if defined; else an empty StringType object
   */
  public getExpressionElement(): StringType {
    return this.expression ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`expression\` property.
   *
   * @param element - the \`expression\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setExpressionElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Expression.expression; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.expression = element;
    } else {
      this.expression = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`expression\` property exists and has a value; \`false\` otherwise
   */
  public hasExpressionElement(): boolean {
    return isDefined<StringType>(this.expression) && !this.expression.isEmpty();
  }

  /**
   * @returns the \`expression\` property value as a fhirString if defined; else undefined
   */
  public getExpression(): fhirString | undefined {
    return this.expression?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`expression\` property.
   *
   * @param value - the \`expression\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setExpression(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Expression.expression (\${String(value)})\`;
      this.expression = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.expression = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`expression\` property exists and has a value; \`false\` otherwise
   */
  public hasExpression(): boolean {
    return this.hasExpressionElement();
  }

  /**
   * @returns the \`reference\` property value as a UriType object if defined; else an empty UriType object
   */
  public getReferenceElement(): UriType {
    return this.reference ?? new UriType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`reference\` property.
   *
   * @param element - the \`reference\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setReferenceElement(element: UriType | undefined): this {
    if (isDefined<UriType>(element)) {
      const optErrMsg = \`Invalid Expression.reference; Provided element is not an instance of UriType.\`;
      assertFhirType<UriType>(element, UriType, optErrMsg);
      this.reference = element;
    } else {
      this.reference = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`reference\` property exists and has a value; \`false\` otherwise
   */
  public hasReferenceElement(): boolean {
    return isDefined<UriType>(this.reference) && !this.reference.isEmpty();
  }

  /**
   * @returns the \`reference\` property value as a fhirUri if defined; else undefined
   */
  public getReference(): fhirUri | undefined {
    return this.reference?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`reference\` property.
   *
   * @param value - the \`reference\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setReference(value: fhirUri | undefined): this {
    if (isDefined<fhirUri>(value)) {
      const optErrMsg = \`Invalid Expression.reference (\${String(value)})\`;
      this.reference = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    } else {
      this.reference = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`reference\` property exists and has a value; \`false\` otherwise
   */
  public hasReference(): boolean {
    return this.hasReferenceElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Expression';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.description,
      this.name,
      this.language,
      this.expression,
      this.reference,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Expression {
    const dest = new Expression();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Expression): void {
    super.copyValues(dest);
    dest.description = this.description?.copy();
    dest.name = this.name?.copy();
    dest.language = this.language ? this.language.copy() : null;
    dest.expression = this.expression?.copy();
    dest.reference = this.reference?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', \`UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasDescriptionElement()) {
      setFhirPrimitiveJson<fhirString>(this.getDescriptionElement(), 'description', jsonObj);
    }

    if (this.hasNameElement()) {
      setFhirPrimitiveJson<fhirId>(this.getNameElement(), 'name', jsonObj);
    }

    if (this.hasLanguageElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getLanguageElement()!, 'language', jsonObj);
    } else {
      missingReqdProperties.push(\`Expression.language\`);
    }

    if (this.hasExpressionElement()) {
      setFhirPrimitiveJson<fhirString>(this.getExpressionElement(), 'expression', jsonObj);
    }

    if (this.hasReferenceElement()) {
      setFhirPrimitiveJson<fhirUri>(this.getReferenceElement(), 'reference', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

/**
 * Extension Class
 *
 * @remarks
 * Base StructureDefinition for Extension Type: Optional Extension Element - found in all resources.
 *
 * The ability to add extensions in a structured way is what keeps FHIR resources simple.
 *
 * **FHIR Specification**
 * - **Short:** Optional Extensions Element
 * - **Definition:** Optional Extension Element - found in all resources.
 * - **FHIR Version:** 4.0.1
 *
 * @category Data Models: ComplexType
 * @see [FHIR Extension](http://hl7.org/fhir/StructureDefinition/Extension)
 */
/* istanbul ignore next */ export class Extension extends CoreExtension {
  constructor(url: fhirUri | null = null, value?: IDataType) {
    super(url, value);
  }

  // *** NOTE ***
  // Following "get"/"has" methods are added for each open data type - one pair of methods for each open data type

  /**
   * @returns the \`value\` property value as a Base64BinaryType object if defined; else undefined
   */
  public getValueBase64BinaryType(): Base64BinaryType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Base64BinaryType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected Base64BinaryType but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a Base64BinaryType and has a value; \`false\` otherwise
   */
  public hasValueBase64BinaryType(): boolean {
    return this.hasValue() && this.value instanceof Base64BinaryType;
  }

  /**
   * @returns the \`value\` property value as a BooleanType object if defined; else undefined
   */
  public getValueBooleanType(): BooleanType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof BooleanType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected BooleanType but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a BooleanType and has a value; \`false\` otherwise
   */
  public hasValueBooleanType(): boolean {
    return this.hasValue() && this.value instanceof BooleanType;
  }

  /**
   * @returns the \`value\` property value as a CanonicalType object if defined; else undefined
   */
  public getValueCanonicalType(): CanonicalType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof CanonicalType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected CanonicalType but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a CanonicalType and has a value; \`false\` otherwise
   */
  public hasValueCanonicalType(): boolean {
    return this.hasValue() && this.value instanceof CanonicalType;
  }

  /**
   * @returns the \`value\` property value as a CodeType object if defined; else undefined
   */
  public getValueCodeType(): CodeType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof CodeType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected CodeType but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a CodeType and has a value; \`false\` otherwise
   */
  public hasValueCodeType(): boolean {
    return this.hasValue() && this.value instanceof CodeType;
  }

  /**
   * @returns the \`value\` property value as a DateType object if defined; else undefined
   */
  public getValueDateType(): DateType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof DateType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected DateType but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a DateType and has a value; \`false\` otherwise
   */
  public hasValueDateType(): boolean {
    return this.hasValue() && this.value instanceof DateType;
  }

  /**
   * @returns the \`value\` property value as a DateTimeType object if defined; else undefined
   */
  public getValueDateTimeType(): DateTimeType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof DateTimeType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected DateTimeType but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a DateTimeType and has a value; \`false\` otherwise
   */
  public hasValueDateTimeType(): boolean {
    return this.hasValue() && this.value instanceof DateTimeType;
  }

  /**
   * @returns the \`value\` property value as a DecimalType object if defined; else undefined
   */
  public getValueDecimalType(): DecimalType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof DecimalType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected DecimalType but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a DecimalType and has a value; \`false\` otherwise
   */
  public hasValueDecimalType(): boolean {
    return this.hasValue() && this.value instanceof DecimalType;
  }

  /**
   * @returns the \`value\` property value as a IdType object if defined; else undefined
   */
  public getValueIdType(): IdType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof IdType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected IdType but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a IdType and has a value; \`false\` otherwise
   */
  public hasValueIdType(): boolean {
    return this.hasValue() && this.value instanceof IdType;
  }

  /**
   * @returns the \`value\` property value as a InstantType object if defined; else undefined
   */
  public getValueInstantType(): InstantType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof InstantType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected InstantType but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a InstantType and has a value; \`false\` otherwise
   */
  public hasValueInstantType(): boolean {
    return this.hasValue() && this.value instanceof InstantType;
  }

  /**
   * @returns the \`value\` property value as a IntegerType object if defined; else undefined
   */
  public getValueIntegerType(): IntegerType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof IntegerType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected IntegerType but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a IntegerType and has a value; \`false\` otherwise
   */
  public hasValueIntegerType(): boolean {
    return this.hasValue() && this.value instanceof IntegerType;
  }

  /**
   * @returns the \`value\` property value as a MarkdownType object if defined; else undefined
   */
  public getValueMarkdownType(): MarkdownType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof MarkdownType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected MarkdownType but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a MarkdownType and has a value; \`false\` otherwise
   */
  public hasValueMarkdownType(): boolean {
    return this.hasValue() && this.value instanceof MarkdownType;
  }

  /**
   * @returns the \`value\` property value as a OidType object if defined; else undefined
   */
  public getValueOidType(): OidType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof OidType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected OidType but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a OidType and has a value; \`false\` otherwise
   */
  public hasValueOidType(): boolean {
    return this.hasValue() && this.value instanceof OidType;
  }

  /**
   * @returns the \`value\` property value as a PositiveIntType object if defined; else undefined
   */
  public getValuePositiveIntType(): PositiveIntType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof PositiveIntType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected PositiveIntType but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a PositiveIntType and has a value; \`false\` otherwise
   */
  public hasValuePositiveIntType(): boolean {
    return this.hasValue() && this.value instanceof PositiveIntType;
  }

  /**
   * @returns the \`value\` property value as a StringType object if defined; else undefined
   */
  public getValueStringType(): StringType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof StringType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected StringType but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a StringType and has a value; \`false\` otherwise
   */
  public hasValueStringType(): boolean {
    return this.hasValue() && this.value instanceof StringType;
  }

  /**
   * @returns the \`value\` property value as a TimeType object if defined; else undefined
   */
  public getValueTimeType(): TimeType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof TimeType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected TimeType but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a TimeType and has a value; \`false\` otherwise
   */
  public hasValueTimeType(): boolean {
    return this.hasValue() && this.value instanceof TimeType;
  }

  /**
   * @returns the \`value\` property value as a UnsignedIntType object if defined; else undefined
   */
  public getValueUnsignedIntType(): UnsignedIntType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof UnsignedIntType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected UnsignedIntType but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a UnsignedIntType and has a value; \`false\` otherwise
   */
  public hasValueUnsignedIntType(): boolean {
    return this.hasValue() && this.value instanceof UnsignedIntType;
  }

  /**
   * @returns the \`value\` property value as a UriType object if defined; else undefined
   */
  public getValueUriType(): UriType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof UriType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected UriType but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a UriType and has a value; \`false\` otherwise
   */
  public hasValueUriType(): boolean {
    return this.hasValue() && this.value instanceof UriType;
  }

  /**
   * @returns the \`value\` property value as a UrlType object if defined; else undefined
   */
  public getValueUrlType(): UrlType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof UrlType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected UrlType but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a UrlType and has a value; \`false\` otherwise
   */
  public hasValueUrlType(): boolean {
    return this.hasValue() && this.value instanceof UrlType;
  }

  /**
   * @returns the \`value\` property value as a UuidType object if defined; else undefined
   */
  public getValueUuidType(): UuidType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof UuidType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected UuidType but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a UuidType and has a value; \`false\` otherwise
   */
  public hasValueUuidType(): boolean {
    return this.hasValue() && this.value instanceof UuidType;
  }

  /**
   * @returns the \`value\` property value as a Address object if defined; else undefined
   */
  public getValueAddress(): Address | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Address)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected Address but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a Address and has a value; \`false\` otherwise
   */
  public hasValueAddress(): boolean {
    return this.hasValue() && this.value instanceof Address;
  }

  /**
   * @returns the \`value\` property value as a Age object if defined; else undefined
   */
  public getValueAge(): Age | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Age)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected Age but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a Age and has a value; \`false\` otherwise
   */
  public hasValueAge(): boolean {
    return this.hasValue() && this.value instanceof Age;
  }

  /**
   * @returns the \`value\` property value as a Annotation object if defined; else undefined
   */
  public getValueAnnotation(): Annotation | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Annotation)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected Annotation but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a Annotation and has a value; \`false\` otherwise
   */
  public hasValueAnnotation(): boolean {
    return this.hasValue() && this.value instanceof Annotation;
  }

  /**
   * @returns the \`value\` property value as a Attachment object if defined; else undefined
   */
  public getValueAttachment(): Attachment | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Attachment)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected Attachment but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a Attachment and has a value; \`false\` otherwise
   */
  public hasValueAttachment(): boolean {
    return this.hasValue() && this.value instanceof Attachment;
  }

  /**
   * @returns the \`value\` property value as a CodeableConcept object if defined; else undefined
   */
  public getValueCodeableConcept(): CodeableConcept | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof CodeableConcept)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected CodeableConcept but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a CodeableConcept and has a value; \`false\` otherwise
   */
  public hasValueCodeableConcept(): boolean {
    return this.hasValue() && this.value instanceof CodeableConcept;
  }

  /**
   * @returns the \`value\` property value as a Coding object if defined; else undefined
   */
  public getValueCoding(): Coding | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Coding)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected Coding but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a Coding and has a value; \`false\` otherwise
   */
  public hasValueCoding(): boolean {
    return this.hasValue() && this.value instanceof Coding;
  }

  /**
   * @returns the \`value\` property value as a ContactPoint object if defined; else undefined
   */
  public getValueContactPoint(): ContactPoint | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof ContactPoint)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected ContactPoint but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a ContactPoint and has a value; \`false\` otherwise
   */
  public hasValueContactPoint(): boolean {
    return this.hasValue() && this.value instanceof ContactPoint;
  }

  /**
   * @returns the \`value\` property value as a Count object if defined; else undefined
   */
  public getValueCount(): Count | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Count)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected Count but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a Count and has a value; \`false\` otherwise
   */
  public hasValueCount(): boolean {
    return this.hasValue() && this.value instanceof Count;
  }

  /**
   * @returns the \`value\` property value as a Distance object if defined; else undefined
   */
  public getValueDistance(): Distance | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Distance)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected Distance but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a Distance and has a value; \`false\` otherwise
   */
  public hasValueDistance(): boolean {
    return this.hasValue() && this.value instanceof Distance;
  }

  /**
   * @returns the \`value\` property value as a Duration object if defined; else undefined
   */
  public getValueDuration(): Duration | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Duration)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected Duration but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a Duration and has a value; \`false\` otherwise
   */
  public hasValueDuration(): boolean {
    return this.hasValue() && this.value instanceof Duration;
  }

  /**
   * @returns the \`value\` property value as a HumanName object if defined; else undefined
   */
  public getValueHumanName(): HumanName | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof HumanName)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected HumanName but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a HumanName and has a value; \`false\` otherwise
   */
  public hasValueHumanName(): boolean {
    return this.hasValue() && this.value instanceof HumanName;
  }

  /**
   * @returns the \`value\` property value as a Identifier object if defined; else undefined
   */
  public getValueIdentifier(): Identifier | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Identifier)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected Identifier but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a Identifier and has a value; \`false\` otherwise
   */
  public hasValueIdentifier(): boolean {
    return this.hasValue() && this.value instanceof Identifier;
  }

  /**
   * @returns the \`value\` property value as a Money object if defined; else undefined
   */
  public getValueMoney(): Money | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Money)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected Money but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a Money and has a value; \`false\` otherwise
   */
  public hasValueMoney(): boolean {
    return this.hasValue() && this.value instanceof Money;
  }

  /**
   * @returns the \`value\` property value as a Period object if defined; else undefined
   */
  public getValuePeriod(): Period | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Period)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected Period but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a Period and has a value; \`false\` otherwise
   */
  public hasValuePeriod(): boolean {
    return this.hasValue() && this.value instanceof Period;
  }

  /**
   * @returns the \`value\` property value as a Quantity object if defined; else undefined
   */
  public getValueQuantity(): Quantity | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Quantity)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected Quantity but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a Quantity and has a value; \`false\` otherwise
   */
  public hasValueQuantity(): boolean {
    return this.hasValue() && this.value instanceof Quantity;
  }

  /**
   * @returns the \`value\` property value as a Range object if defined; else undefined
   */
  public getValueRange(): Range | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Range)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected Range but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a Range and has a value; \`false\` otherwise
   */
  public hasValueRange(): boolean {
    return this.hasValue() && this.value instanceof Range;
  }

  /**
   * @returns the \`value\` property value as a Ratio object if defined; else undefined
   */
  public getValueRatio(): Ratio | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Ratio)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected Ratio but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a Ratio and has a value; \`false\` otherwise
   */
  public hasValueRatio(): boolean {
    return this.hasValue() && this.value instanceof Ratio;
  }

  /**
   * @returns the \`value\` property value as a Reference object if defined; else undefined
   */
  public getValueReference(): Reference | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Reference)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected Reference but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a Reference and has a value; \`false\` otherwise
   */
  public hasValueReference(): boolean {
    return this.hasValue() && this.value instanceof Reference;
  }

  /**
   * @returns the \`value\` property value as a SampledData object if defined; else undefined
   */
  public getValueSampledData(): SampledData | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof SampledData)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected SampledData but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a SampledData and has a value; \`false\` otherwise
   */
  public hasValueSampledData(): boolean {
    return this.hasValue() && this.value instanceof SampledData;
  }

  /**
   * @returns the \`value\` property value as a Signature object if defined; else undefined
   */
  public getValueSignature(): Signature | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Signature)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected Signature but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a Signature and has a value; \`false\` otherwise
   */
  public hasValueSignature(): boolean {
    return this.hasValue() && this.value instanceof Signature;
  }

  /**
   * @returns the \`value\` property value as a Timing object if defined; else undefined
   */
  public getValueTiming(): Timing | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Timing)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected Timing but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a Timing and has a value; \`false\` otherwise
   */
  public hasValueTiming(): boolean {
    return this.hasValue() && this.value instanceof Timing;
  }

  /**
   * @returns the \`value\` property value as a ContactDetail object if defined; else undefined
   */
  public getValueContactDetail(): ContactDetail | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof ContactDetail)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected ContactDetail but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a ContactDetail and has a value; \`false\` otherwise
   */
  public hasValueContactDetail(): boolean {
    return this.hasValue() && this.value instanceof ContactDetail;
  }

  /**
   * @returns the \`value\` property value as a Contributor object if defined; else undefined
   */
  public getValueContributor(): Contributor | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Contributor)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected Contributor but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a Contributor and has a value; \`false\` otherwise
   */
  public hasValueContributor(): boolean {
    return this.hasValue() && this.value instanceof Contributor;
  }

  /**
   * @returns the \`value\` property value as a DataRequirement object if defined; else undefined
   */
  public getValueDataRequirement(): DataRequirement | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof DataRequirement)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected DataRequirement but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a DataRequirement and has a value; \`false\` otherwise
   */
  public hasValueDataRequirement(): boolean {
    return this.hasValue() && this.value instanceof DataRequirement;
  }

  /**
   * @returns the \`value\` property value as a Expression object if defined; else undefined
   */
  public getValueExpression(): Expression | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Expression)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected Expression but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a Expression and has a value; \`false\` otherwise
   */
  public hasValueExpression(): boolean {
    return this.hasValue() && this.value instanceof Expression;
  }

  /**
   * @returns the \`value\` property value as a ParameterDefinition object if defined; else undefined
   */
  public getValueParameterDefinition(): ParameterDefinition | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof ParameterDefinition)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected ParameterDefinition but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a ParameterDefinition and has a value; \`false\` otherwise
   */
  public hasValueParameterDefinition(): boolean {
    return this.hasValue() && this.value instanceof ParameterDefinition;
  }

  /**
   * @returns the \`value\` property value as a RelatedArtifact object if defined; else undefined
   */
  public getValueRelatedArtifact(): RelatedArtifact | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof RelatedArtifact)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected RelatedArtifact but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a RelatedArtifact and has a value; \`false\` otherwise
   */
  public hasValueRelatedArtifact(): boolean {
    return this.hasValue() && this.value instanceof RelatedArtifact;
  }

  /**
   * @returns the \`value\` property value as a TriggerDefinition object if defined; else undefined
   */
  public getValueTriggerDefinition(): TriggerDefinition | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof TriggerDefinition)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected TriggerDefinition but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a TriggerDefinition and has a value; \`false\` otherwise
   */
  public hasValueTriggerDefinition(): boolean {
    return this.hasValue() && this.value instanceof TriggerDefinition;
  }

  /**
   * @returns the \`value\` property value as a UsageContext object if defined; else undefined
   */
  public getValueUsageContext(): UsageContext | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof UsageContext)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected UsageContext but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a UsageContext and has a value; \`false\` otherwise
   */
  public hasValueUsageContext(): boolean {
    return this.hasValue() && this.value instanceof UsageContext;
  }

  /**
   * @returns the \`value\` property value as a Dosage object if defined; else undefined
   */
  public getValueDosage(): Dosage | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Dosage)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected Dosage but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a Dosage and has a value; \`false\` otherwise
   */
  public hasValueDosage(): boolean {
    return this.hasValue() && this.value instanceof Dosage;
  }

  /**
   * @returns the \`value\` property value as a Meta object if defined; else undefined
   */
  public getValueMeta(): Meta | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Meta)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Extension.value[x]: Expected Meta but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`value\` property exists as a Meta and has a value; \`false\` otherwise
   */
  public hasValueMeta(): boolean {
    return this.hasValue() && this.value instanceof Meta;
  }
}

/**
 * HumanName Class
 *
 * @remarks
 * Base StructureDefinition for HumanName Type: A human\\'s name with the ability to identify parts and usage.
 *
 * Need to be able to record names, along with notes about their use.
 *
 * **FHIR Specification**
 * - **Short:** Name of a human - parts and usage
 * - **Definition:** A human\\'s name with the ability to identify parts and usage.
 * - **Comment:** Names may be changed, or repudiated, or people may have different names in different contexts. Names may be divided into parts of different type that have variable significance depending on context, though the division into parts does not always matter. With personal names, the different parts might or might not be imbued with some implicit meaning; various cultures associate different importance with the name parts and the degree to which systems must care about name parts around the world varies widely.
 * - **FHIR Version:** 4.0.1
 *
 * @category Data Models: ComplexType
 * @see [FHIR HumanName](http://hl7.org/fhir/StructureDefinition/HumanName)
 */
/* istanbul ignore next */ export class HumanName extends DataType implements IDataType {
  constructor() {
    super();

    this.nameUseEnum = new NameUseEnum();
  }

  /**
   * Parse the provided \`HumanName\` JSON to instantiate the HumanName data model.
   *
   * @param sourceJson - JSON representing FHIR \`HumanName\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to HumanName
   * @returns HumanName data model or undefined for \`HumanName\`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): HumanName | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'HumanName';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new HumanName();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'use';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setUseElement(datatype);
    }

    fieldName = 'text';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setTextElement(datatype);
    }

    fieldName = 'family';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setFamilyElement(datatype);
    }

    fieldName = 'given';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: StringType | undefined = fhirParser.parseStringType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addGivenElement(datatype);
        }
      });
    }

    fieldName = 'prefix';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: StringType | undefined = fhirParser.parseStringType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addPrefixElement(datatype);
        }
      });
    }

    fieldName = 'suffix';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: StringType | undefined = fhirParser.parseStringType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addSuffixElement(datatype);
        }
      });
    }

    fieldName = 'period';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Period | undefined = Period.parse(classJsonObj[fieldName]!, sourceField);
      instance.setPeriod(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: NameUse
   *
   * @see {@link NameUseEnum }
   */
  private readonly nameUseEnum: NameUseEnum;

  /**
   * HumanName.use Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** usual | official | temp | nickname | anonymous | old | maiden
   * - **Definition:** Identifies the purpose for this name.
   * - **Comment:** Applications can assume that a name is current unless it explicitly says that it is temporary or old.
   * - **Requirements:** Allows the appropriate name for a particular context of use to be selected from among a set of names.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** true
   * - **isModifierReason:** This is labeled as &quot;Is Modifier&quot; because applications should not mistake a temporary or old name etc.for a current/permanent one
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link NameUseEnum }
   */
  private use?: EnumCodeType | undefined;

  /**
   * HumanName.text Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Text representation of the full name
   * - **Definition:** Specifies the entire name as it should be displayed e.g. on an application UI. This may be provided instead of or as well as the specific parts.
   * - **Comment:** Can provide both a text representation and parts. Applications updating a name SHALL ensure that when both text and parts are present,  no content is included in the text that isn\\'t found in a part.
   * - **Requirements:** A renderable, unencoded form.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private text?: StringType | undefined;

  /**
   * HumanName.family Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Family name (often called \\'Surname\\')
   * - **Definition:** The part of a name that links to the genealogy. In some cultures (e.g. Eritrea) the family name of a son is the first name of his father.
   * - **Comment:** Family Name may be decomposed into specific parts using extensions (de, nl, es related cultures).
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private family?: StringType | undefined;

  /**
   * HumanName.given Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Given names (not always \\'first\\'). Includes middle names
   * - **Definition:** Given name.
   * - **Comment:** If only initials are recorded, they may be used in place of the full name parts. Initials may be separated into multiple given names but often aren\\'t due to paractical limitations.  This element is not called "first name" since given names do not always come first.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private given?: StringType[] | undefined;

  /**
   * HumanName.prefix Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Parts that come before the name
   * - **Definition:** Part of the name that is acquired as a title due to academic, legal, employment or nobility status, etc. and that appears at the start of the name.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private prefix?: StringType[] | undefined;

  /**
   * HumanName.suffix Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Parts that come after the name
   * - **Definition:** Part of the name that is acquired as a title due to academic, legal, employment or nobility status, etc. and that appears at the end of the name.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private suffix?: StringType[] | undefined;

  /**
   * HumanName.period Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Time period when name was/is in use
   * - **Definition:** Indicates the period of time when this name was valid for the named person.
   * - **Requirements:** Allows names to be placed in historical context.
   * - **FHIR Type:** \`Period\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private period?: Period | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`use\` property value as a EnumCodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link NameUseEnum }
   */
  public getUseEnumType(): EnumCodeType | undefined {
    return this.use;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`use\` property.
   *
   * @param enumType - the \`use\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code values
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link NameUseEnum }
   */
  public setUseEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid HumanName.use';
      assertEnumCodeType<NameUseEnum>(enumType, NameUseEnum, errMsgPrefix);
      this.use = enumType;
    } else {
      this.use = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`use\` property exists and has a value; \`false\` otherwise
   */
  public hasUseEnumType(): boolean {
    return isDefined<EnumCodeType>(this.use) && !this.use.isEmpty() && this.use.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`use\` property value as a CodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link NameUseEnum }
   */
  public getUseElement(): CodeType | undefined {
    if (this.use === undefined) {
      return undefined;
    }
    return this.use as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`use\` property.
   *
   * @param element - the \`use\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link NameUseEnum }
   */
  public setUseElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid HumanName.use; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.use = new EnumCodeType(element, this.nameUseEnum);
    } else {
      this.use = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`use\` property exists and has a value; \`false\` otherwise
   */
  public hasUseElement(): boolean {
    return this.hasUseEnumType();
  }

  /**
   * @returns the \`use\` property value as a fhirCode if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link NameUseEnum }
   */
  public getUse(): fhirCode | undefined {
    if (this.use === undefined) {
      return undefined;
    }
    return this.use.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`use\` property.
   *
   * @param value - the \`use\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link NameUseEnum }
   */
  public setUse(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid HumanName.use; Provided value is not an instance of fhirCode.\`;
      this.use = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.nameUseEnum);
    } else {
      this.use = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`use\` property exists and has a value; \`false\` otherwise
   */
  public hasUse(): boolean {
    return this.hasUseEnumType();
  }

  /**
   * @returns the \`text\` property value as a StringType object if defined; else an empty StringType object
   */
  public getTextElement(): StringType {
    return this.text ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`text\` property.
   *
   * @param element - the \`text\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTextElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid HumanName.text; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.text = element;
    } else {
      this.text = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`text\` property exists and has a value; \`false\` otherwise
   */
  public hasTextElement(): boolean {
    return isDefined<StringType>(this.text) && !this.text.isEmpty();
  }

  /**
   * @returns the \`text\` property value as a fhirString if defined; else undefined
   */
  public getText(): fhirString | undefined {
    return this.text?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`text\` property.
   *
   * @param value - the \`text\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setText(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid HumanName.text (\${String(value)})\`;
      this.text = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.text = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`text\` property exists and has a value; \`false\` otherwise
   */
  public hasText(): boolean {
    return this.hasTextElement();
  }

  /**
   * @returns the \`family\` property value as a StringType object if defined; else an empty StringType object
   */
  public getFamilyElement(): StringType {
    return this.family ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`family\` property.
   *
   * @param element - the \`family\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setFamilyElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid HumanName.family; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.family = element;
    } else {
      this.family = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`family\` property exists and has a value; \`false\` otherwise
   */
  public hasFamilyElement(): boolean {
    return isDefined<StringType>(this.family) && !this.family.isEmpty();
  }

  /**
   * @returns the \`family\` property value as a fhirString if defined; else undefined
   */
  public getFamily(): fhirString | undefined {
    return this.family?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`family\` property.
   *
   * @param value - the \`family\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setFamily(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid HumanName.family (\${String(value)})\`;
      this.family = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.family = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`family\` property exists and has a value; \`false\` otherwise
   */
  public hasFamily(): boolean {
    return this.hasFamilyElement();
  }

  /**
   * @returns the \`given\` property value as a StringType array
   */
  public getGivenElement(): StringType[] {
    return this.given ?? ([] as StringType[]);
  }

  /**
   * Assigns the provided StringType array value to the \`given\` property.
   *
   * @param element - the \`given\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setGivenElement(element: StringType[] | undefined): this {
    if (isDefinedList<StringType>(element)) {
      const optErrMsg = \`Invalid HumanName.given; Provided value array has an element that is not an instance of StringType.\`;
      assertFhirTypeList<StringType>(element, StringType, optErrMsg);
      this.given = element;
    } else {
      this.given = undefined;
    }
    return this;
  }

  /**
   * Add the provided StringType value to the \`given\` array property.
   *
   * @param element - the \`given\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addGivenElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid HumanName.given; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.initGiven();
      this.given?.push(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`given\` property exists and has a value; \`false\` otherwise
   */
  public hasGivenElement(): boolean {
    return isDefinedList<StringType>(this.given) && this.given.some((item: StringType) => !item.isEmpty());
  }

  /**
   * @returns the \`given\` property value as a fhirString array
   */
  public getGiven(): fhirString[] {
    this.initGiven();
    const givenValues = [] as fhirString[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.given!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        givenValues.push(value);
      }
    }
    return givenValues;
  }

  /**
   * Assigns the provided primitive value array to the \`given\` property.
   *
   * @param value - the \`given\` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setGiven(value: fhirString[] | undefined): this {
    if (isDefinedList<fhirString>(value)) {
      const givenElements = [] as StringType[];
      for (const givenValue of value) {
        const optErrMsg = \`Invalid HumanName.given array item (\${String(givenValue)})\`;
        const element = new StringType(parseFhirPrimitiveData(givenValue, fhirStringSchema, optErrMsg));
        givenElements.push(element);
      }
      this.given = givenElements;
    } else {
      this.given = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`given\` array property.
   *
   * @param value - the \`given\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addGiven(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid HumanName.given array item (\${String(value)})\`;
      const element = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
      this.initGiven();
      this.addGivenElement(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`given\` property exists and has a value; \`false\` otherwise
   */
  public hasGiven(): boolean {
    return this.hasGivenElement();
  }

  /**
   * Initialize the \`given\` property
   */
  private initGiven(): void {
    if (!this.hasGiven()) {
      this.given = [] as StringType[];
    }
  }

  /**
   * @returns the \`prefix\` property value as a StringType array
   */
  public getPrefixElement(): StringType[] {
    return this.prefix ?? ([] as StringType[]);
  }

  /**
   * Assigns the provided StringType array value to the \`prefix\` property.
   *
   * @param element - the \`prefix\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPrefixElement(element: StringType[] | undefined): this {
    if (isDefinedList<StringType>(element)) {
      const optErrMsg = \`Invalid HumanName.prefix; Provided value array has an element that is not an instance of StringType.\`;
      assertFhirTypeList<StringType>(element, StringType, optErrMsg);
      this.prefix = element;
    } else {
      this.prefix = undefined;
    }
    return this;
  }

  /**
   * Add the provided StringType value to the \`prefix\` array property.
   *
   * @param element - the \`prefix\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addPrefixElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid HumanName.prefix; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.initPrefix();
      this.prefix?.push(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`prefix\` property exists and has a value; \`false\` otherwise
   */
  public hasPrefixElement(): boolean {
    return isDefinedList<StringType>(this.prefix) && this.prefix.some((item: StringType) => !item.isEmpty());
  }

  /**
   * @returns the \`prefix\` property value as a fhirString array
   */
  public getPrefix(): fhirString[] {
    this.initPrefix();
    const prefixValues = [] as fhirString[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.prefix!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        prefixValues.push(value);
      }
    }
    return prefixValues;
  }

  /**
   * Assigns the provided primitive value array to the \`prefix\` property.
   *
   * @param value - the \`prefix\` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPrefix(value: fhirString[] | undefined): this {
    if (isDefinedList<fhirString>(value)) {
      const prefixElements = [] as StringType[];
      for (const prefixValue of value) {
        const optErrMsg = \`Invalid HumanName.prefix array item (\${String(prefixValue)})\`;
        const element = new StringType(parseFhirPrimitiveData(prefixValue, fhirStringSchema, optErrMsg));
        prefixElements.push(element);
      }
      this.prefix = prefixElements;
    } else {
      this.prefix = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`prefix\` array property.
   *
   * @param value - the \`prefix\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addPrefix(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid HumanName.prefix array item (\${String(value)})\`;
      const element = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
      this.initPrefix();
      this.addPrefixElement(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`prefix\` property exists and has a value; \`false\` otherwise
   */
  public hasPrefix(): boolean {
    return this.hasPrefixElement();
  }

  /**
   * Initialize the \`prefix\` property
   */
  private initPrefix(): void {
    if (!this.hasPrefix()) {
      this.prefix = [] as StringType[];
    }
  }

  /**
   * @returns the \`suffix\` property value as a StringType array
   */
  public getSuffixElement(): StringType[] {
    return this.suffix ?? ([] as StringType[]);
  }

  /**
   * Assigns the provided StringType array value to the \`suffix\` property.
   *
   * @param element - the \`suffix\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSuffixElement(element: StringType[] | undefined): this {
    if (isDefinedList<StringType>(element)) {
      const optErrMsg = \`Invalid HumanName.suffix; Provided value array has an element that is not an instance of StringType.\`;
      assertFhirTypeList<StringType>(element, StringType, optErrMsg);
      this.suffix = element;
    } else {
      this.suffix = undefined;
    }
    return this;
  }

  /**
   * Add the provided StringType value to the \`suffix\` array property.
   *
   * @param element - the \`suffix\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addSuffixElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid HumanName.suffix; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.initSuffix();
      this.suffix?.push(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`suffix\` property exists and has a value; \`false\` otherwise
   */
  public hasSuffixElement(): boolean {
    return isDefinedList<StringType>(this.suffix) && this.suffix.some((item: StringType) => !item.isEmpty());
  }

  /**
   * @returns the \`suffix\` property value as a fhirString array
   */
  public getSuffix(): fhirString[] {
    this.initSuffix();
    const suffixValues = [] as fhirString[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.suffix!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        suffixValues.push(value);
      }
    }
    return suffixValues;
  }

  /**
   * Assigns the provided primitive value array to the \`suffix\` property.
   *
   * @param value - the \`suffix\` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSuffix(value: fhirString[] | undefined): this {
    if (isDefinedList<fhirString>(value)) {
      const suffixElements = [] as StringType[];
      for (const suffixValue of value) {
        const optErrMsg = \`Invalid HumanName.suffix array item (\${String(suffixValue)})\`;
        const element = new StringType(parseFhirPrimitiveData(suffixValue, fhirStringSchema, optErrMsg));
        suffixElements.push(element);
      }
      this.suffix = suffixElements;
    } else {
      this.suffix = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`suffix\` array property.
   *
   * @param value - the \`suffix\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addSuffix(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid HumanName.suffix array item (\${String(value)})\`;
      const element = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
      this.initSuffix();
      this.addSuffixElement(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`suffix\` property exists and has a value; \`false\` otherwise
   */
  public hasSuffix(): boolean {
    return this.hasSuffixElement();
  }

  /**
   * Initialize the \`suffix\` property
   */
  private initSuffix(): void {
    if (!this.hasSuffix()) {
      this.suffix = [] as StringType[];
    }
  }

  /**
   * @returns the \`period\` property value as a Period object if defined; else an empty Period object
   */
  public getPeriod(): Period {
    return this.period ?? new Period();
  }

  /**
   * Assigns the provided Period object value to the \`period\` property.
   *
   * @param value - the \`period\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setPeriod(value: Period | undefined): this {
    if (isDefined<Period>(value)) {
      const optErrMsg = \`Invalid HumanName.period; Provided element is not an instance of Period.\`;
      assertFhirType<Period>(value, Period, optErrMsg);
      this.period = value;
    } else {
      this.period = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`period\` property exists and has a value; \`false\` otherwise
   */
  public hasPeriod(): boolean {
    return isDefined<Period>(this.period) && !this.period.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'HumanName';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.use,
      this.text,
      this.family,
      this.given,
      this.prefix,
      this.suffix,
      this.period,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): HumanName {
    const dest = new HumanName();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: HumanName): void {
    super.copyValues(dest);
    dest.use = this.use?.copy();
    dest.text = this.text?.copy();
    dest.family = this.family?.copy();
    const givenList = copyListValues<StringType>(this.given);
    dest.given = givenList.length === 0 ? undefined : givenList;
    const prefixList = copyListValues<StringType>(this.prefix);
    dest.prefix = prefixList.length === 0 ? undefined : prefixList;
    const suffixList = copyListValues<StringType>(this.suffix);
    dest.suffix = suffixList.length === 0 ? undefined : suffixList;
    dest.period = this.period?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', \`UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasUseElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getUseElement()!, 'use', jsonObj);
    }

    if (this.hasTextElement()) {
      setFhirPrimitiveJson<fhirString>(this.getTextElement(), 'text', jsonObj);
    }

    if (this.hasFamilyElement()) {
      setFhirPrimitiveJson<fhirString>(this.getFamilyElement(), 'family', jsonObj);
    }

    if (this.hasGiven()) {
      setFhirPrimitiveListJson(this.getGivenElement(), 'given', jsonObj);
    }

    if (this.hasPrefix()) {
      setFhirPrimitiveListJson(this.getPrefixElement(), 'prefix', jsonObj);
    }

    if (this.hasSuffix()) {
      setFhirPrimitiveListJson(this.getSuffixElement(), 'suffix', jsonObj);
    }

    if (this.hasPeriod()) {
      setFhirComplexJson(this.getPeriod(), 'period', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * Money Class
 *
 * @remarks
 * Base StructureDefinition for Money Type: An amount of economic utility in some recognized currency.
 *
 * **FHIR Specification**
 * - **Short:** An amount of economic utility in some recognized currency
 * - **Definition:** An amount of economic utility in some recognized currency.
 * - **FHIR Version:** 4.0.1
 *
 * @category Data Models: ComplexType
 * @see [FHIR Money](http://hl7.org/fhir/StructureDefinition/Money)
 */
/* istanbul ignore next */ export class Money extends DataType implements IDataType {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`Money\` JSON to instantiate the Money data model.
   *
   * @param sourceJson - JSON representing FHIR \`Money\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Money
   * @returns Money data model or undefined for \`Money\`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Money | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Money';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Money();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'value';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setValueElement(datatype);
    }

    fieldName = 'currency';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setCurrencyElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Money.value Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Numerical value (with implicit precision)
   * - **Definition:** Numerical value (with implicit precision).
   * - **Comment:** Monetary values have their own rules for handling precision (refer to standard accounting text books).
   * - **Requirements:** The amount of the currency. The value includes an implicit precision in the presentation of the value.
   * - **FHIR Type:** \`decimal\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private value?: DecimalType | undefined;

  /**
   * Money.currency Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** ISO 4217 Currency Code
   * - **Definition:** ISO 4217 Currency Code.
   * - **Requirements:** A code indicating the currency, taken from ISO 4217.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private currency?: CodeType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`value\` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getValueElement(): DecimalType {
    return this.value ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`value\` property.
   *
   * @param element - the \`value\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValueElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = \`Invalid Money.value; Provided element is not an instance of DecimalType.\`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.value = element;
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`value\` property exists and has a value; \`false\` otherwise
   */
  public hasValueElement(): boolean {
    return isDefined<DecimalType>(this.value) && !this.value.isEmpty();
  }

  /**
   * @returns the \`value\` property value as a fhirDecimal if defined; else undefined
   */
  public getValue(): fhirDecimal | undefined {
    return this.value?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`value\` property.
   *
   * @param value - the \`value\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValue(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = \`Invalid Money.value (\${String(value)})\`;
      this.value = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`value\` property exists and has a value; \`false\` otherwise
   */
  public hasValue(): boolean {
    return this.hasValueElement();
  }

  /**
   * @returns the \`currency\` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getCurrencyElement(): CodeType {
    return this.currency ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`currency\` property.
   *
   * @param element - the \`currency\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCurrencyElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Money.currency; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.currency = element;
    } else {
      this.currency = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`currency\` property exists and has a value; \`false\` otherwise
   */
  public hasCurrencyElement(): boolean {
    return isDefined<CodeType>(this.currency) && !this.currency.isEmpty();
  }

  /**
   * @returns the \`currency\` property value as a fhirCode if defined; else undefined
   */
  public getCurrency(): fhirCode | undefined {
    return this.currency?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`currency\` property.
   *
   * @param value - the \`currency\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCurrency(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Money.currency (\${String(value)})\`;
      this.currency = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.currency = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`currency\` property exists and has a value; \`false\` otherwise
   */
  public hasCurrency(): boolean {
    return this.hasCurrencyElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Money';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.value,
      this.currency,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Money {
    const dest = new Money();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Money): void {
    super.copyValues(dest);
    dest.value = this.value?.copy();
    dest.currency = this.currency?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', \`UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasValueElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getValueElement(), 'value', jsonObj);
    }

    if (this.hasCurrencyElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getCurrencyElement(), 'currency', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * ParameterDefinition Class
 *
 * @remarks
 * Base StructureDefinition for ParameterDefinition Type: The parameters to the module. This collection specifies both the input and output parameters. Input parameters are provided by the caller as part of the $evaluate operation. Output parameters are included in the GuidanceResponse.
 *
 * **FHIR Specification**
 * - **Short:** Definition of a parameter to a module
 * - **Definition:** The parameters to the module. This collection specifies both the input and output parameters. Input parameters are provided by the caller as part of the $evaluate operation. Output parameters are included in the GuidanceResponse.
 * - **FHIR Version:** 4.0.1
 *
 * @category Data Models: ComplexType
 * @see [FHIR ParameterDefinition](http://hl7.org/fhir/StructureDefinition/ParameterDefinition)
 */
/* istanbul ignore next */ export class ParameterDefinition extends DataType implements IDataType {
  constructor(use: EnumCodeType | CodeType | fhirCode | null = null, type_: CodeType | fhirCode | null = null) {
    super();

    this.operationParameterUseEnum = new OperationParameterUseEnum();

    this.use = constructorCodeValueAsEnumCodeType<OperationParameterUseEnum>(
      use,
      OperationParameterUseEnum,
      this.operationParameterUseEnum,
      'ParameterDefinition.use',
    );

    this.type_ = null;
    if (isDefined<CodeType | fhirCode>(type_)) {
      if (type_ instanceof PrimitiveType) {
        this.setTypeElement(type_);
      } else {
        this.setType(type_);
      }
    }
  }

  /**
   * Parse the provided \`ParameterDefinition\` JSON to instantiate the ParameterDefinition data model.
   *
   * @param sourceJson - JSON representing FHIR \`ParameterDefinition\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to ParameterDefinition
   * @returns ParameterDefinition data model or undefined for \`ParameterDefinition\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): ParameterDefinition | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'ParameterDefinition';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new ParameterDefinition();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'name';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setNameElement(datatype);
    }

    fieldName = 'use';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setUseElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'min';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: IntegerType | undefined = fhirParser.parseIntegerType(dtJson, dtSiblingJson);
      instance.setMinElement(datatype);
    }

    fieldName = 'max';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setMaxElement(datatype);
    }

    fieldName = 'documentation';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setDocumentationElement(datatype);
    }

    fieldName = 'type';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setTypeElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'profile';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CanonicalType | undefined = fhirParser.parseCanonicalType(dtJson, dtSiblingJson);
      instance.setProfileElement(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * ParameterDefinition.name Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Name used to access the parameter value
   * - **Definition:** The name of the parameter used to allow access to the value of the parameter in evaluation contexts.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private name?: CodeType | undefined;

  /**
   * FHIR CodeSystem: OperationParameterUse
   *
   * @see {@link OperationParameterUseEnum }
   */
  private readonly operationParameterUseEnum: OperationParameterUseEnum;

  /**
   * ParameterDefinition.use Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** in | out
   * - **Definition:** Whether the parameter is input or output for the module.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link OperationParameterUseEnum }
   */
  private use: EnumCodeType | null;

  /**
   * ParameterDefinition.min Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Minimum cardinality
   * - **Definition:** The minimum number of times this parameter SHALL appear in the request or response.
   * - **FHIR Type:** \`integer\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private min?: IntegerType | undefined;

  /**
   * ParameterDefinition.max Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Maximum cardinality (a number of *)
   * - **Definition:** The maximum number of times this element is permitted to appear in the request or response.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private max?: StringType | undefined;

  /**
   * ParameterDefinition.documentation Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A brief description of the parameter
   * - **Definition:** A brief discussion of what the parameter is for and how it is used by the module.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private documentation?: StringType | undefined;

  /**
   * ParameterDefinition.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** What type of value
   * - **Definition:** The type of the parameter.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private type_: CodeType | null;

  /**
   * ParameterDefinition.profile Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** What profile the value is expected to be
   * - **Definition:** If specified, this indicates a profile that the input data must conform to, or that the output data will conform to.
   * - **FHIR Type:** \`canonical\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/StructureDefinition',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private profile?: CanonicalType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`name\` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getNameElement(): CodeType {
    return this.name ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`name\` property.
   *
   * @param element - the \`name\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setNameElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid ParameterDefinition.name; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.name = element;
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`name\` property exists and has a value; \`false\` otherwise
   */
  public hasNameElement(): boolean {
    return isDefined<CodeType>(this.name) && !this.name.isEmpty();
  }

  /**
   * @returns the \`name\` property value as a fhirCode if defined; else undefined
   */
  public getName(): fhirCode | undefined {
    return this.name?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`name\` property.
   *
   * @param value - the \`name\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setName(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid ParameterDefinition.name (\${String(value)})\`;
      this.name = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`name\` property exists and has a value; \`false\` otherwise
   */
  public hasName(): boolean {
    return this.hasNameElement();
  }

  /**
   * @returns the \`use\` property value as a EnumCodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link OperationParameterUseEnum }
   */
  public getUseEnumType(): EnumCodeType | null {
    return this.use;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`use\` property.
   *
   * @param enumType - the \`use\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link OperationParameterUseEnum }
   */
  public setUseEnumType(enumType: EnumCodeType): this {
    assertIsDefined<EnumCodeType>(enumType, \`ParameterDefinition.use is required\`);
    const errMsgPrefix = \`Invalid ParameterDefinition.use\`;
    assertEnumCodeType<OperationParameterUseEnum>(enumType, OperationParameterUseEnum, errMsgPrefix);
    this.use = enumType;
    return this;
  }

  /**
   * @returns \`true\` if the \`use\` property exists and has a value; \`false\` otherwise
   */
  public hasUseEnumType(): boolean {
    return isDefined<EnumCodeType>(this.use) && !this.use.isEmpty() && this.use.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`use\` property value as a CodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link OperationParameterUseEnum }
   */
  public getUseElement(): CodeType | null {
    if (this.use === null) {
      return null;
    }
    return this.use as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`use\` property.
   *
   * @param element - the \`use\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link OperationParameterUseEnum }
   */
  public setUseElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, \`ParameterDefinition.use is required\`);
    const optErrMsg = \`Invalid ParameterDefinition.use; Provided value is not an instance of CodeType.\`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.use = new EnumCodeType(element, this.operationParameterUseEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`use\` property exists and has a value; \`false\` otherwise
   */
  public hasUseElement(): boolean {
    return this.hasUseEnumType();
  }

  /**
   * @returns the \`use\` property value as a fhirCode if defined; else null
   *
   * @see CodeSystem Enumeration: {@link OperationParameterUseEnum }
   */
  public getUse(): fhirCode | null {
    if (this.use === null) {
      return null;
    }
    return this.use.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`use\` property.
   *
   * @param value - the \`use\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link OperationParameterUseEnum }
   */
  public setUse(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, \`ParameterDefinition.use is required\`);
    const optErrMsg = \`Invalid ParameterDefinition.use (\${String(value)})\`;
    this.use = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.operationParameterUseEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`use\` property exists and has a value; \`false\` otherwise
   */
  public hasUse(): boolean {
    return this.hasUseEnumType();
  }

  /**
   * @returns the \`min\` property value as a IntegerType object if defined; else an empty IntegerType object
   */
  public getMinElement(): IntegerType {
    return this.min ?? new IntegerType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`min\` property.
   *
   * @param element - the \`min\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMinElement(element: IntegerType | undefined): this {
    if (isDefined<IntegerType>(element)) {
      const optErrMsg = \`Invalid ParameterDefinition.min; Provided element is not an instance of IntegerType.\`;
      assertFhirType<IntegerType>(element, IntegerType, optErrMsg);
      this.min = element;
    } else {
      this.min = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`min\` property exists and has a value; \`false\` otherwise
   */
  public hasMinElement(): boolean {
    return isDefined<IntegerType>(this.min) && !this.min.isEmpty();
  }

  /**
   * @returns the \`min\` property value as a fhirInteger if defined; else undefined
   */
  public getMin(): fhirInteger | undefined {
    return this.min?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`min\` property.
   *
   * @param value - the \`min\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMin(value: fhirInteger | undefined): this {
    if (isDefined<fhirInteger>(value)) {
      const optErrMsg = \`Invalid ParameterDefinition.min (\${String(value)})\`;
      this.min = new IntegerType(parseFhirPrimitiveData(value, fhirIntegerSchema, optErrMsg));
    } else {
      this.min = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`min\` property exists and has a value; \`false\` otherwise
   */
  public hasMin(): boolean {
    return this.hasMinElement();
  }

  /**
   * @returns the \`max\` property value as a StringType object if defined; else an empty StringType object
   */
  public getMaxElement(): StringType {
    return this.max ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`max\` property.
   *
   * @param element - the \`max\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMaxElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid ParameterDefinition.max; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.max = element;
    } else {
      this.max = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`max\` property exists and has a value; \`false\` otherwise
   */
  public hasMaxElement(): boolean {
    return isDefined<StringType>(this.max) && !this.max.isEmpty();
  }

  /**
   * @returns the \`max\` property value as a fhirString if defined; else undefined
   */
  public getMax(): fhirString | undefined {
    return this.max?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`max\` property.
   *
   * @param value - the \`max\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMax(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid ParameterDefinition.max (\${String(value)})\`;
      this.max = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.max = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`max\` property exists and has a value; \`false\` otherwise
   */
  public hasMax(): boolean {
    return this.hasMaxElement();
  }

  /**
   * @returns the \`documentation\` property value as a StringType object if defined; else an empty StringType object
   */
  public getDocumentationElement(): StringType {
    return this.documentation ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`documentation\` property.
   *
   * @param element - the \`documentation\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDocumentationElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid ParameterDefinition.documentation; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.documentation = element;
    } else {
      this.documentation = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`documentation\` property exists and has a value; \`false\` otherwise
   */
  public hasDocumentationElement(): boolean {
    return isDefined<StringType>(this.documentation) && !this.documentation.isEmpty();
  }

  /**
   * @returns the \`documentation\` property value as a fhirString if defined; else undefined
   */
  public getDocumentation(): fhirString | undefined {
    return this.documentation?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`documentation\` property.
   *
   * @param value - the \`documentation\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDocumentation(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid ParameterDefinition.documentation (\${String(value)})\`;
      this.documentation = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.documentation = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`documentation\` property exists and has a value; \`false\` otherwise
   */
  public hasDocumentation(): boolean {
    return this.hasDocumentationElement();
  }

  /**
   * @returns the \`type_\` property value as a CodeType object if defined; else null
   */
  public getTypeElement(): CodeType | null {
    return this.type_;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`type_\` property.
   *
   * @param element - the \`type_\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTypeElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, \`ParameterDefinition.type is required\`);
    const optErrMsg = \`Invalid ParameterDefinition.type; Provided value is not an instance of CodeType.\`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.type_ = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasTypeElement(): boolean {
    return isDefined<CodeType>(this.type_) && !this.type_.isEmpty();
  }

  /**
   * @returns the \`type_\` property value as a fhirCode if defined; else null
   */
  public getType(): fhirCode | null {
    if (this.type_?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.type_.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`type_\` property.
   *
   * @param value - the \`type_\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setType(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, \`ParameterDefinition.type is required\`);
    const optErrMsg = \`Invalid ParameterDefinition.type (\${String(value)})\`;
    this.type_ = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasType(): boolean {
    return this.hasTypeElement();
  }

  /**
   * @returns the \`profile\` property value as a CanonicalType object if defined; else an empty CanonicalType object
   */
  public getProfileElement(): CanonicalType {
    return this.profile ?? new CanonicalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`profile\` property.
   *
   * @param element - the \`profile\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setProfileElement(element: CanonicalType | undefined): this {
    if (isDefined<CanonicalType>(element)) {
      const optErrMsg = \`Invalid ParameterDefinition.profile; Provided element is not an instance of CanonicalType.\`;
      assertFhirType<CanonicalType>(element, CanonicalType, optErrMsg);
      this.profile = element;
    } else {
      this.profile = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`profile\` property exists and has a value; \`false\` otherwise
   */
  public hasProfileElement(): boolean {
    return isDefined<CanonicalType>(this.profile) && !this.profile.isEmpty();
  }

  /**
   * @returns the \`profile\` property value as a fhirCanonical if defined; else undefined
   */
  public getProfile(): fhirCanonical | undefined {
    return this.profile?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`profile\` property.
   *
   * @param value - the \`profile\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setProfile(value: fhirCanonical | undefined): this {
    if (isDefined<fhirCanonical>(value)) {
      const optErrMsg = \`Invalid ParameterDefinition.profile (\${String(value)})\`;
      this.profile = new CanonicalType(parseFhirPrimitiveData(value, fhirCanonicalSchema, optErrMsg));
    } else {
      this.profile = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`profile\` property exists and has a value; \`false\` otherwise
   */
  public hasProfile(): boolean {
    return this.hasProfileElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'ParameterDefinition';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.name,
      this.use,
      this.min,
      this.max,
      this.documentation,
      this.type_,
      this.profile,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): ParameterDefinition {
    const dest = new ParameterDefinition();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: ParameterDefinition): void {
    super.copyValues(dest);
    dest.name = this.name?.copy();
    dest.use = this.use ? this.use.copy() : null;
    dest.min = this.min?.copy();
    dest.max = this.max?.copy();
    dest.documentation = this.documentation?.copy();
    dest.type_ = this.type_ ? this.type_.copy() : null;
    dest.profile = this.profile?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', \`UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasNameElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getNameElement(), 'name', jsonObj);
    }

    if (this.hasUseElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getUseElement()!, 'use', jsonObj);
    } else {
      missingReqdProperties.push(\`ParameterDefinition.use\`);
    }

    if (this.hasMinElement()) {
      setFhirPrimitiveJson<fhirInteger>(this.getMinElement(), 'min', jsonObj);
    }

    if (this.hasMaxElement()) {
      setFhirPrimitiveJson<fhirString>(this.getMaxElement(), 'max', jsonObj);
    }

    if (this.hasDocumentationElement()) {
      setFhirPrimitiveJson<fhirString>(this.getDocumentationElement(), 'documentation', jsonObj);
    }

    if (this.hasTypeElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getTypeElement()!, 'type', jsonObj);
    } else {
      missingReqdProperties.push(\`ParameterDefinition.type\`);
    }

    if (this.hasProfileElement()) {
      setFhirPrimitiveJson<fhirCanonical>(this.getProfileElement(), 'profile', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

/**
 * ProdCharacteristic Class
 *
 * @remarks
 * Base StructureDefinition for ProdCharacteristic Type: The marketing status describes the date when a medicinal product is actually put on the market or the date as of which it is no longer available.
 *
 * **FHIR Specification**
 * - **Short:** The marketing status describes the date when a medicinal product is actually put on the market or the date as of which it is no longer available
 * - **Definition:** The marketing status describes the date when a medicinal product is actually put on the market or the date as of which it is no longer available.
 * - **FHIR Version:** 4.0.1
 *
 * @category Data Models: ComplexType
 * @see [FHIR ProdCharacteristic](http://hl7.org/fhir/StructureDefinition/ProdCharacteristic)
 */
/* istanbul ignore next */ export class ProdCharacteristic extends BackboneType implements IBackboneType {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`ProdCharacteristic\` JSON to instantiate the ProdCharacteristic data model.
   *
   * @param sourceJson - JSON representing FHIR \`ProdCharacteristic\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to ProdCharacteristic
   * @returns ProdCharacteristic data model or undefined for \`ProdCharacteristic\`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): ProdCharacteristic | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'ProdCharacteristic';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new ProdCharacteristic();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneTypeJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'height';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = Quantity.parse(classJsonObj[fieldName]!, sourceField);
      instance.setHeight(datatype);
    }

    fieldName = 'width';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = Quantity.parse(classJsonObj[fieldName]!, sourceField);
      instance.setWidth(datatype);
    }

    fieldName = 'depth';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = Quantity.parse(classJsonObj[fieldName]!, sourceField);
      instance.setDepth(datatype);
    }

    fieldName = 'weight';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = Quantity.parse(classJsonObj[fieldName]!, sourceField);
      instance.setWeight(datatype);
    }

    fieldName = 'nominalVolume';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = Quantity.parse(classJsonObj[fieldName]!, sourceField);
      instance.setNominalVolume(datatype);
    }

    fieldName = 'externalDiameter';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = Quantity.parse(classJsonObj[fieldName]!, sourceField);
      instance.setExternalDiameter(datatype);
    }

    fieldName = 'shape';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setShapeElement(datatype);
    }

    fieldName = 'color';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: StringType | undefined = fhirParser.parseStringType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addColorElement(datatype);
        }
      });
    }

    fieldName = 'imprint';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: StringType | undefined = fhirParser.parseStringType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addImprintElement(datatype);
        }
      });
    }

    fieldName = 'image';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Attachment | undefined = Attachment.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addImage(datatype);
        }
      });
    }

    fieldName = 'scoring';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = CodeableConcept.parse(classJsonObj[fieldName]!, sourceField);
      instance.setScoring(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * ProdCharacteristic.height Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Where applicable, the height can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used
   * - **Definition:** Where applicable, the height can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used.
   * - **FHIR Type:** \`Quantity\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private height?: Quantity | undefined;

  /**
   * ProdCharacteristic.width Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Where applicable, the width can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used
   * - **Definition:** Where applicable, the width can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used.
   * - **FHIR Type:** \`Quantity\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private width?: Quantity | undefined;

  /**
   * ProdCharacteristic.depth Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Where applicable, the depth can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used
   * - **Definition:** Where applicable, the depth can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used.
   * - **FHIR Type:** \`Quantity\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private depth?: Quantity | undefined;

  /**
   * ProdCharacteristic.weight Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Where applicable, the weight can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used
   * - **Definition:** Where applicable, the weight can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used.
   * - **FHIR Type:** \`Quantity\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private weight?: Quantity | undefined;

  /**
   * ProdCharacteristic.nominalVolume Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Where applicable, the nominal volume can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used
   * - **Definition:** Where applicable, the nominal volume can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used.
   * - **FHIR Type:** \`Quantity\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private nominalVolume?: Quantity | undefined;

  /**
   * ProdCharacteristic.externalDiameter Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Where applicable, the external diameter can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used
   * - **Definition:** Where applicable, the external diameter can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used.
   * - **FHIR Type:** \`Quantity\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private externalDiameter?: Quantity | undefined;

  /**
   * ProdCharacteristic.shape Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Where applicable, the shape can be specified An appropriate controlled vocabulary shall be used The term and the term identifier shall be used
   * - **Definition:** Where applicable, the shape can be specified An appropriate controlled vocabulary shall be used The term and the term identifier shall be used.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private shape?: StringType | undefined;

  /**
   * ProdCharacteristic.color Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Where applicable, the color can be specified An appropriate controlled vocabulary shall be used The term and the term identifier shall be used
   * - **Definition:** Where applicable, the color can be specified An appropriate controlled vocabulary shall be used The term and the term identifier shall be used.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private color?: StringType[] | undefined;

  /**
   * ProdCharacteristic.imprint Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Where applicable, the imprint can be specified as text
   * - **Definition:** Where applicable, the imprint can be specified as text.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private imprint?: StringType[] | undefined;

  /**
   * ProdCharacteristic.image Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Where applicable, the image can be provided The format of the image attachment shall be specified by regional implementations
   * - **Definition:** Where applicable, the image can be provided The format of the image attachment shall be specified by regional implementations.
   * - **FHIR Type:** \`Attachment\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private image?: Attachment[] | undefined;

  /**
   * ProdCharacteristic.scoring Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Where applicable, the scoring can be specified An appropriate controlled vocabulary shall be used The term and the term identifier shall be used
   * - **Definition:** Where applicable, the scoring can be specified An appropriate controlled vocabulary shall be used The term and the term identifier shall be used.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private scoring?: CodeableConcept | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`height\` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getHeight(): Quantity {
    return this.height ?? new Quantity();
  }

  /**
   * Assigns the provided Height object value to the \`height\` property.
   *
   * @param value - the \`height\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setHeight(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = \`Invalid ProdCharacteristic.height; Provided element is not an instance of Quantity.\`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.height = value;
    } else {
      this.height = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`height\` property exists and has a value; \`false\` otherwise
   */
  public hasHeight(): boolean {
    return isDefined<Quantity>(this.height) && !this.height.isEmpty();
  }

  /**
   * @returns the \`width\` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getWidth(): Quantity {
    return this.width ?? new Quantity();
  }

  /**
   * Assigns the provided Width object value to the \`width\` property.
   *
   * @param value - the \`width\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setWidth(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = \`Invalid ProdCharacteristic.width; Provided element is not an instance of Quantity.\`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.width = value;
    } else {
      this.width = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`width\` property exists and has a value; \`false\` otherwise
   */
  public hasWidth(): boolean {
    return isDefined<Quantity>(this.width) && !this.width.isEmpty();
  }

  /**
   * @returns the \`depth\` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getDepth(): Quantity {
    return this.depth ?? new Quantity();
  }

  /**
   * Assigns the provided Depth object value to the \`depth\` property.
   *
   * @param value - the \`depth\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setDepth(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = \`Invalid ProdCharacteristic.depth; Provided element is not an instance of Quantity.\`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.depth = value;
    } else {
      this.depth = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`depth\` property exists and has a value; \`false\` otherwise
   */
  public hasDepth(): boolean {
    return isDefined<Quantity>(this.depth) && !this.depth.isEmpty();
  }

  /**
   * @returns the \`weight\` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getWeight(): Quantity {
    return this.weight ?? new Quantity();
  }

  /**
   * Assigns the provided Weight object value to the \`weight\` property.
   *
   * @param value - the \`weight\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setWeight(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = \`Invalid ProdCharacteristic.weight; Provided element is not an instance of Quantity.\`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.weight = value;
    } else {
      this.weight = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`weight\` property exists and has a value; \`false\` otherwise
   */
  public hasWeight(): boolean {
    return isDefined<Quantity>(this.weight) && !this.weight.isEmpty();
  }

  /**
   * @returns the \`nominalVolume\` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getNominalVolume(): Quantity {
    return this.nominalVolume ?? new Quantity();
  }

  /**
   * Assigns the provided NominalVolume object value to the \`nominalVolume\` property.
   *
   * @param value - the \`nominalVolume\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setNominalVolume(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = \`Invalid ProdCharacteristic.nominalVolume; Provided element is not an instance of Quantity.\`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.nominalVolume = value;
    } else {
      this.nominalVolume = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`nominalVolume\` property exists and has a value; \`false\` otherwise
   */
  public hasNominalVolume(): boolean {
    return isDefined<Quantity>(this.nominalVolume) && !this.nominalVolume.isEmpty();
  }

  /**
   * @returns the \`externalDiameter\` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getExternalDiameter(): Quantity {
    return this.externalDiameter ?? new Quantity();
  }

  /**
   * Assigns the provided ExternalDiameter object value to the \`externalDiameter\` property.
   *
   * @param value - the \`externalDiameter\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setExternalDiameter(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = \`Invalid ProdCharacteristic.externalDiameter; Provided element is not an instance of Quantity.\`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.externalDiameter = value;
    } else {
      this.externalDiameter = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`externalDiameter\` property exists and has a value; \`false\` otherwise
   */
  public hasExternalDiameter(): boolean {
    return isDefined<Quantity>(this.externalDiameter) && !this.externalDiameter.isEmpty();
  }

  /**
   * @returns the \`shape\` property value as a StringType object if defined; else an empty StringType object
   */
  public getShapeElement(): StringType {
    return this.shape ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`shape\` property.
   *
   * @param element - the \`shape\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setShapeElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid ProdCharacteristic.shape; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.shape = element;
    } else {
      this.shape = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`shape\` property exists and has a value; \`false\` otherwise
   */
  public hasShapeElement(): boolean {
    return isDefined<StringType>(this.shape) && !this.shape.isEmpty();
  }

  /**
   * @returns the \`shape\` property value as a fhirString if defined; else undefined
   */
  public getShape(): fhirString | undefined {
    return this.shape?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`shape\` property.
   *
   * @param value - the \`shape\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setShape(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid ProdCharacteristic.shape (\${String(value)})\`;
      this.shape = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.shape = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`shape\` property exists and has a value; \`false\` otherwise
   */
  public hasShape(): boolean {
    return this.hasShapeElement();
  }

  /**
   * @returns the \`color\` property value as a StringType array
   */
  public getColorElement(): StringType[] {
    return this.color ?? ([] as StringType[]);
  }

  /**
   * Assigns the provided StringType array value to the \`color\` property.
   *
   * @param element - the \`color\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setColorElement(element: StringType[] | undefined): this {
    if (isDefinedList<StringType>(element)) {
      const optErrMsg = \`Invalid ProdCharacteristic.color; Provided value array has an element that is not an instance of StringType.\`;
      assertFhirTypeList<StringType>(element, StringType, optErrMsg);
      this.color = element;
    } else {
      this.color = undefined;
    }
    return this;
  }

  /**
   * Add the provided StringType value to the \`color\` array property.
   *
   * @param element - the \`color\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addColorElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid ProdCharacteristic.color; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.initColor();
      this.color?.push(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`color\` property exists and has a value; \`false\` otherwise
   */
  public hasColorElement(): boolean {
    return isDefinedList<StringType>(this.color) && this.color.some((item: StringType) => !item.isEmpty());
  }

  /**
   * @returns the \`color\` property value as a fhirString array
   */
  public getColor(): fhirString[] {
    this.initColor();
    const colorValues = [] as fhirString[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.color!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        colorValues.push(value);
      }
    }
    return colorValues;
  }

  /**
   * Assigns the provided primitive value array to the \`color\` property.
   *
   * @param value - the \`color\` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setColor(value: fhirString[] | undefined): this {
    if (isDefinedList<fhirString>(value)) {
      const colorElements = [] as StringType[];
      for (const colorValue of value) {
        const optErrMsg = \`Invalid ProdCharacteristic.color array item (\${String(colorValue)})\`;
        const element = new StringType(parseFhirPrimitiveData(colorValue, fhirStringSchema, optErrMsg));
        colorElements.push(element);
      }
      this.color = colorElements;
    } else {
      this.color = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`color\` array property.
   *
   * @param value - the \`color\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addColor(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid ProdCharacteristic.color array item (\${String(value)})\`;
      const element = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
      this.initColor();
      this.addColorElement(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`color\` property exists and has a value; \`false\` otherwise
   */
  public hasColor(): boolean {
    return this.hasColorElement();
  }

  /**
   * Initialize the \`color\` property
   */
  private initColor(): void {
    if (!this.hasColor()) {
      this.color = [] as StringType[];
    }
  }

  /**
   * @returns the \`imprint\` property value as a StringType array
   */
  public getImprintElement(): StringType[] {
    return this.imprint ?? ([] as StringType[]);
  }

  /**
   * Assigns the provided StringType array value to the \`imprint\` property.
   *
   * @param element - the \`imprint\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setImprintElement(element: StringType[] | undefined): this {
    if (isDefinedList<StringType>(element)) {
      const optErrMsg = \`Invalid ProdCharacteristic.imprint; Provided value array has an element that is not an instance of StringType.\`;
      assertFhirTypeList<StringType>(element, StringType, optErrMsg);
      this.imprint = element;
    } else {
      this.imprint = undefined;
    }
    return this;
  }

  /**
   * Add the provided StringType value to the \`imprint\` array property.
   *
   * @param element - the \`imprint\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addImprintElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid ProdCharacteristic.imprint; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.initImprint();
      this.imprint?.push(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`imprint\` property exists and has a value; \`false\` otherwise
   */
  public hasImprintElement(): boolean {
    return isDefinedList<StringType>(this.imprint) && this.imprint.some((item: StringType) => !item.isEmpty());
  }

  /**
   * @returns the \`imprint\` property value as a fhirString array
   */
  public getImprint(): fhirString[] {
    this.initImprint();
    const imprintValues = [] as fhirString[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.imprint!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        imprintValues.push(value);
      }
    }
    return imprintValues;
  }

  /**
   * Assigns the provided primitive value array to the \`imprint\` property.
   *
   * @param value - the \`imprint\` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setImprint(value: fhirString[] | undefined): this {
    if (isDefinedList<fhirString>(value)) {
      const imprintElements = [] as StringType[];
      for (const imprintValue of value) {
        const optErrMsg = \`Invalid ProdCharacteristic.imprint array item (\${String(imprintValue)})\`;
        const element = new StringType(parseFhirPrimitiveData(imprintValue, fhirStringSchema, optErrMsg));
        imprintElements.push(element);
      }
      this.imprint = imprintElements;
    } else {
      this.imprint = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`imprint\` array property.
   *
   * @param value - the \`imprint\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addImprint(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid ProdCharacteristic.imprint array item (\${String(value)})\`;
      const element = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
      this.initImprint();
      this.addImprintElement(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`imprint\` property exists and has a value; \`false\` otherwise
   */
  public hasImprint(): boolean {
    return this.hasImprintElement();
  }

  /**
   * Initialize the \`imprint\` property
   */
  private initImprint(): void {
    if (!this.hasImprint()) {
      this.imprint = [] as StringType[];
    }
  }

  /**
   * @returns the \`image\` property value as a Attachment array
   */
  public getImage(): Attachment[] {
    return this.image ?? ([] as Attachment[]);
  }

  /**
   * Assigns the provided Attachment array value to the \`image\` property.
   *
   * @param value - the \`image\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setImage(value: Attachment[] | undefined): this {
    if (isDefinedList<Attachment>(value)) {
      const optErrMsg = \`Invalid ProdCharacteristic.image; Provided value array has an element that is not an instance of Attachment.\`;
      assertFhirTypeList<Attachment>(value, Attachment, optErrMsg);
      this.image = value;
    } else {
      this.image = undefined;
    }
    return this;
  }

  /**
   * Add the provided Attachment value to the \`image\` array property.
   *
   * @param value - the \`image\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addImage(value: Attachment | undefined): this {
    if (isDefined<Attachment>(value)) {
      const optErrMsg = \`Invalid ProdCharacteristic.image; Provided element is not an instance of Attachment.\`;
      assertFhirType<Attachment>(value, Attachment, optErrMsg);
      this.initImage();
      this.image?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`image\` property exists and has a value; \`false\` otherwise
   */
  public hasImage(): boolean {
    return isDefinedList<Attachment>(this.image) && this.image.some((item: Attachment) => !item.isEmpty());
  }

  /**
   * Initialize the \`image\` property
   */
  private initImage(): void {
    if(!this.hasImage()) {
      this.image = [] as Attachment[];
    }
  }

  /**
   * @returns the \`scoring\` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getScoring(): CodeableConcept {
    return this.scoring ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Scoring object value to the \`scoring\` property.
   *
   * @param value - the \`scoring\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setScoring(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid ProdCharacteristic.scoring; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.scoring = value;
    } else {
      this.scoring = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`scoring\` property exists and has a value; \`false\` otherwise
   */
  public hasScoring(): boolean {
    return isDefined<CodeableConcept>(this.scoring) && !this.scoring.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'ProdCharacteristic';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.height,
      this.width,
      this.depth,
      this.weight,
      this.nominalVolume,
      this.externalDiameter,
      this.shape,
      this.color,
      this.imprint,
      this.image,
      this.scoring,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): ProdCharacteristic {
    const dest = new ProdCharacteristic();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: ProdCharacteristic): void {
    super.copyValues(dest);
    dest.height = this.height?.copy();
    dest.width = this.width?.copy();
    dest.depth = this.depth?.copy();
    dest.weight = this.weight?.copy();
    dest.nominalVolume = this.nominalVolume?.copy();
    dest.externalDiameter = this.externalDiameter?.copy();
    dest.shape = this.shape?.copy();
    const colorList = copyListValues<StringType>(this.color);
    dest.color = colorList.length === 0 ? undefined : colorList;
    const imprintList = copyListValues<StringType>(this.imprint);
    dest.imprint = imprintList.length === 0 ? undefined : imprintList;
    const imageList = copyListValues<Attachment>(this.image);
    dest.image = imageList.length === 0 ? undefined : imageList;
    dest.scoring = this.scoring?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', \`UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasHeight()) {
      setFhirComplexJson(this.getHeight(), 'height', jsonObj);
    }

    if (this.hasWidth()) {
      setFhirComplexJson(this.getWidth(), 'width', jsonObj);
    }

    if (this.hasDepth()) {
      setFhirComplexJson(this.getDepth(), 'depth', jsonObj);
    }

    if (this.hasWeight()) {
      setFhirComplexJson(this.getWeight(), 'weight', jsonObj);
    }

    if (this.hasNominalVolume()) {
      setFhirComplexJson(this.getNominalVolume(), 'nominalVolume', jsonObj);
    }

    if (this.hasExternalDiameter()) {
      setFhirComplexJson(this.getExternalDiameter(), 'externalDiameter', jsonObj);
    }

    if (this.hasShapeElement()) {
      setFhirPrimitiveJson<fhirString>(this.getShapeElement(), 'shape', jsonObj);
    }

    if (this.hasColor()) {
      setFhirPrimitiveListJson(this.getColorElement(), 'color', jsonObj);
    }

    if (this.hasImprint()) {
      setFhirPrimitiveListJson(this.getImprintElement(), 'imprint', jsonObj);
    }

    if (this.hasImage()) {
      setFhirComplexListJson(this.getImage(), 'image', jsonObj);
    }

    if (this.hasScoring()) {
      setFhirComplexJson(this.getScoring(), 'scoring', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * ProductShelfLife Class
 *
 * @remarks
 * Base StructureDefinition for ProductShelfLife Type: The shelf-life and storage information for a medicinal product item or container can be described using this class.
 *
 * **FHIR Specification**
 * - **Short:** The shelf-life and storage information for a medicinal product item or container can be described using this class
 * - **Definition:** The shelf-life and storage information for a medicinal product item or container can be described using this class.
 * - **FHIR Version:** 4.0.1
 *
 * @category Data Models: ComplexType
 * @see [FHIR ProductShelfLife](http://hl7.org/fhir/StructureDefinition/ProductShelfLife)
 */
/* istanbul ignore next */ export class ProductShelfLife extends BackboneType implements IBackboneType {
  constructor(type_: CodeableConcept | null = null, period: Quantity | null = null) {
    super();

    this.type_ = null;
    if (isDefined<CodeableConcept>(type_)) {
      this.setType(type_);
    }

    this.period = null;
    if (isDefined<Quantity>(period)) {
      this.setPeriod(period);
    }
  }

  /**
   * Parse the provided \`ProductShelfLife\` JSON to instantiate the ProductShelfLife data model.
   *
   * @param sourceJson - JSON representing FHIR \`ProductShelfLife\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to ProductShelfLife
   * @returns ProductShelfLife data model or undefined for \`ProductShelfLife\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): ProductShelfLife | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'ProductShelfLife';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new ProductShelfLife();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneTypeJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';

    const missingReqdProperties: string[] = [];

    fieldName = 'identifier';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Identifier | undefined = Identifier.parse(classJsonObj[fieldName]!, sourceField);
      instance.setIdentifier(datatype);
    }

    fieldName = 'type';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = CodeableConcept.parse(classJsonObj[fieldName]!, sourceField);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setType(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'period';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = Quantity.parse(classJsonObj[fieldName]!, sourceField);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setPeriod(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'specialPrecautionsForStorage';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: CodeableConcept | undefined = CodeableConcept.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addSpecialPrecautionsForStorage(datatype);
        }
      });
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * ProductShelfLife.identifier Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Unique identifier for the packaged Medicinal Product
   * - **Definition:** Unique identifier for the packaged Medicinal Product.
   * - **FHIR Type:** \`Identifier\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private identifier?: Identifier | undefined;

  /**
   * ProductShelfLife.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** This describes the shelf life, taking into account various scenarios such as shelf life of the packaged Medicinal Product itself, shelf life after transformation where necessary and shelf life after the first opening of a bottle, etc. The shelf life type shall be specified using an appropriate controlled vocabulary The controlled term and the controlled term identifier shall be specified
   * - **Definition:** This describes the shelf life, taking into account various scenarios such as shelf life of the packaged Medicinal Product itself, shelf life after transformation where necessary and shelf life after the first opening of a bottle, etc. The shelf life type shall be specified using an appropriate controlled vocabulary The controlled term and the controlled term identifier shall be specified.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private type_: CodeableConcept | null;

  /**
   * ProductShelfLife.period Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The shelf life time period can be specified using a numerical value for the period of time and its unit of time measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used
   * - **Definition:** The shelf life time period can be specified using a numerical value for the period of time and its unit of time measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used.
   * - **FHIR Type:** \`Quantity\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private period: Quantity | null;

  /**
   * ProductShelfLife.specialPrecautionsForStorage Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Special precautions for storage, if any, can be specified using an appropriate controlled vocabulary The controlled term and the controlled term identifier shall be specified
   * - **Definition:** Special precautions for storage, if any, can be specified using an appropriate controlled vocabulary The controlled term and the controlled term identifier shall be specified.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private specialPrecautionsForStorage?: CodeableConcept[] | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`identifier\` property value as a Identifier object if defined; else an empty Identifier object
   */
  public getIdentifier(): Identifier {
    return this.identifier ?? new Identifier();
  }

  /**
   * Assigns the provided Identifier object value to the \`identifier\` property.
   *
   * @param value - the \`identifier\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setIdentifier(value: Identifier | undefined): this {
    if (isDefined<Identifier>(value)) {
      const optErrMsg = \`Invalid ProductShelfLife.identifier; Provided element is not an instance of Identifier.\`;
      assertFhirType<Identifier>(value, Identifier, optErrMsg);
      this.identifier = value;
    } else {
      this.identifier = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`identifier\` property exists and has a value; \`false\` otherwise
   */
  public hasIdentifier(): boolean {
    return isDefined<Identifier>(this.identifier) && !this.identifier.isEmpty();
  }

  /**
   * @returns the \`type_\` property value as a CodeableConcept object if defined; else null
   */
  public getType(): CodeableConcept | null {
    return this.type_;
  }

  /**
   * Assigns the provided CodeableConcept object value to the \`type_\` property.
   *
   * @param value - the \`type_\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setType(value: CodeableConcept): this {
    assertIsDefined<CodeableConcept>(value, \`ProductShelfLife.type is required\`);
    const optErrMsg = \`Invalid ProductShelfLife.type; Provided element is not an instance of CodeableConcept.\`;
    assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
    this.type_ = value;
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasType(): boolean {
    return isDefined<CodeableConcept>(this.type_) && !this.type_.isEmpty();
  }

  /**
   * @returns the \`period\` property value as a Quantity object if defined; else null
   */
  public getPeriod(): Quantity | null {
    return this.period;
  }

  /**
   * Assigns the provided Quantity object value to the \`period\` property.
   *
   * @param value - the \`period\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setPeriod(value: Quantity): this {
    assertIsDefined<Quantity>(value, \`ProductShelfLife.period is required\`);
    const optErrMsg = \`Invalid ProductShelfLife.period; Provided element is not an instance of Quantity.\`;
    assertFhirType<Quantity>(value, Quantity, optErrMsg);
    this.period = value;
    return this;
  }

  /**
   * @returns \`true\` if the \`period\` property exists and has a value; \`false\` otherwise
   */
  public hasPeriod(): boolean {
    return isDefined<Quantity>(this.period) && !this.period.isEmpty();
  }

  /**
   * @returns the \`specialPrecautionsForStorage\` property value as a CodeableConcept array
   */
  public getSpecialPrecautionsForStorage(): CodeableConcept[] {
    return this.specialPrecautionsForStorage ?? ([] as CodeableConcept[]);
  }

  /**
   * Assigns the provided CodeableConcept array value to the \`specialPrecautionsForStorage\` property.
   *
   * @param value - the \`specialPrecautionsForStorage\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setSpecialPrecautionsForStorage(value: CodeableConcept[] | undefined): this {
    if (isDefinedList<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid ProductShelfLife.specialPrecautionsForStorage; Provided value array has an element that is not an instance of CodeableConcept.\`;
      assertFhirTypeList<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.specialPrecautionsForStorage = value;
    } else {
      this.specialPrecautionsForStorage = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeableConcept value to the \`specialPrecautionsForStorage\` array property.
   *
   * @param value - the \`specialPrecautionsForStorage\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addSpecialPrecautionsForStorage(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid ProductShelfLife.specialPrecautionsForStorage; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.initSpecialPrecautionsForStorage();
      this.specialPrecautionsForStorage?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`specialPrecautionsForStorage\` property exists and has a value; \`false\` otherwise
   */
  public hasSpecialPrecautionsForStorage(): boolean {
    return isDefinedList<CodeableConcept>(this.specialPrecautionsForStorage) && this.specialPrecautionsForStorage.some((item: CodeableConcept) => !item.isEmpty());
  }

  /**
   * Initialize the \`specialPrecautionsForStorage\` property
   */
  private initSpecialPrecautionsForStorage(): void {
    if(!this.hasSpecialPrecautionsForStorage()) {
      this.specialPrecautionsForStorage = [] as CodeableConcept[];
    }
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'ProductShelfLife';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.identifier,
      this.type_,
      this.period,
      this.specialPrecautionsForStorage,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): ProductShelfLife {
    const dest = new ProductShelfLife();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: ProductShelfLife): void {
    super.copyValues(dest);
    dest.identifier = this.identifier?.copy();
    dest.type_ = this.type_ ? this.type_.copy() : null;
    dest.period = this.period ? this.period.copy() : null;
    const specialPrecautionsForStorageList = copyListValues<CodeableConcept>(this.specialPrecautionsForStorage);
    dest.specialPrecautionsForStorage = specialPrecautionsForStorageList.length === 0 ? undefined : specialPrecautionsForStorageList;
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', \`UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasIdentifier()) {
      setFhirComplexJson(this.getIdentifier(), 'identifier', jsonObj);
    }

    if (this.hasType()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirComplexJson(this.getType()!, 'type', jsonObj);
    } else {
      missingReqdProperties.push(\`ProductShelfLife.type\`);
    }

    if (this.hasPeriod()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirComplexJson(this.getPeriod()!, 'period', jsonObj);
    } else {
      missingReqdProperties.push(\`ProductShelfLife.period\`);
    }

    if (this.hasSpecialPrecautionsForStorage()) {
      setFhirComplexListJson(this.getSpecialPrecautionsForStorage(), 'specialPrecautionsForStorage', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

/**
 * Quantity Class
 *
 * @remarks
 * Base StructureDefinition for Quantity Type: A measured amount (or an amount that can potentially be measured). Note that measured amounts include amounts that are not precisely quantified, including amounts involving arbitrary units and floating currencies.
 *
 * Need to able to capture all sorts of measured values, even if the measured value are not precisely quantified. Values include exact measures such as 3.51g, customary units such as 3 tablets, and currencies such as $100.32USD.
 *
 * **FHIR Specification**
 * - **Short:** A measured or measurable amount
 * - **Definition:** A measured amount (or an amount that can potentially be measured). Note that measured amounts include amounts that are not precisely quantified, including amounts involving arbitrary units and floating currencies.
 * - **Comment:** The context of use may frequently define what kind of quantity this is and therefore what kind of units can be used. The context of use may also restrict the values for the comparator.
 * - **FHIR Version:** 4.0.1
 *
 * @category Data Models: ComplexType
 * @see [FHIR Quantity](http://hl7.org/fhir/StructureDefinition/Quantity)
 */
/* istanbul ignore next */ export class Quantity extends DataType implements IDataType {
  constructor() {
    super();

    this.quantityComparatorEnum = new QuantityComparatorEnum();
  }

  /**
   * Parse the provided \`Quantity\` JSON to instantiate the Quantity data model.
   *
   * @param sourceJson - JSON representing FHIR \`Quantity\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Quantity
   * @returns Quantity data model or undefined for \`Quantity\`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Quantity | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Quantity';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Quantity();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'value';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setValueElement(datatype);
    }

    fieldName = 'comparator';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setComparatorElement(datatype);
    }

    fieldName = 'unit';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setUnitElement(datatype);
    }

    fieldName = 'system';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = fhirParser.parseUriType(dtJson, dtSiblingJson);
      instance.setSystemElement(datatype);
    }

    fieldName = 'code';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setCodeElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Quantity.value Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Numerical value (with implicit precision)
   * - **Definition:** The value of the measured amount. The value includes an implicit precision in the presentation of the value.
   * - **Comment:** The implicit precision in the value should always be honored. Monetary values have their own rules for handling precision (refer to standard accounting text books).
   * - **Requirements:** Precision is handled implicitly in almost all cases of measurement.
   * - **FHIR Type:** \`decimal\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private value?: DecimalType | undefined;

  /**
   * FHIR CodeSystem: QuantityComparator
   *
   * @see {@link QuantityComparatorEnum }
   */
  private readonly quantityComparatorEnum: QuantityComparatorEnum;

  /**
   * Quantity.comparator Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** < | <= | >= | > - how to understand the value
   * - **Definition:** How the value should be understood and represented - whether the actual value is greater or less than the stated value due to measurement issues; e.g. if the comparator is "<" , then the real value is < stated value.
   * - **Requirements:** Need a framework for handling measures where the value is <5ug/L or >400mg/L due to the limitations of measuring methodology.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** true
   * - **isModifierReason:** This is labeled as &quot;Is Modifier&quot; because the comparator modifies the interpretation of the value significantly. If there is no comparator, then there is no modification of the value
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  private comparator?: EnumCodeType | undefined;

  /**
   * Quantity.unit Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Unit representation
   * - **Definition:** A human-readable form of the unit.
   * - **Requirements:** There are many representations for units of measure and in many contexts, particular representations are fixed and required. I.e. mcg for micrograms.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private unit?: StringType | undefined;

  /**
   * Quantity.system Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** System that defines coded unit form
   * - **Definition:** The identification of the system that provides the coded form of the unit.
   * - **Requirements:** Need to know the system that defines the coded form of the unit.
   * - **FHIR Type:** \`uri\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private system?: UriType | undefined;

  /**
   * Quantity.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Coded form of the unit
   * - **Definition:** A computer processable form of the unit in some unit representation system.
   * - **Comment:** The preferred system is UCUM, but SNOMED CT can also be used (for customary units) or ISO 4217 for currency.  The context of use may additionally require a code from a particular system.
   * - **Requirements:** Need a computable form of the unit that is fixed across all forms. UCUM provides this for quantities, but SNOMED CT provides many units of interest.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code?: CodeType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`value\` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getValueElement(): DecimalType {
    return this.value ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`value\` property.
   *
   * @param element - the \`value\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValueElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = \`Invalid Quantity.value; Provided element is not an instance of DecimalType.\`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.value = element;
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`value\` property exists and has a value; \`false\` otherwise
   */
  public hasValueElement(): boolean {
    return isDefined<DecimalType>(this.value) && !this.value.isEmpty();
  }

  /**
   * @returns the \`value\` property value as a fhirDecimal if defined; else undefined
   */
  public getValue(): fhirDecimal | undefined {
    return this.value?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`value\` property.
   *
   * @param value - the \`value\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValue(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = \`Invalid Quantity.value (\${String(value)})\`;
      this.value = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`value\` property exists and has a value; \`false\` otherwise
   */
  public hasValue(): boolean {
    return this.hasValueElement();
  }

  /**
   * @returns the \`comparator\` property value as a EnumCodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public getComparatorEnumType(): EnumCodeType | undefined {
    return this.comparator;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`comparator\` property.
   *
   * @param enumType - the \`comparator\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code values
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public setComparatorEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid Quantity.comparator';
      assertEnumCodeType<QuantityComparatorEnum>(enumType, QuantityComparatorEnum, errMsgPrefix);
      this.comparator = enumType;
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`comparator\` property exists and has a value; \`false\` otherwise
   */
  public hasComparatorEnumType(): boolean {
    return isDefined<EnumCodeType>(this.comparator) && !this.comparator.isEmpty() && this.comparator.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`comparator\` property value as a CodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public getComparatorElement(): CodeType | undefined {
    if (this.comparator === undefined) {
      return undefined;
    }
    return this.comparator as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`comparator\` property.
   *
   * @param element - the \`comparator\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public setComparatorElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Quantity.comparator; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.comparator = new EnumCodeType(element, this.quantityComparatorEnum);
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`comparator\` property exists and has a value; \`false\` otherwise
   */
  public hasComparatorElement(): boolean {
    return this.hasComparatorEnumType();
  }

  /**
   * @returns the \`comparator\` property value as a fhirCode if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public getComparator(): fhirCode | undefined {
    if (this.comparator === undefined) {
      return undefined;
    }
    return this.comparator.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`comparator\` property.
   *
   * @param value - the \`comparator\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public setComparator(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Quantity.comparator; Provided value is not an instance of fhirCode.\`;
      this.comparator = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.quantityComparatorEnum);
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`comparator\` property exists and has a value; \`false\` otherwise
   */
  public hasComparator(): boolean {
    return this.hasComparatorEnumType();
  }

  /**
   * @returns the \`unit\` property value as a StringType object if defined; else an empty StringType object
   */
  public getUnitElement(): StringType {
    return this.unit ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`unit\` property.
   *
   * @param element - the \`unit\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUnitElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Quantity.unit; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.unit = element;
    } else {
      this.unit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`unit\` property exists and has a value; \`false\` otherwise
   */
  public hasUnitElement(): boolean {
    return isDefined<StringType>(this.unit) && !this.unit.isEmpty();
  }

  /**
   * @returns the \`unit\` property value as a fhirString if defined; else undefined
   */
  public getUnit(): fhirString | undefined {
    return this.unit?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`unit\` property.
   *
   * @param value - the \`unit\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUnit(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Quantity.unit (\${String(value)})\`;
      this.unit = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.unit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`unit\` property exists and has a value; \`false\` otherwise
   */
  public hasUnit(): boolean {
    return this.hasUnitElement();
  }

  /**
   * @returns the \`system\` property value as a UriType object if defined; else an empty UriType object
   */
  public getSystemElement(): UriType {
    return this.system ?? new UriType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`system\` property.
   *
   * @param element - the \`system\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSystemElement(element: UriType | undefined): this {
    if (isDefined<UriType>(element)) {
      const optErrMsg = \`Invalid Quantity.system; Provided element is not an instance of UriType.\`;
      assertFhirType<UriType>(element, UriType, optErrMsg);
      this.system = element;
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`system\` property exists and has a value; \`false\` otherwise
   */
  public hasSystemElement(): boolean {
    return isDefined<UriType>(this.system) && !this.system.isEmpty();
  }

  /**
   * @returns the \`system\` property value as a fhirUri if defined; else undefined
   */
  public getSystem(): fhirUri | undefined {
    return this.system?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`system\` property.
   *
   * @param value - the \`system\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSystem(value: fhirUri | undefined): this {
    if (isDefined<fhirUri>(value)) {
      const optErrMsg = \`Invalid Quantity.system (\${String(value)})\`;
      this.system = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`system\` property exists and has a value; \`false\` otherwise
   */
  public hasSystem(): boolean {
    return this.hasSystemElement();
  }

  /**
   * @returns the \`code\` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getCodeElement(): CodeType {
    return this.code ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`code\` property.
   *
   * @param element - the \`code\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCodeElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Quantity.code; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.code = element;
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`code\` property exists and has a value; \`false\` otherwise
   */
  public hasCodeElement(): boolean {
    return isDefined<CodeType>(this.code) && !this.code.isEmpty();
  }

  /**
   * @returns the \`code\` property value as a fhirCode if defined; else undefined
   */
  public getCode(): fhirCode | undefined {
    return this.code?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`code\` property.
   *
   * @param value - the \`code\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCode(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Quantity.code (\${String(value)})\`;
      this.code = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`code\` property exists and has a value; \`false\` otherwise
   */
  public hasCode(): boolean {
    return this.hasCodeElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Quantity';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.value,
      this.comparator,
      this.unit,
      this.system,
      this.code,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Quantity {
    const dest = new Quantity();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Quantity): void {
    super.copyValues(dest);
    dest.value = this.value?.copy();
    dest.comparator = this.comparator?.copy();
    dest.unit = this.unit?.copy();
    dest.system = this.system?.copy();
    dest.code = this.code?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', \`UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasValueElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getValueElement(), 'value', jsonObj);
    }

    if (this.hasComparatorElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getComparatorElement()!, 'comparator', jsonObj);
    }

    if (this.hasUnitElement()) {
      setFhirPrimitiveJson<fhirString>(this.getUnitElement(), 'unit', jsonObj);
    }

    if (this.hasSystemElement()) {
      setFhirPrimitiveJson<fhirUri>(this.getSystemElement(), 'system', jsonObj);
    }

    if (this.hasCodeElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getCodeElement(), 'code', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * Range Class
 *
 * @remarks
 * Base StructureDefinition for Range Type: A set of ordered Quantities defined by a low and high limit.
 *
 * Need to be able to specify ranges of values.
 *
 * **FHIR Specification**
 * - **Short:** Set of values bounded by low and high
 * - **Definition:** A set of ordered Quantities defined by a low and high limit.
 * - **Comment:** The stated low and high value are assumed to have arbitrarily high precision when it comes to determining which values are in the range. I.e. 1.99 is not in the range 2 -> 3.
 * - **FHIR Version:** 4.0.1
 *
 * @category Data Models: ComplexType
 * @see [FHIR Range](http://hl7.org/fhir/StructureDefinition/Range)
 */
/* istanbul ignore next */ export class Range extends DataType implements IDataType {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`Range\` JSON to instantiate the Range data model.
   *
   * @param sourceJson - JSON representing FHIR \`Range\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Range
   * @returns Range data model or undefined for \`Range\`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Range | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Range';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Range();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';

    fieldName = 'low';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = Quantity.parse(classJsonObj[fieldName]!, sourceField);
      instance.setLow(datatype);
    }

    fieldName = 'high';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = Quantity.parse(classJsonObj[fieldName]!, sourceField);
      instance.setHigh(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Range.low Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Low limit
   * - **Definition:** The low limit. The boundary is inclusive.
   * - **Comment:** If the low element is missing, the low boundary is not known.
   * - **FHIR Type:** \`Quantity\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private low?: Quantity | undefined;

  /**
   * Range.high Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** High limit
   * - **Definition:** The high limit. The boundary is inclusive.
   * - **Comment:** If the high element is missing, the high boundary is not known.
   * - **FHIR Type:** \`Quantity\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private high?: Quantity | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`low\` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getLow(): Quantity {
    return this.low ?? new Quantity();
  }

  /**
   * Assigns the provided Low object value to the \`low\` property.
   *
   * @param value - the \`low\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setLow(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = \`Invalid Range.low; Provided element is not an instance of Quantity.\`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.low = value;
    } else {
      this.low = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`low\` property exists and has a value; \`false\` otherwise
   */
  public hasLow(): boolean {
    return isDefined<Quantity>(this.low) && !this.low.isEmpty();
  }

  /**
   * @returns the \`high\` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getHigh(): Quantity {
    return this.high ?? new Quantity();
  }

  /**
   * Assigns the provided High object value to the \`high\` property.
   *
   * @param value - the \`high\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setHigh(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = \`Invalid Range.high; Provided element is not an instance of Quantity.\`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.high = value;
    } else {
      this.high = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`high\` property exists and has a value; \`false\` otherwise
   */
  public hasHigh(): boolean {
    return isDefined<Quantity>(this.high) && !this.high.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Range';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.low,
      this.high,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Range {
    const dest = new Range();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Range): void {
    super.copyValues(dest);
    dest.low = this.low?.copy();
    dest.high = this.high?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', \`UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasLow()) {
      setFhirComplexJson(this.getLow(), 'low', jsonObj);
    }

    if (this.hasHigh()) {
      setFhirComplexJson(this.getHigh(), 'high', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * Ratio Class
 *
 * @remarks
 * Base StructureDefinition for Ratio Type: A relationship of two Quantity values - expressed as a numerator and a denominator.
 *
 * Need to able to capture ratios for some measurements (titers) and some rates (costs).
 *
 * **FHIR Specification**
 * - **Short:** A ratio of two Quantity values - a numerator and a denominator
 * - **Definition:** A relationship of two Quantity values - expressed as a numerator and a denominator.
 * - **Comment:** The Ratio datatype should only be used to express a relationship of two numbers if the relationship cannot be suitably expressed using a Quantity and a common unit.  Where the denominator value is known to be fixed to "1", Quantity should be used instead of Ratio.
 * - **FHIR Version:** 4.0.1
 *
 * @category Data Models: ComplexType
 * @see [FHIR Ratio](http://hl7.org/fhir/StructureDefinition/Ratio)
 */
/* istanbul ignore next */ export class Ratio extends DataType implements IDataType {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`Ratio\` JSON to instantiate the Ratio data model.
   *
   * @param sourceJson - JSON representing FHIR \`Ratio\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Ratio
   * @returns Ratio data model or undefined for \`Ratio\`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Ratio | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Ratio';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Ratio();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';

    fieldName = 'numerator';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = Quantity.parse(classJsonObj[fieldName]!, sourceField);
      instance.setNumerator(datatype);
    }

    fieldName = 'denominator';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = Quantity.parse(classJsonObj[fieldName]!, sourceField);
      instance.setDenominator(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Ratio.numerator Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Numerator value
   * - **Definition:** The value of the numerator.
   * - **FHIR Type:** \`Quantity\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private numerator?: Quantity | undefined;

  /**
   * Ratio.denominator Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Denominator value
   * - **Definition:** The value of the denominator.
   * - **FHIR Type:** \`Quantity\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private denominator?: Quantity | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`numerator\` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getNumerator(): Quantity {
    return this.numerator ?? new Quantity();
  }

  /**
   * Assigns the provided Numerator object value to the \`numerator\` property.
   *
   * @param value - the \`numerator\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setNumerator(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = \`Invalid Ratio.numerator; Provided element is not an instance of Quantity.\`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.numerator = value;
    } else {
      this.numerator = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`numerator\` property exists and has a value; \`false\` otherwise
   */
  public hasNumerator(): boolean {
    return isDefined<Quantity>(this.numerator) && !this.numerator.isEmpty();
  }

  /**
   * @returns the \`denominator\` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getDenominator(): Quantity {
    return this.denominator ?? new Quantity();
  }

  /**
   * Assigns the provided Denominator object value to the \`denominator\` property.
   *
   * @param value - the \`denominator\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setDenominator(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = \`Invalid Ratio.denominator; Provided element is not an instance of Quantity.\`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.denominator = value;
    } else {
      this.denominator = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`denominator\` property exists and has a value; \`false\` otherwise
   */
  public hasDenominator(): boolean {
    return isDefined<Quantity>(this.denominator) && !this.denominator.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Ratio';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.numerator,
      this.denominator,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Ratio {
    const dest = new Ratio();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Ratio): void {
    super.copyValues(dest);
    dest.numerator = this.numerator?.copy();
    dest.denominator = this.denominator?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', \`UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasNumerator()) {
      setFhirComplexJson(this.getNumerator(), 'numerator', jsonObj);
    }

    if (this.hasDenominator()) {
      setFhirComplexJson(this.getDenominator(), 'denominator', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * RelatedArtifact Class
 *
 * @remarks
 * Base StructureDefinition for RelatedArtifact Type: Related artifacts such as additional documentation, justification, or bibliographic references.
 *
 * Knowledge resources must be able to provide enough information for consumers of the content (and/or interventions or results produced by the content) to be able to determine and understand the justification for and evidence in support of the content.
 *
 * **FHIR Specification**
 * - **Short:** Related artifacts for a knowledge resource
 * - **Definition:** Related artifacts such as additional documentation, justification, or bibliographic references.
 * - **Comment:** Each related artifact is either an attachment, or a reference to another knowledge resource, but not both.
 * - **FHIR Version:** 4.0.1
 *
 * @category Data Models: ComplexType
 * @see [FHIR RelatedArtifact](http://hl7.org/fhir/StructureDefinition/RelatedArtifact)
 */
/* istanbul ignore next */ export class RelatedArtifact extends DataType implements IDataType {
  constructor(type_: EnumCodeType | CodeType | fhirCode | null = null) {
    super();

    this.relatedArtifactTypeEnum = new RelatedArtifactTypeEnum();

    this.type_ = constructorCodeValueAsEnumCodeType<RelatedArtifactTypeEnum>(
      type_,
      RelatedArtifactTypeEnum,
      this.relatedArtifactTypeEnum,
      'RelatedArtifact.type',
    );
  }

  /**
   * Parse the provided \`RelatedArtifact\` JSON to instantiate the RelatedArtifact data model.
   *
   * @param sourceJson - JSON representing FHIR \`RelatedArtifact\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to RelatedArtifact
   * @returns RelatedArtifact data model or undefined for \`RelatedArtifact\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): RelatedArtifact | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'RelatedArtifact';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new RelatedArtifact();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'type';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setTypeElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'label';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setLabelElement(datatype);
    }

    fieldName = 'display';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setDisplayElement(datatype);
    }

    fieldName = 'citation';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: MarkdownType | undefined = fhirParser.parseMarkdownType(dtJson, dtSiblingJson);
      instance.setCitationElement(datatype);
    }

    fieldName = 'url';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UrlType | undefined = fhirParser.parseUrlType(dtJson, dtSiblingJson);
      instance.setUrlElement(datatype);
    }

    fieldName = 'document';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Attachment | undefined = Attachment.parse(classJsonObj[fieldName]!, sourceField);
      instance.setDocument(datatype);
    }

    fieldName = 'resource';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CanonicalType | undefined = fhirParser.parseCanonicalType(dtJson, dtSiblingJson);
      instance.setResourceElement(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: RelatedArtifactType
   *
   * @see {@link RelatedArtifactTypeEnum }
   */
  private readonly relatedArtifactTypeEnum: RelatedArtifactTypeEnum;

  /**
   * RelatedArtifact.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** documentation | justification | citation | predecessor | successor | derived-from | depends-on | composed-of
   * - **Definition:** The type of relationship to the related artifact.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link RelatedArtifactTypeEnum }
   */
  private type_: EnumCodeType | null;

  /**
   * RelatedArtifact.label Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Short label
   * - **Definition:** A short label that can be used to reference the citation from elsewhere in the containing artifact, such as a footnote index.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private label?: StringType | undefined;

  /**
   * RelatedArtifact.display Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Brief description of the related artifact
   * - **Definition:** A brief description of the document or knowledge resource being referenced, suitable for display to a consumer.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private display?: StringType | undefined;

  /**
   * RelatedArtifact.citation Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Bibliographic citation for the artifact
   * - **Definition:** A bibliographic citation for the related artifact. This text SHOULD be formatted according to an accepted citation format.
   * - **Comment:** Additional structured information about citations should be captured as extensions.
   * - **FHIR Type:** \`markdown\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private citation?: MarkdownType | undefined;

  /**
   * RelatedArtifact.url Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Where the artifact can be accessed
   * - **Definition:** A url for the artifact that can be followed to access the actual content.
   * - **Comment:** If a document or resource element is present, this element SHALL NOT be provided (use the url or reference in the Attachment or resource reference).
   * - **FHIR Type:** \`url\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private url?: UrlType | undefined;

  /**
   * RelatedArtifact.document Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** What document is being referenced
   * - **Definition:** The document being referenced, represented as an attachment. This is exclusive with the resource element.
   * - **FHIR Type:** \`Attachment\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private document?: Attachment | undefined;

  /**
   * RelatedArtifact.resource Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** What resource is being referenced
   * - **Definition:** The related resource, such as a library, value set, profile, or other knowledge resource.
   * - **Comment:** If the type is predecessor, this is a reference to the succeeding knowledge resource. If the type is successor, this is a reference to the prior knowledge resource.
   * - **FHIR Type:** \`canonical\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Resource',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private resource?: CanonicalType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`type_\` property value as a EnumCodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link RelatedArtifactTypeEnum }
   */
  public getTypeEnumType(): EnumCodeType | null {
    return this.type_;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`type_\` property.
   *
   * @param enumType - the \`type_\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link RelatedArtifactTypeEnum }
   */
  public setTypeEnumType(enumType: EnumCodeType): this {
    assertIsDefined<EnumCodeType>(enumType, \`RelatedArtifact.type is required\`);
    const errMsgPrefix = \`Invalid RelatedArtifact.type\`;
    assertEnumCodeType<RelatedArtifactTypeEnum>(enumType, RelatedArtifactTypeEnum, errMsgPrefix);
    this.type_ = enumType;
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasTypeEnumType(): boolean {
    return isDefined<EnumCodeType>(this.type_) && !this.type_.isEmpty() && this.type_.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`type_\` property value as a CodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link RelatedArtifactTypeEnum }
   */
  public getTypeElement(): CodeType | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_ as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`type_\` property.
   *
   * @param element - the \`type_\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link RelatedArtifactTypeEnum }
   */
  public setTypeElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, \`RelatedArtifact.type is required\`);
    const optErrMsg = \`Invalid RelatedArtifact.type; Provided value is not an instance of CodeType.\`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.type_ = new EnumCodeType(element, this.relatedArtifactTypeEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasTypeElement(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the \`type_\` property value as a fhirCode if defined; else null
   *
   * @see CodeSystem Enumeration: {@link RelatedArtifactTypeEnum }
   */
  public getType(): fhirCode | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`type_\` property.
   *
   * @param value - the \`type_\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link RelatedArtifactTypeEnum }
   */
  public setType(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, \`RelatedArtifact.type is required\`);
    const optErrMsg = \`Invalid RelatedArtifact.type (\${String(value)})\`;
    this.type_ = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.relatedArtifactTypeEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasType(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the \`label\` property value as a StringType object if defined; else an empty StringType object
   */
  public getLabelElement(): StringType {
    return this.label ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`label\` property.
   *
   * @param element - the \`label\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLabelElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid RelatedArtifact.label; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.label = element;
    } else {
      this.label = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`label\` property exists and has a value; \`false\` otherwise
   */
  public hasLabelElement(): boolean {
    return isDefined<StringType>(this.label) && !this.label.isEmpty();
  }

  /**
   * @returns the \`label\` property value as a fhirString if defined; else undefined
   */
  public getLabel(): fhirString | undefined {
    return this.label?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`label\` property.
   *
   * @param value - the \`label\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLabel(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid RelatedArtifact.label (\${String(value)})\`;
      this.label = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.label = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`label\` property exists and has a value; \`false\` otherwise
   */
  public hasLabel(): boolean {
    return this.hasLabelElement();
  }

  /**
   * @returns the \`display\` property value as a StringType object if defined; else an empty StringType object
   */
  public getDisplayElement(): StringType {
    return this.display ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`display\` property.
   *
   * @param element - the \`display\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDisplayElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid RelatedArtifact.display; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.display = element;
    } else {
      this.display = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`display\` property exists and has a value; \`false\` otherwise
   */
  public hasDisplayElement(): boolean {
    return isDefined<StringType>(this.display) && !this.display.isEmpty();
  }

  /**
   * @returns the \`display\` property value as a fhirString if defined; else undefined
   */
  public getDisplay(): fhirString | undefined {
    return this.display?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`display\` property.
   *
   * @param value - the \`display\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDisplay(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid RelatedArtifact.display (\${String(value)})\`;
      this.display = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.display = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`display\` property exists and has a value; \`false\` otherwise
   */
  public hasDisplay(): boolean {
    return this.hasDisplayElement();
  }

  /**
   * @returns the \`citation\` property value as a MarkdownType object if defined; else an empty MarkdownType object
   */
  public getCitationElement(): MarkdownType {
    return this.citation ?? new MarkdownType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`citation\` property.
   *
   * @param element - the \`citation\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCitationElement(element: MarkdownType | undefined): this {
    if (isDefined<MarkdownType>(element)) {
      const optErrMsg = \`Invalid RelatedArtifact.citation; Provided element is not an instance of MarkdownType.\`;
      assertFhirType<MarkdownType>(element, MarkdownType, optErrMsg);
      this.citation = element;
    } else {
      this.citation = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`citation\` property exists and has a value; \`false\` otherwise
   */
  public hasCitationElement(): boolean {
    return isDefined<MarkdownType>(this.citation) && !this.citation.isEmpty();
  }

  /**
   * @returns the \`citation\` property value as a fhirMarkdown if defined; else undefined
   */
  public getCitation(): fhirMarkdown | undefined {
    return this.citation?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`citation\` property.
   *
   * @param value - the \`citation\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCitation(value: fhirMarkdown | undefined): this {
    if (isDefined<fhirMarkdown>(value)) {
      const optErrMsg = \`Invalid RelatedArtifact.citation (\${String(value)})\`;
      this.citation = new MarkdownType(parseFhirPrimitiveData(value, fhirMarkdownSchema, optErrMsg));
    } else {
      this.citation = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`citation\` property exists and has a value; \`false\` otherwise
   */
  public hasCitation(): boolean {
    return this.hasCitationElement();
  }

  /**
   * @returns the \`url\` property value as a UrlType object if defined; else an empty UrlType object
   */
  public getUrlElement(): UrlType {
    return this.url ?? new UrlType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`url\` property.
   *
   * @param element - the \`url\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUrlElement(element: UrlType | undefined): this {
    if (isDefined<UrlType>(element)) {
      const optErrMsg = \`Invalid RelatedArtifact.url; Provided element is not an instance of UrlType.\`;
      assertFhirType<UrlType>(element, UrlType, optErrMsg);
      this.url = element;
    } else {
      this.url = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`url\` property exists and has a value; \`false\` otherwise
   */
  public hasUrlElement(): boolean {
    return isDefined<UrlType>(this.url) && !this.url.isEmpty();
  }

  /**
   * @returns the \`url\` property value as a fhirUrl if defined; else undefined
   */
  public getUrl(): fhirUrl | undefined {
    return this.url?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`url\` property.
   *
   * @param value - the \`url\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUrl(value: fhirUrl | undefined): this {
    if (isDefined<fhirUrl>(value)) {
      const optErrMsg = \`Invalid RelatedArtifact.url (\${String(value)})\`;
      this.url = new UrlType(parseFhirPrimitiveData(value, fhirUrlSchema, optErrMsg));
    } else {
      this.url = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`url\` property exists and has a value; \`false\` otherwise
   */
  public hasUrl(): boolean {
    return this.hasUrlElement();
  }

  /**
   * @returns the \`document\` property value as a Attachment object if defined; else an empty Attachment object
   */
  public getDocument(): Attachment {
    return this.document ?? new Attachment();
  }

  /**
   * Assigns the provided Document object value to the \`document\` property.
   *
   * @param value - the \`document\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setDocument(value: Attachment | undefined): this {
    if (isDefined<Attachment>(value)) {
      const optErrMsg = \`Invalid RelatedArtifact.document; Provided element is not an instance of Attachment.\`;
      assertFhirType<Attachment>(value, Attachment, optErrMsg);
      this.document = value;
    } else {
      this.document = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`document\` property exists and has a value; \`false\` otherwise
   */
  public hasDocument(): boolean {
    return isDefined<Attachment>(this.document) && !this.document.isEmpty();
  }

  /**
   * @returns the \`resource\` property value as a CanonicalType object if defined; else an empty CanonicalType object
   */
  public getResourceElement(): CanonicalType {
    return this.resource ?? new CanonicalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`resource\` property.
   *
   * @param element - the \`resource\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setResourceElement(element: CanonicalType | undefined): this {
    if (isDefined<CanonicalType>(element)) {
      const optErrMsg = \`Invalid RelatedArtifact.resource; Provided element is not an instance of CanonicalType.\`;
      assertFhirType<CanonicalType>(element, CanonicalType, optErrMsg);
      this.resource = element;
    } else {
      this.resource = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`resource\` property exists and has a value; \`false\` otherwise
   */
  public hasResourceElement(): boolean {
    return isDefined<CanonicalType>(this.resource) && !this.resource.isEmpty();
  }

  /**
   * @returns the \`resource\` property value as a fhirCanonical if defined; else undefined
   */
  public getResource(): fhirCanonical | undefined {
    return this.resource?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`resource\` property.
   *
   * @param value - the \`resource\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setResource(value: fhirCanonical | undefined): this {
    if (isDefined<fhirCanonical>(value)) {
      const optErrMsg = \`Invalid RelatedArtifact.resource (\${String(value)})\`;
      this.resource = new CanonicalType(parseFhirPrimitiveData(value, fhirCanonicalSchema, optErrMsg));
    } else {
      this.resource = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`resource\` property exists and has a value; \`false\` otherwise
   */
  public hasResource(): boolean {
    return this.hasResourceElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'RelatedArtifact';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.type_,
      this.label,
      this.display,
      this.citation,
      this.url,
      this.document,
      this.resource,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): RelatedArtifact {
    const dest = new RelatedArtifact();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: RelatedArtifact): void {
    super.copyValues(dest);
    dest.type_ = this.type_ ? this.type_.copy() : null;
    dest.label = this.label?.copy();
    dest.display = this.display?.copy();
    dest.citation = this.citation?.copy();
    dest.url = this.url?.copy();
    dest.document = this.document?.copy();
    dest.resource = this.resource?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', \`UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasTypeElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getTypeElement()!, 'type', jsonObj);
    } else {
      missingReqdProperties.push(\`RelatedArtifact.type\`);
    }

    if (this.hasLabelElement()) {
      setFhirPrimitiveJson<fhirString>(this.getLabelElement(), 'label', jsonObj);
    }

    if (this.hasDisplayElement()) {
      setFhirPrimitiveJson<fhirString>(this.getDisplayElement(), 'display', jsonObj);
    }

    if (this.hasCitationElement()) {
      setFhirPrimitiveJson<fhirMarkdown>(this.getCitationElement(), 'citation', jsonObj);
    }

    if (this.hasUrlElement()) {
      setFhirPrimitiveJson<fhirUrl>(this.getUrlElement(), 'url', jsonObj);
    }

    if (this.hasDocument()) {
      setFhirComplexJson(this.getDocument(), 'document', jsonObj);
    }

    if (this.hasResourceElement()) {
      setFhirPrimitiveJson<fhirCanonical>(this.getResourceElement(), 'resource', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

/**
 * SampledData Class
 *
 * @remarks
 * Base StructureDefinition for SampledData Type: A series of measurements taken by a device, with upper and lower limits. There may be more than one dimension in the data.
 *
 * There is a need for a concise way to handle the data produced by devices that sample a physical state at a high frequency.
 *
 * **FHIR Specification**
 * - **Short:** A series of measurements taken by a device
 * - **Definition:** A series of measurements taken by a device, with upper and lower limits. There may be more than one dimension in the data.
 * - **Comment:** The data is not interpretable without at least origin, period, and dimensions, but these are optional to allow a separation between the template of measurement and the actual measurement, such as between DeviceCapabilities and DeviceLog.  When providing a summary view (for example with Observation.value[x]) SampledData should be represented with a brief display text such as "Sampled Data".
 * - **FHIR Version:** 4.0.1
 *
 * @category Data Models: ComplexType
 * @see [FHIR SampledData](http://hl7.org/fhir/StructureDefinition/SampledData)
 */
/* istanbul ignore next */ export class SampledData extends DataType implements IDataType {
  constructor(origin: Quantity | null = null, period: DecimalType | fhirDecimal | null = null, dimensions: PositiveIntType | fhirPositiveInt | null = null) {
    super();

    this.origin = null;
    if (isDefined<Quantity>(origin)) {
      this.setOrigin(origin);
    }

    this.period = null;
    if (isDefined<DecimalType | fhirDecimal>(period)) {
      if (period instanceof PrimitiveType) {
        this.setPeriodElement(period);
      } else {
        this.setPeriod(period);
      }
    }

    this.dimensions = null;
    if (isDefined<PositiveIntType | fhirPositiveInt>(dimensions)) {
      if (dimensions instanceof PrimitiveType) {
        this.setDimensionsElement(dimensions);
      } else {
        this.setDimensions(dimensions);
      }
    }
  }

  /**
   * Parse the provided \`SampledData\` JSON to instantiate the SampledData data model.
   *
   * @param sourceJson - JSON representing FHIR \`SampledData\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to SampledData
   * @returns SampledData data model or undefined for \`SampledData\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): SampledData | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'SampledData';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new SampledData();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'origin';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = Quantity.parse(classJsonObj[fieldName]!, sourceField);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setOrigin(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'period';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setPeriodElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'factor';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setFactorElement(datatype);
    }

    fieldName = 'lowerLimit';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setLowerLimitElement(datatype);
    }

    fieldName = 'upperLimit';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setUpperLimitElement(datatype);
    }

    fieldName = 'dimensions';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = fhirParser.parsePositiveIntType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setDimensionsElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'data';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setDataElement(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * SampledData.origin Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Zero value and units
   * - **Definition:** The base quantity that a measured value of zero represents. In addition, this provides the units of the entire measurement series.
   * - **FHIR Type:** \`Quantity\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private origin: Quantity | null;

  /**
   * SampledData.period Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Number of milliseconds between samples
   * - **Definition:** The length of time between sampling times, measured in milliseconds.
   * - **Comment:** This is usually a whole number.
   * - **FHIR Type:** \`decimal\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private period: DecimalType | null;

  /**
   * SampledData.factor Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Multiply data by this before adding to origin
   * - **Definition:** A correction factor that is applied to the sampled data points before they are added to the origin.
   * - **FHIR Type:** \`decimal\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private factor?: DecimalType | undefined;

  /**
   * SampledData.lowerLimit Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Lower limit of detection
   * - **Definition:** The lower limit of detection of the measured points. This is needed if any of the data points have the value "L" (lower than detection limit).
   * - **FHIR Type:** \`decimal\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private lowerLimit?: DecimalType | undefined;

  /**
   * SampledData.upperLimit Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Upper limit of detection
   * - **Definition:** The upper limit of detection of the measured points. This is needed if any of the data points have the value "U" (higher than detection limit).
   * - **FHIR Type:** \`decimal\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private upperLimit?: DecimalType | undefined;

  /**
   * SampledData.dimensions Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Number of sample points at each time point
   * - **Definition:** The number of sample points at each time point. If this value is greater than one, then the dimensions will be interlaced - all the sample points for a point in time will be recorded at once.
   * - **Comment:** If there is more than one dimension, the code for the type of data will define the meaning of the dimensions (typically ECG data).
   * - **FHIR Type:** \`positiveInt\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private dimensions: PositiveIntType | null;

  /**
   * SampledData.data Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Decimal values with spaces, or "E" | "U" | "L"
   * - **Definition:** A series of data points which are decimal values separated by a single space (character u20). The special values "E" (error), "L" (below detection limit) and "U" (above detection limit) can also be used in place of a decimal value.
   * - **Comment:** Data may be missing if it is omitted for summarization purposes. In general, data is required for any actual use of a SampledData.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private data?: StringType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`origin\` property value as a Quantity object if defined; else null
   */
  public getOrigin(): Quantity | null {
    return this.origin;
  }

  /**
   * Assigns the provided Quantity object value to the \`origin\` property.
   *
   * @param value - the \`origin\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setOrigin(value: Quantity): this {
    assertIsDefined<Quantity>(value, \`SampledData.origin is required\`);
    const optErrMsg = \`Invalid SampledData.origin; Provided element is not an instance of Quantity.\`;
    assertFhirType<Quantity>(value, Quantity, optErrMsg);
    this.origin = value;
    return this;
  }

  /**
   * @returns \`true\` if the \`origin\` property exists and has a value; \`false\` otherwise
   */
  public hasOrigin(): boolean {
    return isDefined<Quantity>(this.origin) && !this.origin.isEmpty();
  }

  /**
   * @returns the \`period\` property value as a DecimalType object if defined; else null
   */
  public getPeriodElement(): DecimalType | null {
    return this.period;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`period\` property.
   *
   * @param element - the \`period\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPeriodElement(element: DecimalType): this {
    assertIsDefined<DecimalType>(element, \`SampledData.period is required\`);
    const optErrMsg = \`Invalid SampledData.period; Provided value is not an instance of DecimalType.\`;
    assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
    this.period = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`period\` property exists and has a value; \`false\` otherwise
   */
  public hasPeriodElement(): boolean {
    return isDefined<DecimalType>(this.period) && !this.period.isEmpty();
  }

  /**
   * @returns the \`period\` property value as a fhirDecimal if defined; else null
   */
  public getPeriod(): fhirDecimal | null {
    if (this.period?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.period.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`period\` property.
   *
   * @param value - the \`period\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPeriod(value: fhirDecimal): this {
    assertIsDefined<fhirDecimal>(value, \`SampledData.period is required\`);
    const optErrMsg = \`Invalid SampledData.period (\${String(value)})\`;
    this.period = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`period\` property exists and has a value; \`false\` otherwise
   */
  public hasPeriod(): boolean {
    return this.hasPeriodElement();
  }

  /**
   * @returns the \`factor\` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getFactorElement(): DecimalType {
    return this.factor ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`factor\` property.
   *
   * @param element - the \`factor\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setFactorElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = \`Invalid SampledData.factor; Provided element is not an instance of DecimalType.\`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.factor = element;
    } else {
      this.factor = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`factor\` property exists and has a value; \`false\` otherwise
   */
  public hasFactorElement(): boolean {
    return isDefined<DecimalType>(this.factor) && !this.factor.isEmpty();
  }

  /**
   * @returns the \`factor\` property value as a fhirDecimal if defined; else undefined
   */
  public getFactor(): fhirDecimal | undefined {
    return this.factor?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`factor\` property.
   *
   * @param value - the \`factor\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setFactor(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = \`Invalid SampledData.factor (\${String(value)})\`;
      this.factor = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.factor = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`factor\` property exists and has a value; \`false\` otherwise
   */
  public hasFactor(): boolean {
    return this.hasFactorElement();
  }

  /**
   * @returns the \`lowerLimit\` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getLowerLimitElement(): DecimalType {
    return this.lowerLimit ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`lowerLimit\` property.
   *
   * @param element - the \`lowerLimit\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLowerLimitElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = \`Invalid SampledData.lowerLimit; Provided element is not an instance of DecimalType.\`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.lowerLimit = element;
    } else {
      this.lowerLimit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`lowerLimit\` property exists and has a value; \`false\` otherwise
   */
  public hasLowerLimitElement(): boolean {
    return isDefined<DecimalType>(this.lowerLimit) && !this.lowerLimit.isEmpty();
  }

  /**
   * @returns the \`lowerLimit\` property value as a fhirDecimal if defined; else undefined
   */
  public getLowerLimit(): fhirDecimal | undefined {
    return this.lowerLimit?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`lowerLimit\` property.
   *
   * @param value - the \`lowerLimit\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLowerLimit(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = \`Invalid SampledData.lowerLimit (\${String(value)})\`;
      this.lowerLimit = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.lowerLimit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`lowerLimit\` property exists and has a value; \`false\` otherwise
   */
  public hasLowerLimit(): boolean {
    return this.hasLowerLimitElement();
  }

  /**
   * @returns the \`upperLimit\` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getUpperLimitElement(): DecimalType {
    return this.upperLimit ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`upperLimit\` property.
   *
   * @param element - the \`upperLimit\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUpperLimitElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = \`Invalid SampledData.upperLimit; Provided element is not an instance of DecimalType.\`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.upperLimit = element;
    } else {
      this.upperLimit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`upperLimit\` property exists and has a value; \`false\` otherwise
   */
  public hasUpperLimitElement(): boolean {
    return isDefined<DecimalType>(this.upperLimit) && !this.upperLimit.isEmpty();
  }

  /**
   * @returns the \`upperLimit\` property value as a fhirDecimal if defined; else undefined
   */
  public getUpperLimit(): fhirDecimal | undefined {
    return this.upperLimit?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`upperLimit\` property.
   *
   * @param value - the \`upperLimit\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUpperLimit(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = \`Invalid SampledData.upperLimit (\${String(value)})\`;
      this.upperLimit = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.upperLimit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`upperLimit\` property exists and has a value; \`false\` otherwise
   */
  public hasUpperLimit(): boolean {
    return this.hasUpperLimitElement();
  }

  /**
   * @returns the \`dimensions\` property value as a PositiveIntType object if defined; else null
   */
  public getDimensionsElement(): PositiveIntType | null {
    return this.dimensions;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`dimensions\` property.
   *
   * @param element - the \`dimensions\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDimensionsElement(element: PositiveIntType): this {
    assertIsDefined<PositiveIntType>(element, \`SampledData.dimensions is required\`);
    const optErrMsg = \`Invalid SampledData.dimensions; Provided value is not an instance of PositiveIntType.\`;
    assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
    this.dimensions = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`dimensions\` property exists and has a value; \`false\` otherwise
   */
  public hasDimensionsElement(): boolean {
    return isDefined<PositiveIntType>(this.dimensions) && !this.dimensions.isEmpty();
  }

  /**
   * @returns the \`dimensions\` property value as a fhirPositiveInt if defined; else null
   */
  public getDimensions(): fhirPositiveInt | null {
    if (this.dimensions?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.dimensions.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`dimensions\` property.
   *
   * @param value - the \`dimensions\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDimensions(value: fhirPositiveInt): this {
    assertIsDefined<fhirPositiveInt>(value, \`SampledData.dimensions is required\`);
    const optErrMsg = \`Invalid SampledData.dimensions (\${String(value)})\`;
    this.dimensions = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`dimensions\` property exists and has a value; \`false\` otherwise
   */
  public hasDimensions(): boolean {
    return this.hasDimensionsElement();
  }

  /**
   * @returns the \`data\` property value as a StringType object if defined; else an empty StringType object
   */
  public getDataElement(): StringType {
    return this.data ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`data\` property.
   *
   * @param element - the \`data\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDataElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid SampledData.data; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.data = element;
    } else {
      this.data = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`data\` property exists and has a value; \`false\` otherwise
   */
  public hasDataElement(): boolean {
    return isDefined<StringType>(this.data) && !this.data.isEmpty();
  }

  /**
   * @returns the \`data\` property value as a fhirString if defined; else undefined
   */
  public getData(): fhirString | undefined {
    return this.data?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`data\` property.
   *
   * @param value - the \`data\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setData(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid SampledData.data (\${String(value)})\`;
      this.data = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.data = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`data\` property exists and has a value; \`false\` otherwise
   */
  public hasData(): boolean {
    return this.hasDataElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'SampledData';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.origin,
      this.period,
      this.factor,
      this.lowerLimit,
      this.upperLimit,
      this.dimensions,
      this.data,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): SampledData {
    const dest = new SampledData();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: SampledData): void {
    super.copyValues(dest);
    dest.origin = this.origin ? this.origin.copy() : null;
    dest.period = this.period ? this.period.copy() : null;
    dest.factor = this.factor?.copy();
    dest.lowerLimit = this.lowerLimit?.copy();
    dest.upperLimit = this.upperLimit?.copy();
    dest.dimensions = this.dimensions ? this.dimensions.copy() : null;
    dest.data = this.data?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', \`UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasOrigin()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirComplexJson(this.getOrigin()!, 'origin', jsonObj);
    } else {
      missingReqdProperties.push(\`SampledData.origin\`);
    }

    if (this.hasPeriodElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirDecimal>(this.getPeriodElement()!, 'period', jsonObj);
    } else {
      missingReqdProperties.push(\`SampledData.period\`);
    }

    if (this.hasFactorElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getFactorElement(), 'factor', jsonObj);
    }

    if (this.hasLowerLimitElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getLowerLimitElement(), 'lowerLimit', jsonObj);
    }

    if (this.hasUpperLimitElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getUpperLimitElement(), 'upperLimit', jsonObj);
    }

    if (this.hasDimensionsElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirPositiveInt>(this.getDimensionsElement()!, 'dimensions', jsonObj);
    } else {
      missingReqdProperties.push(\`SampledData.dimensions\`);
    }

    if (this.hasDataElement()) {
      setFhirPrimitiveJson<fhirString>(this.getDataElement(), 'data', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

/**
 * Signature Class
 *
 * @remarks
 * Base StructureDefinition for Signature Type: A signature along with supporting context. The signature may be a digital signature that is cryptographic in nature, or some other signature acceptable to the domain. This other signature may be as simple as a graphical image representing a hand-written signature, or a signature ceremony Different signature approaches have different utilities.
 *
 * There are a number of places where content must be signed in healthcare.
 *
 * **FHIR Specification**
 * - **Short:** A Signature - XML DigSig, JWS, Graphical image of signature, etc.
 * - **Definition:** A signature along with supporting context. The signature may be a digital signature that is cryptographic in nature, or some other signature acceptable to the domain. This other signature may be as simple as a graphical image representing a hand-written signature, or a signature ceremony Different signature approaches have different utilities.
 * - **Comment:** The elements of the Signature Resource are for ease of access of these elements. For digital signatures (Xml DigSig, JWS), the non-repudiation proof comes from the Signature  validation, which includes validation of the referenced objects (e.g. Resources) (a.k.a., Content) in the XML-Signature Detached form.
 * - **FHIR Version:** 4.0.1
 *
 * @category Data Models: ComplexType
 * @see [FHIR Signature](http://hl7.org/fhir/StructureDefinition/Signature)
 */
/* istanbul ignore next */ export class Signature extends DataType implements IDataType {
  constructor(type_: Coding[] | null = null, when: InstantType | fhirInstant | null = null, who: Reference | null = null) {
    super();

    this.type_ = null;
    if (isDefinedList<Coding>(type_)) {
      this.setType(type_);
    }

    this.when = null;
    if (isDefined<InstantType | fhirInstant>(when)) {
      if (when instanceof PrimitiveType) {
        this.setWhenElement(when);
      } else {
        this.setWhen(when);
      }
    }

    this.who = null;
    if (isDefined<Reference>(who)) {
      this.setWho(who);
    }
  }

  /**
   * Parse the provided \`Signature\` JSON to instantiate the Signature data model.
   *
   * @param sourceJson - JSON representing FHIR \`Signature\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Signature
   * @returns Signature data model or undefined for \`Signature\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Signature | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Signature';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Signature();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'type';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Coding | undefined = Coding.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype === undefined) {
          missingReqdProperties.push(\`\${sourceField}[\${String(idx)}]\`);
        } else {
          instance.addType(datatype);
        }
      });
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'when';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: InstantType | undefined = fhirParser.parseInstantType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setWhenElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'who';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = Reference.parse(classJsonObj[fieldName]!, sourceField);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setWho(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'onBehalfOf';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = Reference.parse(classJsonObj[fieldName]!, sourceField);
      instance.setOnBehalfOf(datatype);
    }

    fieldName = 'targetFormat';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setTargetFormatElement(datatype);
    }

    fieldName = 'sigFormat';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setSigFormatElement(datatype);
    }

    fieldName = 'data';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: Base64BinaryType | undefined = fhirParser.parseBase64BinaryType(dtJson, dtSiblingJson);
      instance.setDataElement(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Signature.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Indication of the reason the entity signed the object(s)
   * - **Definition:** An indication of the reason that the entity signed this document. This may be explicitly included as part of the signature information and can be used when determining accountability for various actions concerning the document.
   * - **Comment:** Examples include attesting to: authorship, correct transcription, and witness of specific event. Also known as a &quot;Commitment Type Indication&quot;.
   * - **FHIR Type:** \`Coding\`
   * - **Cardinality:** 1..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private type_: Coding[] | null;

  /**
   * Signature.when Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** When the signature was created
   * - **Definition:** When the digital signature was signed.
   * - **Comment:** This should agree with the information in the signature.
   * - **FHIR Type:** \`instant\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private when: InstantType | null;

  /**
   * Signature.who Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Who signed
   * - **Definition:** A reference to an application-usable description of the identity that signed  (e.g. the signature used their private key).
   * - **Comment:** This should agree with the information in the signature.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Practitioner',
   *       'http://hl7.org/fhir/StructureDefinition/PractitionerRole',
   *       'http://hl7.org/fhir/StructureDefinition/RelatedPerson',
   *       'http://hl7.org/fhir/StructureDefinition/Patient',
   *       'http://hl7.org/fhir/StructureDefinition/Device',
   *       'http://hl7.org/fhir/StructureDefinition/Organization',
   *     ]
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private who: Reference | null;

  /**
   * Signature.onBehalfOf Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The party represented
   * - **Definition:** A reference to an application-usable description of the identity that is represented by the signature.
   * - **Comment:** The party that can\\'t sign. For example a child.
   * - **Requirements:** used when the signature is on behalf of a non-signer.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Practitioner',
   *       'http://hl7.org/fhir/StructureDefinition/PractitionerRole',
   *       'http://hl7.org/fhir/StructureDefinition/RelatedPerson',
   *       'http://hl7.org/fhir/StructureDefinition/Patient',
   *       'http://hl7.org/fhir/StructureDefinition/Device',
   *       'http://hl7.org/fhir/StructureDefinition/Organization',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private onBehalfOf?: Reference | undefined;

  /**
   * Signature.targetFormat Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The technical format of the signed resources
   * - **Definition:** A mime type that indicates the technical format of the target resources signed by the signature.
   * - **Comment:** "xml", "json" and "ttl" are allowed, which describe the simple encodings described in the specification (and imply appropriate bundle support). Otherwise, mime types are legal here.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private targetFormat?: CodeType | undefined;

  /**
   * Signature.sigFormat Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The technical format of the signature
   * - **Definition:** A mime type that indicates the technical format of the signature. Important mime types are application/signature+xml for X ML DigSig, application/jose for JWS, and image/* for a graphical image of a signature, etc.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private sigFormat?: CodeType | undefined;

  /**
   * Signature.data Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The actual signature content (XML DigSig. JWS, picture, etc.)
   * - **Definition:** The base64 encoding of the Signature content. When signature is not recorded electronically this element would be empty.
   * - **Comment:** Where the signature type is an XML DigSig, the signed content is a FHIR Resource(s), the signature is of the XML form of the Resource(s) using  XML-Signature (XMLDIG) "Detached Signature" form.
   * - **FHIR Type:** \`base64Binary\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private data?: Base64BinaryType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`type_\` property value as a Coding array
   */
  public getType(): Coding[] {
    return this.type_ ?? ([] as Coding[]);
  }

  /**
   * Assigns the provided Coding array value to the \`type_\` property.
   *
   * @param value - the \`type_\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setType(value: Coding[]): this {
    assertIsDefinedList<Coding>(value, \`Signature.type is required\`);
    const optErrMsg = \`Invalid Signature.type; Provided value array has an element that is not an instance of Coding.\`;
    assertFhirTypeList<Coding>(value, Coding, optErrMsg);
    this.type_ = value;
    return this;
  }

  /**
   * Add the provided Coding value to the \`type_\` array property.
   *
   * @param value - the \`type_\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addType(value: Coding | undefined): this {
    if (isDefined<Coding>(value)) {
      const optErrMsg = \`Invalid Signature.type; Provided element is not an instance of Coding.\`;
      assertFhirType<Coding>(value, Coding, optErrMsg);
      this.initType();
      this.type_?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasType(): boolean {
    return isDefinedList<Coding>(this.type_) && this.type_.some((item: Coding) => !item.isEmpty());
  }

  /**
   * Initialize the \`type_\` property
   */
  private initType(): void {
    if(!this.hasType()) {
      this.type_ = [] as Coding[];
    }
  }

  /**
   * @returns the \`when\` property value as a InstantType object if defined; else null
   */
  public getWhenElement(): InstantType | null {
    return this.when;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`when\` property.
   *
   * @param element - the \`when\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setWhenElement(element: InstantType): this {
    assertIsDefined<InstantType>(element, \`Signature.when is required\`);
    const optErrMsg = \`Invalid Signature.when; Provided value is not an instance of InstantType.\`;
    assertFhirType<InstantType>(element, InstantType, optErrMsg);
    this.when = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`when\` property exists and has a value; \`false\` otherwise
   */
  public hasWhenElement(): boolean {
    return isDefined<InstantType>(this.when) && !this.when.isEmpty();
  }

  /**
   * @returns the \`when\` property value as a fhirInstant if defined; else null
   */
  public getWhen(): fhirInstant | null {
    if (this.when?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.when.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`when\` property.
   *
   * @param value - the \`when\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setWhen(value: fhirInstant): this {
    assertIsDefined<fhirInstant>(value, \`Signature.when is required\`);
    const optErrMsg = \`Invalid Signature.when (\${String(value)})\`;
    this.when = new InstantType(parseFhirPrimitiveData(value, fhirInstantSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`when\` property exists and has a value; \`false\` otherwise
   */
  public hasWhen(): boolean {
    return this.hasWhenElement();
  }

  /**
   * @returns the \`who\` property value as a Reference object if defined; else null
   */
  public getWho(): Reference | null {
    return this.who;
  }

  /**
   * Assigns the provided Who object value to the \`who\` property.
   *
   * @decorator \`@ReferenceTargets('Signature.who', ['Practitioner','PractitionerRole','RelatedPerson','Patient','Device','Organization',])\`
   *
   * @param value - the \`who\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('Signature.who', [
    'Practitioner',
  
    'PractitionerRole',
  
    'RelatedPerson',
  
    'Patient',
  
    'Device',
  
    'Organization',
  ])
  public setWho(value: Reference): this {
    assertIsDefined<Reference>(value, \`Signature.who is required\`);
    // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
    this.who = value;
    return this;
  }

  /**
   * @returns \`true\` if the \`who\` property exists and has a value; \`false\` otherwise
   */
  public hasWho(): boolean {
    return isDefined<Reference>(this.who) && !this.who.isEmpty();
  }

  /**
   * @returns the \`onBehalfOf\` property value as a Reference object; else an empty Reference object
   */
  public getOnBehalfOf(): Reference {
    return this.onBehalfOf ?? new Reference();
  }

  /**
   * Assigns the provided OnBehalfOf object value to the \`onBehalfOf\` property.
   *
   * @decorator \`@ReferenceTargets('Signature.onBehalfOf', ['Practitioner','PractitionerRole','RelatedPerson','Patient','Device','Organization',])\`
   *
   * @param value - the \`onBehalfOf\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('Signature.onBehalfOf', [
    'Practitioner',
  
    'PractitionerRole',
  
    'RelatedPerson',
  
    'Patient',
  
    'Device',
  
    'Organization',
  ])
  public setOnBehalfOf(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.onBehalfOf = value;
    } else {
      this.onBehalfOf = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`onBehalfOf\` property exists and has a value; \`false\` otherwise
   */
  public hasOnBehalfOf(): boolean {
    return isDefined<Reference>(this.onBehalfOf) && !this.onBehalfOf.isEmpty();
  }

  /**
   * @returns the \`targetFormat\` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getTargetFormatElement(): CodeType {
    return this.targetFormat ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`targetFormat\` property.
   *
   * @param element - the \`targetFormat\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTargetFormatElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Signature.targetFormat; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.targetFormat = element;
    } else {
      this.targetFormat = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`targetFormat\` property exists and has a value; \`false\` otherwise
   */
  public hasTargetFormatElement(): boolean {
    return isDefined<CodeType>(this.targetFormat) && !this.targetFormat.isEmpty();
  }

  /**
   * @returns the \`targetFormat\` property value as a fhirCode if defined; else undefined
   */
  public getTargetFormat(): fhirCode | undefined {
    return this.targetFormat?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`targetFormat\` property.
   *
   * @param value - the \`targetFormat\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTargetFormat(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Signature.targetFormat (\${String(value)})\`;
      this.targetFormat = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.targetFormat = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`targetFormat\` property exists and has a value; \`false\` otherwise
   */
  public hasTargetFormat(): boolean {
    return this.hasTargetFormatElement();
  }

  /**
   * @returns the \`sigFormat\` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getSigFormatElement(): CodeType {
    return this.sigFormat ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`sigFormat\` property.
   *
   * @param element - the \`sigFormat\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSigFormatElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Signature.sigFormat; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.sigFormat = element;
    } else {
      this.sigFormat = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`sigFormat\` property exists and has a value; \`false\` otherwise
   */
  public hasSigFormatElement(): boolean {
    return isDefined<CodeType>(this.sigFormat) && !this.sigFormat.isEmpty();
  }

  /**
   * @returns the \`sigFormat\` property value as a fhirCode if defined; else undefined
   */
  public getSigFormat(): fhirCode | undefined {
    return this.sigFormat?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`sigFormat\` property.
   *
   * @param value - the \`sigFormat\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSigFormat(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Signature.sigFormat (\${String(value)})\`;
      this.sigFormat = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.sigFormat = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`sigFormat\` property exists and has a value; \`false\` otherwise
   */
  public hasSigFormat(): boolean {
    return this.hasSigFormatElement();
  }

  /**
   * @returns the \`data\` property value as a Base64BinaryType object if defined; else an empty Base64BinaryType object
   */
  public getDataElement(): Base64BinaryType {
    return this.data ?? new Base64BinaryType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`data\` property.
   *
   * @param element - the \`data\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDataElement(element: Base64BinaryType | undefined): this {
    if (isDefined<Base64BinaryType>(element)) {
      const optErrMsg = \`Invalid Signature.data; Provided element is not an instance of Base64BinaryType.\`;
      assertFhirType<Base64BinaryType>(element, Base64BinaryType, optErrMsg);
      this.data = element;
    } else {
      this.data = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`data\` property exists and has a value; \`false\` otherwise
   */
  public hasDataElement(): boolean {
    return isDefined<Base64BinaryType>(this.data) && !this.data.isEmpty();
  }

  /**
   * @returns the \`data\` property value as a fhirBase64Binary if defined; else undefined
   */
  public getData(): fhirBase64Binary | undefined {
    return this.data?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`data\` property.
   *
   * @param value - the \`data\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setData(value: fhirBase64Binary | undefined): this {
    if (isDefined<fhirBase64Binary>(value)) {
      const optErrMsg = \`Invalid Signature.data (\${String(value)})\`;
      this.data = new Base64BinaryType(parseFhirPrimitiveData(value, fhirBase64BinarySchema, optErrMsg));
    } else {
      this.data = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`data\` property exists and has a value; \`false\` otherwise
   */
  public hasData(): boolean {
    return this.hasDataElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Signature';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.type_,
      this.when,
      this.who,
      this.onBehalfOf,
      this.targetFormat,
      this.sigFormat,
      this.data,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Signature {
    const dest = new Signature();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Signature): void {
    super.copyValues(dest);
    const typeList = copyListValues<Coding>(this.type_);
    dest.type_ = typeList.length === 0 ? null : typeList;
    dest.when = this.when ? this.when.copy() : null;
    dest.who = this.who ? this.who.copy() : null;
    dest.onBehalfOf = this.onBehalfOf?.copy();
    dest.targetFormat = this.targetFormat?.copy();
    dest.sigFormat = this.sigFormat?.copy();
    dest.data = this.data?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', \`UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasType()) {
      setFhirComplexListJson(this.getType(), 'type', jsonObj);
    } else {
      missingReqdProperties.push(\`Signature.type\`);
    }

    if (this.hasWhenElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirInstant>(this.getWhenElement()!, 'when', jsonObj);
    } else {
      missingReqdProperties.push(\`Signature.when\`);
    }

    if (this.hasWho()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirComplexJson(this.getWho()!, 'who', jsonObj);
    } else {
      missingReqdProperties.push(\`Signature.who\`);
    }

    if (this.hasOnBehalfOf()) {
      setFhirComplexJson(this.getOnBehalfOf(), 'onBehalfOf', jsonObj);
    }

    if (this.hasTargetFormatElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getTargetFormatElement(), 'targetFormat', jsonObj);
    }

    if (this.hasSigFormatElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getSigFormatElement(), 'sigFormat', jsonObj);
    }

    if (this.hasDataElement()) {
      setFhirPrimitiveJson<fhirBase64Binary>(this.getDataElement(), 'data', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

/**
 * Timing Class
 *
 * @remarks
 * Base StructureDefinition for Timing Type: Specifies an event that may occur multiple times. Timing schedules are used to record when things are planned, expected or requested to occur. The most common usage is in dosage instructions for medications. They are also used when planning care of various kinds, and may be used for reporting the schedule to which past regular activities were carried out.
 *
 * Need to able to track proposed timing schedules. There are several different ways to do this: one or more specified times, a simple rules like three times a day, or  before/after meals.
 *
 * **FHIR Specification**
 * - **Short:** A timing schedule that specifies an event that may occur multiple times
 * - **Definition:** Specifies an event that may occur multiple times. Timing schedules are used to record when things are planned, expected or requested to occur. The most common usage is in dosage instructions for medications. They are also used when planning care of various kinds, and may be used for reporting the schedule to which past regular activities were carried out.
 * - **Comment:** Describes the occurrence of an event that may occur multiple times. Timing schedules are used for specifying when events are expected or requested to occur, and may also be used to represent the summary of a past or ongoing event.  For simplicity, the definitions of Timing components are expressed as \\'future\\' events, but such components can also be used to describe historic or ongoing events. A Timing schedule can be a list of events and/or criteria for when the event happens, which can be expressed in a structured form and/or as a code. When both event and a repeating specification are provided, the list of events should be understood as an interpretation of the information in the repeat structure.
 * - **FHIR Version:** 4.0.1
 *
 * @category Data Models: ComplexType
 * @see [FHIR Timing](http://hl7.org/fhir/StructureDefinition/Timing)
 */
export class Timing extends BackboneType implements IBackboneType {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`Timing\` JSON to instantiate the Timing data model.
   *
   * @param sourceJson - JSON representing FHIR \`Timing\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Timing
   * @returns Timing data model or undefined for \`Timing\`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Timing | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Timing';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Timing();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneTypeJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    

    fieldName = 'event';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: DateTimeType | undefined = fhirParser.parseDateTimeType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addEventElement(datatype);
        }
      });
    }

    fieldName = 'repeat';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: TimingRepeatComponent | undefined = TimingRepeatComponent.parse(classJsonObj[fieldName]!, sourceField);
      instance.setRepeat(datatype);
    }

    fieldName = 'code';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = CodeableConcept.parse(classJsonObj[fieldName]!, sourceField);
      instance.setCode(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Timing.event Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** When the event occurs
   * - **Definition:** Identifies specific times when the event occurs.
   * - **Requirements:** In a Medication Administration Record, for instance, you need to take a general specification, and turn it into a precise specification.
   * - **FHIR Type:** \`dateTime\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private event?: DateTimeType[] | undefined;

  /**
   * Timing.repeat Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** When the event is to occur
   * - **Definition:** A set of rules that describe when the event is scheduled.
   * - **Requirements:** Many timing schedules are determined by regular repetitions.
   * - **FHIR Type:** \`Element\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private repeat?: TimingRepeatComponent | undefined;

  /**
   * Timing.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** BID | TID | QID | AM | PM | QD | QOD | +
   * - **Definition:** A code for the timing schedule (or just text in code.text). Some codes such as BID are ubiquitous, but many institutions define their own additional codes. If a code is provided, the code is understood to be a complete statement of whatever is specified in the structured timing data, and either the code or the data may be used to interpret the Timing, with the exception that .repeat.bounds still applies over the code (and is not contained in the code).
   * - **Comment:** BID etc. are defined as \\'at institutionally specified times\\'. For example, an institution may choose that BID is "always at 7am and 6pm".  If it is inappropriate for this choice to be made, the code BID should not be used. Instead, a distinct organization-specific code should be used in place of the HL7-defined BID code and/or a structured representation should be used (in this case, specifying the two event times).
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code?: CodeableConcept | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`event\` property value as a DateTimeType array
   */
  public getEventElement(): DateTimeType[] {
    return this.event ?? ([] as DateTimeType[]);
  }

  /**
   * Assigns the provided DateTimeType array value to the \`event\` property.
   *
   * @param element - the \`event\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setEventElement(element: DateTimeType[] | undefined): this {
    if (isDefinedList<DateTimeType>(element)) {
      const optErrMsg = \`Invalid Timing.event; Provided value array has an element that is not an instance of DateTimeType.\`;
      assertFhirTypeList<DateTimeType>(element, DateTimeType, optErrMsg);
      this.event = element;
    } else {
      this.event = undefined;
    }
    return this;
  }

  /**
   * Add the provided DateTimeType value to the \`event\` array property.
   *
   * @param element - the \`event\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addEventElement(element: DateTimeType | undefined): this {
    if (isDefined<DateTimeType>(element)) {
      const optErrMsg = \`Invalid Timing.event; Provided element is not an instance of DateTimeType.\`;
      assertFhirType<DateTimeType>(element, DateTimeType, optErrMsg);
      this.initEvent();
      this.event?.push(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`event\` property exists and has a value; \`false\` otherwise
   */
  public hasEventElement(): boolean {
    return isDefinedList<DateTimeType>(this.event) && this.event.some((item: DateTimeType) => !item.isEmpty());
  }

  /**
   * @returns the \`event\` property value as a fhirDateTime array
   */
  public getEvent(): fhirDateTime[] {
    this.initEvent();
    const eventValues = [] as fhirDateTime[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.event!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        eventValues.push(value);
      }
    }
    return eventValues;
  }

  /**
   * Assigns the provided primitive value array to the \`event\` property.
   *
   * @param value - the \`event\` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setEvent(value: fhirDateTime[] | undefined): this {
    if (isDefinedList<fhirDateTime>(value)) {
      const eventElements = [] as DateTimeType[];
      for (const eventValue of value) {
        const optErrMsg = \`Invalid Timing.event array item (\${String(eventValue)})\`;
        const element = new DateTimeType(parseFhirPrimitiveData(eventValue, fhirDateTimeSchema, optErrMsg));
        eventElements.push(element);
      }
      this.event = eventElements;
    } else {
      this.event = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`event\` array property.
   *
   * @param value - the \`event\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addEvent(value: fhirDateTime | undefined): this {
    if (isDefined<fhirDateTime>(value)) {
      const optErrMsg = \`Invalid Timing.event array item (\${String(value)})\`;
      const element = new DateTimeType(parseFhirPrimitiveData(value, fhirDateTimeSchema, optErrMsg));
      this.initEvent();
      this.addEventElement(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`event\` property exists and has a value; \`false\` otherwise
   */
  public hasEvent(): boolean {
    return this.hasEventElement();
  }

  /**
   * Initialize the \`event\` property
   */
  private initEvent(): void {
    if (!this.hasEvent()) {
      this.event = [] as DateTimeType[];
    }
  }

  /**
   * @returns the \`repeat\` property value as a TimingRepeatComponent object if defined; else an empty TimingRepeatComponent object
   */
  public getRepeat(): TimingRepeatComponent {
    return this.repeat ?? new TimingRepeatComponent();
  }

  /**
   * Assigns the provided Repeat object value to the \`repeat\` property.
   *
   * @param value - the \`repeat\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setRepeat(value: TimingRepeatComponent | undefined): this {
    if (isDefined<TimingRepeatComponent>(value)) {
      const optErrMsg = \`Invalid Timing.repeat; Provided element is not an instance of TimingRepeatComponent.\`;
      assertFhirType<TimingRepeatComponent>(value, TimingRepeatComponent, optErrMsg);
      this.repeat = value;
    } else {
      this.repeat = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`repeat\` property exists and has a value; \`false\` otherwise
   */
  public hasRepeat(): boolean {
    return isDefined<TimingRepeatComponent>(this.repeat) && !this.repeat.isEmpty();
  }

  /**
   * @returns the \`code\` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getCode(): CodeableConcept {
    return this.code ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Code object value to the \`code\` property.
   *
   * @param value - the \`code\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setCode(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Timing.code; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.code = value;
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`code\` property exists and has a value; \`false\` otherwise
   */
  public hasCode(): boolean {
    return isDefined<CodeableConcept>(this.code) && !this.code.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Timing';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.event,
      this.repeat,
      this.code,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Timing {
    const dest = new Timing();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Timing): void {
    super.copyValues(dest);
    const eventList = copyListValues<DateTimeType>(this.event);
    dest.event = eventList.length === 0 ? undefined : eventList;
    dest.repeat = this.repeat?.copy();
    dest.code = this.code?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', \`UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasEvent()) {
      setFhirPrimitiveListJson(this.getEventElement(), 'event', jsonObj);
    }

    if (this.hasRepeat()) {
      setFhirComplexJson(this.getRepeat(), 'repeat', jsonObj);
    }

    if (this.hasCode()) {
      setFhirComplexJson(this.getCode(), 'code', jsonObj);
    }

    return jsonObj;
  }
}
/**
 * TimingRepeatComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** When the event is to occur
 * - **Definition:** A set of rules that describe when the event is scheduled.
 * - **Requirements:** Many timing schedules are determined by regular repetitions.
 *
 * @category Data Models: ComplexType
 * @see [FHIR Timing](http://hl7.org/fhir/StructureDefinition/Timing)
 */
export class TimingRepeatComponent extends DataType implements IDataType {
  constructor() {
    super();

    this.daysOfWeekEnum = new DaysOfWeekEnum();
  }

  /**
   * Parse the provided \`TimingRepeatComponent\` JSON to instantiate the TimingRepeatComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`TimingRepeatComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to TimingRepeatComponent
   * @returns TimingRepeatComponent data model or undefined for \`TimingRepeatComponent\`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): TimingRepeatComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'TimingRepeatComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new TimingRepeatComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const classMetadata: DecoratorMetadataObject | null = TimingRepeatComponent[Symbol.metadata];
    const errorMessage = \`DecoratorMetadataObject does not exist for TimingRepeatComponent\`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    fieldName = 'bounds[x]';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const bounds: IDataType | undefined = fhirParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setBounds(bounds);

    fieldName = 'count';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = fhirParser.parsePositiveIntType(dtJson, dtSiblingJson);
      instance.setCountElement(datatype);
    }

    fieldName = 'countMax';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = fhirParser.parsePositiveIntType(dtJson, dtSiblingJson);
      instance.setCountMaxElement(datatype);
    }

    fieldName = 'duration';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setDurationElement(datatype);
    }

    fieldName = 'durationMax';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setDurationMaxElement(datatype);
    }

    fieldName = 'durationUnit';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setDurationUnitElement(datatype);
    }

    fieldName = 'frequency';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = fhirParser.parsePositiveIntType(dtJson, dtSiblingJson);
      instance.setFrequencyElement(datatype);
    }

    fieldName = 'frequencyMax';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = fhirParser.parsePositiveIntType(dtJson, dtSiblingJson);
      instance.setFrequencyMaxElement(datatype);
    }

    fieldName = 'period';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setPeriodElement(datatype);
    }

    fieldName = 'periodMax';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setPeriodMaxElement(datatype);
    }

    fieldName = 'periodUnit';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setPeriodUnitElement(datatype);
    }

    fieldName = 'dayOfWeek';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: CodeType | undefined = fhirParser.parseCodeType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addDayOfWeekElement(datatype);
        }
      });
    }

    fieldName = 'timeOfDay';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: TimeType | undefined = fhirParser.parseTimeType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addTimeOfDayElement(datatype);
        }
      });
    }

    fieldName = 'when';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: CodeType | undefined = fhirParser.parseCodeType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addWhenElement(datatype);
        }
      });
    }

    fieldName = 'offset';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UnsignedIntType | undefined = fhirParser.parseUnsignedIntType(dtJson, dtSiblingJson);
      instance.setOffsetElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Timing.repeat.bounds[x] Element
   *
   * @decorator \`@ChoiceDataTypesMeta('Timing.repeat.bounds[x]', ['Duration','Range','Period',]\`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Length/Range of lengths, or (Start and/or end) limits
   * - **Definition:** Either a duration for the length of the timing schedule, a range of possible length, or outer bounds for start and/or end limits of the timing schedule.
   * - **FHIR Types:**
   *     'Duration',
   *     'Range',
   *     'Period',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('Timing.repeat.bounds[x]',[
    'Duration',
    'Range',
    'Period',
  ])
  private bounds?: IDataType | undefined;

  /**
   * Timing.repeat.count Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Number of times to repeat
   * - **Definition:** A total count of the desired number of repetitions across the duration of the entire timing specification. If countMax is present, this element indicates the lower bound of the allowed range of count values.
   * - **Comment:** If you have both bounds and count, then this should be understood as within the bounds period, until count times happens.
   * - **Requirements:** Repetitions may be limited by end time or total occurrences.
   * - **FHIR Type:** \`positiveInt\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private count?: PositiveIntType | undefined;

  /**
   * Timing.repeat.countMax Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Maximum number of times to repeat
   * - **Definition:** If present, indicates that the count is a range - so to perform the action between [count] and [countMax] times.
   * - **FHIR Type:** \`positiveInt\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private countMax?: PositiveIntType | undefined;

  /**
   * Timing.repeat.duration Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** How long when it happens
   * - **Definition:** How long this thing happens for when it happens. If durationMax is present, this element indicates the lower bound of the allowed range of the duration.
   * - **Comment:** For some events the duration is part of the definition of the event (e.g. IV infusions, where the duration is implicit in the specified quantity and rate). For others, it\\'s part of the timing specification (e.g. exercise).
   * - **Requirements:** Some activities are not instantaneous and need to be maintained for a period of time.
   * - **FHIR Type:** \`decimal\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private duration?: DecimalType | undefined;

  /**
   * Timing.repeat.durationMax Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** How long when it happens (Max)
   * - **Definition:** If present, indicates that the duration is a range - so to perform the action between [duration] and [durationMax] time length.
   * - **Comment:** For some events the duration is part of the definition of the event (e.g. IV infusions, where the duration is implicit in the specified quantity and rate). For others, it\\'s part of the timing specification (e.g. exercise).
   * - **Requirements:** Some activities are not instantaneous and need to be maintained for a period of time.
   * - **FHIR Type:** \`decimal\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private durationMax?: DecimalType | undefined;

  /**
   * Timing.repeat.durationUnit Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** s | min | h | d | wk | mo | a - unit of time (UCUM)
   * - **Definition:** The units of time for the duration, in UCUM units.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private durationUnit?: CodeType | undefined;

  /**
   * Timing.repeat.frequency Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Event occurs frequency times per period
   * - **Definition:** The number of times to repeat the action within the specified period. If frequencyMax is present, this element indicates the lower bound of the allowed range of the frequency.
   * - **FHIR Type:** \`positiveInt\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private frequency?: PositiveIntType | undefined;

  /**
   * Timing.repeat.frequencyMax Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Event occurs up to frequencyMax times per period
   * - **Definition:** If present, indicates that the frequency is a range - so to repeat between [frequency] and [frequencyMax] times within the period or period range.
   * - **FHIR Type:** \`positiveInt\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private frequencyMax?: PositiveIntType | undefined;

  /**
   * Timing.repeat.period Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Event occurs frequency times per period
   * - **Definition:** Indicates the duration of time over which repetitions are to occur; e.g. to express "3 times per day", 3 would be the frequency and "1 day" would be the period. If periodMax is present, this element indicates the lower bound of the allowed range of the period length.
   * - **FHIR Type:** \`decimal\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private period?: DecimalType | undefined;

  /**
   * Timing.repeat.periodMax Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Upper limit of period (3-4 hours)
   * - **Definition:** If present, indicates that the period is a range from [period] to [periodMax], allowing expressing concepts such as "do this once every 3-5 days.
   * - **FHIR Type:** \`decimal\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private periodMax?: DecimalType | undefined;

  /**
   * Timing.repeat.periodUnit Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** s | min | h | d | wk | mo | a - unit of time (UCUM)
   * - **Definition:** The units of time for the period in UCUM units.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private periodUnit?: CodeType | undefined;

  /**
   * FHIR CodeSystem: DaysOfWeek
   *
   * @see {@link DaysOfWeekEnum }
   */
  private readonly daysOfWeekEnum: DaysOfWeekEnum;

  /**
   * Timing.repeat.dayOfWeek Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** mon | tue | wed | thu | fri | sat | sun
   * - **Definition:** If one or more days of week is provided, then the action happens only on the specified day(s).
   * - **Comment:** If no days are specified, the action is assumed to happen every day as otherwise specified. The elements frequency and period cannot be used as well as dayOfWeek.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  private dayOfWeek?: EnumCodeType[] | undefined;

  /**
   * Timing.repeat.timeOfDay Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Time of day for action
   * - **Definition:** Specified time of day for action to take place.
   * - **Comment:** When time of day is specified, it is inferred that the action happens every day (as filtered by dayofWeek) on the specified times. The elements when, frequency and period cannot be used as well as timeOfDay.
   * - **FHIR Type:** \`time\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private timeOfDay?: TimeType[] | undefined;

  /**
   * Timing.repeat.when Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Code for time period of occurrence
   * - **Definition:** An approximate time period during the day, potentially linked to an event of daily living that indicates when the action should occur.
   * - **Comment:** When more than one event is listed, the event is tied to the union of the specified events.
   * - **Requirements:** Timings are frequently determined by occurrences such as waking, eating and sleep.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private when?: CodeType[] | undefined;

  /**
   * Timing.repeat.offset Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Minutes from event (before or after)
   * - **Definition:** The number of minutes from the event. If the event code does not indicate whether the minutes is before or after the event, then the offset is assumed to be after the event.
   * - **FHIR Type:** \`unsignedInt\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private offset?: UnsignedIntType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`bounds\` property value as a DataType object if defined; else undefined
   */
  public getBounds(): IDataType | undefined {
    return this.bounds;
  }

  /**
   * Assigns the provided DataType object value to the \`bounds\` property.
   *
   * @decorator \`@ChoiceDataTypes('Timing.repeat.bounds[x]')\`
   *
   * @param value - the \`bounds\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  @ChoiceDataTypes('Timing.repeat.bounds[x]')
  public setBounds(value: IDataType | undefined): this {
    if (isDefined<IDataType>(value)) {
      // assertFhirType<IDataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.bounds = value;
    } else {
      this.bounds = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`bounds\` property exists and has a value; \`false\` otherwise
   */
  public hasBounds(): boolean {
    return isDefined<IDataType>(this.bounds) && !this.bounds.isEmpty();
  }

  // *** NOTE ***
  // Following choice datatype-specific "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the \`bounds\` property value as a Duration object if defined; else undefined
   */
  public getBoundsDuration(): Duration | undefined {
    if (!isDefined<IDataType | undefined>(this.bounds)) {
      return undefined;
    }
    if (!(this.bounds instanceof Duration)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Timing.repeat.bounds[x]: Expected Duration but encountered \${this.bounds.fhirType()}\`,
      );
    }
    return this.bounds;
  }

  /**
   * @returns \`true\` if the \`bounds\` property exists as a Duration and has a value; \`false\` otherwise
   */
  public hasBoundsDuration(): boolean {
    return this.hasBounds() && this.bounds instanceof Duration;
  }

  /**
   * @returns the \`bounds\` property value as a Range object if defined; else undefined
   */
  public getBoundsRange(): Range | undefined {
    if (!isDefined<IDataType | undefined>(this.bounds)) {
      return undefined;
    }
    if (!(this.bounds instanceof Range)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Timing.repeat.bounds[x]: Expected Range but encountered \${this.bounds.fhirType()}\`,
      );
    }
    return this.bounds;
  }

  /**
   * @returns \`true\` if the \`bounds\` property exists as a Range and has a value; \`false\` otherwise
   */
  public hasBoundsRange(): boolean {
    return this.hasBounds() && this.bounds instanceof Range;
  }

  /**
   * @returns the \`bounds\` property value as a Period object if defined; else undefined
   */
  public getBoundsPeriod(): Period | undefined {
    if (!isDefined<IDataType | undefined>(this.bounds)) {
      return undefined;
    }
    if (!(this.bounds instanceof Period)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Timing.repeat.bounds[x]: Expected Period but encountered \${this.bounds.fhirType()}\`,
      );
    }
    return this.bounds;
  }

  /**
   * @returns \`true\` if the \`bounds\` property exists as a Period and has a value; \`false\` otherwise
   */
  public hasBoundsPeriod(): boolean {
    return this.hasBounds() && this.bounds instanceof Period;
  }

  // End of choice datatype-specific "get"/"has" methods

  /**
   * @returns the \`count\` property value as a PositiveIntType object if defined; else an empty PositiveIntType object
   */
  public getCountElement(): PositiveIntType {
    return this.count ?? new PositiveIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`count\` property.
   *
   * @param element - the \`count\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCountElement(element: PositiveIntType | undefined): this {
    if (isDefined<PositiveIntType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.count; Provided element is not an instance of PositiveIntType.\`;
      assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
      this.count = element;
    } else {
      this.count = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`count\` property exists and has a value; \`false\` otherwise
   */
  public hasCountElement(): boolean {
    return isDefined<PositiveIntType>(this.count) && !this.count.isEmpty();
  }

  /**
   * @returns the \`count\` property value as a fhirPositiveInt if defined; else undefined
   */
  public getCount(): fhirPositiveInt | undefined {
    return this.count?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`count\` property.
   *
   * @param value - the \`count\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCount(value: fhirPositiveInt | undefined): this {
    if (isDefined<fhirPositiveInt>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.count (\${String(value)})\`;
      this.count = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    } else {
      this.count = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`count\` property exists and has a value; \`false\` otherwise
   */
  public hasCount(): boolean {
    return this.hasCountElement();
  }

  /**
   * @returns the \`countMax\` property value as a PositiveIntType object if defined; else an empty PositiveIntType object
   */
  public getCountMaxElement(): PositiveIntType {
    return this.countMax ?? new PositiveIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`countMax\` property.
   *
   * @param element - the \`countMax\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCountMaxElement(element: PositiveIntType | undefined): this {
    if (isDefined<PositiveIntType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.countMax; Provided element is not an instance of PositiveIntType.\`;
      assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
      this.countMax = element;
    } else {
      this.countMax = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`countMax\` property exists and has a value; \`false\` otherwise
   */
  public hasCountMaxElement(): boolean {
    return isDefined<PositiveIntType>(this.countMax) && !this.countMax.isEmpty();
  }

  /**
   * @returns the \`countMax\` property value as a fhirPositiveInt if defined; else undefined
   */
  public getCountMax(): fhirPositiveInt | undefined {
    return this.countMax?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`countMax\` property.
   *
   * @param value - the \`countMax\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCountMax(value: fhirPositiveInt | undefined): this {
    if (isDefined<fhirPositiveInt>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.countMax (\${String(value)})\`;
      this.countMax = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    } else {
      this.countMax = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`countMax\` property exists and has a value; \`false\` otherwise
   */
  public hasCountMax(): boolean {
    return this.hasCountMaxElement();
  }

  /**
   * @returns the \`duration\` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getDurationElement(): DecimalType {
    return this.duration ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`duration\` property.
   *
   * @param element - the \`duration\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDurationElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.duration; Provided element is not an instance of DecimalType.\`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.duration = element;
    } else {
      this.duration = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`duration\` property exists and has a value; \`false\` otherwise
   */
  public hasDurationElement(): boolean {
    return isDefined<DecimalType>(this.duration) && !this.duration.isEmpty();
  }

  /**
   * @returns the \`duration\` property value as a fhirDecimal if defined; else undefined
   */
  public getDuration(): fhirDecimal | undefined {
    return this.duration?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`duration\` property.
   *
   * @param value - the \`duration\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDuration(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.duration (\${String(value)})\`;
      this.duration = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.duration = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`duration\` property exists and has a value; \`false\` otherwise
   */
  public hasDuration(): boolean {
    return this.hasDurationElement();
  }

  /**
   * @returns the \`durationMax\` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getDurationMaxElement(): DecimalType {
    return this.durationMax ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`durationMax\` property.
   *
   * @param element - the \`durationMax\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDurationMaxElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.durationMax; Provided element is not an instance of DecimalType.\`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.durationMax = element;
    } else {
      this.durationMax = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`durationMax\` property exists and has a value; \`false\` otherwise
   */
  public hasDurationMaxElement(): boolean {
    return isDefined<DecimalType>(this.durationMax) && !this.durationMax.isEmpty();
  }

  /**
   * @returns the \`durationMax\` property value as a fhirDecimal if defined; else undefined
   */
  public getDurationMax(): fhirDecimal | undefined {
    return this.durationMax?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`durationMax\` property.
   *
   * @param value - the \`durationMax\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDurationMax(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.durationMax (\${String(value)})\`;
      this.durationMax = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.durationMax = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`durationMax\` property exists and has a value; \`false\` otherwise
   */
  public hasDurationMax(): boolean {
    return this.hasDurationMaxElement();
  }

  /**
   * @returns the \`durationUnit\` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getDurationUnitElement(): CodeType {
    return this.durationUnit ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`durationUnit\` property.
   *
   * @param element - the \`durationUnit\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDurationUnitElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.durationUnit; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.durationUnit = element;
    } else {
      this.durationUnit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`durationUnit\` property exists and has a value; \`false\` otherwise
   */
  public hasDurationUnitElement(): boolean {
    return isDefined<CodeType>(this.durationUnit) && !this.durationUnit.isEmpty();
  }

  /**
   * @returns the \`durationUnit\` property value as a fhirCode if defined; else undefined
   */
  public getDurationUnit(): fhirCode | undefined {
    return this.durationUnit?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`durationUnit\` property.
   *
   * @param value - the \`durationUnit\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDurationUnit(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.durationUnit (\${String(value)})\`;
      this.durationUnit = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.durationUnit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`durationUnit\` property exists and has a value; \`false\` otherwise
   */
  public hasDurationUnit(): boolean {
    return this.hasDurationUnitElement();
  }

  /**
   * @returns the \`frequency\` property value as a PositiveIntType object if defined; else an empty PositiveIntType object
   */
  public getFrequencyElement(): PositiveIntType {
    return this.frequency ?? new PositiveIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`frequency\` property.
   *
   * @param element - the \`frequency\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setFrequencyElement(element: PositiveIntType | undefined): this {
    if (isDefined<PositiveIntType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.frequency; Provided element is not an instance of PositiveIntType.\`;
      assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
      this.frequency = element;
    } else {
      this.frequency = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`frequency\` property exists and has a value; \`false\` otherwise
   */
  public hasFrequencyElement(): boolean {
    return isDefined<PositiveIntType>(this.frequency) && !this.frequency.isEmpty();
  }

  /**
   * @returns the \`frequency\` property value as a fhirPositiveInt if defined; else undefined
   */
  public getFrequency(): fhirPositiveInt | undefined {
    return this.frequency?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`frequency\` property.
   *
   * @param value - the \`frequency\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setFrequency(value: fhirPositiveInt | undefined): this {
    if (isDefined<fhirPositiveInt>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.frequency (\${String(value)})\`;
      this.frequency = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    } else {
      this.frequency = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`frequency\` property exists and has a value; \`false\` otherwise
   */
  public hasFrequency(): boolean {
    return this.hasFrequencyElement();
  }

  /**
   * @returns the \`frequencyMax\` property value as a PositiveIntType object if defined; else an empty PositiveIntType object
   */
  public getFrequencyMaxElement(): PositiveIntType {
    return this.frequencyMax ?? new PositiveIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`frequencyMax\` property.
   *
   * @param element - the \`frequencyMax\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setFrequencyMaxElement(element: PositiveIntType | undefined): this {
    if (isDefined<PositiveIntType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.frequencyMax; Provided element is not an instance of PositiveIntType.\`;
      assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
      this.frequencyMax = element;
    } else {
      this.frequencyMax = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`frequencyMax\` property exists and has a value; \`false\` otherwise
   */
  public hasFrequencyMaxElement(): boolean {
    return isDefined<PositiveIntType>(this.frequencyMax) && !this.frequencyMax.isEmpty();
  }

  /**
   * @returns the \`frequencyMax\` property value as a fhirPositiveInt if defined; else undefined
   */
  public getFrequencyMax(): fhirPositiveInt | undefined {
    return this.frequencyMax?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`frequencyMax\` property.
   *
   * @param value - the \`frequencyMax\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setFrequencyMax(value: fhirPositiveInt | undefined): this {
    if (isDefined<fhirPositiveInt>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.frequencyMax (\${String(value)})\`;
      this.frequencyMax = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    } else {
      this.frequencyMax = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`frequencyMax\` property exists and has a value; \`false\` otherwise
   */
  public hasFrequencyMax(): boolean {
    return this.hasFrequencyMaxElement();
  }

  /**
   * @returns the \`period\` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getPeriodElement(): DecimalType {
    return this.period ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`period\` property.
   *
   * @param element - the \`period\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPeriodElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.period; Provided element is not an instance of DecimalType.\`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.period = element;
    } else {
      this.period = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`period\` property exists and has a value; \`false\` otherwise
   */
  public hasPeriodElement(): boolean {
    return isDefined<DecimalType>(this.period) && !this.period.isEmpty();
  }

  /**
   * @returns the \`period\` property value as a fhirDecimal if defined; else undefined
   */
  public getPeriod(): fhirDecimal | undefined {
    return this.period?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`period\` property.
   *
   * @param value - the \`period\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPeriod(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.period (\${String(value)})\`;
      this.period = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.period = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`period\` property exists and has a value; \`false\` otherwise
   */
  public hasPeriod(): boolean {
    return this.hasPeriodElement();
  }

  /**
   * @returns the \`periodMax\` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getPeriodMaxElement(): DecimalType {
    return this.periodMax ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`periodMax\` property.
   *
   * @param element - the \`periodMax\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPeriodMaxElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.periodMax; Provided element is not an instance of DecimalType.\`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.periodMax = element;
    } else {
      this.periodMax = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`periodMax\` property exists and has a value; \`false\` otherwise
   */
  public hasPeriodMaxElement(): boolean {
    return isDefined<DecimalType>(this.periodMax) && !this.periodMax.isEmpty();
  }

  /**
   * @returns the \`periodMax\` property value as a fhirDecimal if defined; else undefined
   */
  public getPeriodMax(): fhirDecimal | undefined {
    return this.periodMax?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`periodMax\` property.
   *
   * @param value - the \`periodMax\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPeriodMax(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.periodMax (\${String(value)})\`;
      this.periodMax = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.periodMax = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`periodMax\` property exists and has a value; \`false\` otherwise
   */
  public hasPeriodMax(): boolean {
    return this.hasPeriodMaxElement();
  }

  /**
   * @returns the \`periodUnit\` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getPeriodUnitElement(): CodeType {
    return this.periodUnit ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`periodUnit\` property.
   *
   * @param element - the \`periodUnit\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPeriodUnitElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.periodUnit; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.periodUnit = element;
    } else {
      this.periodUnit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`periodUnit\` property exists and has a value; \`false\` otherwise
   */
  public hasPeriodUnitElement(): boolean {
    return isDefined<CodeType>(this.periodUnit) && !this.periodUnit.isEmpty();
  }

  /**
   * @returns the \`periodUnit\` property value as a fhirCode if defined; else undefined
   */
  public getPeriodUnit(): fhirCode | undefined {
    return this.periodUnit?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`periodUnit\` property.
   *
   * @param value - the \`periodUnit\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPeriodUnit(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.periodUnit (\${String(value)})\`;
      this.periodUnit = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.periodUnit = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`periodUnit\` property exists and has a value; \`false\` otherwise
   */
  public hasPeriodUnit(): boolean {
    return this.hasPeriodUnitElement();
  }

  /**
   * @returns the \`dayOfWeek\` property value as a EnumCodeType array
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public getDayOfWeekEnumType(): EnumCodeType[] {
    return this.dayOfWeek ?? ([] as EnumCodeType[]);
  }

  /**
   * Assigns the provided EnumCodeType array value to the \`dayOfWeek\` property.
   *
   * @param enumType - the \`dayOfWeek\` array value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public setDayOfWeekEnumType(enumType: EnumCodeType[] | undefined): this {
    if (isDefinedList<EnumCodeType>(enumType)) {
      const errMsgPrefix = \`Invalid Timing.repeat.dayOfWeek\`;
      assertEnumCodeTypeList<DaysOfWeekEnum>(enumType, DaysOfWeekEnum, errMsgPrefix);
      this.dayOfWeek = enumType;
    } else {
      this.dayOfWeek = undefined;
    }
    return this;
  }

  /**
   * Add the provided EnumCodeType value to the \`dayOfWeek\` array property.
   *
   * @param enumType - the \`dayOfWeek\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public addDayOfWeekEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = \`Invalid Timing.repeat.dayOfWeek\`;
      assertEnumCodeType<DaysOfWeekEnum>(enumType, DaysOfWeekEnum, errMsgPrefix);
      this.initDayOfWeek();
      this.dayOfWeek?.push(enumType);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`dayOfWeek\` property exists and has a value; \`false\` otherwise
   */
  public hasDayOfWeekEnumType(): boolean {
    return isDefinedList<EnumCodeType>(this.dayOfWeek) && this.dayOfWeek.some((item: EnumCodeType) => !item.isEmpty()) && this.dayOfWeek.every((item: EnumCodeType) => item.fhirCodeEnumeration.length > 0);
  }

  /**
   * @returns the \`dayOfWeek\` property value as a CodeType array
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public getDayOfWeekElement(): CodeType[] {
    if (this.dayOfWeek === undefined) {
      return [] as CodeType[];
    }
    return this.dayOfWeek as CodeType[];
  }

  /**
   * Assigns the provided PrimitiveType array value to the \`dayOfWeek\` property.
   *
   * @param element - the \`dayOfWeek\` array value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public setDayOfWeekElement(element: CodeType[] | undefined): this {
    if (isDefinedList<CodeType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.dayOfWeek; Provided element array has an element that is not an instance of CodeType.\`;
      assertFhirTypeList<CodeType>(element, CodeType, optErrMsg);
      const enumCodeTypes = [] as EnumCodeType[];
      element.forEach((type: CodeType) => {
        enumCodeTypes.push(new EnumCodeType(type, this.daysOfWeekEnum));
      });
      this.dayOfWeek = enumCodeTypes;
    } else {
      this.dayOfWeek = undefined;
    }
    return this;
  }

  /**
   * Add the provided PrimitiveType value to the \`dayOfWeek\` array property.
   *
   * @param element - the \`dayOfWeek\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public addDayOfWeekElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.dayOfWeek; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.initDayOfWeek();
      this.dayOfWeek?.push(new EnumCodeType(element, this.daysOfWeekEnum));
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`dayOfWeek\` property exists and has a value; \`false\` otherwise
   */
  public hasDayOfWeekElement(): boolean {
    return this.hasDayOfWeekEnumType();
  }

  /**
   * @returns the \`dayOfWeek\` property value as a fhirCode array
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public getDayOfWeek(): fhirCode[] {
    if (this.dayOfWeek === undefined) {
      return [] as fhirCode[];
    }
    const values = [] as fhirCode[];
    for (const item of this.dayOfWeek) {
      values.push(item.fhirCode.code);
    }
    return values;
  }

  /**
   * Assigns the provided primitive value array to the \`dayOfWeek\` property.
   *
   * @param value - the \`dayOfWeek\` value array
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public setDayOfWeek(value: fhirCode[] | undefined): this {
    if (isDefinedList<fhirCode>(value)) {
      const enumCodeTypes = [] as EnumCodeType[];
      const optErrMsg = \`Invalid Timing.repeat.dayOfWeek; Provided value is not an instance of fhirCode.\`;
      value.forEach((val: fhirCode) => {
        enumCodeTypes.push(new EnumCodeType(parseFhirPrimitiveData(val, fhirCodeSchema, optErrMsg), this.daysOfWeekEnum));
      });
      this.dayOfWeek = enumCodeTypes;
    } else {
      this.dayOfWeek = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`dayOfWeek\` array property.
   *
   * @param value - the \`dayOfWeek\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public addDayOfWeek(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      this.initDayOfWeek();
      const optErrMsg = \`Invalid Timing.repeat.dayOfWeek; Provided value is not an instance of fhirCode.\`;
      this.dayOfWeek?.push(new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.daysOfWeekEnum));
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`dayOfWeek\` property exists and has a value; \`false\` otherwise
   */
  public hasDayOfWeek(): boolean {
    return this.hasDayOfWeekEnumType();
  }

  /**
   * Initialize the dayOfWeek property
   */
  private initDayOfWeek(): void {
    if(!this.hasDayOfWeekEnumType()) {
      this.dayOfWeek = [] as EnumCodeType[];
    }
  }

  /**
   * @returns the \`timeOfDay\` property value as a TimeType array
   */
  public getTimeOfDayElement(): TimeType[] {
    return this.timeOfDay ?? ([] as TimeType[]);
  }

  /**
   * Assigns the provided TimeType array value to the \`timeOfDay\` property.
   *
   * @param element - the \`timeOfDay\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTimeOfDayElement(element: TimeType[] | undefined): this {
    if (isDefinedList<TimeType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.timeOfDay; Provided value array has an element that is not an instance of TimeType.\`;
      assertFhirTypeList<TimeType>(element, TimeType, optErrMsg);
      this.timeOfDay = element;
    } else {
      this.timeOfDay = undefined;
    }
    return this;
  }

  /**
   * Add the provided TimeType value to the \`timeOfDay\` array property.
   *
   * @param element - the \`timeOfDay\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addTimeOfDayElement(element: TimeType | undefined): this {
    if (isDefined<TimeType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.timeOfDay; Provided element is not an instance of TimeType.\`;
      assertFhirType<TimeType>(element, TimeType, optErrMsg);
      this.initTimeOfDay();
      this.timeOfDay?.push(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`timeOfDay\` property exists and has a value; \`false\` otherwise
   */
  public hasTimeOfDayElement(): boolean {
    return isDefinedList<TimeType>(this.timeOfDay) && this.timeOfDay.some((item: TimeType) => !item.isEmpty());
  }

  /**
   * @returns the \`timeOfDay\` property value as a fhirTime array
   */
  public getTimeOfDay(): fhirTime[] {
    this.initTimeOfDay();
    const timeOfDayValues = [] as fhirTime[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.timeOfDay!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        timeOfDayValues.push(value);
      }
    }
    return timeOfDayValues;
  }

  /**
   * Assigns the provided primitive value array to the \`timeOfDay\` property.
   *
   * @param value - the \`timeOfDay\` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTimeOfDay(value: fhirTime[] | undefined): this {
    if (isDefinedList<fhirTime>(value)) {
      const timeOfDayElements = [] as TimeType[];
      for (const timeOfDayValue of value) {
        const optErrMsg = \`Invalid Timing.repeat.timeOfDay array item (\${String(timeOfDayValue)})\`;
        const element = new TimeType(parseFhirPrimitiveData(timeOfDayValue, fhirTimeSchema, optErrMsg));
        timeOfDayElements.push(element);
      }
      this.timeOfDay = timeOfDayElements;
    } else {
      this.timeOfDay = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`timeOfDay\` array property.
   *
   * @param value - the \`timeOfDay\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addTimeOfDay(value: fhirTime | undefined): this {
    if (isDefined<fhirTime>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.timeOfDay array item (\${String(value)})\`;
      const element = new TimeType(parseFhirPrimitiveData(value, fhirTimeSchema, optErrMsg));
      this.initTimeOfDay();
      this.addTimeOfDayElement(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`timeOfDay\` property exists and has a value; \`false\` otherwise
   */
  public hasTimeOfDay(): boolean {
    return this.hasTimeOfDayElement();
  }

  /**
   * Initialize the \`timeOfDay\` property
   */
  private initTimeOfDay(): void {
    if (!this.hasTimeOfDay()) {
      this.timeOfDay = [] as TimeType[];
    }
  }

  /**
   * @returns the \`when\` property value as a CodeType array
   */
  public getWhenElement(): CodeType[] {
    return this.when ?? ([] as CodeType[]);
  }

  /**
   * Assigns the provided CodeType array value to the \`when\` property.
   *
   * @param element - the \`when\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setWhenElement(element: CodeType[] | undefined): this {
    if (isDefinedList<CodeType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.when; Provided value array has an element that is not an instance of CodeType.\`;
      assertFhirTypeList<CodeType>(element, CodeType, optErrMsg);
      this.when = element;
    } else {
      this.when = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeType value to the \`when\` array property.
   *
   * @param element - the \`when\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addWhenElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.when; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.initWhen();
      this.when?.push(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`when\` property exists and has a value; \`false\` otherwise
   */
  public hasWhenElement(): boolean {
    return isDefinedList<CodeType>(this.when) && this.when.some((item: CodeType) => !item.isEmpty());
  }

  /**
   * @returns the \`when\` property value as a fhirCode array
   */
  public getWhen(): fhirCode[] {
    this.initWhen();
    const whenValues = [] as fhirCode[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.when!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        whenValues.push(value);
      }
    }
    return whenValues;
  }

  /**
   * Assigns the provided primitive value array to the \`when\` property.
   *
   * @param value - the \`when\` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setWhen(value: fhirCode[] | undefined): this {
    if (isDefinedList<fhirCode>(value)) {
      const whenElements = [] as CodeType[];
      for (const whenValue of value) {
        const optErrMsg = \`Invalid Timing.repeat.when array item (\${String(whenValue)})\`;
        const element = new CodeType(parseFhirPrimitiveData(whenValue, fhirCodeSchema, optErrMsg));
        whenElements.push(element);
      }
      this.when = whenElements;
    } else {
      this.when = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`when\` array property.
   *
   * @param value - the \`when\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addWhen(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.when array item (\${String(value)})\`;
      const element = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
      this.initWhen();
      this.addWhenElement(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`when\` property exists and has a value; \`false\` otherwise
   */
  public hasWhen(): boolean {
    return this.hasWhenElement();
  }

  /**
   * Initialize the \`when\` property
   */
  private initWhen(): void {
    if (!this.hasWhen()) {
      this.when = [] as CodeType[];
    }
  }

  /**
   * @returns the \`offset\` property value as a UnsignedIntType object if defined; else an empty UnsignedIntType object
   */
  public getOffsetElement(): UnsignedIntType {
    return this.offset ?? new UnsignedIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`offset\` property.
   *
   * @param element - the \`offset\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setOffsetElement(element: UnsignedIntType | undefined): this {
    if (isDefined<UnsignedIntType>(element)) {
      const optErrMsg = \`Invalid Timing.repeat.offset; Provided element is not an instance of UnsignedIntType.\`;
      assertFhirType<UnsignedIntType>(element, UnsignedIntType, optErrMsg);
      this.offset = element;
    } else {
      this.offset = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`offset\` property exists and has a value; \`false\` otherwise
   */
  public hasOffsetElement(): boolean {
    return isDefined<UnsignedIntType>(this.offset) && !this.offset.isEmpty();
  }

  /**
   * @returns the \`offset\` property value as a fhirUnsignedInt if defined; else undefined
   */
  public getOffset(): fhirUnsignedInt | undefined {
    return this.offset?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`offset\` property.
   *
   * @param value - the \`offset\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setOffset(value: fhirUnsignedInt | undefined): this {
    if (isDefined<fhirUnsignedInt>(value)) {
      const optErrMsg = \`Invalid Timing.repeat.offset (\${String(value)})\`;
      this.offset = new UnsignedIntType(parseFhirPrimitiveData(value, fhirUnsignedIntSchema, optErrMsg));
    } else {
      this.offset = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`offset\` property exists and has a value; \`false\` otherwise
   */
  public hasOffset(): boolean {
    return this.hasOffsetElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Timing.repeat';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.bounds,
      this.count,
      this.countMax,
      this.duration,
      this.durationMax,
      this.durationUnit,
      this.frequency,
      this.frequencyMax,
      this.period,
      this.periodMax,
      this.periodUnit,
      this.dayOfWeek,
      this.timeOfDay,
      this.when,
      this.offset,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): TimingRepeatComponent {
    const dest = new TimingRepeatComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: TimingRepeatComponent): void {
    super.copyValues(dest);
    dest.bounds = this.bounds?.copy() as IDataType;
    dest.count = this.count?.copy();
    dest.countMax = this.countMax?.copy();
    dest.duration = this.duration?.copy();
    dest.durationMax = this.durationMax?.copy();
    dest.durationUnit = this.durationUnit?.copy();
    dest.frequency = this.frequency?.copy();
    dest.frequencyMax = this.frequencyMax?.copy();
    dest.period = this.period?.copy();
    dest.periodMax = this.periodMax?.copy();
    dest.periodUnit = this.periodUnit?.copy();
    const dayOfWeekList = copyListValues<EnumCodeType>(this.dayOfWeek);
    dest.dayOfWeek = dayOfWeekList.length === 0 ? undefined : dayOfWeekList;
    const timeOfDayList = copyListValues<TimeType>(this.timeOfDay);
    dest.timeOfDay = timeOfDayList.length === 0 ? undefined : timeOfDayList;
    const whenList = copyListValues<CodeType>(this.when);
    dest.when = whenList.length === 0 ? undefined : whenList;
    dest.offset = this.offset?.copy();
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', \`UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasBounds()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getBounds()!, 'bounds', jsonObj);
    }

    if (this.hasCountElement()) {
      setFhirPrimitiveJson<fhirPositiveInt>(this.getCountElement(), 'count', jsonObj);
    }

    if (this.hasCountMaxElement()) {
      setFhirPrimitiveJson<fhirPositiveInt>(this.getCountMaxElement(), 'countMax', jsonObj);
    }

    if (this.hasDurationElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getDurationElement(), 'duration', jsonObj);
    }

    if (this.hasDurationMaxElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getDurationMaxElement(), 'durationMax', jsonObj);
    }

    if (this.hasDurationUnitElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getDurationUnitElement(), 'durationUnit', jsonObj);
    }

    if (this.hasFrequencyElement()) {
      setFhirPrimitiveJson<fhirPositiveInt>(this.getFrequencyElement(), 'frequency', jsonObj);
    }

    if (this.hasFrequencyMaxElement()) {
      setFhirPrimitiveJson<fhirPositiveInt>(this.getFrequencyMaxElement(), 'frequencyMax', jsonObj);
    }

    if (this.hasPeriodElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getPeriodElement(), 'period', jsonObj);
    }

    if (this.hasPeriodMaxElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getPeriodMaxElement(), 'periodMax', jsonObj);
    }

    if (this.hasPeriodUnitElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getPeriodUnitElement(), 'periodUnit', jsonObj);
    }

    if (this.hasDayOfWeekElement()) {
      setFhirPrimitiveListJson<fhirCode>(this.getDayOfWeekElement(), 'dayOfWeek', jsonObj);
    }

    if (this.hasTimeOfDay()) {
      setFhirPrimitiveListJson(this.getTimeOfDayElement(), 'timeOfDay', jsonObj);
    }

    if (this.hasWhen()) {
      setFhirPrimitiveListJson(this.getWhenElement(), 'when', jsonObj);
    }

    if (this.hasOffsetElement()) {
      setFhirPrimitiveJson<fhirUnsignedInt>(this.getOffsetElement(), 'offset', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * TriggerDefinition Class
 *
 * @remarks
 * Base StructureDefinition for TriggerDefinition Type: A description of a triggering event. Triggering events can be named events, data events, or periodic, as determined by the type element.
 *
 * **FHIR Specification**
 * - **Short:** Defines an expected trigger for a module
 * - **Definition:** A description of a triggering event. Triggering events can be named events, data events, or periodic, as determined by the type element.
 * - **Comment:** If an event is a named-event, it means the event is completely pre-coordinated, and no other information can be specified for the event. If the event is one of the data- events, the data and condition elements specify the triggering criteria. The data element specifies the structured component, and the condition element provides additional optional refinement of that structured component. If the event is periodic, the timing element defines when the event is triggered. For both data- and periodic events, a name can be provided as a shorthand for the formal semantics provided by the other elements.
 * - **FHIR Version:** 4.0.1
 *
 * @category Data Models: ComplexType
 * @see [FHIR TriggerDefinition](http://hl7.org/fhir/StructureDefinition/TriggerDefinition)
 */
/* istanbul ignore next */ export class TriggerDefinition extends DataType implements IDataType {
  constructor(type_: EnumCodeType | CodeType | fhirCode | null = null) {
    super();

    this.triggerTypeEnum = new TriggerTypeEnum();

    this.type_ = constructorCodeValueAsEnumCodeType<TriggerTypeEnum>(
      type_,
      TriggerTypeEnum,
      this.triggerTypeEnum,
      'TriggerDefinition.type',
    );
  }

  /**
   * Parse the provided \`TriggerDefinition\` JSON to instantiate the TriggerDefinition data model.
   *
   * @param sourceJson - JSON representing FHIR \`TriggerDefinition\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to TriggerDefinition
   * @returns TriggerDefinition data model or undefined for \`TriggerDefinition\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): TriggerDefinition | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'TriggerDefinition';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new TriggerDefinition();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const classMetadata: DecoratorMetadataObject | null = TriggerDefinition[Symbol.metadata];
    const errorMessage = \`DecoratorMetadataObject does not exist for TriggerDefinition\`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    const missingReqdProperties: string[] = [];

    fieldName = 'type';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setTypeElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'name';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setNameElement(datatype);
    }

    fieldName = 'timing[x]';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const timing: IDataType | undefined = fhirParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setTiming(timing);

    fieldName = 'data';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: DataRequirement | undefined = DataRequirement.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addData(datatype);
        }
      });
    }

    fieldName = 'condition';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Expression | undefined = Expression.parse(classJsonObj[fieldName]!, sourceField);
      instance.setCondition(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: TriggerType
   *
   * @see {@link TriggerTypeEnum }
   */
  private readonly triggerTypeEnum: TriggerTypeEnum;

  /**
   * TriggerDefinition.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** named-event | periodic | data-changed | data-added | data-modified | data-removed | data-accessed | data-access-ended
   * - **Definition:** The type of triggering event.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link TriggerTypeEnum }
   */
  private type_: EnumCodeType | null;

  /**
   * TriggerDefinition.name Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Name or URI that identifies the event
   * - **Definition:** A formal name for the event. This may be an absolute URI that identifies the event formally (e.g. from a trigger registry), or a simple relative URI that identifies the event in a local context.
   * - **Comment:** An event name can be provided for all event types, but is required for named events. If a name is provided for a type other than named events, it is considered to be a shorthand for the semantics described by the formal description of the event.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private name?: StringType | undefined;

  /**
   * TriggerDefinition.timing[x] Element
   *
   * @decorator \`@ChoiceDataTypesMeta('TriggerDefinition.timing[x]', ['Timing','Reference','date','dateTime',]\`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Timing of the event
   * - **Definition:** The timing of the event (if this is a periodic trigger).
   * - **FHIR Types:**
   *     'Timing',
   *     'Reference',
   *     'date',
   *     'dateTime',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('TriggerDefinition.timing[x]',[
    'Timing',
    'Reference',
    'date',
    'dateTime',
  ])
  private timing?: IDataType | undefined;

  /**
   * TriggerDefinition.data Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Triggering data of the event (multiple = \\'and\\')
   * - **Definition:** The triggering data of the event (if this is a data trigger). If more than one data is requirement is specified, then all the data requirements must be true.
   * - **Comment:** This element shall be present for any data type trigger.
   * - **FHIR Type:** \`DataRequirement\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private data?: DataRequirement[] | undefined;

  /**
   * TriggerDefinition.condition Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Whether the event triggers (boolean expression)
   * - **Definition:** A boolean-valued expression that is evaluated in the context of the container of the trigger definition and returns whether or not the trigger fires.
   * - **Comment:** This element can be only be specified for data type triggers and provides additional semantics for the trigger. The context available within the condition is based on the type of data event. For all events, the current resource will be available as context. In addition, for modification events, the previous resource will also be available. The expression may be inlined, or may be a simple absolute URI, which is a reference to a named expression within a logic library referenced by a library element or extension within the containing resource. If the expression is a FHIR Path expression, it evaluates in the context of a resource of one of the type identified in the data requirement, and may also refer to the variable %previous for delta comparisons on events of type data-changed, data-modified, and data-deleted which will always have the same type.
   * - **Requirements:** Need to be able to formally describe the triggering criteria.
   * - **FHIR Type:** \`Expression\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private condition?: Expression | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`type_\` property value as a EnumCodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link TriggerTypeEnum }
   */
  public getTypeEnumType(): EnumCodeType | null {
    return this.type_;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`type_\` property.
   *
   * @param enumType - the \`type_\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link TriggerTypeEnum }
   */
  public setTypeEnumType(enumType: EnumCodeType): this {
    assertIsDefined<EnumCodeType>(enumType, \`TriggerDefinition.type is required\`);
    const errMsgPrefix = \`Invalid TriggerDefinition.type\`;
    assertEnumCodeType<TriggerTypeEnum>(enumType, TriggerTypeEnum, errMsgPrefix);
    this.type_ = enumType;
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasTypeEnumType(): boolean {
    return isDefined<EnumCodeType>(this.type_) && !this.type_.isEmpty() && this.type_.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`type_\` property value as a CodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link TriggerTypeEnum }
   */
  public getTypeElement(): CodeType | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_ as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`type_\` property.
   *
   * @param element - the \`type_\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link TriggerTypeEnum }
   */
  public setTypeElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, \`TriggerDefinition.type is required\`);
    const optErrMsg = \`Invalid TriggerDefinition.type; Provided value is not an instance of CodeType.\`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.type_ = new EnumCodeType(element, this.triggerTypeEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasTypeElement(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the \`type_\` property value as a fhirCode if defined; else null
   *
   * @see CodeSystem Enumeration: {@link TriggerTypeEnum }
   */
  public getType(): fhirCode | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`type_\` property.
   *
   * @param value - the \`type_\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link TriggerTypeEnum }
   */
  public setType(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, \`TriggerDefinition.type is required\`);
    const optErrMsg = \`Invalid TriggerDefinition.type (\${String(value)})\`;
    this.type_ = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.triggerTypeEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasType(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the \`name\` property value as a StringType object if defined; else an empty StringType object
   */
  public getNameElement(): StringType {
    return this.name ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`name\` property.
   *
   * @param element - the \`name\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setNameElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid TriggerDefinition.name; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.name = element;
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`name\` property exists and has a value; \`false\` otherwise
   */
  public hasNameElement(): boolean {
    return isDefined<StringType>(this.name) && !this.name.isEmpty();
  }

  /**
   * @returns the \`name\` property value as a fhirString if defined; else undefined
   */
  public getName(): fhirString | undefined {
    return this.name?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`name\` property.
   *
   * @param value - the \`name\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setName(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid TriggerDefinition.name (\${String(value)})\`;
      this.name = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`name\` property exists and has a value; \`false\` otherwise
   */
  public hasName(): boolean {
    return this.hasNameElement();
  }

  /**
   * @returns the \`timing\` property value as a DataType object if defined; else undefined
   */
  public getTiming(): IDataType | undefined {
    return this.timing;
  }

  /**
   * Assigns the provided DataType object value to the \`timing\` property.
   *
   * @decorator \`@ChoiceDataTypes('TriggerDefinition.timing[x]')\`
   *
   * @param value - the \`timing\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  @ChoiceDataTypes('TriggerDefinition.timing[x]')
  public setTiming(value: IDataType | undefined): this {
    if (isDefined<IDataType>(value)) {
      // assertFhirType<IDataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.timing = value;
    } else {
      this.timing = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`timing\` property exists and has a value; \`false\` otherwise
   */
  public hasTiming(): boolean {
    return isDefined<IDataType>(this.timing) && !this.timing.isEmpty();
  }

  // *** NOTE ***
  // Following choice datatype-specific "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the \`timing\` property value as a Timing object if defined; else undefined
   */
  public getTimingTiming(): Timing | undefined {
    if (!isDefined<IDataType | undefined>(this.timing)) {
      return undefined;
    }
    if (!(this.timing instanceof Timing)) {
      throw new InvalidTypeError(
        \`DataType mismatch for TriggerDefinition.timing[x]: Expected Timing but encountered \${this.timing.fhirType()}\`,
      );
    }
    return this.timing;
  }

  /**
   * @returns \`true\` if the \`timing\` property exists as a Timing and has a value; \`false\` otherwise
   */
  public hasTimingTiming(): boolean {
    return this.hasTiming() && this.timing instanceof Timing;
  }

  /**
   * @returns the \`timing\` property value as a Reference object if defined; else undefined
   */
  public getTimingReference(): Reference | undefined {
    if (!isDefined<IDataType | undefined>(this.timing)) {
      return undefined;
    }
    if (!(this.timing instanceof Reference)) {
      throw new InvalidTypeError(
        \`DataType mismatch for TriggerDefinition.timing[x]: Expected Reference but encountered \${this.timing.fhirType()}\`,
      );
    }
    return this.timing;
  }

  /**
   * @returns \`true\` if the \`timing\` property exists as a Reference and has a value; \`false\` otherwise
   */
  public hasTimingReference(): boolean {
    return this.hasTiming() && this.timing instanceof Reference;
  }

  /**
   * @returns the \`timing\` property value as a DateType object if defined; else undefined
   */
  public getTimingDateType(): DateType | undefined {
    if (!isDefined<IDataType | undefined>(this.timing)) {
      return undefined;
    }
    if (!(this.timing instanceof DateType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for TriggerDefinition.timing[x]: Expected DateType but encountered \${this.timing.fhirType()}\`,
      );
    }
    return this.timing;
  }

  /**
   * @returns \`true\` if the \`timing\` property exists as a DateType and has a value; \`false\` otherwise
   */
  public hasTimingDateType(): boolean {
    return this.hasTiming() && this.timing instanceof DateType;
  }

  /**
   * @returns the \`timing\` property value as a DateTimeType object if defined; else undefined
   */
  public getTimingDateTimeType(): DateTimeType | undefined {
    if (!isDefined<IDataType | undefined>(this.timing)) {
      return undefined;
    }
    if (!(this.timing instanceof DateTimeType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for TriggerDefinition.timing[x]: Expected DateTimeType but encountered \${this.timing.fhirType()}\`,
      );
    }
    return this.timing;
  }

  /**
   * @returns \`true\` if the \`timing\` property exists as a DateTimeType and has a value; \`false\` otherwise
   */
  public hasTimingDateTimeType(): boolean {
    return this.hasTiming() && this.timing instanceof DateTimeType;
  }

  // End of choice datatype-specific "get"/"has" methods

  /**
   * @returns the \`data\` property value as a DataRequirement array
   */
  public getData(): DataRequirement[] {
    return this.data ?? ([] as DataRequirement[]);
  }

  /**
   * Assigns the provided DataRequirement array value to the \`data\` property.
   *
   * @param value - the \`data\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setData(value: DataRequirement[] | undefined): this {
    if (isDefinedList<DataRequirement>(value)) {
      const optErrMsg = \`Invalid TriggerDefinition.data; Provided value array has an element that is not an instance of DataRequirement.\`;
      assertFhirTypeList<DataRequirement>(value, DataRequirement, optErrMsg);
      this.data = value;
    } else {
      this.data = undefined;
    }
    return this;
  }

  /**
   * Add the provided DataRequirement value to the \`data\` array property.
   *
   * @param value - the \`data\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addData(value: DataRequirement | undefined): this {
    if (isDefined<DataRequirement>(value)) {
      const optErrMsg = \`Invalid TriggerDefinition.data; Provided element is not an instance of DataRequirement.\`;
      assertFhirType<DataRequirement>(value, DataRequirement, optErrMsg);
      this.initData();
      this.data?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`data\` property exists and has a value; \`false\` otherwise
   */
  public hasData(): boolean {
    return isDefinedList<DataRequirement>(this.data) && this.data.some((item: DataRequirement) => !item.isEmpty());
  }

  /**
   * Initialize the \`data\` property
   */
  private initData(): void {
    if(!this.hasData()) {
      this.data = [] as DataRequirement[];
    }
  }

  /**
   * @returns the \`condition\` property value as a Expression object if defined; else an empty Expression object
   */
  public getCondition(): Expression {
    return this.condition ?? new Expression();
  }

  /**
   * Assigns the provided Condition object value to the \`condition\` property.
   *
   * @param value - the \`condition\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setCondition(value: Expression | undefined): this {
    if (isDefined<Expression>(value)) {
      const optErrMsg = \`Invalid TriggerDefinition.condition; Provided element is not an instance of Expression.\`;
      assertFhirType<Expression>(value, Expression, optErrMsg);
      this.condition = value;
    } else {
      this.condition = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`condition\` property exists and has a value; \`false\` otherwise
   */
  public hasCondition(): boolean {
    return isDefined<Expression>(this.condition) && !this.condition.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'TriggerDefinition';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.type_,
      this.name,
      this.timing,
      this.data,
      this.condition,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): TriggerDefinition {
    const dest = new TriggerDefinition();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: TriggerDefinition): void {
    super.copyValues(dest);
    dest.type_ = this.type_ ? this.type_.copy() : null;
    dest.name = this.name?.copy();
    dest.timing = this.timing?.copy() as IDataType;
    const dataList = copyListValues<DataRequirement>(this.data);
    dest.data = dataList.length === 0 ? undefined : dataList;
    dest.condition = this.condition?.copy();
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', \`UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasTypeElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getTypeElement()!, 'type', jsonObj);
    } else {
      missingReqdProperties.push(\`TriggerDefinition.type\`);
    }

    if (this.hasNameElement()) {
      setFhirPrimitiveJson<fhirString>(this.getNameElement(), 'name', jsonObj);
    }

    if (this.hasTiming()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getTiming()!, 'timing', jsonObj);
    }

    if (this.hasData()) {
      setFhirComplexListJson(this.getData(), 'data', jsonObj);
    }

    if (this.hasCondition()) {
      setFhirComplexJson(this.getCondition(), 'condition', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

/**
 * UsageContext Class
 *
 * @remarks
 * Base StructureDefinition for UsageContext Type: Specifies clinical/business/etc. metadata that can be used to retrieve, index and/or categorize an artifact. This metadata can either be specific to the applicable population (e.g., age category, DRG) or the specific context of care (e.g., venue, care setting, provider of care).
 *
 * Consumers of the resource must be able to determine the intended applicability for the resource. Ideally, this information would be used programmatically to determine when and how it should be incorporated or exposed.
 *
 * **FHIR Specification**
 * - **Short:** Describes the context of use for a conformance or knowledge resource
 * - **Definition:** Specifies clinical/business/etc. metadata that can be used to retrieve, index and/or categorize an artifact. This metadata can either be specific to the applicable population (e.g., age category, DRG) or the specific context of care (e.g., venue, care setting, provider of care).
 * - **FHIR Version:** 4.0.1
 *
 * @category Data Models: ComplexType
 * @see [FHIR UsageContext](http://hl7.org/fhir/StructureDefinition/UsageContext)
 */
/* istanbul ignore next */ export class UsageContext extends DataType implements IDataType {
  constructor(code: Coding | null = null, value: IDataType | null = null) {
    super();

    this.code = null;
    if (isDefined<Coding>(code)) {
      this.setCode(code);
    }

    this.value = null;
    if (isDefined<IDataType>(value)) {
      this.setValue(value);
    }

  }

  /**
   * Parse the provided \`UsageContext\` JSON to instantiate the UsageContext data model.
   *
   * @param sourceJson - JSON representing FHIR \`UsageContext\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to UsageContext
   * @returns UsageContext data model or undefined for \`UsageContext\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): UsageContext | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'UsageContext';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new UsageContext();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';

    const classMetadata: DecoratorMetadataObject | null = UsageContext[Symbol.metadata];
    const errorMessage = \`DecoratorMetadataObject does not exist for UsageContext\`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    const missingReqdProperties: string[] = [];

    fieldName = 'code';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Coding | undefined = Coding.parse(classJsonObj[fieldName]!, sourceField);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setCode(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'value[x]';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const value: IDataType | undefined = fhirParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    if (value === undefined) {
      missingReqdProperties.push(sourceField);
    } else {
      instance.setValue(value);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * UsageContext.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Type of context being specified
   * - **Definition:** A code that identifies the type of context being specified by this usage context.
   * - **FHIR Type:** \`Coding\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code: Coding | null;

  /**
   * UsageContext.value[x] Element
   *
   * @decorator \`@ChoiceDataTypesMeta('UsageContext.value[x]', ['CodeableConcept','Quantity','Range','Reference',]\`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Value that defines the context
   * - **Definition:** A value that defines the context specified in this context of use. The interpretation of the value is defined by the code.
   * - **FHIR Types:**
   *     'CodeableConcept',
   *     'Quantity',
   *     'Range',
   *     'Reference',
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('UsageContext.value[x]',[
    'CodeableConcept',
    'Quantity',
    'Range',
    'Reference',
  ])
  private value: IDataType | null;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`code\` property value as a Coding object if defined; else null
   */
  public getCode(): Coding | null {
    return this.code;
  }

  /**
   * Assigns the provided Coding object value to the \`code\` property.
   *
   * @param value - the \`code\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setCode(value: Coding): this {
    assertIsDefined<Coding>(value, \`UsageContext.code is required\`);
    const optErrMsg = \`Invalid UsageContext.code; Provided element is not an instance of Coding.\`;
    assertFhirType<Coding>(value, Coding, optErrMsg);
    this.code = value;
    return this;
  }

  /**
   * @returns \`true\` if the \`code\` property exists and has a value; \`false\` otherwise
   */
  public hasCode(): boolean {
    return isDefined<Coding>(this.code) && !this.code.isEmpty();
  }

  /**
   * @returns the \`value\` property value as a DataType object; else null
   */
  public getValue(): IDataType | null {
    return this.value;
  }

  /**
   * Assigns the provided DataType object value to the \`value\` property.
   *
   * @decorator \`@ChoiceDataTypes('UsageContext.value[x]')\`
   *
   * @param value - the \`value\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  @ChoiceDataTypes('UsageContext.value[x]')
  public setValue(value: IDataType): this {
    assertIsDefined<IDataType>(value, \`UsageContext.value[x] is required\`);
    // assertFhirType<IDataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
    this.value = value;
    return this;
  }

  /**
   * @returns \`true\` if the \`value\` property exists and has a value; \`false\` otherwise
   */
  public hasValue(): boolean {
    return isDefined<IDataType>(this.value) && !this.value.isEmpty();
  }

  // *** NOTE ***
  // Following choice datatype-specific "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the \`value\` property value as a CodeableConcept object if defined; else null
   */
  public getValueCodeableConcept(): CodeableConcept | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof CodeableConcept)) {
      throw new InvalidTypeError(
        \`DataType mismatch for UsageContext.value[x]: Expected CodeableConcept but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`\` property exists as a CodeableConcept and has a value; \`false\` otherwise
   */
  public hasValueCodeableConcept(): boolean {
    return this.hasValue() && this.value instanceof CodeableConcept;
  }

  /**
   * @returns the \`value\` property value as a Quantity object if defined; else null
   */
  public getValueQuantity(): Quantity | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Quantity)) {
      throw new InvalidTypeError(
        \`DataType mismatch for UsageContext.value[x]: Expected Quantity but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`\` property exists as a Quantity and has a value; \`false\` otherwise
   */
  public hasValueQuantity(): boolean {
    return this.hasValue() && this.value instanceof Quantity;
  }

  /**
   * @returns the \`value\` property value as a Range object if defined; else null
   */
  public getValueRange(): Range | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Range)) {
      throw new InvalidTypeError(
        \`DataType mismatch for UsageContext.value[x]: Expected Range but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`\` property exists as a Range and has a value; \`false\` otherwise
   */
  public hasValueRange(): boolean {
    return this.hasValue() && this.value instanceof Range;
  }

  /**
   * @returns the \`value\` property value as a Reference object if defined; else null
   */
  public getValueReference(): Reference | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Reference)) {
      throw new InvalidTypeError(
        \`DataType mismatch for UsageContext.value[x]: Expected Reference but encountered \${this.value.fhirType()}\`,
      );
    }
    return this.value;
  }

  /**
   * @returns \`true\` if the \`\` property exists as a Reference and has a value; \`false\` otherwise
   */
  public hasValueReference(): boolean {
    return this.hasValue() && this.value instanceof Reference;
  }

  // End of choice datatype-specific "get"/"has" methods

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'UsageContext';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.code,
      this.value,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): UsageContext {
    const dest = new UsageContext();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: UsageContext): void {
    super.copyValues(dest);
    dest.code = this.code ? this.code.copy() : null;
    dest.value = this.value ? this.value.copy() as IDataType : null;
  }

  /**
   * @returns \`true\` if the instance is a FHIR complex datatype; \`false\` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', \`UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasCode()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirComplexJson(this.getCode()!, 'code', jsonObj);
    } else {
      missingReqdProperties.push(\`UsageContext.code\`);
    }

    if (this.hasValue()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getValue()!, 'value', jsonObj);
    } else {
      missingReqdProperties.push(\`UsageContext.value[x]\`);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

/**
 * PARSABLE_DATATYPE_MAP
 *
 * @remarks
 * Map of all parsable DataTypes where the key is the name of the DataType and the value is its ParsableDataType<DataType> class.
 *
 * @internal
 */
export const PARSABLE_DATATYPE_MAP = new Map<string, ParsableDataType<DataType>>();
PARSABLE_DATATYPE_MAP.set('Address', Address);
PARSABLE_DATATYPE_MAP.set('Age', Age);
PARSABLE_DATATYPE_MAP.set('Annotation', Annotation);
PARSABLE_DATATYPE_MAP.set('Attachment', Attachment);
PARSABLE_DATATYPE_MAP.set('CodeableConcept', CodeableConcept);
PARSABLE_DATATYPE_MAP.set('Coding', Coding);
PARSABLE_DATATYPE_MAP.set('ContactDetail', ContactDetail);
PARSABLE_DATATYPE_MAP.set('ContactPoint', ContactPoint);
PARSABLE_DATATYPE_MAP.set('Contributor', Contributor);
PARSABLE_DATATYPE_MAP.set('Count', Count);
PARSABLE_DATATYPE_MAP.set('DataRequirement', DataRequirement);
PARSABLE_DATATYPE_MAP.set('Distance', Distance);
PARSABLE_DATATYPE_MAP.set('Dosage', Dosage);
PARSABLE_DATATYPE_MAP.set('Duration', Duration);
PARSABLE_DATATYPE_MAP.set('Expression', Expression);
PARSABLE_DATATYPE_MAP.set('HumanName', HumanName);
PARSABLE_DATATYPE_MAP.set('Identifier', Identifier);
PARSABLE_DATATYPE_MAP.set('Meta', Meta);
PARSABLE_DATATYPE_MAP.set('Money', Money);
PARSABLE_DATATYPE_MAP.set('Narrative', Narrative);
PARSABLE_DATATYPE_MAP.set('ParameterDefinition', ParameterDefinition);
PARSABLE_DATATYPE_MAP.set('Period', Period);
PARSABLE_DATATYPE_MAP.set('ProdCharacteristic', ProdCharacteristic);
PARSABLE_DATATYPE_MAP.set('ProductShelfLife', ProductShelfLife);
PARSABLE_DATATYPE_MAP.set('Quantity', Quantity);
PARSABLE_DATATYPE_MAP.set('Range', Range);
PARSABLE_DATATYPE_MAP.set('Ratio', Ratio);
PARSABLE_DATATYPE_MAP.set('Reference', Reference);
PARSABLE_DATATYPE_MAP.set('RelatedArtifact', RelatedArtifact);
PARSABLE_DATATYPE_MAP.set('SampledData', SampledData);
PARSABLE_DATATYPE_MAP.set('Signature', Signature);
PARSABLE_DATATYPE_MAP.set('Timing', Timing);
PARSABLE_DATATYPE_MAP.set('TriggerDefinition', TriggerDefinition);
PARSABLE_DATATYPE_MAP.set('UsageContext', UsageContext);
",
  "fileExtension": "ts",
  "filename": "complex-datatypes",
}
`;

exports[`generator-datamodel-ftest Functional Test Suite generator-app verify generated content should consistently create GeneratedContent[] 30`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/src",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/test/ftest-cache",
    "pkgName": "ftest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "Resource",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * Bundle Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/Bundle
 * StructureDefinition.name: Bundle
 * StructureDefinition.description: A container for a collection of resources.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  BackboneElement,
  CodeType,
  DecimalType,
  EnumCodeType,
  FhirError,
  FhirParser,
  IBackboneElement,
  INSTANCE_EMPTY_ERROR_MSG,
  IResource,
  InstantType,
  JSON,
  PrimitiveType,
  REQUIRED_PROPERTIES_DO_NOT_EXIST,
  REQUIRED_PROPERTIES_REQD_IN_JSON,
  Resource,
  StringType,
  UnsignedIntType,
  UriType,
  assertEnumCodeType,
  assertFhirResourceType,
  assertFhirType,
  assertFhirTypeList,
  assertIsDefined,
  constructorCodeValueAsEnumCodeType,
  copyListValues,
  fhirCode,
  fhirCodeSchema,
  fhirDecimal,
  fhirDecimalSchema,
  fhirInstant,
  fhirInstantSchema,
  fhirString,
  fhirStringSchema,
  fhirUnsignedInt,
  fhirUnsignedIntSchema,
  fhirUri,
  fhirUriSchema,
  getPrimitiveTypeJson,
  isDefined,
  isDefinedList,
  isElementEmpty,
  isEmpty,
  parseFhirPrimitiveData,
  setFhirBackboneElementJson,
  setFhirBackboneElementListJson,
  setFhirComplexJson,
  setFhirPrimitiveJson,
  setFhirResourceJson,
} from '@paq-ts-fhir/fhir-core';
import { BundleTypeEnum } from '../code-systems/BundleTypeEnum';
import { HttpVerbEnum } from '../code-systems/HttpVerbEnum';
import { Identifier, PARSABLE_DATATYPE_MAP, Signature } from '../complex-types/complex-datatypes';
import { PARSABLE_RESOURCE_MAP } from './parsable-resource-map';
import { SearchEntryModeEnum } from '../code-systems/SearchEntryModeEnum';

/**
 * Bundle Class
 *
 * @remarks
 * A container for a collection of resources.
 *
 * **FHIR Specification**
 * - **Short:** Contains a collection of resources
 * - **Definition:** A container for a collection of resources.
 * - **FHIR Version:** 4.0.1
 *
 * @category Data Models: Resource
 * @see [FHIR Bundle](http://hl7.org/fhir/StructureDefinition/Bundle)
 */
export class Bundle extends Resource implements IResource {
  constructor(type_: EnumCodeType | CodeType | fhirCode | null = null) {
    super();

    this.bundleTypeEnum = new BundleTypeEnum();

    this.type_ = constructorCodeValueAsEnumCodeType<BundleTypeEnum>(
      type_,
      BundleTypeEnum,
      this.bundleTypeEnum,
      'Bundle.type',
    );
  }

  /**
   * Parse the provided \`Bundle\` JSON to instantiate the Bundle data model.
   *
   * @param sourceJson - JSON representing FHIR \`Bundle\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Bundle
   * @returns Bundle data model or undefined for \`Bundle\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static override parse(sourceJson: JSON.Value, optSourceField?: string): Bundle | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Bundle';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Bundle();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.verifyResourceType(classJsonObj, 'Bundle');
    fhirParser.processResourceJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'identifier';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Identifier | undefined = Identifier.parse(classJsonObj[fieldName]!, sourceField);
      instance.setIdentifier(datatype);
    }

    fieldName = 'type';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setTypeElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'timestamp';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: InstantType | undefined = fhirParser.parseInstantType(dtJson, dtSiblingJson);
      instance.setTimestampElement(datatype);
    }

    fieldName = 'total';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UnsignedIntType | undefined = fhirParser.parseUnsignedIntType(dtJson, dtSiblingJson);
      instance.setTotalElement(datatype);
    }

    fieldName = 'link';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const componentJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      componentJsonArray.forEach((componentJson: JSON.Value, idx) => {
        const component: BundleLinkComponent | undefined = BundleLinkComponent.parse(componentJson, \`\${sourceField}[\${String(idx)}]\`);
        if (component !== undefined) {
          instance.addLink(component);
        }
      });
    }

    fieldName = 'entry';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const componentJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      componentJsonArray.forEach((componentJson: JSON.Value, idx) => {
        const component: BundleEntryComponent | undefined = BundleEntryComponent.parse(componentJson, \`\${sourceField}[\${String(idx)}]\`);
        if (component !== undefined) {
          instance.addEntry(component);
        }
      });
    }

    fieldName = 'signature';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Signature | undefined = Signature.parse(classJsonObj[fieldName]!, sourceField);
      instance.setSignature(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Bundle.identifier Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Persistent identifier for the bundle
   * - **Definition:** A persistent identifier for the bundle that won\\'t change as a bundle is copied from server to server.
   * - **Comment:** Persistent identity generally only matters for batches of type Document, Message, and Collection. It would not normally be populated for search and history results and servers ignore Bundle.identifier when processing batches and transactions. For Documents  the .identifier SHALL be populated such that the .identifier is globally unique.
   * - **FHIR Type:** \`Identifier\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private identifier?: Identifier | undefined;

  /**
   * FHIR CodeSystem: BundleType
   *
   * @see {@link BundleTypeEnum }
   */
  private readonly bundleTypeEnum: BundleTypeEnum;

  /**
   * Bundle.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** document | message | transaction | transaction-response | batch | batch-response | history | searchset | collection
   * - **Definition:** Indicates the purpose of this bundle - how it is intended to be used.
   * - **Comment:** It\\'s possible to use a bundle for other purposes (e.g. a document can be accepted as a transaction). This is primarily defined so that there can be specific rules for some of the bundle types.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link BundleTypeEnum }
   */
  private type_: EnumCodeType | null;

  /**
   * Bundle.timestamp Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** When the bundle was assembled
   * - **Definition:** The date/time that the bundle was assembled - i.e. when the resources were placed in the bundle.
   * - **Comment:** For many bundles, the timestamp is equal to .meta.lastUpdated, because they are not stored (e.g. search results). When a bundle is placed in a persistent store, .meta.lastUpdated will be usually be changed by the server. When the bundle is a message, a middleware agent altering the message (even if not stored) SHOULD update .meta.lastUpdated. .timestamp is used to track the original time of the Bundle, and SHOULD be populated.   Usage: * document : the date the document was created. Note: the composition may predate the document, or be associated with multiple documents. The date of the composition - the authoring time - may be earlier than the document assembly time * message : the date that the content of the message was assembled. This date is not changed by middleware engines unless they add additional data that changes the meaning of the time of the message * history : the date that the history was assembled. This time would be used as the _since time to ask for subsequent updates * searchset : the time that the search set was assembled. Note that different pages MAY have different timestamps but need not. Having different timestamps does not imply that subsequent pages will represent or include changes made since the initial query * transaction | transaction-response | batch | batch-response | collection : no particular assigned meaning The timestamp value should be greater than the lastUpdated and other timestamps in the resources in the bundle, and it should be equal or earlier than the .meta.lastUpdated on the Bundle itself.
   * - **FHIR Type:** \`instant\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private timestamp?: InstantType | undefined;

  /**
   * Bundle.total Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** If search, the total number of matches
   * - **Definition:** If a set of search matches, this is the total number of entries of type \\'match\\' across all pages in the search.  It does not include search.mode = \\'include\\' or \\'outcome\\' entries and it does not provide a count of the number of entries in the Bundle.
   * - **Comment:** Only used if the bundle is a search result set. The total does not include resources such as OperationOutcome and included resources, only the total number of matching resources.
   * - **FHIR Type:** \`unsignedInt\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private total?: UnsignedIntType | undefined;

  /**
   * Bundle.link Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Links related to this Bundle
   * - **Definition:** A series of links that provide context to this bundle.
   * - **Comment:** Both Bundle.link and Bundle.entry.link are defined to support providing additional context when Bundles are used (e.g. [HATEOAS](http://en.wikipedia.org/wiki/HATEOAS)).  Bundle.entry.link corresponds to links found in the HTTP header if the resource in the entry was [read](https://hl7.org/fhir/http.html#read) directly. This specification defines some specific uses of Bundle.link for [searching](https://hl7.org/fhir/search.html#conformance) and [paging](https://hl7.org/fhir/http.html#paging), but no specific uses for Bundle.entry.link, and no defined function in a transaction - the meaning is implementation specific.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private link?: BundleLinkComponent[] | undefined;

  /**
   * Bundle.entry Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Entry in the bundle - will have a resource or information
   * - **Definition:** An entry in a bundle resource - will either contain a resource or information about a resource (transactions and history only).
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private entry?: BundleEntryComponent[] | undefined;

  /**
   * Bundle.signature Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Digital Signature
   * - **Definition:** Digital Signature - base64 encoded. XML-DSig or a JWT.
   * - **Comment:** The signature could be created by the "author" of the bundle or by the originating device.   Requirements around inclusion of a signature, verification of signatures and treatment of signed/non-signed bundles is implementation-environment specific.
   * - **Requirements:** A Signature holds an electronic representation of a signature and its supporting context in a FHIR accessible form. The signature may either be a cryptographic type (XML DigSig or a JWS), which is able to provide non-repudiation proof, or it may be a graphical image that represents a signature or a signature process. This element allows capturing signatures on documents, messages, transactions or even search responses, to support content-authentication, non-repudiation or other business cases. This is primarily relevant where the bundle may travel through multiple hops or via other mechanisms where HTTPS non-repudiation is insufficient.
   * - **FHIR Type:** \`Signature\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private signature?: Signature | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`identifier\` property value as a Identifier object if defined; else an empty Identifier object
   */
  public getIdentifier(): Identifier {
    return this.identifier ?? new Identifier();
  }

  /**
   * Assigns the provided Identifier object value to the \`identifier\` property.
   *
   * @param value - the \`identifier\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setIdentifier(value: Identifier | undefined): this {
    if (isDefined<Identifier>(value)) {
      const optErrMsg = \`Invalid Bundle.identifier; Provided element is not an instance of Identifier.\`;
      assertFhirType<Identifier>(value, Identifier, optErrMsg);
      this.identifier = value;
    } else {
      this.identifier = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`identifier\` property exists and has a value; \`false\` otherwise
   */
  public hasIdentifier(): boolean {
    return isDefined<Identifier>(this.identifier) && !this.identifier.isEmpty();
  }

  /**
   * @returns the \`type_\` property value as a EnumCodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link BundleTypeEnum }
   */
  public getTypeEnumType(): EnumCodeType | null {
    return this.type_;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`type_\` property.
   *
   * @param enumType - the \`type_\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link BundleTypeEnum }
   */
  public setTypeEnumType(enumType: EnumCodeType): this {
    assertIsDefined<EnumCodeType>(enumType, \`Bundle.type is required\`);
    const errMsgPrefix = \`Invalid Bundle.type\`;
    assertEnumCodeType<BundleTypeEnum>(enumType, BundleTypeEnum, errMsgPrefix);
    this.type_ = enumType;
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasTypeEnumType(): boolean {
    return isDefined<EnumCodeType>(this.type_) && !this.type_.isEmpty() && this.type_.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`type_\` property value as a CodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link BundleTypeEnum }
   */
  public getTypeElement(): CodeType | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_ as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`type_\` property.
   *
   * @param element - the \`type_\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link BundleTypeEnum }
   */
  public setTypeElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, \`Bundle.type is required\`);
    const optErrMsg = \`Invalid Bundle.type; Provided value is not an instance of CodeType.\`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.type_ = new EnumCodeType(element, this.bundleTypeEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasTypeElement(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the \`type_\` property value as a fhirCode if defined; else null
   *
   * @see CodeSystem Enumeration: {@link BundleTypeEnum }
   */
  public getType(): fhirCode | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`type_\` property.
   *
   * @param value - the \`type_\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link BundleTypeEnum }
   */
  public setType(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, \`Bundle.type is required\`);
    const optErrMsg = \`Invalid Bundle.type (\${String(value)})\`;
    this.type_ = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.bundleTypeEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasType(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the \`timestamp\` property value as a InstantType object if defined; else an empty InstantType object
   */
  public getTimestampElement(): InstantType {
    return this.timestamp ?? new InstantType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`timestamp\` property.
   *
   * @param element - the \`timestamp\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTimestampElement(element: InstantType | undefined): this {
    if (isDefined<InstantType>(element)) {
      const optErrMsg = \`Invalid Bundle.timestamp; Provided element is not an instance of InstantType.\`;
      assertFhirType<InstantType>(element, InstantType, optErrMsg);
      this.timestamp = element;
    } else {
      this.timestamp = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`timestamp\` property exists and has a value; \`false\` otherwise
   */
  public hasTimestampElement(): boolean {
    return isDefined<InstantType>(this.timestamp) && !this.timestamp.isEmpty();
  }

  /**
   * @returns the \`timestamp\` property value as a fhirInstant if defined; else undefined
   */
  public getTimestamp(): fhirInstant | undefined {
    return this.timestamp?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`timestamp\` property.
   *
   * @param value - the \`timestamp\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTimestamp(value: fhirInstant | undefined): this {
    if (isDefined<fhirInstant>(value)) {
      const optErrMsg = \`Invalid Bundle.timestamp (\${String(value)})\`;
      this.timestamp = new InstantType(parseFhirPrimitiveData(value, fhirInstantSchema, optErrMsg));
    } else {
      this.timestamp = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`timestamp\` property exists and has a value; \`false\` otherwise
   */
  public hasTimestamp(): boolean {
    return this.hasTimestampElement();
  }

  /**
   * @returns the \`total\` property value as a UnsignedIntType object if defined; else an empty UnsignedIntType object
   */
  public getTotalElement(): UnsignedIntType {
    return this.total ?? new UnsignedIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`total\` property.
   *
   * @param element - the \`total\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTotalElement(element: UnsignedIntType | undefined): this {
    if (isDefined<UnsignedIntType>(element)) {
      const optErrMsg = \`Invalid Bundle.total; Provided element is not an instance of UnsignedIntType.\`;
      assertFhirType<UnsignedIntType>(element, UnsignedIntType, optErrMsg);
      this.total = element;
    } else {
      this.total = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`total\` property exists and has a value; \`false\` otherwise
   */
  public hasTotalElement(): boolean {
    return isDefined<UnsignedIntType>(this.total) && !this.total.isEmpty();
  }

  /**
   * @returns the \`total\` property value as a fhirUnsignedInt if defined; else undefined
   */
  public getTotal(): fhirUnsignedInt | undefined {
    return this.total?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`total\` property.
   *
   * @param value - the \`total\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTotal(value: fhirUnsignedInt | undefined): this {
    if (isDefined<fhirUnsignedInt>(value)) {
      const optErrMsg = \`Invalid Bundle.total (\${String(value)})\`;
      this.total = new UnsignedIntType(parseFhirPrimitiveData(value, fhirUnsignedIntSchema, optErrMsg));
    } else {
      this.total = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`total\` property exists and has a value; \`false\` otherwise
   */
  public hasTotal(): boolean {
    return this.hasTotalElement();
  }

  /**
   * @returns the \`link\` property value as a BundleLinkComponent array
   */
  public getLink(): BundleLinkComponent[] {
    return this.link ?? ([] as BundleLinkComponent[]);
  }

  /**
   * Assigns the provided BundleLinkComponent array value to the \`link\` property.
   *
   * @param value - the \`link\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setLink(value: BundleLinkComponent[] | undefined): this {
    if (isDefinedList<BundleLinkComponent>(value)) {
      const optErrMsg = \`Invalid Bundle.link; Provided value array has an element that is not an instance of BundleLinkComponent.\`;
      assertFhirTypeList<BundleLinkComponent>(value, BundleLinkComponent, optErrMsg);
      this.link = value;
    } else {
      this.link = undefined;
    }
    return this;
  }

  /**
   * Add the provided BundleLinkComponent value to the \`link\` array property.
   *
   * @param value - the \`link\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addLink(value: BundleLinkComponent | undefined): this {
    if (isDefined<BundleLinkComponent>(value)) {
      const optErrMsg = \`Invalid Bundle.link; Provided element is not an instance of BundleLinkComponent.\`;
      assertFhirType<BundleLinkComponent>(value, BundleLinkComponent, optErrMsg);
      this.initLink();
      this.link?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`link\` property exists and has a value; \`false\` otherwise
   */
  public hasLink(): boolean {
    return isDefinedList<BundleLinkComponent>(this.link) && this.link.some((item: BundleLinkComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`link\` property
   */
  private initLink(): void {
    if(!this.hasLink()) {
      this.link = [] as BundleLinkComponent[];
    }
  }

  /**
   * @returns the \`entry\` property value as a BundleEntryComponent array
   */
  public getEntry(): BundleEntryComponent[] {
    return this.entry ?? ([] as BundleEntryComponent[]);
  }

  /**
   * Assigns the provided BundleEntryComponent array value to the \`entry\` property.
   *
   * @param value - the \`entry\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setEntry(value: BundleEntryComponent[] | undefined): this {
    if (isDefinedList<BundleEntryComponent>(value)) {
      const optErrMsg = \`Invalid Bundle.entry; Provided value array has an element that is not an instance of BundleEntryComponent.\`;
      assertFhirTypeList<BundleEntryComponent>(value, BundleEntryComponent, optErrMsg);
      this.entry = value;
    } else {
      this.entry = undefined;
    }
    return this;
  }

  /**
   * Add the provided BundleEntryComponent value to the \`entry\` array property.
   *
   * @param value - the \`entry\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addEntry(value: BundleEntryComponent | undefined): this {
    if (isDefined<BundleEntryComponent>(value)) {
      const optErrMsg = \`Invalid Bundle.entry; Provided element is not an instance of BundleEntryComponent.\`;
      assertFhirType<BundleEntryComponent>(value, BundleEntryComponent, optErrMsg);
      this.initEntry();
      this.entry?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`entry\` property exists and has a value; \`false\` otherwise
   */
  public hasEntry(): boolean {
    return isDefinedList<BundleEntryComponent>(this.entry) && this.entry.some((item: BundleEntryComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`entry\` property
   */
  private initEntry(): void {
    if(!this.hasEntry()) {
      this.entry = [] as BundleEntryComponent[];
    }
  }

  /**
   * @returns the \`signature\` property value as a Signature object if defined; else an empty Signature object
   */
  public getSignature(): Signature {
    return this.signature ?? new Signature();
  }

  /**
   * Assigns the provided Signature object value to the \`signature\` property.
   *
   * @param value - the \`signature\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setSignature(value: Signature | undefined): this {
    if (isDefined<Signature>(value)) {
      const optErrMsg = \`Invalid Bundle.signature; Provided element is not an instance of Signature.\`;
      assertFhirType<Signature>(value, Signature, optErrMsg);
      this.signature = value;
    } else {
      this.signature = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`signature\` property exists and has a value; \`false\` otherwise
   */
  public hasSignature(): boolean {
    return isDefined<Signature>(this.signature) && !this.signature.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Bundle';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.identifier,
      this.type_,
      this.timestamp,
      this.total,
      this.link,
      this.entry,
      this.signature,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Bundle {
    const dest = new Bundle();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Bundle): void {
    super.copyValues(dest);
    dest.identifier = this.identifier?.copy();
    dest.type_ = this.type_ ? this.type_.copy() : null;
    dest.timestamp = this.timestamp?.copy();
    dest.total = this.total?.copy();
    const linkList = copyListValues<BundleLinkComponent>(this.link);
    dest.link = linkList.length === 0 ? undefined : linkList;
    const entryList = copyListValues<BundleEntryComponent>(this.entry);
    dest.entry = entryList.length === 0 ? undefined : entryList;
    dest.signature = this.signature?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasIdentifier()) {
      setFhirComplexJson(this.getIdentifier(), 'identifier', jsonObj);
    }

    if (this.hasTypeElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getTypeElement()!, 'type', jsonObj);
    } else {
      missingReqdProperties.push(\`Bundle.type\`);
    }

    if (this.hasTimestampElement()) {
      setFhirPrimitiveJson<fhirInstant>(this.getTimestampElement(), 'timestamp', jsonObj);
    }

    if (this.hasTotalElement()) {
      setFhirPrimitiveJson<fhirUnsignedInt>(this.getTotalElement(), 'total', jsonObj);
    }

    if (this.hasLink()) {
      setFhirBackboneElementListJson(this.getLink(), 'link', jsonObj);
    }

    if (this.hasEntry()) {
      setFhirBackboneElementListJson(this.getEntry(), 'entry', jsonObj);
    }

    if (this.hasSignature()) {
      setFhirComplexJson(this.getSignature(), 'signature', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

/**
 * BundleLinkComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Links related to this Bundle
 * - **Definition:** A series of links that provide context to this bundle.
 * - **Comment:** Both Bundle.link and Bundle.entry.link are defined to support providing additional context when Bundles are used (e.g. [HATEOAS](http://en.wikipedia.org/wiki/HATEOAS)).  Bundle.entry.link corresponds to links found in the HTTP header if the resource in the entry was [read](https://hl7.org/fhir/http.html#read) directly. This specification defines some specific uses of Bundle.link for [searching](https://hl7.org/fhir/search.html#conformance) and [paging](https://hl7.org/fhir/http.html#paging), but no specific uses for Bundle.entry.link, and no defined function in a transaction - the meaning is implementation specific.
 *
 * @category Data Models: Resource
 * @see [FHIR Bundle](http://hl7.org/fhir/StructureDefinition/Bundle)
 */
export class BundleLinkComponent extends BackboneElement implements IBackboneElement {
  constructor(relation: StringType | fhirString | null = null, url: UriType | fhirUri | null = null) {
    super();

    this.relation = null;
    if (isDefined<StringType | fhirString>(relation)) {
      if (relation instanceof PrimitiveType) {
        this.setRelationElement(relation);
      } else {
        this.setRelation(relation);
      }
    }

    this.url = null;
    if (isDefined<UriType | fhirUri>(url)) {
      if (url instanceof PrimitiveType) {
        this.setUrlElement(url);
      } else {
        this.setUrl(url);
      }
    }
  }

  /**
   * Parse the provided \`BundleLinkComponent\` JSON to instantiate the BundleLinkComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`BundleLinkComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to BundleLinkComponent
   * @returns BundleLinkComponent data model or undefined for \`BundleLinkComponent\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): BundleLinkComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'BundleLinkComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new BundleLinkComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'relation';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setRelationElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'url';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = fhirParser.parseUriType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setUrlElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Bundle.link.relation Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** See http://www.iana.org/assignments/link-relations/link-relations.xhtml#link-relations-1
   * - **Definition:** A name which details the functional use for this link - see [http://www.iana.org/assignments/link-relations/link-relations.xhtml#link-relations-1](http://www.iana.org/assignments/link-relations/link-relations.xhtml#link-relations-1).
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private relation: StringType | null;

  /**
   * Bundle.link.url Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Reference details for the link
   * - **Definition:** The reference details for the link.
   * - **FHIR Type:** \`uri\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private url: UriType | null;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`relation\` property value as a StringType object if defined; else null
   */
  public getRelationElement(): StringType | null {
    return this.relation;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`relation\` property.
   *
   * @param element - the \`relation\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setRelationElement(element: StringType): this {
    assertIsDefined<StringType>(element, \`Bundle.link.relation is required\`);
    const optErrMsg = \`Invalid Bundle.link.relation; Provided value is not an instance of StringType.\`;
    assertFhirType<StringType>(element, StringType, optErrMsg);
    this.relation = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`relation\` property exists and has a value; \`false\` otherwise
   */
  public hasRelationElement(): boolean {
    return isDefined<StringType>(this.relation) && !this.relation.isEmpty();
  }

  /**
   * @returns the \`relation\` property value as a fhirString if defined; else null
   */
  public getRelation(): fhirString | null {
    if (this.relation?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.relation.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`relation\` property.
   *
   * @param value - the \`relation\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setRelation(value: fhirString): this {
    assertIsDefined<fhirString>(value, \`Bundle.link.relation is required\`);
    const optErrMsg = \`Invalid Bundle.link.relation (\${String(value)})\`;
    this.relation = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`relation\` property exists and has a value; \`false\` otherwise
   */
  public hasRelation(): boolean {
    return this.hasRelationElement();
  }

  /**
   * @returns the \`url\` property value as a UriType object if defined; else null
   */
  public getUrlElement(): UriType | null {
    return this.url;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`url\` property.
   *
   * @param element - the \`url\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUrlElement(element: UriType): this {
    assertIsDefined<UriType>(element, \`Bundle.link.url is required\`);
    const optErrMsg = \`Invalid Bundle.link.url; Provided value is not an instance of UriType.\`;
    assertFhirType<UriType>(element, UriType, optErrMsg);
    this.url = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`url\` property exists and has a value; \`false\` otherwise
   */
  public hasUrlElement(): boolean {
    return isDefined<UriType>(this.url) && !this.url.isEmpty();
  }

  /**
   * @returns the \`url\` property value as a fhirUri if defined; else null
   */
  public getUrl(): fhirUri | null {
    if (this.url?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.url.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`url\` property.
   *
   * @param value - the \`url\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUrl(value: fhirUri): this {
    assertIsDefined<fhirUri>(value, \`Bundle.link.url is required\`);
    const optErrMsg = \`Invalid Bundle.link.url (\${String(value)})\`;
    this.url = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`url\` property exists and has a value; \`false\` otherwise
   */
  public hasUrl(): boolean {
    return this.hasUrlElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Bundle.link';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.relation,
      this.url,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): BundleLinkComponent {
    const dest = new BundleLinkComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: BundleLinkComponent): void {
    super.copyValues(dest);
    dest.relation = this.relation ? this.relation.copy() : null;
    dest.url = this.url ? this.url.copy() : null;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasRelationElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirString>(this.getRelationElement()!, 'relation', jsonObj);
    } else {
      missingReqdProperties.push(\`Bundle.link.relation\`);
    }

    if (this.hasUrlElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirUri>(this.getUrlElement()!, 'url', jsonObj);
    } else {
      missingReqdProperties.push(\`Bundle.link.url\`);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
/**
 * BundleEntryComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Entry in the bundle - will have a resource or information
 * - **Definition:** An entry in a bundle resource - will either contain a resource or information about a resource (transactions and history only).
 *
 * @category Data Models: Resource
 * @see [FHIR Bundle](http://hl7.org/fhir/StructureDefinition/Bundle)
 */
export class BundleEntryComponent extends BackboneElement implements IBackboneElement {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`BundleEntryComponent\` JSON to instantiate the BundleEntryComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`BundleEntryComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to BundleEntryComponent
   * @returns BundleEntryComponent data model or undefined for \`BundleEntryComponent\`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): BundleEntryComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'BundleEntryComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new BundleEntryComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    

    fieldName = 'link';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const componentJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      componentJsonArray.forEach((componentJson: JSON.Value, idx) => {
        const component: BundleLinkComponent | undefined = BundleLinkComponent.parse(componentJson, \`\${sourceField}[\${String(idx)}]\`);
        if (component !== undefined) {
          instance.addLink(component);
        }
      });
    }

    fieldName = 'fullUrl';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = fhirParser.parseUriType(dtJson, dtSiblingJson);
      instance.setFullUrlElement(datatype);
    }

    fieldName = 'resource';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      const resource: IResource | undefined = fhirParser.parseInlineResource(classJsonObj[fieldName], sourceField);
      instance.setResource(resource);
    }

    fieldName = 'search';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const component: BundleEntrySearchComponent | undefined = BundleEntrySearchComponent.parse(classJsonObj[fieldName]!, sourceField);
      instance.setSearch(component);
    }

    fieldName = 'request';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const component: BundleEntryRequestComponent | undefined = BundleEntryRequestComponent.parse(classJsonObj[fieldName]!, sourceField);
      instance.setRequest(component);
    }

    fieldName = 'response';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const component: BundleEntryResponseComponent | undefined = BundleEntryResponseComponent.parse(classJsonObj[fieldName]!, sourceField);
      instance.setResponse(component);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Bundle.entry.link Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Links related to this entry
   * - **Definition:** A series of links that provide context to this entry.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private link?: BundleLinkComponent[] | undefined;

  /**
   * Bundle.entry.fullUrl Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** URI for resource (Absolute URL server address or URI for UUID/OID)
   * - **Definition:** The Absolute URL for the resource.  The fullUrl SHALL NOT disagree with the id in the resource - i.e. if the fullUrl is not a urn:uuid, the URL shall be version-independent URL consistent with the Resource.id. The fullUrl is a version independent reference to the resource. The fullUrl element SHALL have a value except that:  * fullUrl can be empty on a POST (although it does not need to when specifying a temporary id for reference in the bundle) * Results from operations might involve resources that are not identified.
   * - **Comment:** fullUrl might not be [unique in the context of a resource](https://hl7.org/fhir/bundle.html#bundle-unique). Note that since [FHIR resources do not need to be served through the FHIR API](https://hl7.org/fhir/references.html), the fullURL might be a URN or an absolute URL that does not end with the logical id of the resource (Resource.id). However, but if the fullUrl does look like a RESTful server URL (e.g. meets the [regex](https://hl7.org/fhir/references.html#regex), then the \\'id\\' portion of the fullUrl SHALL end with the Resource.id. Note that the fullUrl is not the same as the canonical URL - it\\'s an absolute url for an endpoint serving the resource (these will happen to have the same value on the canonical server for the resource with the canonical URL).
   * - **FHIR Type:** \`uri\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private fullUrl?: UriType | undefined;

  /**
   * Bundle.entry.resource Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A resource in the bundle
   * - **Definition:** The Resource for the entry. The purpose/meaning of the resource is determined by the Bundle.type.
   * - **FHIR Type:** \`Resource\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private resource?: IResource | undefined;

  /**
   * Bundle.entry.search Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Search related information
   * - **Definition:** Information about the search process that lead to the creation of this entry.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private search?: BundleEntrySearchComponent | undefined;

  /**
   * Bundle.entry.request Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Additional execution information (transaction/batch/history)
   * - **Definition:** Additional information about how this entry should be processed as part of a transaction or batch.  For history, it shows how the entry was processed to create the version contained in the entry.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private request?: BundleEntryRequestComponent | undefined;

  /**
   * Bundle.entry.response Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Results of execution (transaction/batch/history)
   * - **Definition:** Indicates the results of processing the corresponding \\'request\\' entry in the batch or transaction being responded to or what the results of an operation where when returning history.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private response?: BundleEntryResponseComponent | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`link\` property value as a BundleLinkComponent array
   */
  public getLink(): BundleLinkComponent[] {
    return this.link ?? ([] as BundleLinkComponent[]);
  }

  /**
   * Assigns the provided BundleLinkComponent array value to the \`link\` property.
   *
   * @param value - the \`link\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setLink(value: BundleLinkComponent[] | undefined): this {
    if (isDefinedList<BundleLinkComponent>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.link; Provided value array has an element that is not an instance of BundleLinkComponent.\`;
      assertFhirTypeList<BundleLinkComponent>(value, BundleLinkComponent, optErrMsg);
      this.link = value;
    } else {
      this.link = undefined;
    }
    return this;
  }

  /**
   * Add the provided BundleLinkComponent value to the \`link\` array property.
   *
   * @param value - the \`link\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addLink(value: BundleLinkComponent | undefined): this {
    if (isDefined<BundleLinkComponent>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.link; Provided element is not an instance of BundleLinkComponent.\`;
      assertFhirType<BundleLinkComponent>(value, BundleLinkComponent, optErrMsg);
      this.initLink();
      this.link?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`link\` property exists and has a value; \`false\` otherwise
   */
  public hasLink(): boolean {
    return isDefinedList<BundleLinkComponent>(this.link) && this.link.some((item: BundleLinkComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`link\` property
   */
  private initLink(): void {
    if(!this.hasLink()) {
      this.link = [] as BundleLinkComponent[];
    }
  }

  /**
   * @returns the \`fullUrl\` property value as a UriType object if defined; else an empty UriType object
   */
  public getFullUrlElement(): UriType {
    return this.fullUrl ?? new UriType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`fullUrl\` property.
   *
   * @param element - the \`fullUrl\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setFullUrlElement(element: UriType | undefined): this {
    if (isDefined<UriType>(element)) {
      const optErrMsg = \`Invalid Bundle.entry.fullUrl; Provided element is not an instance of UriType.\`;
      assertFhirType<UriType>(element, UriType, optErrMsg);
      this.fullUrl = element;
    } else {
      this.fullUrl = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`fullUrl\` property exists and has a value; \`false\` otherwise
   */
  public hasFullUrlElement(): boolean {
    return isDefined<UriType>(this.fullUrl) && !this.fullUrl.isEmpty();
  }

  /**
   * @returns the \`fullUrl\` property value as a fhirUri if defined; else undefined
   */
  public getFullUrl(): fhirUri | undefined {
    return this.fullUrl?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`fullUrl\` property.
   *
   * @param value - the \`fullUrl\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setFullUrl(value: fhirUri | undefined): this {
    if (isDefined<fhirUri>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.fullUrl (\${String(value)})\`;
      this.fullUrl = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    } else {
      this.fullUrl = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`fullUrl\` property exists and has a value; \`false\` otherwise
   */
  public hasFullUrl(): boolean {
    return this.hasFullUrlElement();
  }

  /**
   * @returns the \`resource\` property value as a Resource object if defined; else undefined
   */
  public getResource(): IResource | undefined {
    return this.resource;
  }

  /**
   * Assigns the provided Resource object value to the \`resource\` property.
   *
   * @param value - the \`resource\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid resource type
   */
  public setResource(value: IResource | undefined): this {
    if (isDefined<IResource>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.resource; Provided element is not an instance of Resource.\`;
      assertFhirResourceType(value, optErrMsg);
      this.resource = value;
    } else {
      this.resource = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`resource\` property exists and has a value; \`false\` otherwise
   */
  public hasResource(): boolean {
    return isDefined<IResource>(this.resource) && !this.resource.isEmpty();
  }

  /**
   * @returns the \`search\` property value as a BundleEntrySearchComponent object if defined; else an empty BundleEntrySearchComponent object
   */
  public getSearch(): BundleEntrySearchComponent {
    return this.search ?? new BundleEntrySearchComponent();
  }

  /**
   * Assigns the provided Search object value to the \`search\` property.
   *
   * @param value - the \`search\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setSearch(value: BundleEntrySearchComponent | undefined): this {
    if (isDefined<BundleEntrySearchComponent>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.search; Provided element is not an instance of BundleEntrySearchComponent.\`;
      assertFhirType<BundleEntrySearchComponent>(value, BundleEntrySearchComponent, optErrMsg);
      this.search = value;
    } else {
      this.search = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`search\` property exists and has a value; \`false\` otherwise
   */
  public hasSearch(): boolean {
    return isDefined<BundleEntrySearchComponent>(this.search) && !this.search.isEmpty();
  }

  /**
   * @returns the \`request\` property value as a BundleEntryRequestComponent object if defined; else an empty BundleEntryRequestComponent object
   */
  public getRequest(): BundleEntryRequestComponent {
    return this.request ?? new BundleEntryRequestComponent();
  }

  /**
   * Assigns the provided Request object value to the \`request\` property.
   *
   * @param value - the \`request\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setRequest(value: BundleEntryRequestComponent | undefined): this {
    if (isDefined<BundleEntryRequestComponent>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.request; Provided element is not an instance of BundleEntryRequestComponent.\`;
      assertFhirType<BundleEntryRequestComponent>(value, BundleEntryRequestComponent, optErrMsg);
      this.request = value;
    } else {
      this.request = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`request\` property exists and has a value; \`false\` otherwise
   */
  public hasRequest(): boolean {
    return isDefined<BundleEntryRequestComponent>(this.request) && !this.request.isEmpty();
  }

  /**
   * @returns the \`response\` property value as a BundleEntryResponseComponent object if defined; else an empty BundleEntryResponseComponent object
   */
  public getResponse(): BundleEntryResponseComponent {
    return this.response ?? new BundleEntryResponseComponent();
  }

  /**
   * Assigns the provided Response object value to the \`response\` property.
   *
   * @param value - the \`response\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setResponse(value: BundleEntryResponseComponent | undefined): this {
    if (isDefined<BundleEntryResponseComponent>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.response; Provided element is not an instance of BundleEntryResponseComponent.\`;
      assertFhirType<BundleEntryResponseComponent>(value, BundleEntryResponseComponent, optErrMsg);
      this.response = value;
    } else {
      this.response = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`response\` property exists and has a value; \`false\` otherwise
   */
  public hasResponse(): boolean {
    return isDefined<BundleEntryResponseComponent>(this.response) && !this.response.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Bundle.entry';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.link,
      this.fullUrl,
      this.resource,
      this.search,
      this.request,
      this.response,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): BundleEntryComponent {
    const dest = new BundleEntryComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: BundleEntryComponent): void {
    super.copyValues(dest);
    const linkList = copyListValues<BundleLinkComponent>(this.link);
    dest.link = linkList.length === 0 ? undefined : linkList;
    dest.fullUrl = this.fullUrl?.copy();
    dest.resource = this.resource?.copy() as IResource;
    dest.search = this.search?.copy();
    dest.request = this.request?.copy();
    dest.response = this.response?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasLink()) {
      setFhirBackboneElementListJson(this.getLink(), 'link', jsonObj);
    }

    if (this.hasFullUrlElement()) {
      setFhirPrimitiveJson<fhirUri>(this.getFullUrlElement(), 'fullUrl', jsonObj);
    }

    if (this.hasResource()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirResourceJson(this.getResource()!, 'resource', jsonObj);
    }

    if (this.hasSearch()) {
      setFhirBackboneElementJson(this.getSearch(), 'search', jsonObj);
    }

    if (this.hasRequest()) {
      setFhirBackboneElementJson(this.getRequest(), 'request', jsonObj);
    }

    if (this.hasResponse()) {
      setFhirBackboneElementJson(this.getResponse(), 'response', jsonObj);
    }

    return jsonObj;
  }
}
/**
 * BundleEntrySearchComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Search related information
 * - **Definition:** Information about the search process that lead to the creation of this entry.
 *
 * @category Data Models: Resource
 * @see [FHIR Bundle](http://hl7.org/fhir/StructureDefinition/Bundle)
 */
export class BundleEntrySearchComponent extends BackboneElement implements IBackboneElement {
  constructor() {
    super();

    this.searchEntryModeEnum = new SearchEntryModeEnum();
  }

  /**
   * Parse the provided \`BundleEntrySearchComponent\` JSON to instantiate the BundleEntrySearchComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`BundleEntrySearchComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to BundleEntrySearchComponent
   * @returns BundleEntrySearchComponent data model or undefined for \`BundleEntrySearchComponent\`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): BundleEntrySearchComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'BundleEntrySearchComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new BundleEntrySearchComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'mode';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setModeElement(datatype);
    }

    fieldName = 'score';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setScoreElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: SearchEntryMode
   *
   * @see {@link SearchEntryModeEnum }
   */
  private readonly searchEntryModeEnum: SearchEntryModeEnum;

  /**
   * Bundle.entry.search.mode Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** match | include | outcome - why this is in the result set
   * - **Definition:** Why this entry is in the result set - whether it\\'s included as a match or because of an _include requirement, or to convey information or warning information about the search process.
   * - **Comment:** There is only one mode. In some corner cases, a resource may be included because it is both a match and an include. In these circumstances, \\'match\\' takes precedence.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link SearchEntryModeEnum }
   */
  private mode?: EnumCodeType | undefined;

  /**
   * Bundle.entry.search.score Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Search ranking (between 0 and 1)
   * - **Definition:** When searching, the server\\'s search ranking score for the entry.
   * - **Comment:** Servers are not required to return a ranking score. 1 is most relevant, and 0 is least relevant. Often, search results are sorted by score, but the client may specify a different sort order. See [Patient Match](https://hl7.org/fhir/patient-operation-match.html) for the EMPI search which relates to this element.
   * - **FHIR Type:** \`decimal\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private score?: DecimalType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`mode\` property value as a EnumCodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link SearchEntryModeEnum }
   */
  public getModeEnumType(): EnumCodeType | undefined {
    return this.mode;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`mode\` property.
   *
   * @param enumType - the \`mode\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code values
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link SearchEntryModeEnum }
   */
  public setModeEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid Bundle.entry.search.mode';
      assertEnumCodeType<SearchEntryModeEnum>(enumType, SearchEntryModeEnum, errMsgPrefix);
      this.mode = enumType;
    } else {
      this.mode = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`mode\` property exists and has a value; \`false\` otherwise
   */
  public hasModeEnumType(): boolean {
    return isDefined<EnumCodeType>(this.mode) && !this.mode.isEmpty() && this.mode.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`mode\` property value as a CodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link SearchEntryModeEnum }
   */
  public getModeElement(): CodeType | undefined {
    if (this.mode === undefined) {
      return undefined;
    }
    return this.mode as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`mode\` property.
   *
   * @param element - the \`mode\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link SearchEntryModeEnum }
   */
  public setModeElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Bundle.entry.search.mode; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.mode = new EnumCodeType(element, this.searchEntryModeEnum);
    } else {
      this.mode = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`mode\` property exists and has a value; \`false\` otherwise
   */
  public hasModeElement(): boolean {
    return this.hasModeEnumType();
  }

  /**
   * @returns the \`mode\` property value as a fhirCode if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link SearchEntryModeEnum }
   */
  public getMode(): fhirCode | undefined {
    if (this.mode === undefined) {
      return undefined;
    }
    return this.mode.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`mode\` property.
   *
   * @param value - the \`mode\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link SearchEntryModeEnum }
   */
  public setMode(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.search.mode; Provided value is not an instance of fhirCode.\`;
      this.mode = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.searchEntryModeEnum);
    } else {
      this.mode = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`mode\` property exists and has a value; \`false\` otherwise
   */
  public hasMode(): boolean {
    return this.hasModeEnumType();
  }

  /**
   * @returns the \`score\` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getScoreElement(): DecimalType {
    return this.score ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`score\` property.
   *
   * @param element - the \`score\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setScoreElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = \`Invalid Bundle.entry.search.score; Provided element is not an instance of DecimalType.\`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.score = element;
    } else {
      this.score = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`score\` property exists and has a value; \`false\` otherwise
   */
  public hasScoreElement(): boolean {
    return isDefined<DecimalType>(this.score) && !this.score.isEmpty();
  }

  /**
   * @returns the \`score\` property value as a fhirDecimal if defined; else undefined
   */
  public getScore(): fhirDecimal | undefined {
    return this.score?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`score\` property.
   *
   * @param value - the \`score\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setScore(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.search.score (\${String(value)})\`;
      this.score = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.score = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`score\` property exists and has a value; \`false\` otherwise
   */
  public hasScore(): boolean {
    return this.hasScoreElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Bundle.entry.search';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.mode,
      this.score,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): BundleEntrySearchComponent {
    const dest = new BundleEntrySearchComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: BundleEntrySearchComponent): void {
    super.copyValues(dest);
    dest.mode = this.mode?.copy();
    dest.score = this.score?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasModeElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getModeElement()!, 'mode', jsonObj);
    }

    if (this.hasScoreElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getScoreElement(), 'score', jsonObj);
    }

    return jsonObj;
  }
}
/**
 * BundleEntryRequestComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Additional execution information (transaction/batch/history)
 * - **Definition:** Additional information about how this entry should be processed as part of a transaction or batch.  For history, it shows how the entry was processed to create the version contained in the entry.
 *
 * @category Data Models: Resource
 * @see [FHIR Bundle](http://hl7.org/fhir/StructureDefinition/Bundle)
 */
export class BundleEntryRequestComponent extends BackboneElement implements IBackboneElement {
  constructor(method: EnumCodeType | CodeType | fhirCode | null = null, url: UriType | fhirUri | null = null) {
    super();

    this.httpVerbEnum = new HttpVerbEnum();

    this.method = constructorCodeValueAsEnumCodeType<HttpVerbEnum>(
      method,
      HttpVerbEnum,
      this.httpVerbEnum,
      'Bundle.entry.request.method',
    );

    this.url = null;
    if (isDefined<UriType | fhirUri>(url)) {
      if (url instanceof PrimitiveType) {
        this.setUrlElement(url);
      } else {
        this.setUrl(url);
      }
    }
  }

  /**
   * Parse the provided \`BundleEntryRequestComponent\` JSON to instantiate the BundleEntryRequestComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`BundleEntryRequestComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to BundleEntryRequestComponent
   * @returns BundleEntryRequestComponent data model or undefined for \`BundleEntryRequestComponent\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): BundleEntryRequestComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'BundleEntryRequestComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new BundleEntryRequestComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'method';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setMethodElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'url';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = fhirParser.parseUriType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setUrlElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'ifNoneMatch';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setIfNoneMatchElement(datatype);
    }

    fieldName = 'ifModifiedSince';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: InstantType | undefined = fhirParser.parseInstantType(dtJson, dtSiblingJson);
      instance.setIfModifiedSinceElement(datatype);
    }

    fieldName = 'ifMatch';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setIfMatchElement(datatype);
    }

    fieldName = 'ifNoneExist';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setIfNoneExistElement(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: HttpVerb
   *
   * @see {@link HttpVerbEnum }
   */
  private readonly httpVerbEnum: HttpVerbEnum;

  /**
   * Bundle.entry.request.method Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** GET | HEAD | POST | PUT | DELETE | PATCH
   * - **Definition:** In a transaction or batch, this is the HTTP action to be executed for this entry. In a history bundle, this indicates the HTTP action that occurred.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link HttpVerbEnum }
   */
  private method: EnumCodeType | null;

  /**
   * Bundle.entry.request.url Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** URL for HTTP equivalent of this entry
   * - **Definition:** The URL for this entry, relative to the root (the address to which the request is posted).
   * - **Comment:** E.g. for a Patient Create, the method would be "POST" and the URL would be "Patient". For a Patient Update, the method would be PUT and the URL would be "Patient/[id]".
   * - **FHIR Type:** \`uri\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private url: UriType | null;

  /**
   * Bundle.entry.request.ifNoneMatch Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** For managing cache currency
   * - **Definition:** If the ETag values match, return a 304 Not Modified status. See the API documentation for ["Conditional Read"](https://hl7.org/fhir/http.html#cread).
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private ifNoneMatch?: StringType | undefined;

  /**
   * Bundle.entry.request.ifModifiedSince Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** For managing cache currency
   * - **Definition:** Only perform the operation if the last updated date matches. See the API documentation for ["Conditional Read"](https://hl7.org/fhir/http.html#cread).
   * - **FHIR Type:** \`instant\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private ifModifiedSince?: InstantType | undefined;

  /**
   * Bundle.entry.request.ifMatch Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** For managing update contention
   * - **Definition:** Only perform the operation if the Etag value matches. For more information, see the API section ["Managing Resource Contention"](https://hl7.org/fhir/http.html#concurrency).
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private ifMatch?: StringType | undefined;

  /**
   * Bundle.entry.request.ifNoneExist Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** For conditional creates
   * - **Definition:** Instruct the server not to perform the create if a specified resource already exists. For further information, see the API documentation for ["Conditional Create"](https://hl7.org/fhir/http.html#ccreate). This is just the query portion of the URL - what follows the "?" (not including the "?").
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private ifNoneExist?: StringType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`method\` property value as a EnumCodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link HttpVerbEnum }
   */
  public getMethodEnumType(): EnumCodeType | null {
    return this.method;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`method\` property.
   *
   * @param enumType - the \`method\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link HttpVerbEnum }
   */
  public setMethodEnumType(enumType: EnumCodeType): this {
    assertIsDefined<EnumCodeType>(enumType, \`Bundle.entry.request.method is required\`);
    const errMsgPrefix = \`Invalid Bundle.entry.request.method\`;
    assertEnumCodeType<HttpVerbEnum>(enumType, HttpVerbEnum, errMsgPrefix);
    this.method = enumType;
    return this;
  }

  /**
   * @returns \`true\` if the \`method\` property exists and has a value; \`false\` otherwise
   */
  public hasMethodEnumType(): boolean {
    return isDefined<EnumCodeType>(this.method) && !this.method.isEmpty() && this.method.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`method\` property value as a CodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link HttpVerbEnum }
   */
  public getMethodElement(): CodeType | null {
    if (this.method === null) {
      return null;
    }
    return this.method as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`method\` property.
   *
   * @param element - the \`method\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link HttpVerbEnum }
   */
  public setMethodElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, \`Bundle.entry.request.method is required\`);
    const optErrMsg = \`Invalid Bundle.entry.request.method; Provided value is not an instance of CodeType.\`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.method = new EnumCodeType(element, this.httpVerbEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`method\` property exists and has a value; \`false\` otherwise
   */
  public hasMethodElement(): boolean {
    return this.hasMethodEnumType();
  }

  /**
   * @returns the \`method\` property value as a fhirCode if defined; else null
   *
   * @see CodeSystem Enumeration: {@link HttpVerbEnum }
   */
  public getMethod(): fhirCode | null {
    if (this.method === null) {
      return null;
    }
    return this.method.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`method\` property.
   *
   * @param value - the \`method\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link HttpVerbEnum }
   */
  public setMethod(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, \`Bundle.entry.request.method is required\`);
    const optErrMsg = \`Invalid Bundle.entry.request.method (\${String(value)})\`;
    this.method = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.httpVerbEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`method\` property exists and has a value; \`false\` otherwise
   */
  public hasMethod(): boolean {
    return this.hasMethodEnumType();
  }

  /**
   * @returns the \`url\` property value as a UriType object if defined; else null
   */
  public getUrlElement(): UriType | null {
    return this.url;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`url\` property.
   *
   * @param element - the \`url\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUrlElement(element: UriType): this {
    assertIsDefined<UriType>(element, \`Bundle.entry.request.url is required\`);
    const optErrMsg = \`Invalid Bundle.entry.request.url; Provided value is not an instance of UriType.\`;
    assertFhirType<UriType>(element, UriType, optErrMsg);
    this.url = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`url\` property exists and has a value; \`false\` otherwise
   */
  public hasUrlElement(): boolean {
    return isDefined<UriType>(this.url) && !this.url.isEmpty();
  }

  /**
   * @returns the \`url\` property value as a fhirUri if defined; else null
   */
  public getUrl(): fhirUri | null {
    if (this.url?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.url.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`url\` property.
   *
   * @param value - the \`url\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUrl(value: fhirUri): this {
    assertIsDefined<fhirUri>(value, \`Bundle.entry.request.url is required\`);
    const optErrMsg = \`Invalid Bundle.entry.request.url (\${String(value)})\`;
    this.url = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`url\` property exists and has a value; \`false\` otherwise
   */
  public hasUrl(): boolean {
    return this.hasUrlElement();
  }

  /**
   * @returns the \`ifNoneMatch\` property value as a StringType object if defined; else an empty StringType object
   */
  public getIfNoneMatchElement(): StringType {
    return this.ifNoneMatch ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`ifNoneMatch\` property.
   *
   * @param element - the \`ifNoneMatch\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setIfNoneMatchElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Bundle.entry.request.ifNoneMatch; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.ifNoneMatch = element;
    } else {
      this.ifNoneMatch = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`ifNoneMatch\` property exists and has a value; \`false\` otherwise
   */
  public hasIfNoneMatchElement(): boolean {
    return isDefined<StringType>(this.ifNoneMatch) && !this.ifNoneMatch.isEmpty();
  }

  /**
   * @returns the \`ifNoneMatch\` property value as a fhirString if defined; else undefined
   */
  public getIfNoneMatch(): fhirString | undefined {
    return this.ifNoneMatch?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`ifNoneMatch\` property.
   *
   * @param value - the \`ifNoneMatch\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setIfNoneMatch(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.request.ifNoneMatch (\${String(value)})\`;
      this.ifNoneMatch = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.ifNoneMatch = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`ifNoneMatch\` property exists and has a value; \`false\` otherwise
   */
  public hasIfNoneMatch(): boolean {
    return this.hasIfNoneMatchElement();
  }

  /**
   * @returns the \`ifModifiedSince\` property value as a InstantType object if defined; else an empty InstantType object
   */
  public getIfModifiedSinceElement(): InstantType {
    return this.ifModifiedSince ?? new InstantType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`ifModifiedSince\` property.
   *
   * @param element - the \`ifModifiedSince\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setIfModifiedSinceElement(element: InstantType | undefined): this {
    if (isDefined<InstantType>(element)) {
      const optErrMsg = \`Invalid Bundle.entry.request.ifModifiedSince; Provided element is not an instance of InstantType.\`;
      assertFhirType<InstantType>(element, InstantType, optErrMsg);
      this.ifModifiedSince = element;
    } else {
      this.ifModifiedSince = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`ifModifiedSince\` property exists and has a value; \`false\` otherwise
   */
  public hasIfModifiedSinceElement(): boolean {
    return isDefined<InstantType>(this.ifModifiedSince) && !this.ifModifiedSince.isEmpty();
  }

  /**
   * @returns the \`ifModifiedSince\` property value as a fhirInstant if defined; else undefined
   */
  public getIfModifiedSince(): fhirInstant | undefined {
    return this.ifModifiedSince?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`ifModifiedSince\` property.
   *
   * @param value - the \`ifModifiedSince\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setIfModifiedSince(value: fhirInstant | undefined): this {
    if (isDefined<fhirInstant>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.request.ifModifiedSince (\${String(value)})\`;
      this.ifModifiedSince = new InstantType(parseFhirPrimitiveData(value, fhirInstantSchema, optErrMsg));
    } else {
      this.ifModifiedSince = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`ifModifiedSince\` property exists and has a value; \`false\` otherwise
   */
  public hasIfModifiedSince(): boolean {
    return this.hasIfModifiedSinceElement();
  }

  /**
   * @returns the \`ifMatch\` property value as a StringType object if defined; else an empty StringType object
   */
  public getIfMatchElement(): StringType {
    return this.ifMatch ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`ifMatch\` property.
   *
   * @param element - the \`ifMatch\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setIfMatchElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Bundle.entry.request.ifMatch; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.ifMatch = element;
    } else {
      this.ifMatch = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`ifMatch\` property exists and has a value; \`false\` otherwise
   */
  public hasIfMatchElement(): boolean {
    return isDefined<StringType>(this.ifMatch) && !this.ifMatch.isEmpty();
  }

  /**
   * @returns the \`ifMatch\` property value as a fhirString if defined; else undefined
   */
  public getIfMatch(): fhirString | undefined {
    return this.ifMatch?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`ifMatch\` property.
   *
   * @param value - the \`ifMatch\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setIfMatch(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.request.ifMatch (\${String(value)})\`;
      this.ifMatch = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.ifMatch = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`ifMatch\` property exists and has a value; \`false\` otherwise
   */
  public hasIfMatch(): boolean {
    return this.hasIfMatchElement();
  }

  /**
   * @returns the \`ifNoneExist\` property value as a StringType object if defined; else an empty StringType object
   */
  public getIfNoneExistElement(): StringType {
    return this.ifNoneExist ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`ifNoneExist\` property.
   *
   * @param element - the \`ifNoneExist\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setIfNoneExistElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Bundle.entry.request.ifNoneExist; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.ifNoneExist = element;
    } else {
      this.ifNoneExist = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`ifNoneExist\` property exists and has a value; \`false\` otherwise
   */
  public hasIfNoneExistElement(): boolean {
    return isDefined<StringType>(this.ifNoneExist) && !this.ifNoneExist.isEmpty();
  }

  /**
   * @returns the \`ifNoneExist\` property value as a fhirString if defined; else undefined
   */
  public getIfNoneExist(): fhirString | undefined {
    return this.ifNoneExist?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`ifNoneExist\` property.
   *
   * @param value - the \`ifNoneExist\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setIfNoneExist(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.request.ifNoneExist (\${String(value)})\`;
      this.ifNoneExist = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.ifNoneExist = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`ifNoneExist\` property exists and has a value; \`false\` otherwise
   */
  public hasIfNoneExist(): boolean {
    return this.hasIfNoneExistElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Bundle.entry.request';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.method,
      this.url,
      this.ifNoneMatch,
      this.ifModifiedSince,
      this.ifMatch,
      this.ifNoneExist,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): BundleEntryRequestComponent {
    const dest = new BundleEntryRequestComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: BundleEntryRequestComponent): void {
    super.copyValues(dest);
    dest.method = this.method ? this.method.copy() : null;
    dest.url = this.url ? this.url.copy() : null;
    dest.ifNoneMatch = this.ifNoneMatch?.copy();
    dest.ifModifiedSince = this.ifModifiedSince?.copy();
    dest.ifMatch = this.ifMatch?.copy();
    dest.ifNoneExist = this.ifNoneExist?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasMethodElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getMethodElement()!, 'method', jsonObj);
    } else {
      missingReqdProperties.push(\`Bundle.entry.request.method\`);
    }

    if (this.hasUrlElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirUri>(this.getUrlElement()!, 'url', jsonObj);
    } else {
      missingReqdProperties.push(\`Bundle.entry.request.url\`);
    }

    if (this.hasIfNoneMatchElement()) {
      setFhirPrimitiveJson<fhirString>(this.getIfNoneMatchElement(), 'ifNoneMatch', jsonObj);
    }

    if (this.hasIfModifiedSinceElement()) {
      setFhirPrimitiveJson<fhirInstant>(this.getIfModifiedSinceElement(), 'ifModifiedSince', jsonObj);
    }

    if (this.hasIfMatchElement()) {
      setFhirPrimitiveJson<fhirString>(this.getIfMatchElement(), 'ifMatch', jsonObj);
    }

    if (this.hasIfNoneExistElement()) {
      setFhirPrimitiveJson<fhirString>(this.getIfNoneExistElement(), 'ifNoneExist', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
/**
 * BundleEntryResponseComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Results of execution (transaction/batch/history)
 * - **Definition:** Indicates the results of processing the corresponding \\'request\\' entry in the batch or transaction being responded to or what the results of an operation where when returning history.
 *
 * @category Data Models: Resource
 * @see [FHIR Bundle](http://hl7.org/fhir/StructureDefinition/Bundle)
 */
export class BundleEntryResponseComponent extends BackboneElement implements IBackboneElement {
  constructor(status: StringType | fhirString | null = null) {
    super();

    this.status = null;
    if (isDefined<StringType | fhirString>(status)) {
      if (status instanceof PrimitiveType) {
        this.setStatusElement(status);
      } else {
        this.setStatus(status);
      }
    }
  }

  /**
   * Parse the provided \`BundleEntryResponseComponent\` JSON to instantiate the BundleEntryResponseComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`BundleEntryResponseComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to BundleEntryResponseComponent
   * @returns BundleEntryResponseComponent data model or undefined for \`BundleEntryResponseComponent\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): BundleEntryResponseComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'BundleEntryResponseComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new BundleEntryResponseComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'status';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setStatusElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'location';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = fhirParser.parseUriType(dtJson, dtSiblingJson);
      instance.setLocationElement(datatype);
    }

    fieldName = 'etag';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setEtagElement(datatype);
    }

    fieldName = 'lastModified';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: InstantType | undefined = fhirParser.parseInstantType(dtJson, dtSiblingJson);
      instance.setLastModifiedElement(datatype);
    }

    fieldName = 'outcome';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      const outcome: IResource | undefined = fhirParser.parseInlineResource(classJsonObj[fieldName], sourceField);
      instance.setOutcome(outcome);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Bundle.entry.response.status Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Status response code (text optional)
   * - **Definition:** The status code returned by processing this entry. The status SHALL start with a 3 digit HTTP code (e.g. 404) and may contain the standard HTTP description associated with the status code.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private status: StringType | null;

  /**
   * Bundle.entry.response.location Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The location (if the operation returns a location)
   * - **Definition:** The location header created by processing this operation, populated if the operation returns a location.
   * - **FHIR Type:** \`uri\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private location?: UriType | undefined;

  /**
   * Bundle.entry.response.etag Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The Etag for the resource (if relevant)
   * - **Definition:** The Etag for the resource, if the operation for the entry produced a versioned resource (see [Resource Metadata and Versioning](https://hl7.org/fhir/http.html#versioning) and [Managing Resource Contention](https://hl7.org/fhir/http.html#concurrency)).
   * - **Comment:** Etags match the Resource.meta.versionId. The ETag has to match the version id in the header if a resource is included.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private etag?: StringType | undefined;

  /**
   * Bundle.entry.response.lastModified Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Server\\'s date time modified
   * - **Definition:** The date/time that the resource was modified on the server.
   * - **Comment:** This has to match the same time in the meta header (meta.lastUpdated) if a resource is included.
   * - **FHIR Type:** \`instant\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private lastModified?: InstantType | undefined;

  /**
   * Bundle.entry.response.outcome Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** OperationOutcome with hints and warnings (for batch/transaction)
   * - **Definition:** An OperationOutcome containing hints and warnings produced as part of processing this entry in a batch or transaction.
   * - **Comment:** For a POST/PUT operation, this is the equivalent outcome that would be returned for prefer = operationoutcome - except that the resource is always returned whether or not the outcome is returned. This outcome is not used for error responses in batch/transaction, only for hints and warnings. In a batch operation, the error will be in Bundle.entry.response, and for transaction, there will be a single OperationOutcome instead of a bundle in the case of an error.
   * - **FHIR Type:** \`Resource\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private outcome?: IResource | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`status\` property value as a StringType object if defined; else null
   */
  public getStatusElement(): StringType | null {
    return this.status;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`status\` property.
   *
   * @param element - the \`status\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setStatusElement(element: StringType): this {
    assertIsDefined<StringType>(element, \`Bundle.entry.response.status is required\`);
    const optErrMsg = \`Invalid Bundle.entry.response.status; Provided value is not an instance of StringType.\`;
    assertFhirType<StringType>(element, StringType, optErrMsg);
    this.status = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`status\` property exists and has a value; \`false\` otherwise
   */
  public hasStatusElement(): boolean {
    return isDefined<StringType>(this.status) && !this.status.isEmpty();
  }

  /**
   * @returns the \`status\` property value as a fhirString if defined; else null
   */
  public getStatus(): fhirString | null {
    if (this.status?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.status.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`status\` property.
   *
   * @param value - the \`status\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setStatus(value: fhirString): this {
    assertIsDefined<fhirString>(value, \`Bundle.entry.response.status is required\`);
    const optErrMsg = \`Invalid Bundle.entry.response.status (\${String(value)})\`;
    this.status = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`status\` property exists and has a value; \`false\` otherwise
   */
  public hasStatus(): boolean {
    return this.hasStatusElement();
  }

  /**
   * @returns the \`location\` property value as a UriType object if defined; else an empty UriType object
   */
  public getLocationElement(): UriType {
    return this.location ?? new UriType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`location\` property.
   *
   * @param element - the \`location\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLocationElement(element: UriType | undefined): this {
    if (isDefined<UriType>(element)) {
      const optErrMsg = \`Invalid Bundle.entry.response.location; Provided element is not an instance of UriType.\`;
      assertFhirType<UriType>(element, UriType, optErrMsg);
      this.location = element;
    } else {
      this.location = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`location\` property exists and has a value; \`false\` otherwise
   */
  public hasLocationElement(): boolean {
    return isDefined<UriType>(this.location) && !this.location.isEmpty();
  }

  /**
   * @returns the \`location\` property value as a fhirUri if defined; else undefined
   */
  public getLocation(): fhirUri | undefined {
    return this.location?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`location\` property.
   *
   * @param value - the \`location\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLocation(value: fhirUri | undefined): this {
    if (isDefined<fhirUri>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.response.location (\${String(value)})\`;
      this.location = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    } else {
      this.location = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`location\` property exists and has a value; \`false\` otherwise
   */
  public hasLocation(): boolean {
    return this.hasLocationElement();
  }

  /**
   * @returns the \`etag\` property value as a StringType object if defined; else an empty StringType object
   */
  public getEtagElement(): StringType {
    return this.etag ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`etag\` property.
   *
   * @param element - the \`etag\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setEtagElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Bundle.entry.response.etag; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.etag = element;
    } else {
      this.etag = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`etag\` property exists and has a value; \`false\` otherwise
   */
  public hasEtagElement(): boolean {
    return isDefined<StringType>(this.etag) && !this.etag.isEmpty();
  }

  /**
   * @returns the \`etag\` property value as a fhirString if defined; else undefined
   */
  public getEtag(): fhirString | undefined {
    return this.etag?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`etag\` property.
   *
   * @param value - the \`etag\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setEtag(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.response.etag (\${String(value)})\`;
      this.etag = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.etag = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`etag\` property exists and has a value; \`false\` otherwise
   */
  public hasEtag(): boolean {
    return this.hasEtagElement();
  }

  /**
   * @returns the \`lastModified\` property value as a InstantType object if defined; else an empty InstantType object
   */
  public getLastModifiedElement(): InstantType {
    return this.lastModified ?? new InstantType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`lastModified\` property.
   *
   * @param element - the \`lastModified\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLastModifiedElement(element: InstantType | undefined): this {
    if (isDefined<InstantType>(element)) {
      const optErrMsg = \`Invalid Bundle.entry.response.lastModified; Provided element is not an instance of InstantType.\`;
      assertFhirType<InstantType>(element, InstantType, optErrMsg);
      this.lastModified = element;
    } else {
      this.lastModified = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`lastModified\` property exists and has a value; \`false\` otherwise
   */
  public hasLastModifiedElement(): boolean {
    return isDefined<InstantType>(this.lastModified) && !this.lastModified.isEmpty();
  }

  /**
   * @returns the \`lastModified\` property value as a fhirInstant if defined; else undefined
   */
  public getLastModified(): fhirInstant | undefined {
    return this.lastModified?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`lastModified\` property.
   *
   * @param value - the \`lastModified\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLastModified(value: fhirInstant | undefined): this {
    if (isDefined<fhirInstant>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.response.lastModified (\${String(value)})\`;
      this.lastModified = new InstantType(parseFhirPrimitiveData(value, fhirInstantSchema, optErrMsg));
    } else {
      this.lastModified = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`lastModified\` property exists and has a value; \`false\` otherwise
   */
  public hasLastModified(): boolean {
    return this.hasLastModifiedElement();
  }

  /**
   * @returns the \`outcome\` property value as a Resource object if defined; else undefined
   */
  public getOutcome(): IResource | undefined {
    return this.outcome;
  }

  /**
   * Assigns the provided Resource object value to the \`outcome\` property.
   *
   * @param value - the \`outcome\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid resource type
   */
  public setOutcome(value: IResource | undefined): this {
    if (isDefined<IResource>(value)) {
      const optErrMsg = \`Invalid Bundle.entry.response.outcome; Provided element is not an instance of Resource.\`;
      assertFhirResourceType(value, optErrMsg);
      this.outcome = value;
    } else {
      this.outcome = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`outcome\` property exists and has a value; \`false\` otherwise
   */
  public hasOutcome(): boolean {
    return isDefined<IResource>(this.outcome) && !this.outcome.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Bundle.entry.response';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.status,
      this.location,
      this.etag,
      this.lastModified,
      this.outcome,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): BundleEntryResponseComponent {
    const dest = new BundleEntryResponseComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: BundleEntryResponseComponent): void {
    super.copyValues(dest);
    dest.status = this.status ? this.status.copy() : null;
    dest.location = this.location?.copy();
    dest.etag = this.etag?.copy();
    dest.lastModified = this.lastModified?.copy();
    dest.outcome = this.outcome?.copy() as IResource;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasStatusElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirString>(this.getStatusElement()!, 'status', jsonObj);
    } else {
      missingReqdProperties.push(\`Bundle.entry.response.status\`);
    }

    if (this.hasLocationElement()) {
      setFhirPrimitiveJson<fhirUri>(this.getLocationElement(), 'location', jsonObj);
    }

    if (this.hasEtagElement()) {
      setFhirPrimitiveJson<fhirString>(this.getEtagElement(), 'etag', jsonObj);
    }

    if (this.hasLastModifiedElement()) {
      setFhirPrimitiveJson<fhirInstant>(this.getLastModifiedElement(), 'lastModified', jsonObj);
    }

    if (this.hasOutcome()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirResourceJson(this.getOutcome()!, 'outcome', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
",
  "fileExtension": "ts",
  "filename": "Bundle",
}
`;

exports[`generator-datamodel-ftest Functional Test Suite generator-app verify generated content should consistently create GeneratedContent[] 31`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/src",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/test/ftest-cache",
    "pkgName": "ftest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "Resource",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * Device Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/Device
 * StructureDefinition.name: Device
 * StructureDefinition.description: A type of a manufactured item that is used in the provision of healthcare without being substantially changed through that activity. The device may be a medical or non-medical device.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  BackboneElement,
  Base64BinaryType,
  CodeType,
  DateTimeType,
  DomainResource,
  EnumCodeType,
  FhirError,
  FhirParser,
  IBackboneElement,
  IDomainResource,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  PrimitiveType,
  REQUIRED_PROPERTIES_DO_NOT_EXIST,
  REQUIRED_PROPERTIES_REQD_IN_JSON,
  ReferenceTargets,
  StringType,
  UriType,
  assertEnumCodeType,
  assertFhirType,
  assertFhirTypeList,
  assertIsDefined,
  constructorCodeValueAsEnumCodeType,
  copyListValues,
  fhirBase64Binary,
  fhirBase64BinarySchema,
  fhirCode,
  fhirCodeSchema,
  fhirDateTime,
  fhirDateTimeSchema,
  fhirString,
  fhirStringSchema,
  fhirUri,
  fhirUriSchema,
  getPrimitiveTypeJson,
  isDefined,
  isDefinedList,
  isElementEmpty,
  isEmpty,
  parseFhirPrimitiveData,
  setFhirBackboneElementListJson,
  setFhirComplexJson,
  setFhirComplexListJson,
  setFhirPrimitiveJson,
} from '@paq-ts-fhir/fhir-core';
import { Annotation, CodeableConcept, ContactPoint, Identifier, PARSABLE_DATATYPE_MAP, Quantity, Reference } from '../complex-types/complex-datatypes';
import { DeviceNametypeEnum } from '../code-systems/DeviceNametypeEnum';
import { DeviceStatusEnum } from '../code-systems/DeviceStatusEnum';
import { PARSABLE_RESOURCE_MAP } from './parsable-resource-map';
import { UdiEntryTypeEnum } from '../code-systems/UdiEntryTypeEnum';

/**
 * Device Class
 *
 * @remarks
 * A type of a manufactured item that is used in the provision of healthcare without being substantially changed through that activity. The device may be a medical or non-medical device.
 *
 * Allows institutions to track their devices.
 *
 * **FHIR Specification**
 * - **Short:** Item used in healthcare
 * - **Definition:** A type of a manufactured item that is used in the provision of healthcare without being substantially changed through that activity. The device may be a medical or non-medical device.
 * - **FHIR Version:** 4.0.1
 *
 * @category Data Models: Resource
 * @see [FHIR Device](http://hl7.org/fhir/StructureDefinition/Device)
 */
export class Device extends DomainResource implements IDomainResource {
  constructor() {
    super();

    this.deviceStatusEnum = new DeviceStatusEnum();
  }

  /**
   * Parse the provided \`Device\` JSON to instantiate the Device data model.
   *
   * @param sourceJson - JSON representing FHIR \`Device\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Device
   * @returns Device data model or undefined for \`Device\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static override parse(sourceJson: JSON.Value, optSourceField?: string): Device | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Device';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Device();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.verifyResourceType(classJsonObj, 'Device');
    fhirParser.processDomainResourceJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'identifier';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Identifier | undefined = Identifier.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addIdentifier(datatype);
        }
      });
    }

    fieldName = 'definition';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = Reference.parse(classJsonObj[fieldName]!, sourceField);
      instance.setDefinition(datatype);
    }

    fieldName = 'udiCarrier';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const componentJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      componentJsonArray.forEach((componentJson: JSON.Value, idx) => {
        const component: DeviceUdiCarrierComponent | undefined = DeviceUdiCarrierComponent.parse(componentJson, \`\${sourceField}[\${String(idx)}]\`);
        if (component !== undefined) {
          instance.addUdiCarrier(component);
        }
      });
    }

    fieldName = 'status';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setStatusElement(datatype);
    }

    fieldName = 'statusReason';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: CodeableConcept | undefined = CodeableConcept.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addStatusReason(datatype);
        }
      });
    }

    fieldName = 'distinctIdentifier';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setDistinctIdentifierElement(datatype);
    }

    fieldName = 'manufacturer';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setManufacturerElement(datatype);
    }

    fieldName = 'manufactureDate';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DateTimeType | undefined = fhirParser.parseDateTimeType(dtJson, dtSiblingJson);
      instance.setManufactureDateElement(datatype);
    }

    fieldName = 'expirationDate';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DateTimeType | undefined = fhirParser.parseDateTimeType(dtJson, dtSiblingJson);
      instance.setExpirationDateElement(datatype);
    }

    fieldName = 'lotNumber';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setLotNumberElement(datatype);
    }

    fieldName = 'serialNumber';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setSerialNumberElement(datatype);
    }

    fieldName = 'deviceName';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const componentJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      componentJsonArray.forEach((componentJson: JSON.Value, idx) => {
        const component: DeviceDeviceNameComponent | undefined = DeviceDeviceNameComponent.parse(componentJson, \`\${sourceField}[\${String(idx)}]\`);
        if (component !== undefined) {
          instance.addDeviceName(component);
        }
      });
    }

    fieldName = 'modelNumber';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setModelNumberElement(datatype);
    }

    fieldName = 'partNumber';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setPartNumberElement(datatype);
    }

    fieldName = 'type';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = CodeableConcept.parse(classJsonObj[fieldName]!, sourceField);
      instance.setType(datatype);
    }

    fieldName = 'specialization';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const componentJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      componentJsonArray.forEach((componentJson: JSON.Value, idx) => {
        const component: DeviceSpecializationComponent | undefined = DeviceSpecializationComponent.parse(componentJson, \`\${sourceField}[\${String(idx)}]\`);
        if (component !== undefined) {
          instance.addSpecialization(component);
        }
      });
    }

    fieldName = 'version';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const componentJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      componentJsonArray.forEach((componentJson: JSON.Value, idx) => {
        const component: DeviceVersionComponent | undefined = DeviceVersionComponent.parse(componentJson, \`\${sourceField}[\${String(idx)}]\`);
        if (component !== undefined) {
          instance.addVersion(component);
        }
      });
    }

    fieldName = 'property';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const componentJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      componentJsonArray.forEach((componentJson: JSON.Value, idx) => {
        const component: DevicePropertyComponent | undefined = DevicePropertyComponent.parse(componentJson, \`\${sourceField}[\${String(idx)}]\`);
        if (component !== undefined) {
          instance.addProperty(component);
        }
      });
    }

    fieldName = 'patient';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = Reference.parse(classJsonObj[fieldName]!, sourceField);
      instance.setPatient(datatype);
    }

    fieldName = 'owner';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = Reference.parse(classJsonObj[fieldName]!, sourceField);
      instance.setOwner(datatype);
    }

    fieldName = 'contact';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: ContactPoint | undefined = ContactPoint.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addContact(datatype);
        }
      });
    }

    fieldName = 'location';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = Reference.parse(classJsonObj[fieldName]!, sourceField);
      instance.setLocation(datatype);
    }

    fieldName = 'url';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = fhirParser.parseUriType(dtJson, dtSiblingJson);
      instance.setUrlElement(datatype);
    }

    fieldName = 'note';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Annotation | undefined = Annotation.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addNote(datatype);
        }
      });
    }

    fieldName = 'safety';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: CodeableConcept | undefined = CodeableConcept.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addSafety(datatype);
        }
      });
    }

    fieldName = 'parent';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = Reference.parse(classJsonObj[fieldName]!, sourceField);
      instance.setParent(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Device.identifier Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Instance identifier
   * - **Definition:** Unique instance identifiers assigned to a device by manufacturers other organizations or owners.
   * - **Comment:** The barcode string from a barcode present on a device label or package may identify the instance, include names given to the device in local usage, or may identify the type of device. If the identifier identifies the type of device, Device.type element should be used.
   * - **FHIR Type:** \`Identifier\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private identifier?: Identifier[] | undefined;

  /**
   * Device.definition Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The reference to the definition for the device
   * - **Definition:** The reference to the definition for the device.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/DeviceDefinition',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private definition?: Reference | undefined;

  /**
   * Device.udiCarrier Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Unique Device Identifier (UDI) Barcode string
   * - **Definition:** Unique device identifier (UDI) assigned to device label or package.  Note that the Device may include multiple udiCarriers as it either may include just the udiCarrier for the jurisdiction it is sold, or for multiple jurisdictions it could have been sold.
   * - **Comment:** UDI may identify an unique instance of a device, or it may only identify the type of the device.  See [UDI mappings](https://hl7.org/fhir/device-mappings.html#udi) for a complete mapping of UDI parts to Device.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private udiCarrier?: DeviceUdiCarrierComponent[] | undefined;

  /**
   * FHIR CodeSystem: DeviceStatus
   *
   * @see {@link DeviceStatusEnum }
   */
  private readonly deviceStatusEnum: DeviceStatusEnum;

  /**
   * Device.status Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** active | inactive | entered-in-error | unknown
   * - **Definition:** Status of the Device availability.
   * - **Comment:** This element is labeled as a modifier because the status contains the codes inactive and entered-in-error that mark the device (record)as not currently valid.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** true
   * - **isModifierReason:** This element is labelled as a modifier because it is a status element that contains status entered-in-error which means that the resource should not be treated as valid
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link DeviceStatusEnum }
   */
  private status?: EnumCodeType | undefined;

  /**
   * Device.statusReason Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** online | paused | standby | offline | not-ready | transduc-discon | hw-discon | off
   * - **Definition:** Reason for the dtatus of the Device availability.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private statusReason?: CodeableConcept[] | undefined;

  /**
   * Device.distinctIdentifier Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The distinct identification string
   * - **Definition:** The distinct identification string as required by regulation for a human cell, tissue, or cellular and tissue-based product.
   * - **Comment:** For example, this applies to devices in the United States regulated under *Code of Federal Regulation 21CFR§1271.290(c)*.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private distinctIdentifier?: StringType | undefined;

  /**
   * Device.manufacturer Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Name of device manufacturer
   * - **Definition:** A name of the manufacturer.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private manufacturer?: StringType | undefined;

  /**
   * Device.manufactureDate Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Date when the device was made
   * - **Definition:** The date and time when the device was manufactured.
   * - **FHIR Type:** \`dateTime\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private manufactureDate?: DateTimeType | undefined;

  /**
   * Device.expirationDate Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Date and time of expiry of this device (if applicable)
   * - **Definition:** The date and time beyond which this device is no longer valid or should not be used (if applicable).
   * - **FHIR Type:** \`dateTime\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private expirationDate?: DateTimeType | undefined;

  /**
   * Device.lotNumber Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Lot number of manufacture
   * - **Definition:** Lot number assigned by the manufacturer.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private lotNumber?: StringType | undefined;

  /**
   * Device.serialNumber Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Serial number assigned by the manufacturer
   * - **Definition:** The serial number assigned by the organization when the device was manufactured.
   * - **Comment:** Alphanumeric Maximum 20.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private serialNumber?: StringType | undefined;

  /**
   * Device.deviceName Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The name of the device as given by the manufacturer
   * - **Definition:** This represents the manufacturer\\'s name of the device as provided by the device, from a UDI label, or by a person describing the Device.  This typically would be used when a person provides the name(s) or when the device represents one of the names available from DeviceDefinition.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private deviceName?: DeviceDeviceNameComponent[] | undefined;

  /**
   * Device.modelNumber Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The model number for the device
   * - **Definition:** The model number for the device.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private modelNumber?: StringType | undefined;

  /**
   * Device.partNumber Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The part number of the device
   * - **Definition:** The part number of the device.
   * - **Comment:** Alphanumeric Maximum 20.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private partNumber?: StringType | undefined;

  /**
   * Device.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The kind or type of device
   * - **Definition:** The kind or type of device.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private type_?: CodeableConcept | undefined;

  /**
   * Device.specialization Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The capabilities supported on a  device, the standards to which the device conforms for a particular purpose, and used for the communication
   * - **Definition:** The capabilities supported on a  device, the standards to which the device conforms for a particular purpose, and used for the communication.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private specialization?: DeviceSpecializationComponent[] | undefined;

  /**
   * Device.version Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The actual design of the device or software version running on the device
   * - **Definition:** The actual design of the device or software version running on the device.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private version?: DeviceVersionComponent[] | undefined;

  /**
   * Device.property Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The actual configuration settings of a device as it actually operates, e.g., regulation status, time properties
   * - **Definition:** The actual configuration settings of a device as it actually operates, e.g., regulation status, time properties.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private property?: DevicePropertyComponent[] | undefined;

  /**
   * Device.patient Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Patient to whom Device is affixed
   * - **Definition:** Patient information, If the device is affixed to a person.
   * - **Requirements:** If the device is implanted in a patient, then need to associate the device to the patient.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Patient',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private patient?: Reference | undefined;

  /**
   * Device.owner Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Organization responsible for device
   * - **Definition:** An organization that is responsible for the provision and ongoing maintenance of the device.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Organization',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private owner?: Reference | undefined;

  /**
   * Device.contact Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Details for human/organization for support
   * - **Definition:** Contact details for an organization or a particular human that is responsible for the device.
   * - **Comment:** used for troubleshooting etc.
   * - **FHIR Type:** \`ContactPoint\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private contact?: ContactPoint[] | undefined;

  /**
   * Device.location Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Where the device is found
   * - **Definition:** The place where the device can be found.
   * - **Requirements:** Device.location can be used to track device location.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Location',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private location?: Reference | undefined;

  /**
   * Device.url Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Network address to contact device
   * - **Definition:** A network address on which the device may be contacted directly.
   * - **Comment:** If the device is running a FHIR server, the network address should  be the Base URL from which a conformance statement may be retrieved.
   * - **FHIR Type:** \`uri\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private url?: UriType | undefined;

  /**
   * Device.note Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Device notes and comments
   * - **Definition:** Descriptive information, usage information or implantation information that is not captured in an existing element.
   * - **FHIR Type:** \`Annotation\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private note?: Annotation[] | undefined;

  /**
   * Device.safety Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Safety Characteristics of Device
   * - **Definition:** Provides additional safety characteristics about a medical device.  For example devices containing latex.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private safety?: CodeableConcept[] | undefined;

  /**
   * Device.parent Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The parent device
   * - **Definition:** The parent device.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Device',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private parent?: Reference | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`identifier\` property value as a Identifier array
   */
  public getIdentifier(): Identifier[] {
    return this.identifier ?? ([] as Identifier[]);
  }

  /**
   * Assigns the provided Identifier array value to the \`identifier\` property.
   *
   * @param value - the \`identifier\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setIdentifier(value: Identifier[] | undefined): this {
    if (isDefinedList<Identifier>(value)) {
      const optErrMsg = \`Invalid Device.identifier; Provided value array has an element that is not an instance of Identifier.\`;
      assertFhirTypeList<Identifier>(value, Identifier, optErrMsg);
      this.identifier = value;
    } else {
      this.identifier = undefined;
    }
    return this;
  }

  /**
   * Add the provided Identifier value to the \`identifier\` array property.
   *
   * @param value - the \`identifier\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addIdentifier(value: Identifier | undefined): this {
    if (isDefined<Identifier>(value)) {
      const optErrMsg = \`Invalid Device.identifier; Provided element is not an instance of Identifier.\`;
      assertFhirType<Identifier>(value, Identifier, optErrMsg);
      this.initIdentifier();
      this.identifier?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`identifier\` property exists and has a value; \`false\` otherwise
   */
  public hasIdentifier(): boolean {
    return isDefinedList<Identifier>(this.identifier) && this.identifier.some((item: Identifier) => !item.isEmpty());
  }

  /**
   * Initialize the \`identifier\` property
   */
  private initIdentifier(): void {
    if(!this.hasIdentifier()) {
      this.identifier = [] as Identifier[];
    }
  }

  /**
   * @returns the \`definition\` property value as a Reference object; else an empty Reference object
   */
  public getDefinition(): Reference {
    return this.definition ?? new Reference();
  }

  /**
   * Assigns the provided Definition object value to the \`definition\` property.
   *
   * @decorator \`@ReferenceTargets('Device.definition', ['DeviceDefinition',])\`
   *
   * @param value - the \`definition\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('Device.definition', [
    'DeviceDefinition',
  ])
  public setDefinition(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.definition = value;
    } else {
      this.definition = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`definition\` property exists and has a value; \`false\` otherwise
   */
  public hasDefinition(): boolean {
    return isDefined<Reference>(this.definition) && !this.definition.isEmpty();
  }

  /**
   * @returns the \`udiCarrier\` property value as a DeviceUdiCarrierComponent array
   */
  public getUdiCarrier(): DeviceUdiCarrierComponent[] {
    return this.udiCarrier ?? ([] as DeviceUdiCarrierComponent[]);
  }

  /**
   * Assigns the provided DeviceUdiCarrierComponent array value to the \`udiCarrier\` property.
   *
   * @param value - the \`udiCarrier\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setUdiCarrier(value: DeviceUdiCarrierComponent[] | undefined): this {
    if (isDefinedList<DeviceUdiCarrierComponent>(value)) {
      const optErrMsg = \`Invalid Device.udiCarrier; Provided value array has an element that is not an instance of DeviceUdiCarrierComponent.\`;
      assertFhirTypeList<DeviceUdiCarrierComponent>(value, DeviceUdiCarrierComponent, optErrMsg);
      this.udiCarrier = value;
    } else {
      this.udiCarrier = undefined;
    }
    return this;
  }

  /**
   * Add the provided DeviceUdiCarrierComponent value to the \`udiCarrier\` array property.
   *
   * @param value - the \`udiCarrier\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addUdiCarrier(value: DeviceUdiCarrierComponent | undefined): this {
    if (isDefined<DeviceUdiCarrierComponent>(value)) {
      const optErrMsg = \`Invalid Device.udiCarrier; Provided element is not an instance of DeviceUdiCarrierComponent.\`;
      assertFhirType<DeviceUdiCarrierComponent>(value, DeviceUdiCarrierComponent, optErrMsg);
      this.initUdiCarrier();
      this.udiCarrier?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`udiCarrier\` property exists and has a value; \`false\` otherwise
   */
  public hasUdiCarrier(): boolean {
    return isDefinedList<DeviceUdiCarrierComponent>(this.udiCarrier) && this.udiCarrier.some((item: DeviceUdiCarrierComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`udiCarrier\` property
   */
  private initUdiCarrier(): void {
    if(!this.hasUdiCarrier()) {
      this.udiCarrier = [] as DeviceUdiCarrierComponent[];
    }
  }

  /**
   * @returns the \`status\` property value as a EnumCodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link DeviceStatusEnum }
   */
  public getStatusEnumType(): EnumCodeType | undefined {
    return this.status;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`status\` property.
   *
   * @param enumType - the \`status\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code values
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link DeviceStatusEnum }
   */
  public setStatusEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid Device.status';
      assertEnumCodeType<DeviceStatusEnum>(enumType, DeviceStatusEnum, errMsgPrefix);
      this.status = enumType;
    } else {
      this.status = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`status\` property exists and has a value; \`false\` otherwise
   */
  public hasStatusEnumType(): boolean {
    return isDefined<EnumCodeType>(this.status) && !this.status.isEmpty() && this.status.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`status\` property value as a CodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link DeviceStatusEnum }
   */
  public getStatusElement(): CodeType | undefined {
    if (this.status === undefined) {
      return undefined;
    }
    return this.status as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`status\` property.
   *
   * @param element - the \`status\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link DeviceStatusEnum }
   */
  public setStatusElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Device.status; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.status = new EnumCodeType(element, this.deviceStatusEnum);
    } else {
      this.status = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`status\` property exists and has a value; \`false\` otherwise
   */
  public hasStatusElement(): boolean {
    return this.hasStatusEnumType();
  }

  /**
   * @returns the \`status\` property value as a fhirCode if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link DeviceStatusEnum }
   */
  public getStatus(): fhirCode | undefined {
    if (this.status === undefined) {
      return undefined;
    }
    return this.status.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`status\` property.
   *
   * @param value - the \`status\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link DeviceStatusEnum }
   */
  public setStatus(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Device.status; Provided value is not an instance of fhirCode.\`;
      this.status = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.deviceStatusEnum);
    } else {
      this.status = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`status\` property exists and has a value; \`false\` otherwise
   */
  public hasStatus(): boolean {
    return this.hasStatusEnumType();
  }

  /**
   * @returns the \`statusReason\` property value as a CodeableConcept array
   */
  public getStatusReason(): CodeableConcept[] {
    return this.statusReason ?? ([] as CodeableConcept[]);
  }

  /**
   * Assigns the provided CodeableConcept array value to the \`statusReason\` property.
   *
   * @param value - the \`statusReason\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setStatusReason(value: CodeableConcept[] | undefined): this {
    if (isDefinedList<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Device.statusReason; Provided value array has an element that is not an instance of CodeableConcept.\`;
      assertFhirTypeList<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.statusReason = value;
    } else {
      this.statusReason = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeableConcept value to the \`statusReason\` array property.
   *
   * @param value - the \`statusReason\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addStatusReason(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Device.statusReason; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.initStatusReason();
      this.statusReason?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`statusReason\` property exists and has a value; \`false\` otherwise
   */
  public hasStatusReason(): boolean {
    return isDefinedList<CodeableConcept>(this.statusReason) && this.statusReason.some((item: CodeableConcept) => !item.isEmpty());
  }

  /**
   * Initialize the \`statusReason\` property
   */
  private initStatusReason(): void {
    if(!this.hasStatusReason()) {
      this.statusReason = [] as CodeableConcept[];
    }
  }

  /**
   * @returns the \`distinctIdentifier\` property value as a StringType object if defined; else an empty StringType object
   */
  public getDistinctIdentifierElement(): StringType {
    return this.distinctIdentifier ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`distinctIdentifier\` property.
   *
   * @param element - the \`distinctIdentifier\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDistinctIdentifierElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Device.distinctIdentifier; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.distinctIdentifier = element;
    } else {
      this.distinctIdentifier = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`distinctIdentifier\` property exists and has a value; \`false\` otherwise
   */
  public hasDistinctIdentifierElement(): boolean {
    return isDefined<StringType>(this.distinctIdentifier) && !this.distinctIdentifier.isEmpty();
  }

  /**
   * @returns the \`distinctIdentifier\` property value as a fhirString if defined; else undefined
   */
  public getDistinctIdentifier(): fhirString | undefined {
    return this.distinctIdentifier?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`distinctIdentifier\` property.
   *
   * @param value - the \`distinctIdentifier\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDistinctIdentifier(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Device.distinctIdentifier (\${String(value)})\`;
      this.distinctIdentifier = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.distinctIdentifier = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`distinctIdentifier\` property exists and has a value; \`false\` otherwise
   */
  public hasDistinctIdentifier(): boolean {
    return this.hasDistinctIdentifierElement();
  }

  /**
   * @returns the \`manufacturer\` property value as a StringType object if defined; else an empty StringType object
   */
  public getManufacturerElement(): StringType {
    return this.manufacturer ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`manufacturer\` property.
   *
   * @param element - the \`manufacturer\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setManufacturerElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Device.manufacturer; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.manufacturer = element;
    } else {
      this.manufacturer = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`manufacturer\` property exists and has a value; \`false\` otherwise
   */
  public hasManufacturerElement(): boolean {
    return isDefined<StringType>(this.manufacturer) && !this.manufacturer.isEmpty();
  }

  /**
   * @returns the \`manufacturer\` property value as a fhirString if defined; else undefined
   */
  public getManufacturer(): fhirString | undefined {
    return this.manufacturer?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`manufacturer\` property.
   *
   * @param value - the \`manufacturer\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setManufacturer(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Device.manufacturer (\${String(value)})\`;
      this.manufacturer = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.manufacturer = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`manufacturer\` property exists and has a value; \`false\` otherwise
   */
  public hasManufacturer(): boolean {
    return this.hasManufacturerElement();
  }

  /**
   * @returns the \`manufactureDate\` property value as a DateTimeType object if defined; else an empty DateTimeType object
   */
  public getManufactureDateElement(): DateTimeType {
    return this.manufactureDate ?? new DateTimeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`manufactureDate\` property.
   *
   * @param element - the \`manufactureDate\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setManufactureDateElement(element: DateTimeType | undefined): this {
    if (isDefined<DateTimeType>(element)) {
      const optErrMsg = \`Invalid Device.manufactureDate; Provided element is not an instance of DateTimeType.\`;
      assertFhirType<DateTimeType>(element, DateTimeType, optErrMsg);
      this.manufactureDate = element;
    } else {
      this.manufactureDate = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`manufactureDate\` property exists and has a value; \`false\` otherwise
   */
  public hasManufactureDateElement(): boolean {
    return isDefined<DateTimeType>(this.manufactureDate) && !this.manufactureDate.isEmpty();
  }

  /**
   * @returns the \`manufactureDate\` property value as a fhirDateTime if defined; else undefined
   */
  public getManufactureDate(): fhirDateTime | undefined {
    return this.manufactureDate?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`manufactureDate\` property.
   *
   * @param value - the \`manufactureDate\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setManufactureDate(value: fhirDateTime | undefined): this {
    if (isDefined<fhirDateTime>(value)) {
      const optErrMsg = \`Invalid Device.manufactureDate (\${String(value)})\`;
      this.manufactureDate = new DateTimeType(parseFhirPrimitiveData(value, fhirDateTimeSchema, optErrMsg));
    } else {
      this.manufactureDate = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`manufactureDate\` property exists and has a value; \`false\` otherwise
   */
  public hasManufactureDate(): boolean {
    return this.hasManufactureDateElement();
  }

  /**
   * @returns the \`expirationDate\` property value as a DateTimeType object if defined; else an empty DateTimeType object
   */
  public getExpirationDateElement(): DateTimeType {
    return this.expirationDate ?? new DateTimeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`expirationDate\` property.
   *
   * @param element - the \`expirationDate\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setExpirationDateElement(element: DateTimeType | undefined): this {
    if (isDefined<DateTimeType>(element)) {
      const optErrMsg = \`Invalid Device.expirationDate; Provided element is not an instance of DateTimeType.\`;
      assertFhirType<DateTimeType>(element, DateTimeType, optErrMsg);
      this.expirationDate = element;
    } else {
      this.expirationDate = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`expirationDate\` property exists and has a value; \`false\` otherwise
   */
  public hasExpirationDateElement(): boolean {
    return isDefined<DateTimeType>(this.expirationDate) && !this.expirationDate.isEmpty();
  }

  /**
   * @returns the \`expirationDate\` property value as a fhirDateTime if defined; else undefined
   */
  public getExpirationDate(): fhirDateTime | undefined {
    return this.expirationDate?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`expirationDate\` property.
   *
   * @param value - the \`expirationDate\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setExpirationDate(value: fhirDateTime | undefined): this {
    if (isDefined<fhirDateTime>(value)) {
      const optErrMsg = \`Invalid Device.expirationDate (\${String(value)})\`;
      this.expirationDate = new DateTimeType(parseFhirPrimitiveData(value, fhirDateTimeSchema, optErrMsg));
    } else {
      this.expirationDate = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`expirationDate\` property exists and has a value; \`false\` otherwise
   */
  public hasExpirationDate(): boolean {
    return this.hasExpirationDateElement();
  }

  /**
   * @returns the \`lotNumber\` property value as a StringType object if defined; else an empty StringType object
   */
  public getLotNumberElement(): StringType {
    return this.lotNumber ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`lotNumber\` property.
   *
   * @param element - the \`lotNumber\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLotNumberElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Device.lotNumber; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.lotNumber = element;
    } else {
      this.lotNumber = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`lotNumber\` property exists and has a value; \`false\` otherwise
   */
  public hasLotNumberElement(): boolean {
    return isDefined<StringType>(this.lotNumber) && !this.lotNumber.isEmpty();
  }

  /**
   * @returns the \`lotNumber\` property value as a fhirString if defined; else undefined
   */
  public getLotNumber(): fhirString | undefined {
    return this.lotNumber?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`lotNumber\` property.
   *
   * @param value - the \`lotNumber\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLotNumber(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Device.lotNumber (\${String(value)})\`;
      this.lotNumber = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.lotNumber = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`lotNumber\` property exists and has a value; \`false\` otherwise
   */
  public hasLotNumber(): boolean {
    return this.hasLotNumberElement();
  }

  /**
   * @returns the \`serialNumber\` property value as a StringType object if defined; else an empty StringType object
   */
  public getSerialNumberElement(): StringType {
    return this.serialNumber ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`serialNumber\` property.
   *
   * @param element - the \`serialNumber\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSerialNumberElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Device.serialNumber; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.serialNumber = element;
    } else {
      this.serialNumber = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`serialNumber\` property exists and has a value; \`false\` otherwise
   */
  public hasSerialNumberElement(): boolean {
    return isDefined<StringType>(this.serialNumber) && !this.serialNumber.isEmpty();
  }

  /**
   * @returns the \`serialNumber\` property value as a fhirString if defined; else undefined
   */
  public getSerialNumber(): fhirString | undefined {
    return this.serialNumber?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`serialNumber\` property.
   *
   * @param value - the \`serialNumber\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSerialNumber(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Device.serialNumber (\${String(value)})\`;
      this.serialNumber = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.serialNumber = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`serialNumber\` property exists and has a value; \`false\` otherwise
   */
  public hasSerialNumber(): boolean {
    return this.hasSerialNumberElement();
  }

  /**
   * @returns the \`deviceName\` property value as a DeviceDeviceNameComponent array
   */
  public getDeviceName(): DeviceDeviceNameComponent[] {
    return this.deviceName ?? ([] as DeviceDeviceNameComponent[]);
  }

  /**
   * Assigns the provided DeviceDeviceNameComponent array value to the \`deviceName\` property.
   *
   * @param value - the \`deviceName\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setDeviceName(value: DeviceDeviceNameComponent[] | undefined): this {
    if (isDefinedList<DeviceDeviceNameComponent>(value)) {
      const optErrMsg = \`Invalid Device.deviceName; Provided value array has an element that is not an instance of DeviceDeviceNameComponent.\`;
      assertFhirTypeList<DeviceDeviceNameComponent>(value, DeviceDeviceNameComponent, optErrMsg);
      this.deviceName = value;
    } else {
      this.deviceName = undefined;
    }
    return this;
  }

  /**
   * Add the provided DeviceDeviceNameComponent value to the \`deviceName\` array property.
   *
   * @param value - the \`deviceName\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addDeviceName(value: DeviceDeviceNameComponent | undefined): this {
    if (isDefined<DeviceDeviceNameComponent>(value)) {
      const optErrMsg = \`Invalid Device.deviceName; Provided element is not an instance of DeviceDeviceNameComponent.\`;
      assertFhirType<DeviceDeviceNameComponent>(value, DeviceDeviceNameComponent, optErrMsg);
      this.initDeviceName();
      this.deviceName?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`deviceName\` property exists and has a value; \`false\` otherwise
   */
  public hasDeviceName(): boolean {
    return isDefinedList<DeviceDeviceNameComponent>(this.deviceName) && this.deviceName.some((item: DeviceDeviceNameComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`deviceName\` property
   */
  private initDeviceName(): void {
    if(!this.hasDeviceName()) {
      this.deviceName = [] as DeviceDeviceNameComponent[];
    }
  }

  /**
   * @returns the \`modelNumber\` property value as a StringType object if defined; else an empty StringType object
   */
  public getModelNumberElement(): StringType {
    return this.modelNumber ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`modelNumber\` property.
   *
   * @param element - the \`modelNumber\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setModelNumberElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Device.modelNumber; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.modelNumber = element;
    } else {
      this.modelNumber = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`modelNumber\` property exists and has a value; \`false\` otherwise
   */
  public hasModelNumberElement(): boolean {
    return isDefined<StringType>(this.modelNumber) && !this.modelNumber.isEmpty();
  }

  /**
   * @returns the \`modelNumber\` property value as a fhirString if defined; else undefined
   */
  public getModelNumber(): fhirString | undefined {
    return this.modelNumber?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`modelNumber\` property.
   *
   * @param value - the \`modelNumber\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setModelNumber(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Device.modelNumber (\${String(value)})\`;
      this.modelNumber = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.modelNumber = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`modelNumber\` property exists and has a value; \`false\` otherwise
   */
  public hasModelNumber(): boolean {
    return this.hasModelNumberElement();
  }

  /**
   * @returns the \`partNumber\` property value as a StringType object if defined; else an empty StringType object
   */
  public getPartNumberElement(): StringType {
    return this.partNumber ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`partNumber\` property.
   *
   * @param element - the \`partNumber\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPartNumberElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Device.partNumber; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.partNumber = element;
    } else {
      this.partNumber = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`partNumber\` property exists and has a value; \`false\` otherwise
   */
  public hasPartNumberElement(): boolean {
    return isDefined<StringType>(this.partNumber) && !this.partNumber.isEmpty();
  }

  /**
   * @returns the \`partNumber\` property value as a fhirString if defined; else undefined
   */
  public getPartNumber(): fhirString | undefined {
    return this.partNumber?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`partNumber\` property.
   *
   * @param value - the \`partNumber\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPartNumber(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Device.partNumber (\${String(value)})\`;
      this.partNumber = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.partNumber = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`partNumber\` property exists and has a value; \`false\` otherwise
   */
  public hasPartNumber(): boolean {
    return this.hasPartNumberElement();
  }

  /**
   * @returns the \`type_\` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getType(): CodeableConcept {
    return this.type_ ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Type object value to the \`type_\` property.
   *
   * @param value - the \`type_\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setType(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Device.type; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.type_ = value;
    } else {
      this.type_ = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasType(): boolean {
    return isDefined<CodeableConcept>(this.type_) && !this.type_.isEmpty();
  }

  /**
   * @returns the \`specialization\` property value as a DeviceSpecializationComponent array
   */
  public getSpecialization(): DeviceSpecializationComponent[] {
    return this.specialization ?? ([] as DeviceSpecializationComponent[]);
  }

  /**
   * Assigns the provided DeviceSpecializationComponent array value to the \`specialization\` property.
   *
   * @param value - the \`specialization\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setSpecialization(value: DeviceSpecializationComponent[] | undefined): this {
    if (isDefinedList<DeviceSpecializationComponent>(value)) {
      const optErrMsg = \`Invalid Device.specialization; Provided value array has an element that is not an instance of DeviceSpecializationComponent.\`;
      assertFhirTypeList<DeviceSpecializationComponent>(value, DeviceSpecializationComponent, optErrMsg);
      this.specialization = value;
    } else {
      this.specialization = undefined;
    }
    return this;
  }

  /**
   * Add the provided DeviceSpecializationComponent value to the \`specialization\` array property.
   *
   * @param value - the \`specialization\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addSpecialization(value: DeviceSpecializationComponent | undefined): this {
    if (isDefined<DeviceSpecializationComponent>(value)) {
      const optErrMsg = \`Invalid Device.specialization; Provided element is not an instance of DeviceSpecializationComponent.\`;
      assertFhirType<DeviceSpecializationComponent>(value, DeviceSpecializationComponent, optErrMsg);
      this.initSpecialization();
      this.specialization?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`specialization\` property exists and has a value; \`false\` otherwise
   */
  public hasSpecialization(): boolean {
    return isDefinedList<DeviceSpecializationComponent>(this.specialization) && this.specialization.some((item: DeviceSpecializationComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`specialization\` property
   */
  private initSpecialization(): void {
    if(!this.hasSpecialization()) {
      this.specialization = [] as DeviceSpecializationComponent[];
    }
  }

  /**
   * @returns the \`version\` property value as a DeviceVersionComponent array
   */
  public getVersion(): DeviceVersionComponent[] {
    return this.version ?? ([] as DeviceVersionComponent[]);
  }

  /**
   * Assigns the provided DeviceVersionComponent array value to the \`version\` property.
   *
   * @param value - the \`version\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setVersion(value: DeviceVersionComponent[] | undefined): this {
    if (isDefinedList<DeviceVersionComponent>(value)) {
      const optErrMsg = \`Invalid Device.version; Provided value array has an element that is not an instance of DeviceVersionComponent.\`;
      assertFhirTypeList<DeviceVersionComponent>(value, DeviceVersionComponent, optErrMsg);
      this.version = value;
    } else {
      this.version = undefined;
    }
    return this;
  }

  /**
   * Add the provided DeviceVersionComponent value to the \`version\` array property.
   *
   * @param value - the \`version\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addVersion(value: DeviceVersionComponent | undefined): this {
    if (isDefined<DeviceVersionComponent>(value)) {
      const optErrMsg = \`Invalid Device.version; Provided element is not an instance of DeviceVersionComponent.\`;
      assertFhirType<DeviceVersionComponent>(value, DeviceVersionComponent, optErrMsg);
      this.initVersion();
      this.version?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`version\` property exists and has a value; \`false\` otherwise
   */
  public hasVersion(): boolean {
    return isDefinedList<DeviceVersionComponent>(this.version) && this.version.some((item: DeviceVersionComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`version\` property
   */
  private initVersion(): void {
    if(!this.hasVersion()) {
      this.version = [] as DeviceVersionComponent[];
    }
  }

  /**
   * @returns the \`property\` property value as a DevicePropertyComponent array
   */
  public getProperty(): DevicePropertyComponent[] {
    return this.property ?? ([] as DevicePropertyComponent[]);
  }

  /**
   * Assigns the provided DevicePropertyComponent array value to the \`property\` property.
   *
   * @param value - the \`property\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setProperty(value: DevicePropertyComponent[] | undefined): this {
    if (isDefinedList<DevicePropertyComponent>(value)) {
      const optErrMsg = \`Invalid Device.property; Provided value array has an element that is not an instance of DevicePropertyComponent.\`;
      assertFhirTypeList<DevicePropertyComponent>(value, DevicePropertyComponent, optErrMsg);
      this.property = value;
    } else {
      this.property = undefined;
    }
    return this;
  }

  /**
   * Add the provided DevicePropertyComponent value to the \`property\` array property.
   *
   * @param value - the \`property\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addProperty(value: DevicePropertyComponent | undefined): this {
    if (isDefined<DevicePropertyComponent>(value)) {
      const optErrMsg = \`Invalid Device.property; Provided element is not an instance of DevicePropertyComponent.\`;
      assertFhirType<DevicePropertyComponent>(value, DevicePropertyComponent, optErrMsg);
      this.initProperty();
      this.property?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`property\` property exists and has a value; \`false\` otherwise
   */
  public hasProperty(): boolean {
    return isDefinedList<DevicePropertyComponent>(this.property) && this.property.some((item: DevicePropertyComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`property\` property
   */
  private initProperty(): void {
    if(!this.hasProperty()) {
      this.property = [] as DevicePropertyComponent[];
    }
  }

  /**
   * @returns the \`patient\` property value as a Reference object; else an empty Reference object
   */
  public getPatient(): Reference {
    return this.patient ?? new Reference();
  }

  /**
   * Assigns the provided Patient object value to the \`patient\` property.
   *
   * @decorator \`@ReferenceTargets('Device.patient', ['Patient',])\`
   *
   * @param value - the \`patient\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('Device.patient', [
    'Patient',
  ])
  public setPatient(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.patient = value;
    } else {
      this.patient = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`patient\` property exists and has a value; \`false\` otherwise
   */
  public hasPatient(): boolean {
    return isDefined<Reference>(this.patient) && !this.patient.isEmpty();
  }

  /**
   * @returns the \`owner\` property value as a Reference object; else an empty Reference object
   */
  public getOwner(): Reference {
    return this.owner ?? new Reference();
  }

  /**
   * Assigns the provided Owner object value to the \`owner\` property.
   *
   * @decorator \`@ReferenceTargets('Device.owner', ['Organization',])\`
   *
   * @param value - the \`owner\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('Device.owner', [
    'Organization',
  ])
  public setOwner(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.owner = value;
    } else {
      this.owner = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`owner\` property exists and has a value; \`false\` otherwise
   */
  public hasOwner(): boolean {
    return isDefined<Reference>(this.owner) && !this.owner.isEmpty();
  }

  /**
   * @returns the \`contact\` property value as a ContactPoint array
   */
  public getContact(): ContactPoint[] {
    return this.contact ?? ([] as ContactPoint[]);
  }

  /**
   * Assigns the provided ContactPoint array value to the \`contact\` property.
   *
   * @param value - the \`contact\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setContact(value: ContactPoint[] | undefined): this {
    if (isDefinedList<ContactPoint>(value)) {
      const optErrMsg = \`Invalid Device.contact; Provided value array has an element that is not an instance of ContactPoint.\`;
      assertFhirTypeList<ContactPoint>(value, ContactPoint, optErrMsg);
      this.contact = value;
    } else {
      this.contact = undefined;
    }
    return this;
  }

  /**
   * Add the provided ContactPoint value to the \`contact\` array property.
   *
   * @param value - the \`contact\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addContact(value: ContactPoint | undefined): this {
    if (isDefined<ContactPoint>(value)) {
      const optErrMsg = \`Invalid Device.contact; Provided element is not an instance of ContactPoint.\`;
      assertFhirType<ContactPoint>(value, ContactPoint, optErrMsg);
      this.initContact();
      this.contact?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`contact\` property exists and has a value; \`false\` otherwise
   */
  public hasContact(): boolean {
    return isDefinedList<ContactPoint>(this.contact) && this.contact.some((item: ContactPoint) => !item.isEmpty());
  }

  /**
   * Initialize the \`contact\` property
   */
  private initContact(): void {
    if(!this.hasContact()) {
      this.contact = [] as ContactPoint[];
    }
  }

  /**
   * @returns the \`location\` property value as a Reference object; else an empty Reference object
   */
  public getLocation(): Reference {
    return this.location ?? new Reference();
  }

  /**
   * Assigns the provided Location object value to the \`location\` property.
   *
   * @decorator \`@ReferenceTargets('Device.location', ['Location',])\`
   *
   * @param value - the \`location\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('Device.location', [
    'Location',
  ])
  public setLocation(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.location = value;
    } else {
      this.location = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`location\` property exists and has a value; \`false\` otherwise
   */
  public hasLocation(): boolean {
    return isDefined<Reference>(this.location) && !this.location.isEmpty();
  }

  /**
   * @returns the \`url\` property value as a UriType object if defined; else an empty UriType object
   */
  public getUrlElement(): UriType {
    return this.url ?? new UriType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`url\` property.
   *
   * @param element - the \`url\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUrlElement(element: UriType | undefined): this {
    if (isDefined<UriType>(element)) {
      const optErrMsg = \`Invalid Device.url; Provided element is not an instance of UriType.\`;
      assertFhirType<UriType>(element, UriType, optErrMsg);
      this.url = element;
    } else {
      this.url = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`url\` property exists and has a value; \`false\` otherwise
   */
  public hasUrlElement(): boolean {
    return isDefined<UriType>(this.url) && !this.url.isEmpty();
  }

  /**
   * @returns the \`url\` property value as a fhirUri if defined; else undefined
   */
  public getUrl(): fhirUri | undefined {
    return this.url?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`url\` property.
   *
   * @param value - the \`url\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUrl(value: fhirUri | undefined): this {
    if (isDefined<fhirUri>(value)) {
      const optErrMsg = \`Invalid Device.url (\${String(value)})\`;
      this.url = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    } else {
      this.url = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`url\` property exists and has a value; \`false\` otherwise
   */
  public hasUrl(): boolean {
    return this.hasUrlElement();
  }

  /**
   * @returns the \`note\` property value as a Annotation array
   */
  public getNote(): Annotation[] {
    return this.note ?? ([] as Annotation[]);
  }

  /**
   * Assigns the provided Annotation array value to the \`note\` property.
   *
   * @param value - the \`note\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setNote(value: Annotation[] | undefined): this {
    if (isDefinedList<Annotation>(value)) {
      const optErrMsg = \`Invalid Device.note; Provided value array has an element that is not an instance of Annotation.\`;
      assertFhirTypeList<Annotation>(value, Annotation, optErrMsg);
      this.note = value;
    } else {
      this.note = undefined;
    }
    return this;
  }

  /**
   * Add the provided Annotation value to the \`note\` array property.
   *
   * @param value - the \`note\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addNote(value: Annotation | undefined): this {
    if (isDefined<Annotation>(value)) {
      const optErrMsg = \`Invalid Device.note; Provided element is not an instance of Annotation.\`;
      assertFhirType<Annotation>(value, Annotation, optErrMsg);
      this.initNote();
      this.note?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`note\` property exists and has a value; \`false\` otherwise
   */
  public hasNote(): boolean {
    return isDefinedList<Annotation>(this.note) && this.note.some((item: Annotation) => !item.isEmpty());
  }

  /**
   * Initialize the \`note\` property
   */
  private initNote(): void {
    if(!this.hasNote()) {
      this.note = [] as Annotation[];
    }
  }

  /**
   * @returns the \`safety\` property value as a CodeableConcept array
   */
  public getSafety(): CodeableConcept[] {
    return this.safety ?? ([] as CodeableConcept[]);
  }

  /**
   * Assigns the provided CodeableConcept array value to the \`safety\` property.
   *
   * @param value - the \`safety\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setSafety(value: CodeableConcept[] | undefined): this {
    if (isDefinedList<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Device.safety; Provided value array has an element that is not an instance of CodeableConcept.\`;
      assertFhirTypeList<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.safety = value;
    } else {
      this.safety = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeableConcept value to the \`safety\` array property.
   *
   * @param value - the \`safety\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addSafety(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Device.safety; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.initSafety();
      this.safety?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`safety\` property exists and has a value; \`false\` otherwise
   */
  public hasSafety(): boolean {
    return isDefinedList<CodeableConcept>(this.safety) && this.safety.some((item: CodeableConcept) => !item.isEmpty());
  }

  /**
   * Initialize the \`safety\` property
   */
  private initSafety(): void {
    if(!this.hasSafety()) {
      this.safety = [] as CodeableConcept[];
    }
  }

  /**
   * @returns the \`parent\` property value as a Reference object; else an empty Reference object
   */
  public getParent(): Reference {
    return this.parent ?? new Reference();
  }

  /**
   * Assigns the provided Parent object value to the \`parent\` property.
   *
   * @decorator \`@ReferenceTargets('Device.parent', ['Device',])\`
   *
   * @param value - the \`parent\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('Device.parent', [
    'Device',
  ])
  public setParent(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.parent = value;
    } else {
      this.parent = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`parent\` property exists and has a value; \`false\` otherwise
   */
  public hasParent(): boolean {
    return isDefined<Reference>(this.parent) && !this.parent.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Device';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.identifier,
      this.definition,
      this.udiCarrier,
      this.status,
      this.statusReason,
      this.distinctIdentifier,
      this.manufacturer,
      this.manufactureDate,
      this.expirationDate,
      this.lotNumber,
      this.serialNumber,
      this.deviceName,
      this.modelNumber,
      this.partNumber,
      this.type_,
      this.specialization,
      this.version,
      this.property,
      this.patient,
      this.owner,
      this.contact,
      this.location,
      this.url,
      this.note,
      this.safety,
      this.parent,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Device {
    const dest = new Device();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Device): void {
    super.copyValues(dest);
    const identifierList = copyListValues<Identifier>(this.identifier);
    dest.identifier = identifierList.length === 0 ? undefined : identifierList;
    dest.definition = this.definition?.copy();
    const udiCarrierList = copyListValues<DeviceUdiCarrierComponent>(this.udiCarrier);
    dest.udiCarrier = udiCarrierList.length === 0 ? undefined : udiCarrierList;
    dest.status = this.status?.copy();
    const statusReasonList = copyListValues<CodeableConcept>(this.statusReason);
    dest.statusReason = statusReasonList.length === 0 ? undefined : statusReasonList;
    dest.distinctIdentifier = this.distinctIdentifier?.copy();
    dest.manufacturer = this.manufacturer?.copy();
    dest.manufactureDate = this.manufactureDate?.copy();
    dest.expirationDate = this.expirationDate?.copy();
    dest.lotNumber = this.lotNumber?.copy();
    dest.serialNumber = this.serialNumber?.copy();
    const deviceNameList = copyListValues<DeviceDeviceNameComponent>(this.deviceName);
    dest.deviceName = deviceNameList.length === 0 ? undefined : deviceNameList;
    dest.modelNumber = this.modelNumber?.copy();
    dest.partNumber = this.partNumber?.copy();
    dest.type_ = this.type_?.copy();
    const specializationList = copyListValues<DeviceSpecializationComponent>(this.specialization);
    dest.specialization = specializationList.length === 0 ? undefined : specializationList;
    const versionList = copyListValues<DeviceVersionComponent>(this.version);
    dest.version = versionList.length === 0 ? undefined : versionList;
    const propertyList = copyListValues<DevicePropertyComponent>(this.property);
    dest.property = propertyList.length === 0 ? undefined : propertyList;
    dest.patient = this.patient?.copy();
    dest.owner = this.owner?.copy();
    const contactList = copyListValues<ContactPoint>(this.contact);
    dest.contact = contactList.length === 0 ? undefined : contactList;
    dest.location = this.location?.copy();
    dest.url = this.url?.copy();
    const noteList = copyListValues<Annotation>(this.note);
    dest.note = noteList.length === 0 ? undefined : noteList;
    const safetyList = copyListValues<CodeableConcept>(this.safety);
    dest.safety = safetyList.length === 0 ? undefined : safetyList;
    dest.parent = this.parent?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasIdentifier()) {
      setFhirComplexListJson(this.getIdentifier(), 'identifier', jsonObj);
    }

    if (this.hasDefinition()) {
      setFhirComplexJson(this.getDefinition(), 'definition', jsonObj);
    }

    if (this.hasUdiCarrier()) {
      setFhirBackboneElementListJson(this.getUdiCarrier(), 'udiCarrier', jsonObj);
    }

    if (this.hasStatusElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getStatusElement()!, 'status', jsonObj);
    }

    if (this.hasStatusReason()) {
      setFhirComplexListJson(this.getStatusReason(), 'statusReason', jsonObj);
    }

    if (this.hasDistinctIdentifierElement()) {
      setFhirPrimitiveJson<fhirString>(this.getDistinctIdentifierElement(), 'distinctIdentifier', jsonObj);
    }

    if (this.hasManufacturerElement()) {
      setFhirPrimitiveJson<fhirString>(this.getManufacturerElement(), 'manufacturer', jsonObj);
    }

    if (this.hasManufactureDateElement()) {
      setFhirPrimitiveJson<fhirDateTime>(this.getManufactureDateElement(), 'manufactureDate', jsonObj);
    }

    if (this.hasExpirationDateElement()) {
      setFhirPrimitiveJson<fhirDateTime>(this.getExpirationDateElement(), 'expirationDate', jsonObj);
    }

    if (this.hasLotNumberElement()) {
      setFhirPrimitiveJson<fhirString>(this.getLotNumberElement(), 'lotNumber', jsonObj);
    }

    if (this.hasSerialNumberElement()) {
      setFhirPrimitiveJson<fhirString>(this.getSerialNumberElement(), 'serialNumber', jsonObj);
    }

    if (this.hasDeviceName()) {
      setFhirBackboneElementListJson(this.getDeviceName(), 'deviceName', jsonObj);
    }

    if (this.hasModelNumberElement()) {
      setFhirPrimitiveJson<fhirString>(this.getModelNumberElement(), 'modelNumber', jsonObj);
    }

    if (this.hasPartNumberElement()) {
      setFhirPrimitiveJson<fhirString>(this.getPartNumberElement(), 'partNumber', jsonObj);
    }

    if (this.hasType()) {
      setFhirComplexJson(this.getType(), 'type', jsonObj);
    }

    if (this.hasSpecialization()) {
      setFhirBackboneElementListJson(this.getSpecialization(), 'specialization', jsonObj);
    }

    if (this.hasVersion()) {
      setFhirBackboneElementListJson(this.getVersion(), 'version', jsonObj);
    }

    if (this.hasProperty()) {
      setFhirBackboneElementListJson(this.getProperty(), 'property', jsonObj);
    }

    if (this.hasPatient()) {
      setFhirComplexJson(this.getPatient(), 'patient', jsonObj);
    }

    if (this.hasOwner()) {
      setFhirComplexJson(this.getOwner(), 'owner', jsonObj);
    }

    if (this.hasContact()) {
      setFhirComplexListJson(this.getContact(), 'contact', jsonObj);
    }

    if (this.hasLocation()) {
      setFhirComplexJson(this.getLocation(), 'location', jsonObj);
    }

    if (this.hasUrlElement()) {
      setFhirPrimitiveJson<fhirUri>(this.getUrlElement(), 'url', jsonObj);
    }

    if (this.hasNote()) {
      setFhirComplexListJson(this.getNote(), 'note', jsonObj);
    }

    if (this.hasSafety()) {
      setFhirComplexListJson(this.getSafety(), 'safety', jsonObj);
    }

    if (this.hasParent()) {
      setFhirComplexJson(this.getParent(), 'parent', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * DeviceUdiCarrierComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Unique Device Identifier (UDI) Barcode string
 * - **Definition:** Unique device identifier (UDI) assigned to device label or package.  Note that the Device may include multiple udiCarriers as it either may include just the udiCarrier for the jurisdiction it is sold, or for multiple jurisdictions it could have been sold.
 * - **Comment:** UDI may identify an unique instance of a device, or it may only identify the type of the device.  See [UDI mappings](https://hl7.org/fhir/device-mappings.html#udi) for a complete mapping of UDI parts to Device.
 *
 * @category Data Models: Resource
 * @see [FHIR Device](http://hl7.org/fhir/StructureDefinition/Device)
 */
export class DeviceUdiCarrierComponent extends BackboneElement implements IBackboneElement {
  constructor() {
    super();

    this.udiEntryTypeEnum = new UdiEntryTypeEnum();
  }

  /**
   * Parse the provided \`DeviceUdiCarrierComponent\` JSON to instantiate the DeviceUdiCarrierComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`DeviceUdiCarrierComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to DeviceUdiCarrierComponent
   * @returns DeviceUdiCarrierComponent data model or undefined for \`DeviceUdiCarrierComponent\`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): DeviceUdiCarrierComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'DeviceUdiCarrierComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new DeviceUdiCarrierComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'deviceIdentifier';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setDeviceIdentifierElement(datatype);
    }

    fieldName = 'issuer';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = fhirParser.parseUriType(dtJson, dtSiblingJson);
      instance.setIssuerElement(datatype);
    }

    fieldName = 'jurisdiction';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = fhirParser.parseUriType(dtJson, dtSiblingJson);
      instance.setJurisdictionElement(datatype);
    }

    fieldName = 'carrierAIDC';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: Base64BinaryType | undefined = fhirParser.parseBase64BinaryType(dtJson, dtSiblingJson);
      instance.setCarrierAIDCElement(datatype);
    }

    fieldName = 'carrierHRF';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setCarrierHRFElement(datatype);
    }

    fieldName = 'entryType';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setEntryTypeElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Device.udiCarrier.deviceIdentifier Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Mandatory fixed portion of UDI
   * - **Definition:** The device identifier (DI) is a mandatory, fixed portion of a UDI that identifies the labeler and the specific version or model of a device.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private deviceIdentifier?: StringType | undefined;

  /**
   * Device.udiCarrier.issuer Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** UDI Issuing Organization
   * - **Definition:** Organization that is charged with issuing UDIs for devices.  For example, the US FDA issuers include : 1) GS1:  http://hl7.org/fhir/NamingSystem/gs1-di,  2) HIBCC: http://hl7.org/fhir/NamingSystem/hibcc-dI,  3) ICCBBA for blood containers: http://hl7.org/fhir/NamingSystem/iccbba-blood-di,  4) ICCBA for other devices: http://hl7.org/fhir/NamingSystem/iccbba-other-di.
   * - **FHIR Type:** \`uri\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private issuer?: UriType | undefined;

  /**
   * Device.udiCarrier.jurisdiction Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Regional UDI authority
   * - **Definition:** The identity of the authoritative source for UDI generation within a  jurisdiction.  All UDIs are globally unique within a single namespace with the appropriate repository uri as the system.  For example,  UDIs of devices managed in the U.S. by the FDA, the value is  http://hl7.org/fhir/NamingSystem/fda-udi.
   * - **Requirements:** Allows a recipient of a UDI to know which database will contain the UDI-associated metadata.
   * - **FHIR Type:** \`uri\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private jurisdiction?: UriType | undefined;

  /**
   * Device.udiCarrier.carrierAIDC Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** UDI Machine Readable Barcode String
   * - **Definition:** The full UDI carrier of the Automatic Identification and Data Capture (AIDC) technology representation of the barcode string as printed on the packaging of the device - e.g., a barcode or RFID.   Because of limitations on character sets in XML and the need to round-trip JSON data through XML, AIDC Formats *SHALL* be base64 encoded.
   * - **Comment:** The AIDC form of UDIs should be scanned or otherwise used for the identification of the device whenever possible to minimize errors in records resulting from manual transcriptions. If separate barcodes for DI and PI are present, concatenate the string with DI first and in order of human readable expression on label.
   * - **FHIR Type:** \`base64Binary\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private carrierAIDC?: Base64BinaryType | undefined;

  /**
   * Device.udiCarrier.carrierHRF Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** UDI Human Readable Barcode String
   * - **Definition:** The full UDI carrier as the human readable form (HRF) representation of the barcode string as printed on the packaging of the device.
   * - **Comment:** If separate barcodes for DI and PI are present, concatenate the string with DI first and in order of human readable expression on label.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private carrierHRF?: StringType | undefined;

  /**
   * FHIR CodeSystem: UdiEntryType
   *
   * @see {@link UdiEntryTypeEnum }
   */
  private readonly udiEntryTypeEnum: UdiEntryTypeEnum;

  /**
   * Device.udiCarrier.entryType Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** barcode | rfid | manual +
   * - **Definition:** A coded entry to indicate how the data was entered.
   * - **Requirements:** Supports a way to distinguish hand entered from machine read data.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   *
   * @see CodeSystem Enumeration: {@link UdiEntryTypeEnum }
   */
  private entryType?: EnumCodeType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`deviceIdentifier\` property value as a StringType object if defined; else an empty StringType object
   */
  public getDeviceIdentifierElement(): StringType {
    return this.deviceIdentifier ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`deviceIdentifier\` property.
   *
   * @param element - the \`deviceIdentifier\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDeviceIdentifierElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Device.udiCarrier.deviceIdentifier; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.deviceIdentifier = element;
    } else {
      this.deviceIdentifier = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`deviceIdentifier\` property exists and has a value; \`false\` otherwise
   */
  public hasDeviceIdentifierElement(): boolean {
    return isDefined<StringType>(this.deviceIdentifier) && !this.deviceIdentifier.isEmpty();
  }

  /**
   * @returns the \`deviceIdentifier\` property value as a fhirString if defined; else undefined
   */
  public getDeviceIdentifier(): fhirString | undefined {
    return this.deviceIdentifier?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`deviceIdentifier\` property.
   *
   * @param value - the \`deviceIdentifier\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDeviceIdentifier(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Device.udiCarrier.deviceIdentifier (\${String(value)})\`;
      this.deviceIdentifier = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.deviceIdentifier = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`deviceIdentifier\` property exists and has a value; \`false\` otherwise
   */
  public hasDeviceIdentifier(): boolean {
    return this.hasDeviceIdentifierElement();
  }

  /**
   * @returns the \`issuer\` property value as a UriType object if defined; else an empty UriType object
   */
  public getIssuerElement(): UriType {
    return this.issuer ?? new UriType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`issuer\` property.
   *
   * @param element - the \`issuer\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setIssuerElement(element: UriType | undefined): this {
    if (isDefined<UriType>(element)) {
      const optErrMsg = \`Invalid Device.udiCarrier.issuer; Provided element is not an instance of UriType.\`;
      assertFhirType<UriType>(element, UriType, optErrMsg);
      this.issuer = element;
    } else {
      this.issuer = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`issuer\` property exists and has a value; \`false\` otherwise
   */
  public hasIssuerElement(): boolean {
    return isDefined<UriType>(this.issuer) && !this.issuer.isEmpty();
  }

  /**
   * @returns the \`issuer\` property value as a fhirUri if defined; else undefined
   */
  public getIssuer(): fhirUri | undefined {
    return this.issuer?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`issuer\` property.
   *
   * @param value - the \`issuer\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setIssuer(value: fhirUri | undefined): this {
    if (isDefined<fhirUri>(value)) {
      const optErrMsg = \`Invalid Device.udiCarrier.issuer (\${String(value)})\`;
      this.issuer = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    } else {
      this.issuer = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`issuer\` property exists and has a value; \`false\` otherwise
   */
  public hasIssuer(): boolean {
    return this.hasIssuerElement();
  }

  /**
   * @returns the \`jurisdiction\` property value as a UriType object if defined; else an empty UriType object
   */
  public getJurisdictionElement(): UriType {
    return this.jurisdiction ?? new UriType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`jurisdiction\` property.
   *
   * @param element - the \`jurisdiction\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setJurisdictionElement(element: UriType | undefined): this {
    if (isDefined<UriType>(element)) {
      const optErrMsg = \`Invalid Device.udiCarrier.jurisdiction; Provided element is not an instance of UriType.\`;
      assertFhirType<UriType>(element, UriType, optErrMsg);
      this.jurisdiction = element;
    } else {
      this.jurisdiction = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`jurisdiction\` property exists and has a value; \`false\` otherwise
   */
  public hasJurisdictionElement(): boolean {
    return isDefined<UriType>(this.jurisdiction) && !this.jurisdiction.isEmpty();
  }

  /**
   * @returns the \`jurisdiction\` property value as a fhirUri if defined; else undefined
   */
  public getJurisdiction(): fhirUri | undefined {
    return this.jurisdiction?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`jurisdiction\` property.
   *
   * @param value - the \`jurisdiction\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setJurisdiction(value: fhirUri | undefined): this {
    if (isDefined<fhirUri>(value)) {
      const optErrMsg = \`Invalid Device.udiCarrier.jurisdiction (\${String(value)})\`;
      this.jurisdiction = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    } else {
      this.jurisdiction = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`jurisdiction\` property exists and has a value; \`false\` otherwise
   */
  public hasJurisdiction(): boolean {
    return this.hasJurisdictionElement();
  }

  /**
   * @returns the \`carrierAIDC\` property value as a Base64BinaryType object if defined; else an empty Base64BinaryType object
   */
  public getCarrierAIDCElement(): Base64BinaryType {
    return this.carrierAIDC ?? new Base64BinaryType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`carrierAIDC\` property.
   *
   * @param element - the \`carrierAIDC\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCarrierAIDCElement(element: Base64BinaryType | undefined): this {
    if (isDefined<Base64BinaryType>(element)) {
      const optErrMsg = \`Invalid Device.udiCarrier.carrierAIDC; Provided element is not an instance of Base64BinaryType.\`;
      assertFhirType<Base64BinaryType>(element, Base64BinaryType, optErrMsg);
      this.carrierAIDC = element;
    } else {
      this.carrierAIDC = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`carrierAIDC\` property exists and has a value; \`false\` otherwise
   */
  public hasCarrierAIDCElement(): boolean {
    return isDefined<Base64BinaryType>(this.carrierAIDC) && !this.carrierAIDC.isEmpty();
  }

  /**
   * @returns the \`carrierAIDC\` property value as a fhirBase64Binary if defined; else undefined
   */
  public getCarrierAIDC(): fhirBase64Binary | undefined {
    return this.carrierAIDC?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`carrierAIDC\` property.
   *
   * @param value - the \`carrierAIDC\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCarrierAIDC(value: fhirBase64Binary | undefined): this {
    if (isDefined<fhirBase64Binary>(value)) {
      const optErrMsg = \`Invalid Device.udiCarrier.carrierAIDC (\${String(value)})\`;
      this.carrierAIDC = new Base64BinaryType(parseFhirPrimitiveData(value, fhirBase64BinarySchema, optErrMsg));
    } else {
      this.carrierAIDC = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`carrierAIDC\` property exists and has a value; \`false\` otherwise
   */
  public hasCarrierAIDC(): boolean {
    return this.hasCarrierAIDCElement();
  }

  /**
   * @returns the \`carrierHRF\` property value as a StringType object if defined; else an empty StringType object
   */
  public getCarrierHRFElement(): StringType {
    return this.carrierHRF ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`carrierHRF\` property.
   *
   * @param element - the \`carrierHRF\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCarrierHRFElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Device.udiCarrier.carrierHRF; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.carrierHRF = element;
    } else {
      this.carrierHRF = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`carrierHRF\` property exists and has a value; \`false\` otherwise
   */
  public hasCarrierHRFElement(): boolean {
    return isDefined<StringType>(this.carrierHRF) && !this.carrierHRF.isEmpty();
  }

  /**
   * @returns the \`carrierHRF\` property value as a fhirString if defined; else undefined
   */
  public getCarrierHRF(): fhirString | undefined {
    return this.carrierHRF?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`carrierHRF\` property.
   *
   * @param value - the \`carrierHRF\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCarrierHRF(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Device.udiCarrier.carrierHRF (\${String(value)})\`;
      this.carrierHRF = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.carrierHRF = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`carrierHRF\` property exists and has a value; \`false\` otherwise
   */
  public hasCarrierHRF(): boolean {
    return this.hasCarrierHRFElement();
  }

  /**
   * @returns the \`entryType\` property value as a EnumCodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link UdiEntryTypeEnum }
   */
  public getEntryTypeEnumType(): EnumCodeType | undefined {
    return this.entryType;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`entryType\` property.
   *
   * @param enumType - the \`entryType\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code values
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link UdiEntryTypeEnum }
   */
  public setEntryTypeEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid Device.udiCarrier.entryType';
      assertEnumCodeType<UdiEntryTypeEnum>(enumType, UdiEntryTypeEnum, errMsgPrefix);
      this.entryType = enumType;
    } else {
      this.entryType = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`entryType\` property exists and has a value; \`false\` otherwise
   */
  public hasEntryTypeEnumType(): boolean {
    return isDefined<EnumCodeType>(this.entryType) && !this.entryType.isEmpty() && this.entryType.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`entryType\` property value as a CodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link UdiEntryTypeEnum }
   */
  public getEntryTypeElement(): CodeType | undefined {
    if (this.entryType === undefined) {
      return undefined;
    }
    return this.entryType as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`entryType\` property.
   *
   * @param element - the \`entryType\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link UdiEntryTypeEnum }
   */
  public setEntryTypeElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Device.udiCarrier.entryType; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.entryType = new EnumCodeType(element, this.udiEntryTypeEnum);
    } else {
      this.entryType = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`entryType\` property exists and has a value; \`false\` otherwise
   */
  public hasEntryTypeElement(): boolean {
    return this.hasEntryTypeEnumType();
  }

  /**
   * @returns the \`entryType\` property value as a fhirCode if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link UdiEntryTypeEnum }
   */
  public getEntryType(): fhirCode | undefined {
    if (this.entryType === undefined) {
      return undefined;
    }
    return this.entryType.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`entryType\` property.
   *
   * @param value - the \`entryType\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link UdiEntryTypeEnum }
   */
  public setEntryType(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Device.udiCarrier.entryType; Provided value is not an instance of fhirCode.\`;
      this.entryType = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.udiEntryTypeEnum);
    } else {
      this.entryType = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`entryType\` property exists and has a value; \`false\` otherwise
   */
  public hasEntryType(): boolean {
    return this.hasEntryTypeEnumType();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Device.udiCarrier';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.deviceIdentifier,
      this.issuer,
      this.jurisdiction,
      this.carrierAIDC,
      this.carrierHRF,
      this.entryType,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): DeviceUdiCarrierComponent {
    const dest = new DeviceUdiCarrierComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: DeviceUdiCarrierComponent): void {
    super.copyValues(dest);
    dest.deviceIdentifier = this.deviceIdentifier?.copy();
    dest.issuer = this.issuer?.copy();
    dest.jurisdiction = this.jurisdiction?.copy();
    dest.carrierAIDC = this.carrierAIDC?.copy();
    dest.carrierHRF = this.carrierHRF?.copy();
    dest.entryType = this.entryType?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasDeviceIdentifierElement()) {
      setFhirPrimitiveJson<fhirString>(this.getDeviceIdentifierElement(), 'deviceIdentifier', jsonObj);
    }

    if (this.hasIssuerElement()) {
      setFhirPrimitiveJson<fhirUri>(this.getIssuerElement(), 'issuer', jsonObj);
    }

    if (this.hasJurisdictionElement()) {
      setFhirPrimitiveJson<fhirUri>(this.getJurisdictionElement(), 'jurisdiction', jsonObj);
    }

    if (this.hasCarrierAIDCElement()) {
      setFhirPrimitiveJson<fhirBase64Binary>(this.getCarrierAIDCElement(), 'carrierAIDC', jsonObj);
    }

    if (this.hasCarrierHRFElement()) {
      setFhirPrimitiveJson<fhirString>(this.getCarrierHRFElement(), 'carrierHRF', jsonObj);
    }

    if (this.hasEntryTypeElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getEntryTypeElement()!, 'entryType', jsonObj);
    }

    return jsonObj;
  }
}
/**
 * DeviceDeviceNameComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** The name of the device as given by the manufacturer
 * - **Definition:** This represents the manufacturer\\'s name of the device as provided by the device, from a UDI label, or by a person describing the Device.  This typically would be used when a person provides the name(s) or when the device represents one of the names available from DeviceDefinition.
 *
 * @category Data Models: Resource
 * @see [FHIR Device](http://hl7.org/fhir/StructureDefinition/Device)
 */
export class DeviceDeviceNameComponent extends BackboneElement implements IBackboneElement {
  constructor(name: StringType | fhirString | null = null, type_: EnumCodeType | CodeType | fhirCode | null = null) {
    super();

    this.deviceNametypeEnum = new DeviceNametypeEnum();

    this.name = null;
    if (isDefined<StringType | fhirString>(name)) {
      if (name instanceof PrimitiveType) {
        this.setNameElement(name);
      } else {
        this.setName(name);
      }
    }

    this.type_ = constructorCodeValueAsEnumCodeType<DeviceNametypeEnum>(
      type_,
      DeviceNametypeEnum,
      this.deviceNametypeEnum,
      'Device.deviceName.type',
    );
  }

  /**
   * Parse the provided \`DeviceDeviceNameComponent\` JSON to instantiate the DeviceDeviceNameComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`DeviceDeviceNameComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to DeviceDeviceNameComponent
   * @returns DeviceDeviceNameComponent data model or undefined for \`DeviceDeviceNameComponent\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): DeviceDeviceNameComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'DeviceDeviceNameComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new DeviceDeviceNameComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'name';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setNameElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'type';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setTypeElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Device.deviceName.name Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The name of the device
   * - **Definition:** The name of the device.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private name: StringType | null;

  /**
   * FHIR CodeSystem: DeviceNametype
   *
   * @see {@link DeviceNametypeEnum }
   */
  private readonly deviceNametypeEnum: DeviceNametypeEnum;

  /**
   * Device.deviceName.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** udi-label-name | user-friendly-name | patient-reported-name | manufacturer-name | model-name | other
   * - **Definition:** The type of deviceName. UDILabelName | UserFriendlyName | PatientReportedName | ManufactureDeviceName | ModelName.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** false
   *
   * @see CodeSystem Enumeration: {@link DeviceNametypeEnum }
   */
  private type_: EnumCodeType | null;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`name\` property value as a StringType object if defined; else null
   */
  public getNameElement(): StringType | null {
    return this.name;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`name\` property.
   *
   * @param element - the \`name\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setNameElement(element: StringType): this {
    assertIsDefined<StringType>(element, \`Device.deviceName.name is required\`);
    const optErrMsg = \`Invalid Device.deviceName.name; Provided value is not an instance of StringType.\`;
    assertFhirType<StringType>(element, StringType, optErrMsg);
    this.name = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`name\` property exists and has a value; \`false\` otherwise
   */
  public hasNameElement(): boolean {
    return isDefined<StringType>(this.name) && !this.name.isEmpty();
  }

  /**
   * @returns the \`name\` property value as a fhirString if defined; else null
   */
  public getName(): fhirString | null {
    if (this.name?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.name.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`name\` property.
   *
   * @param value - the \`name\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setName(value: fhirString): this {
    assertIsDefined<fhirString>(value, \`Device.deviceName.name is required\`);
    const optErrMsg = \`Invalid Device.deviceName.name (\${String(value)})\`;
    this.name = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`name\` property exists and has a value; \`false\` otherwise
   */
  public hasName(): boolean {
    return this.hasNameElement();
  }

  /**
   * @returns the \`type_\` property value as a EnumCodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link DeviceNametypeEnum }
   */
  public getTypeEnumType(): EnumCodeType | null {
    return this.type_;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`type_\` property.
   *
   * @param enumType - the \`type_\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link DeviceNametypeEnum }
   */
  public setTypeEnumType(enumType: EnumCodeType): this {
    assertIsDefined<EnumCodeType>(enumType, \`Device.deviceName.type is required\`);
    const errMsgPrefix = \`Invalid Device.deviceName.type\`;
    assertEnumCodeType<DeviceNametypeEnum>(enumType, DeviceNametypeEnum, errMsgPrefix);
    this.type_ = enumType;
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasTypeEnumType(): boolean {
    return isDefined<EnumCodeType>(this.type_) && !this.type_.isEmpty() && this.type_.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`type_\` property value as a CodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link DeviceNametypeEnum }
   */
  public getTypeElement(): CodeType | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_ as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`type_\` property.
   *
   * @param element - the \`type_\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link DeviceNametypeEnum }
   */
  public setTypeElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, \`Device.deviceName.type is required\`);
    const optErrMsg = \`Invalid Device.deviceName.type; Provided value is not an instance of CodeType.\`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.type_ = new EnumCodeType(element, this.deviceNametypeEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasTypeElement(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the \`type_\` property value as a fhirCode if defined; else null
   *
   * @see CodeSystem Enumeration: {@link DeviceNametypeEnum }
   */
  public getType(): fhirCode | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`type_\` property.
   *
   * @param value - the \`type_\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link DeviceNametypeEnum }
   */
  public setType(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, \`Device.deviceName.type is required\`);
    const optErrMsg = \`Invalid Device.deviceName.type (\${String(value)})\`;
    this.type_ = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.deviceNametypeEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasType(): boolean {
    return this.hasTypeEnumType();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Device.deviceName';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.name,
      this.type_,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): DeviceDeviceNameComponent {
    const dest = new DeviceDeviceNameComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: DeviceDeviceNameComponent): void {
    super.copyValues(dest);
    dest.name = this.name ? this.name.copy() : null;
    dest.type_ = this.type_ ? this.type_.copy() : null;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasNameElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirString>(this.getNameElement()!, 'name', jsonObj);
    } else {
      missingReqdProperties.push(\`Device.deviceName.name\`);
    }

    if (this.hasTypeElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getTypeElement()!, 'type', jsonObj);
    } else {
      missingReqdProperties.push(\`Device.deviceName.type\`);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
/**
 * DeviceSpecializationComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** The capabilities supported on a  device, the standards to which the device conforms for a particular purpose, and used for the communication
 * - **Definition:** The capabilities supported on a  device, the standards to which the device conforms for a particular purpose, and used for the communication.
 *
 * @category Data Models: Resource
 * @see [FHIR Device](http://hl7.org/fhir/StructureDefinition/Device)
 */
export class DeviceSpecializationComponent extends BackboneElement implements IBackboneElement {
  constructor(systemType: CodeableConcept | null = null) {
    super();

    this.systemType = null;
    if (isDefined<CodeableConcept>(systemType)) {
      this.setSystemType(systemType);
    }
  }

  /**
   * Parse the provided \`DeviceSpecializationComponent\` JSON to instantiate the DeviceSpecializationComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`DeviceSpecializationComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to DeviceSpecializationComponent
   * @returns DeviceSpecializationComponent data model or undefined for \`DeviceSpecializationComponent\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): DeviceSpecializationComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'DeviceSpecializationComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new DeviceSpecializationComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    

    const missingReqdProperties: string[] = [];

    fieldName = 'systemType';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = CodeableConcept.parse(classJsonObj[fieldName]!, sourceField);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setSystemType(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'version';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setVersionElement(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Device.specialization.systemType Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The standard that is used to operate and communicate
   * - **Definition:** The standard that is used to operate and communicate.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private systemType: CodeableConcept | null;

  /**
   * Device.specialization.version Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The version of the standard that is used to operate and communicate
   * - **Definition:** The version of the standard that is used to operate and communicate.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private version?: StringType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`systemType\` property value as a CodeableConcept object if defined; else null
   */
  public getSystemType(): CodeableConcept | null {
    return this.systemType;
  }

  /**
   * Assigns the provided CodeableConcept object value to the \`systemType\` property.
   *
   * @param value - the \`systemType\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setSystemType(value: CodeableConcept): this {
    assertIsDefined<CodeableConcept>(value, \`Device.specialization.systemType is required\`);
    const optErrMsg = \`Invalid Device.specialization.systemType; Provided element is not an instance of CodeableConcept.\`;
    assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
    this.systemType = value;
    return this;
  }

  /**
   * @returns \`true\` if the \`systemType\` property exists and has a value; \`false\` otherwise
   */
  public hasSystemType(): boolean {
    return isDefined<CodeableConcept>(this.systemType) && !this.systemType.isEmpty();
  }

  /**
   * @returns the \`version\` property value as a StringType object if defined; else an empty StringType object
   */
  public getVersionElement(): StringType {
    return this.version ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`version\` property.
   *
   * @param element - the \`version\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setVersionElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Device.specialization.version; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.version = element;
    } else {
      this.version = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`version\` property exists and has a value; \`false\` otherwise
   */
  public hasVersionElement(): boolean {
    return isDefined<StringType>(this.version) && !this.version.isEmpty();
  }

  /**
   * @returns the \`version\` property value as a fhirString if defined; else undefined
   */
  public getVersion(): fhirString | undefined {
    return this.version?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`version\` property.
   *
   * @param value - the \`version\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setVersion(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Device.specialization.version (\${String(value)})\`;
      this.version = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.version = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`version\` property exists and has a value; \`false\` otherwise
   */
  public hasVersion(): boolean {
    return this.hasVersionElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Device.specialization';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.systemType,
      this.version,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): DeviceSpecializationComponent {
    const dest = new DeviceSpecializationComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: DeviceSpecializationComponent): void {
    super.copyValues(dest);
    dest.systemType = this.systemType ? this.systemType.copy() : null;
    dest.version = this.version?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasSystemType()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirComplexJson(this.getSystemType()!, 'systemType', jsonObj);
    } else {
      missingReqdProperties.push(\`Device.specialization.systemType\`);
    }

    if (this.hasVersionElement()) {
      setFhirPrimitiveJson<fhirString>(this.getVersionElement(), 'version', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
/**
 * DeviceVersionComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** The actual design of the device or software version running on the device
 * - **Definition:** The actual design of the device or software version running on the device.
 *
 * @category Data Models: Resource
 * @see [FHIR Device](http://hl7.org/fhir/StructureDefinition/Device)
 */
export class DeviceVersionComponent extends BackboneElement implements IBackboneElement {
  constructor(value: StringType | fhirString | null = null) {
    super();

    this.value = null;
    if (isDefined<StringType | fhirString>(value)) {
      if (value instanceof PrimitiveType) {
        this.setValueElement(value);
      } else {
        this.setValue(value);
      }
    }
  }

  /**
   * Parse the provided \`DeviceVersionComponent\` JSON to instantiate the DeviceVersionComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`DeviceVersionComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to DeviceVersionComponent
   * @returns DeviceVersionComponent data model or undefined for \`DeviceVersionComponent\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): DeviceVersionComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'DeviceVersionComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new DeviceVersionComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    

    const missingReqdProperties: string[] = [];

    fieldName = 'type';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = CodeableConcept.parse(classJsonObj[fieldName]!, sourceField);
      instance.setType(datatype);
    }

    fieldName = 'component';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Identifier | undefined = Identifier.parse(classJsonObj[fieldName]!, sourceField);
      instance.setComponent(datatype);
    }

    fieldName = 'value';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setValueElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Device.version.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The type of the device version
   * - **Definition:** The type of the device version.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private type_?: CodeableConcept | undefined;

  /**
   * Device.version.component Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A single component of the device version
   * - **Definition:** A single component of the device version.
   * - **FHIR Type:** \`Identifier\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private component?: Identifier | undefined;

  /**
   * Device.version.value Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The version text
   * - **Definition:** The version text.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private value: StringType | null;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`type_\` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getType(): CodeableConcept {
    return this.type_ ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Type object value to the \`type_\` property.
   *
   * @param value - the \`type_\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setType(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Device.version.type; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.type_ = value;
    } else {
      this.type_ = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasType(): boolean {
    return isDefined<CodeableConcept>(this.type_) && !this.type_.isEmpty();
  }

  /**
   * @returns the \`component\` property value as a Identifier object if defined; else an empty Identifier object
   */
  public getComponent(): Identifier {
    return this.component ?? new Identifier();
  }

  /**
   * Assigns the provided Component object value to the \`component\` property.
   *
   * @param value - the \`component\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setComponent(value: Identifier | undefined): this {
    if (isDefined<Identifier>(value)) {
      const optErrMsg = \`Invalid Device.version.component; Provided element is not an instance of Identifier.\`;
      assertFhirType<Identifier>(value, Identifier, optErrMsg);
      this.component = value;
    } else {
      this.component = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`component\` property exists and has a value; \`false\` otherwise
   */
  public hasComponent(): boolean {
    return isDefined<Identifier>(this.component) && !this.component.isEmpty();
  }

  /**
   * @returns the \`value\` property value as a StringType object if defined; else null
   */
  public getValueElement(): StringType | null {
    return this.value;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`value\` property.
   *
   * @param element - the \`value\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValueElement(element: StringType): this {
    assertIsDefined<StringType>(element, \`Device.version.value is required\`);
    const optErrMsg = \`Invalid Device.version.value; Provided value is not an instance of StringType.\`;
    assertFhirType<StringType>(element, StringType, optErrMsg);
    this.value = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`value\` property exists and has a value; \`false\` otherwise
   */
  public hasValueElement(): boolean {
    return isDefined<StringType>(this.value) && !this.value.isEmpty();
  }

  /**
   * @returns the \`value\` property value as a fhirString if defined; else null
   */
  public getValue(): fhirString | null {
    if (this.value?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.value.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`value\` property.
   *
   * @param value - the \`value\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValue(value: fhirString): this {
    assertIsDefined<fhirString>(value, \`Device.version.value is required\`);
    const optErrMsg = \`Invalid Device.version.value (\${String(value)})\`;
    this.value = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`value\` property exists and has a value; \`false\` otherwise
   */
  public hasValue(): boolean {
    return this.hasValueElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Device.version';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.type_,
      this.component,
      this.value,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): DeviceVersionComponent {
    const dest = new DeviceVersionComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: DeviceVersionComponent): void {
    super.copyValues(dest);
    dest.type_ = this.type_?.copy();
    dest.component = this.component?.copy();
    dest.value = this.value ? this.value.copy() : null;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasType()) {
      setFhirComplexJson(this.getType(), 'type', jsonObj);
    }

    if (this.hasComponent()) {
      setFhirComplexJson(this.getComponent(), 'component', jsonObj);
    }

    if (this.hasValueElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirString>(this.getValueElement()!, 'value', jsonObj);
    } else {
      missingReqdProperties.push(\`Device.version.value\`);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
/**
 * DevicePropertyComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** The actual configuration settings of a device as it actually operates, e.g., regulation status, time properties
 * - **Definition:** The actual configuration settings of a device as it actually operates, e.g., regulation status, time properties.
 *
 * @category Data Models: Resource
 * @see [FHIR Device](http://hl7.org/fhir/StructureDefinition/Device)
 */
export class DevicePropertyComponent extends BackboneElement implements IBackboneElement {
  constructor(type_: CodeableConcept | null = null) {
    super();

    this.type_ = null;
    if (isDefined<CodeableConcept>(type_)) {
      this.setType(type_);
    }
  }

  /**
   * Parse the provided \`DevicePropertyComponent\` JSON to instantiate the DevicePropertyComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`DevicePropertyComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to DevicePropertyComponent
   * @returns DevicePropertyComponent data model or undefined for \`DevicePropertyComponent\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): DevicePropertyComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'DevicePropertyComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new DevicePropertyComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';

    const missingReqdProperties: string[] = [];

    fieldName = 'type';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = CodeableConcept.parse(classJsonObj[fieldName]!, sourceField);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setType(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'valueQuantity';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Quantity | undefined = Quantity.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addValueQuantity(datatype);
        }
      });
    }

    fieldName = 'valueCode';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: CodeableConcept | undefined = CodeableConcept.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addValueCode(datatype);
        }
      });
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Device.property.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Code that specifies the property DeviceDefinitionPropetyCode (Extensible)
   * - **Definition:** Code that specifies the property DeviceDefinitionPropetyCode (Extensible).
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private type_: CodeableConcept | null;

  /**
   * Device.property.valueQuantity Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Property value as a quantity
   * - **Definition:** Property value as a quantity.
   * - **FHIR Type:** \`Quantity\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private valueQuantity?: Quantity[] | undefined;

  /**
   * Device.property.valueCode Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Property value as a code, e.g., NTP4 (synced to NTP)
   * - **Definition:** Property value as a code, e.g., NTP4 (synced to NTP).
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private valueCode?: CodeableConcept[] | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`type_\` property value as a CodeableConcept object if defined; else null
   */
  public getType(): CodeableConcept | null {
    return this.type_;
  }

  /**
   * Assigns the provided CodeableConcept object value to the \`type_\` property.
   *
   * @param value - the \`type_\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setType(value: CodeableConcept): this {
    assertIsDefined<CodeableConcept>(value, \`Device.property.type is required\`);
    const optErrMsg = \`Invalid Device.property.type; Provided element is not an instance of CodeableConcept.\`;
    assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
    this.type_ = value;
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasType(): boolean {
    return isDefined<CodeableConcept>(this.type_) && !this.type_.isEmpty();
  }

  /**
   * @returns the \`valueQuantity\` property value as a Quantity array
   */
  public getValueQuantity(): Quantity[] {
    return this.valueQuantity ?? ([] as Quantity[]);
  }

  /**
   * Assigns the provided Quantity array value to the \`valueQuantity\` property.
   *
   * @param value - the \`valueQuantity\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setValueQuantity(value: Quantity[] | undefined): this {
    if (isDefinedList<Quantity>(value)) {
      const optErrMsg = \`Invalid Device.property.valueQuantity; Provided value array has an element that is not an instance of Quantity.\`;
      assertFhirTypeList<Quantity>(value, Quantity, optErrMsg);
      this.valueQuantity = value;
    } else {
      this.valueQuantity = undefined;
    }
    return this;
  }

  /**
   * Add the provided Quantity value to the \`valueQuantity\` array property.
   *
   * @param value - the \`valueQuantity\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addValueQuantity(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = \`Invalid Device.property.valueQuantity; Provided element is not an instance of Quantity.\`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.initValueQuantity();
      this.valueQuantity?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`valueQuantity\` property exists and has a value; \`false\` otherwise
   */
  public hasValueQuantity(): boolean {
    return isDefinedList<Quantity>(this.valueQuantity) && this.valueQuantity.some((item: Quantity) => !item.isEmpty());
  }

  /**
   * Initialize the \`valueQuantity\` property
   */
  private initValueQuantity(): void {
    if(!this.hasValueQuantity()) {
      this.valueQuantity = [] as Quantity[];
    }
  }

  /**
   * @returns the \`valueCode\` property value as a CodeableConcept array
   */
  public getValueCode(): CodeableConcept[] {
    return this.valueCode ?? ([] as CodeableConcept[]);
  }

  /**
   * Assigns the provided CodeableConcept array value to the \`valueCode\` property.
   *
   * @param value - the \`valueCode\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setValueCode(value: CodeableConcept[] | undefined): this {
    if (isDefinedList<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Device.property.valueCode; Provided value array has an element that is not an instance of CodeableConcept.\`;
      assertFhirTypeList<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.valueCode = value;
    } else {
      this.valueCode = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeableConcept value to the \`valueCode\` array property.
   *
   * @param value - the \`valueCode\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addValueCode(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Device.property.valueCode; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.initValueCode();
      this.valueCode?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`valueCode\` property exists and has a value; \`false\` otherwise
   */
  public hasValueCode(): boolean {
    return isDefinedList<CodeableConcept>(this.valueCode) && this.valueCode.some((item: CodeableConcept) => !item.isEmpty());
  }

  /**
   * Initialize the \`valueCode\` property
   */
  private initValueCode(): void {
    if(!this.hasValueCode()) {
      this.valueCode = [] as CodeableConcept[];
    }
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Device.property';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.type_,
      this.valueQuantity,
      this.valueCode,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): DevicePropertyComponent {
    const dest = new DevicePropertyComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: DevicePropertyComponent): void {
    super.copyValues(dest);
    dest.type_ = this.type_ ? this.type_.copy() : null;
    const valueQuantityList = copyListValues<Quantity>(this.valueQuantity);
    dest.valueQuantity = valueQuantityList.length === 0 ? undefined : valueQuantityList;
    const valueCodeList = copyListValues<CodeableConcept>(this.valueCode);
    dest.valueCode = valueCodeList.length === 0 ? undefined : valueCodeList;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasType()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirComplexJson(this.getType()!, 'type', jsonObj);
    } else {
      missingReqdProperties.push(\`Device.property.type\`);
    }

    if (this.hasValueQuantity()) {
      setFhirComplexListJson(this.getValueQuantity(), 'valueQuantity', jsonObj);
    }

    if (this.hasValueCode()) {
      setFhirComplexListJson(this.getValueCode(), 'valueCode', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
",
  "fileExtension": "ts",
  "filename": "Device",
}
`;

exports[`generator-datamodel-ftest Functional Test Suite generator-app verify generated content should consistently create GeneratedContent[] 32`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/src",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/test/ftest-cache",
    "pkgName": "ftest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "Resource",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * DeviceDefinition Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/DeviceDefinition
 * StructureDefinition.name: DeviceDefinition
 * StructureDefinition.description: The characteristics, operational status and capabilities of a medical-related component of a medical device.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  BackboneElement,
  BooleanType,
  ChoiceDataTypes,
  ChoiceDataTypesMeta,
  CodeType,
  DomainResource,
  EnumCodeType,
  FhirError,
  FhirParser,
  IBackboneElement,
  IDataType,
  IDomainResource,
  INSTANCE_EMPTY_ERROR_MSG,
  InvalidTypeError,
  JSON,
  PrimitiveType,
  PrimitiveTypeJson,
  REQUIRED_PROPERTIES_DO_NOT_EXIST,
  REQUIRED_PROPERTIES_REQD_IN_JSON,
  ReferenceTargets,
  StringType,
  UriType,
  assertEnumCodeType,
  assertFhirType,
  assertFhirTypeList,
  assertIsDefined,
  constructorCodeValueAsEnumCodeType,
  copyListValues,
  fhirBoolean,
  fhirBooleanSchema,
  fhirCode,
  fhirCodeSchema,
  fhirString,
  fhirStringSchema,
  fhirUri,
  fhirUriSchema,
  getPrimitiveTypeJson,
  getPrimitiveTypeListJson,
  isDefined,
  isDefinedList,
  isElementEmpty,
  isEmpty,
  parseFhirPrimitiveData,
  setFhirBackboneElementListJson,
  setFhirComplexJson,
  setFhirComplexListJson,
  setFhirPrimitiveJson,
  setFhirPrimitiveListJson,
  setPolymorphicValueJson,
} from '@paq-ts-fhir/fhir-core';
import { Annotation, CodeableConcept, ContactPoint, Identifier, PARSABLE_DATATYPE_MAP, ProdCharacteristic, ProductShelfLife, Quantity, Reference } from '../complex-types/complex-datatypes';
import { DeviceNametypeEnum } from '../code-systems/DeviceNametypeEnum';
import { PARSABLE_RESOURCE_MAP } from './parsable-resource-map';

// eslint-disable-next-line @typescript-eslint/no-explicit-any -- Symbol.metadata polyfill secret sauce for decorator metadata
(Symbol.metadata as any) ??= Symbol('Symbol.metadata');

/**
 * DeviceDefinition Class
 *
 * @remarks
 * The characteristics, operational status and capabilities of a medical-related component of a medical device.
 *
 * **FHIR Specification**
 * - **Short:** An instance of a medical-related component of a medical device
 * - **Definition:** The characteristics, operational status and capabilities of a medical-related component of a medical device.
 * - **Comment:** For the initial scope, this DeviceDefinition resource is only applicable to describe a single node in the containment tree that is produced by the context scanner in any medical device that implements or derives from the ISO/IEEE 11073 standard and that does not represent a metric. Examples for such a node are MDS, VMD, or Channel.
 * - **FHIR Version:** 4.0.1
 *
 * @category Data Models: Resource
 * @see [FHIR DeviceDefinition](http://hl7.org/fhir/StructureDefinition/DeviceDefinition)
 */
export class DeviceDefinition extends DomainResource implements IDomainResource {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`DeviceDefinition\` JSON to instantiate the DeviceDefinition data model.
   *
   * @param sourceJson - JSON representing FHIR \`DeviceDefinition\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to DeviceDefinition
   * @returns DeviceDefinition data model or undefined for \`DeviceDefinition\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static override parse(sourceJson: JSON.Value, optSourceField?: string): DeviceDefinition | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'DeviceDefinition';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new DeviceDefinition();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.verifyResourceType(classJsonObj, 'DeviceDefinition');
    fhirParser.processDomainResourceJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const classMetadata: DecoratorMetadataObject | null = DeviceDefinition[Symbol.metadata];
    const errorMessage = \`DecoratorMetadataObject does not exist for DeviceDefinition\`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    fieldName = 'identifier';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Identifier | undefined = Identifier.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addIdentifier(datatype);
        }
      });
    }

    fieldName = 'udiDeviceIdentifier';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const componentJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      componentJsonArray.forEach((componentJson: JSON.Value, idx) => {
        const component: DeviceDefinitionUdiDeviceIdentifierComponent | undefined = DeviceDefinitionUdiDeviceIdentifierComponent.parse(componentJson, \`\${sourceField}[\${String(idx)}]\`);
        if (component !== undefined) {
          instance.addUdiDeviceIdentifier(component);
        }
      });
    }

    fieldName = 'manufacturer[x]';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const manufacturer: IDataType | undefined = fhirParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setManufacturer(manufacturer);

    fieldName = 'deviceName';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const componentJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      componentJsonArray.forEach((componentJson: JSON.Value, idx) => {
        const component: DeviceDefinitionDeviceNameComponent | undefined = DeviceDefinitionDeviceNameComponent.parse(componentJson, \`\${sourceField}[\${String(idx)}]\`);
        if (component !== undefined) {
          instance.addDeviceName(component);
        }
      });
    }

    fieldName = 'modelNumber';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setModelNumberElement(datatype);
    }

    fieldName = 'type';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = CodeableConcept.parse(classJsonObj[fieldName]!, sourceField);
      instance.setType(datatype);
    }

    fieldName = 'specialization';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const componentJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      componentJsonArray.forEach((componentJson: JSON.Value, idx) => {
        const component: DeviceDefinitionSpecializationComponent | undefined = DeviceDefinitionSpecializationComponent.parse(componentJson, \`\${sourceField}[\${String(idx)}]\`);
        if (component !== undefined) {
          instance.addSpecialization(component);
        }
      });
    }

    fieldName = 'version';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: StringType | undefined = fhirParser.parseStringType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addVersionElement(datatype);
        }
      });
    }

    fieldName = 'safety';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: CodeableConcept | undefined = CodeableConcept.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addSafety(datatype);
        }
      });
    }

    fieldName = 'shelfLifeStorage';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: ProductShelfLife | undefined = ProductShelfLife.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addShelfLifeStorage(datatype);
        }
      });
    }

    fieldName = 'physicalCharacteristics';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: ProdCharacteristic | undefined = ProdCharacteristic.parse(classJsonObj[fieldName]!, sourceField);
      instance.setPhysicalCharacteristics(datatype);
    }

    fieldName = 'languageCode';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: CodeableConcept | undefined = CodeableConcept.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addLanguageCode(datatype);
        }
      });
    }

    fieldName = 'capability';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const componentJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      componentJsonArray.forEach((componentJson: JSON.Value, idx) => {
        const component: DeviceDefinitionCapabilityComponent | undefined = DeviceDefinitionCapabilityComponent.parse(componentJson, \`\${sourceField}[\${String(idx)}]\`);
        if (component !== undefined) {
          instance.addCapability(component);
        }
      });
    }

    fieldName = 'property';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const componentJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      componentJsonArray.forEach((componentJson: JSON.Value, idx) => {
        const component: DeviceDefinitionPropertyComponent | undefined = DeviceDefinitionPropertyComponent.parse(componentJson, \`\${sourceField}[\${String(idx)}]\`);
        if (component !== undefined) {
          instance.addProperty(component);
        }
      });
    }

    fieldName = 'owner';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = Reference.parse(classJsonObj[fieldName]!, sourceField);
      instance.setOwner(datatype);
    }

    fieldName = 'contact';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: ContactPoint | undefined = ContactPoint.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addContact(datatype);
        }
      });
    }

    fieldName = 'url';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = fhirParser.parseUriType(dtJson, dtSiblingJson);
      instance.setUrlElement(datatype);
    }

    fieldName = 'onlineInformation';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = fhirParser.parseUriType(dtJson, dtSiblingJson);
      instance.setOnlineInformationElement(datatype);
    }

    fieldName = 'note';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Annotation | undefined = Annotation.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addNote(datatype);
        }
      });
    }

    fieldName = 'quantity';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = Quantity.parse(classJsonObj[fieldName]!, sourceField);
      instance.setQuantity(datatype);
    }

    fieldName = 'parentDevice';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = Reference.parse(classJsonObj[fieldName]!, sourceField);
      instance.setParentDevice(datatype);
    }

    fieldName = 'material';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const componentJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      componentJsonArray.forEach((componentJson: JSON.Value, idx) => {
        const component: DeviceDefinitionMaterialComponent | undefined = DeviceDefinitionMaterialComponent.parse(componentJson, \`\${sourceField}[\${String(idx)}]\`);
        if (component !== undefined) {
          instance.addMaterial(component);
        }
      });
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * DeviceDefinition.identifier Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Instance identifier
   * - **Definition:** Unique instance identifiers assigned to a device by the software, manufacturers, other organizations or owners. For example: handle ID.
   * - **FHIR Type:** \`Identifier\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private identifier?: Identifier[] | undefined;

  /**
   * DeviceDefinition.udiDeviceIdentifier Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Unique Device Identifier (UDI) Barcode string
   * - **Definition:** Unique device identifier (UDI) assigned to device label or package.  Note that the Device may include multiple udiCarriers as it either may include just the udiCarrier for the jurisdiction it is sold, or for multiple jurisdictions it could have been sold.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private udiDeviceIdentifier?: DeviceDefinitionUdiDeviceIdentifierComponent[] | undefined;

  /**
   * DeviceDefinition.manufacturer[x] Element
   *
   * @decorator \`@ChoiceDataTypesMeta('DeviceDefinition.manufacturer[x]', ['string','Reference',]\`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Name of device manufacturer
   * - **Definition:** A name of the manufacturer.
   * - **FHIR Types:**
   *     'string',
   *     'Reference',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  @ChoiceDataTypesMeta('DeviceDefinition.manufacturer[x]',[
    'string',
    'Reference',
  ])
  private manufacturer?: IDataType | undefined;

  /**
   * DeviceDefinition.deviceName Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A name given to the device to identify it
   * - **Definition:** A name given to the device to identify it.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private deviceName?: DeviceDefinitionDeviceNameComponent[] | undefined;

  /**
   * DeviceDefinition.modelNumber Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The model number for the device
   * - **Definition:** The model number for the device.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private modelNumber?: StringType | undefined;

  /**
   * DeviceDefinition.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** What kind of device or device system this is
   * - **Definition:** What kind of device or device system this is.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private type_?: CodeableConcept | undefined;

  /**
   * DeviceDefinition.specialization Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The capabilities supported on a  device, the standards to which the device conforms for a particular purpose, and used for the communication
   * - **Definition:** The capabilities supported on a  device, the standards to which the device conforms for a particular purpose, and used for the communication.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private specialization?: DeviceDefinitionSpecializationComponent[] | undefined;

  /**
   * DeviceDefinition.version Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Available versions
   * - **Definition:** The available versions of the device, e.g., software versions.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private version?: StringType[] | undefined;

  /**
   * DeviceDefinition.safety Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Safety characteristics of the device
   * - **Definition:** Safety characteristics of the device.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private safety?: CodeableConcept[] | undefined;

  /**
   * DeviceDefinition.shelfLifeStorage Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Shelf Life and storage information
   * - **Definition:** Shelf Life and storage information.
   * - **FHIR Type:** \`ProductShelfLife\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private shelfLifeStorage?: ProductShelfLife[] | undefined;

  /**
   * DeviceDefinition.physicalCharacteristics Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Dimensions, color etc.
   * - **Definition:** Dimensions, color etc.
   * - **FHIR Type:** \`ProdCharacteristic\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private physicalCharacteristics?: ProdCharacteristic | undefined;

  /**
   * DeviceDefinition.languageCode Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Language code for the human-readable text strings produced by the device (all supported)
   * - **Definition:** Language code for the human-readable text strings produced by the device (all supported).
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private languageCode?: CodeableConcept[] | undefined;

  /**
   * DeviceDefinition.capability Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Device capabilities
   * - **Definition:** Device capabilities.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private capability?: DeviceDefinitionCapabilityComponent[] | undefined;

  /**
   * DeviceDefinition.property Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The actual configuration settings of a device as it actually operates, e.g., regulation status, time properties
   * - **Definition:** The actual configuration settings of a device as it actually operates, e.g., regulation status, time properties.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private property?: DeviceDefinitionPropertyComponent[] | undefined;

  /**
   * DeviceDefinition.owner Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Organization responsible for device
   * - **Definition:** An organization that is responsible for the provision and ongoing maintenance of the device.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Organization',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private owner?: Reference | undefined;

  /**
   * DeviceDefinition.contact Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Details for human/organization for support
   * - **Definition:** Contact details for an organization or a particular human that is responsible for the device.
   * - **Comment:** used for troubleshooting etc.
   * - **FHIR Type:** \`ContactPoint\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private contact?: ContactPoint[] | undefined;

  /**
   * DeviceDefinition.url Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Network address to contact device
   * - **Definition:** A network address on which the device may be contacted directly.
   * - **Comment:** If the device is running a FHIR server, the network address should  be the Base URL from which a conformance statement may be retrieved.
   * - **FHIR Type:** \`uri\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private url?: UriType | undefined;

  /**
   * DeviceDefinition.onlineInformation Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Access to on-line information
   * - **Definition:** Access to on-line information about the device.
   * - **FHIR Type:** \`uri\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private onlineInformation?: UriType | undefined;

  /**
   * DeviceDefinition.note Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Device notes and comments
   * - **Definition:** Descriptive information, usage information or implantation information that is not captured in an existing element.
   * - **FHIR Type:** \`Annotation\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private note?: Annotation[] | undefined;

  /**
   * DeviceDefinition.quantity Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The quantity of the device present in the packaging (e.g. the number of devices present in a pack, or the number of devices in the same package of the medicinal product)
   * - **Definition:** The quantity of the device present in the packaging (e.g. the number of devices present in a pack, or the number of devices in the same package of the medicinal product).
   * - **FHIR Type:** \`Quantity\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private quantity?: Quantity | undefined;

  /**
   * DeviceDefinition.parentDevice Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The parent device it can be part of
   * - **Definition:** The parent device it can be part of.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/DeviceDefinition',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private parentDevice?: Reference | undefined;

  /**
   * DeviceDefinition.material Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A substance used to create the material(s) of which the device is made
   * - **Definition:** A substance used to create the material(s) of which the device is made.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private material?: DeviceDefinitionMaterialComponent[] | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`identifier\` property value as a Identifier array
   */
  public getIdentifier(): Identifier[] {
    return this.identifier ?? ([] as Identifier[]);
  }

  /**
   * Assigns the provided Identifier array value to the \`identifier\` property.
   *
   * @param value - the \`identifier\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setIdentifier(value: Identifier[] | undefined): this {
    if (isDefinedList<Identifier>(value)) {
      const optErrMsg = \`Invalid DeviceDefinition.identifier; Provided value array has an element that is not an instance of Identifier.\`;
      assertFhirTypeList<Identifier>(value, Identifier, optErrMsg);
      this.identifier = value;
    } else {
      this.identifier = undefined;
    }
    return this;
  }

  /**
   * Add the provided Identifier value to the \`identifier\` array property.
   *
   * @param value - the \`identifier\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addIdentifier(value: Identifier | undefined): this {
    if (isDefined<Identifier>(value)) {
      const optErrMsg = \`Invalid DeviceDefinition.identifier; Provided element is not an instance of Identifier.\`;
      assertFhirType<Identifier>(value, Identifier, optErrMsg);
      this.initIdentifier();
      this.identifier?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`identifier\` property exists and has a value; \`false\` otherwise
   */
  public hasIdentifier(): boolean {
    return isDefinedList<Identifier>(this.identifier) && this.identifier.some((item: Identifier) => !item.isEmpty());
  }

  /**
   * Initialize the \`identifier\` property
   */
  private initIdentifier(): void {
    if(!this.hasIdentifier()) {
      this.identifier = [] as Identifier[];
    }
  }

  /**
   * @returns the \`udiDeviceIdentifier\` property value as a DeviceDefinitionUdiDeviceIdentifierComponent array
   */
  public getUdiDeviceIdentifier(): DeviceDefinitionUdiDeviceIdentifierComponent[] {
    return this.udiDeviceIdentifier ?? ([] as DeviceDefinitionUdiDeviceIdentifierComponent[]);
  }

  /**
   * Assigns the provided DeviceDefinitionUdiDeviceIdentifierComponent array value to the \`udiDeviceIdentifier\` property.
   *
   * @param value - the \`udiDeviceIdentifier\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setUdiDeviceIdentifier(value: DeviceDefinitionUdiDeviceIdentifierComponent[] | undefined): this {
    if (isDefinedList<DeviceDefinitionUdiDeviceIdentifierComponent>(value)) {
      const optErrMsg = \`Invalid DeviceDefinition.udiDeviceIdentifier; Provided value array has an element that is not an instance of DeviceDefinitionUdiDeviceIdentifierComponent.\`;
      assertFhirTypeList<DeviceDefinitionUdiDeviceIdentifierComponent>(value, DeviceDefinitionUdiDeviceIdentifierComponent, optErrMsg);
      this.udiDeviceIdentifier = value;
    } else {
      this.udiDeviceIdentifier = undefined;
    }
    return this;
  }

  /**
   * Add the provided DeviceDefinitionUdiDeviceIdentifierComponent value to the \`udiDeviceIdentifier\` array property.
   *
   * @param value - the \`udiDeviceIdentifier\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addUdiDeviceIdentifier(value: DeviceDefinitionUdiDeviceIdentifierComponent | undefined): this {
    if (isDefined<DeviceDefinitionUdiDeviceIdentifierComponent>(value)) {
      const optErrMsg = \`Invalid DeviceDefinition.udiDeviceIdentifier; Provided element is not an instance of DeviceDefinitionUdiDeviceIdentifierComponent.\`;
      assertFhirType<DeviceDefinitionUdiDeviceIdentifierComponent>(value, DeviceDefinitionUdiDeviceIdentifierComponent, optErrMsg);
      this.initUdiDeviceIdentifier();
      this.udiDeviceIdentifier?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`udiDeviceIdentifier\` property exists and has a value; \`false\` otherwise
   */
  public hasUdiDeviceIdentifier(): boolean {
    return isDefinedList<DeviceDefinitionUdiDeviceIdentifierComponent>(this.udiDeviceIdentifier) && this.udiDeviceIdentifier.some((item: DeviceDefinitionUdiDeviceIdentifierComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`udiDeviceIdentifier\` property
   */
  private initUdiDeviceIdentifier(): void {
    if(!this.hasUdiDeviceIdentifier()) {
      this.udiDeviceIdentifier = [] as DeviceDefinitionUdiDeviceIdentifierComponent[];
    }
  }

  /**
   * @returns the \`manufacturer\` property value as a DataType object if defined; else undefined
   */
  public getManufacturer(): IDataType | undefined {
    return this.manufacturer;
  }

  /**
   * Assigns the provided DataType object value to the \`manufacturer\` property.
   *
   * @decorator \`@ChoiceDataTypes('DeviceDefinition.manufacturer[x]')\`
   *
   * @param value - the \`manufacturer\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  @ChoiceDataTypes('DeviceDefinition.manufacturer[x]')
  public setManufacturer(value: IDataType | undefined): this {
    if (isDefined<IDataType>(value)) {
      // assertFhirType<IDataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.manufacturer = value;
    } else {
      this.manufacturer = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`manufacturer\` property exists and has a value; \`false\` otherwise
   */
  public hasManufacturer(): boolean {
    return isDefined<IDataType>(this.manufacturer) && !this.manufacturer.isEmpty();
  }

  // *** NOTE ***
  // Following choice datatype-specific "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the \`manufacturer\` property value as a StringType object if defined; else undefined
   */
  public getManufacturerStringType(): StringType | undefined {
    if (!isDefined<IDataType | undefined>(this.manufacturer)) {
      return undefined;
    }
    if (!(this.manufacturer instanceof StringType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for DeviceDefinition.manufacturer[x]: Expected StringType but encountered \${this.manufacturer.fhirType()}\`,
      );
    }
    return this.manufacturer;
  }

  /**
   * @returns \`true\` if the \`manufacturer\` property exists as a StringType and has a value; \`false\` otherwise
   */
  public hasManufacturerStringType(): boolean {
    return this.hasManufacturer() && this.manufacturer instanceof StringType;
  }

  /**
   * @returns the \`manufacturer\` property value as a Reference object if defined; else undefined
   */
  public getManufacturerReference(): Reference | undefined {
    if (!isDefined<IDataType | undefined>(this.manufacturer)) {
      return undefined;
    }
    if (!(this.manufacturer instanceof Reference)) {
      throw new InvalidTypeError(
        \`DataType mismatch for DeviceDefinition.manufacturer[x]: Expected Reference but encountered \${this.manufacturer.fhirType()}\`,
      );
    }
    return this.manufacturer;
  }

  /**
   * @returns \`true\` if the \`manufacturer\` property exists as a Reference and has a value; \`false\` otherwise
   */
  public hasManufacturerReference(): boolean {
    return this.hasManufacturer() && this.manufacturer instanceof Reference;
  }

  // End of choice datatype-specific "get"/"has" methods

  /**
   * @returns the \`deviceName\` property value as a DeviceDefinitionDeviceNameComponent array
   */
  public getDeviceName(): DeviceDefinitionDeviceNameComponent[] {
    return this.deviceName ?? ([] as DeviceDefinitionDeviceNameComponent[]);
  }

  /**
   * Assigns the provided DeviceDefinitionDeviceNameComponent array value to the \`deviceName\` property.
   *
   * @param value - the \`deviceName\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setDeviceName(value: DeviceDefinitionDeviceNameComponent[] | undefined): this {
    if (isDefinedList<DeviceDefinitionDeviceNameComponent>(value)) {
      const optErrMsg = \`Invalid DeviceDefinition.deviceName; Provided value array has an element that is not an instance of DeviceDefinitionDeviceNameComponent.\`;
      assertFhirTypeList<DeviceDefinitionDeviceNameComponent>(value, DeviceDefinitionDeviceNameComponent, optErrMsg);
      this.deviceName = value;
    } else {
      this.deviceName = undefined;
    }
    return this;
  }

  /**
   * Add the provided DeviceDefinitionDeviceNameComponent value to the \`deviceName\` array property.
   *
   * @param value - the \`deviceName\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addDeviceName(value: DeviceDefinitionDeviceNameComponent | undefined): this {
    if (isDefined<DeviceDefinitionDeviceNameComponent>(value)) {
      const optErrMsg = \`Invalid DeviceDefinition.deviceName; Provided element is not an instance of DeviceDefinitionDeviceNameComponent.\`;
      assertFhirType<DeviceDefinitionDeviceNameComponent>(value, DeviceDefinitionDeviceNameComponent, optErrMsg);
      this.initDeviceName();
      this.deviceName?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`deviceName\` property exists and has a value; \`false\` otherwise
   */
  public hasDeviceName(): boolean {
    return isDefinedList<DeviceDefinitionDeviceNameComponent>(this.deviceName) && this.deviceName.some((item: DeviceDefinitionDeviceNameComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`deviceName\` property
   */
  private initDeviceName(): void {
    if(!this.hasDeviceName()) {
      this.deviceName = [] as DeviceDefinitionDeviceNameComponent[];
    }
  }

  /**
   * @returns the \`modelNumber\` property value as a StringType object if defined; else an empty StringType object
   */
  public getModelNumberElement(): StringType {
    return this.modelNumber ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`modelNumber\` property.
   *
   * @param element - the \`modelNumber\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setModelNumberElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid DeviceDefinition.modelNumber; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.modelNumber = element;
    } else {
      this.modelNumber = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`modelNumber\` property exists and has a value; \`false\` otherwise
   */
  public hasModelNumberElement(): boolean {
    return isDefined<StringType>(this.modelNumber) && !this.modelNumber.isEmpty();
  }

  /**
   * @returns the \`modelNumber\` property value as a fhirString if defined; else undefined
   */
  public getModelNumber(): fhirString | undefined {
    return this.modelNumber?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`modelNumber\` property.
   *
   * @param value - the \`modelNumber\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setModelNumber(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid DeviceDefinition.modelNumber (\${String(value)})\`;
      this.modelNumber = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.modelNumber = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`modelNumber\` property exists and has a value; \`false\` otherwise
   */
  public hasModelNumber(): boolean {
    return this.hasModelNumberElement();
  }

  /**
   * @returns the \`type_\` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getType(): CodeableConcept {
    return this.type_ ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Type object value to the \`type_\` property.
   *
   * @param value - the \`type_\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setType(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid DeviceDefinition.type; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.type_ = value;
    } else {
      this.type_ = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasType(): boolean {
    return isDefined<CodeableConcept>(this.type_) && !this.type_.isEmpty();
  }

  /**
   * @returns the \`specialization\` property value as a DeviceDefinitionSpecializationComponent array
   */
  public getSpecialization(): DeviceDefinitionSpecializationComponent[] {
    return this.specialization ?? ([] as DeviceDefinitionSpecializationComponent[]);
  }

  /**
   * Assigns the provided DeviceDefinitionSpecializationComponent array value to the \`specialization\` property.
   *
   * @param value - the \`specialization\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setSpecialization(value: DeviceDefinitionSpecializationComponent[] | undefined): this {
    if (isDefinedList<DeviceDefinitionSpecializationComponent>(value)) {
      const optErrMsg = \`Invalid DeviceDefinition.specialization; Provided value array has an element that is not an instance of DeviceDefinitionSpecializationComponent.\`;
      assertFhirTypeList<DeviceDefinitionSpecializationComponent>(value, DeviceDefinitionSpecializationComponent, optErrMsg);
      this.specialization = value;
    } else {
      this.specialization = undefined;
    }
    return this;
  }

  /**
   * Add the provided DeviceDefinitionSpecializationComponent value to the \`specialization\` array property.
   *
   * @param value - the \`specialization\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addSpecialization(value: DeviceDefinitionSpecializationComponent | undefined): this {
    if (isDefined<DeviceDefinitionSpecializationComponent>(value)) {
      const optErrMsg = \`Invalid DeviceDefinition.specialization; Provided element is not an instance of DeviceDefinitionSpecializationComponent.\`;
      assertFhirType<DeviceDefinitionSpecializationComponent>(value, DeviceDefinitionSpecializationComponent, optErrMsg);
      this.initSpecialization();
      this.specialization?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`specialization\` property exists and has a value; \`false\` otherwise
   */
  public hasSpecialization(): boolean {
    return isDefinedList<DeviceDefinitionSpecializationComponent>(this.specialization) && this.specialization.some((item: DeviceDefinitionSpecializationComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`specialization\` property
   */
  private initSpecialization(): void {
    if(!this.hasSpecialization()) {
      this.specialization = [] as DeviceDefinitionSpecializationComponent[];
    }
  }

  /**
   * @returns the \`version\` property value as a StringType array
   */
  public getVersionElement(): StringType[] {
    return this.version ?? ([] as StringType[]);
  }

  /**
   * Assigns the provided StringType array value to the \`version\` property.
   *
   * @param element - the \`version\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setVersionElement(element: StringType[] | undefined): this {
    if (isDefinedList<StringType>(element)) {
      const optErrMsg = \`Invalid DeviceDefinition.version; Provided value array has an element that is not an instance of StringType.\`;
      assertFhirTypeList<StringType>(element, StringType, optErrMsg);
      this.version = element;
    } else {
      this.version = undefined;
    }
    return this;
  }

  /**
   * Add the provided StringType value to the \`version\` array property.
   *
   * @param element - the \`version\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addVersionElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid DeviceDefinition.version; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.initVersion();
      this.version?.push(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`version\` property exists and has a value; \`false\` otherwise
   */
  public hasVersionElement(): boolean {
    return isDefinedList<StringType>(this.version) && this.version.some((item: StringType) => !item.isEmpty());
  }

  /**
   * @returns the \`version\` property value as a fhirString array
   */
  public getVersion(): fhirString[] {
    this.initVersion();
    const versionValues = [] as fhirString[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.version!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        versionValues.push(value);
      }
    }
    return versionValues;
  }

  /**
   * Assigns the provided primitive value array to the \`version\` property.
   *
   * @param value - the \`version\` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setVersion(value: fhirString[] | undefined): this {
    if (isDefinedList<fhirString>(value)) {
      const versionElements = [] as StringType[];
      for (const versionValue of value) {
        const optErrMsg = \`Invalid DeviceDefinition.version array item (\${String(versionValue)})\`;
        const element = new StringType(parseFhirPrimitiveData(versionValue, fhirStringSchema, optErrMsg));
        versionElements.push(element);
      }
      this.version = versionElements;
    } else {
      this.version = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`version\` array property.
   *
   * @param value - the \`version\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addVersion(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid DeviceDefinition.version array item (\${String(value)})\`;
      const element = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
      this.initVersion();
      this.addVersionElement(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`version\` property exists and has a value; \`false\` otherwise
   */
  public hasVersion(): boolean {
    return this.hasVersionElement();
  }

  /**
   * Initialize the \`version\` property
   */
  private initVersion(): void {
    if (!this.hasVersion()) {
      this.version = [] as StringType[];
    }
  }

  /**
   * @returns the \`safety\` property value as a CodeableConcept array
   */
  public getSafety(): CodeableConcept[] {
    return this.safety ?? ([] as CodeableConcept[]);
  }

  /**
   * Assigns the provided CodeableConcept array value to the \`safety\` property.
   *
   * @param value - the \`safety\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setSafety(value: CodeableConcept[] | undefined): this {
    if (isDefinedList<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid DeviceDefinition.safety; Provided value array has an element that is not an instance of CodeableConcept.\`;
      assertFhirTypeList<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.safety = value;
    } else {
      this.safety = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeableConcept value to the \`safety\` array property.
   *
   * @param value - the \`safety\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addSafety(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid DeviceDefinition.safety; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.initSafety();
      this.safety?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`safety\` property exists and has a value; \`false\` otherwise
   */
  public hasSafety(): boolean {
    return isDefinedList<CodeableConcept>(this.safety) && this.safety.some((item: CodeableConcept) => !item.isEmpty());
  }

  /**
   * Initialize the \`safety\` property
   */
  private initSafety(): void {
    if(!this.hasSafety()) {
      this.safety = [] as CodeableConcept[];
    }
  }

  /**
   * @returns the \`shelfLifeStorage\` property value as a ProductShelfLife array
   */
  public getShelfLifeStorage(): ProductShelfLife[] {
    return this.shelfLifeStorage ?? ([] as ProductShelfLife[]);
  }

  /**
   * Assigns the provided ProductShelfLife array value to the \`shelfLifeStorage\` property.
   *
   * @param value - the \`shelfLifeStorage\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setShelfLifeStorage(value: ProductShelfLife[] | undefined): this {
    if (isDefinedList<ProductShelfLife>(value)) {
      const optErrMsg = \`Invalid DeviceDefinition.shelfLifeStorage; Provided value array has an element that is not an instance of ProductShelfLife.\`;
      assertFhirTypeList<ProductShelfLife>(value, ProductShelfLife, optErrMsg);
      this.shelfLifeStorage = value;
    } else {
      this.shelfLifeStorage = undefined;
    }
    return this;
  }

  /**
   * Add the provided ProductShelfLife value to the \`shelfLifeStorage\` array property.
   *
   * @param value - the \`shelfLifeStorage\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addShelfLifeStorage(value: ProductShelfLife | undefined): this {
    if (isDefined<ProductShelfLife>(value)) {
      const optErrMsg = \`Invalid DeviceDefinition.shelfLifeStorage; Provided element is not an instance of ProductShelfLife.\`;
      assertFhirType<ProductShelfLife>(value, ProductShelfLife, optErrMsg);
      this.initShelfLifeStorage();
      this.shelfLifeStorage?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`shelfLifeStorage\` property exists and has a value; \`false\` otherwise
   */
  public hasShelfLifeStorage(): boolean {
    return isDefinedList<ProductShelfLife>(this.shelfLifeStorage) && this.shelfLifeStorage.some((item: ProductShelfLife) => !item.isEmpty());
  }

  /**
   * Initialize the \`shelfLifeStorage\` property
   */
  private initShelfLifeStorage(): void {
    if(!this.hasShelfLifeStorage()) {
      this.shelfLifeStorage = [] as ProductShelfLife[];
    }
  }

  /**
   * @returns the \`physicalCharacteristics\` property value as a ProdCharacteristic object if defined; else an empty ProdCharacteristic object
   */
  public getPhysicalCharacteristics(): ProdCharacteristic {
    return this.physicalCharacteristics ?? new ProdCharacteristic();
  }

  /**
   * Assigns the provided PhysicalCharacteristics object value to the \`physicalCharacteristics\` property.
   *
   * @param value - the \`physicalCharacteristics\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setPhysicalCharacteristics(value: ProdCharacteristic | undefined): this {
    if (isDefined<ProdCharacteristic>(value)) {
      const optErrMsg = \`Invalid DeviceDefinition.physicalCharacteristics; Provided element is not an instance of ProdCharacteristic.\`;
      assertFhirType<ProdCharacteristic>(value, ProdCharacteristic, optErrMsg);
      this.physicalCharacteristics = value;
    } else {
      this.physicalCharacteristics = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`physicalCharacteristics\` property exists and has a value; \`false\` otherwise
   */
  public hasPhysicalCharacteristics(): boolean {
    return isDefined<ProdCharacteristic>(this.physicalCharacteristics) && !this.physicalCharacteristics.isEmpty();
  }

  /**
   * @returns the \`languageCode\` property value as a CodeableConcept array
   */
  public getLanguageCode(): CodeableConcept[] {
    return this.languageCode ?? ([] as CodeableConcept[]);
  }

  /**
   * Assigns the provided CodeableConcept array value to the \`languageCode\` property.
   *
   * @param value - the \`languageCode\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setLanguageCode(value: CodeableConcept[] | undefined): this {
    if (isDefinedList<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid DeviceDefinition.languageCode; Provided value array has an element that is not an instance of CodeableConcept.\`;
      assertFhirTypeList<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.languageCode = value;
    } else {
      this.languageCode = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeableConcept value to the \`languageCode\` array property.
   *
   * @param value - the \`languageCode\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addLanguageCode(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid DeviceDefinition.languageCode; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.initLanguageCode();
      this.languageCode?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`languageCode\` property exists and has a value; \`false\` otherwise
   */
  public hasLanguageCode(): boolean {
    return isDefinedList<CodeableConcept>(this.languageCode) && this.languageCode.some((item: CodeableConcept) => !item.isEmpty());
  }

  /**
   * Initialize the \`languageCode\` property
   */
  private initLanguageCode(): void {
    if(!this.hasLanguageCode()) {
      this.languageCode = [] as CodeableConcept[];
    }
  }

  /**
   * @returns the \`capability\` property value as a DeviceDefinitionCapabilityComponent array
   */
  public getCapability(): DeviceDefinitionCapabilityComponent[] {
    return this.capability ?? ([] as DeviceDefinitionCapabilityComponent[]);
  }

  /**
   * Assigns the provided DeviceDefinitionCapabilityComponent array value to the \`capability\` property.
   *
   * @param value - the \`capability\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setCapability(value: DeviceDefinitionCapabilityComponent[] | undefined): this {
    if (isDefinedList<DeviceDefinitionCapabilityComponent>(value)) {
      const optErrMsg = \`Invalid DeviceDefinition.capability; Provided value array has an element that is not an instance of DeviceDefinitionCapabilityComponent.\`;
      assertFhirTypeList<DeviceDefinitionCapabilityComponent>(value, DeviceDefinitionCapabilityComponent, optErrMsg);
      this.capability = value;
    } else {
      this.capability = undefined;
    }
    return this;
  }

  /**
   * Add the provided DeviceDefinitionCapabilityComponent value to the \`capability\` array property.
   *
   * @param value - the \`capability\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addCapability(value: DeviceDefinitionCapabilityComponent | undefined): this {
    if (isDefined<DeviceDefinitionCapabilityComponent>(value)) {
      const optErrMsg = \`Invalid DeviceDefinition.capability; Provided element is not an instance of DeviceDefinitionCapabilityComponent.\`;
      assertFhirType<DeviceDefinitionCapabilityComponent>(value, DeviceDefinitionCapabilityComponent, optErrMsg);
      this.initCapability();
      this.capability?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`capability\` property exists and has a value; \`false\` otherwise
   */
  public hasCapability(): boolean {
    return isDefinedList<DeviceDefinitionCapabilityComponent>(this.capability) && this.capability.some((item: DeviceDefinitionCapabilityComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`capability\` property
   */
  private initCapability(): void {
    if(!this.hasCapability()) {
      this.capability = [] as DeviceDefinitionCapabilityComponent[];
    }
  }

  /**
   * @returns the \`property\` property value as a DeviceDefinitionPropertyComponent array
   */
  public getProperty(): DeviceDefinitionPropertyComponent[] {
    return this.property ?? ([] as DeviceDefinitionPropertyComponent[]);
  }

  /**
   * Assigns the provided DeviceDefinitionPropertyComponent array value to the \`property\` property.
   *
   * @param value - the \`property\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setProperty(value: DeviceDefinitionPropertyComponent[] | undefined): this {
    if (isDefinedList<DeviceDefinitionPropertyComponent>(value)) {
      const optErrMsg = \`Invalid DeviceDefinition.property; Provided value array has an element that is not an instance of DeviceDefinitionPropertyComponent.\`;
      assertFhirTypeList<DeviceDefinitionPropertyComponent>(value, DeviceDefinitionPropertyComponent, optErrMsg);
      this.property = value;
    } else {
      this.property = undefined;
    }
    return this;
  }

  /**
   * Add the provided DeviceDefinitionPropertyComponent value to the \`property\` array property.
   *
   * @param value - the \`property\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addProperty(value: DeviceDefinitionPropertyComponent | undefined): this {
    if (isDefined<DeviceDefinitionPropertyComponent>(value)) {
      const optErrMsg = \`Invalid DeviceDefinition.property; Provided element is not an instance of DeviceDefinitionPropertyComponent.\`;
      assertFhirType<DeviceDefinitionPropertyComponent>(value, DeviceDefinitionPropertyComponent, optErrMsg);
      this.initProperty();
      this.property?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`property\` property exists and has a value; \`false\` otherwise
   */
  public hasProperty(): boolean {
    return isDefinedList<DeviceDefinitionPropertyComponent>(this.property) && this.property.some((item: DeviceDefinitionPropertyComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`property\` property
   */
  private initProperty(): void {
    if(!this.hasProperty()) {
      this.property = [] as DeviceDefinitionPropertyComponent[];
    }
  }

  /**
   * @returns the \`owner\` property value as a Reference object; else an empty Reference object
   */
  public getOwner(): Reference {
    return this.owner ?? new Reference();
  }

  /**
   * Assigns the provided Owner object value to the \`owner\` property.
   *
   * @decorator \`@ReferenceTargets('DeviceDefinition.owner', ['Organization',])\`
   *
   * @param value - the \`owner\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('DeviceDefinition.owner', [
    'Organization',
  ])
  public setOwner(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.owner = value;
    } else {
      this.owner = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`owner\` property exists and has a value; \`false\` otherwise
   */
  public hasOwner(): boolean {
    return isDefined<Reference>(this.owner) && !this.owner.isEmpty();
  }

  /**
   * @returns the \`contact\` property value as a ContactPoint array
   */
  public getContact(): ContactPoint[] {
    return this.contact ?? ([] as ContactPoint[]);
  }

  /**
   * Assigns the provided ContactPoint array value to the \`contact\` property.
   *
   * @param value - the \`contact\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setContact(value: ContactPoint[] | undefined): this {
    if (isDefinedList<ContactPoint>(value)) {
      const optErrMsg = \`Invalid DeviceDefinition.contact; Provided value array has an element that is not an instance of ContactPoint.\`;
      assertFhirTypeList<ContactPoint>(value, ContactPoint, optErrMsg);
      this.contact = value;
    } else {
      this.contact = undefined;
    }
    return this;
  }

  /**
   * Add the provided ContactPoint value to the \`contact\` array property.
   *
   * @param value - the \`contact\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addContact(value: ContactPoint | undefined): this {
    if (isDefined<ContactPoint>(value)) {
      const optErrMsg = \`Invalid DeviceDefinition.contact; Provided element is not an instance of ContactPoint.\`;
      assertFhirType<ContactPoint>(value, ContactPoint, optErrMsg);
      this.initContact();
      this.contact?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`contact\` property exists and has a value; \`false\` otherwise
   */
  public hasContact(): boolean {
    return isDefinedList<ContactPoint>(this.contact) && this.contact.some((item: ContactPoint) => !item.isEmpty());
  }

  /**
   * Initialize the \`contact\` property
   */
  private initContact(): void {
    if(!this.hasContact()) {
      this.contact = [] as ContactPoint[];
    }
  }

  /**
   * @returns the \`url\` property value as a UriType object if defined; else an empty UriType object
   */
  public getUrlElement(): UriType {
    return this.url ?? new UriType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`url\` property.
   *
   * @param element - the \`url\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUrlElement(element: UriType | undefined): this {
    if (isDefined<UriType>(element)) {
      const optErrMsg = \`Invalid DeviceDefinition.url; Provided element is not an instance of UriType.\`;
      assertFhirType<UriType>(element, UriType, optErrMsg);
      this.url = element;
    } else {
      this.url = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`url\` property exists and has a value; \`false\` otherwise
   */
  public hasUrlElement(): boolean {
    return isDefined<UriType>(this.url) && !this.url.isEmpty();
  }

  /**
   * @returns the \`url\` property value as a fhirUri if defined; else undefined
   */
  public getUrl(): fhirUri | undefined {
    return this.url?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`url\` property.
   *
   * @param value - the \`url\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUrl(value: fhirUri | undefined): this {
    if (isDefined<fhirUri>(value)) {
      const optErrMsg = \`Invalid DeviceDefinition.url (\${String(value)})\`;
      this.url = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    } else {
      this.url = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`url\` property exists and has a value; \`false\` otherwise
   */
  public hasUrl(): boolean {
    return this.hasUrlElement();
  }

  /**
   * @returns the \`onlineInformation\` property value as a UriType object if defined; else an empty UriType object
   */
  public getOnlineInformationElement(): UriType {
    return this.onlineInformation ?? new UriType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`onlineInformation\` property.
   *
   * @param element - the \`onlineInformation\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setOnlineInformationElement(element: UriType | undefined): this {
    if (isDefined<UriType>(element)) {
      const optErrMsg = \`Invalid DeviceDefinition.onlineInformation; Provided element is not an instance of UriType.\`;
      assertFhirType<UriType>(element, UriType, optErrMsg);
      this.onlineInformation = element;
    } else {
      this.onlineInformation = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`onlineInformation\` property exists and has a value; \`false\` otherwise
   */
  public hasOnlineInformationElement(): boolean {
    return isDefined<UriType>(this.onlineInformation) && !this.onlineInformation.isEmpty();
  }

  /**
   * @returns the \`onlineInformation\` property value as a fhirUri if defined; else undefined
   */
  public getOnlineInformation(): fhirUri | undefined {
    return this.onlineInformation?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`onlineInformation\` property.
   *
   * @param value - the \`onlineInformation\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setOnlineInformation(value: fhirUri | undefined): this {
    if (isDefined<fhirUri>(value)) {
      const optErrMsg = \`Invalid DeviceDefinition.onlineInformation (\${String(value)})\`;
      this.onlineInformation = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    } else {
      this.onlineInformation = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`onlineInformation\` property exists and has a value; \`false\` otherwise
   */
  public hasOnlineInformation(): boolean {
    return this.hasOnlineInformationElement();
  }

  /**
   * @returns the \`note\` property value as a Annotation array
   */
  public getNote(): Annotation[] {
    return this.note ?? ([] as Annotation[]);
  }

  /**
   * Assigns the provided Annotation array value to the \`note\` property.
   *
   * @param value - the \`note\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setNote(value: Annotation[] | undefined): this {
    if (isDefinedList<Annotation>(value)) {
      const optErrMsg = \`Invalid DeviceDefinition.note; Provided value array has an element that is not an instance of Annotation.\`;
      assertFhirTypeList<Annotation>(value, Annotation, optErrMsg);
      this.note = value;
    } else {
      this.note = undefined;
    }
    return this;
  }

  /**
   * Add the provided Annotation value to the \`note\` array property.
   *
   * @param value - the \`note\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addNote(value: Annotation | undefined): this {
    if (isDefined<Annotation>(value)) {
      const optErrMsg = \`Invalid DeviceDefinition.note; Provided element is not an instance of Annotation.\`;
      assertFhirType<Annotation>(value, Annotation, optErrMsg);
      this.initNote();
      this.note?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`note\` property exists and has a value; \`false\` otherwise
   */
  public hasNote(): boolean {
    return isDefinedList<Annotation>(this.note) && this.note.some((item: Annotation) => !item.isEmpty());
  }

  /**
   * Initialize the \`note\` property
   */
  private initNote(): void {
    if(!this.hasNote()) {
      this.note = [] as Annotation[];
    }
  }

  /**
   * @returns the \`quantity\` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getQuantity(): Quantity {
    return this.quantity ?? new Quantity();
  }

  /**
   * Assigns the provided Quantity object value to the \`quantity\` property.
   *
   * @param value - the \`quantity\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setQuantity(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = \`Invalid DeviceDefinition.quantity; Provided element is not an instance of Quantity.\`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.quantity = value;
    } else {
      this.quantity = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`quantity\` property exists and has a value; \`false\` otherwise
   */
  public hasQuantity(): boolean {
    return isDefined<Quantity>(this.quantity) && !this.quantity.isEmpty();
  }

  /**
   * @returns the \`parentDevice\` property value as a Reference object; else an empty Reference object
   */
  public getParentDevice(): Reference {
    return this.parentDevice ?? new Reference();
  }

  /**
   * Assigns the provided ParentDevice object value to the \`parentDevice\` property.
   *
   * @decorator \`@ReferenceTargets('DeviceDefinition.parentDevice', ['DeviceDefinition',])\`
   *
   * @param value - the \`parentDevice\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('DeviceDefinition.parentDevice', [
    'DeviceDefinition',
  ])
  public setParentDevice(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.parentDevice = value;
    } else {
      this.parentDevice = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`parentDevice\` property exists and has a value; \`false\` otherwise
   */
  public hasParentDevice(): boolean {
    return isDefined<Reference>(this.parentDevice) && !this.parentDevice.isEmpty();
  }

  /**
   * @returns the \`material\` property value as a DeviceDefinitionMaterialComponent array
   */
  public getMaterial(): DeviceDefinitionMaterialComponent[] {
    return this.material ?? ([] as DeviceDefinitionMaterialComponent[]);
  }

  /**
   * Assigns the provided DeviceDefinitionMaterialComponent array value to the \`material\` property.
   *
   * @param value - the \`material\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setMaterial(value: DeviceDefinitionMaterialComponent[] | undefined): this {
    if (isDefinedList<DeviceDefinitionMaterialComponent>(value)) {
      const optErrMsg = \`Invalid DeviceDefinition.material; Provided value array has an element that is not an instance of DeviceDefinitionMaterialComponent.\`;
      assertFhirTypeList<DeviceDefinitionMaterialComponent>(value, DeviceDefinitionMaterialComponent, optErrMsg);
      this.material = value;
    } else {
      this.material = undefined;
    }
    return this;
  }

  /**
   * Add the provided DeviceDefinitionMaterialComponent value to the \`material\` array property.
   *
   * @param value - the \`material\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addMaterial(value: DeviceDefinitionMaterialComponent | undefined): this {
    if (isDefined<DeviceDefinitionMaterialComponent>(value)) {
      const optErrMsg = \`Invalid DeviceDefinition.material; Provided element is not an instance of DeviceDefinitionMaterialComponent.\`;
      assertFhirType<DeviceDefinitionMaterialComponent>(value, DeviceDefinitionMaterialComponent, optErrMsg);
      this.initMaterial();
      this.material?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`material\` property exists and has a value; \`false\` otherwise
   */
  public hasMaterial(): boolean {
    return isDefinedList<DeviceDefinitionMaterialComponent>(this.material) && this.material.some((item: DeviceDefinitionMaterialComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`material\` property
   */
  private initMaterial(): void {
    if(!this.hasMaterial()) {
      this.material = [] as DeviceDefinitionMaterialComponent[];
    }
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'DeviceDefinition';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.identifier,
      this.udiDeviceIdentifier,
      this.manufacturer,
      this.deviceName,
      this.modelNumber,
      this.type_,
      this.specialization,
      this.version,
      this.safety,
      this.shelfLifeStorage,
      this.physicalCharacteristics,
      this.languageCode,
      this.capability,
      this.property,
      this.owner,
      this.contact,
      this.url,
      this.onlineInformation,
      this.note,
      this.quantity,
      this.parentDevice,
      this.material,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): DeviceDefinition {
    const dest = new DeviceDefinition();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: DeviceDefinition): void {
    super.copyValues(dest);
    const identifierList = copyListValues<Identifier>(this.identifier);
    dest.identifier = identifierList.length === 0 ? undefined : identifierList;
    const udiDeviceIdentifierList = copyListValues<DeviceDefinitionUdiDeviceIdentifierComponent>(this.udiDeviceIdentifier);
    dest.udiDeviceIdentifier = udiDeviceIdentifierList.length === 0 ? undefined : udiDeviceIdentifierList;
    dest.manufacturer = this.manufacturer?.copy() as IDataType;
    const deviceNameList = copyListValues<DeviceDefinitionDeviceNameComponent>(this.deviceName);
    dest.deviceName = deviceNameList.length === 0 ? undefined : deviceNameList;
    dest.modelNumber = this.modelNumber?.copy();
    dest.type_ = this.type_?.copy();
    const specializationList = copyListValues<DeviceDefinitionSpecializationComponent>(this.specialization);
    dest.specialization = specializationList.length === 0 ? undefined : specializationList;
    const versionList = copyListValues<StringType>(this.version);
    dest.version = versionList.length === 0 ? undefined : versionList;
    const safetyList = copyListValues<CodeableConcept>(this.safety);
    dest.safety = safetyList.length === 0 ? undefined : safetyList;
    const shelfLifeStorageList = copyListValues<ProductShelfLife>(this.shelfLifeStorage);
    dest.shelfLifeStorage = shelfLifeStorageList.length === 0 ? undefined : shelfLifeStorageList;
    dest.physicalCharacteristics = this.physicalCharacteristics?.copy();
    const languageCodeList = copyListValues<CodeableConcept>(this.languageCode);
    dest.languageCode = languageCodeList.length === 0 ? undefined : languageCodeList;
    const capabilityList = copyListValues<DeviceDefinitionCapabilityComponent>(this.capability);
    dest.capability = capabilityList.length === 0 ? undefined : capabilityList;
    const propertyList = copyListValues<DeviceDefinitionPropertyComponent>(this.property);
    dest.property = propertyList.length === 0 ? undefined : propertyList;
    dest.owner = this.owner?.copy();
    const contactList = copyListValues<ContactPoint>(this.contact);
    dest.contact = contactList.length === 0 ? undefined : contactList;
    dest.url = this.url?.copy();
    dest.onlineInformation = this.onlineInformation?.copy();
    const noteList = copyListValues<Annotation>(this.note);
    dest.note = noteList.length === 0 ? undefined : noteList;
    dest.quantity = this.quantity?.copy();
    dest.parentDevice = this.parentDevice?.copy();
    const materialList = copyListValues<DeviceDefinitionMaterialComponent>(this.material);
    dest.material = materialList.length === 0 ? undefined : materialList;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasIdentifier()) {
      setFhirComplexListJson(this.getIdentifier(), 'identifier', jsonObj);
    }

    if (this.hasUdiDeviceIdentifier()) {
      setFhirBackboneElementListJson(this.getUdiDeviceIdentifier(), 'udiDeviceIdentifier', jsonObj);
    }

    if (this.hasManufacturer()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getManufacturer()!, 'manufacturer', jsonObj);
    }

    if (this.hasDeviceName()) {
      setFhirBackboneElementListJson(this.getDeviceName(), 'deviceName', jsonObj);
    }

    if (this.hasModelNumberElement()) {
      setFhirPrimitiveJson<fhirString>(this.getModelNumberElement(), 'modelNumber', jsonObj);
    }

    if (this.hasType()) {
      setFhirComplexJson(this.getType(), 'type', jsonObj);
    }

    if (this.hasSpecialization()) {
      setFhirBackboneElementListJson(this.getSpecialization(), 'specialization', jsonObj);
    }

    if (this.hasVersion()) {
      setFhirPrimitiveListJson(this.getVersionElement(), 'version', jsonObj);
    }

    if (this.hasSafety()) {
      setFhirComplexListJson(this.getSafety(), 'safety', jsonObj);
    }

    if (this.hasShelfLifeStorage()) {
      setFhirComplexListJson(this.getShelfLifeStorage(), 'shelfLifeStorage', jsonObj);
    }

    if (this.hasPhysicalCharacteristics()) {
      setFhirComplexJson(this.getPhysicalCharacteristics(), 'physicalCharacteristics', jsonObj);
    }

    if (this.hasLanguageCode()) {
      setFhirComplexListJson(this.getLanguageCode(), 'languageCode', jsonObj);
    }

    if (this.hasCapability()) {
      setFhirBackboneElementListJson(this.getCapability(), 'capability', jsonObj);
    }

    if (this.hasProperty()) {
      setFhirBackboneElementListJson(this.getProperty(), 'property', jsonObj);
    }

    if (this.hasOwner()) {
      setFhirComplexJson(this.getOwner(), 'owner', jsonObj);
    }

    if (this.hasContact()) {
      setFhirComplexListJson(this.getContact(), 'contact', jsonObj);
    }

    if (this.hasUrlElement()) {
      setFhirPrimitiveJson<fhirUri>(this.getUrlElement(), 'url', jsonObj);
    }

    if (this.hasOnlineInformationElement()) {
      setFhirPrimitiveJson<fhirUri>(this.getOnlineInformationElement(), 'onlineInformation', jsonObj);
    }

    if (this.hasNote()) {
      setFhirComplexListJson(this.getNote(), 'note', jsonObj);
    }

    if (this.hasQuantity()) {
      setFhirComplexJson(this.getQuantity(), 'quantity', jsonObj);
    }

    if (this.hasParentDevice()) {
      setFhirComplexJson(this.getParentDevice(), 'parentDevice', jsonObj);
    }

    if (this.hasMaterial()) {
      setFhirBackboneElementListJson(this.getMaterial(), 'material', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * DeviceDefinitionUdiDeviceIdentifierComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Unique Device Identifier (UDI) Barcode string
 * - **Definition:** Unique device identifier (UDI) assigned to device label or package.  Note that the Device may include multiple udiCarriers as it either may include just the udiCarrier for the jurisdiction it is sold, or for multiple jurisdictions it could have been sold.
 *
 * @category Data Models: Resource
 * @see [FHIR DeviceDefinition](http://hl7.org/fhir/StructureDefinition/DeviceDefinition)
 */
export class DeviceDefinitionUdiDeviceIdentifierComponent extends BackboneElement implements IBackboneElement {
  constructor(deviceIdentifier: StringType | fhirString | null = null, issuer: UriType | fhirUri | null = null, jurisdiction: UriType | fhirUri | null = null) {
    super();

    this.deviceIdentifier = null;
    if (isDefined<StringType | fhirString>(deviceIdentifier)) {
      if (deviceIdentifier instanceof PrimitiveType) {
        this.setDeviceIdentifierElement(deviceIdentifier);
      } else {
        this.setDeviceIdentifier(deviceIdentifier);
      }
    }

    this.issuer = null;
    if (isDefined<UriType | fhirUri>(issuer)) {
      if (issuer instanceof PrimitiveType) {
        this.setIssuerElement(issuer);
      } else {
        this.setIssuer(issuer);
      }
    }

    this.jurisdiction = null;
    if (isDefined<UriType | fhirUri>(jurisdiction)) {
      if (jurisdiction instanceof PrimitiveType) {
        this.setJurisdictionElement(jurisdiction);
      } else {
        this.setJurisdiction(jurisdiction);
      }
    }
  }

  /**
   * Parse the provided \`DeviceDefinitionUdiDeviceIdentifierComponent\` JSON to instantiate the DeviceDefinitionUdiDeviceIdentifierComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`DeviceDefinitionUdiDeviceIdentifierComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to DeviceDefinitionUdiDeviceIdentifierComponent
   * @returns DeviceDefinitionUdiDeviceIdentifierComponent data model or undefined for \`DeviceDefinitionUdiDeviceIdentifierComponent\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): DeviceDefinitionUdiDeviceIdentifierComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'DeviceDefinitionUdiDeviceIdentifierComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new DeviceDefinitionUdiDeviceIdentifierComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'deviceIdentifier';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setDeviceIdentifierElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'issuer';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = fhirParser.parseUriType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setIssuerElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'jurisdiction';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = fhirParser.parseUriType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setJurisdictionElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * DeviceDefinition.udiDeviceIdentifier.deviceIdentifier Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The identifier that is to be associated with every Device that references this DeviceDefintiion for the issuer and jurisdication porvided in the DeviceDefinition.udiDeviceIdentifier
   * - **Definition:** The identifier that is to be associated with every Device that references this DeviceDefintiion for the issuer and jurisdication porvided in the DeviceDefinition.udiDeviceIdentifier.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private deviceIdentifier: StringType | null;

  /**
   * DeviceDefinition.udiDeviceIdentifier.issuer Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The organization that assigns the identifier algorithm
   * - **Definition:** The organization that assigns the identifier algorithm.
   * - **FHIR Type:** \`uri\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private issuer: UriType | null;

  /**
   * DeviceDefinition.udiDeviceIdentifier.jurisdiction Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The jurisdiction to which the deviceIdentifier applies
   * - **Definition:** The jurisdiction to which the deviceIdentifier applies.
   * - **FHIR Type:** \`uri\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private jurisdiction: UriType | null;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`deviceIdentifier\` property value as a StringType object if defined; else null
   */
  public getDeviceIdentifierElement(): StringType | null {
    return this.deviceIdentifier;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`deviceIdentifier\` property.
   *
   * @param element - the \`deviceIdentifier\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDeviceIdentifierElement(element: StringType): this {
    assertIsDefined<StringType>(element, \`DeviceDefinition.udiDeviceIdentifier.deviceIdentifier is required\`);
    const optErrMsg = \`Invalid DeviceDefinition.udiDeviceIdentifier.deviceIdentifier; Provided value is not an instance of StringType.\`;
    assertFhirType<StringType>(element, StringType, optErrMsg);
    this.deviceIdentifier = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`deviceIdentifier\` property exists and has a value; \`false\` otherwise
   */
  public hasDeviceIdentifierElement(): boolean {
    return isDefined<StringType>(this.deviceIdentifier) && !this.deviceIdentifier.isEmpty();
  }

  /**
   * @returns the \`deviceIdentifier\` property value as a fhirString if defined; else null
   */
  public getDeviceIdentifier(): fhirString | null {
    if (this.deviceIdentifier?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.deviceIdentifier.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`deviceIdentifier\` property.
   *
   * @param value - the \`deviceIdentifier\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDeviceIdentifier(value: fhirString): this {
    assertIsDefined<fhirString>(value, \`DeviceDefinition.udiDeviceIdentifier.deviceIdentifier is required\`);
    const optErrMsg = \`Invalid DeviceDefinition.udiDeviceIdentifier.deviceIdentifier (\${String(value)})\`;
    this.deviceIdentifier = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`deviceIdentifier\` property exists and has a value; \`false\` otherwise
   */
  public hasDeviceIdentifier(): boolean {
    return this.hasDeviceIdentifierElement();
  }

  /**
   * @returns the \`issuer\` property value as a UriType object if defined; else null
   */
  public getIssuerElement(): UriType | null {
    return this.issuer;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`issuer\` property.
   *
   * @param element - the \`issuer\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setIssuerElement(element: UriType): this {
    assertIsDefined<UriType>(element, \`DeviceDefinition.udiDeviceIdentifier.issuer is required\`);
    const optErrMsg = \`Invalid DeviceDefinition.udiDeviceIdentifier.issuer; Provided value is not an instance of UriType.\`;
    assertFhirType<UriType>(element, UriType, optErrMsg);
    this.issuer = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`issuer\` property exists and has a value; \`false\` otherwise
   */
  public hasIssuerElement(): boolean {
    return isDefined<UriType>(this.issuer) && !this.issuer.isEmpty();
  }

  /**
   * @returns the \`issuer\` property value as a fhirUri if defined; else null
   */
  public getIssuer(): fhirUri | null {
    if (this.issuer?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.issuer.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`issuer\` property.
   *
   * @param value - the \`issuer\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setIssuer(value: fhirUri): this {
    assertIsDefined<fhirUri>(value, \`DeviceDefinition.udiDeviceIdentifier.issuer is required\`);
    const optErrMsg = \`Invalid DeviceDefinition.udiDeviceIdentifier.issuer (\${String(value)})\`;
    this.issuer = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`issuer\` property exists and has a value; \`false\` otherwise
   */
  public hasIssuer(): boolean {
    return this.hasIssuerElement();
  }

  /**
   * @returns the \`jurisdiction\` property value as a UriType object if defined; else null
   */
  public getJurisdictionElement(): UriType | null {
    return this.jurisdiction;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`jurisdiction\` property.
   *
   * @param element - the \`jurisdiction\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setJurisdictionElement(element: UriType): this {
    assertIsDefined<UriType>(element, \`DeviceDefinition.udiDeviceIdentifier.jurisdiction is required\`);
    const optErrMsg = \`Invalid DeviceDefinition.udiDeviceIdentifier.jurisdiction; Provided value is not an instance of UriType.\`;
    assertFhirType<UriType>(element, UriType, optErrMsg);
    this.jurisdiction = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`jurisdiction\` property exists and has a value; \`false\` otherwise
   */
  public hasJurisdictionElement(): boolean {
    return isDefined<UriType>(this.jurisdiction) && !this.jurisdiction.isEmpty();
  }

  /**
   * @returns the \`jurisdiction\` property value as a fhirUri if defined; else null
   */
  public getJurisdiction(): fhirUri | null {
    if (this.jurisdiction?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.jurisdiction.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`jurisdiction\` property.
   *
   * @param value - the \`jurisdiction\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setJurisdiction(value: fhirUri): this {
    assertIsDefined<fhirUri>(value, \`DeviceDefinition.udiDeviceIdentifier.jurisdiction is required\`);
    const optErrMsg = \`Invalid DeviceDefinition.udiDeviceIdentifier.jurisdiction (\${String(value)})\`;
    this.jurisdiction = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`jurisdiction\` property exists and has a value; \`false\` otherwise
   */
  public hasJurisdiction(): boolean {
    return this.hasJurisdictionElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'DeviceDefinition.udiDeviceIdentifier';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.deviceIdentifier,
      this.issuer,
      this.jurisdiction,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): DeviceDefinitionUdiDeviceIdentifierComponent {
    const dest = new DeviceDefinitionUdiDeviceIdentifierComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: DeviceDefinitionUdiDeviceIdentifierComponent): void {
    super.copyValues(dest);
    dest.deviceIdentifier = this.deviceIdentifier ? this.deviceIdentifier.copy() : null;
    dest.issuer = this.issuer ? this.issuer.copy() : null;
    dest.jurisdiction = this.jurisdiction ? this.jurisdiction.copy() : null;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasDeviceIdentifierElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirString>(this.getDeviceIdentifierElement()!, 'deviceIdentifier', jsonObj);
    } else {
      missingReqdProperties.push(\`DeviceDefinition.udiDeviceIdentifier.deviceIdentifier\`);
    }

    if (this.hasIssuerElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirUri>(this.getIssuerElement()!, 'issuer', jsonObj);
    } else {
      missingReqdProperties.push(\`DeviceDefinition.udiDeviceIdentifier.issuer\`);
    }

    if (this.hasJurisdictionElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirUri>(this.getJurisdictionElement()!, 'jurisdiction', jsonObj);
    } else {
      missingReqdProperties.push(\`DeviceDefinition.udiDeviceIdentifier.jurisdiction\`);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
/**
 * DeviceDefinitionDeviceNameComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** A name given to the device to identify it
 * - **Definition:** A name given to the device to identify it.
 *
 * @category Data Models: Resource
 * @see [FHIR DeviceDefinition](http://hl7.org/fhir/StructureDefinition/DeviceDefinition)
 */
export class DeviceDefinitionDeviceNameComponent extends BackboneElement implements IBackboneElement {
  constructor(name: StringType | fhirString | null = null, type_: EnumCodeType | CodeType | fhirCode | null = null) {
    super();

    this.deviceNametypeEnum = new DeviceNametypeEnum();

    this.name = null;
    if (isDefined<StringType | fhirString>(name)) {
      if (name instanceof PrimitiveType) {
        this.setNameElement(name);
      } else {
        this.setName(name);
      }
    }

    this.type_ = constructorCodeValueAsEnumCodeType<DeviceNametypeEnum>(
      type_,
      DeviceNametypeEnum,
      this.deviceNametypeEnum,
      'DeviceDefinition.deviceName.type',
    );
  }

  /**
   * Parse the provided \`DeviceDefinitionDeviceNameComponent\` JSON to instantiate the DeviceDefinitionDeviceNameComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`DeviceDefinitionDeviceNameComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to DeviceDefinitionDeviceNameComponent
   * @returns DeviceDefinitionDeviceNameComponent data model or undefined for \`DeviceDefinitionDeviceNameComponent\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): DeviceDefinitionDeviceNameComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'DeviceDefinitionDeviceNameComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new DeviceDefinitionDeviceNameComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'name';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setNameElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'type';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setTypeElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * DeviceDefinition.deviceName.name Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The name of the device
   * - **Definition:** The name of the device.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private name: StringType | null;

  /**
   * FHIR CodeSystem: DeviceNametype
   *
   * @see {@link DeviceNametypeEnum }
   */
  private readonly deviceNametypeEnum: DeviceNametypeEnum;

  /**
   * DeviceDefinition.deviceName.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** udi-label-name | user-friendly-name | patient-reported-name | manufacturer-name | model-name | other
   * - **Definition:** The type of deviceName. UDILabelName | UserFriendlyName | PatientReportedName | ManufactureDeviceName | ModelName.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** false
   *
   * @see CodeSystem Enumeration: {@link DeviceNametypeEnum }
   */
  private type_: EnumCodeType | null;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`name\` property value as a StringType object if defined; else null
   */
  public getNameElement(): StringType | null {
    return this.name;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`name\` property.
   *
   * @param element - the \`name\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setNameElement(element: StringType): this {
    assertIsDefined<StringType>(element, \`DeviceDefinition.deviceName.name is required\`);
    const optErrMsg = \`Invalid DeviceDefinition.deviceName.name; Provided value is not an instance of StringType.\`;
    assertFhirType<StringType>(element, StringType, optErrMsg);
    this.name = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`name\` property exists and has a value; \`false\` otherwise
   */
  public hasNameElement(): boolean {
    return isDefined<StringType>(this.name) && !this.name.isEmpty();
  }

  /**
   * @returns the \`name\` property value as a fhirString if defined; else null
   */
  public getName(): fhirString | null {
    if (this.name?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.name.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`name\` property.
   *
   * @param value - the \`name\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setName(value: fhirString): this {
    assertIsDefined<fhirString>(value, \`DeviceDefinition.deviceName.name is required\`);
    const optErrMsg = \`Invalid DeviceDefinition.deviceName.name (\${String(value)})\`;
    this.name = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`name\` property exists and has a value; \`false\` otherwise
   */
  public hasName(): boolean {
    return this.hasNameElement();
  }

  /**
   * @returns the \`type_\` property value as a EnumCodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link DeviceNametypeEnum }
   */
  public getTypeEnumType(): EnumCodeType | null {
    return this.type_;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`type_\` property.
   *
   * @param enumType - the \`type_\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link DeviceNametypeEnum }
   */
  public setTypeEnumType(enumType: EnumCodeType): this {
    assertIsDefined<EnumCodeType>(enumType, \`DeviceDefinition.deviceName.type is required\`);
    const errMsgPrefix = \`Invalid DeviceDefinition.deviceName.type\`;
    assertEnumCodeType<DeviceNametypeEnum>(enumType, DeviceNametypeEnum, errMsgPrefix);
    this.type_ = enumType;
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasTypeEnumType(): boolean {
    return isDefined<EnumCodeType>(this.type_) && !this.type_.isEmpty() && this.type_.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`type_\` property value as a CodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link DeviceNametypeEnum }
   */
  public getTypeElement(): CodeType | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_ as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`type_\` property.
   *
   * @param element - the \`type_\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link DeviceNametypeEnum }
   */
  public setTypeElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, \`DeviceDefinition.deviceName.type is required\`);
    const optErrMsg = \`Invalid DeviceDefinition.deviceName.type; Provided value is not an instance of CodeType.\`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.type_ = new EnumCodeType(element, this.deviceNametypeEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasTypeElement(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the \`type_\` property value as a fhirCode if defined; else null
   *
   * @see CodeSystem Enumeration: {@link DeviceNametypeEnum }
   */
  public getType(): fhirCode | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`type_\` property.
   *
   * @param value - the \`type_\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link DeviceNametypeEnum }
   */
  public setType(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, \`DeviceDefinition.deviceName.type is required\`);
    const optErrMsg = \`Invalid DeviceDefinition.deviceName.type (\${String(value)})\`;
    this.type_ = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.deviceNametypeEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasType(): boolean {
    return this.hasTypeEnumType();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'DeviceDefinition.deviceName';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.name,
      this.type_,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): DeviceDefinitionDeviceNameComponent {
    const dest = new DeviceDefinitionDeviceNameComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: DeviceDefinitionDeviceNameComponent): void {
    super.copyValues(dest);
    dest.name = this.name ? this.name.copy() : null;
    dest.type_ = this.type_ ? this.type_.copy() : null;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasNameElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirString>(this.getNameElement()!, 'name', jsonObj);
    } else {
      missingReqdProperties.push(\`DeviceDefinition.deviceName.name\`);
    }

    if (this.hasTypeElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getTypeElement()!, 'type', jsonObj);
    } else {
      missingReqdProperties.push(\`DeviceDefinition.deviceName.type\`);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
/**
 * DeviceDefinitionSpecializationComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** The capabilities supported on a  device, the standards to which the device conforms for a particular purpose, and used for the communication
 * - **Definition:** The capabilities supported on a  device, the standards to which the device conforms for a particular purpose, and used for the communication.
 *
 * @category Data Models: Resource
 * @see [FHIR DeviceDefinition](http://hl7.org/fhir/StructureDefinition/DeviceDefinition)
 */
export class DeviceDefinitionSpecializationComponent extends BackboneElement implements IBackboneElement {
  constructor(systemType: StringType | fhirString | null = null) {
    super();

    this.systemType = null;
    if (isDefined<StringType | fhirString>(systemType)) {
      if (systemType instanceof PrimitiveType) {
        this.setSystemTypeElement(systemType);
      } else {
        this.setSystemType(systemType);
      }
    }
  }

  /**
   * Parse the provided \`DeviceDefinitionSpecializationComponent\` JSON to instantiate the DeviceDefinitionSpecializationComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`DeviceDefinitionSpecializationComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to DeviceDefinitionSpecializationComponent
   * @returns DeviceDefinitionSpecializationComponent data model or undefined for \`DeviceDefinitionSpecializationComponent\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): DeviceDefinitionSpecializationComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'DeviceDefinitionSpecializationComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new DeviceDefinitionSpecializationComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'systemType';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setSystemTypeElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'version';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setVersionElement(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * DeviceDefinition.specialization.systemType Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The standard that is used to operate and communicate
   * - **Definition:** The standard that is used to operate and communicate.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private systemType: StringType | null;

  /**
   * DeviceDefinition.specialization.version Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The version of the standard that is used to operate and communicate
   * - **Definition:** The version of the standard that is used to operate and communicate.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private version?: StringType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`systemType\` property value as a StringType object if defined; else null
   */
  public getSystemTypeElement(): StringType | null {
    return this.systemType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`systemType\` property.
   *
   * @param element - the \`systemType\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSystemTypeElement(element: StringType): this {
    assertIsDefined<StringType>(element, \`DeviceDefinition.specialization.systemType is required\`);
    const optErrMsg = \`Invalid DeviceDefinition.specialization.systemType; Provided value is not an instance of StringType.\`;
    assertFhirType<StringType>(element, StringType, optErrMsg);
    this.systemType = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`systemType\` property exists and has a value; \`false\` otherwise
   */
  public hasSystemTypeElement(): boolean {
    return isDefined<StringType>(this.systemType) && !this.systemType.isEmpty();
  }

  /**
   * @returns the \`systemType\` property value as a fhirString if defined; else null
   */
  public getSystemType(): fhirString | null {
    if (this.systemType?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.systemType.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`systemType\` property.
   *
   * @param value - the \`systemType\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSystemType(value: fhirString): this {
    assertIsDefined<fhirString>(value, \`DeviceDefinition.specialization.systemType is required\`);
    const optErrMsg = \`Invalid DeviceDefinition.specialization.systemType (\${String(value)})\`;
    this.systemType = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`systemType\` property exists and has a value; \`false\` otherwise
   */
  public hasSystemType(): boolean {
    return this.hasSystemTypeElement();
  }

  /**
   * @returns the \`version\` property value as a StringType object if defined; else an empty StringType object
   */
  public getVersionElement(): StringType {
    return this.version ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`version\` property.
   *
   * @param element - the \`version\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setVersionElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid DeviceDefinition.specialization.version; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.version = element;
    } else {
      this.version = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`version\` property exists and has a value; \`false\` otherwise
   */
  public hasVersionElement(): boolean {
    return isDefined<StringType>(this.version) && !this.version.isEmpty();
  }

  /**
   * @returns the \`version\` property value as a fhirString if defined; else undefined
   */
  public getVersion(): fhirString | undefined {
    return this.version?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`version\` property.
   *
   * @param value - the \`version\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setVersion(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid DeviceDefinition.specialization.version (\${String(value)})\`;
      this.version = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.version = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`version\` property exists and has a value; \`false\` otherwise
   */
  public hasVersion(): boolean {
    return this.hasVersionElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'DeviceDefinition.specialization';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.systemType,
      this.version,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): DeviceDefinitionSpecializationComponent {
    const dest = new DeviceDefinitionSpecializationComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: DeviceDefinitionSpecializationComponent): void {
    super.copyValues(dest);
    dest.systemType = this.systemType ? this.systemType.copy() : null;
    dest.version = this.version?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasSystemTypeElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirString>(this.getSystemTypeElement()!, 'systemType', jsonObj);
    } else {
      missingReqdProperties.push(\`DeviceDefinition.specialization.systemType\`);
    }

    if (this.hasVersionElement()) {
      setFhirPrimitiveJson<fhirString>(this.getVersionElement(), 'version', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
/**
 * DeviceDefinitionCapabilityComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Device capabilities
 * - **Definition:** Device capabilities.
 *
 * @category Data Models: Resource
 * @see [FHIR DeviceDefinition](http://hl7.org/fhir/StructureDefinition/DeviceDefinition)
 */
export class DeviceDefinitionCapabilityComponent extends BackboneElement implements IBackboneElement {
  constructor(type_: CodeableConcept | null = null) {
    super();

    this.type_ = null;
    if (isDefined<CodeableConcept>(type_)) {
      this.setType(type_);
    }
  }

  /**
   * Parse the provided \`DeviceDefinitionCapabilityComponent\` JSON to instantiate the DeviceDefinitionCapabilityComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`DeviceDefinitionCapabilityComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to DeviceDefinitionCapabilityComponent
   * @returns DeviceDefinitionCapabilityComponent data model or undefined for \`DeviceDefinitionCapabilityComponent\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): DeviceDefinitionCapabilityComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'DeviceDefinitionCapabilityComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new DeviceDefinitionCapabilityComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';

    const missingReqdProperties: string[] = [];

    fieldName = 'type';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = CodeableConcept.parse(classJsonObj[fieldName]!, sourceField);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setType(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'description';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: CodeableConcept | undefined = CodeableConcept.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addDescription(datatype);
        }
      });
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * DeviceDefinition.capability.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Type of capability
   * - **Definition:** Type of capability.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private type_: CodeableConcept | null;

  /**
   * DeviceDefinition.capability.description Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Description of capability
   * - **Definition:** Description of capability.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private description?: CodeableConcept[] | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`type_\` property value as a CodeableConcept object if defined; else null
   */
  public getType(): CodeableConcept | null {
    return this.type_;
  }

  /**
   * Assigns the provided CodeableConcept object value to the \`type_\` property.
   *
   * @param value - the \`type_\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setType(value: CodeableConcept): this {
    assertIsDefined<CodeableConcept>(value, \`DeviceDefinition.capability.type is required\`);
    const optErrMsg = \`Invalid DeviceDefinition.capability.type; Provided element is not an instance of CodeableConcept.\`;
    assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
    this.type_ = value;
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasType(): boolean {
    return isDefined<CodeableConcept>(this.type_) && !this.type_.isEmpty();
  }

  /**
   * @returns the \`description\` property value as a CodeableConcept array
   */
  public getDescription(): CodeableConcept[] {
    return this.description ?? ([] as CodeableConcept[]);
  }

  /**
   * Assigns the provided CodeableConcept array value to the \`description\` property.
   *
   * @param value - the \`description\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setDescription(value: CodeableConcept[] | undefined): this {
    if (isDefinedList<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid DeviceDefinition.capability.description; Provided value array has an element that is not an instance of CodeableConcept.\`;
      assertFhirTypeList<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.description = value;
    } else {
      this.description = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeableConcept value to the \`description\` array property.
   *
   * @param value - the \`description\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addDescription(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid DeviceDefinition.capability.description; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.initDescription();
      this.description?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`description\` property exists and has a value; \`false\` otherwise
   */
  public hasDescription(): boolean {
    return isDefinedList<CodeableConcept>(this.description) && this.description.some((item: CodeableConcept) => !item.isEmpty());
  }

  /**
   * Initialize the \`description\` property
   */
  private initDescription(): void {
    if(!this.hasDescription()) {
      this.description = [] as CodeableConcept[];
    }
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'DeviceDefinition.capability';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.type_,
      this.description,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): DeviceDefinitionCapabilityComponent {
    const dest = new DeviceDefinitionCapabilityComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: DeviceDefinitionCapabilityComponent): void {
    super.copyValues(dest);
    dest.type_ = this.type_ ? this.type_.copy() : null;
    const descriptionList = copyListValues<CodeableConcept>(this.description);
    dest.description = descriptionList.length === 0 ? undefined : descriptionList;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasType()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirComplexJson(this.getType()!, 'type', jsonObj);
    } else {
      missingReqdProperties.push(\`DeviceDefinition.capability.type\`);
    }

    if (this.hasDescription()) {
      setFhirComplexListJson(this.getDescription(), 'description', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
/**
 * DeviceDefinitionPropertyComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** The actual configuration settings of a device as it actually operates, e.g., regulation status, time properties
 * - **Definition:** The actual configuration settings of a device as it actually operates, e.g., regulation status, time properties.
 *
 * @category Data Models: Resource
 * @see [FHIR DeviceDefinition](http://hl7.org/fhir/StructureDefinition/DeviceDefinition)
 */
export class DeviceDefinitionPropertyComponent extends BackboneElement implements IBackboneElement {
  constructor(type_: CodeableConcept | null = null) {
    super();

    this.type_ = null;
    if (isDefined<CodeableConcept>(type_)) {
      this.setType(type_);
    }
  }

  /**
   * Parse the provided \`DeviceDefinitionPropertyComponent\` JSON to instantiate the DeviceDefinitionPropertyComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`DeviceDefinitionPropertyComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to DeviceDefinitionPropertyComponent
   * @returns DeviceDefinitionPropertyComponent data model or undefined for \`DeviceDefinitionPropertyComponent\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): DeviceDefinitionPropertyComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'DeviceDefinitionPropertyComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new DeviceDefinitionPropertyComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';

    const missingReqdProperties: string[] = [];

    fieldName = 'type';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = CodeableConcept.parse(classJsonObj[fieldName]!, sourceField);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setType(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'valueQuantity';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Quantity | undefined = Quantity.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addValueQuantity(datatype);
        }
      });
    }

    fieldName = 'valueCode';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: CodeableConcept | undefined = CodeableConcept.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addValueCode(datatype);
        }
      });
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * DeviceDefinition.property.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Code that specifies the property DeviceDefinitionPropetyCode (Extensible)
   * - **Definition:** Code that specifies the property DeviceDefinitionPropetyCode (Extensible).
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private type_: CodeableConcept | null;

  /**
   * DeviceDefinition.property.valueQuantity Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Property value as a quantity
   * - **Definition:** Property value as a quantity.
   * - **FHIR Type:** \`Quantity\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private valueQuantity?: Quantity[] | undefined;

  /**
   * DeviceDefinition.property.valueCode Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Property value as a code, e.g., NTP4 (synced to NTP)
   * - **Definition:** Property value as a code, e.g., NTP4 (synced to NTP).
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private valueCode?: CodeableConcept[] | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`type_\` property value as a CodeableConcept object if defined; else null
   */
  public getType(): CodeableConcept | null {
    return this.type_;
  }

  /**
   * Assigns the provided CodeableConcept object value to the \`type_\` property.
   *
   * @param value - the \`type_\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setType(value: CodeableConcept): this {
    assertIsDefined<CodeableConcept>(value, \`DeviceDefinition.property.type is required\`);
    const optErrMsg = \`Invalid DeviceDefinition.property.type; Provided element is not an instance of CodeableConcept.\`;
    assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
    this.type_ = value;
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasType(): boolean {
    return isDefined<CodeableConcept>(this.type_) && !this.type_.isEmpty();
  }

  /**
   * @returns the \`valueQuantity\` property value as a Quantity array
   */
  public getValueQuantity(): Quantity[] {
    return this.valueQuantity ?? ([] as Quantity[]);
  }

  /**
   * Assigns the provided Quantity array value to the \`valueQuantity\` property.
   *
   * @param value - the \`valueQuantity\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setValueQuantity(value: Quantity[] | undefined): this {
    if (isDefinedList<Quantity>(value)) {
      const optErrMsg = \`Invalid DeviceDefinition.property.valueQuantity; Provided value array has an element that is not an instance of Quantity.\`;
      assertFhirTypeList<Quantity>(value, Quantity, optErrMsg);
      this.valueQuantity = value;
    } else {
      this.valueQuantity = undefined;
    }
    return this;
  }

  /**
   * Add the provided Quantity value to the \`valueQuantity\` array property.
   *
   * @param value - the \`valueQuantity\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addValueQuantity(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = \`Invalid DeviceDefinition.property.valueQuantity; Provided element is not an instance of Quantity.\`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.initValueQuantity();
      this.valueQuantity?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`valueQuantity\` property exists and has a value; \`false\` otherwise
   */
  public hasValueQuantity(): boolean {
    return isDefinedList<Quantity>(this.valueQuantity) && this.valueQuantity.some((item: Quantity) => !item.isEmpty());
  }

  /**
   * Initialize the \`valueQuantity\` property
   */
  private initValueQuantity(): void {
    if(!this.hasValueQuantity()) {
      this.valueQuantity = [] as Quantity[];
    }
  }

  /**
   * @returns the \`valueCode\` property value as a CodeableConcept array
   */
  public getValueCode(): CodeableConcept[] {
    return this.valueCode ?? ([] as CodeableConcept[]);
  }

  /**
   * Assigns the provided CodeableConcept array value to the \`valueCode\` property.
   *
   * @param value - the \`valueCode\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setValueCode(value: CodeableConcept[] | undefined): this {
    if (isDefinedList<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid DeviceDefinition.property.valueCode; Provided value array has an element that is not an instance of CodeableConcept.\`;
      assertFhirTypeList<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.valueCode = value;
    } else {
      this.valueCode = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeableConcept value to the \`valueCode\` array property.
   *
   * @param value - the \`valueCode\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addValueCode(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid DeviceDefinition.property.valueCode; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.initValueCode();
      this.valueCode?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`valueCode\` property exists and has a value; \`false\` otherwise
   */
  public hasValueCode(): boolean {
    return isDefinedList<CodeableConcept>(this.valueCode) && this.valueCode.some((item: CodeableConcept) => !item.isEmpty());
  }

  /**
   * Initialize the \`valueCode\` property
   */
  private initValueCode(): void {
    if(!this.hasValueCode()) {
      this.valueCode = [] as CodeableConcept[];
    }
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'DeviceDefinition.property';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.type_,
      this.valueQuantity,
      this.valueCode,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): DeviceDefinitionPropertyComponent {
    const dest = new DeviceDefinitionPropertyComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: DeviceDefinitionPropertyComponent): void {
    super.copyValues(dest);
    dest.type_ = this.type_ ? this.type_.copy() : null;
    const valueQuantityList = copyListValues<Quantity>(this.valueQuantity);
    dest.valueQuantity = valueQuantityList.length === 0 ? undefined : valueQuantityList;
    const valueCodeList = copyListValues<CodeableConcept>(this.valueCode);
    dest.valueCode = valueCodeList.length === 0 ? undefined : valueCodeList;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasType()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirComplexJson(this.getType()!, 'type', jsonObj);
    } else {
      missingReqdProperties.push(\`DeviceDefinition.property.type\`);
    }

    if (this.hasValueQuantity()) {
      setFhirComplexListJson(this.getValueQuantity(), 'valueQuantity', jsonObj);
    }

    if (this.hasValueCode()) {
      setFhirComplexListJson(this.getValueCode(), 'valueCode', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
/**
 * DeviceDefinitionMaterialComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** A substance used to create the material(s) of which the device is made
 * - **Definition:** A substance used to create the material(s) of which the device is made.
 *
 * @category Data Models: Resource
 * @see [FHIR DeviceDefinition](http://hl7.org/fhir/StructureDefinition/DeviceDefinition)
 */
export class DeviceDefinitionMaterialComponent extends BackboneElement implements IBackboneElement {
  constructor(substance: CodeableConcept | null = null) {
    super();

    this.substance = null;
    if (isDefined<CodeableConcept>(substance)) {
      this.setSubstance(substance);
    }
  }

  /**
   * Parse the provided \`DeviceDefinitionMaterialComponent\` JSON to instantiate the DeviceDefinitionMaterialComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`DeviceDefinitionMaterialComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to DeviceDefinitionMaterialComponent
   * @returns DeviceDefinitionMaterialComponent data model or undefined for \`DeviceDefinitionMaterialComponent\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): DeviceDefinitionMaterialComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'DeviceDefinitionMaterialComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new DeviceDefinitionMaterialComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'substance';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = CodeableConcept.parse(classJsonObj[fieldName]!, sourceField);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setSubstance(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'alternate';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'boolean';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: BooleanType | undefined = fhirParser.parseBooleanType(dtJson, dtSiblingJson);
      instance.setAlternateElement(datatype);
    }

    fieldName = 'allergenicIndicator';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'boolean';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: BooleanType | undefined = fhirParser.parseBooleanType(dtJson, dtSiblingJson);
      instance.setAllergenicIndicatorElement(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * DeviceDefinition.material.substance Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The substance
   * - **Definition:** The substance.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private substance: CodeableConcept | null;

  /**
   * DeviceDefinition.material.alternate Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Indicates an alternative material of the device
   * - **Definition:** Indicates an alternative material of the device.
   * - **FHIR Type:** \`boolean\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private alternate?: BooleanType | undefined;

  /**
   * DeviceDefinition.material.allergenicIndicator Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Whether the substance is a known or suspected allergen
   * - **Definition:** Whether the substance is a known or suspected allergen.
   * - **FHIR Type:** \`boolean\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private allergenicIndicator?: BooleanType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`substance\` property value as a CodeableConcept object if defined; else null
   */
  public getSubstance(): CodeableConcept | null {
    return this.substance;
  }

  /**
   * Assigns the provided CodeableConcept object value to the \`substance\` property.
   *
   * @param value - the \`substance\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setSubstance(value: CodeableConcept): this {
    assertIsDefined<CodeableConcept>(value, \`DeviceDefinition.material.substance is required\`);
    const optErrMsg = \`Invalid DeviceDefinition.material.substance; Provided element is not an instance of CodeableConcept.\`;
    assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
    this.substance = value;
    return this;
  }

  /**
   * @returns \`true\` if the \`substance\` property exists and has a value; \`false\` otherwise
   */
  public hasSubstance(): boolean {
    return isDefined<CodeableConcept>(this.substance) && !this.substance.isEmpty();
  }

  /**
   * @returns the \`alternate\` property value as a BooleanType object if defined; else an empty BooleanType object
   */
  public getAlternateElement(): BooleanType {
    return this.alternate ?? new BooleanType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`alternate\` property.
   *
   * @param element - the \`alternate\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAlternateElement(element: BooleanType | undefined): this {
    if (isDefined<BooleanType>(element)) {
      const optErrMsg = \`Invalid DeviceDefinition.material.alternate; Provided element is not an instance of BooleanType.\`;
      assertFhirType<BooleanType>(element, BooleanType, optErrMsg);
      this.alternate = element;
    } else {
      this.alternate = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`alternate\` property exists and has a value; \`false\` otherwise
   */
  public hasAlternateElement(): boolean {
    return isDefined<BooleanType>(this.alternate) && !this.alternate.isEmpty();
  }

  /**
   * @returns the \`alternate\` property value as a fhirBoolean if defined; else undefined
   */
  public getAlternate(): fhirBoolean | undefined {
    return this.alternate?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`alternate\` property.
   *
   * @param value - the \`alternate\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAlternate(value: fhirBoolean | undefined): this {
    if (isDefined<fhirBoolean>(value)) {
      const optErrMsg = \`Invalid DeviceDefinition.material.alternate (\${String(value)})\`;
      this.alternate = new BooleanType(parseFhirPrimitiveData(value, fhirBooleanSchema, optErrMsg));
    } else {
      this.alternate = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`alternate\` property exists and has a value; \`false\` otherwise
   */
  public hasAlternate(): boolean {
    return this.hasAlternateElement();
  }

  /**
   * @returns the \`allergenicIndicator\` property value as a BooleanType object if defined; else an empty BooleanType object
   */
  public getAllergenicIndicatorElement(): BooleanType {
    return this.allergenicIndicator ?? new BooleanType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`allergenicIndicator\` property.
   *
   * @param element - the \`allergenicIndicator\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAllergenicIndicatorElement(element: BooleanType | undefined): this {
    if (isDefined<BooleanType>(element)) {
      const optErrMsg = \`Invalid DeviceDefinition.material.allergenicIndicator; Provided element is not an instance of BooleanType.\`;
      assertFhirType<BooleanType>(element, BooleanType, optErrMsg);
      this.allergenicIndicator = element;
    } else {
      this.allergenicIndicator = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`allergenicIndicator\` property exists and has a value; \`false\` otherwise
   */
  public hasAllergenicIndicatorElement(): boolean {
    return isDefined<BooleanType>(this.allergenicIndicator) && !this.allergenicIndicator.isEmpty();
  }

  /**
   * @returns the \`allergenicIndicator\` property value as a fhirBoolean if defined; else undefined
   */
  public getAllergenicIndicator(): fhirBoolean | undefined {
    return this.allergenicIndicator?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`allergenicIndicator\` property.
   *
   * @param value - the \`allergenicIndicator\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAllergenicIndicator(value: fhirBoolean | undefined): this {
    if (isDefined<fhirBoolean>(value)) {
      const optErrMsg = \`Invalid DeviceDefinition.material.allergenicIndicator (\${String(value)})\`;
      this.allergenicIndicator = new BooleanType(parseFhirPrimitiveData(value, fhirBooleanSchema, optErrMsg));
    } else {
      this.allergenicIndicator = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`allergenicIndicator\` property exists and has a value; \`false\` otherwise
   */
  public hasAllergenicIndicator(): boolean {
    return this.hasAllergenicIndicatorElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'DeviceDefinition.material';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.substance,
      this.alternate,
      this.allergenicIndicator,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): DeviceDefinitionMaterialComponent {
    const dest = new DeviceDefinitionMaterialComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: DeviceDefinitionMaterialComponent): void {
    super.copyValues(dest);
    dest.substance = this.substance ? this.substance.copy() : null;
    dest.alternate = this.alternate?.copy();
    dest.allergenicIndicator = this.allergenicIndicator?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasSubstance()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirComplexJson(this.getSubstance()!, 'substance', jsonObj);
    } else {
      missingReqdProperties.push(\`DeviceDefinition.material.substance\`);
    }

    if (this.hasAlternateElement()) {
      setFhirPrimitiveJson<fhirBoolean>(this.getAlternateElement(), 'alternate', jsonObj);
    }

    if (this.hasAllergenicIndicatorElement()) {
      setFhirPrimitiveJson<fhirBoolean>(this.getAllergenicIndicatorElement(), 'allergenicIndicator', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
",
  "fileExtension": "ts",
  "filename": "DeviceDefinition",
}
`;

exports[`generator-datamodel-ftest Functional Test Suite generator-app verify generated content should consistently create GeneratedContent[] 33`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/src",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/test/ftest-cache",
    "pkgName": "ftest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "Resource",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * Endpoint Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/Endpoint
 * StructureDefinition.name: Endpoint
 * StructureDefinition.description: The technical details of an endpoint that can be used for electronic services, such as for web services providing XDS.b or a REST endpoint for another FHIR server. This may include any security context information.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  CodeType,
  DomainResource,
  EnumCodeType,
  FhirError,
  FhirParser,
  IDomainResource,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  PrimitiveType,
  PrimitiveTypeJson,
  REQUIRED_PROPERTIES_DO_NOT_EXIST,
  REQUIRED_PROPERTIES_REQD_IN_JSON,
  ReferenceTargets,
  StringType,
  UrlType,
  assertEnumCodeType,
  assertFhirType,
  assertFhirTypeList,
  assertIsDefined,
  assertIsDefinedList,
  constructorCodeValueAsEnumCodeType,
  copyListValues,
  fhirCode,
  fhirCodeSchema,
  fhirString,
  fhirStringSchema,
  fhirUrl,
  fhirUrlSchema,
  getPrimitiveTypeJson,
  getPrimitiveTypeListJson,
  isDefined,
  isDefinedList,
  isElementEmpty,
  isEmpty,
  parseFhirPrimitiveData,
  setFhirComplexJson,
  setFhirComplexListJson,
  setFhirPrimitiveJson,
  setFhirPrimitiveListJson,
} from '@paq-ts-fhir/fhir-core';
import { CodeableConcept, Coding, ContactPoint, Identifier, PARSABLE_DATATYPE_MAP, Period, Reference } from '../complex-types/complex-datatypes';
import { EndpointStatusEnum } from '../code-systems/EndpointStatusEnum';
import { PARSABLE_RESOURCE_MAP } from './parsable-resource-map';

/**
 * Endpoint Class
 *
 * @remarks
 * The technical details of an endpoint that can be used for electronic services, such as for web services providing XDS.b or a REST endpoint for another FHIR server. This may include any security context information.
 *
 * **FHIR Specification**
 * - **Short:** The technical details of an endpoint that can be used for electronic services
 * - **Definition:** The technical details of an endpoint that can be used for electronic services, such as for web services providing XDS.b or a REST endpoint for another FHIR server. This may include any security context information.
 * - **FHIR Version:** 4.0.1
 *
 * @category Data Models: Resource
 * @see [FHIR Endpoint](http://hl7.org/fhir/StructureDefinition/Endpoint)
 */
export class Endpoint extends DomainResource implements IDomainResource {
  constructor(status: EnumCodeType | CodeType | fhirCode | null = null, connectionType: Coding | null = null, payloadType: CodeableConcept[] | null = null, address: UrlType | fhirUrl | null = null) {
    super();

    this.endpointStatusEnum = new EndpointStatusEnum();

    this.status = constructorCodeValueAsEnumCodeType<EndpointStatusEnum>(
      status,
      EndpointStatusEnum,
      this.endpointStatusEnum,
      'Endpoint.status',
    );

    this.connectionType = null;
    if (isDefined<Coding>(connectionType)) {
      this.setConnectionType(connectionType);
    }

    this.payloadType = null;
    if (isDefinedList<CodeableConcept>(payloadType)) {
      this.setPayloadType(payloadType);
    }

    this.address = null;
    if (isDefined<UrlType | fhirUrl>(address)) {
      if (address instanceof PrimitiveType) {
        this.setAddressElement(address);
      } else {
        this.setAddress(address);
      }
    }
  }

  /**
   * Parse the provided \`Endpoint\` JSON to instantiate the Endpoint data model.
   *
   * @param sourceJson - JSON representing FHIR \`Endpoint\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Endpoint
   * @returns Endpoint data model or undefined for \`Endpoint\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static override parse(sourceJson: JSON.Value, optSourceField?: string): Endpoint | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Endpoint';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Endpoint();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.verifyResourceType(classJsonObj, 'Endpoint');
    fhirParser.processDomainResourceJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'identifier';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Identifier | undefined = Identifier.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addIdentifier(datatype);
        }
      });
    }

    fieldName = 'status';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setStatusElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'connectionType';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Coding | undefined = Coding.parse(classJsonObj[fieldName]!, sourceField);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setConnectionType(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'name';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setNameElement(datatype);
    }

    fieldName = 'managingOrganization';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = Reference.parse(classJsonObj[fieldName]!, sourceField);
      instance.setManagingOrganization(datatype);
    }

    fieldName = 'contact';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: ContactPoint | undefined = ContactPoint.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addContact(datatype);
        }
      });
    }

    fieldName = 'period';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Period | undefined = Period.parse(classJsonObj[fieldName]!, sourceField);
      instance.setPeriod(datatype);
    }

    fieldName = 'payloadType';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: CodeableConcept | undefined = CodeableConcept.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype === undefined) {
          missingReqdProperties.push(\`\${sourceField}[\${String(idx)}]\`);
        } else {
          instance.addPayloadType(datatype);
        }
      });
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'payloadMimeType';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: CodeType | undefined = fhirParser.parseCodeType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addPayloadMimeTypeElement(datatype);
        }
      });
    }

    fieldName = 'address';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UrlType | undefined = fhirParser.parseUrlType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setAddressElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'header';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: StringType | undefined = fhirParser.parseStringType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addHeaderElement(datatype);
        }
      });
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Endpoint.identifier Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Identifies this endpoint across multiple systems
   * - **Definition:** Identifier for the organization that is used to identify the endpoint across multiple disparate systems.
   * - **FHIR Type:** \`Identifier\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private identifier?: Identifier[] | undefined;

  /**
   * FHIR CodeSystem: EndpointStatus
   *
   * @see {@link EndpointStatusEnum }
   */
  private readonly endpointStatusEnum: EndpointStatusEnum;

  /**
   * Endpoint.status Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** active | suspended | error | off | entered-in-error | test
   * - **Definition:** active | suspended | error | off | test.
   * - **Comment:** This element is labeled as a modifier because the status contains codes that mark the endpoint as not currently valid.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 1..1
   * - **isModifier:** true
   * - **isModifierReason:** This element is labelled as a modifier because it is a status element that contains status entered-in-error which means that the resource should not be treated as valid
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link EndpointStatusEnum }
   */
  private status: EnumCodeType | null;

  /**
   * Endpoint.connectionType Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Protocol/Profile/Standard to be used with this endpoint connection
   * - **Definition:** A coded value that represents the technical details of the usage of this endpoint, such as what WSDLs should be used in what way. (e.g. XDS.b/DICOM/cds-hook).
   * - **Comment:** For additional connectivity details for the protocol, extensions will be used at this point, as in the XDS example.
   * - **FHIR Type:** \`Coding\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private connectionType: Coding | null;

  /**
   * Endpoint.name Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A name that this endpoint can be identified by
   * - **Definition:** A friendly name that this endpoint can be referred to with.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private name?: StringType | undefined;

  /**
   * Endpoint.managingOrganization Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Organization that manages this endpoint (might not be the organization that exposes the endpoint)
   * - **Definition:** The organization that manages this endpoint (even if technically another organization is hosting this in the cloud, it is the organization associated with the data).
   * - **Comment:** This property is not typically used when searching for Endpoint resources for usage. The typical usage is via the reference from an applicable Organization/Location/Practitioner resource, which is where the context is provided. Multiple Locations may reference a single endpoint, and don\\'t have to be within the same organization resource, but most likely within the same organizational hierarchy.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Organization',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private managingOrganization?: Reference | undefined;

  /**
   * Endpoint.contact Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Contact details for source (e.g. troubleshooting)
   * - **Definition:** Contact details for a human to contact about the subscription. The primary use of this for system administrator troubleshooting.
   * - **FHIR Type:** \`ContactPoint\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private contact?: ContactPoint[] | undefined;

  /**
   * Endpoint.period Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Interval the endpoint is expected to be operational
   * - **Definition:** The interval during which the endpoint is expected to be operational.
   * - **FHIR Type:** \`Period\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private period?: Period | undefined;

  /**
   * Endpoint.payloadType Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The type of content that may be used at this endpoint (e.g. XDS Discharge summaries)
   * - **Definition:** The payload type describes the acceptable content that can be communicated on the endpoint.
   * - **Comment:** The payloadFormat describes the serialization format of the data, where the payloadType indicates the specific document/schema that is being transferred; e.g. DischargeSummary or CarePlan.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 1..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private payloadType: CodeableConcept[] | null;

  /**
   * Endpoint.payloadMimeType Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Mimetype to send. If not specified, the content could be anything (including no payload, if the connectionType defined this)
   * - **Definition:** The mime type to send the payload in - e.g. application/fhir+xml, application/fhir+json. If the mime type is not specified, then the sender could send any content (including no content depending on the connectionType).
   * - **Comment:** Sending the payload has obvious security consequences. The server is responsible for ensuring that the content is appropriately secured.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private payloadMimeType?: CodeType[] | undefined;

  /**
   * Endpoint.address Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The technical base address for connecting to this endpoint
   * - **Definition:** The uri that describes the actual end-point to connect to.
   * - **Comment:** For rest-hook, and websocket, the end-point must be an http: or https: URL; for email, a mailto: url, for sms, a tel: url, and for message the endpoint can be in any form of url the server understands (usually, http: or mllp:). The URI is allowed to be relative; in which case, it is relative to the server end-point (since there may be more than one, clients should avoid using relative URIs) This address will be to the service base, without any parameters, or sub-services or resources tacked on. E.g. for a WADO-RS endpoint, the url should be "https://pacs.hospital.org/wado-rs" and not "https://pacs.hospital.org/wado-rs/studies/1.2.250.1.59.40211.12345678.678910/series/1.2.250.1.59.40211.789001276.14556172.67789/instances/...".
   * - **FHIR Type:** \`url\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private address: UrlType | null;

  /**
   * Endpoint.header Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Usage depends on the channel type
   * - **Definition:** Additional headers / information to send as part of the notification.
   * - **Comment:** Exactly what these mean depends on the channel type. The can convey additional information to the recipient and/or meet security requirements.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private header?: StringType[] | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`identifier\` property value as a Identifier array
   */
  public getIdentifier(): Identifier[] {
    return this.identifier ?? ([] as Identifier[]);
  }

  /**
   * Assigns the provided Identifier array value to the \`identifier\` property.
   *
   * @param value - the \`identifier\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setIdentifier(value: Identifier[] | undefined): this {
    if (isDefinedList<Identifier>(value)) {
      const optErrMsg = \`Invalid Endpoint.identifier; Provided value array has an element that is not an instance of Identifier.\`;
      assertFhirTypeList<Identifier>(value, Identifier, optErrMsg);
      this.identifier = value;
    } else {
      this.identifier = undefined;
    }
    return this;
  }

  /**
   * Add the provided Identifier value to the \`identifier\` array property.
   *
   * @param value - the \`identifier\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addIdentifier(value: Identifier | undefined): this {
    if (isDefined<Identifier>(value)) {
      const optErrMsg = \`Invalid Endpoint.identifier; Provided element is not an instance of Identifier.\`;
      assertFhirType<Identifier>(value, Identifier, optErrMsg);
      this.initIdentifier();
      this.identifier?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`identifier\` property exists and has a value; \`false\` otherwise
   */
  public hasIdentifier(): boolean {
    return isDefinedList<Identifier>(this.identifier) && this.identifier.some((item: Identifier) => !item.isEmpty());
  }

  /**
   * Initialize the \`identifier\` property
   */
  private initIdentifier(): void {
    if(!this.hasIdentifier()) {
      this.identifier = [] as Identifier[];
    }
  }

  /**
   * @returns the \`status\` property value as a EnumCodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link EndpointStatusEnum }
   */
  public getStatusEnumType(): EnumCodeType | null {
    return this.status;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`status\` property.
   *
   * @param enumType - the \`status\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link EndpointStatusEnum }
   */
  public setStatusEnumType(enumType: EnumCodeType): this {
    assertIsDefined<EnumCodeType>(enumType, \`Endpoint.status is required\`);
    const errMsgPrefix = \`Invalid Endpoint.status\`;
    assertEnumCodeType<EndpointStatusEnum>(enumType, EndpointStatusEnum, errMsgPrefix);
    this.status = enumType;
    return this;
  }

  /**
   * @returns \`true\` if the \`status\` property exists and has a value; \`false\` otherwise
   */
  public hasStatusEnumType(): boolean {
    return isDefined<EnumCodeType>(this.status) && !this.status.isEmpty() && this.status.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`status\` property value as a CodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link EndpointStatusEnum }
   */
  public getStatusElement(): CodeType | null {
    if (this.status === null) {
      return null;
    }
    return this.status as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`status\` property.
   *
   * @param element - the \`status\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link EndpointStatusEnum }
   */
  public setStatusElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, \`Endpoint.status is required\`);
    const optErrMsg = \`Invalid Endpoint.status; Provided value is not an instance of CodeType.\`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.status = new EnumCodeType(element, this.endpointStatusEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`status\` property exists and has a value; \`false\` otherwise
   */
  public hasStatusElement(): boolean {
    return this.hasStatusEnumType();
  }

  /**
   * @returns the \`status\` property value as a fhirCode if defined; else null
   *
   * @see CodeSystem Enumeration: {@link EndpointStatusEnum }
   */
  public getStatus(): fhirCode | null {
    if (this.status === null) {
      return null;
    }
    return this.status.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`status\` property.
   *
   * @param value - the \`status\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link EndpointStatusEnum }
   */
  public setStatus(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, \`Endpoint.status is required\`);
    const optErrMsg = \`Invalid Endpoint.status (\${String(value)})\`;
    this.status = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.endpointStatusEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`status\` property exists and has a value; \`false\` otherwise
   */
  public hasStatus(): boolean {
    return this.hasStatusEnumType();
  }

  /**
   * @returns the \`connectionType\` property value as a Coding object if defined; else null
   */
  public getConnectionType(): Coding | null {
    return this.connectionType;
  }

  /**
   * Assigns the provided Coding object value to the \`connectionType\` property.
   *
   * @param value - the \`connectionType\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setConnectionType(value: Coding): this {
    assertIsDefined<Coding>(value, \`Endpoint.connectionType is required\`);
    const optErrMsg = \`Invalid Endpoint.connectionType; Provided element is not an instance of Coding.\`;
    assertFhirType<Coding>(value, Coding, optErrMsg);
    this.connectionType = value;
    return this;
  }

  /**
   * @returns \`true\` if the \`connectionType\` property exists and has a value; \`false\` otherwise
   */
  public hasConnectionType(): boolean {
    return isDefined<Coding>(this.connectionType) && !this.connectionType.isEmpty();
  }

  /**
   * @returns the \`name\` property value as a StringType object if defined; else an empty StringType object
   */
  public getNameElement(): StringType {
    return this.name ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`name\` property.
   *
   * @param element - the \`name\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setNameElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Endpoint.name; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.name = element;
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`name\` property exists and has a value; \`false\` otherwise
   */
  public hasNameElement(): boolean {
    return isDefined<StringType>(this.name) && !this.name.isEmpty();
  }

  /**
   * @returns the \`name\` property value as a fhirString if defined; else undefined
   */
  public getName(): fhirString | undefined {
    return this.name?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`name\` property.
   *
   * @param value - the \`name\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setName(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Endpoint.name (\${String(value)})\`;
      this.name = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`name\` property exists and has a value; \`false\` otherwise
   */
  public hasName(): boolean {
    return this.hasNameElement();
  }

  /**
   * @returns the \`managingOrganization\` property value as a Reference object; else an empty Reference object
   */
  public getManagingOrganization(): Reference {
    return this.managingOrganization ?? new Reference();
  }

  /**
   * Assigns the provided ManagingOrganization object value to the \`managingOrganization\` property.
   *
   * @decorator \`@ReferenceTargets('Endpoint.managingOrganization', ['Organization',])\`
   *
   * @param value - the \`managingOrganization\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('Endpoint.managingOrganization', [
    'Organization',
  ])
  public setManagingOrganization(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.managingOrganization = value;
    } else {
      this.managingOrganization = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`managingOrganization\` property exists and has a value; \`false\` otherwise
   */
  public hasManagingOrganization(): boolean {
    return isDefined<Reference>(this.managingOrganization) && !this.managingOrganization.isEmpty();
  }

  /**
   * @returns the \`contact\` property value as a ContactPoint array
   */
  public getContact(): ContactPoint[] {
    return this.contact ?? ([] as ContactPoint[]);
  }

  /**
   * Assigns the provided ContactPoint array value to the \`contact\` property.
   *
   * @param value - the \`contact\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setContact(value: ContactPoint[] | undefined): this {
    if (isDefinedList<ContactPoint>(value)) {
      const optErrMsg = \`Invalid Endpoint.contact; Provided value array has an element that is not an instance of ContactPoint.\`;
      assertFhirTypeList<ContactPoint>(value, ContactPoint, optErrMsg);
      this.contact = value;
    } else {
      this.contact = undefined;
    }
    return this;
  }

  /**
   * Add the provided ContactPoint value to the \`contact\` array property.
   *
   * @param value - the \`contact\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addContact(value: ContactPoint | undefined): this {
    if (isDefined<ContactPoint>(value)) {
      const optErrMsg = \`Invalid Endpoint.contact; Provided element is not an instance of ContactPoint.\`;
      assertFhirType<ContactPoint>(value, ContactPoint, optErrMsg);
      this.initContact();
      this.contact?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`contact\` property exists and has a value; \`false\` otherwise
   */
  public hasContact(): boolean {
    return isDefinedList<ContactPoint>(this.contact) && this.contact.some((item: ContactPoint) => !item.isEmpty());
  }

  /**
   * Initialize the \`contact\` property
   */
  private initContact(): void {
    if(!this.hasContact()) {
      this.contact = [] as ContactPoint[];
    }
  }

  /**
   * @returns the \`period\` property value as a Period object if defined; else an empty Period object
   */
  public getPeriod(): Period {
    return this.period ?? new Period();
  }

  /**
   * Assigns the provided Period object value to the \`period\` property.
   *
   * @param value - the \`period\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setPeriod(value: Period | undefined): this {
    if (isDefined<Period>(value)) {
      const optErrMsg = \`Invalid Endpoint.period; Provided element is not an instance of Period.\`;
      assertFhirType<Period>(value, Period, optErrMsg);
      this.period = value;
    } else {
      this.period = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`period\` property exists and has a value; \`false\` otherwise
   */
  public hasPeriod(): boolean {
    return isDefined<Period>(this.period) && !this.period.isEmpty();
  }

  /**
   * @returns the \`payloadType\` property value as a CodeableConcept array
   */
  public getPayloadType(): CodeableConcept[] {
    return this.payloadType ?? ([] as CodeableConcept[]);
  }

  /**
   * Assigns the provided CodeableConcept array value to the \`payloadType\` property.
   *
   * @param value - the \`payloadType\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setPayloadType(value: CodeableConcept[]): this {
    assertIsDefinedList<CodeableConcept>(value, \`Endpoint.payloadType is required\`);
    const optErrMsg = \`Invalid Endpoint.payloadType; Provided value array has an element that is not an instance of CodeableConcept.\`;
    assertFhirTypeList<CodeableConcept>(value, CodeableConcept, optErrMsg);
    this.payloadType = value;
    return this;
  }

  /**
   * Add the provided CodeableConcept value to the \`payloadType\` array property.
   *
   * @param value - the \`payloadType\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addPayloadType(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Endpoint.payloadType; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.initPayloadType();
      this.payloadType?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`payloadType\` property exists and has a value; \`false\` otherwise
   */
  public hasPayloadType(): boolean {
    return isDefinedList<CodeableConcept>(this.payloadType) && this.payloadType.some((item: CodeableConcept) => !item.isEmpty());
  }

  /**
   * Initialize the \`payloadType\` property
   */
  private initPayloadType(): void {
    if(!this.hasPayloadType()) {
      this.payloadType = [] as CodeableConcept[];
    }
  }

  /**
   * @returns the \`payloadMimeType\` property value as a CodeType array
   */
  public getPayloadMimeTypeElement(): CodeType[] {
    return this.payloadMimeType ?? ([] as CodeType[]);
  }

  /**
   * Assigns the provided CodeType array value to the \`payloadMimeType\` property.
   *
   * @param element - the \`payloadMimeType\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPayloadMimeTypeElement(element: CodeType[] | undefined): this {
    if (isDefinedList<CodeType>(element)) {
      const optErrMsg = \`Invalid Endpoint.payloadMimeType; Provided value array has an element that is not an instance of CodeType.\`;
      assertFhirTypeList<CodeType>(element, CodeType, optErrMsg);
      this.payloadMimeType = element;
    } else {
      this.payloadMimeType = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeType value to the \`payloadMimeType\` array property.
   *
   * @param element - the \`payloadMimeType\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addPayloadMimeTypeElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Endpoint.payloadMimeType; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.initPayloadMimeType();
      this.payloadMimeType?.push(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`payloadMimeType\` property exists and has a value; \`false\` otherwise
   */
  public hasPayloadMimeTypeElement(): boolean {
    return isDefinedList<CodeType>(this.payloadMimeType) && this.payloadMimeType.some((item: CodeType) => !item.isEmpty());
  }

  /**
   * @returns the \`payloadMimeType\` property value as a fhirCode array
   */
  public getPayloadMimeType(): fhirCode[] {
    this.initPayloadMimeType();
    const payloadMimeTypeValues = [] as fhirCode[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.payloadMimeType!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        payloadMimeTypeValues.push(value);
      }
    }
    return payloadMimeTypeValues;
  }

  /**
   * Assigns the provided primitive value array to the \`payloadMimeType\` property.
   *
   * @param value - the \`payloadMimeType\` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPayloadMimeType(value: fhirCode[] | undefined): this {
    if (isDefinedList<fhirCode>(value)) {
      const payloadMimeTypeElements = [] as CodeType[];
      for (const payloadMimeTypeValue of value) {
        const optErrMsg = \`Invalid Endpoint.payloadMimeType array item (\${String(payloadMimeTypeValue)})\`;
        const element = new CodeType(parseFhirPrimitiveData(payloadMimeTypeValue, fhirCodeSchema, optErrMsg));
        payloadMimeTypeElements.push(element);
      }
      this.payloadMimeType = payloadMimeTypeElements;
    } else {
      this.payloadMimeType = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`payloadMimeType\` array property.
   *
   * @param value - the \`payloadMimeType\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addPayloadMimeType(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Endpoint.payloadMimeType array item (\${String(value)})\`;
      const element = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
      this.initPayloadMimeType();
      this.addPayloadMimeTypeElement(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`payloadMimeType\` property exists and has a value; \`false\` otherwise
   */
  public hasPayloadMimeType(): boolean {
    return this.hasPayloadMimeTypeElement();
  }

  /**
   * Initialize the \`payloadMimeType\` property
   */
  private initPayloadMimeType(): void {
    if (!this.hasPayloadMimeType()) {
      this.payloadMimeType = [] as CodeType[];
    }
  }

  /**
   * @returns the \`address\` property value as a UrlType object if defined; else null
   */
  public getAddressElement(): UrlType | null {
    return this.address;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`address\` property.
   *
   * @param element - the \`address\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAddressElement(element: UrlType): this {
    assertIsDefined<UrlType>(element, \`Endpoint.address is required\`);
    const optErrMsg = \`Invalid Endpoint.address; Provided value is not an instance of UrlType.\`;
    assertFhirType<UrlType>(element, UrlType, optErrMsg);
    this.address = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`address\` property exists and has a value; \`false\` otherwise
   */
  public hasAddressElement(): boolean {
    return isDefined<UrlType>(this.address) && !this.address.isEmpty();
  }

  /**
   * @returns the \`address\` property value as a fhirUrl if defined; else null
   */
  public getAddress(): fhirUrl | null {
    if (this.address?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.address.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`address\` property.
   *
   * @param value - the \`address\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAddress(value: fhirUrl): this {
    assertIsDefined<fhirUrl>(value, \`Endpoint.address is required\`);
    const optErrMsg = \`Invalid Endpoint.address (\${String(value)})\`;
    this.address = new UrlType(parseFhirPrimitiveData(value, fhirUrlSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`address\` property exists and has a value; \`false\` otherwise
   */
  public hasAddress(): boolean {
    return this.hasAddressElement();
  }

  /**
   * @returns the \`header\` property value as a StringType array
   */
  public getHeaderElement(): StringType[] {
    return this.header ?? ([] as StringType[]);
  }

  /**
   * Assigns the provided StringType array value to the \`header\` property.
   *
   * @param element - the \`header\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setHeaderElement(element: StringType[] | undefined): this {
    if (isDefinedList<StringType>(element)) {
      const optErrMsg = \`Invalid Endpoint.header; Provided value array has an element that is not an instance of StringType.\`;
      assertFhirTypeList<StringType>(element, StringType, optErrMsg);
      this.header = element;
    } else {
      this.header = undefined;
    }
    return this;
  }

  /**
   * Add the provided StringType value to the \`header\` array property.
   *
   * @param element - the \`header\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addHeaderElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Endpoint.header; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.initHeader();
      this.header?.push(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`header\` property exists and has a value; \`false\` otherwise
   */
  public hasHeaderElement(): boolean {
    return isDefinedList<StringType>(this.header) && this.header.some((item: StringType) => !item.isEmpty());
  }

  /**
   * @returns the \`header\` property value as a fhirString array
   */
  public getHeader(): fhirString[] {
    this.initHeader();
    const headerValues = [] as fhirString[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.header!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        headerValues.push(value);
      }
    }
    return headerValues;
  }

  /**
   * Assigns the provided primitive value array to the \`header\` property.
   *
   * @param value - the \`header\` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setHeader(value: fhirString[] | undefined): this {
    if (isDefinedList<fhirString>(value)) {
      const headerElements = [] as StringType[];
      for (const headerValue of value) {
        const optErrMsg = \`Invalid Endpoint.header array item (\${String(headerValue)})\`;
        const element = new StringType(parseFhirPrimitiveData(headerValue, fhirStringSchema, optErrMsg));
        headerElements.push(element);
      }
      this.header = headerElements;
    } else {
      this.header = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`header\` array property.
   *
   * @param value - the \`header\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addHeader(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Endpoint.header array item (\${String(value)})\`;
      const element = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
      this.initHeader();
      this.addHeaderElement(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`header\` property exists and has a value; \`false\` otherwise
   */
  public hasHeader(): boolean {
    return this.hasHeaderElement();
  }

  /**
   * Initialize the \`header\` property
   */
  private initHeader(): void {
    if (!this.hasHeader()) {
      this.header = [] as StringType[];
    }
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Endpoint';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.identifier,
      this.status,
      this.connectionType,
      this.name,
      this.managingOrganization,
      this.contact,
      this.period,
      this.payloadType,
      this.payloadMimeType,
      this.address,
      this.header,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Endpoint {
    const dest = new Endpoint();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Endpoint): void {
    super.copyValues(dest);
    const identifierList = copyListValues<Identifier>(this.identifier);
    dest.identifier = identifierList.length === 0 ? undefined : identifierList;
    dest.status = this.status ? this.status.copy() : null;
    dest.connectionType = this.connectionType ? this.connectionType.copy() : null;
    dest.name = this.name?.copy();
    dest.managingOrganization = this.managingOrganization?.copy();
    const contactList = copyListValues<ContactPoint>(this.contact);
    dest.contact = contactList.length === 0 ? undefined : contactList;
    dest.period = this.period?.copy();
    const payloadTypeList = copyListValues<CodeableConcept>(this.payloadType);
    dest.payloadType = payloadTypeList.length === 0 ? null : payloadTypeList;
    const payloadMimeTypeList = copyListValues<CodeType>(this.payloadMimeType);
    dest.payloadMimeType = payloadMimeTypeList.length === 0 ? undefined : payloadMimeTypeList;
    dest.address = this.address ? this.address.copy() : null;
    const headerList = copyListValues<StringType>(this.header);
    dest.header = headerList.length === 0 ? undefined : headerList;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasIdentifier()) {
      setFhirComplexListJson(this.getIdentifier(), 'identifier', jsonObj);
    }

    if (this.hasStatusElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getStatusElement()!, 'status', jsonObj);
    } else {
      missingReqdProperties.push(\`Endpoint.status\`);
    }

    if (this.hasConnectionType()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirComplexJson(this.getConnectionType()!, 'connectionType', jsonObj);
    } else {
      missingReqdProperties.push(\`Endpoint.connectionType\`);
    }

    if (this.hasNameElement()) {
      setFhirPrimitiveJson<fhirString>(this.getNameElement(), 'name', jsonObj);
    }

    if (this.hasManagingOrganization()) {
      setFhirComplexJson(this.getManagingOrganization(), 'managingOrganization', jsonObj);
    }

    if (this.hasContact()) {
      setFhirComplexListJson(this.getContact(), 'contact', jsonObj);
    }

    if (this.hasPeriod()) {
      setFhirComplexJson(this.getPeriod(), 'period', jsonObj);
    }

    if (this.hasPayloadType()) {
      setFhirComplexListJson(this.getPayloadType(), 'payloadType', jsonObj);
    } else {
      missingReqdProperties.push(\`Endpoint.payloadType\`);
    }

    if (this.hasPayloadMimeType()) {
      setFhirPrimitiveListJson(this.getPayloadMimeTypeElement(), 'payloadMimeType', jsonObj);
    }

    if (this.hasAddressElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirUrl>(this.getAddressElement()!, 'address', jsonObj);
    } else {
      missingReqdProperties.push(\`Endpoint.address\`);
    }

    if (this.hasHeader()) {
      setFhirPrimitiveListJson(this.getHeaderElement(), 'header', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "Endpoint",
}
`;

exports[`generator-datamodel-ftest Functional Test Suite generator-app verify generated content should consistently create GeneratedContent[] 34`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/src",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/test/ftest-cache",
    "pkgName": "ftest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "Resource",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * HealthcareService Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/HealthcareService
 * StructureDefinition.name: HealthcareService
 * StructureDefinition.description: The details of a healthcare service available at a location.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  BackboneElement,
  BooleanType,
  CodeType,
  DomainResource,
  EnumCodeType,
  FhirError,
  FhirParser,
  IBackboneElement,
  IDomainResource,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  MarkdownType,
  PrimitiveType,
  PrimitiveTypeJson,
  REQUIRED_PROPERTIES_DO_NOT_EXIST,
  REQUIRED_PROPERTIES_REQD_IN_JSON,
  ReferenceTargets,
  StringType,
  TimeType,
  assertEnumCodeType,
  assertEnumCodeTypeList,
  assertFhirType,
  assertFhirTypeList,
  assertIsDefined,
  copyListValues,
  fhirBoolean,
  fhirBooleanSchema,
  fhirCode,
  fhirCodeSchema,
  fhirMarkdown,
  fhirMarkdownSchema,
  fhirString,
  fhirStringSchema,
  fhirTime,
  fhirTimeSchema,
  getPrimitiveTypeJson,
  getPrimitiveTypeListJson,
  isDefined,
  isDefinedList,
  isElementEmpty,
  isEmpty,
  parseFhirPrimitiveData,
  setFhirBackboneElementListJson,
  setFhirComplexJson,
  setFhirComplexListJson,
  setFhirPrimitiveJson,
  setFhirPrimitiveListJson,
} from '@paq-ts-fhir/fhir-core';
import { Attachment, CodeableConcept, ContactPoint, Identifier, PARSABLE_DATATYPE_MAP, Period, Reference } from '../complex-types/complex-datatypes';
import { DaysOfWeekEnum } from '../code-systems/DaysOfWeekEnum';
import { PARSABLE_RESOURCE_MAP } from './parsable-resource-map';

/**
 * HealthcareService Class
 *
 * @remarks
 * The details of a healthcare service available at a location.
 *
 * **FHIR Specification**
 * - **Short:** The details of a healthcare service available at a location
 * - **Definition:** The details of a healthcare service available at a location.
 * - **FHIR Version:** 4.0.1
 *
 * @category Data Models: Resource
 * @see [FHIR HealthcareService](http://hl7.org/fhir/StructureDefinition/HealthcareService)
 */
export class HealthcareService extends DomainResource implements IDomainResource {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`HealthcareService\` JSON to instantiate the HealthcareService data model.
   *
   * @param sourceJson - JSON representing FHIR \`HealthcareService\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to HealthcareService
   * @returns HealthcareService data model or undefined for \`HealthcareService\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static override parse(sourceJson: JSON.Value, optSourceField?: string): HealthcareService | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'HealthcareService';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new HealthcareService();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.verifyResourceType(classJsonObj, 'HealthcareService');
    fhirParser.processDomainResourceJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'identifier';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Identifier | undefined = Identifier.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addIdentifier(datatype);
        }
      });
    }

    fieldName = 'active';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'boolean';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: BooleanType | undefined = fhirParser.parseBooleanType(dtJson, dtSiblingJson);
      instance.setActiveElement(datatype);
    }

    fieldName = 'providedBy';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = Reference.parse(classJsonObj[fieldName]!, sourceField);
      instance.setProvidedBy(datatype);
    }

    fieldName = 'category';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: CodeableConcept | undefined = CodeableConcept.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addCategory(datatype);
        }
      });
    }

    fieldName = 'type';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: CodeableConcept | undefined = CodeableConcept.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addType(datatype);
        }
      });
    }

    fieldName = 'specialty';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: CodeableConcept | undefined = CodeableConcept.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addSpecialty(datatype);
        }
      });
    }

    fieldName = 'location';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Reference | undefined = Reference.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addLocation(datatype);
        }
      });
  }

    fieldName = 'name';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setNameElement(datatype);
    }

    fieldName = 'comment';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setCommentElement(datatype);
    }

    fieldName = 'extraDetails';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: MarkdownType | undefined = fhirParser.parseMarkdownType(dtJson, dtSiblingJson);
      instance.setExtraDetailsElement(datatype);
    }

    fieldName = 'photo';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Attachment | undefined = Attachment.parse(classJsonObj[fieldName]!, sourceField);
      instance.setPhoto(datatype);
    }

    fieldName = 'telecom';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: ContactPoint | undefined = ContactPoint.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addTelecom(datatype);
        }
      });
    }

    fieldName = 'coverageArea';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Reference | undefined = Reference.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addCoverageArea(datatype);
        }
      });
  }

    fieldName = 'serviceProvisionCode';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: CodeableConcept | undefined = CodeableConcept.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addServiceProvisionCode(datatype);
        }
      });
    }

    fieldName = 'eligibility';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const componentJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      componentJsonArray.forEach((componentJson: JSON.Value, idx) => {
        const component: HealthcareServiceEligibilityComponent | undefined = HealthcareServiceEligibilityComponent.parse(componentJson, \`\${sourceField}[\${String(idx)}]\`);
        if (component !== undefined) {
          instance.addEligibility(component);
        }
      });
    }

    fieldName = 'program';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: CodeableConcept | undefined = CodeableConcept.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addProgram(datatype);
        }
      });
    }

    fieldName = 'characteristic';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: CodeableConcept | undefined = CodeableConcept.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addCharacteristic(datatype);
        }
      });
    }

    fieldName = 'communication';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: CodeableConcept | undefined = CodeableConcept.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addCommunication(datatype);
        }
      });
    }

    fieldName = 'referralMethod';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: CodeableConcept | undefined = CodeableConcept.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addReferralMethod(datatype);
        }
      });
    }

    fieldName = 'appointmentRequired';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'boolean';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: BooleanType | undefined = fhirParser.parseBooleanType(dtJson, dtSiblingJson);
      instance.setAppointmentRequiredElement(datatype);
    }

    fieldName = 'availableTime';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const componentJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      componentJsonArray.forEach((componentJson: JSON.Value, idx) => {
        const component: HealthcareServiceAvailableTimeComponent | undefined = HealthcareServiceAvailableTimeComponent.parse(componentJson, \`\${sourceField}[\${String(idx)}]\`);
        if (component !== undefined) {
          instance.addAvailableTime(component);
        }
      });
    }

    fieldName = 'notAvailable';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const componentJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      componentJsonArray.forEach((componentJson: JSON.Value, idx) => {
        const component: HealthcareServiceNotAvailableComponent | undefined = HealthcareServiceNotAvailableComponent.parse(componentJson, \`\${sourceField}[\${String(idx)}]\`);
        if (component !== undefined) {
          instance.addNotAvailable(component);
        }
      });
    }

    fieldName = 'availabilityExceptions';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setAvailabilityExceptionsElement(datatype);
    }

    fieldName = 'endpoint';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Reference | undefined = Reference.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addEndpoint(datatype);
        }
      });
  }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * HealthcareService.identifier Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** External identifiers for this item
   * - **Definition:** External identifiers for this item.
   * - **FHIR Type:** \`Identifier\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private identifier?: Identifier[] | undefined;

  /**
   * HealthcareService.active Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Whether this HealthcareService record is in active use
   * - **Definition:** This flag is used to mark the record to not be used. This is not used when a center is closed for maintenance, or for holidays, the notAvailable period is to be used for this.
   * - **Comment:** This element is labeled as a modifier because it may be used to mark that the resource was created in error.
   * - **FHIR Type:** \`boolean\`
   * - **Cardinality:** 0..1
   * - **isModifier:** true
   * - **isModifierReason:** This element is labelled as a modifier because it is a status element that can indicate that a record should not be treated as valid
   * - **isSummary:** true
   */
  private active?: BooleanType | undefined;

  /**
   * HealthcareService.providedBy Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Organization that provides this service
   * - **Definition:** The organization that provides this healthcare service.
   * - **Comment:** This property is recommended to be the same as the Location\\'s managingOrganization, and if not provided should be interpreted as such. If the Location does not have a managing Organization, then this property should be populated.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Organization',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private providedBy?: Reference | undefined;

  /**
   * HealthcareService.category Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Broad category of service being performed or delivered
   * - **Definition:** Identifies the broad category of service being performed or delivered.
   * - **Comment:** Selecting a Service Category then determines the list of relevant service types that can be selected in the primary service type.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private category?: CodeableConcept[] | undefined;

  /**
   * HealthcareService.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Type of service that may be delivered or performed
   * - **Definition:** The specific type of service that may be delivered or performed.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private type_?: CodeableConcept[] | undefined;

  /**
   * HealthcareService.specialty Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Specialties handled by the HealthcareService
   * - **Definition:** Collection of specialties handled by the service site. This is more of a medical term.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private specialty?: CodeableConcept[] | undefined;

  /**
   * HealthcareService.location Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Location(s) where service may be provided
   * - **Definition:** The location(s) where this healthcare service may be provided.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Location',
   *     ]
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private location?: Reference[] | undefined;

  /**
   * HealthcareService.name Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Description of service as presented to a consumer while searching
   * - **Definition:** Further description of the service as it would be presented to a consumer while searching.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private name?: StringType | undefined;

  /**
   * HealthcareService.comment Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Additional description and/or any specific issues not covered elsewhere
   * - **Definition:** Any additional description of the service and/or any specific issues not covered by the other attributes, which can be displayed as further detail under the serviceName.
   * - **Comment:** Would expect that a user would not see this information on a search results, and it would only be available when viewing the complete details of the service.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private comment?: StringType | undefined;

  /**
   * HealthcareService.extraDetails Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Extra details about the service that can\\'t be placed in the other fields
   * - **Definition:** Extra details about the service that can\\'t be placed in the other fields.
   * - **FHIR Type:** \`markdown\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private extraDetails?: MarkdownType | undefined;

  /**
   * HealthcareService.photo Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Facilitates quick identification of the service
   * - **Definition:** If there is a photo/symbol associated with this HealthcareService, it may be included here to facilitate quick identification of the service in a list.
   * - **FHIR Type:** \`Attachment\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private photo?: Attachment | undefined;

  /**
   * HealthcareService.telecom Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Contacts related to the healthcare service
   * - **Definition:** List of contacts related to this specific healthcare service.
   * - **Comment:** If this is empty, then refer to the location\\'s contacts.
   * - **FHIR Type:** \`ContactPoint\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private telecom?: ContactPoint[] | undefined;

  /**
   * HealthcareService.coverageArea Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Location(s) service is intended for/available to
   * - **Definition:** The location(s) that this service is available to (not where the service is provided).
   * - **Comment:** The locations referenced by the coverage area can include both specific locations, including areas, and also conceptual domains too (mode = kind), such as a physical area (tri-state area) and some other attribute (covered by Example Care Organization). These types of Locations are often not managed by any specific organization. This could also include generic locations such as "in-home".
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Location',
   *     ]
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private coverageArea?: Reference[] | undefined;

  /**
   * HealthcareService.serviceProvisionCode Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Conditions under which service is available/offered
   * - **Definition:** The code(s) that detail the conditions under which the healthcare service is available/offered.
   * - **Comment:** The provision means being commissioned by, contractually obliged or financially sourced. Types of costings that may apply to this healthcare service, such if the service may be available for free, some discounts available, or fees apply.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private serviceProvisionCode?: CodeableConcept[] | undefined;

  /**
   * HealthcareService.eligibility Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Specific eligibility requirements required to use the service
   * - **Definition:** Does this service have specific eligibility requirements that need to be met in order to use the service?
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private eligibility?: HealthcareServiceEligibilityComponent[] | undefined;

  /**
   * HealthcareService.program Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Programs that this service is applicable to
   * - **Definition:** Programs that this service is applicable to.
   * - **Comment:** Programs are often defined externally to an Organization, commonly by governments; e.g. Home and Community Care Programs, Homeless Program, ....
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private program?: CodeableConcept[] | undefined;

  /**
   * HealthcareService.characteristic Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Collection of characteristics (attributes)
   * - **Definition:** Collection of characteristics (attributes).
   * - **Comment:** These could be such things as is wheelchair accessible.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private characteristic?: CodeableConcept[] | undefined;

  /**
   * HealthcareService.communication Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The language that this service is offered in
   * - **Definition:** Some services are specifically made available in multiple languages, this property permits a directory to declare the languages this is offered in. Typically this is only provided where a service operates in communities with mixed languages used.
   * - **Comment:** When using this property it indicates that the service is available with this language, it is not derived from the practitioners, and not all are required to use this language, just that this language is available while scheduling.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private communication?: CodeableConcept[] | undefined;

  /**
   * HealthcareService.referralMethod Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Ways that the service accepts referrals
   * - **Definition:** Ways that the service accepts referrals, if this is not provided then it is implied that no referral is required.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private referralMethod?: CodeableConcept[] | undefined;

  /**
   * HealthcareService.appointmentRequired Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** If an appointment is required for access to this service
   * - **Definition:** Indicates whether or not a prospective consumer will require an appointment for a particular service at a site to be provided by the Organization. Indicates if an appointment is required for access to this service.
   * - **FHIR Type:** \`boolean\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private appointmentRequired?: BooleanType | undefined;

  /**
   * HealthcareService.availableTime Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Times the Service Site is available
   * - **Definition:** A collection of times that the Service Site is available.
   * - **Comment:** More detailed availability information may be provided in associated Schedule/Slot resources.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private availableTime?: HealthcareServiceAvailableTimeComponent[] | undefined;

  /**
   * HealthcareService.notAvailable Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Not available during this time due to provided reason
   * - **Definition:** The HealthcareService is not available during this period of time due to the provided reason.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private notAvailable?: HealthcareServiceNotAvailableComponent[] | undefined;

  /**
   * HealthcareService.availabilityExceptions Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Description of availability exceptions
   * - **Definition:** A description of site availability exceptions, e.g. public holiday availability. Succinctly describing all possible exceptions to normal site availability as details in the available Times and not available Times.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private availabilityExceptions?: StringType | undefined;

  /**
   * HealthcareService.endpoint Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Technical endpoints providing access to electronic services operated for the healthcare service
   * - **Definition:** Technical endpoints providing access to services operated for the specific healthcare services defined at this resource.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Endpoint',
   *     ]
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private endpoint?: Reference[] | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`identifier\` property value as a Identifier array
   */
  public getIdentifier(): Identifier[] {
    return this.identifier ?? ([] as Identifier[]);
  }

  /**
   * Assigns the provided Identifier array value to the \`identifier\` property.
   *
   * @param value - the \`identifier\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setIdentifier(value: Identifier[] | undefined): this {
    if (isDefinedList<Identifier>(value)) {
      const optErrMsg = \`Invalid HealthcareService.identifier; Provided value array has an element that is not an instance of Identifier.\`;
      assertFhirTypeList<Identifier>(value, Identifier, optErrMsg);
      this.identifier = value;
    } else {
      this.identifier = undefined;
    }
    return this;
  }

  /**
   * Add the provided Identifier value to the \`identifier\` array property.
   *
   * @param value - the \`identifier\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addIdentifier(value: Identifier | undefined): this {
    if (isDefined<Identifier>(value)) {
      const optErrMsg = \`Invalid HealthcareService.identifier; Provided element is not an instance of Identifier.\`;
      assertFhirType<Identifier>(value, Identifier, optErrMsg);
      this.initIdentifier();
      this.identifier?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`identifier\` property exists and has a value; \`false\` otherwise
   */
  public hasIdentifier(): boolean {
    return isDefinedList<Identifier>(this.identifier) && this.identifier.some((item: Identifier) => !item.isEmpty());
  }

  /**
   * Initialize the \`identifier\` property
   */
  private initIdentifier(): void {
    if(!this.hasIdentifier()) {
      this.identifier = [] as Identifier[];
    }
  }

  /**
   * @returns the \`active\` property value as a BooleanType object if defined; else an empty BooleanType object
   */
  public getActiveElement(): BooleanType {
    return this.active ?? new BooleanType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`active\` property.
   *
   * @param element - the \`active\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setActiveElement(element: BooleanType | undefined): this {
    if (isDefined<BooleanType>(element)) {
      const optErrMsg = \`Invalid HealthcareService.active; Provided element is not an instance of BooleanType.\`;
      assertFhirType<BooleanType>(element, BooleanType, optErrMsg);
      this.active = element;
    } else {
      this.active = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`active\` property exists and has a value; \`false\` otherwise
   */
  public hasActiveElement(): boolean {
    return isDefined<BooleanType>(this.active) && !this.active.isEmpty();
  }

  /**
   * @returns the \`active\` property value as a fhirBoolean if defined; else undefined
   */
  public getActive(): fhirBoolean | undefined {
    return this.active?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`active\` property.
   *
   * @param value - the \`active\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setActive(value: fhirBoolean | undefined): this {
    if (isDefined<fhirBoolean>(value)) {
      const optErrMsg = \`Invalid HealthcareService.active (\${String(value)})\`;
      this.active = new BooleanType(parseFhirPrimitiveData(value, fhirBooleanSchema, optErrMsg));
    } else {
      this.active = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`active\` property exists and has a value; \`false\` otherwise
   */
  public hasActive(): boolean {
    return this.hasActiveElement();
  }

  /**
   * @returns the \`providedBy\` property value as a Reference object; else an empty Reference object
   */
  public getProvidedBy(): Reference {
    return this.providedBy ?? new Reference();
  }

  /**
   * Assigns the provided ProvidedBy object value to the \`providedBy\` property.
   *
   * @decorator \`@ReferenceTargets('HealthcareService.providedBy', ['Organization',])\`
   *
   * @param value - the \`providedBy\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('HealthcareService.providedBy', [
    'Organization',
  ])
  public setProvidedBy(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.providedBy = value;
    } else {
      this.providedBy = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`providedBy\` property exists and has a value; \`false\` otherwise
   */
  public hasProvidedBy(): boolean {
    return isDefined<Reference>(this.providedBy) && !this.providedBy.isEmpty();
  }

  /**
   * @returns the \`category\` property value as a CodeableConcept array
   */
  public getCategory(): CodeableConcept[] {
    return this.category ?? ([] as CodeableConcept[]);
  }

  /**
   * Assigns the provided CodeableConcept array value to the \`category\` property.
   *
   * @param value - the \`category\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setCategory(value: CodeableConcept[] | undefined): this {
    if (isDefinedList<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid HealthcareService.category; Provided value array has an element that is not an instance of CodeableConcept.\`;
      assertFhirTypeList<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.category = value;
    } else {
      this.category = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeableConcept value to the \`category\` array property.
   *
   * @param value - the \`category\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addCategory(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid HealthcareService.category; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.initCategory();
      this.category?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`category\` property exists and has a value; \`false\` otherwise
   */
  public hasCategory(): boolean {
    return isDefinedList<CodeableConcept>(this.category) && this.category.some((item: CodeableConcept) => !item.isEmpty());
  }

  /**
   * Initialize the \`category\` property
   */
  private initCategory(): void {
    if(!this.hasCategory()) {
      this.category = [] as CodeableConcept[];
    }
  }

  /**
   * @returns the \`type_\` property value as a CodeableConcept array
   */
  public getType(): CodeableConcept[] {
    return this.type_ ?? ([] as CodeableConcept[]);
  }

  /**
   * Assigns the provided CodeableConcept array value to the \`type_\` property.
   *
   * @param value - the \`type_\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setType(value: CodeableConcept[] | undefined): this {
    if (isDefinedList<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid HealthcareService.type; Provided value array has an element that is not an instance of CodeableConcept.\`;
      assertFhirTypeList<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.type_ = value;
    } else {
      this.type_ = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeableConcept value to the \`type_\` array property.
   *
   * @param value - the \`type_\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addType(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid HealthcareService.type; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.initType();
      this.type_?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasType(): boolean {
    return isDefinedList<CodeableConcept>(this.type_) && this.type_.some((item: CodeableConcept) => !item.isEmpty());
  }

  /**
   * Initialize the \`type_\` property
   */
  private initType(): void {
    if(!this.hasType()) {
      this.type_ = [] as CodeableConcept[];
    }
  }

  /**
   * @returns the \`specialty\` property value as a CodeableConcept array
   */
  public getSpecialty(): CodeableConcept[] {
    return this.specialty ?? ([] as CodeableConcept[]);
  }

  /**
   * Assigns the provided CodeableConcept array value to the \`specialty\` property.
   *
   * @param value - the \`specialty\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setSpecialty(value: CodeableConcept[] | undefined): this {
    if (isDefinedList<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid HealthcareService.specialty; Provided value array has an element that is not an instance of CodeableConcept.\`;
      assertFhirTypeList<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.specialty = value;
    } else {
      this.specialty = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeableConcept value to the \`specialty\` array property.
   *
   * @param value - the \`specialty\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addSpecialty(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid HealthcareService.specialty; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.initSpecialty();
      this.specialty?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`specialty\` property exists and has a value; \`false\` otherwise
   */
  public hasSpecialty(): boolean {
    return isDefinedList<CodeableConcept>(this.specialty) && this.specialty.some((item: CodeableConcept) => !item.isEmpty());
  }

  /**
   * Initialize the \`specialty\` property
   */
  private initSpecialty(): void {
    if(!this.hasSpecialty()) {
      this.specialty = [] as CodeableConcept[];
    }
  }

  /**
   * @returns the \`location\` property value as a Reference array
   */
  public getLocation(): Reference[] {
    return this.location ?? ([] as Reference[]);
  }

  /**
   * Assigns the provided Reference array value to the \`location\` property.
   *
   * @decorator \`@ReferenceTargets('HealthcareService.location', ['Location',])\`
   *
   * @param value - the \`location\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('HealthcareService.location', [
    'Location',
  ])
  public setLocation(value: Reference[] | undefined): this {
    if (isDefinedList<Reference>(value)) {
      // assertFhirTypeList<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.location = value;
    } else {
      this.location = undefined;
    }
    return this;
  }

  /**
   * Add the provided Reference value to the \`location\` array property.
   *
   * @decorator \`@ReferenceTargets('HealthcareService.location', ['Location',])\`
   *
   * @param value - the \`location\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('HealthcareService.location', [
    'Location',
  ])
  public addLocation(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.initLocation();
      this.location?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`location\` property exists and has a value; \`false\` otherwise
   */
  public hasLocation(): boolean {
    return isDefinedList<Reference>(this.location) && this.location.some((item: Reference) => !item.isEmpty());
  }

  /**
   * Initialize the \`location\` property
   */
  private initLocation(): void {
    if (!this.hasLocation()) {
      this.location = [] as Reference[];
    }
  }

  /**
   * @returns the \`name\` property value as a StringType object if defined; else an empty StringType object
   */
  public getNameElement(): StringType {
    return this.name ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`name\` property.
   *
   * @param element - the \`name\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setNameElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid HealthcareService.name; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.name = element;
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`name\` property exists and has a value; \`false\` otherwise
   */
  public hasNameElement(): boolean {
    return isDefined<StringType>(this.name) && !this.name.isEmpty();
  }

  /**
   * @returns the \`name\` property value as a fhirString if defined; else undefined
   */
  public getName(): fhirString | undefined {
    return this.name?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`name\` property.
   *
   * @param value - the \`name\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setName(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid HealthcareService.name (\${String(value)})\`;
      this.name = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`name\` property exists and has a value; \`false\` otherwise
   */
  public hasName(): boolean {
    return this.hasNameElement();
  }

  /**
   * @returns the \`comment\` property value as a StringType object if defined; else an empty StringType object
   */
  public getCommentElement(): StringType {
    return this.comment ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`comment\` property.
   *
   * @param element - the \`comment\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCommentElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid HealthcareService.comment; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.comment = element;
    } else {
      this.comment = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`comment\` property exists and has a value; \`false\` otherwise
   */
  public hasCommentElement(): boolean {
    return isDefined<StringType>(this.comment) && !this.comment.isEmpty();
  }

  /**
   * @returns the \`comment\` property value as a fhirString if defined; else undefined
   */
  public getComment(): fhirString | undefined {
    return this.comment?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`comment\` property.
   *
   * @param value - the \`comment\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setComment(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid HealthcareService.comment (\${String(value)})\`;
      this.comment = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.comment = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`comment\` property exists and has a value; \`false\` otherwise
   */
  public hasComment(): boolean {
    return this.hasCommentElement();
  }

  /**
   * @returns the \`extraDetails\` property value as a MarkdownType object if defined; else an empty MarkdownType object
   */
  public getExtraDetailsElement(): MarkdownType {
    return this.extraDetails ?? new MarkdownType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`extraDetails\` property.
   *
   * @param element - the \`extraDetails\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setExtraDetailsElement(element: MarkdownType | undefined): this {
    if (isDefined<MarkdownType>(element)) {
      const optErrMsg = \`Invalid HealthcareService.extraDetails; Provided element is not an instance of MarkdownType.\`;
      assertFhirType<MarkdownType>(element, MarkdownType, optErrMsg);
      this.extraDetails = element;
    } else {
      this.extraDetails = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`extraDetails\` property exists and has a value; \`false\` otherwise
   */
  public hasExtraDetailsElement(): boolean {
    return isDefined<MarkdownType>(this.extraDetails) && !this.extraDetails.isEmpty();
  }

  /**
   * @returns the \`extraDetails\` property value as a fhirMarkdown if defined; else undefined
   */
  public getExtraDetails(): fhirMarkdown | undefined {
    return this.extraDetails?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`extraDetails\` property.
   *
   * @param value - the \`extraDetails\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setExtraDetails(value: fhirMarkdown | undefined): this {
    if (isDefined<fhirMarkdown>(value)) {
      const optErrMsg = \`Invalid HealthcareService.extraDetails (\${String(value)})\`;
      this.extraDetails = new MarkdownType(parseFhirPrimitiveData(value, fhirMarkdownSchema, optErrMsg));
    } else {
      this.extraDetails = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`extraDetails\` property exists and has a value; \`false\` otherwise
   */
  public hasExtraDetails(): boolean {
    return this.hasExtraDetailsElement();
  }

  /**
   * @returns the \`photo\` property value as a Attachment object if defined; else an empty Attachment object
   */
  public getPhoto(): Attachment {
    return this.photo ?? new Attachment();
  }

  /**
   * Assigns the provided Photo object value to the \`photo\` property.
   *
   * @param value - the \`photo\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setPhoto(value: Attachment | undefined): this {
    if (isDefined<Attachment>(value)) {
      const optErrMsg = \`Invalid HealthcareService.photo; Provided element is not an instance of Attachment.\`;
      assertFhirType<Attachment>(value, Attachment, optErrMsg);
      this.photo = value;
    } else {
      this.photo = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`photo\` property exists and has a value; \`false\` otherwise
   */
  public hasPhoto(): boolean {
    return isDefined<Attachment>(this.photo) && !this.photo.isEmpty();
  }

  /**
   * @returns the \`telecom\` property value as a ContactPoint array
   */
  public getTelecom(): ContactPoint[] {
    return this.telecom ?? ([] as ContactPoint[]);
  }

  /**
   * Assigns the provided ContactPoint array value to the \`telecom\` property.
   *
   * @param value - the \`telecom\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setTelecom(value: ContactPoint[] | undefined): this {
    if (isDefinedList<ContactPoint>(value)) {
      const optErrMsg = \`Invalid HealthcareService.telecom; Provided value array has an element that is not an instance of ContactPoint.\`;
      assertFhirTypeList<ContactPoint>(value, ContactPoint, optErrMsg);
      this.telecom = value;
    } else {
      this.telecom = undefined;
    }
    return this;
  }

  /**
   * Add the provided ContactPoint value to the \`telecom\` array property.
   *
   * @param value - the \`telecom\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addTelecom(value: ContactPoint | undefined): this {
    if (isDefined<ContactPoint>(value)) {
      const optErrMsg = \`Invalid HealthcareService.telecom; Provided element is not an instance of ContactPoint.\`;
      assertFhirType<ContactPoint>(value, ContactPoint, optErrMsg);
      this.initTelecom();
      this.telecom?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`telecom\` property exists and has a value; \`false\` otherwise
   */
  public hasTelecom(): boolean {
    return isDefinedList<ContactPoint>(this.telecom) && this.telecom.some((item: ContactPoint) => !item.isEmpty());
  }

  /**
   * Initialize the \`telecom\` property
   */
  private initTelecom(): void {
    if(!this.hasTelecom()) {
      this.telecom = [] as ContactPoint[];
    }
  }

  /**
   * @returns the \`coverageArea\` property value as a Reference array
   */
  public getCoverageArea(): Reference[] {
    return this.coverageArea ?? ([] as Reference[]);
  }

  /**
   * Assigns the provided Reference array value to the \`coverageArea\` property.
   *
   * @decorator \`@ReferenceTargets('HealthcareService.coverageArea', ['Location',])\`
   *
   * @param value - the \`coverageArea\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('HealthcareService.coverageArea', [
    'Location',
  ])
  public setCoverageArea(value: Reference[] | undefined): this {
    if (isDefinedList<Reference>(value)) {
      // assertFhirTypeList<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.coverageArea = value;
    } else {
      this.coverageArea = undefined;
    }
    return this;
  }

  /**
   * Add the provided Reference value to the \`coverageArea\` array property.
   *
   * @decorator \`@ReferenceTargets('HealthcareService.coverageArea', ['Location',])\`
   *
   * @param value - the \`coverageArea\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('HealthcareService.coverageArea', [
    'Location',
  ])
  public addCoverageArea(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.initCoverageArea();
      this.coverageArea?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`coverageArea\` property exists and has a value; \`false\` otherwise
   */
  public hasCoverageArea(): boolean {
    return isDefinedList<Reference>(this.coverageArea) && this.coverageArea.some((item: Reference) => !item.isEmpty());
  }

  /**
   * Initialize the \`coverageArea\` property
   */
  private initCoverageArea(): void {
    if (!this.hasCoverageArea()) {
      this.coverageArea = [] as Reference[];
    }
  }

  /**
   * @returns the \`serviceProvisionCode\` property value as a CodeableConcept array
   */
  public getServiceProvisionCode(): CodeableConcept[] {
    return this.serviceProvisionCode ?? ([] as CodeableConcept[]);
  }

  /**
   * Assigns the provided CodeableConcept array value to the \`serviceProvisionCode\` property.
   *
   * @param value - the \`serviceProvisionCode\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setServiceProvisionCode(value: CodeableConcept[] | undefined): this {
    if (isDefinedList<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid HealthcareService.serviceProvisionCode; Provided value array has an element that is not an instance of CodeableConcept.\`;
      assertFhirTypeList<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.serviceProvisionCode = value;
    } else {
      this.serviceProvisionCode = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeableConcept value to the \`serviceProvisionCode\` array property.
   *
   * @param value - the \`serviceProvisionCode\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addServiceProvisionCode(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid HealthcareService.serviceProvisionCode; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.initServiceProvisionCode();
      this.serviceProvisionCode?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`serviceProvisionCode\` property exists and has a value; \`false\` otherwise
   */
  public hasServiceProvisionCode(): boolean {
    return isDefinedList<CodeableConcept>(this.serviceProvisionCode) && this.serviceProvisionCode.some((item: CodeableConcept) => !item.isEmpty());
  }

  /**
   * Initialize the \`serviceProvisionCode\` property
   */
  private initServiceProvisionCode(): void {
    if(!this.hasServiceProvisionCode()) {
      this.serviceProvisionCode = [] as CodeableConcept[];
    }
  }

  /**
   * @returns the \`eligibility\` property value as a HealthcareServiceEligibilityComponent array
   */
  public getEligibility(): HealthcareServiceEligibilityComponent[] {
    return this.eligibility ?? ([] as HealthcareServiceEligibilityComponent[]);
  }

  /**
   * Assigns the provided HealthcareServiceEligibilityComponent array value to the \`eligibility\` property.
   *
   * @param value - the \`eligibility\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setEligibility(value: HealthcareServiceEligibilityComponent[] | undefined): this {
    if (isDefinedList<HealthcareServiceEligibilityComponent>(value)) {
      const optErrMsg = \`Invalid HealthcareService.eligibility; Provided value array has an element that is not an instance of HealthcareServiceEligibilityComponent.\`;
      assertFhirTypeList<HealthcareServiceEligibilityComponent>(value, HealthcareServiceEligibilityComponent, optErrMsg);
      this.eligibility = value;
    } else {
      this.eligibility = undefined;
    }
    return this;
  }

  /**
   * Add the provided HealthcareServiceEligibilityComponent value to the \`eligibility\` array property.
   *
   * @param value - the \`eligibility\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addEligibility(value: HealthcareServiceEligibilityComponent | undefined): this {
    if (isDefined<HealthcareServiceEligibilityComponent>(value)) {
      const optErrMsg = \`Invalid HealthcareService.eligibility; Provided element is not an instance of HealthcareServiceEligibilityComponent.\`;
      assertFhirType<HealthcareServiceEligibilityComponent>(value, HealthcareServiceEligibilityComponent, optErrMsg);
      this.initEligibility();
      this.eligibility?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`eligibility\` property exists and has a value; \`false\` otherwise
   */
  public hasEligibility(): boolean {
    return isDefinedList<HealthcareServiceEligibilityComponent>(this.eligibility) && this.eligibility.some((item: HealthcareServiceEligibilityComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`eligibility\` property
   */
  private initEligibility(): void {
    if(!this.hasEligibility()) {
      this.eligibility = [] as HealthcareServiceEligibilityComponent[];
    }
  }

  /**
   * @returns the \`program\` property value as a CodeableConcept array
   */
  public getProgram(): CodeableConcept[] {
    return this.program ?? ([] as CodeableConcept[]);
  }

  /**
   * Assigns the provided CodeableConcept array value to the \`program\` property.
   *
   * @param value - the \`program\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setProgram(value: CodeableConcept[] | undefined): this {
    if (isDefinedList<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid HealthcareService.program; Provided value array has an element that is not an instance of CodeableConcept.\`;
      assertFhirTypeList<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.program = value;
    } else {
      this.program = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeableConcept value to the \`program\` array property.
   *
   * @param value - the \`program\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addProgram(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid HealthcareService.program; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.initProgram();
      this.program?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`program\` property exists and has a value; \`false\` otherwise
   */
  public hasProgram(): boolean {
    return isDefinedList<CodeableConcept>(this.program) && this.program.some((item: CodeableConcept) => !item.isEmpty());
  }

  /**
   * Initialize the \`program\` property
   */
  private initProgram(): void {
    if(!this.hasProgram()) {
      this.program = [] as CodeableConcept[];
    }
  }

  /**
   * @returns the \`characteristic\` property value as a CodeableConcept array
   */
  public getCharacteristic(): CodeableConcept[] {
    return this.characteristic ?? ([] as CodeableConcept[]);
  }

  /**
   * Assigns the provided CodeableConcept array value to the \`characteristic\` property.
   *
   * @param value - the \`characteristic\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setCharacteristic(value: CodeableConcept[] | undefined): this {
    if (isDefinedList<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid HealthcareService.characteristic; Provided value array has an element that is not an instance of CodeableConcept.\`;
      assertFhirTypeList<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.characteristic = value;
    } else {
      this.characteristic = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeableConcept value to the \`characteristic\` array property.
   *
   * @param value - the \`characteristic\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addCharacteristic(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid HealthcareService.characteristic; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.initCharacteristic();
      this.characteristic?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`characteristic\` property exists and has a value; \`false\` otherwise
   */
  public hasCharacteristic(): boolean {
    return isDefinedList<CodeableConcept>(this.characteristic) && this.characteristic.some((item: CodeableConcept) => !item.isEmpty());
  }

  /**
   * Initialize the \`characteristic\` property
   */
  private initCharacteristic(): void {
    if(!this.hasCharacteristic()) {
      this.characteristic = [] as CodeableConcept[];
    }
  }

  /**
   * @returns the \`communication\` property value as a CodeableConcept array
   */
  public getCommunication(): CodeableConcept[] {
    return this.communication ?? ([] as CodeableConcept[]);
  }

  /**
   * Assigns the provided CodeableConcept array value to the \`communication\` property.
   *
   * @param value - the \`communication\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setCommunication(value: CodeableConcept[] | undefined): this {
    if (isDefinedList<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid HealthcareService.communication; Provided value array has an element that is not an instance of CodeableConcept.\`;
      assertFhirTypeList<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.communication = value;
    } else {
      this.communication = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeableConcept value to the \`communication\` array property.
   *
   * @param value - the \`communication\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addCommunication(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid HealthcareService.communication; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.initCommunication();
      this.communication?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`communication\` property exists and has a value; \`false\` otherwise
   */
  public hasCommunication(): boolean {
    return isDefinedList<CodeableConcept>(this.communication) && this.communication.some((item: CodeableConcept) => !item.isEmpty());
  }

  /**
   * Initialize the \`communication\` property
   */
  private initCommunication(): void {
    if(!this.hasCommunication()) {
      this.communication = [] as CodeableConcept[];
    }
  }

  /**
   * @returns the \`referralMethod\` property value as a CodeableConcept array
   */
  public getReferralMethod(): CodeableConcept[] {
    return this.referralMethod ?? ([] as CodeableConcept[]);
  }

  /**
   * Assigns the provided CodeableConcept array value to the \`referralMethod\` property.
   *
   * @param value - the \`referralMethod\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setReferralMethod(value: CodeableConcept[] | undefined): this {
    if (isDefinedList<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid HealthcareService.referralMethod; Provided value array has an element that is not an instance of CodeableConcept.\`;
      assertFhirTypeList<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.referralMethod = value;
    } else {
      this.referralMethod = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeableConcept value to the \`referralMethod\` array property.
   *
   * @param value - the \`referralMethod\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addReferralMethod(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid HealthcareService.referralMethod; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.initReferralMethod();
      this.referralMethod?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`referralMethod\` property exists and has a value; \`false\` otherwise
   */
  public hasReferralMethod(): boolean {
    return isDefinedList<CodeableConcept>(this.referralMethod) && this.referralMethod.some((item: CodeableConcept) => !item.isEmpty());
  }

  /**
   * Initialize the \`referralMethod\` property
   */
  private initReferralMethod(): void {
    if(!this.hasReferralMethod()) {
      this.referralMethod = [] as CodeableConcept[];
    }
  }

  /**
   * @returns the \`appointmentRequired\` property value as a BooleanType object if defined; else an empty BooleanType object
   */
  public getAppointmentRequiredElement(): BooleanType {
    return this.appointmentRequired ?? new BooleanType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`appointmentRequired\` property.
   *
   * @param element - the \`appointmentRequired\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAppointmentRequiredElement(element: BooleanType | undefined): this {
    if (isDefined<BooleanType>(element)) {
      const optErrMsg = \`Invalid HealthcareService.appointmentRequired; Provided element is not an instance of BooleanType.\`;
      assertFhirType<BooleanType>(element, BooleanType, optErrMsg);
      this.appointmentRequired = element;
    } else {
      this.appointmentRequired = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`appointmentRequired\` property exists and has a value; \`false\` otherwise
   */
  public hasAppointmentRequiredElement(): boolean {
    return isDefined<BooleanType>(this.appointmentRequired) && !this.appointmentRequired.isEmpty();
  }

  /**
   * @returns the \`appointmentRequired\` property value as a fhirBoolean if defined; else undefined
   */
  public getAppointmentRequired(): fhirBoolean | undefined {
    return this.appointmentRequired?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`appointmentRequired\` property.
   *
   * @param value - the \`appointmentRequired\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAppointmentRequired(value: fhirBoolean | undefined): this {
    if (isDefined<fhirBoolean>(value)) {
      const optErrMsg = \`Invalid HealthcareService.appointmentRequired (\${String(value)})\`;
      this.appointmentRequired = new BooleanType(parseFhirPrimitiveData(value, fhirBooleanSchema, optErrMsg));
    } else {
      this.appointmentRequired = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`appointmentRequired\` property exists and has a value; \`false\` otherwise
   */
  public hasAppointmentRequired(): boolean {
    return this.hasAppointmentRequiredElement();
  }

  /**
   * @returns the \`availableTime\` property value as a HealthcareServiceAvailableTimeComponent array
   */
  public getAvailableTime(): HealthcareServiceAvailableTimeComponent[] {
    return this.availableTime ?? ([] as HealthcareServiceAvailableTimeComponent[]);
  }

  /**
   * Assigns the provided HealthcareServiceAvailableTimeComponent array value to the \`availableTime\` property.
   *
   * @param value - the \`availableTime\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setAvailableTime(value: HealthcareServiceAvailableTimeComponent[] | undefined): this {
    if (isDefinedList<HealthcareServiceAvailableTimeComponent>(value)) {
      const optErrMsg = \`Invalid HealthcareService.availableTime; Provided value array has an element that is not an instance of HealthcareServiceAvailableTimeComponent.\`;
      assertFhirTypeList<HealthcareServiceAvailableTimeComponent>(value, HealthcareServiceAvailableTimeComponent, optErrMsg);
      this.availableTime = value;
    } else {
      this.availableTime = undefined;
    }
    return this;
  }

  /**
   * Add the provided HealthcareServiceAvailableTimeComponent value to the \`availableTime\` array property.
   *
   * @param value - the \`availableTime\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addAvailableTime(value: HealthcareServiceAvailableTimeComponent | undefined): this {
    if (isDefined<HealthcareServiceAvailableTimeComponent>(value)) {
      const optErrMsg = \`Invalid HealthcareService.availableTime; Provided element is not an instance of HealthcareServiceAvailableTimeComponent.\`;
      assertFhirType<HealthcareServiceAvailableTimeComponent>(value, HealthcareServiceAvailableTimeComponent, optErrMsg);
      this.initAvailableTime();
      this.availableTime?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`availableTime\` property exists and has a value; \`false\` otherwise
   */
  public hasAvailableTime(): boolean {
    return isDefinedList<HealthcareServiceAvailableTimeComponent>(this.availableTime) && this.availableTime.some((item: HealthcareServiceAvailableTimeComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`availableTime\` property
   */
  private initAvailableTime(): void {
    if(!this.hasAvailableTime()) {
      this.availableTime = [] as HealthcareServiceAvailableTimeComponent[];
    }
  }

  /**
   * @returns the \`notAvailable\` property value as a HealthcareServiceNotAvailableComponent array
   */
  public getNotAvailable(): HealthcareServiceNotAvailableComponent[] {
    return this.notAvailable ?? ([] as HealthcareServiceNotAvailableComponent[]);
  }

  /**
   * Assigns the provided HealthcareServiceNotAvailableComponent array value to the \`notAvailable\` property.
   *
   * @param value - the \`notAvailable\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setNotAvailable(value: HealthcareServiceNotAvailableComponent[] | undefined): this {
    if (isDefinedList<HealthcareServiceNotAvailableComponent>(value)) {
      const optErrMsg = \`Invalid HealthcareService.notAvailable; Provided value array has an element that is not an instance of HealthcareServiceNotAvailableComponent.\`;
      assertFhirTypeList<HealthcareServiceNotAvailableComponent>(value, HealthcareServiceNotAvailableComponent, optErrMsg);
      this.notAvailable = value;
    } else {
      this.notAvailable = undefined;
    }
    return this;
  }

  /**
   * Add the provided HealthcareServiceNotAvailableComponent value to the \`notAvailable\` array property.
   *
   * @param value - the \`notAvailable\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addNotAvailable(value: HealthcareServiceNotAvailableComponent | undefined): this {
    if (isDefined<HealthcareServiceNotAvailableComponent>(value)) {
      const optErrMsg = \`Invalid HealthcareService.notAvailable; Provided element is not an instance of HealthcareServiceNotAvailableComponent.\`;
      assertFhirType<HealthcareServiceNotAvailableComponent>(value, HealthcareServiceNotAvailableComponent, optErrMsg);
      this.initNotAvailable();
      this.notAvailable?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`notAvailable\` property exists and has a value; \`false\` otherwise
   */
  public hasNotAvailable(): boolean {
    return isDefinedList<HealthcareServiceNotAvailableComponent>(this.notAvailable) && this.notAvailable.some((item: HealthcareServiceNotAvailableComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`notAvailable\` property
   */
  private initNotAvailable(): void {
    if(!this.hasNotAvailable()) {
      this.notAvailable = [] as HealthcareServiceNotAvailableComponent[];
    }
  }

  /**
   * @returns the \`availabilityExceptions\` property value as a StringType object if defined; else an empty StringType object
   */
  public getAvailabilityExceptionsElement(): StringType {
    return this.availabilityExceptions ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`availabilityExceptions\` property.
   *
   * @param element - the \`availabilityExceptions\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAvailabilityExceptionsElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid HealthcareService.availabilityExceptions; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.availabilityExceptions = element;
    } else {
      this.availabilityExceptions = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`availabilityExceptions\` property exists and has a value; \`false\` otherwise
   */
  public hasAvailabilityExceptionsElement(): boolean {
    return isDefined<StringType>(this.availabilityExceptions) && !this.availabilityExceptions.isEmpty();
  }

  /**
   * @returns the \`availabilityExceptions\` property value as a fhirString if defined; else undefined
   */
  public getAvailabilityExceptions(): fhirString | undefined {
    return this.availabilityExceptions?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`availabilityExceptions\` property.
   *
   * @param value - the \`availabilityExceptions\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAvailabilityExceptions(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid HealthcareService.availabilityExceptions (\${String(value)})\`;
      this.availabilityExceptions = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.availabilityExceptions = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`availabilityExceptions\` property exists and has a value; \`false\` otherwise
   */
  public hasAvailabilityExceptions(): boolean {
    return this.hasAvailabilityExceptionsElement();
  }

  /**
   * @returns the \`endpoint\` property value as a Reference array
   */
  public getEndpoint(): Reference[] {
    return this.endpoint ?? ([] as Reference[]);
  }

  /**
   * Assigns the provided Reference array value to the \`endpoint\` property.
   *
   * @decorator \`@ReferenceTargets('HealthcareService.endpoint', ['Endpoint',])\`
   *
   * @param value - the \`endpoint\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('HealthcareService.endpoint', [
    'Endpoint',
  ])
  public setEndpoint(value: Reference[] | undefined): this {
    if (isDefinedList<Reference>(value)) {
      // assertFhirTypeList<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.endpoint = value;
    } else {
      this.endpoint = undefined;
    }
    return this;
  }

  /**
   * Add the provided Reference value to the \`endpoint\` array property.
   *
   * @decorator \`@ReferenceTargets('HealthcareService.endpoint', ['Endpoint',])\`
   *
   * @param value - the \`endpoint\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('HealthcareService.endpoint', [
    'Endpoint',
  ])
  public addEndpoint(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.initEndpoint();
      this.endpoint?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`endpoint\` property exists and has a value; \`false\` otherwise
   */
  public hasEndpoint(): boolean {
    return isDefinedList<Reference>(this.endpoint) && this.endpoint.some((item: Reference) => !item.isEmpty());
  }

  /**
   * Initialize the \`endpoint\` property
   */
  private initEndpoint(): void {
    if (!this.hasEndpoint()) {
      this.endpoint = [] as Reference[];
    }
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'HealthcareService';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.identifier,
      this.active,
      this.providedBy,
      this.category,
      this.type_,
      this.specialty,
      this.location,
      this.name,
      this.comment,
      this.extraDetails,
      this.photo,
      this.telecom,
      this.coverageArea,
      this.serviceProvisionCode,
      this.eligibility,
      this.program,
      this.characteristic,
      this.communication,
      this.referralMethod,
      this.appointmentRequired,
      this.availableTime,
      this.notAvailable,
      this.availabilityExceptions,
      this.endpoint,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): HealthcareService {
    const dest = new HealthcareService();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: HealthcareService): void {
    super.copyValues(dest);
    const identifierList = copyListValues<Identifier>(this.identifier);
    dest.identifier = identifierList.length === 0 ? undefined : identifierList;
    dest.active = this.active?.copy();
    dest.providedBy = this.providedBy?.copy();
    const categoryList = copyListValues<CodeableConcept>(this.category);
    dest.category = categoryList.length === 0 ? undefined : categoryList;
    const typeList = copyListValues<CodeableConcept>(this.type_);
    dest.type_ = typeList.length === 0 ? undefined : typeList;
    const specialtyList = copyListValues<CodeableConcept>(this.specialty);
    dest.specialty = specialtyList.length === 0 ? undefined : specialtyList;
    const locationList = copyListValues<Reference>(this.location);
    dest.location = locationList.length === 0 ? undefined : locationList;
    dest.name = this.name?.copy();
    dest.comment = this.comment?.copy();
    dest.extraDetails = this.extraDetails?.copy();
    dest.photo = this.photo?.copy();
    const telecomList = copyListValues<ContactPoint>(this.telecom);
    dest.telecom = telecomList.length === 0 ? undefined : telecomList;
    const coverageAreaList = copyListValues<Reference>(this.coverageArea);
    dest.coverageArea = coverageAreaList.length === 0 ? undefined : coverageAreaList;
    const serviceProvisionCodeList = copyListValues<CodeableConcept>(this.serviceProvisionCode);
    dest.serviceProvisionCode = serviceProvisionCodeList.length === 0 ? undefined : serviceProvisionCodeList;
    const eligibilityList = copyListValues<HealthcareServiceEligibilityComponent>(this.eligibility);
    dest.eligibility = eligibilityList.length === 0 ? undefined : eligibilityList;
    const programList = copyListValues<CodeableConcept>(this.program);
    dest.program = programList.length === 0 ? undefined : programList;
    const characteristicList = copyListValues<CodeableConcept>(this.characteristic);
    dest.characteristic = characteristicList.length === 0 ? undefined : characteristicList;
    const communicationList = copyListValues<CodeableConcept>(this.communication);
    dest.communication = communicationList.length === 0 ? undefined : communicationList;
    const referralMethodList = copyListValues<CodeableConcept>(this.referralMethod);
    dest.referralMethod = referralMethodList.length === 0 ? undefined : referralMethodList;
    dest.appointmentRequired = this.appointmentRequired?.copy();
    const availableTimeList = copyListValues<HealthcareServiceAvailableTimeComponent>(this.availableTime);
    dest.availableTime = availableTimeList.length === 0 ? undefined : availableTimeList;
    const notAvailableList = copyListValues<HealthcareServiceNotAvailableComponent>(this.notAvailable);
    dest.notAvailable = notAvailableList.length === 0 ? undefined : notAvailableList;
    dest.availabilityExceptions = this.availabilityExceptions?.copy();
    const endpointList = copyListValues<Reference>(this.endpoint);
    dest.endpoint = endpointList.length === 0 ? undefined : endpointList;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasIdentifier()) {
      setFhirComplexListJson(this.getIdentifier(), 'identifier', jsonObj);
    }

    if (this.hasActiveElement()) {
      setFhirPrimitiveJson<fhirBoolean>(this.getActiveElement(), 'active', jsonObj);
    }

    if (this.hasProvidedBy()) {
      setFhirComplexJson(this.getProvidedBy(), 'providedBy', jsonObj);
    }

    if (this.hasCategory()) {
      setFhirComplexListJson(this.getCategory(), 'category', jsonObj);
    }

    if (this.hasType()) {
      setFhirComplexListJson(this.getType(), 'type', jsonObj);
    }

    if (this.hasSpecialty()) {
      setFhirComplexListJson(this.getSpecialty(), 'specialty', jsonObj);
    }

    if (this.hasLocation()) {
      setFhirComplexListJson(this.getLocation(), 'location', jsonObj);
    }

    if (this.hasNameElement()) {
      setFhirPrimitiveJson<fhirString>(this.getNameElement(), 'name', jsonObj);
    }

    if (this.hasCommentElement()) {
      setFhirPrimitiveJson<fhirString>(this.getCommentElement(), 'comment', jsonObj);
    }

    if (this.hasExtraDetailsElement()) {
      setFhirPrimitiveJson<fhirMarkdown>(this.getExtraDetailsElement(), 'extraDetails', jsonObj);
    }

    if (this.hasPhoto()) {
      setFhirComplexJson(this.getPhoto(), 'photo', jsonObj);
    }

    if (this.hasTelecom()) {
      setFhirComplexListJson(this.getTelecom(), 'telecom', jsonObj);
    }

    if (this.hasCoverageArea()) {
      setFhirComplexListJson(this.getCoverageArea(), 'coverageArea', jsonObj);
    }

    if (this.hasServiceProvisionCode()) {
      setFhirComplexListJson(this.getServiceProvisionCode(), 'serviceProvisionCode', jsonObj);
    }

    if (this.hasEligibility()) {
      setFhirBackboneElementListJson(this.getEligibility(), 'eligibility', jsonObj);
    }

    if (this.hasProgram()) {
      setFhirComplexListJson(this.getProgram(), 'program', jsonObj);
    }

    if (this.hasCharacteristic()) {
      setFhirComplexListJson(this.getCharacteristic(), 'characteristic', jsonObj);
    }

    if (this.hasCommunication()) {
      setFhirComplexListJson(this.getCommunication(), 'communication', jsonObj);
    }

    if (this.hasReferralMethod()) {
      setFhirComplexListJson(this.getReferralMethod(), 'referralMethod', jsonObj);
    }

    if (this.hasAppointmentRequiredElement()) {
      setFhirPrimitiveJson<fhirBoolean>(this.getAppointmentRequiredElement(), 'appointmentRequired', jsonObj);
    }

    if (this.hasAvailableTime()) {
      setFhirBackboneElementListJson(this.getAvailableTime(), 'availableTime', jsonObj);
    }

    if (this.hasNotAvailable()) {
      setFhirBackboneElementListJson(this.getNotAvailable(), 'notAvailable', jsonObj);
    }

    if (this.hasAvailabilityExceptionsElement()) {
      setFhirPrimitiveJson<fhirString>(this.getAvailabilityExceptionsElement(), 'availabilityExceptions', jsonObj);
    }

    if (this.hasEndpoint()) {
      setFhirComplexListJson(this.getEndpoint(), 'endpoint', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * HealthcareServiceEligibilityComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Specific eligibility requirements required to use the service
 * - **Definition:** Does this service have specific eligibility requirements that need to be met in order to use the service?
 *
 * @category Data Models: Resource
 * @see [FHIR HealthcareService](http://hl7.org/fhir/StructureDefinition/HealthcareService)
 */
export class HealthcareServiceEligibilityComponent extends BackboneElement implements IBackboneElement {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`HealthcareServiceEligibilityComponent\` JSON to instantiate the HealthcareServiceEligibilityComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`HealthcareServiceEligibilityComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to HealthcareServiceEligibilityComponent
   * @returns HealthcareServiceEligibilityComponent data model or undefined for \`HealthcareServiceEligibilityComponent\`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): HealthcareServiceEligibilityComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'HealthcareServiceEligibilityComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new HealthcareServiceEligibilityComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    

    fieldName = 'code';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = CodeableConcept.parse(classJsonObj[fieldName]!, sourceField);
      instance.setCode(datatype);
    }

    fieldName = 'comment';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: MarkdownType | undefined = fhirParser.parseMarkdownType(dtJson, dtSiblingJson);
      instance.setCommentElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * HealthcareService.eligibility.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Coded value for the eligibility
   * - **Definition:** Coded value for the eligibility.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private code?: CodeableConcept | undefined;

  /**
   * HealthcareService.eligibility.comment Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Describes the eligibility conditions for the service
   * - **Definition:** Describes the eligibility conditions for the service.
   * - **Comment:** The description of service eligibility should, in general, not exceed one or two paragraphs. It should be sufficient for a prospective consumer to determine if they are likely to be eligible or not. Where eligibility requirements and conditions are complex, it may simply be noted that an eligibility assessment is required. Where eligibility is determined by an outside source, such as an Act of Parliament, this should be noted, preferably with a reference to a commonly available copy of the source document such as a web page.
   * - **FHIR Type:** \`markdown\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private comment?: MarkdownType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`code\` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getCode(): CodeableConcept {
    return this.code ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Code object value to the \`code\` property.
   *
   * @param value - the \`code\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setCode(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid HealthcareService.eligibility.code; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.code = value;
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`code\` property exists and has a value; \`false\` otherwise
   */
  public hasCode(): boolean {
    return isDefined<CodeableConcept>(this.code) && !this.code.isEmpty();
  }

  /**
   * @returns the \`comment\` property value as a MarkdownType object if defined; else an empty MarkdownType object
   */
  public getCommentElement(): MarkdownType {
    return this.comment ?? new MarkdownType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`comment\` property.
   *
   * @param element - the \`comment\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCommentElement(element: MarkdownType | undefined): this {
    if (isDefined<MarkdownType>(element)) {
      const optErrMsg = \`Invalid HealthcareService.eligibility.comment; Provided element is not an instance of MarkdownType.\`;
      assertFhirType<MarkdownType>(element, MarkdownType, optErrMsg);
      this.comment = element;
    } else {
      this.comment = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`comment\` property exists and has a value; \`false\` otherwise
   */
  public hasCommentElement(): boolean {
    return isDefined<MarkdownType>(this.comment) && !this.comment.isEmpty();
  }

  /**
   * @returns the \`comment\` property value as a fhirMarkdown if defined; else undefined
   */
  public getComment(): fhirMarkdown | undefined {
    return this.comment?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`comment\` property.
   *
   * @param value - the \`comment\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setComment(value: fhirMarkdown | undefined): this {
    if (isDefined<fhirMarkdown>(value)) {
      const optErrMsg = \`Invalid HealthcareService.eligibility.comment (\${String(value)})\`;
      this.comment = new MarkdownType(parseFhirPrimitiveData(value, fhirMarkdownSchema, optErrMsg));
    } else {
      this.comment = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`comment\` property exists and has a value; \`false\` otherwise
   */
  public hasComment(): boolean {
    return this.hasCommentElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'HealthcareService.eligibility';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.code,
      this.comment,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): HealthcareServiceEligibilityComponent {
    const dest = new HealthcareServiceEligibilityComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: HealthcareServiceEligibilityComponent): void {
    super.copyValues(dest);
    dest.code = this.code?.copy();
    dest.comment = this.comment?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasCode()) {
      setFhirComplexJson(this.getCode(), 'code', jsonObj);
    }

    if (this.hasCommentElement()) {
      setFhirPrimitiveJson<fhirMarkdown>(this.getCommentElement(), 'comment', jsonObj);
    }

    return jsonObj;
  }
}
/**
 * HealthcareServiceAvailableTimeComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Times the Service Site is available
 * - **Definition:** A collection of times that the Service Site is available.
 * - **Comment:** More detailed availability information may be provided in associated Schedule/Slot resources.
 *
 * @category Data Models: Resource
 * @see [FHIR HealthcareService](http://hl7.org/fhir/StructureDefinition/HealthcareService)
 */
export class HealthcareServiceAvailableTimeComponent extends BackboneElement implements IBackboneElement {
  constructor() {
    super();

    this.daysOfWeekEnum = new DaysOfWeekEnum();
  }

  /**
   * Parse the provided \`HealthcareServiceAvailableTimeComponent\` JSON to instantiate the HealthcareServiceAvailableTimeComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`HealthcareServiceAvailableTimeComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to HealthcareServiceAvailableTimeComponent
   * @returns HealthcareServiceAvailableTimeComponent data model or undefined for \`HealthcareServiceAvailableTimeComponent\`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): HealthcareServiceAvailableTimeComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'HealthcareServiceAvailableTimeComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new HealthcareServiceAvailableTimeComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'daysOfWeek';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: CodeType | undefined = fhirParser.parseCodeType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addDaysOfWeekElement(datatype);
        }
      });
    }

    fieldName = 'allDay';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'boolean';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: BooleanType | undefined = fhirParser.parseBooleanType(dtJson, dtSiblingJson);
      instance.setAllDayElement(datatype);
    }

    fieldName = 'availableStartTime';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: TimeType | undefined = fhirParser.parseTimeType(dtJson, dtSiblingJson);
      instance.setAvailableStartTimeElement(datatype);
    }

    fieldName = 'availableEndTime';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: TimeType | undefined = fhirParser.parseTimeType(dtJson, dtSiblingJson);
      instance.setAvailableEndTimeElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: DaysOfWeek
   *
   * @see {@link DaysOfWeekEnum }
   */
  private readonly daysOfWeekEnum: DaysOfWeekEnum;

  /**
   * HealthcareService.availableTime.daysOfWeek Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** mon | tue | wed | thu | fri | sat | sun
   * - **Definition:** Indicates which days of the week are available between the start and end Times.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  private daysOfWeek?: EnumCodeType[] | undefined;

  /**
   * HealthcareService.availableTime.allDay Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Always available? e.g. 24 hour service
   * - **Definition:** Is this always available? (hence times are irrelevant) e.g. 24 hour service.
   * - **FHIR Type:** \`boolean\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private allDay?: BooleanType | undefined;

  /**
   * HealthcareService.availableTime.availableStartTime Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Opening time of day (ignored if allDay = true)
   * - **Definition:** The opening time of day. Note: If the AllDay flag is set, then this time is ignored.
   * - **Comment:** The time zone is expected to be for where this HealthcareService is provided at.
   * - **FHIR Type:** \`time\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private availableStartTime?: TimeType | undefined;

  /**
   * HealthcareService.availableTime.availableEndTime Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Closing time of day (ignored if allDay = true)
   * - **Definition:** The closing time of day. Note: If the AllDay flag is set, then this time is ignored.
   * - **Comment:** The time zone is expected to be for where this HealthcareService is provided at.
   * - **FHIR Type:** \`time\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private availableEndTime?: TimeType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`daysOfWeek\` property value as a EnumCodeType array
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public getDaysOfWeekEnumType(): EnumCodeType[] {
    return this.daysOfWeek ?? ([] as EnumCodeType[]);
  }

  /**
   * Assigns the provided EnumCodeType array value to the \`daysOfWeek\` property.
   *
   * @param enumType - the \`daysOfWeek\` array value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public setDaysOfWeekEnumType(enumType: EnumCodeType[] | undefined): this {
    if (isDefinedList<EnumCodeType>(enumType)) {
      const errMsgPrefix = \`Invalid HealthcareService.availableTime.daysOfWeek\`;
      assertEnumCodeTypeList<DaysOfWeekEnum>(enumType, DaysOfWeekEnum, errMsgPrefix);
      this.daysOfWeek = enumType;
    } else {
      this.daysOfWeek = undefined;
    }
    return this;
  }

  /**
   * Add the provided EnumCodeType value to the \`daysOfWeek\` array property.
   *
   * @param enumType - the \`daysOfWeek\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public addDaysOfWeekEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = \`Invalid HealthcareService.availableTime.daysOfWeek\`;
      assertEnumCodeType<DaysOfWeekEnum>(enumType, DaysOfWeekEnum, errMsgPrefix);
      this.initDaysOfWeek();
      this.daysOfWeek?.push(enumType);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`daysOfWeek\` property exists and has a value; \`false\` otherwise
   */
  public hasDaysOfWeekEnumType(): boolean {
    return isDefinedList<EnumCodeType>(this.daysOfWeek) && this.daysOfWeek.some((item: EnumCodeType) => !item.isEmpty()) && this.daysOfWeek.every((item: EnumCodeType) => item.fhirCodeEnumeration.length > 0);
  }

  /**
   * @returns the \`daysOfWeek\` property value as a CodeType array
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public getDaysOfWeekElement(): CodeType[] {
    if (this.daysOfWeek === undefined) {
      return [] as CodeType[];
    }
    return this.daysOfWeek as CodeType[];
  }

  /**
   * Assigns the provided PrimitiveType array value to the \`daysOfWeek\` property.
   *
   * @param element - the \`daysOfWeek\` array value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public setDaysOfWeekElement(element: CodeType[] | undefined): this {
    if (isDefinedList<CodeType>(element)) {
      const optErrMsg = \`Invalid HealthcareService.availableTime.daysOfWeek; Provided element array has an element that is not an instance of CodeType.\`;
      assertFhirTypeList<CodeType>(element, CodeType, optErrMsg);
      const enumCodeTypes = [] as EnumCodeType[];
      element.forEach((type: CodeType) => {
        enumCodeTypes.push(new EnumCodeType(type, this.daysOfWeekEnum));
      });
      this.daysOfWeek = enumCodeTypes;
    } else {
      this.daysOfWeek = undefined;
    }
    return this;
  }

  /**
   * Add the provided PrimitiveType value to the \`daysOfWeek\` array property.
   *
   * @param element - the \`daysOfWeek\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public addDaysOfWeekElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid HealthcareService.availableTime.daysOfWeek; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.initDaysOfWeek();
      this.daysOfWeek?.push(new EnumCodeType(element, this.daysOfWeekEnum));
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`daysOfWeek\` property exists and has a value; \`false\` otherwise
   */
  public hasDaysOfWeekElement(): boolean {
    return this.hasDaysOfWeekEnumType();
  }

  /**
   * @returns the \`daysOfWeek\` property value as a fhirCode array
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public getDaysOfWeek(): fhirCode[] {
    if (this.daysOfWeek === undefined) {
      return [] as fhirCode[];
    }
    const values = [] as fhirCode[];
    for (const item of this.daysOfWeek) {
      values.push(item.fhirCode.code);
    }
    return values;
  }

  /**
   * Assigns the provided primitive value array to the \`daysOfWeek\` property.
   *
   * @param value - the \`daysOfWeek\` value array
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public setDaysOfWeek(value: fhirCode[] | undefined): this {
    if (isDefinedList<fhirCode>(value)) {
      const enumCodeTypes = [] as EnumCodeType[];
      const optErrMsg = \`Invalid HealthcareService.availableTime.daysOfWeek; Provided value is not an instance of fhirCode.\`;
      value.forEach((val: fhirCode) => {
        enumCodeTypes.push(new EnumCodeType(parseFhirPrimitiveData(val, fhirCodeSchema, optErrMsg), this.daysOfWeekEnum));
      });
      this.daysOfWeek = enumCodeTypes;
    } else {
      this.daysOfWeek = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`daysOfWeek\` array property.
   *
   * @param value - the \`daysOfWeek\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public addDaysOfWeek(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      this.initDaysOfWeek();
      const optErrMsg = \`Invalid HealthcareService.availableTime.daysOfWeek; Provided value is not an instance of fhirCode.\`;
      this.daysOfWeek?.push(new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.daysOfWeekEnum));
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`daysOfWeek\` property exists and has a value; \`false\` otherwise
   */
  public hasDaysOfWeek(): boolean {
    return this.hasDaysOfWeekEnumType();
  }

  /**
   * Initialize the daysOfWeek property
   */
  private initDaysOfWeek(): void {
    if(!this.hasDaysOfWeekEnumType()) {
      this.daysOfWeek = [] as EnumCodeType[];
    }
  }

  /**
   * @returns the \`allDay\` property value as a BooleanType object if defined; else an empty BooleanType object
   */
  public getAllDayElement(): BooleanType {
    return this.allDay ?? new BooleanType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`allDay\` property.
   *
   * @param element - the \`allDay\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAllDayElement(element: BooleanType | undefined): this {
    if (isDefined<BooleanType>(element)) {
      const optErrMsg = \`Invalid HealthcareService.availableTime.allDay; Provided element is not an instance of BooleanType.\`;
      assertFhirType<BooleanType>(element, BooleanType, optErrMsg);
      this.allDay = element;
    } else {
      this.allDay = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`allDay\` property exists and has a value; \`false\` otherwise
   */
  public hasAllDayElement(): boolean {
    return isDefined<BooleanType>(this.allDay) && !this.allDay.isEmpty();
  }

  /**
   * @returns the \`allDay\` property value as a fhirBoolean if defined; else undefined
   */
  public getAllDay(): fhirBoolean | undefined {
    return this.allDay?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`allDay\` property.
   *
   * @param value - the \`allDay\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAllDay(value: fhirBoolean | undefined): this {
    if (isDefined<fhirBoolean>(value)) {
      const optErrMsg = \`Invalid HealthcareService.availableTime.allDay (\${String(value)})\`;
      this.allDay = new BooleanType(parseFhirPrimitiveData(value, fhirBooleanSchema, optErrMsg));
    } else {
      this.allDay = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`allDay\` property exists and has a value; \`false\` otherwise
   */
  public hasAllDay(): boolean {
    return this.hasAllDayElement();
  }

  /**
   * @returns the \`availableStartTime\` property value as a TimeType object if defined; else an empty TimeType object
   */
  public getAvailableStartTimeElement(): TimeType {
    return this.availableStartTime ?? new TimeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`availableStartTime\` property.
   *
   * @param element - the \`availableStartTime\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAvailableStartTimeElement(element: TimeType | undefined): this {
    if (isDefined<TimeType>(element)) {
      const optErrMsg = \`Invalid HealthcareService.availableTime.availableStartTime; Provided element is not an instance of TimeType.\`;
      assertFhirType<TimeType>(element, TimeType, optErrMsg);
      this.availableStartTime = element;
    } else {
      this.availableStartTime = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`availableStartTime\` property exists and has a value; \`false\` otherwise
   */
  public hasAvailableStartTimeElement(): boolean {
    return isDefined<TimeType>(this.availableStartTime) && !this.availableStartTime.isEmpty();
  }

  /**
   * @returns the \`availableStartTime\` property value as a fhirTime if defined; else undefined
   */
  public getAvailableStartTime(): fhirTime | undefined {
    return this.availableStartTime?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`availableStartTime\` property.
   *
   * @param value - the \`availableStartTime\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAvailableStartTime(value: fhirTime | undefined): this {
    if (isDefined<fhirTime>(value)) {
      const optErrMsg = \`Invalid HealthcareService.availableTime.availableStartTime (\${String(value)})\`;
      this.availableStartTime = new TimeType(parseFhirPrimitiveData(value, fhirTimeSchema, optErrMsg));
    } else {
      this.availableStartTime = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`availableStartTime\` property exists and has a value; \`false\` otherwise
   */
  public hasAvailableStartTime(): boolean {
    return this.hasAvailableStartTimeElement();
  }

  /**
   * @returns the \`availableEndTime\` property value as a TimeType object if defined; else an empty TimeType object
   */
  public getAvailableEndTimeElement(): TimeType {
    return this.availableEndTime ?? new TimeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`availableEndTime\` property.
   *
   * @param element - the \`availableEndTime\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAvailableEndTimeElement(element: TimeType | undefined): this {
    if (isDefined<TimeType>(element)) {
      const optErrMsg = \`Invalid HealthcareService.availableTime.availableEndTime; Provided element is not an instance of TimeType.\`;
      assertFhirType<TimeType>(element, TimeType, optErrMsg);
      this.availableEndTime = element;
    } else {
      this.availableEndTime = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`availableEndTime\` property exists and has a value; \`false\` otherwise
   */
  public hasAvailableEndTimeElement(): boolean {
    return isDefined<TimeType>(this.availableEndTime) && !this.availableEndTime.isEmpty();
  }

  /**
   * @returns the \`availableEndTime\` property value as a fhirTime if defined; else undefined
   */
  public getAvailableEndTime(): fhirTime | undefined {
    return this.availableEndTime?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`availableEndTime\` property.
   *
   * @param value - the \`availableEndTime\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAvailableEndTime(value: fhirTime | undefined): this {
    if (isDefined<fhirTime>(value)) {
      const optErrMsg = \`Invalid HealthcareService.availableTime.availableEndTime (\${String(value)})\`;
      this.availableEndTime = new TimeType(parseFhirPrimitiveData(value, fhirTimeSchema, optErrMsg));
    } else {
      this.availableEndTime = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`availableEndTime\` property exists and has a value; \`false\` otherwise
   */
  public hasAvailableEndTime(): boolean {
    return this.hasAvailableEndTimeElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'HealthcareService.availableTime';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.daysOfWeek,
      this.allDay,
      this.availableStartTime,
      this.availableEndTime,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): HealthcareServiceAvailableTimeComponent {
    const dest = new HealthcareServiceAvailableTimeComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: HealthcareServiceAvailableTimeComponent): void {
    super.copyValues(dest);
    const daysOfWeekList = copyListValues<EnumCodeType>(this.daysOfWeek);
    dest.daysOfWeek = daysOfWeekList.length === 0 ? undefined : daysOfWeekList;
    dest.allDay = this.allDay?.copy();
    dest.availableStartTime = this.availableStartTime?.copy();
    dest.availableEndTime = this.availableEndTime?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasDaysOfWeekElement()) {
      setFhirPrimitiveListJson<fhirCode>(this.getDaysOfWeekElement(), 'daysOfWeek', jsonObj);
    }

    if (this.hasAllDayElement()) {
      setFhirPrimitiveJson<fhirBoolean>(this.getAllDayElement(), 'allDay', jsonObj);
    }

    if (this.hasAvailableStartTimeElement()) {
      setFhirPrimitiveJson<fhirTime>(this.getAvailableStartTimeElement(), 'availableStartTime', jsonObj);
    }

    if (this.hasAvailableEndTimeElement()) {
      setFhirPrimitiveJson<fhirTime>(this.getAvailableEndTimeElement(), 'availableEndTime', jsonObj);
    }

    return jsonObj;
  }
}
/**
 * HealthcareServiceNotAvailableComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Not available during this time due to provided reason
 * - **Definition:** The HealthcareService is not available during this period of time due to the provided reason.
 *
 * @category Data Models: Resource
 * @see [FHIR HealthcareService](http://hl7.org/fhir/StructureDefinition/HealthcareService)
 */
export class HealthcareServiceNotAvailableComponent extends BackboneElement implements IBackboneElement {
  constructor(description: StringType | fhirString | null = null) {
    super();

    this.description = null;
    if (isDefined<StringType | fhirString>(description)) {
      if (description instanceof PrimitiveType) {
        this.setDescriptionElement(description);
      } else {
        this.setDescription(description);
      }
    }
  }

  /**
   * Parse the provided \`HealthcareServiceNotAvailableComponent\` JSON to instantiate the HealthcareServiceNotAvailableComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`HealthcareServiceNotAvailableComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to HealthcareServiceNotAvailableComponent
   * @returns HealthcareServiceNotAvailableComponent data model or undefined for \`HealthcareServiceNotAvailableComponent\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): HealthcareServiceNotAvailableComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'HealthcareServiceNotAvailableComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new HealthcareServiceNotAvailableComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    

    const missingReqdProperties: string[] = [];

    fieldName = 'description';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setDescriptionElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'during';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Period | undefined = Period.parse(classJsonObj[fieldName]!, sourceField);
      instance.setDuring(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * HealthcareService.notAvailable.description Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Reason presented to the user explaining why time not available
   * - **Definition:** The reason that can be presented to the user as to why this time is not available.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private description: StringType | null;

  /**
   * HealthcareService.notAvailable.during Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Service not available from this date
   * - **Definition:** Service is not available (seasonally or for a public holiday) from this date.
   * - **FHIR Type:** \`Period\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private during?: Period | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`description\` property value as a StringType object if defined; else null
   */
  public getDescriptionElement(): StringType | null {
    return this.description;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`description\` property.
   *
   * @param element - the \`description\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDescriptionElement(element: StringType): this {
    assertIsDefined<StringType>(element, \`HealthcareService.notAvailable.description is required\`);
    const optErrMsg = \`Invalid HealthcareService.notAvailable.description; Provided value is not an instance of StringType.\`;
    assertFhirType<StringType>(element, StringType, optErrMsg);
    this.description = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`description\` property exists and has a value; \`false\` otherwise
   */
  public hasDescriptionElement(): boolean {
    return isDefined<StringType>(this.description) && !this.description.isEmpty();
  }

  /**
   * @returns the \`description\` property value as a fhirString if defined; else null
   */
  public getDescription(): fhirString | null {
    if (this.description?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.description.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`description\` property.
   *
   * @param value - the \`description\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDescription(value: fhirString): this {
    assertIsDefined<fhirString>(value, \`HealthcareService.notAvailable.description is required\`);
    const optErrMsg = \`Invalid HealthcareService.notAvailable.description (\${String(value)})\`;
    this.description = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`description\` property exists and has a value; \`false\` otherwise
   */
  public hasDescription(): boolean {
    return this.hasDescriptionElement();
  }

  /**
   * @returns the \`during\` property value as a Period object if defined; else an empty Period object
   */
  public getDuring(): Period {
    return this.during ?? new Period();
  }

  /**
   * Assigns the provided During object value to the \`during\` property.
   *
   * @param value - the \`during\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setDuring(value: Period | undefined): this {
    if (isDefined<Period>(value)) {
      const optErrMsg = \`Invalid HealthcareService.notAvailable.during; Provided element is not an instance of Period.\`;
      assertFhirType<Period>(value, Period, optErrMsg);
      this.during = value;
    } else {
      this.during = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`during\` property exists and has a value; \`false\` otherwise
   */
  public hasDuring(): boolean {
    return isDefined<Period>(this.during) && !this.during.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'HealthcareService.notAvailable';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.description,
      this.during,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): HealthcareServiceNotAvailableComponent {
    const dest = new HealthcareServiceNotAvailableComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: HealthcareServiceNotAvailableComponent): void {
    super.copyValues(dest);
    dest.description = this.description ? this.description.copy() : null;
    dest.during = this.during?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasDescriptionElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirString>(this.getDescriptionElement()!, 'description', jsonObj);
    } else {
      missingReqdProperties.push(\`HealthcareService.notAvailable.description\`);
    }

    if (this.hasDuring()) {
      setFhirComplexJson(this.getDuring(), 'during', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
",
  "fileExtension": "ts",
  "filename": "HealthcareService",
}
`;

exports[`generator-datamodel-ftest Functional Test Suite generator-app verify generated content should consistently create GeneratedContent[] 35`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/src",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/test/ftest-cache",
    "pkgName": "ftest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "Resource",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * Location Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/Location
 * StructureDefinition.name: Location
 * StructureDefinition.description: Details and position information for a physical place where services are provided and resources and participants may be stored, found, contained, or accommodated.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  BackboneElement,
  BooleanType,
  CodeType,
  DecimalType,
  DomainResource,
  EnumCodeType,
  FhirError,
  FhirParser,
  IBackboneElement,
  IDomainResource,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  PrimitiveType,
  PrimitiveTypeJson,
  REQUIRED_PROPERTIES_DO_NOT_EXIST,
  REQUIRED_PROPERTIES_REQD_IN_JSON,
  ReferenceTargets,
  StringType,
  TimeType,
  assertEnumCodeType,
  assertEnumCodeTypeList,
  assertFhirType,
  assertFhirTypeList,
  assertIsDefined,
  copyListValues,
  fhirBoolean,
  fhirBooleanSchema,
  fhirCode,
  fhirCodeSchema,
  fhirDecimal,
  fhirDecimalSchema,
  fhirString,
  fhirStringSchema,
  fhirTime,
  fhirTimeSchema,
  getPrimitiveTypeJson,
  getPrimitiveTypeListJson,
  isDefined,
  isDefinedList,
  isElementEmpty,
  isEmpty,
  parseFhirPrimitiveData,
  setFhirBackboneElementJson,
  setFhirBackboneElementListJson,
  setFhirComplexJson,
  setFhirComplexListJson,
  setFhirPrimitiveJson,
  setFhirPrimitiveListJson,
} from '@paq-ts-fhir/fhir-core';
import { Address, CodeableConcept, Coding, ContactPoint, Identifier, PARSABLE_DATATYPE_MAP, Reference } from '../complex-types/complex-datatypes';
import { DaysOfWeekEnum } from '../code-systems/DaysOfWeekEnum';
import { LocationModeEnum } from '../code-systems/LocationModeEnum';
import { LocationStatusEnum } from '../code-systems/LocationStatusEnum';
import { PARSABLE_RESOURCE_MAP } from './parsable-resource-map';

/**
 * Location Class
 *
 * @remarks
 * Details and position information for a physical place where services are provided and resources and participants may be stored, found, contained, or accommodated.
 *
 * **FHIR Specification**
 * - **Short:** Details and position information for a physical place
 * - **Definition:** Details and position information for a physical place where services are provided and resources and participants may be stored, found, contained, or accommodated.
 * - **FHIR Version:** 4.0.1
 *
 * @category Data Models: Resource
 * @see [FHIR Location](http://hl7.org/fhir/StructureDefinition/Location)
 */
export class Location extends DomainResource implements IDomainResource {
  constructor() {
    super();

    this.locationStatusEnum = new LocationStatusEnum();
    this.locationModeEnum = new LocationModeEnum();
  }

  /**
   * Parse the provided \`Location\` JSON to instantiate the Location data model.
   *
   * @param sourceJson - JSON representing FHIR \`Location\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Location
   * @returns Location data model or undefined for \`Location\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static override parse(sourceJson: JSON.Value, optSourceField?: string): Location | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Location';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Location();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.verifyResourceType(classJsonObj, 'Location');
    fhirParser.processDomainResourceJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'identifier';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Identifier | undefined = Identifier.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addIdentifier(datatype);
        }
      });
    }

    fieldName = 'status';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setStatusElement(datatype);
    }

    fieldName = 'operationalStatus';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Coding | undefined = Coding.parse(classJsonObj[fieldName]!, sourceField);
      instance.setOperationalStatus(datatype);
    }

    fieldName = 'name';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setNameElement(datatype);
    }

    fieldName = 'alias';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: StringType | undefined = fhirParser.parseStringType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addAliasElement(datatype);
        }
      });
    }

    fieldName = 'description';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setDescriptionElement(datatype);
    }

    fieldName = 'mode';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setModeElement(datatype);
    }

    fieldName = 'type';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: CodeableConcept | undefined = CodeableConcept.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addType(datatype);
        }
      });
    }

    fieldName = 'telecom';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: ContactPoint | undefined = ContactPoint.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addTelecom(datatype);
        }
      });
    }

    fieldName = 'address';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Address | undefined = Address.parse(classJsonObj[fieldName]!, sourceField);
      instance.setAddress(datatype);
    }

    fieldName = 'physicalType';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = CodeableConcept.parse(classJsonObj[fieldName]!, sourceField);
      instance.setPhysicalType(datatype);
    }

    fieldName = 'position';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const component: LocationPositionComponent | undefined = LocationPositionComponent.parse(classJsonObj[fieldName]!, sourceField);
      instance.setPosition(component);
    }

    fieldName = 'managingOrganization';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = Reference.parse(classJsonObj[fieldName]!, sourceField);
      instance.setManagingOrganization(datatype);
    }

    fieldName = 'partOf';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = Reference.parse(classJsonObj[fieldName]!, sourceField);
      instance.setPartOf(datatype);
    }

    fieldName = 'hoursOfOperation';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const componentJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      componentJsonArray.forEach((componentJson: JSON.Value, idx) => {
        const component: LocationHoursOfOperationComponent | undefined = LocationHoursOfOperationComponent.parse(componentJson, \`\${sourceField}[\${String(idx)}]\`);
        if (component !== undefined) {
          instance.addHoursOfOperation(component);
        }
      });
    }

    fieldName = 'availabilityExceptions';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setAvailabilityExceptionsElement(datatype);
    }

    fieldName = 'endpoint';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Reference | undefined = Reference.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addEndpoint(datatype);
        }
      });
  }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Location.identifier Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Unique code or number identifying the location to its users
   * - **Definition:** Unique code or number identifying the location to its users.
   * - **Requirements:** Organization label locations in registries, need to keep track of those.
   * - **FHIR Type:** \`Identifier\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private identifier?: Identifier[] | undefined;

  /**
   * FHIR CodeSystem: LocationStatus
   *
   * @see {@link LocationStatusEnum }
   */
  private readonly locationStatusEnum: LocationStatusEnum;

  /**
   * Location.status Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** active | suspended | inactive
   * - **Definition:** The status property covers the general availability of the resource, not the current value which may be covered by the operationStatus, or by a schedule/slots if they are configured for the location.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** true
   * - **isModifierReason:** This element is labeled as a modifier because the status contains codes that mark the resource as not currently valid
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link LocationStatusEnum }
   */
  private status?: EnumCodeType | undefined;

  /**
   * Location.operationalStatus Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The operational status of the location (typically only for a bed/room)
   * - **Definition:** The operational status covers operation values most relevant to beds (but can also apply to rooms/units/chairs/etc. such as an isolation unit/dialysis chair). This typically covers concepts such as contamination, housekeeping, and other activities like maintenance.
   * - **FHIR Type:** \`Coding\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private operationalStatus?: Coding | undefined;

  /**
   * Location.name Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Name of the location as used by humans
   * - **Definition:** Name of the location as used by humans. Does not need to be unique.
   * - **Comment:** If the name of a location changes, consider putting the old name in the alias column so that it can still be located through searches.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private name?: StringType | undefined;

  /**
   * Location.alias Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A list of alternate names that the location is known as, or was known as, in the past
   * - **Definition:** A list of alternate names that the location is known as, or was known as, in the past.
   * - **Comment:** There are no dates associated with the alias/historic names, as this is not intended to track when names were used, but to assist in searching so that older names can still result in identifying the location.
   * - **Requirements:** Over time locations and organizations go through many changes and can be known by different names. For searching knowing previous names that the location was known by can be very useful.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private alias?: StringType[] | undefined;

  /**
   * Location.description Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Additional details about the location that could be displayed as further information to identify the location beyond its name
   * - **Definition:** Description of the Location, which helps in finding or referencing the place.
   * - **Requirements:** Humans need additional information to verify a correct location has been identified.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private description?: StringType | undefined;

  /**
   * FHIR CodeSystem: LocationMode
   *
   * @see {@link LocationModeEnum }
   */
  private readonly locationModeEnum: LocationModeEnum;

  /**
   * Location.mode Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** instance | kind
   * - **Definition:** Indicates whether a resource instance represents a specific location or a class of locations.
   * - **Comment:** This is labeled as a modifier because whether or not the location is a class of locations changes how it can be used and understood.
   * - **Requirements:** When using a Location resource for scheduling or orders, we need to be able to refer to a class of Locations instead of a specific Location.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link LocationModeEnum }
   */
  private mode?: EnumCodeType | undefined;

  /**
   * Location.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Type of function performed
   * - **Definition:** Indicates the type of function performed at the location.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private type_?: CodeableConcept[] | undefined;

  /**
   * Location.telecom Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Contact details of the location
   * - **Definition:** The contact details of communication devices available at the location. This can include phone numbers, fax numbers, mobile numbers, email addresses and web sites.
   * - **FHIR Type:** \`ContactPoint\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private telecom?: ContactPoint[] | undefined;

  /**
   * Location.address Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Physical location
   * - **Definition:** Physical location.
   * - **Comment:** Additional addresses should be recorded using another instance of the Location resource, or via the Organization.
   * - **Requirements:** If locations can be visited, we need to keep track of their address.
   * - **FHIR Type:** \`Address\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private address?: Address | undefined;

  /**
   * Location.physicalType Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Physical form of the location
   * - **Definition:** Physical form of the location, e.g. building, room, vehicle, road.
   * - **Requirements:** For purposes of showing relevant locations in queries, we need to categorize locations.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private physicalType?: CodeableConcept | undefined;

  /**
   * Location.position Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The absolute geographic location
   * - **Definition:** The absolute geographic location of the Location, expressed using the WGS84 datum (This is the same co-ordinate system used in KML).
   * - **Requirements:** For mobile applications and automated route-finding knowing the exact location of the Location is required.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private position?: LocationPositionComponent | undefined;

  /**
   * Location.managingOrganization Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Organization responsible for provisioning and upkeep
   * - **Definition:** The organization responsible for the provisioning and upkeep of the location.
   * - **Comment:** This can also be used as the part of the organization hierarchy where this location provides services. These services can be defined through the HealthcareService resource.
   * - **Requirements:** Need to know who manages the location.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Organization',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private managingOrganization?: Reference | undefined;

  /**
   * Location.partOf Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Another Location this one is physically a part of
   * - **Definition:** Another Location of which this Location is physically a part of.
   * - **Requirements:** For purposes of location, display and identification, knowing which locations are located within other locations is important.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Location',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private partOf?: Reference | undefined;

  /**
   * Location.hoursOfOperation Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** What days/times during a week is this location usually open
   * - **Definition:** What days/times during a week is this location usually open.
   * - **Comment:** This type of information is commonly found published in directories and on websites informing customers when the facility is available. Specific services within the location may have their own hours which could be shorter (or longer) than the locations hours.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private hoursOfOperation?: LocationHoursOfOperationComponent[] | undefined;

  /**
   * Location.availabilityExceptions Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Description of availability exceptions
   * - **Definition:** A description of when the locations opening ours are different to normal, e.g. public holiday availability. Succinctly describing all possible exceptions to normal site availability as detailed in the opening hours Times.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private availabilityExceptions?: StringType | undefined;

  /**
   * Location.endpoint Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Technical endpoints providing access to services operated for the location
   * - **Definition:** Technical endpoints providing access to services operated for the location.
   * - **Requirements:** Organizations may have different systems at different locations that provide various services and need to be able to define the technical connection details for how to connect to them, and for what purpose.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Endpoint',
   *     ]
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private endpoint?: Reference[] | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`identifier\` property value as a Identifier array
   */
  public getIdentifier(): Identifier[] {
    return this.identifier ?? ([] as Identifier[]);
  }

  /**
   * Assigns the provided Identifier array value to the \`identifier\` property.
   *
   * @param value - the \`identifier\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setIdentifier(value: Identifier[] | undefined): this {
    if (isDefinedList<Identifier>(value)) {
      const optErrMsg = \`Invalid Location.identifier; Provided value array has an element that is not an instance of Identifier.\`;
      assertFhirTypeList<Identifier>(value, Identifier, optErrMsg);
      this.identifier = value;
    } else {
      this.identifier = undefined;
    }
    return this;
  }

  /**
   * Add the provided Identifier value to the \`identifier\` array property.
   *
   * @param value - the \`identifier\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addIdentifier(value: Identifier | undefined): this {
    if (isDefined<Identifier>(value)) {
      const optErrMsg = \`Invalid Location.identifier; Provided element is not an instance of Identifier.\`;
      assertFhirType<Identifier>(value, Identifier, optErrMsg);
      this.initIdentifier();
      this.identifier?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`identifier\` property exists and has a value; \`false\` otherwise
   */
  public hasIdentifier(): boolean {
    return isDefinedList<Identifier>(this.identifier) && this.identifier.some((item: Identifier) => !item.isEmpty());
  }

  /**
   * Initialize the \`identifier\` property
   */
  private initIdentifier(): void {
    if(!this.hasIdentifier()) {
      this.identifier = [] as Identifier[];
    }
  }

  /**
   * @returns the \`status\` property value as a EnumCodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link LocationStatusEnum }
   */
  public getStatusEnumType(): EnumCodeType | undefined {
    return this.status;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`status\` property.
   *
   * @param enumType - the \`status\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code values
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link LocationStatusEnum }
   */
  public setStatusEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid Location.status';
      assertEnumCodeType<LocationStatusEnum>(enumType, LocationStatusEnum, errMsgPrefix);
      this.status = enumType;
    } else {
      this.status = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`status\` property exists and has a value; \`false\` otherwise
   */
  public hasStatusEnumType(): boolean {
    return isDefined<EnumCodeType>(this.status) && !this.status.isEmpty() && this.status.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`status\` property value as a CodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link LocationStatusEnum }
   */
  public getStatusElement(): CodeType | undefined {
    if (this.status === undefined) {
      return undefined;
    }
    return this.status as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`status\` property.
   *
   * @param element - the \`status\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link LocationStatusEnum }
   */
  public setStatusElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Location.status; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.status = new EnumCodeType(element, this.locationStatusEnum);
    } else {
      this.status = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`status\` property exists and has a value; \`false\` otherwise
   */
  public hasStatusElement(): boolean {
    return this.hasStatusEnumType();
  }

  /**
   * @returns the \`status\` property value as a fhirCode if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link LocationStatusEnum }
   */
  public getStatus(): fhirCode | undefined {
    if (this.status === undefined) {
      return undefined;
    }
    return this.status.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`status\` property.
   *
   * @param value - the \`status\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link LocationStatusEnum }
   */
  public setStatus(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Location.status; Provided value is not an instance of fhirCode.\`;
      this.status = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.locationStatusEnum);
    } else {
      this.status = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`status\` property exists and has a value; \`false\` otherwise
   */
  public hasStatus(): boolean {
    return this.hasStatusEnumType();
  }

  /**
   * @returns the \`operationalStatus\` property value as a Coding object if defined; else an empty Coding object
   */
  public getOperationalStatus(): Coding {
    return this.operationalStatus ?? new Coding();
  }

  /**
   * Assigns the provided OperationalStatus object value to the \`operationalStatus\` property.
   *
   * @param value - the \`operationalStatus\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setOperationalStatus(value: Coding | undefined): this {
    if (isDefined<Coding>(value)) {
      const optErrMsg = \`Invalid Location.operationalStatus; Provided element is not an instance of Coding.\`;
      assertFhirType<Coding>(value, Coding, optErrMsg);
      this.operationalStatus = value;
    } else {
      this.operationalStatus = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`operationalStatus\` property exists and has a value; \`false\` otherwise
   */
  public hasOperationalStatus(): boolean {
    return isDefined<Coding>(this.operationalStatus) && !this.operationalStatus.isEmpty();
  }

  /**
   * @returns the \`name\` property value as a StringType object if defined; else an empty StringType object
   */
  public getNameElement(): StringType {
    return this.name ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`name\` property.
   *
   * @param element - the \`name\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setNameElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Location.name; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.name = element;
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`name\` property exists and has a value; \`false\` otherwise
   */
  public hasNameElement(): boolean {
    return isDefined<StringType>(this.name) && !this.name.isEmpty();
  }

  /**
   * @returns the \`name\` property value as a fhirString if defined; else undefined
   */
  public getName(): fhirString | undefined {
    return this.name?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`name\` property.
   *
   * @param value - the \`name\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setName(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Location.name (\${String(value)})\`;
      this.name = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`name\` property exists and has a value; \`false\` otherwise
   */
  public hasName(): boolean {
    return this.hasNameElement();
  }

  /**
   * @returns the \`alias\` property value as a StringType array
   */
  public getAliasElement(): StringType[] {
    return this.alias ?? ([] as StringType[]);
  }

  /**
   * Assigns the provided StringType array value to the \`alias\` property.
   *
   * @param element - the \`alias\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAliasElement(element: StringType[] | undefined): this {
    if (isDefinedList<StringType>(element)) {
      const optErrMsg = \`Invalid Location.alias; Provided value array has an element that is not an instance of StringType.\`;
      assertFhirTypeList<StringType>(element, StringType, optErrMsg);
      this.alias = element;
    } else {
      this.alias = undefined;
    }
    return this;
  }

  /**
   * Add the provided StringType value to the \`alias\` array property.
   *
   * @param element - the \`alias\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addAliasElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Location.alias; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.initAlias();
      this.alias?.push(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`alias\` property exists and has a value; \`false\` otherwise
   */
  public hasAliasElement(): boolean {
    return isDefinedList<StringType>(this.alias) && this.alias.some((item: StringType) => !item.isEmpty());
  }

  /**
   * @returns the \`alias\` property value as a fhirString array
   */
  public getAlias(): fhirString[] {
    this.initAlias();
    const aliasValues = [] as fhirString[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.alias!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        aliasValues.push(value);
      }
    }
    return aliasValues;
  }

  /**
   * Assigns the provided primitive value array to the \`alias\` property.
   *
   * @param value - the \`alias\` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAlias(value: fhirString[] | undefined): this {
    if (isDefinedList<fhirString>(value)) {
      const aliasElements = [] as StringType[];
      for (const aliasValue of value) {
        const optErrMsg = \`Invalid Location.alias array item (\${String(aliasValue)})\`;
        const element = new StringType(parseFhirPrimitiveData(aliasValue, fhirStringSchema, optErrMsg));
        aliasElements.push(element);
      }
      this.alias = aliasElements;
    } else {
      this.alias = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`alias\` array property.
   *
   * @param value - the \`alias\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addAlias(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Location.alias array item (\${String(value)})\`;
      const element = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
      this.initAlias();
      this.addAliasElement(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`alias\` property exists and has a value; \`false\` otherwise
   */
  public hasAlias(): boolean {
    return this.hasAliasElement();
  }

  /**
   * Initialize the \`alias\` property
   */
  private initAlias(): void {
    if (!this.hasAlias()) {
      this.alias = [] as StringType[];
    }
  }

  /**
   * @returns the \`description\` property value as a StringType object if defined; else an empty StringType object
   */
  public getDescriptionElement(): StringType {
    return this.description ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`description\` property.
   *
   * @param element - the \`description\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDescriptionElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Location.description; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.description = element;
    } else {
      this.description = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`description\` property exists and has a value; \`false\` otherwise
   */
  public hasDescriptionElement(): boolean {
    return isDefined<StringType>(this.description) && !this.description.isEmpty();
  }

  /**
   * @returns the \`description\` property value as a fhirString if defined; else undefined
   */
  public getDescription(): fhirString | undefined {
    return this.description?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`description\` property.
   *
   * @param value - the \`description\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDescription(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Location.description (\${String(value)})\`;
      this.description = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.description = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`description\` property exists and has a value; \`false\` otherwise
   */
  public hasDescription(): boolean {
    return this.hasDescriptionElement();
  }

  /**
   * @returns the \`mode\` property value as a EnumCodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link LocationModeEnum }
   */
  public getModeEnumType(): EnumCodeType | undefined {
    return this.mode;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`mode\` property.
   *
   * @param enumType - the \`mode\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code values
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link LocationModeEnum }
   */
  public setModeEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid Location.mode';
      assertEnumCodeType<LocationModeEnum>(enumType, LocationModeEnum, errMsgPrefix);
      this.mode = enumType;
    } else {
      this.mode = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`mode\` property exists and has a value; \`false\` otherwise
   */
  public hasModeEnumType(): boolean {
    return isDefined<EnumCodeType>(this.mode) && !this.mode.isEmpty() && this.mode.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`mode\` property value as a CodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link LocationModeEnum }
   */
  public getModeElement(): CodeType | undefined {
    if (this.mode === undefined) {
      return undefined;
    }
    return this.mode as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`mode\` property.
   *
   * @param element - the \`mode\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link LocationModeEnum }
   */
  public setModeElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Location.mode; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.mode = new EnumCodeType(element, this.locationModeEnum);
    } else {
      this.mode = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`mode\` property exists and has a value; \`false\` otherwise
   */
  public hasModeElement(): boolean {
    return this.hasModeEnumType();
  }

  /**
   * @returns the \`mode\` property value as a fhirCode if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link LocationModeEnum }
   */
  public getMode(): fhirCode | undefined {
    if (this.mode === undefined) {
      return undefined;
    }
    return this.mode.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`mode\` property.
   *
   * @param value - the \`mode\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link LocationModeEnum }
   */
  public setMode(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Location.mode; Provided value is not an instance of fhirCode.\`;
      this.mode = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.locationModeEnum);
    } else {
      this.mode = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`mode\` property exists and has a value; \`false\` otherwise
   */
  public hasMode(): boolean {
    return this.hasModeEnumType();
  }

  /**
   * @returns the \`type_\` property value as a CodeableConcept array
   */
  public getType(): CodeableConcept[] {
    return this.type_ ?? ([] as CodeableConcept[]);
  }

  /**
   * Assigns the provided CodeableConcept array value to the \`type_\` property.
   *
   * @param value - the \`type_\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setType(value: CodeableConcept[] | undefined): this {
    if (isDefinedList<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Location.type; Provided value array has an element that is not an instance of CodeableConcept.\`;
      assertFhirTypeList<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.type_ = value;
    } else {
      this.type_ = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeableConcept value to the \`type_\` array property.
   *
   * @param value - the \`type_\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addType(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Location.type; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.initType();
      this.type_?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasType(): boolean {
    return isDefinedList<CodeableConcept>(this.type_) && this.type_.some((item: CodeableConcept) => !item.isEmpty());
  }

  /**
   * Initialize the \`type_\` property
   */
  private initType(): void {
    if(!this.hasType()) {
      this.type_ = [] as CodeableConcept[];
    }
  }

  /**
   * @returns the \`telecom\` property value as a ContactPoint array
   */
  public getTelecom(): ContactPoint[] {
    return this.telecom ?? ([] as ContactPoint[]);
  }

  /**
   * Assigns the provided ContactPoint array value to the \`telecom\` property.
   *
   * @param value - the \`telecom\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setTelecom(value: ContactPoint[] | undefined): this {
    if (isDefinedList<ContactPoint>(value)) {
      const optErrMsg = \`Invalid Location.telecom; Provided value array has an element that is not an instance of ContactPoint.\`;
      assertFhirTypeList<ContactPoint>(value, ContactPoint, optErrMsg);
      this.telecom = value;
    } else {
      this.telecom = undefined;
    }
    return this;
  }

  /**
   * Add the provided ContactPoint value to the \`telecom\` array property.
   *
   * @param value - the \`telecom\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addTelecom(value: ContactPoint | undefined): this {
    if (isDefined<ContactPoint>(value)) {
      const optErrMsg = \`Invalid Location.telecom; Provided element is not an instance of ContactPoint.\`;
      assertFhirType<ContactPoint>(value, ContactPoint, optErrMsg);
      this.initTelecom();
      this.telecom?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`telecom\` property exists and has a value; \`false\` otherwise
   */
  public hasTelecom(): boolean {
    return isDefinedList<ContactPoint>(this.telecom) && this.telecom.some((item: ContactPoint) => !item.isEmpty());
  }

  /**
   * Initialize the \`telecom\` property
   */
  private initTelecom(): void {
    if(!this.hasTelecom()) {
      this.telecom = [] as ContactPoint[];
    }
  }

  /**
   * @returns the \`address\` property value as a Address object if defined; else an empty Address object
   */
  public getAddress(): Address {
    return this.address ?? new Address();
  }

  /**
   * Assigns the provided Address object value to the \`address\` property.
   *
   * @param value - the \`address\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setAddress(value: Address | undefined): this {
    if (isDefined<Address>(value)) {
      const optErrMsg = \`Invalid Location.address; Provided element is not an instance of Address.\`;
      assertFhirType<Address>(value, Address, optErrMsg);
      this.address = value;
    } else {
      this.address = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`address\` property exists and has a value; \`false\` otherwise
   */
  public hasAddress(): boolean {
    return isDefined<Address>(this.address) && !this.address.isEmpty();
  }

  /**
   * @returns the \`physicalType\` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getPhysicalType(): CodeableConcept {
    return this.physicalType ?? new CodeableConcept();
  }

  /**
   * Assigns the provided PhysicalType object value to the \`physicalType\` property.
   *
   * @param value - the \`physicalType\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setPhysicalType(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Location.physicalType; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.physicalType = value;
    } else {
      this.physicalType = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`physicalType\` property exists and has a value; \`false\` otherwise
   */
  public hasPhysicalType(): boolean {
    return isDefined<CodeableConcept>(this.physicalType) && !this.physicalType.isEmpty();
  }

  /**
   * @returns the \`position\` property value as a LocationPositionComponent object if defined; else an empty LocationPositionComponent object
   */
  public getPosition(): LocationPositionComponent {
    return this.position ?? new LocationPositionComponent();
  }

  /**
   * Assigns the provided Position object value to the \`position\` property.
   *
   * @param value - the \`position\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setPosition(value: LocationPositionComponent | undefined): this {
    if (isDefined<LocationPositionComponent>(value)) {
      const optErrMsg = \`Invalid Location.position; Provided element is not an instance of LocationPositionComponent.\`;
      assertFhirType<LocationPositionComponent>(value, LocationPositionComponent, optErrMsg);
      this.position = value;
    } else {
      this.position = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`position\` property exists and has a value; \`false\` otherwise
   */
  public hasPosition(): boolean {
    return isDefined<LocationPositionComponent>(this.position) && !this.position.isEmpty();
  }

  /**
   * @returns the \`managingOrganization\` property value as a Reference object; else an empty Reference object
   */
  public getManagingOrganization(): Reference {
    return this.managingOrganization ?? new Reference();
  }

  /**
   * Assigns the provided ManagingOrganization object value to the \`managingOrganization\` property.
   *
   * @decorator \`@ReferenceTargets('Location.managingOrganization', ['Organization',])\`
   *
   * @param value - the \`managingOrganization\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('Location.managingOrganization', [
    'Organization',
  ])
  public setManagingOrganization(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.managingOrganization = value;
    } else {
      this.managingOrganization = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`managingOrganization\` property exists and has a value; \`false\` otherwise
   */
  public hasManagingOrganization(): boolean {
    return isDefined<Reference>(this.managingOrganization) && !this.managingOrganization.isEmpty();
  }

  /**
   * @returns the \`partOf\` property value as a Reference object; else an empty Reference object
   */
  public getPartOf(): Reference {
    return this.partOf ?? new Reference();
  }

  /**
   * Assigns the provided PartOf object value to the \`partOf\` property.
   *
   * @decorator \`@ReferenceTargets('Location.partOf', ['Location',])\`
   *
   * @param value - the \`partOf\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('Location.partOf', [
    'Location',
  ])
  public setPartOf(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.partOf = value;
    } else {
      this.partOf = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`partOf\` property exists and has a value; \`false\` otherwise
   */
  public hasPartOf(): boolean {
    return isDefined<Reference>(this.partOf) && !this.partOf.isEmpty();
  }

  /**
   * @returns the \`hoursOfOperation\` property value as a LocationHoursOfOperationComponent array
   */
  public getHoursOfOperation(): LocationHoursOfOperationComponent[] {
    return this.hoursOfOperation ?? ([] as LocationHoursOfOperationComponent[]);
  }

  /**
   * Assigns the provided LocationHoursOfOperationComponent array value to the \`hoursOfOperation\` property.
   *
   * @param value - the \`hoursOfOperation\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setHoursOfOperation(value: LocationHoursOfOperationComponent[] | undefined): this {
    if (isDefinedList<LocationHoursOfOperationComponent>(value)) {
      const optErrMsg = \`Invalid Location.hoursOfOperation; Provided value array has an element that is not an instance of LocationHoursOfOperationComponent.\`;
      assertFhirTypeList<LocationHoursOfOperationComponent>(value, LocationHoursOfOperationComponent, optErrMsg);
      this.hoursOfOperation = value;
    } else {
      this.hoursOfOperation = undefined;
    }
    return this;
  }

  /**
   * Add the provided LocationHoursOfOperationComponent value to the \`hoursOfOperation\` array property.
   *
   * @param value - the \`hoursOfOperation\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addHoursOfOperation(value: LocationHoursOfOperationComponent | undefined): this {
    if (isDefined<LocationHoursOfOperationComponent>(value)) {
      const optErrMsg = \`Invalid Location.hoursOfOperation; Provided element is not an instance of LocationHoursOfOperationComponent.\`;
      assertFhirType<LocationHoursOfOperationComponent>(value, LocationHoursOfOperationComponent, optErrMsg);
      this.initHoursOfOperation();
      this.hoursOfOperation?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`hoursOfOperation\` property exists and has a value; \`false\` otherwise
   */
  public hasHoursOfOperation(): boolean {
    return isDefinedList<LocationHoursOfOperationComponent>(this.hoursOfOperation) && this.hoursOfOperation.some((item: LocationHoursOfOperationComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`hoursOfOperation\` property
   */
  private initHoursOfOperation(): void {
    if(!this.hasHoursOfOperation()) {
      this.hoursOfOperation = [] as LocationHoursOfOperationComponent[];
    }
  }

  /**
   * @returns the \`availabilityExceptions\` property value as a StringType object if defined; else an empty StringType object
   */
  public getAvailabilityExceptionsElement(): StringType {
    return this.availabilityExceptions ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`availabilityExceptions\` property.
   *
   * @param element - the \`availabilityExceptions\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAvailabilityExceptionsElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Location.availabilityExceptions; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.availabilityExceptions = element;
    } else {
      this.availabilityExceptions = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`availabilityExceptions\` property exists and has a value; \`false\` otherwise
   */
  public hasAvailabilityExceptionsElement(): boolean {
    return isDefined<StringType>(this.availabilityExceptions) && !this.availabilityExceptions.isEmpty();
  }

  /**
   * @returns the \`availabilityExceptions\` property value as a fhirString if defined; else undefined
   */
  public getAvailabilityExceptions(): fhirString | undefined {
    return this.availabilityExceptions?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`availabilityExceptions\` property.
   *
   * @param value - the \`availabilityExceptions\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAvailabilityExceptions(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Location.availabilityExceptions (\${String(value)})\`;
      this.availabilityExceptions = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.availabilityExceptions = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`availabilityExceptions\` property exists and has a value; \`false\` otherwise
   */
  public hasAvailabilityExceptions(): boolean {
    return this.hasAvailabilityExceptionsElement();
  }

  /**
   * @returns the \`endpoint\` property value as a Reference array
   */
  public getEndpoint(): Reference[] {
    return this.endpoint ?? ([] as Reference[]);
  }

  /**
   * Assigns the provided Reference array value to the \`endpoint\` property.
   *
   * @decorator \`@ReferenceTargets('Location.endpoint', ['Endpoint',])\`
   *
   * @param value - the \`endpoint\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('Location.endpoint', [
    'Endpoint',
  ])
  public setEndpoint(value: Reference[] | undefined): this {
    if (isDefinedList<Reference>(value)) {
      // assertFhirTypeList<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.endpoint = value;
    } else {
      this.endpoint = undefined;
    }
    return this;
  }

  /**
   * Add the provided Reference value to the \`endpoint\` array property.
   *
   * @decorator \`@ReferenceTargets('Location.endpoint', ['Endpoint',])\`
   *
   * @param value - the \`endpoint\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('Location.endpoint', [
    'Endpoint',
  ])
  public addEndpoint(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.initEndpoint();
      this.endpoint?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`endpoint\` property exists and has a value; \`false\` otherwise
   */
  public hasEndpoint(): boolean {
    return isDefinedList<Reference>(this.endpoint) && this.endpoint.some((item: Reference) => !item.isEmpty());
  }

  /**
   * Initialize the \`endpoint\` property
   */
  private initEndpoint(): void {
    if (!this.hasEndpoint()) {
      this.endpoint = [] as Reference[];
    }
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Location';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.identifier,
      this.status,
      this.operationalStatus,
      this.name,
      this.alias,
      this.description,
      this.mode,
      this.type_,
      this.telecom,
      this.address,
      this.physicalType,
      this.position,
      this.managingOrganization,
      this.partOf,
      this.hoursOfOperation,
      this.availabilityExceptions,
      this.endpoint,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Location {
    const dest = new Location();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Location): void {
    super.copyValues(dest);
    const identifierList = copyListValues<Identifier>(this.identifier);
    dest.identifier = identifierList.length === 0 ? undefined : identifierList;
    dest.status = this.status?.copy();
    dest.operationalStatus = this.operationalStatus?.copy();
    dest.name = this.name?.copy();
    const aliasList = copyListValues<StringType>(this.alias);
    dest.alias = aliasList.length === 0 ? undefined : aliasList;
    dest.description = this.description?.copy();
    dest.mode = this.mode?.copy();
    const typeList = copyListValues<CodeableConcept>(this.type_);
    dest.type_ = typeList.length === 0 ? undefined : typeList;
    const telecomList = copyListValues<ContactPoint>(this.telecom);
    dest.telecom = telecomList.length === 0 ? undefined : telecomList;
    dest.address = this.address?.copy();
    dest.physicalType = this.physicalType?.copy();
    dest.position = this.position?.copy();
    dest.managingOrganization = this.managingOrganization?.copy();
    dest.partOf = this.partOf?.copy();
    const hoursOfOperationList = copyListValues<LocationHoursOfOperationComponent>(this.hoursOfOperation);
    dest.hoursOfOperation = hoursOfOperationList.length === 0 ? undefined : hoursOfOperationList;
    dest.availabilityExceptions = this.availabilityExceptions?.copy();
    const endpointList = copyListValues<Reference>(this.endpoint);
    dest.endpoint = endpointList.length === 0 ? undefined : endpointList;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasIdentifier()) {
      setFhirComplexListJson(this.getIdentifier(), 'identifier', jsonObj);
    }

    if (this.hasStatusElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getStatusElement()!, 'status', jsonObj);
    }

    if (this.hasOperationalStatus()) {
      setFhirComplexJson(this.getOperationalStatus(), 'operationalStatus', jsonObj);
    }

    if (this.hasNameElement()) {
      setFhirPrimitiveJson<fhirString>(this.getNameElement(), 'name', jsonObj);
    }

    if (this.hasAlias()) {
      setFhirPrimitiveListJson(this.getAliasElement(), 'alias', jsonObj);
    }

    if (this.hasDescriptionElement()) {
      setFhirPrimitiveJson<fhirString>(this.getDescriptionElement(), 'description', jsonObj);
    }

    if (this.hasModeElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getModeElement()!, 'mode', jsonObj);
    }

    if (this.hasType()) {
      setFhirComplexListJson(this.getType(), 'type', jsonObj);
    }

    if (this.hasTelecom()) {
      setFhirComplexListJson(this.getTelecom(), 'telecom', jsonObj);
    }

    if (this.hasAddress()) {
      setFhirComplexJson(this.getAddress(), 'address', jsonObj);
    }

    if (this.hasPhysicalType()) {
      setFhirComplexJson(this.getPhysicalType(), 'physicalType', jsonObj);
    }

    if (this.hasPosition()) {
      setFhirBackboneElementJson(this.getPosition(), 'position', jsonObj);
    }

    if (this.hasManagingOrganization()) {
      setFhirComplexJson(this.getManagingOrganization(), 'managingOrganization', jsonObj);
    }

    if (this.hasPartOf()) {
      setFhirComplexJson(this.getPartOf(), 'partOf', jsonObj);
    }

    if (this.hasHoursOfOperation()) {
      setFhirBackboneElementListJson(this.getHoursOfOperation(), 'hoursOfOperation', jsonObj);
    }

    if (this.hasAvailabilityExceptionsElement()) {
      setFhirPrimitiveJson<fhirString>(this.getAvailabilityExceptionsElement(), 'availabilityExceptions', jsonObj);
    }

    if (this.hasEndpoint()) {
      setFhirComplexListJson(this.getEndpoint(), 'endpoint', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * LocationPositionComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** The absolute geographic location
 * - **Definition:** The absolute geographic location of the Location, expressed using the WGS84 datum (This is the same co-ordinate system used in KML).
 * - **Requirements:** For mobile applications and automated route-finding knowing the exact location of the Location is required.
 *
 * @category Data Models: Resource
 * @see [FHIR Location](http://hl7.org/fhir/StructureDefinition/Location)
 */
export class LocationPositionComponent extends BackboneElement implements IBackboneElement {
  constructor(longitude: DecimalType | fhirDecimal | null = null, latitude: DecimalType | fhirDecimal | null = null) {
    super();

    this.longitude = null;
    if (isDefined<DecimalType | fhirDecimal>(longitude)) {
      if (longitude instanceof PrimitiveType) {
        this.setLongitudeElement(longitude);
      } else {
        this.setLongitude(longitude);
      }
    }

    this.latitude = null;
    if (isDefined<DecimalType | fhirDecimal>(latitude)) {
      if (latitude instanceof PrimitiveType) {
        this.setLatitudeElement(latitude);
      } else {
        this.setLatitude(latitude);
      }
    }
  }

  /**
   * Parse the provided \`LocationPositionComponent\` JSON to instantiate the LocationPositionComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`LocationPositionComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to LocationPositionComponent
   * @returns LocationPositionComponent data model or undefined for \`LocationPositionComponent\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): LocationPositionComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'LocationPositionComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new LocationPositionComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'longitude';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setLongitudeElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'latitude';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setLatitudeElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'altitude';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setAltitudeElement(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Location.position.longitude Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Longitude with WGS84 datum
   * - **Definition:** Longitude. The value domain and the interpretation are the same as for the text of the longitude element in KML (see notes below).
   * - **FHIR Type:** \`decimal\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private longitude: DecimalType | null;

  /**
   * Location.position.latitude Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Latitude with WGS84 datum
   * - **Definition:** Latitude. The value domain and the interpretation are the same as for the text of the latitude element in KML (see notes below).
   * - **FHIR Type:** \`decimal\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private latitude: DecimalType | null;

  /**
   * Location.position.altitude Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Altitude with WGS84 datum
   * - **Definition:** Altitude. The value domain and the interpretation are the same as for the text of the altitude element in KML (see notes below).
   * - **FHIR Type:** \`decimal\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private altitude?: DecimalType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`longitude\` property value as a DecimalType object if defined; else null
   */
  public getLongitudeElement(): DecimalType | null {
    return this.longitude;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`longitude\` property.
   *
   * @param element - the \`longitude\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLongitudeElement(element: DecimalType): this {
    assertIsDefined<DecimalType>(element, \`Location.position.longitude is required\`);
    const optErrMsg = \`Invalid Location.position.longitude; Provided value is not an instance of DecimalType.\`;
    assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
    this.longitude = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`longitude\` property exists and has a value; \`false\` otherwise
   */
  public hasLongitudeElement(): boolean {
    return isDefined<DecimalType>(this.longitude) && !this.longitude.isEmpty();
  }

  /**
   * @returns the \`longitude\` property value as a fhirDecimal if defined; else null
   */
  public getLongitude(): fhirDecimal | null {
    if (this.longitude?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.longitude.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`longitude\` property.
   *
   * @param value - the \`longitude\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLongitude(value: fhirDecimal): this {
    assertIsDefined<fhirDecimal>(value, \`Location.position.longitude is required\`);
    const optErrMsg = \`Invalid Location.position.longitude (\${String(value)})\`;
    this.longitude = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`longitude\` property exists and has a value; \`false\` otherwise
   */
  public hasLongitude(): boolean {
    return this.hasLongitudeElement();
  }

  /**
   * @returns the \`latitude\` property value as a DecimalType object if defined; else null
   */
  public getLatitudeElement(): DecimalType | null {
    return this.latitude;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`latitude\` property.
   *
   * @param element - the \`latitude\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLatitudeElement(element: DecimalType): this {
    assertIsDefined<DecimalType>(element, \`Location.position.latitude is required\`);
    const optErrMsg = \`Invalid Location.position.latitude; Provided value is not an instance of DecimalType.\`;
    assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
    this.latitude = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`latitude\` property exists and has a value; \`false\` otherwise
   */
  public hasLatitudeElement(): boolean {
    return isDefined<DecimalType>(this.latitude) && !this.latitude.isEmpty();
  }

  /**
   * @returns the \`latitude\` property value as a fhirDecimal if defined; else null
   */
  public getLatitude(): fhirDecimal | null {
    if (this.latitude?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.latitude.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`latitude\` property.
   *
   * @param value - the \`latitude\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLatitude(value: fhirDecimal): this {
    assertIsDefined<fhirDecimal>(value, \`Location.position.latitude is required\`);
    const optErrMsg = \`Invalid Location.position.latitude (\${String(value)})\`;
    this.latitude = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`latitude\` property exists and has a value; \`false\` otherwise
   */
  public hasLatitude(): boolean {
    return this.hasLatitudeElement();
  }

  /**
   * @returns the \`altitude\` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getAltitudeElement(): DecimalType {
    return this.altitude ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`altitude\` property.
   *
   * @param element - the \`altitude\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAltitudeElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = \`Invalid Location.position.altitude; Provided element is not an instance of DecimalType.\`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.altitude = element;
    } else {
      this.altitude = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`altitude\` property exists and has a value; \`false\` otherwise
   */
  public hasAltitudeElement(): boolean {
    return isDefined<DecimalType>(this.altitude) && !this.altitude.isEmpty();
  }

  /**
   * @returns the \`altitude\` property value as a fhirDecimal if defined; else undefined
   */
  public getAltitude(): fhirDecimal | undefined {
    return this.altitude?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`altitude\` property.
   *
   * @param value - the \`altitude\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAltitude(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = \`Invalid Location.position.altitude (\${String(value)})\`;
      this.altitude = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.altitude = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`altitude\` property exists and has a value; \`false\` otherwise
   */
  public hasAltitude(): boolean {
    return this.hasAltitudeElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Location.position';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.longitude,
      this.latitude,
      this.altitude,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): LocationPositionComponent {
    const dest = new LocationPositionComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: LocationPositionComponent): void {
    super.copyValues(dest);
    dest.longitude = this.longitude ? this.longitude.copy() : null;
    dest.latitude = this.latitude ? this.latitude.copy() : null;
    dest.altitude = this.altitude?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasLongitudeElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirDecimal>(this.getLongitudeElement()!, 'longitude', jsonObj);
    } else {
      missingReqdProperties.push(\`Location.position.longitude\`);
    }

    if (this.hasLatitudeElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirDecimal>(this.getLatitudeElement()!, 'latitude', jsonObj);
    } else {
      missingReqdProperties.push(\`Location.position.latitude\`);
    }

    if (this.hasAltitudeElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getAltitudeElement(), 'altitude', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
/**
 * LocationHoursOfOperationComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** What days/times during a week is this location usually open
 * - **Definition:** What days/times during a week is this location usually open.
 * - **Comment:** This type of information is commonly found published in directories and on websites informing customers when the facility is available. Specific services within the location may have their own hours which could be shorter (or longer) than the locations hours.
 *
 * @category Data Models: Resource
 * @see [FHIR Location](http://hl7.org/fhir/StructureDefinition/Location)
 */
export class LocationHoursOfOperationComponent extends BackboneElement implements IBackboneElement {
  constructor() {
    super();

    this.daysOfWeekEnum = new DaysOfWeekEnum();
  }

  /**
   * Parse the provided \`LocationHoursOfOperationComponent\` JSON to instantiate the LocationHoursOfOperationComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`LocationHoursOfOperationComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to LocationHoursOfOperationComponent
   * @returns LocationHoursOfOperationComponent data model or undefined for \`LocationHoursOfOperationComponent\`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): LocationHoursOfOperationComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'LocationHoursOfOperationComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new LocationHoursOfOperationComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'daysOfWeek';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: CodeType | undefined = fhirParser.parseCodeType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addDaysOfWeekElement(datatype);
        }
      });
    }

    fieldName = 'allDay';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'boolean';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: BooleanType | undefined = fhirParser.parseBooleanType(dtJson, dtSiblingJson);
      instance.setAllDayElement(datatype);
    }

    fieldName = 'openingTime';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: TimeType | undefined = fhirParser.parseTimeType(dtJson, dtSiblingJson);
      instance.setOpeningTimeElement(datatype);
    }

    fieldName = 'closingTime';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: TimeType | undefined = fhirParser.parseTimeType(dtJson, dtSiblingJson);
      instance.setClosingTimeElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: DaysOfWeek
   *
   * @see {@link DaysOfWeekEnum }
   */
  private readonly daysOfWeekEnum: DaysOfWeekEnum;

  /**
   * Location.hoursOfOperation.daysOfWeek Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** mon | tue | wed | thu | fri | sat | sun
   * - **Definition:** Indicates which days of the week are available between the start and end Times.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  private daysOfWeek?: EnumCodeType[] | undefined;

  /**
   * Location.hoursOfOperation.allDay Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The Location is open all day
   * - **Definition:** The Location is open all day.
   * - **FHIR Type:** \`boolean\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private allDay?: BooleanType | undefined;

  /**
   * Location.hoursOfOperation.openingTime Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Time that the Location opens
   * - **Definition:** Time that the Location opens.
   * - **FHIR Type:** \`time\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private openingTime?: TimeType | undefined;

  /**
   * Location.hoursOfOperation.closingTime Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Time that the Location closes
   * - **Definition:** Time that the Location closes.
   * - **FHIR Type:** \`time\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private closingTime?: TimeType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`daysOfWeek\` property value as a EnumCodeType array
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public getDaysOfWeekEnumType(): EnumCodeType[] {
    return this.daysOfWeek ?? ([] as EnumCodeType[]);
  }

  /**
   * Assigns the provided EnumCodeType array value to the \`daysOfWeek\` property.
   *
   * @param enumType - the \`daysOfWeek\` array value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public setDaysOfWeekEnumType(enumType: EnumCodeType[] | undefined): this {
    if (isDefinedList<EnumCodeType>(enumType)) {
      const errMsgPrefix = \`Invalid Location.hoursOfOperation.daysOfWeek\`;
      assertEnumCodeTypeList<DaysOfWeekEnum>(enumType, DaysOfWeekEnum, errMsgPrefix);
      this.daysOfWeek = enumType;
    } else {
      this.daysOfWeek = undefined;
    }
    return this;
  }

  /**
   * Add the provided EnumCodeType value to the \`daysOfWeek\` array property.
   *
   * @param enumType - the \`daysOfWeek\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public addDaysOfWeekEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = \`Invalid Location.hoursOfOperation.daysOfWeek\`;
      assertEnumCodeType<DaysOfWeekEnum>(enumType, DaysOfWeekEnum, errMsgPrefix);
      this.initDaysOfWeek();
      this.daysOfWeek?.push(enumType);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`daysOfWeek\` property exists and has a value; \`false\` otherwise
   */
  public hasDaysOfWeekEnumType(): boolean {
    return isDefinedList<EnumCodeType>(this.daysOfWeek) && this.daysOfWeek.some((item: EnumCodeType) => !item.isEmpty()) && this.daysOfWeek.every((item: EnumCodeType) => item.fhirCodeEnumeration.length > 0);
  }

  /**
   * @returns the \`daysOfWeek\` property value as a CodeType array
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public getDaysOfWeekElement(): CodeType[] {
    if (this.daysOfWeek === undefined) {
      return [] as CodeType[];
    }
    return this.daysOfWeek as CodeType[];
  }

  /**
   * Assigns the provided PrimitiveType array value to the \`daysOfWeek\` property.
   *
   * @param element - the \`daysOfWeek\` array value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public setDaysOfWeekElement(element: CodeType[] | undefined): this {
    if (isDefinedList<CodeType>(element)) {
      const optErrMsg = \`Invalid Location.hoursOfOperation.daysOfWeek; Provided element array has an element that is not an instance of CodeType.\`;
      assertFhirTypeList<CodeType>(element, CodeType, optErrMsg);
      const enumCodeTypes = [] as EnumCodeType[];
      element.forEach((type: CodeType) => {
        enumCodeTypes.push(new EnumCodeType(type, this.daysOfWeekEnum));
      });
      this.daysOfWeek = enumCodeTypes;
    } else {
      this.daysOfWeek = undefined;
    }
    return this;
  }

  /**
   * Add the provided PrimitiveType value to the \`daysOfWeek\` array property.
   *
   * @param element - the \`daysOfWeek\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public addDaysOfWeekElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Location.hoursOfOperation.daysOfWeek; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.initDaysOfWeek();
      this.daysOfWeek?.push(new EnumCodeType(element, this.daysOfWeekEnum));
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`daysOfWeek\` property exists and has a value; \`false\` otherwise
   */
  public hasDaysOfWeekElement(): boolean {
    return this.hasDaysOfWeekEnumType();
  }

  /**
   * @returns the \`daysOfWeek\` property value as a fhirCode array
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public getDaysOfWeek(): fhirCode[] {
    if (this.daysOfWeek === undefined) {
      return [] as fhirCode[];
    }
    const values = [] as fhirCode[];
    for (const item of this.daysOfWeek) {
      values.push(item.fhirCode.code);
    }
    return values;
  }

  /**
   * Assigns the provided primitive value array to the \`daysOfWeek\` property.
   *
   * @param value - the \`daysOfWeek\` value array
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public setDaysOfWeek(value: fhirCode[] | undefined): this {
    if (isDefinedList<fhirCode>(value)) {
      const enumCodeTypes = [] as EnumCodeType[];
      const optErrMsg = \`Invalid Location.hoursOfOperation.daysOfWeek; Provided value is not an instance of fhirCode.\`;
      value.forEach((val: fhirCode) => {
        enumCodeTypes.push(new EnumCodeType(parseFhirPrimitiveData(val, fhirCodeSchema, optErrMsg), this.daysOfWeekEnum));
      });
      this.daysOfWeek = enumCodeTypes;
    } else {
      this.daysOfWeek = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`daysOfWeek\` array property.
   *
   * @param value - the \`daysOfWeek\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public addDaysOfWeek(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      this.initDaysOfWeek();
      const optErrMsg = \`Invalid Location.hoursOfOperation.daysOfWeek; Provided value is not an instance of fhirCode.\`;
      this.daysOfWeek?.push(new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.daysOfWeekEnum));
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`daysOfWeek\` property exists and has a value; \`false\` otherwise
   */
  public hasDaysOfWeek(): boolean {
    return this.hasDaysOfWeekEnumType();
  }

  /**
   * Initialize the daysOfWeek property
   */
  private initDaysOfWeek(): void {
    if(!this.hasDaysOfWeekEnumType()) {
      this.daysOfWeek = [] as EnumCodeType[];
    }
  }

  /**
   * @returns the \`allDay\` property value as a BooleanType object if defined; else an empty BooleanType object
   */
  public getAllDayElement(): BooleanType {
    return this.allDay ?? new BooleanType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`allDay\` property.
   *
   * @param element - the \`allDay\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAllDayElement(element: BooleanType | undefined): this {
    if (isDefined<BooleanType>(element)) {
      const optErrMsg = \`Invalid Location.hoursOfOperation.allDay; Provided element is not an instance of BooleanType.\`;
      assertFhirType<BooleanType>(element, BooleanType, optErrMsg);
      this.allDay = element;
    } else {
      this.allDay = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`allDay\` property exists and has a value; \`false\` otherwise
   */
  public hasAllDayElement(): boolean {
    return isDefined<BooleanType>(this.allDay) && !this.allDay.isEmpty();
  }

  /**
   * @returns the \`allDay\` property value as a fhirBoolean if defined; else undefined
   */
  public getAllDay(): fhirBoolean | undefined {
    return this.allDay?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`allDay\` property.
   *
   * @param value - the \`allDay\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAllDay(value: fhirBoolean | undefined): this {
    if (isDefined<fhirBoolean>(value)) {
      const optErrMsg = \`Invalid Location.hoursOfOperation.allDay (\${String(value)})\`;
      this.allDay = new BooleanType(parseFhirPrimitiveData(value, fhirBooleanSchema, optErrMsg));
    } else {
      this.allDay = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`allDay\` property exists and has a value; \`false\` otherwise
   */
  public hasAllDay(): boolean {
    return this.hasAllDayElement();
  }

  /**
   * @returns the \`openingTime\` property value as a TimeType object if defined; else an empty TimeType object
   */
  public getOpeningTimeElement(): TimeType {
    return this.openingTime ?? new TimeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`openingTime\` property.
   *
   * @param element - the \`openingTime\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setOpeningTimeElement(element: TimeType | undefined): this {
    if (isDefined<TimeType>(element)) {
      const optErrMsg = \`Invalid Location.hoursOfOperation.openingTime; Provided element is not an instance of TimeType.\`;
      assertFhirType<TimeType>(element, TimeType, optErrMsg);
      this.openingTime = element;
    } else {
      this.openingTime = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`openingTime\` property exists and has a value; \`false\` otherwise
   */
  public hasOpeningTimeElement(): boolean {
    return isDefined<TimeType>(this.openingTime) && !this.openingTime.isEmpty();
  }

  /**
   * @returns the \`openingTime\` property value as a fhirTime if defined; else undefined
   */
  public getOpeningTime(): fhirTime | undefined {
    return this.openingTime?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`openingTime\` property.
   *
   * @param value - the \`openingTime\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setOpeningTime(value: fhirTime | undefined): this {
    if (isDefined<fhirTime>(value)) {
      const optErrMsg = \`Invalid Location.hoursOfOperation.openingTime (\${String(value)})\`;
      this.openingTime = new TimeType(parseFhirPrimitiveData(value, fhirTimeSchema, optErrMsg));
    } else {
      this.openingTime = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`openingTime\` property exists and has a value; \`false\` otherwise
   */
  public hasOpeningTime(): boolean {
    return this.hasOpeningTimeElement();
  }

  /**
   * @returns the \`closingTime\` property value as a TimeType object if defined; else an empty TimeType object
   */
  public getClosingTimeElement(): TimeType {
    return this.closingTime ?? new TimeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`closingTime\` property.
   *
   * @param element - the \`closingTime\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setClosingTimeElement(element: TimeType | undefined): this {
    if (isDefined<TimeType>(element)) {
      const optErrMsg = \`Invalid Location.hoursOfOperation.closingTime; Provided element is not an instance of TimeType.\`;
      assertFhirType<TimeType>(element, TimeType, optErrMsg);
      this.closingTime = element;
    } else {
      this.closingTime = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`closingTime\` property exists and has a value; \`false\` otherwise
   */
  public hasClosingTimeElement(): boolean {
    return isDefined<TimeType>(this.closingTime) && !this.closingTime.isEmpty();
  }

  /**
   * @returns the \`closingTime\` property value as a fhirTime if defined; else undefined
   */
  public getClosingTime(): fhirTime | undefined {
    return this.closingTime?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`closingTime\` property.
   *
   * @param value - the \`closingTime\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setClosingTime(value: fhirTime | undefined): this {
    if (isDefined<fhirTime>(value)) {
      const optErrMsg = \`Invalid Location.hoursOfOperation.closingTime (\${String(value)})\`;
      this.closingTime = new TimeType(parseFhirPrimitiveData(value, fhirTimeSchema, optErrMsg));
    } else {
      this.closingTime = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`closingTime\` property exists and has a value; \`false\` otherwise
   */
  public hasClosingTime(): boolean {
    return this.hasClosingTimeElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Location.hoursOfOperation';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.daysOfWeek,
      this.allDay,
      this.openingTime,
      this.closingTime,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): LocationHoursOfOperationComponent {
    const dest = new LocationHoursOfOperationComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: LocationHoursOfOperationComponent): void {
    super.copyValues(dest);
    const daysOfWeekList = copyListValues<EnumCodeType>(this.daysOfWeek);
    dest.daysOfWeek = daysOfWeekList.length === 0 ? undefined : daysOfWeekList;
    dest.allDay = this.allDay?.copy();
    dest.openingTime = this.openingTime?.copy();
    dest.closingTime = this.closingTime?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasDaysOfWeekElement()) {
      setFhirPrimitiveListJson<fhirCode>(this.getDaysOfWeekElement(), 'daysOfWeek', jsonObj);
    }

    if (this.hasAllDayElement()) {
      setFhirPrimitiveJson<fhirBoolean>(this.getAllDayElement(), 'allDay', jsonObj);
    }

    if (this.hasOpeningTimeElement()) {
      setFhirPrimitiveJson<fhirTime>(this.getOpeningTimeElement(), 'openingTime', jsonObj);
    }

    if (this.hasClosingTimeElement()) {
      setFhirPrimitiveJson<fhirTime>(this.getClosingTimeElement(), 'closingTime', jsonObj);
    }

    return jsonObj;
  }
}
",
  "fileExtension": "ts",
  "filename": "Location",
}
`;

exports[`generator-datamodel-ftest Functional Test Suite generator-app verify generated content should consistently create GeneratedContent[] 36`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/src",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/test/ftest-cache",
    "pkgName": "ftest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "Resource",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * Organization Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/Organization
 * StructureDefinition.name: Organization
 * StructureDefinition.description: A formally or informally recognized grouping of people or organizations formed for the purpose of achieving some form of collective action.  Includes companies, institutions, corporations, departments, community groups, healthcare practice groups, payer/insurer, etc.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  BackboneElement,
  BooleanType,
  DomainResource,
  FhirParser,
  IBackboneElement,
  IDomainResource,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  PrimitiveTypeJson,
  ReferenceTargets,
  StringType,
  assertFhirType,
  assertFhirTypeList,
  copyListValues,
  fhirBoolean,
  fhirBooleanSchema,
  fhirString,
  fhirStringSchema,
  getPrimitiveTypeJson,
  getPrimitiveTypeListJson,
  isDefined,
  isDefinedList,
  isElementEmpty,
  isEmpty,
  parseFhirPrimitiveData,
  setFhirBackboneElementListJson,
  setFhirComplexJson,
  setFhirComplexListJson,
  setFhirPrimitiveJson,
  setFhirPrimitiveListJson,
} from '@paq-ts-fhir/fhir-core';
import { Address, CodeableConcept, ContactPoint, HumanName, Identifier, PARSABLE_DATATYPE_MAP, Reference } from '../complex-types/complex-datatypes';
import { PARSABLE_RESOURCE_MAP } from './parsable-resource-map';

/**
 * Organization Class
 *
 * @remarks
 * A formally or informally recognized grouping of people or organizations formed for the purpose of achieving some form of collective action.  Includes companies, institutions, corporations, departments, community groups, healthcare practice groups, payer/insurer, etc.
 *
 * **FHIR Specification**
 * - **Short:** A grouping of people or organizations with a common purpose
 * - **Definition:** A formally or informally recognized grouping of people or organizations formed for the purpose of achieving some form of collective action.  Includes companies, institutions, corporations, departments, community groups, healthcare practice groups, payer/insurer, etc.
 * - **FHIR Version:** 4.0.1
 *
 * @category Data Models: Resource
 * @see [FHIR Organization](http://hl7.org/fhir/StructureDefinition/Organization)
 */
export class Organization extends DomainResource implements IDomainResource {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`Organization\` JSON to instantiate the Organization data model.
   *
   * @param sourceJson - JSON representing FHIR \`Organization\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Organization
   * @returns Organization data model or undefined for \`Organization\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static override parse(sourceJson: JSON.Value, optSourceField?: string): Organization | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Organization';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Organization();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.verifyResourceType(classJsonObj, 'Organization');
    fhirParser.processDomainResourceJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'identifier';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Identifier | undefined = Identifier.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addIdentifier(datatype);
        }
      });
    }

    fieldName = 'active';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'boolean';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: BooleanType | undefined = fhirParser.parseBooleanType(dtJson, dtSiblingJson);
      instance.setActiveElement(datatype);
    }

    fieldName = 'type';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: CodeableConcept | undefined = CodeableConcept.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addType(datatype);
        }
      });
    }

    fieldName = 'name';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setNameElement(datatype);
    }

    fieldName = 'alias';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: StringType | undefined = fhirParser.parseStringType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addAliasElement(datatype);
        }
      });
    }

    fieldName = 'telecom';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: ContactPoint | undefined = ContactPoint.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addTelecom(datatype);
        }
      });
    }

    fieldName = 'address';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Address | undefined = Address.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addAddress(datatype);
        }
      });
    }

    fieldName = 'partOf';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = Reference.parse(classJsonObj[fieldName]!, sourceField);
      instance.setPartOf(datatype);
    }

    fieldName = 'contact';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const componentJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      componentJsonArray.forEach((componentJson: JSON.Value, idx) => {
        const component: OrganizationContactComponent | undefined = OrganizationContactComponent.parse(componentJson, \`\${sourceField}[\${String(idx)}]\`);
        if (component !== undefined) {
          instance.addContact(component);
        }
      });
    }

    fieldName = 'endpoint';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Reference | undefined = Reference.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addEndpoint(datatype);
        }
      });
  }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Organization.identifier Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Identifies this organization  across multiple systems
   * - **Definition:** Identifier for the organization that is used to identify the organization across multiple disparate systems.
   * - **Requirements:** Organizations are known by a variety of ids. Some institutions maintain several, and most collect identifiers for exchange with other organizations concerning the organization.
   * - **FHIR Type:** \`Identifier\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private identifier?: Identifier[] | undefined;

  /**
   * Organization.active Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Whether the organization\\'s record is still in active use
   * - **Definition:** Whether the organization\\'s record is still in active use.
   * - **Comment:** This active flag is not intended to be used to mark an organization as temporarily closed or under construction. Instead the Location(s) within the Organization should have the suspended status. If further details of the reason for the suspension are required, then an extension on this element should be used. This element is labeled as a modifier because it may be used to mark that the resource was created in error.
   * - **Requirements:** Need a flag to indicate a record is no longer to be used and should generally be hidden for the user in the UI.
   * - **FHIR Type:** \`boolean\`
   * - **Cardinality:** 0..1
   * - **isModifier:** true
   * - **isModifierReason:** This element is labelled as a modifier because it is a status element that can indicate that a record should not be treated as valid
   * - **isSummary:** true
   */
  private active?: BooleanType | undefined;

  /**
   * Organization.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Kind of organization
   * - **Definition:** The kind(s) of organization that this is.
   * - **Comment:** Organizations can be corporations, wards, sections, clinical teams, government departments, etc. Note that code is generally a classifier of the type of organization; in many applications, codes are used to identity a particular organization (say, ward) as opposed to another of the same type - these are identifiers, not codes When considering if multiple types are appropriate, you should evaluate if child organizations would be a more appropriate use of the concept, as different types likely are in different sub-areas of the organization. This is most likely to be used where type values have orthogonal values, such as a religious, academic and medical center. We expect that some jurisdictions will profile this optionality to be a single cardinality.
   * - **Requirements:** Need to be able to track the kind of organization that this is - different organization types have different uses.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private type_?: CodeableConcept[] | undefined;

  /**
   * Organization.name Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Name used for the organization
   * - **Definition:** A name associated with the organization.
   * - **Comment:** If the name of an organization changes, consider putting the old name in the alias column so that it can still be located through searches.
   * - **Requirements:** Need to use the name as the label of the organization.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private name?: StringType | undefined;

  /**
   * Organization.alias Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A list of alternate names that the organization is known as, or was known as in the past
   * - **Definition:** A list of alternate names that the organization is known as, or was known as in the past.
   * - **Comment:** There are no dates associated with the alias/historic names, as this is not intended to track when names were used, but to assist in searching so that older names can still result in identifying the organization.
   * - **Requirements:** Over time locations and organizations go through many changes and can be known by different names. For searching knowing previous names that the organization was known by can be very useful.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private alias?: StringType[] | undefined;

  /**
   * Organization.telecom Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A contact detail for the organization
   * - **Definition:** A contact detail for the organization.
   * - **Comment:** The use code \\'home\\' is not to be used. Note that these contacts are not the contact details of people who are employed by or represent the organization, but official contacts for the organization itself.
   * - **Requirements:** Human contact for the organization.
   * - **FHIR Type:** \`ContactPoint\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private telecom?: ContactPoint[] | undefined;

  /**
   * Organization.address Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** An address for the organization
   * - **Definition:** An address for the organization.
   * - **Comment:** Organization may have multiple addresses with different uses or applicable periods. The use code \\'home\\' is not to be used.
   * - **Requirements:** May need to keep track of the organization\\'s addresses for contacting, billing or reporting requirements.
   * - **FHIR Type:** \`Address\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private address?: Address[] | undefined;

  /**
   * Organization.partOf Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The organization of which this organization forms a part
   * - **Definition:** The organization of which this organization forms a part.
   * - **Requirements:** Need to be able to track the hierarchy of organizations within an organization.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Organization',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private partOf?: Reference | undefined;

  /**
   * Organization.contact Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Contact for the organization for a certain purpose
   * - **Definition:** Contact for the organization for a certain purpose.
   * - **Comment:** Where multiple contacts for the same purpose are provided there is a standard extension that can be used to determine which one is the preferred contact to use.
   * - **Requirements:** Need to keep track of assigned contact points within bigger organization.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private contact?: OrganizationContactComponent[] | undefined;

  /**
   * Organization.endpoint Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Technical endpoints providing access to services operated for the organization
   * - **Definition:** Technical endpoints providing access to services operated for the organization.
   * - **Requirements:** Organizations have multiple systems that provide various services and need to be able to define the technical connection details for how to connect to them, and for what purpose.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Endpoint',
   *     ]
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private endpoint?: Reference[] | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`identifier\` property value as a Identifier array
   */
  public getIdentifier(): Identifier[] {
    return this.identifier ?? ([] as Identifier[]);
  }

  /**
   * Assigns the provided Identifier array value to the \`identifier\` property.
   *
   * @param value - the \`identifier\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setIdentifier(value: Identifier[] | undefined): this {
    if (isDefinedList<Identifier>(value)) {
      const optErrMsg = \`Invalid Organization.identifier; Provided value array has an element that is not an instance of Identifier.\`;
      assertFhirTypeList<Identifier>(value, Identifier, optErrMsg);
      this.identifier = value;
    } else {
      this.identifier = undefined;
    }
    return this;
  }

  /**
   * Add the provided Identifier value to the \`identifier\` array property.
   *
   * @param value - the \`identifier\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addIdentifier(value: Identifier | undefined): this {
    if (isDefined<Identifier>(value)) {
      const optErrMsg = \`Invalid Organization.identifier; Provided element is not an instance of Identifier.\`;
      assertFhirType<Identifier>(value, Identifier, optErrMsg);
      this.initIdentifier();
      this.identifier?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`identifier\` property exists and has a value; \`false\` otherwise
   */
  public hasIdentifier(): boolean {
    return isDefinedList<Identifier>(this.identifier) && this.identifier.some((item: Identifier) => !item.isEmpty());
  }

  /**
   * Initialize the \`identifier\` property
   */
  private initIdentifier(): void {
    if(!this.hasIdentifier()) {
      this.identifier = [] as Identifier[];
    }
  }

  /**
   * @returns the \`active\` property value as a BooleanType object if defined; else an empty BooleanType object
   */
  public getActiveElement(): BooleanType {
    return this.active ?? new BooleanType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`active\` property.
   *
   * @param element - the \`active\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setActiveElement(element: BooleanType | undefined): this {
    if (isDefined<BooleanType>(element)) {
      const optErrMsg = \`Invalid Organization.active; Provided element is not an instance of BooleanType.\`;
      assertFhirType<BooleanType>(element, BooleanType, optErrMsg);
      this.active = element;
    } else {
      this.active = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`active\` property exists and has a value; \`false\` otherwise
   */
  public hasActiveElement(): boolean {
    return isDefined<BooleanType>(this.active) && !this.active.isEmpty();
  }

  /**
   * @returns the \`active\` property value as a fhirBoolean if defined; else undefined
   */
  public getActive(): fhirBoolean | undefined {
    return this.active?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`active\` property.
   *
   * @param value - the \`active\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setActive(value: fhirBoolean | undefined): this {
    if (isDefined<fhirBoolean>(value)) {
      const optErrMsg = \`Invalid Organization.active (\${String(value)})\`;
      this.active = new BooleanType(parseFhirPrimitiveData(value, fhirBooleanSchema, optErrMsg));
    } else {
      this.active = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`active\` property exists and has a value; \`false\` otherwise
   */
  public hasActive(): boolean {
    return this.hasActiveElement();
  }

  /**
   * @returns the \`type_\` property value as a CodeableConcept array
   */
  public getType(): CodeableConcept[] {
    return this.type_ ?? ([] as CodeableConcept[]);
  }

  /**
   * Assigns the provided CodeableConcept array value to the \`type_\` property.
   *
   * @param value - the \`type_\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setType(value: CodeableConcept[] | undefined): this {
    if (isDefinedList<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Organization.type; Provided value array has an element that is not an instance of CodeableConcept.\`;
      assertFhirTypeList<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.type_ = value;
    } else {
      this.type_ = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeableConcept value to the \`type_\` array property.
   *
   * @param value - the \`type_\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addType(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Organization.type; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.initType();
      this.type_?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasType(): boolean {
    return isDefinedList<CodeableConcept>(this.type_) && this.type_.some((item: CodeableConcept) => !item.isEmpty());
  }

  /**
   * Initialize the \`type_\` property
   */
  private initType(): void {
    if(!this.hasType()) {
      this.type_ = [] as CodeableConcept[];
    }
  }

  /**
   * @returns the \`name\` property value as a StringType object if defined; else an empty StringType object
   */
  public getNameElement(): StringType {
    return this.name ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`name\` property.
   *
   * @param element - the \`name\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setNameElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Organization.name; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.name = element;
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`name\` property exists and has a value; \`false\` otherwise
   */
  public hasNameElement(): boolean {
    return isDefined<StringType>(this.name) && !this.name.isEmpty();
  }

  /**
   * @returns the \`name\` property value as a fhirString if defined; else undefined
   */
  public getName(): fhirString | undefined {
    return this.name?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`name\` property.
   *
   * @param value - the \`name\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setName(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Organization.name (\${String(value)})\`;
      this.name = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`name\` property exists and has a value; \`false\` otherwise
   */
  public hasName(): boolean {
    return this.hasNameElement();
  }

  /**
   * @returns the \`alias\` property value as a StringType array
   */
  public getAliasElement(): StringType[] {
    return this.alias ?? ([] as StringType[]);
  }

  /**
   * Assigns the provided StringType array value to the \`alias\` property.
   *
   * @param element - the \`alias\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAliasElement(element: StringType[] | undefined): this {
    if (isDefinedList<StringType>(element)) {
      const optErrMsg = \`Invalid Organization.alias; Provided value array has an element that is not an instance of StringType.\`;
      assertFhirTypeList<StringType>(element, StringType, optErrMsg);
      this.alias = element;
    } else {
      this.alias = undefined;
    }
    return this;
  }

  /**
   * Add the provided StringType value to the \`alias\` array property.
   *
   * @param element - the \`alias\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addAliasElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid Organization.alias; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.initAlias();
      this.alias?.push(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`alias\` property exists and has a value; \`false\` otherwise
   */
  public hasAliasElement(): boolean {
    return isDefinedList<StringType>(this.alias) && this.alias.some((item: StringType) => !item.isEmpty());
  }

  /**
   * @returns the \`alias\` property value as a fhirString array
   */
  public getAlias(): fhirString[] {
    this.initAlias();
    const aliasValues = [] as fhirString[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.alias!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        aliasValues.push(value);
      }
    }
    return aliasValues;
  }

  /**
   * Assigns the provided primitive value array to the \`alias\` property.
   *
   * @param value - the \`alias\` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAlias(value: fhirString[] | undefined): this {
    if (isDefinedList<fhirString>(value)) {
      const aliasElements = [] as StringType[];
      for (const aliasValue of value) {
        const optErrMsg = \`Invalid Organization.alias array item (\${String(aliasValue)})\`;
        const element = new StringType(parseFhirPrimitiveData(aliasValue, fhirStringSchema, optErrMsg));
        aliasElements.push(element);
      }
      this.alias = aliasElements;
    } else {
      this.alias = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`alias\` array property.
   *
   * @param value - the \`alias\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addAlias(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid Organization.alias array item (\${String(value)})\`;
      const element = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
      this.initAlias();
      this.addAliasElement(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`alias\` property exists and has a value; \`false\` otherwise
   */
  public hasAlias(): boolean {
    return this.hasAliasElement();
  }

  /**
   * Initialize the \`alias\` property
   */
  private initAlias(): void {
    if (!this.hasAlias()) {
      this.alias = [] as StringType[];
    }
  }

  /**
   * @returns the \`telecom\` property value as a ContactPoint array
   */
  public getTelecom(): ContactPoint[] {
    return this.telecom ?? ([] as ContactPoint[]);
  }

  /**
   * Assigns the provided ContactPoint array value to the \`telecom\` property.
   *
   * @param value - the \`telecom\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setTelecom(value: ContactPoint[] | undefined): this {
    if (isDefinedList<ContactPoint>(value)) {
      const optErrMsg = \`Invalid Organization.telecom; Provided value array has an element that is not an instance of ContactPoint.\`;
      assertFhirTypeList<ContactPoint>(value, ContactPoint, optErrMsg);
      this.telecom = value;
    } else {
      this.telecom = undefined;
    }
    return this;
  }

  /**
   * Add the provided ContactPoint value to the \`telecom\` array property.
   *
   * @param value - the \`telecom\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addTelecom(value: ContactPoint | undefined): this {
    if (isDefined<ContactPoint>(value)) {
      const optErrMsg = \`Invalid Organization.telecom; Provided element is not an instance of ContactPoint.\`;
      assertFhirType<ContactPoint>(value, ContactPoint, optErrMsg);
      this.initTelecom();
      this.telecom?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`telecom\` property exists and has a value; \`false\` otherwise
   */
  public hasTelecom(): boolean {
    return isDefinedList<ContactPoint>(this.telecom) && this.telecom.some((item: ContactPoint) => !item.isEmpty());
  }

  /**
   * Initialize the \`telecom\` property
   */
  private initTelecom(): void {
    if(!this.hasTelecom()) {
      this.telecom = [] as ContactPoint[];
    }
  }

  /**
   * @returns the \`address\` property value as a Address array
   */
  public getAddress(): Address[] {
    return this.address ?? ([] as Address[]);
  }

  /**
   * Assigns the provided Address array value to the \`address\` property.
   *
   * @param value - the \`address\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setAddress(value: Address[] | undefined): this {
    if (isDefinedList<Address>(value)) {
      const optErrMsg = \`Invalid Organization.address; Provided value array has an element that is not an instance of Address.\`;
      assertFhirTypeList<Address>(value, Address, optErrMsg);
      this.address = value;
    } else {
      this.address = undefined;
    }
    return this;
  }

  /**
   * Add the provided Address value to the \`address\` array property.
   *
   * @param value - the \`address\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addAddress(value: Address | undefined): this {
    if (isDefined<Address>(value)) {
      const optErrMsg = \`Invalid Organization.address; Provided element is not an instance of Address.\`;
      assertFhirType<Address>(value, Address, optErrMsg);
      this.initAddress();
      this.address?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`address\` property exists and has a value; \`false\` otherwise
   */
  public hasAddress(): boolean {
    return isDefinedList<Address>(this.address) && this.address.some((item: Address) => !item.isEmpty());
  }

  /**
   * Initialize the \`address\` property
   */
  private initAddress(): void {
    if(!this.hasAddress()) {
      this.address = [] as Address[];
    }
  }

  /**
   * @returns the \`partOf\` property value as a Reference object; else an empty Reference object
   */
  public getPartOf(): Reference {
    return this.partOf ?? new Reference();
  }

  /**
   * Assigns the provided PartOf object value to the \`partOf\` property.
   *
   * @decorator \`@ReferenceTargets('Organization.partOf', ['Organization',])\`
   *
   * @param value - the \`partOf\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('Organization.partOf', [
    'Organization',
  ])
  public setPartOf(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.partOf = value;
    } else {
      this.partOf = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`partOf\` property exists and has a value; \`false\` otherwise
   */
  public hasPartOf(): boolean {
    return isDefined<Reference>(this.partOf) && !this.partOf.isEmpty();
  }

  /**
   * @returns the \`contact\` property value as a OrganizationContactComponent array
   */
  public getContact(): OrganizationContactComponent[] {
    return this.contact ?? ([] as OrganizationContactComponent[]);
  }

  /**
   * Assigns the provided OrganizationContactComponent array value to the \`contact\` property.
   *
   * @param value - the \`contact\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setContact(value: OrganizationContactComponent[] | undefined): this {
    if (isDefinedList<OrganizationContactComponent>(value)) {
      const optErrMsg = \`Invalid Organization.contact; Provided value array has an element that is not an instance of OrganizationContactComponent.\`;
      assertFhirTypeList<OrganizationContactComponent>(value, OrganizationContactComponent, optErrMsg);
      this.contact = value;
    } else {
      this.contact = undefined;
    }
    return this;
  }

  /**
   * Add the provided OrganizationContactComponent value to the \`contact\` array property.
   *
   * @param value - the \`contact\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addContact(value: OrganizationContactComponent | undefined): this {
    if (isDefined<OrganizationContactComponent>(value)) {
      const optErrMsg = \`Invalid Organization.contact; Provided element is not an instance of OrganizationContactComponent.\`;
      assertFhirType<OrganizationContactComponent>(value, OrganizationContactComponent, optErrMsg);
      this.initContact();
      this.contact?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`contact\` property exists and has a value; \`false\` otherwise
   */
  public hasContact(): boolean {
    return isDefinedList<OrganizationContactComponent>(this.contact) && this.contact.some((item: OrganizationContactComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`contact\` property
   */
  private initContact(): void {
    if(!this.hasContact()) {
      this.contact = [] as OrganizationContactComponent[];
    }
  }

  /**
   * @returns the \`endpoint\` property value as a Reference array
   */
  public getEndpoint(): Reference[] {
    return this.endpoint ?? ([] as Reference[]);
  }

  /**
   * Assigns the provided Reference array value to the \`endpoint\` property.
   *
   * @decorator \`@ReferenceTargets('Organization.endpoint', ['Endpoint',])\`
   *
   * @param value - the \`endpoint\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('Organization.endpoint', [
    'Endpoint',
  ])
  public setEndpoint(value: Reference[] | undefined): this {
    if (isDefinedList<Reference>(value)) {
      // assertFhirTypeList<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.endpoint = value;
    } else {
      this.endpoint = undefined;
    }
    return this;
  }

  /**
   * Add the provided Reference value to the \`endpoint\` array property.
   *
   * @decorator \`@ReferenceTargets('Organization.endpoint', ['Endpoint',])\`
   *
   * @param value - the \`endpoint\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('Organization.endpoint', [
    'Endpoint',
  ])
  public addEndpoint(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.initEndpoint();
      this.endpoint?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`endpoint\` property exists and has a value; \`false\` otherwise
   */
  public hasEndpoint(): boolean {
    return isDefinedList<Reference>(this.endpoint) && this.endpoint.some((item: Reference) => !item.isEmpty());
  }

  /**
   * Initialize the \`endpoint\` property
   */
  private initEndpoint(): void {
    if (!this.hasEndpoint()) {
      this.endpoint = [] as Reference[];
    }
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Organization';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.identifier,
      this.active,
      this.type_,
      this.name,
      this.alias,
      this.telecom,
      this.address,
      this.partOf,
      this.contact,
      this.endpoint,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Organization {
    const dest = new Organization();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Organization): void {
    super.copyValues(dest);
    const identifierList = copyListValues<Identifier>(this.identifier);
    dest.identifier = identifierList.length === 0 ? undefined : identifierList;
    dest.active = this.active?.copy();
    const typeList = copyListValues<CodeableConcept>(this.type_);
    dest.type_ = typeList.length === 0 ? undefined : typeList;
    dest.name = this.name?.copy();
    const aliasList = copyListValues<StringType>(this.alias);
    dest.alias = aliasList.length === 0 ? undefined : aliasList;
    const telecomList = copyListValues<ContactPoint>(this.telecom);
    dest.telecom = telecomList.length === 0 ? undefined : telecomList;
    const addressList = copyListValues<Address>(this.address);
    dest.address = addressList.length === 0 ? undefined : addressList;
    dest.partOf = this.partOf?.copy();
    const contactList = copyListValues<OrganizationContactComponent>(this.contact);
    dest.contact = contactList.length === 0 ? undefined : contactList;
    const endpointList = copyListValues<Reference>(this.endpoint);
    dest.endpoint = endpointList.length === 0 ? undefined : endpointList;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasIdentifier()) {
      setFhirComplexListJson(this.getIdentifier(), 'identifier', jsonObj);
    }

    if (this.hasActiveElement()) {
      setFhirPrimitiveJson<fhirBoolean>(this.getActiveElement(), 'active', jsonObj);
    }

    if (this.hasType()) {
      setFhirComplexListJson(this.getType(), 'type', jsonObj);
    }

    if (this.hasNameElement()) {
      setFhirPrimitiveJson<fhirString>(this.getNameElement(), 'name', jsonObj);
    }

    if (this.hasAlias()) {
      setFhirPrimitiveListJson(this.getAliasElement(), 'alias', jsonObj);
    }

    if (this.hasTelecom()) {
      setFhirComplexListJson(this.getTelecom(), 'telecom', jsonObj);
    }

    if (this.hasAddress()) {
      setFhirComplexListJson(this.getAddress(), 'address', jsonObj);
    }

    if (this.hasPartOf()) {
      setFhirComplexJson(this.getPartOf(), 'partOf', jsonObj);
    }

    if (this.hasContact()) {
      setFhirBackboneElementListJson(this.getContact(), 'contact', jsonObj);
    }

    if (this.hasEndpoint()) {
      setFhirComplexListJson(this.getEndpoint(), 'endpoint', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * OrganizationContactComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Contact for the organization for a certain purpose
 * - **Definition:** Contact for the organization for a certain purpose.
 * - **Comment:** Where multiple contacts for the same purpose are provided there is a standard extension that can be used to determine which one is the preferred contact to use.
 * - **Requirements:** Need to keep track of assigned contact points within bigger organization.
 *
 * @category Data Models: Resource
 * @see [FHIR Organization](http://hl7.org/fhir/StructureDefinition/Organization)
 */
export class OrganizationContactComponent extends BackboneElement implements IBackboneElement {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`OrganizationContactComponent\` JSON to instantiate the OrganizationContactComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`OrganizationContactComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to OrganizationContactComponent
   * @returns OrganizationContactComponent data model or undefined for \`OrganizationContactComponent\`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): OrganizationContactComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'OrganizationContactComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new OrganizationContactComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';

    fieldName = 'purpose';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = CodeableConcept.parse(classJsonObj[fieldName]!, sourceField);
      instance.setPurpose(datatype);
    }

    fieldName = 'name';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: HumanName | undefined = HumanName.parse(classJsonObj[fieldName]!, sourceField);
      instance.setName(datatype);
    }

    fieldName = 'telecom';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: ContactPoint | undefined = ContactPoint.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addTelecom(datatype);
        }
      });
    }

    fieldName = 'address';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Address | undefined = Address.parse(classJsonObj[fieldName]!, sourceField);
      instance.setAddress(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Organization.contact.purpose Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The type of contact
   * - **Definition:** Indicates a purpose for which the contact can be reached.
   * - **Requirements:** Need to distinguish between multiple contact persons.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private purpose?: CodeableConcept | undefined;

  /**
   * Organization.contact.name Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A name associated with the contact
   * - **Definition:** A name associated with the contact.
   * - **Requirements:** Need to be able to track the person by name.
   * - **FHIR Type:** \`HumanName\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private name?: HumanName | undefined;

  /**
   * Organization.contact.telecom Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Contact details (telephone, email, etc.)  for a contact
   * - **Definition:** A contact detail (e.g. a telephone number or an email address) by which the party may be contacted.
   * - **Requirements:** People have (primary) ways to contact them in some way such as phone, email.
   * - **FHIR Type:** \`ContactPoint\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private telecom?: ContactPoint[] | undefined;

  /**
   * Organization.contact.address Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Visiting or postal addresses for the contact
   * - **Definition:** Visiting or postal addresses for the contact.
   * - **Requirements:** May need to keep track of a contact party\\'s address for contacting, billing or reporting requirements.
   * - **FHIR Type:** \`Address\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private address?: Address | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`purpose\` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getPurpose(): CodeableConcept {
    return this.purpose ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Purpose object value to the \`purpose\` property.
   *
   * @param value - the \`purpose\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setPurpose(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Organization.contact.purpose; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.purpose = value;
    } else {
      this.purpose = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`purpose\` property exists and has a value; \`false\` otherwise
   */
  public hasPurpose(): boolean {
    return isDefined<CodeableConcept>(this.purpose) && !this.purpose.isEmpty();
  }

  /**
   * @returns the \`name\` property value as a HumanName object if defined; else an empty HumanName object
   */
  public getName(): HumanName {
    return this.name ?? new HumanName();
  }

  /**
   * Assigns the provided Name object value to the \`name\` property.
   *
   * @param value - the \`name\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setName(value: HumanName | undefined): this {
    if (isDefined<HumanName>(value)) {
      const optErrMsg = \`Invalid Organization.contact.name; Provided element is not an instance of HumanName.\`;
      assertFhirType<HumanName>(value, HumanName, optErrMsg);
      this.name = value;
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`name\` property exists and has a value; \`false\` otherwise
   */
  public hasName(): boolean {
    return isDefined<HumanName>(this.name) && !this.name.isEmpty();
  }

  /**
   * @returns the \`telecom\` property value as a ContactPoint array
   */
  public getTelecom(): ContactPoint[] {
    return this.telecom ?? ([] as ContactPoint[]);
  }

  /**
   * Assigns the provided ContactPoint array value to the \`telecom\` property.
   *
   * @param value - the \`telecom\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setTelecom(value: ContactPoint[] | undefined): this {
    if (isDefinedList<ContactPoint>(value)) {
      const optErrMsg = \`Invalid Organization.contact.telecom; Provided value array has an element that is not an instance of ContactPoint.\`;
      assertFhirTypeList<ContactPoint>(value, ContactPoint, optErrMsg);
      this.telecom = value;
    } else {
      this.telecom = undefined;
    }
    return this;
  }

  /**
   * Add the provided ContactPoint value to the \`telecom\` array property.
   *
   * @param value - the \`telecom\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addTelecom(value: ContactPoint | undefined): this {
    if (isDefined<ContactPoint>(value)) {
      const optErrMsg = \`Invalid Organization.contact.telecom; Provided element is not an instance of ContactPoint.\`;
      assertFhirType<ContactPoint>(value, ContactPoint, optErrMsg);
      this.initTelecom();
      this.telecom?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`telecom\` property exists and has a value; \`false\` otherwise
   */
  public hasTelecom(): boolean {
    return isDefinedList<ContactPoint>(this.telecom) && this.telecom.some((item: ContactPoint) => !item.isEmpty());
  }

  /**
   * Initialize the \`telecom\` property
   */
  private initTelecom(): void {
    if(!this.hasTelecom()) {
      this.telecom = [] as ContactPoint[];
    }
  }

  /**
   * @returns the \`address\` property value as a Address object if defined; else an empty Address object
   */
  public getAddress(): Address {
    return this.address ?? new Address();
  }

  /**
   * Assigns the provided Address object value to the \`address\` property.
   *
   * @param value - the \`address\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setAddress(value: Address | undefined): this {
    if (isDefined<Address>(value)) {
      const optErrMsg = \`Invalid Organization.contact.address; Provided element is not an instance of Address.\`;
      assertFhirType<Address>(value, Address, optErrMsg);
      this.address = value;
    } else {
      this.address = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`address\` property exists and has a value; \`false\` otherwise
   */
  public hasAddress(): boolean {
    return isDefined<Address>(this.address) && !this.address.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Organization.contact';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.purpose,
      this.name,
      this.telecom,
      this.address,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): OrganizationContactComponent {
    const dest = new OrganizationContactComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: OrganizationContactComponent): void {
    super.copyValues(dest);
    dest.purpose = this.purpose?.copy();
    dest.name = this.name?.copy();
    const telecomList = copyListValues<ContactPoint>(this.telecom);
    dest.telecom = telecomList.length === 0 ? undefined : telecomList;
    dest.address = this.address?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasPurpose()) {
      setFhirComplexJson(this.getPurpose(), 'purpose', jsonObj);
    }

    if (this.hasName()) {
      setFhirComplexJson(this.getName(), 'name', jsonObj);
    }

    if (this.hasTelecom()) {
      setFhirComplexListJson(this.getTelecom(), 'telecom', jsonObj);
    }

    if (this.hasAddress()) {
      setFhirComplexJson(this.getAddress(), 'address', jsonObj);
    }

    return jsonObj;
  }
}
",
  "fileExtension": "ts",
  "filename": "Organization",
}
`;

exports[`generator-datamodel-ftest Functional Test Suite generator-app verify generated content should consistently create GeneratedContent[] 37`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/src",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/test/ftest-cache",
    "pkgName": "ftest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "Resource",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * Patient Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/Patient
 * StructureDefinition.name: Patient
 * StructureDefinition.description: Demographics and other administrative information about an individual or animal receiving care or other health-related services.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  BackboneElement,
  BooleanType,
  ChoiceDataTypes,
  ChoiceDataTypesMeta,
  CodeType,
  DateTimeType,
  DateType,
  DomainResource,
  EnumCodeType,
  FhirError,
  FhirParser,
  IBackboneElement,
  IDataType,
  IDomainResource,
  INSTANCE_EMPTY_ERROR_MSG,
  IntegerType,
  InvalidTypeError,
  JSON,
  REQUIRED_PROPERTIES_DO_NOT_EXIST,
  REQUIRED_PROPERTIES_REQD_IN_JSON,
  ReferenceTargets,
  assertEnumCodeType,
  assertFhirType,
  assertFhirTypeList,
  assertIsDefined,
  constructorCodeValueAsEnumCodeType,
  copyListValues,
  fhirBoolean,
  fhirBooleanSchema,
  fhirCode,
  fhirCodeSchema,
  fhirDate,
  fhirDateSchema,
  getPrimitiveTypeJson,
  isDefined,
  isDefinedList,
  isElementEmpty,
  isEmpty,
  parseFhirPrimitiveData,
  setFhirBackboneElementListJson,
  setFhirComplexJson,
  setFhirComplexListJson,
  setFhirPrimitiveJson,
  setPolymorphicValueJson,
} from '@paq-ts-fhir/fhir-core';
import { Address, Attachment, CodeableConcept, ContactPoint, HumanName, Identifier, PARSABLE_DATATYPE_MAP, Period, Reference } from '../complex-types/complex-datatypes';
import { AdministrativeGenderEnum } from '../code-systems/AdministrativeGenderEnum';
import { LinkTypeEnum } from '../code-systems/LinkTypeEnum';
import { PARSABLE_RESOURCE_MAP } from './parsable-resource-map';

// eslint-disable-next-line @typescript-eslint/no-explicit-any -- Symbol.metadata polyfill secret sauce for decorator metadata
(Symbol.metadata as any) ??= Symbol('Symbol.metadata');

/**
 * Patient Class
 *
 * @remarks
 * Demographics and other administrative information about an individual or animal receiving care or other health-related services.
 *
 * Tracking patient is the center of the healthcare process.
 *
 * **FHIR Specification**
 * - **Short:** Information about an individual or animal receiving health care services
 * - **Definition:** Demographics and other administrative information about an individual or animal receiving care or other health-related services.
 * - **FHIR Version:** 4.0.1
 *
 * @category Data Models: Resource
 * @see [FHIR Patient](http://hl7.org/fhir/StructureDefinition/Patient)
 */
export class Patient extends DomainResource implements IDomainResource {
  constructor() {
    super();

    this.administrativeGenderEnum = new AdministrativeGenderEnum();
  }

  /**
   * Parse the provided \`Patient\` JSON to instantiate the Patient data model.
   *
   * @param sourceJson - JSON representing FHIR \`Patient\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Patient
   * @returns Patient data model or undefined for \`Patient\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static override parse(sourceJson: JSON.Value, optSourceField?: string): Patient | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Patient';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Patient();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.verifyResourceType(classJsonObj, 'Patient');
    fhirParser.processDomainResourceJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const classMetadata: DecoratorMetadataObject | null = Patient[Symbol.metadata];
    const errorMessage = \`DecoratorMetadataObject does not exist for Patient\`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    fieldName = 'identifier';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Identifier | undefined = Identifier.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addIdentifier(datatype);
        }
      });
    }

    fieldName = 'active';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'boolean';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: BooleanType | undefined = fhirParser.parseBooleanType(dtJson, dtSiblingJson);
      instance.setActiveElement(datatype);
    }

    fieldName = 'name';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: HumanName | undefined = HumanName.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addName(datatype);
        }
      });
    }

    fieldName = 'telecom';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: ContactPoint | undefined = ContactPoint.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addTelecom(datatype);
        }
      });
    }

    fieldName = 'gender';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setGenderElement(datatype);
    }

    fieldName = 'birthDate';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DateType | undefined = fhirParser.parseDateType(dtJson, dtSiblingJson);
      instance.setBirthDateElement(datatype);
    }

    fieldName = 'deceased[x]';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const deceased: IDataType | undefined = fhirParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setDeceased(deceased);

    fieldName = 'address';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Address | undefined = Address.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addAddress(datatype);
        }
      });
    }

    fieldName = 'maritalStatus';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = CodeableConcept.parse(classJsonObj[fieldName]!, sourceField);
      instance.setMaritalStatus(datatype);
    }

    fieldName = 'multipleBirth[x]';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const multipleBirth: IDataType | undefined = fhirParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setMultipleBirth(multipleBirth);

    fieldName = 'photo';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Attachment | undefined = Attachment.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addPhoto(datatype);
        }
      });
    }

    fieldName = 'contact';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const componentJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      componentJsonArray.forEach((componentJson: JSON.Value, idx) => {
        const component: PatientContactComponent | undefined = PatientContactComponent.parse(componentJson, \`\${sourceField}[\${String(idx)}]\`);
        if (component !== undefined) {
          instance.addContact(component);
        }
      });
    }

    fieldName = 'communication';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const componentJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      componentJsonArray.forEach((componentJson: JSON.Value, idx) => {
        const component: PatientCommunicationComponent | undefined = PatientCommunicationComponent.parse(componentJson, \`\${sourceField}[\${String(idx)}]\`);
        if (component !== undefined) {
          instance.addCommunication(component);
        }
      });
    }

    fieldName = 'generalPractitioner';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Reference | undefined = Reference.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addGeneralPractitioner(datatype);
        }
      });
  }

    fieldName = 'managingOrganization';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = Reference.parse(classJsonObj[fieldName]!, sourceField);
      instance.setManagingOrganization(datatype);
    }

    fieldName = 'link';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const componentJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      componentJsonArray.forEach((componentJson: JSON.Value, idx) => {
        const component: PatientLinkComponent | undefined = PatientLinkComponent.parse(componentJson, \`\${sourceField}[\${String(idx)}]\`);
        if (component !== undefined) {
          instance.addLink(component);
        }
      });
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Patient.identifier Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** An identifier for this patient
   * - **Definition:** An identifier for this patient.
   * - **Requirements:** Patients are almost always assigned specific numerical identifiers.
   * - **FHIR Type:** \`Identifier\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private identifier?: Identifier[] | undefined;

  /**
   * Patient.active Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Whether this patient\\'s record is in active use
   * - **Definition:** Whether this patient record is in active use.  Many systems use this property to mark as non-current patients, such as those that have not been seen for a period of time based on an organization\\'s business rules. It is often used to filter patient lists to exclude inactive patients Deceased patients may also be marked as inactive for the same reasons, but may be active for some time after death.
   * - **Comment:** If a record is inactive, and linked to an active record, then future patient/record updates should occur on the other patient.
   * - **Requirements:** Need to be able to mark a patient record as not to be used because it was created in error.
   * - **FHIR Type:** \`boolean\`
   * - **Cardinality:** 0..1
   * - **isModifier:** true
   * - **isModifierReason:** This element is labelled as a modifier because it is a status element that can indicate that a record should not be treated as valid
   * - **isSummary:** true
   */
  private active?: BooleanType | undefined;

  /**
   * Patient.name Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A name associated with the patient
   * - **Definition:** A name associated with the individual.
   * - **Comment:** A patient may have multiple names with different uses or applicable periods. For animals, the name is a "HumanName" in the sense that is assigned and used by humans and has the same patterns.
   * - **Requirements:** Need to be able to track the patient by multiple names. Examples are your official name and a partner name.
   * - **FHIR Type:** \`HumanName\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private name?: HumanName[] | undefined;

  /**
   * Patient.telecom Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A contact detail for the individual
   * - **Definition:** A contact detail (e.g. a telephone number or an email address) by which the individual may be contacted.
   * - **Comment:** A Patient may have multiple ways to be contacted with different uses or applicable periods.  May need to have options for contacting the person urgently and also to help with identification. The address might not go directly to the individual, but may reach another party that is able to proxy for the patient (i.e. home phone, or pet owner\\'s phone).
   * - **Requirements:** People have (primary) ways to contact them in some way such as phone, email.
   * - **FHIR Type:** \`ContactPoint\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private telecom?: ContactPoint[] | undefined;

  /**
   * FHIR CodeSystem: AdministrativeGender
   *
   * @see {@link AdministrativeGenderEnum }
   */
  private readonly administrativeGenderEnum: AdministrativeGenderEnum;

  /**
   * Patient.gender Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** male | female | other | unknown
   * - **Definition:** Administrative Gender - the gender that the patient is considered to have for administration and record keeping purposes.
   * - **Comment:** The gender might not match the biological sex as determined by genetics or the individual\\'s preferred identification. Note that for both humans and particularly animals, there are other legitimate possibilities than male and female, though the vast majority of systems and contexts only support male and female.  Systems providing decision support or enforcing business rules should ideally do this on the basis of Observations dealing with the specific sex or gender aspect of interest (anatomical, chromosomal, social, etc.)  However, because these observations are infrequently recorded, defaulting to the administrative gender is common practice.  Where such defaulting occurs, rule enforcement should allow for the variation between administrative and biological, chromosomal and other gender aspects.  For example, an alert about a hysterectomy on a male should be handled as a warning or overridable error, not a "hard" error.  See the Patient Gender and Sex section for additional information about communicating patient gender and sex.
   * - **Requirements:** Needed for identification of the individual, in combination with (at least) name and birth date.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link AdministrativeGenderEnum }
   */
  private gender?: EnumCodeType | undefined;

  /**
   * Patient.birthDate Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The date of birth for the individual
   * - **Definition:** The date of birth for the individual.
   * - **Comment:** At least an estimated year should be provided as a guess if the real DOB is unknown  There is a standard extension "patient-birthTime" available that should be used where Time is required (such as in maternity/infant care systems).
   * - **Requirements:** Age of the individual drives many clinical processes.
   * - **FHIR Type:** \`date\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private birthDate?: DateType | undefined;

  /**
   * Patient.deceased[x] Element
   *
   * @decorator \`@ChoiceDataTypesMeta('Patient.deceased[x]', ['boolean','dateTime',]\`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Indicates if the individual is deceased or not
   * - **Definition:** Indicates if the individual is deceased or not.
   * - **Comment:** If there\\'s no value in the instance, it means there is no statement on whether or not the individual is deceased. Most systems will interpret the absence of a value as a sign of the person being alive.
   * - **Requirements:** The fact that a patient is deceased influences the clinical process. Also, in human communication and relation management it is necessary to know whether the person is alive.
   * - **FHIR Types:**
   *     'boolean',
   *     'dateTime',
   * - **Cardinality:** 0..1
   * - **isModifier:** true
   * - **isModifierReason:** This element is labeled as a modifier because once a patient is marked as deceased, the actions that are appropriate to perform on the patient may be significantly different.
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('Patient.deceased[x]',[
    'boolean',
    'dateTime',
  ])
  private deceased?: IDataType | undefined;

  /**
   * Patient.address Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** An address for the individual
   * - **Definition:** An address for the individual.
   * - **Comment:** Patient may have multiple addresses with different uses or applicable periods.
   * - **Requirements:** May need to keep track of patient addresses for contacting, billing or reporting requirements and also to help with identification.
   * - **FHIR Type:** \`Address\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private address?: Address[] | undefined;

  /**
   * Patient.maritalStatus Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Marital (civil) status of a patient
   * - **Definition:** This field contains a patient\\'s most recent marital (civil) status.
   * - **Requirements:** Most, if not all systems capture it.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private maritalStatus?: CodeableConcept | undefined;

  /**
   * Patient.multipleBirth[x] Element
   *
   * @decorator \`@ChoiceDataTypesMeta('Patient.multipleBirth[x]', ['boolean','integer',]\`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Whether patient is part of a multiple birth
   * - **Definition:** Indicates whether the patient is part of a multiple (boolean) or indicates the actual birth order (integer).
   * - **Comment:** Where the valueInteger is provided, the number is the birth number in the sequence. E.g. The middle birth in triplets would be valueInteger=2 and the third born would have valueInteger=3 If a boolean value was provided for this triplets example, then all 3 patient records would have valueBoolean=true (the ordering is not indicated).
   * - **Requirements:** For disambiguation of multiple-birth children, especially relevant where the care provider doesn\\'t meet the patient, such as labs.
   * - **FHIR Types:**
   *     'boolean',
   *     'integer',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  @ChoiceDataTypesMeta('Patient.multipleBirth[x]',[
    'boolean',
    'integer',
  ])
  private multipleBirth?: IDataType | undefined;

  /**
   * Patient.photo Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Image of the patient
   * - **Definition:** Image of the patient.
   * - **Comment:** Guidelines: * Use id photos, not clinical photos. * Limit dimensions to thumbnail. * Keep byte count low to ease resource updates.
   * - **Requirements:** Many EHR systems have the capability to capture an image of the patient. Fits with newer social media usage too.
   * - **FHIR Type:** \`Attachment\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private photo?: Attachment[] | undefined;

  /**
   * Patient.contact Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A contact party (e.g. guardian, partner, friend) for the patient
   * - **Definition:** A contact party (e.g. guardian, partner, friend) for the patient.
   * - **Comment:** Contact covers all kinds of contact parties: family members, business contacts, guardians, caregivers. Not applicable to register pedigree and family ties beyond use of having contact.
   * - **Requirements:** Need to track people you can contact about the patient.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private contact?: PatientContactComponent[] | undefined;

  /**
   * Patient.communication Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A language which may be used to communicate with the patient about his or her health
   * - **Definition:** A language which may be used to communicate with the patient about his or her health.
   * - **Comment:** If no language is specified, this *implies* that the default local language is spoken.  If you need to convey proficiency for multiple modes, then you need multiple Patient.Communication associations.   For animals, language is not a relevant field, and should be absent from the instance. If the Patient does not speak the default local language, then the Interpreter Required Standard can be used to explicitly declare that an interpreter is required.
   * - **Requirements:** If a patient does not speak the local language, interpreters may be required, so languages spoken and proficiency are important things to keep track of both for patient and other persons of interest.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private communication?: PatientCommunicationComponent[] | undefined;

  /**
   * Patient.generalPractitioner Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Patient\\'s nominated primary care provider
   * - **Definition:** Patient\\'s nominated care provider.
   * - **Comment:** This may be the primary care provider (in a GP context), or it may be a patient nominated care manager in a community/disability setting, or even organization that will provide people to perform the care provider roles.  It is not to be used to record Care Teams, these should be in a CareTeam resource that may be linked to the CarePlan or EpisodeOfCare resources. Multiple GPs may be recorded against the patient for various reasons, such as a student that has his home GP listed along with the GP at university during the school semesters, or a "fly-in/fly-out" worker that has the onsite GP also included with his home GP to remain aware of medical issues. Jurisdictions may decide that they can profile this down to 1 if desired, or 1 per type.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Organization',
   *       'http://hl7.org/fhir/StructureDefinition/Practitioner',
   *       'http://hl7.org/fhir/StructureDefinition/PractitionerRole',
   *     ]
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private generalPractitioner?: Reference[] | undefined;

  /**
   * Patient.managingOrganization Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Organization that is the custodian of the patient record
   * - **Definition:** Organization that is the custodian of the patient record.
   * - **Comment:** There is only one managing organization for a specific patient record. Other organizations will have their own Patient record, and may use the Link property to join the records together (or a Person resource which can include confidence ratings for the association).
   * - **Requirements:** Need to know who recognizes this patient record, manages and updates it.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Organization',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private managingOrganization?: Reference | undefined;

  /**
   * Patient.link Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Link to another patient resource that concerns the same actual person
   * - **Definition:** Link to another patient resource that concerns the same actual patient.
   * - **Comment:** There is no assumption that linked patient records have mutual links.
   * - **Requirements:** There are multiple use cases:    * Duplicate patient records due to the clerical errors associated with the difficulties of identifying humans consistently, and  * Distribution of patient information across multiple servers.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..*
   * - **isModifier:** true
   * - **isModifierReason:** This element is labeled as a modifier because it might not be the main Patient resource, and the referenced patient should be used instead of this Patient record. This is when the link.type value is \\&#x27;replaced-by\\&#x27;
   * - **isSummary:** true
   */
  private link?: PatientLinkComponent[] | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`identifier\` property value as a Identifier array
   */
  public getIdentifier(): Identifier[] {
    return this.identifier ?? ([] as Identifier[]);
  }

  /**
   * Assigns the provided Identifier array value to the \`identifier\` property.
   *
   * @param value - the \`identifier\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setIdentifier(value: Identifier[] | undefined): this {
    if (isDefinedList<Identifier>(value)) {
      const optErrMsg = \`Invalid Patient.identifier; Provided value array has an element that is not an instance of Identifier.\`;
      assertFhirTypeList<Identifier>(value, Identifier, optErrMsg);
      this.identifier = value;
    } else {
      this.identifier = undefined;
    }
    return this;
  }

  /**
   * Add the provided Identifier value to the \`identifier\` array property.
   *
   * @param value - the \`identifier\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addIdentifier(value: Identifier | undefined): this {
    if (isDefined<Identifier>(value)) {
      const optErrMsg = \`Invalid Patient.identifier; Provided element is not an instance of Identifier.\`;
      assertFhirType<Identifier>(value, Identifier, optErrMsg);
      this.initIdentifier();
      this.identifier?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`identifier\` property exists and has a value; \`false\` otherwise
   */
  public hasIdentifier(): boolean {
    return isDefinedList<Identifier>(this.identifier) && this.identifier.some((item: Identifier) => !item.isEmpty());
  }

  /**
   * Initialize the \`identifier\` property
   */
  private initIdentifier(): void {
    if(!this.hasIdentifier()) {
      this.identifier = [] as Identifier[];
    }
  }

  /**
   * @returns the \`active\` property value as a BooleanType object if defined; else an empty BooleanType object
   */
  public getActiveElement(): BooleanType {
    return this.active ?? new BooleanType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`active\` property.
   *
   * @param element - the \`active\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setActiveElement(element: BooleanType | undefined): this {
    if (isDefined<BooleanType>(element)) {
      const optErrMsg = \`Invalid Patient.active; Provided element is not an instance of BooleanType.\`;
      assertFhirType<BooleanType>(element, BooleanType, optErrMsg);
      this.active = element;
    } else {
      this.active = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`active\` property exists and has a value; \`false\` otherwise
   */
  public hasActiveElement(): boolean {
    return isDefined<BooleanType>(this.active) && !this.active.isEmpty();
  }

  /**
   * @returns the \`active\` property value as a fhirBoolean if defined; else undefined
   */
  public getActive(): fhirBoolean | undefined {
    return this.active?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`active\` property.
   *
   * @param value - the \`active\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setActive(value: fhirBoolean | undefined): this {
    if (isDefined<fhirBoolean>(value)) {
      const optErrMsg = \`Invalid Patient.active (\${String(value)})\`;
      this.active = new BooleanType(parseFhirPrimitiveData(value, fhirBooleanSchema, optErrMsg));
    } else {
      this.active = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`active\` property exists and has a value; \`false\` otherwise
   */
  public hasActive(): boolean {
    return this.hasActiveElement();
  }

  /**
   * @returns the \`name\` property value as a HumanName array
   */
  public getName(): HumanName[] {
    return this.name ?? ([] as HumanName[]);
  }

  /**
   * Assigns the provided HumanName array value to the \`name\` property.
   *
   * @param value - the \`name\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setName(value: HumanName[] | undefined): this {
    if (isDefinedList<HumanName>(value)) {
      const optErrMsg = \`Invalid Patient.name; Provided value array has an element that is not an instance of HumanName.\`;
      assertFhirTypeList<HumanName>(value, HumanName, optErrMsg);
      this.name = value;
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * Add the provided HumanName value to the \`name\` array property.
   *
   * @param value - the \`name\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addName(value: HumanName | undefined): this {
    if (isDefined<HumanName>(value)) {
      const optErrMsg = \`Invalid Patient.name; Provided element is not an instance of HumanName.\`;
      assertFhirType<HumanName>(value, HumanName, optErrMsg);
      this.initName();
      this.name?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`name\` property exists and has a value; \`false\` otherwise
   */
  public hasName(): boolean {
    return isDefinedList<HumanName>(this.name) && this.name.some((item: HumanName) => !item.isEmpty());
  }

  /**
   * Initialize the \`name\` property
   */
  private initName(): void {
    if(!this.hasName()) {
      this.name = [] as HumanName[];
    }
  }

  /**
   * @returns the \`telecom\` property value as a ContactPoint array
   */
  public getTelecom(): ContactPoint[] {
    return this.telecom ?? ([] as ContactPoint[]);
  }

  /**
   * Assigns the provided ContactPoint array value to the \`telecom\` property.
   *
   * @param value - the \`telecom\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setTelecom(value: ContactPoint[] | undefined): this {
    if (isDefinedList<ContactPoint>(value)) {
      const optErrMsg = \`Invalid Patient.telecom; Provided value array has an element that is not an instance of ContactPoint.\`;
      assertFhirTypeList<ContactPoint>(value, ContactPoint, optErrMsg);
      this.telecom = value;
    } else {
      this.telecom = undefined;
    }
    return this;
  }

  /**
   * Add the provided ContactPoint value to the \`telecom\` array property.
   *
   * @param value - the \`telecom\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addTelecom(value: ContactPoint | undefined): this {
    if (isDefined<ContactPoint>(value)) {
      const optErrMsg = \`Invalid Patient.telecom; Provided element is not an instance of ContactPoint.\`;
      assertFhirType<ContactPoint>(value, ContactPoint, optErrMsg);
      this.initTelecom();
      this.telecom?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`telecom\` property exists and has a value; \`false\` otherwise
   */
  public hasTelecom(): boolean {
    return isDefinedList<ContactPoint>(this.telecom) && this.telecom.some((item: ContactPoint) => !item.isEmpty());
  }

  /**
   * Initialize the \`telecom\` property
   */
  private initTelecom(): void {
    if(!this.hasTelecom()) {
      this.telecom = [] as ContactPoint[];
    }
  }

  /**
   * @returns the \`gender\` property value as a EnumCodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link AdministrativeGenderEnum }
   */
  public getGenderEnumType(): EnumCodeType | undefined {
    return this.gender;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`gender\` property.
   *
   * @param enumType - the \`gender\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code values
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link AdministrativeGenderEnum }
   */
  public setGenderEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid Patient.gender';
      assertEnumCodeType<AdministrativeGenderEnum>(enumType, AdministrativeGenderEnum, errMsgPrefix);
      this.gender = enumType;
    } else {
      this.gender = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`gender\` property exists and has a value; \`false\` otherwise
   */
  public hasGenderEnumType(): boolean {
    return isDefined<EnumCodeType>(this.gender) && !this.gender.isEmpty() && this.gender.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`gender\` property value as a CodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link AdministrativeGenderEnum }
   */
  public getGenderElement(): CodeType | undefined {
    if (this.gender === undefined) {
      return undefined;
    }
    return this.gender as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`gender\` property.
   *
   * @param element - the \`gender\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link AdministrativeGenderEnum }
   */
  public setGenderElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Patient.gender; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.gender = new EnumCodeType(element, this.administrativeGenderEnum);
    } else {
      this.gender = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`gender\` property exists and has a value; \`false\` otherwise
   */
  public hasGenderElement(): boolean {
    return this.hasGenderEnumType();
  }

  /**
   * @returns the \`gender\` property value as a fhirCode if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link AdministrativeGenderEnum }
   */
  public getGender(): fhirCode | undefined {
    if (this.gender === undefined) {
      return undefined;
    }
    return this.gender.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`gender\` property.
   *
   * @param value - the \`gender\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link AdministrativeGenderEnum }
   */
  public setGender(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Patient.gender; Provided value is not an instance of fhirCode.\`;
      this.gender = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.administrativeGenderEnum);
    } else {
      this.gender = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`gender\` property exists and has a value; \`false\` otherwise
   */
  public hasGender(): boolean {
    return this.hasGenderEnumType();
  }

  /**
   * @returns the \`birthDate\` property value as a DateType object if defined; else an empty DateType object
   */
  public getBirthDateElement(): DateType {
    return this.birthDate ?? new DateType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`birthDate\` property.
   *
   * @param element - the \`birthDate\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setBirthDateElement(element: DateType | undefined): this {
    if (isDefined<DateType>(element)) {
      const optErrMsg = \`Invalid Patient.birthDate; Provided element is not an instance of DateType.\`;
      assertFhirType<DateType>(element, DateType, optErrMsg);
      this.birthDate = element;
    } else {
      this.birthDate = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`birthDate\` property exists and has a value; \`false\` otherwise
   */
  public hasBirthDateElement(): boolean {
    return isDefined<DateType>(this.birthDate) && !this.birthDate.isEmpty();
  }

  /**
   * @returns the \`birthDate\` property value as a fhirDate if defined; else undefined
   */
  public getBirthDate(): fhirDate | undefined {
    return this.birthDate?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`birthDate\` property.
   *
   * @param value - the \`birthDate\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setBirthDate(value: fhirDate | undefined): this {
    if (isDefined<fhirDate>(value)) {
      const optErrMsg = \`Invalid Patient.birthDate (\${String(value)})\`;
      this.birthDate = new DateType(parseFhirPrimitiveData(value, fhirDateSchema, optErrMsg));
    } else {
      this.birthDate = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`birthDate\` property exists and has a value; \`false\` otherwise
   */
  public hasBirthDate(): boolean {
    return this.hasBirthDateElement();
  }

  /**
   * @returns the \`deceased\` property value as a DataType object if defined; else undefined
   */
  public getDeceased(): IDataType | undefined {
    return this.deceased;
  }

  /**
   * Assigns the provided DataType object value to the \`deceased\` property.
   *
   * @decorator \`@ChoiceDataTypes('Patient.deceased[x]')\`
   *
   * @param value - the \`deceased\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  @ChoiceDataTypes('Patient.deceased[x]')
  public setDeceased(value: IDataType | undefined): this {
    if (isDefined<IDataType>(value)) {
      // assertFhirType<IDataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.deceased = value;
    } else {
      this.deceased = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`deceased\` property exists and has a value; \`false\` otherwise
   */
  public hasDeceased(): boolean {
    return isDefined<IDataType>(this.deceased) && !this.deceased.isEmpty();
  }

  // *** NOTE ***
  // Following choice datatype-specific "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the \`deceased\` property value as a BooleanType object if defined; else undefined
   */
  public getDeceasedBooleanType(): BooleanType | undefined {
    if (!isDefined<IDataType | undefined>(this.deceased)) {
      return undefined;
    }
    if (!(this.deceased instanceof BooleanType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Patient.deceased[x]: Expected BooleanType but encountered \${this.deceased.fhirType()}\`,
      );
    }
    return this.deceased;
  }

  /**
   * @returns \`true\` if the \`deceased\` property exists as a BooleanType and has a value; \`false\` otherwise
   */
  public hasDeceasedBooleanType(): boolean {
    return this.hasDeceased() && this.deceased instanceof BooleanType;
  }

  /**
   * @returns the \`deceased\` property value as a DateTimeType object if defined; else undefined
   */
  public getDeceasedDateTimeType(): DateTimeType | undefined {
    if (!isDefined<IDataType | undefined>(this.deceased)) {
      return undefined;
    }
    if (!(this.deceased instanceof DateTimeType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Patient.deceased[x]: Expected DateTimeType but encountered \${this.deceased.fhirType()}\`,
      );
    }
    return this.deceased;
  }

  /**
   * @returns \`true\` if the \`deceased\` property exists as a DateTimeType and has a value; \`false\` otherwise
   */
  public hasDeceasedDateTimeType(): boolean {
    return this.hasDeceased() && this.deceased instanceof DateTimeType;
  }

  // End of choice datatype-specific "get"/"has" methods

  /**
   * @returns the \`address\` property value as a Address array
   */
  public getAddress(): Address[] {
    return this.address ?? ([] as Address[]);
  }

  /**
   * Assigns the provided Address array value to the \`address\` property.
   *
   * @param value - the \`address\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setAddress(value: Address[] | undefined): this {
    if (isDefinedList<Address>(value)) {
      const optErrMsg = \`Invalid Patient.address; Provided value array has an element that is not an instance of Address.\`;
      assertFhirTypeList<Address>(value, Address, optErrMsg);
      this.address = value;
    } else {
      this.address = undefined;
    }
    return this;
  }

  /**
   * Add the provided Address value to the \`address\` array property.
   *
   * @param value - the \`address\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addAddress(value: Address | undefined): this {
    if (isDefined<Address>(value)) {
      const optErrMsg = \`Invalid Patient.address; Provided element is not an instance of Address.\`;
      assertFhirType<Address>(value, Address, optErrMsg);
      this.initAddress();
      this.address?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`address\` property exists and has a value; \`false\` otherwise
   */
  public hasAddress(): boolean {
    return isDefinedList<Address>(this.address) && this.address.some((item: Address) => !item.isEmpty());
  }

  /**
   * Initialize the \`address\` property
   */
  private initAddress(): void {
    if(!this.hasAddress()) {
      this.address = [] as Address[];
    }
  }

  /**
   * @returns the \`maritalStatus\` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getMaritalStatus(): CodeableConcept {
    return this.maritalStatus ?? new CodeableConcept();
  }

  /**
   * Assigns the provided MaritalStatus object value to the \`maritalStatus\` property.
   *
   * @param value - the \`maritalStatus\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setMaritalStatus(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Patient.maritalStatus; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.maritalStatus = value;
    } else {
      this.maritalStatus = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`maritalStatus\` property exists and has a value; \`false\` otherwise
   */
  public hasMaritalStatus(): boolean {
    return isDefined<CodeableConcept>(this.maritalStatus) && !this.maritalStatus.isEmpty();
  }

  /**
   * @returns the \`multipleBirth\` property value as a DataType object if defined; else undefined
   */
  public getMultipleBirth(): IDataType | undefined {
    return this.multipleBirth;
  }

  /**
   * Assigns the provided DataType object value to the \`multipleBirth\` property.
   *
   * @decorator \`@ChoiceDataTypes('Patient.multipleBirth[x]')\`
   *
   * @param value - the \`multipleBirth\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  @ChoiceDataTypes('Patient.multipleBirth[x]')
  public setMultipleBirth(value: IDataType | undefined): this {
    if (isDefined<IDataType>(value)) {
      // assertFhirType<IDataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.multipleBirth = value;
    } else {
      this.multipleBirth = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`multipleBirth\` property exists and has a value; \`false\` otherwise
   */
  public hasMultipleBirth(): boolean {
    return isDefined<IDataType>(this.multipleBirth) && !this.multipleBirth.isEmpty();
  }

  // *** NOTE ***
  // Following choice datatype-specific "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the \`multipleBirth\` property value as a BooleanType object if defined; else undefined
   */
  public getMultipleBirthBooleanType(): BooleanType | undefined {
    if (!isDefined<IDataType | undefined>(this.multipleBirth)) {
      return undefined;
    }
    if (!(this.multipleBirth instanceof BooleanType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Patient.multipleBirth[x]: Expected BooleanType but encountered \${this.multipleBirth.fhirType()}\`,
      );
    }
    return this.multipleBirth;
  }

  /**
   * @returns \`true\` if the \`multipleBirth\` property exists as a BooleanType and has a value; \`false\` otherwise
   */
  public hasMultipleBirthBooleanType(): boolean {
    return this.hasMultipleBirth() && this.multipleBirth instanceof BooleanType;
  }

  /**
   * @returns the \`multipleBirth\` property value as a IntegerType object if defined; else undefined
   */
  public getMultipleBirthIntegerType(): IntegerType | undefined {
    if (!isDefined<IDataType | undefined>(this.multipleBirth)) {
      return undefined;
    }
    if (!(this.multipleBirth instanceof IntegerType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for Patient.multipleBirth[x]: Expected IntegerType but encountered \${this.multipleBirth.fhirType()}\`,
      );
    }
    return this.multipleBirth;
  }

  /**
   * @returns \`true\` if the \`multipleBirth\` property exists as a IntegerType and has a value; \`false\` otherwise
   */
  public hasMultipleBirthIntegerType(): boolean {
    return this.hasMultipleBirth() && this.multipleBirth instanceof IntegerType;
  }

  // End of choice datatype-specific "get"/"has" methods

  /**
   * @returns the \`photo\` property value as a Attachment array
   */
  public getPhoto(): Attachment[] {
    return this.photo ?? ([] as Attachment[]);
  }

  /**
   * Assigns the provided Attachment array value to the \`photo\` property.
   *
   * @param value - the \`photo\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setPhoto(value: Attachment[] | undefined): this {
    if (isDefinedList<Attachment>(value)) {
      const optErrMsg = \`Invalid Patient.photo; Provided value array has an element that is not an instance of Attachment.\`;
      assertFhirTypeList<Attachment>(value, Attachment, optErrMsg);
      this.photo = value;
    } else {
      this.photo = undefined;
    }
    return this;
  }

  /**
   * Add the provided Attachment value to the \`photo\` array property.
   *
   * @param value - the \`photo\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addPhoto(value: Attachment | undefined): this {
    if (isDefined<Attachment>(value)) {
      const optErrMsg = \`Invalid Patient.photo; Provided element is not an instance of Attachment.\`;
      assertFhirType<Attachment>(value, Attachment, optErrMsg);
      this.initPhoto();
      this.photo?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`photo\` property exists and has a value; \`false\` otherwise
   */
  public hasPhoto(): boolean {
    return isDefinedList<Attachment>(this.photo) && this.photo.some((item: Attachment) => !item.isEmpty());
  }

  /**
   * Initialize the \`photo\` property
   */
  private initPhoto(): void {
    if(!this.hasPhoto()) {
      this.photo = [] as Attachment[];
    }
  }

  /**
   * @returns the \`contact\` property value as a PatientContactComponent array
   */
  public getContact(): PatientContactComponent[] {
    return this.contact ?? ([] as PatientContactComponent[]);
  }

  /**
   * Assigns the provided PatientContactComponent array value to the \`contact\` property.
   *
   * @param value - the \`contact\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setContact(value: PatientContactComponent[] | undefined): this {
    if (isDefinedList<PatientContactComponent>(value)) {
      const optErrMsg = \`Invalid Patient.contact; Provided value array has an element that is not an instance of PatientContactComponent.\`;
      assertFhirTypeList<PatientContactComponent>(value, PatientContactComponent, optErrMsg);
      this.contact = value;
    } else {
      this.contact = undefined;
    }
    return this;
  }

  /**
   * Add the provided PatientContactComponent value to the \`contact\` array property.
   *
   * @param value - the \`contact\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addContact(value: PatientContactComponent | undefined): this {
    if (isDefined<PatientContactComponent>(value)) {
      const optErrMsg = \`Invalid Patient.contact; Provided element is not an instance of PatientContactComponent.\`;
      assertFhirType<PatientContactComponent>(value, PatientContactComponent, optErrMsg);
      this.initContact();
      this.contact?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`contact\` property exists and has a value; \`false\` otherwise
   */
  public hasContact(): boolean {
    return isDefinedList<PatientContactComponent>(this.contact) && this.contact.some((item: PatientContactComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`contact\` property
   */
  private initContact(): void {
    if(!this.hasContact()) {
      this.contact = [] as PatientContactComponent[];
    }
  }

  /**
   * @returns the \`communication\` property value as a PatientCommunicationComponent array
   */
  public getCommunication(): PatientCommunicationComponent[] {
    return this.communication ?? ([] as PatientCommunicationComponent[]);
  }

  /**
   * Assigns the provided PatientCommunicationComponent array value to the \`communication\` property.
   *
   * @param value - the \`communication\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setCommunication(value: PatientCommunicationComponent[] | undefined): this {
    if (isDefinedList<PatientCommunicationComponent>(value)) {
      const optErrMsg = \`Invalid Patient.communication; Provided value array has an element that is not an instance of PatientCommunicationComponent.\`;
      assertFhirTypeList<PatientCommunicationComponent>(value, PatientCommunicationComponent, optErrMsg);
      this.communication = value;
    } else {
      this.communication = undefined;
    }
    return this;
  }

  /**
   * Add the provided PatientCommunicationComponent value to the \`communication\` array property.
   *
   * @param value - the \`communication\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addCommunication(value: PatientCommunicationComponent | undefined): this {
    if (isDefined<PatientCommunicationComponent>(value)) {
      const optErrMsg = \`Invalid Patient.communication; Provided element is not an instance of PatientCommunicationComponent.\`;
      assertFhirType<PatientCommunicationComponent>(value, PatientCommunicationComponent, optErrMsg);
      this.initCommunication();
      this.communication?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`communication\` property exists and has a value; \`false\` otherwise
   */
  public hasCommunication(): boolean {
    return isDefinedList<PatientCommunicationComponent>(this.communication) && this.communication.some((item: PatientCommunicationComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`communication\` property
   */
  private initCommunication(): void {
    if(!this.hasCommunication()) {
      this.communication = [] as PatientCommunicationComponent[];
    }
  }

  /**
   * @returns the \`generalPractitioner\` property value as a Reference array
   */
  public getGeneralPractitioner(): Reference[] {
    return this.generalPractitioner ?? ([] as Reference[]);
  }

  /**
   * Assigns the provided Reference array value to the \`generalPractitioner\` property.
   *
   * @decorator \`@ReferenceTargets('Patient.generalPractitioner', ['Organization','Practitioner','PractitionerRole',])\`
   *
   * @param value - the \`generalPractitioner\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('Patient.generalPractitioner', [
    'Organization',
  
    'Practitioner',
  
    'PractitionerRole',
  ])
  public setGeneralPractitioner(value: Reference[] | undefined): this {
    if (isDefinedList<Reference>(value)) {
      // assertFhirTypeList<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.generalPractitioner = value;
    } else {
      this.generalPractitioner = undefined;
    }
    return this;
  }

  /**
   * Add the provided Reference value to the \`generalPractitioner\` array property.
   *
   * @decorator \`@ReferenceTargets('Patient.generalPractitioner', ['Organization','Practitioner','PractitionerRole',])\`
   *
   * @param value - the \`generalPractitioner\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('Patient.generalPractitioner', [
    'Organization',
  
    'Practitioner',
  
    'PractitionerRole',
  ])
  public addGeneralPractitioner(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.initGeneralPractitioner();
      this.generalPractitioner?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`generalPractitioner\` property exists and has a value; \`false\` otherwise
   */
  public hasGeneralPractitioner(): boolean {
    return isDefinedList<Reference>(this.generalPractitioner) && this.generalPractitioner.some((item: Reference) => !item.isEmpty());
  }

  /**
   * Initialize the \`generalPractitioner\` property
   */
  private initGeneralPractitioner(): void {
    if (!this.hasGeneralPractitioner()) {
      this.generalPractitioner = [] as Reference[];
    }
  }

  /**
   * @returns the \`managingOrganization\` property value as a Reference object; else an empty Reference object
   */
  public getManagingOrganization(): Reference {
    return this.managingOrganization ?? new Reference();
  }

  /**
   * Assigns the provided ManagingOrganization object value to the \`managingOrganization\` property.
   *
   * @decorator \`@ReferenceTargets('Patient.managingOrganization', ['Organization',])\`
   *
   * @param value - the \`managingOrganization\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('Patient.managingOrganization', [
    'Organization',
  ])
  public setManagingOrganization(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.managingOrganization = value;
    } else {
      this.managingOrganization = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`managingOrganization\` property exists and has a value; \`false\` otherwise
   */
  public hasManagingOrganization(): boolean {
    return isDefined<Reference>(this.managingOrganization) && !this.managingOrganization.isEmpty();
  }

  /**
   * @returns the \`link\` property value as a PatientLinkComponent array
   */
  public getLink(): PatientLinkComponent[] {
    return this.link ?? ([] as PatientLinkComponent[]);
  }

  /**
   * Assigns the provided PatientLinkComponent array value to the \`link\` property.
   *
   * @param value - the \`link\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setLink(value: PatientLinkComponent[] | undefined): this {
    if (isDefinedList<PatientLinkComponent>(value)) {
      const optErrMsg = \`Invalid Patient.link; Provided value array has an element that is not an instance of PatientLinkComponent.\`;
      assertFhirTypeList<PatientLinkComponent>(value, PatientLinkComponent, optErrMsg);
      this.link = value;
    } else {
      this.link = undefined;
    }
    return this;
  }

  /**
   * Add the provided PatientLinkComponent value to the \`link\` array property.
   *
   * @param value - the \`link\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addLink(value: PatientLinkComponent | undefined): this {
    if (isDefined<PatientLinkComponent>(value)) {
      const optErrMsg = \`Invalid Patient.link; Provided element is not an instance of PatientLinkComponent.\`;
      assertFhirType<PatientLinkComponent>(value, PatientLinkComponent, optErrMsg);
      this.initLink();
      this.link?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`link\` property exists and has a value; \`false\` otherwise
   */
  public hasLink(): boolean {
    return isDefinedList<PatientLinkComponent>(this.link) && this.link.some((item: PatientLinkComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`link\` property
   */
  private initLink(): void {
    if(!this.hasLink()) {
      this.link = [] as PatientLinkComponent[];
    }
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Patient';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.identifier,
      this.active,
      this.name,
      this.telecom,
      this.gender,
      this.birthDate,
      this.deceased,
      this.address,
      this.maritalStatus,
      this.multipleBirth,
      this.photo,
      this.contact,
      this.communication,
      this.generalPractitioner,
      this.managingOrganization,
      this.link,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Patient {
    const dest = new Patient();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Patient): void {
    super.copyValues(dest);
    const identifierList = copyListValues<Identifier>(this.identifier);
    dest.identifier = identifierList.length === 0 ? undefined : identifierList;
    dest.active = this.active?.copy();
    const nameList = copyListValues<HumanName>(this.name);
    dest.name = nameList.length === 0 ? undefined : nameList;
    const telecomList = copyListValues<ContactPoint>(this.telecom);
    dest.telecom = telecomList.length === 0 ? undefined : telecomList;
    dest.gender = this.gender?.copy();
    dest.birthDate = this.birthDate?.copy();
    dest.deceased = this.deceased?.copy() as IDataType;
    const addressList = copyListValues<Address>(this.address);
    dest.address = addressList.length === 0 ? undefined : addressList;
    dest.maritalStatus = this.maritalStatus?.copy();
    dest.multipleBirth = this.multipleBirth?.copy() as IDataType;
    const photoList = copyListValues<Attachment>(this.photo);
    dest.photo = photoList.length === 0 ? undefined : photoList;
    const contactList = copyListValues<PatientContactComponent>(this.contact);
    dest.contact = contactList.length === 0 ? undefined : contactList;
    const communicationList = copyListValues<PatientCommunicationComponent>(this.communication);
    dest.communication = communicationList.length === 0 ? undefined : communicationList;
    const generalPractitionerList = copyListValues<Reference>(this.generalPractitioner);
    dest.generalPractitioner = generalPractitionerList.length === 0 ? undefined : generalPractitionerList;
    dest.managingOrganization = this.managingOrganization?.copy();
    const linkList = copyListValues<PatientLinkComponent>(this.link);
    dest.link = linkList.length === 0 ? undefined : linkList;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasIdentifier()) {
      setFhirComplexListJson(this.getIdentifier(), 'identifier', jsonObj);
    }

    if (this.hasActiveElement()) {
      setFhirPrimitiveJson<fhirBoolean>(this.getActiveElement(), 'active', jsonObj);
    }

    if (this.hasName()) {
      setFhirComplexListJson(this.getName(), 'name', jsonObj);
    }

    if (this.hasTelecom()) {
      setFhirComplexListJson(this.getTelecom(), 'telecom', jsonObj);
    }

    if (this.hasGenderElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getGenderElement()!, 'gender', jsonObj);
    }

    if (this.hasBirthDateElement()) {
      setFhirPrimitiveJson<fhirDate>(this.getBirthDateElement(), 'birthDate', jsonObj);
    }

    if (this.hasDeceased()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getDeceased()!, 'deceased', jsonObj);
    }

    if (this.hasAddress()) {
      setFhirComplexListJson(this.getAddress(), 'address', jsonObj);
    }

    if (this.hasMaritalStatus()) {
      setFhirComplexJson(this.getMaritalStatus(), 'maritalStatus', jsonObj);
    }

    if (this.hasMultipleBirth()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getMultipleBirth()!, 'multipleBirth', jsonObj);
    }

    if (this.hasPhoto()) {
      setFhirComplexListJson(this.getPhoto(), 'photo', jsonObj);
    }

    if (this.hasContact()) {
      setFhirBackboneElementListJson(this.getContact(), 'contact', jsonObj);
    }

    if (this.hasCommunication()) {
      setFhirBackboneElementListJson(this.getCommunication(), 'communication', jsonObj);
    }

    if (this.hasGeneralPractitioner()) {
      setFhirComplexListJson(this.getGeneralPractitioner(), 'generalPractitioner', jsonObj);
    }

    if (this.hasManagingOrganization()) {
      setFhirComplexJson(this.getManagingOrganization(), 'managingOrganization', jsonObj);
    }

    if (this.hasLink()) {
      setFhirBackboneElementListJson(this.getLink(), 'link', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * PatientContactComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** A contact party (e.g. guardian, partner, friend) for the patient
 * - **Definition:** A contact party (e.g. guardian, partner, friend) for the patient.
 * - **Comment:** Contact covers all kinds of contact parties: family members, business contacts, guardians, caregivers. Not applicable to register pedigree and family ties beyond use of having contact.
 * - **Requirements:** Need to track people you can contact about the patient.
 *
 * @category Data Models: Resource
 * @see [FHIR Patient](http://hl7.org/fhir/StructureDefinition/Patient)
 */
export class PatientContactComponent extends BackboneElement implements IBackboneElement {
  constructor() {
    super();

    this.administrativeGenderEnum = new AdministrativeGenderEnum();
  }

  /**
   * Parse the provided \`PatientContactComponent\` JSON to instantiate the PatientContactComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`PatientContactComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to PatientContactComponent
   * @returns PatientContactComponent data model or undefined for \`PatientContactComponent\`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): PatientContactComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'PatientContactComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new PatientContactComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    

    fieldName = 'relationship';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: CodeableConcept | undefined = CodeableConcept.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addRelationship(datatype);
        }
      });
    }

    fieldName = 'name';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: HumanName | undefined = HumanName.parse(classJsonObj[fieldName]!, sourceField);
      instance.setName(datatype);
    }

    fieldName = 'telecom';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: ContactPoint | undefined = ContactPoint.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addTelecom(datatype);
        }
      });
    }

    fieldName = 'address';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Address | undefined = Address.parse(classJsonObj[fieldName]!, sourceField);
      instance.setAddress(datatype);
    }

    fieldName = 'gender';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setGenderElement(datatype);
    }

    fieldName = 'organization';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = Reference.parse(classJsonObj[fieldName]!, sourceField);
      instance.setOrganization(datatype);
    }

    fieldName = 'period';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Period | undefined = Period.parse(classJsonObj[fieldName]!, sourceField);
      instance.setPeriod(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Patient.contact.relationship Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The kind of relationship
   * - **Definition:** The nature of the relationship between the patient and the contact person.
   * - **Requirements:** Used to determine which contact person is the most relevant to approach, depending on circumstances.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private relationship?: CodeableConcept[] | undefined;

  /**
   * Patient.contact.name Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A name associated with the contact person
   * - **Definition:** A name associated with the contact person.
   * - **Requirements:** Contact persons need to be identified by name, but it is uncommon to need details about multiple other names for that contact person.
   * - **FHIR Type:** \`HumanName\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private name?: HumanName | undefined;

  /**
   * Patient.contact.telecom Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A contact detail for the person
   * - **Definition:** A contact detail for the person, e.g. a telephone number or an email address.
   * - **Comment:** Contact may have multiple ways to be contacted with different uses or applicable periods.  May need to have options for contacting the person urgently, and also to help with identification.
   * - **Requirements:** People have (primary) ways to contact them in some way such as phone, email.
   * - **FHIR Type:** \`ContactPoint\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private telecom?: ContactPoint[] | undefined;

  /**
   * Patient.contact.address Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Address for the contact person
   * - **Definition:** Address for the contact person.
   * - **Requirements:** Need to keep track where the contact person can be contacted per postal mail or visited.
   * - **FHIR Type:** \`Address\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private address?: Address | undefined;

  /**
   * FHIR CodeSystem: AdministrativeGender
   *
   * @see {@link AdministrativeGenderEnum }
   */
  private readonly administrativeGenderEnum: AdministrativeGenderEnum;

  /**
   * Patient.contact.gender Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** male | female | other | unknown
   * - **Definition:** Administrative Gender - the gender that the contact person is considered to have for administration and record keeping purposes.
   * - **Requirements:** Needed to address the person correctly.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   *
   * @see CodeSystem Enumeration: {@link AdministrativeGenderEnum }
   */
  private gender?: EnumCodeType | undefined;

  /**
   * Patient.contact.organization Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Organization that is associated with the contact
   * - **Definition:** Organization on behalf of which the contact is acting or for which the contact is working.
   * - **Requirements:** For guardians or business related contacts, the organization is relevant.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Organization',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private organization?: Reference | undefined;

  /**
   * Patient.contact.period Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The period during which this contact person or organization is valid to be contacted relating to this patient
   * - **Definition:** The period during which this contact person or organization is valid to be contacted relating to this patient.
   * - **FHIR Type:** \`Period\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private period?: Period | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`relationship\` property value as a CodeableConcept array
   */
  public getRelationship(): CodeableConcept[] {
    return this.relationship ?? ([] as CodeableConcept[]);
  }

  /**
   * Assigns the provided CodeableConcept array value to the \`relationship\` property.
   *
   * @param value - the \`relationship\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setRelationship(value: CodeableConcept[] | undefined): this {
    if (isDefinedList<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Patient.contact.relationship; Provided value array has an element that is not an instance of CodeableConcept.\`;
      assertFhirTypeList<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.relationship = value;
    } else {
      this.relationship = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeableConcept value to the \`relationship\` array property.
   *
   * @param value - the \`relationship\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addRelationship(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Patient.contact.relationship; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.initRelationship();
      this.relationship?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`relationship\` property exists and has a value; \`false\` otherwise
   */
  public hasRelationship(): boolean {
    return isDefinedList<CodeableConcept>(this.relationship) && this.relationship.some((item: CodeableConcept) => !item.isEmpty());
  }

  /**
   * Initialize the \`relationship\` property
   */
  private initRelationship(): void {
    if(!this.hasRelationship()) {
      this.relationship = [] as CodeableConcept[];
    }
  }

  /**
   * @returns the \`name\` property value as a HumanName object if defined; else an empty HumanName object
   */
  public getName(): HumanName {
    return this.name ?? new HumanName();
  }

  /**
   * Assigns the provided Name object value to the \`name\` property.
   *
   * @param value - the \`name\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setName(value: HumanName | undefined): this {
    if (isDefined<HumanName>(value)) {
      const optErrMsg = \`Invalid Patient.contact.name; Provided element is not an instance of HumanName.\`;
      assertFhirType<HumanName>(value, HumanName, optErrMsg);
      this.name = value;
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`name\` property exists and has a value; \`false\` otherwise
   */
  public hasName(): boolean {
    return isDefined<HumanName>(this.name) && !this.name.isEmpty();
  }

  /**
   * @returns the \`telecom\` property value as a ContactPoint array
   */
  public getTelecom(): ContactPoint[] {
    return this.telecom ?? ([] as ContactPoint[]);
  }

  /**
   * Assigns the provided ContactPoint array value to the \`telecom\` property.
   *
   * @param value - the \`telecom\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setTelecom(value: ContactPoint[] | undefined): this {
    if (isDefinedList<ContactPoint>(value)) {
      const optErrMsg = \`Invalid Patient.contact.telecom; Provided value array has an element that is not an instance of ContactPoint.\`;
      assertFhirTypeList<ContactPoint>(value, ContactPoint, optErrMsg);
      this.telecom = value;
    } else {
      this.telecom = undefined;
    }
    return this;
  }

  /**
   * Add the provided ContactPoint value to the \`telecom\` array property.
   *
   * @param value - the \`telecom\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addTelecom(value: ContactPoint | undefined): this {
    if (isDefined<ContactPoint>(value)) {
      const optErrMsg = \`Invalid Patient.contact.telecom; Provided element is not an instance of ContactPoint.\`;
      assertFhirType<ContactPoint>(value, ContactPoint, optErrMsg);
      this.initTelecom();
      this.telecom?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`telecom\` property exists and has a value; \`false\` otherwise
   */
  public hasTelecom(): boolean {
    return isDefinedList<ContactPoint>(this.telecom) && this.telecom.some((item: ContactPoint) => !item.isEmpty());
  }

  /**
   * Initialize the \`telecom\` property
   */
  private initTelecom(): void {
    if(!this.hasTelecom()) {
      this.telecom = [] as ContactPoint[];
    }
  }

  /**
   * @returns the \`address\` property value as a Address object if defined; else an empty Address object
   */
  public getAddress(): Address {
    return this.address ?? new Address();
  }

  /**
   * Assigns the provided Address object value to the \`address\` property.
   *
   * @param value - the \`address\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setAddress(value: Address | undefined): this {
    if (isDefined<Address>(value)) {
      const optErrMsg = \`Invalid Patient.contact.address; Provided element is not an instance of Address.\`;
      assertFhirType<Address>(value, Address, optErrMsg);
      this.address = value;
    } else {
      this.address = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`address\` property exists and has a value; \`false\` otherwise
   */
  public hasAddress(): boolean {
    return isDefined<Address>(this.address) && !this.address.isEmpty();
  }

  /**
   * @returns the \`gender\` property value as a EnumCodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link AdministrativeGenderEnum }
   */
  public getGenderEnumType(): EnumCodeType | undefined {
    return this.gender;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`gender\` property.
   *
   * @param enumType - the \`gender\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code values
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link AdministrativeGenderEnum }
   */
  public setGenderEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid Patient.contact.gender';
      assertEnumCodeType<AdministrativeGenderEnum>(enumType, AdministrativeGenderEnum, errMsgPrefix);
      this.gender = enumType;
    } else {
      this.gender = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`gender\` property exists and has a value; \`false\` otherwise
   */
  public hasGenderEnumType(): boolean {
    return isDefined<EnumCodeType>(this.gender) && !this.gender.isEmpty() && this.gender.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`gender\` property value as a CodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link AdministrativeGenderEnum }
   */
  public getGenderElement(): CodeType | undefined {
    if (this.gender === undefined) {
      return undefined;
    }
    return this.gender as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`gender\` property.
   *
   * @param element - the \`gender\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link AdministrativeGenderEnum }
   */
  public setGenderElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Patient.contact.gender; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.gender = new EnumCodeType(element, this.administrativeGenderEnum);
    } else {
      this.gender = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`gender\` property exists and has a value; \`false\` otherwise
   */
  public hasGenderElement(): boolean {
    return this.hasGenderEnumType();
  }

  /**
   * @returns the \`gender\` property value as a fhirCode if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link AdministrativeGenderEnum }
   */
  public getGender(): fhirCode | undefined {
    if (this.gender === undefined) {
      return undefined;
    }
    return this.gender.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`gender\` property.
   *
   * @param value - the \`gender\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link AdministrativeGenderEnum }
   */
  public setGender(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Patient.contact.gender; Provided value is not an instance of fhirCode.\`;
      this.gender = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.administrativeGenderEnum);
    } else {
      this.gender = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`gender\` property exists and has a value; \`false\` otherwise
   */
  public hasGender(): boolean {
    return this.hasGenderEnumType();
  }

  /**
   * @returns the \`organization\` property value as a Reference object; else an empty Reference object
   */
  public getOrganization(): Reference {
    return this.organization ?? new Reference();
  }

  /**
   * Assigns the provided Organization object value to the \`organization\` property.
   *
   * @decorator \`@ReferenceTargets('Patient.contact.organization', ['Organization',])\`
   *
   * @param value - the \`organization\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('Patient.contact.organization', [
    'Organization',
  ])
  public setOrganization(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.organization = value;
    } else {
      this.organization = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`organization\` property exists and has a value; \`false\` otherwise
   */
  public hasOrganization(): boolean {
    return isDefined<Reference>(this.organization) && !this.organization.isEmpty();
  }

  /**
   * @returns the \`period\` property value as a Period object if defined; else an empty Period object
   */
  public getPeriod(): Period {
    return this.period ?? new Period();
  }

  /**
   * Assigns the provided Period object value to the \`period\` property.
   *
   * @param value - the \`period\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setPeriod(value: Period | undefined): this {
    if (isDefined<Period>(value)) {
      const optErrMsg = \`Invalid Patient.contact.period; Provided element is not an instance of Period.\`;
      assertFhirType<Period>(value, Period, optErrMsg);
      this.period = value;
    } else {
      this.period = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`period\` property exists and has a value; \`false\` otherwise
   */
  public hasPeriod(): boolean {
    return isDefined<Period>(this.period) && !this.period.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Patient.contact';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.relationship,
      this.name,
      this.telecom,
      this.address,
      this.gender,
      this.organization,
      this.period,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): PatientContactComponent {
    const dest = new PatientContactComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: PatientContactComponent): void {
    super.copyValues(dest);
    const relationshipList = copyListValues<CodeableConcept>(this.relationship);
    dest.relationship = relationshipList.length === 0 ? undefined : relationshipList;
    dest.name = this.name?.copy();
    const telecomList = copyListValues<ContactPoint>(this.telecom);
    dest.telecom = telecomList.length === 0 ? undefined : telecomList;
    dest.address = this.address?.copy();
    dest.gender = this.gender?.copy();
    dest.organization = this.organization?.copy();
    dest.period = this.period?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasRelationship()) {
      setFhirComplexListJson(this.getRelationship(), 'relationship', jsonObj);
    }

    if (this.hasName()) {
      setFhirComplexJson(this.getName(), 'name', jsonObj);
    }

    if (this.hasTelecom()) {
      setFhirComplexListJson(this.getTelecom(), 'telecom', jsonObj);
    }

    if (this.hasAddress()) {
      setFhirComplexJson(this.getAddress(), 'address', jsonObj);
    }

    if (this.hasGenderElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getGenderElement()!, 'gender', jsonObj);
    }

    if (this.hasOrganization()) {
      setFhirComplexJson(this.getOrganization(), 'organization', jsonObj);
    }

    if (this.hasPeriod()) {
      setFhirComplexJson(this.getPeriod(), 'period', jsonObj);
    }

    return jsonObj;
  }
}
/**
 * PatientCommunicationComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** A language which may be used to communicate with the patient about his or her health
 * - **Definition:** A language which may be used to communicate with the patient about his or her health.
 * - **Comment:** If no language is specified, this *implies* that the default local language is spoken.  If you need to convey proficiency for multiple modes, then you need multiple Patient.Communication associations.   For animals, language is not a relevant field, and should be absent from the instance. If the Patient does not speak the default local language, then the Interpreter Required Standard can be used to explicitly declare that an interpreter is required.
 * - **Requirements:** If a patient does not speak the local language, interpreters may be required, so languages spoken and proficiency are important things to keep track of both for patient and other persons of interest.
 *
 * @category Data Models: Resource
 * @see [FHIR Patient](http://hl7.org/fhir/StructureDefinition/Patient)
 */
export class PatientCommunicationComponent extends BackboneElement implements IBackboneElement {
  constructor(language: CodeableConcept | null = null) {
    super();

    this.language = null;
    if (isDefined<CodeableConcept>(language)) {
      this.setLanguage(language);
    }
  }

  /**
   * Parse the provided \`PatientCommunicationComponent\` JSON to instantiate the PatientCommunicationComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`PatientCommunicationComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to PatientCommunicationComponent
   * @returns PatientCommunicationComponent data model or undefined for \`PatientCommunicationComponent\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): PatientCommunicationComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'PatientCommunicationComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new PatientCommunicationComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    

    const missingReqdProperties: string[] = [];

    fieldName = 'language';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = CodeableConcept.parse(classJsonObj[fieldName]!, sourceField);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setLanguage(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'preferred';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const primitiveJsonType = 'boolean';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: BooleanType | undefined = fhirParser.parseBooleanType(dtJson, dtSiblingJson);
      instance.setPreferredElement(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Patient.communication.language Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The language which can be used to communicate with the patient about his or her health
   * - **Definition:** The ISO-639-1 alpha 2 code in lower case for the language, optionally followed by a hyphen and the ISO-3166-1 alpha 2 code for the region in upper case; e.g. "en" for English, or "en-US" for American English versus "en-EN" for England English.
   * - **Comment:** The structure aa-BB with this exact casing is one the most widely used notations for locale. However not all systems actually code this but instead have it as free text. Hence CodeableConcept instead of code as the data type.
   * - **Requirements:** Most systems in multilingual countries will want to convey language. Not all systems actually need the regional dialect.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private language: CodeableConcept | null;

  /**
   * Patient.communication.preferred Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Language preference indicator
   * - **Definition:** Indicates whether or not the patient prefers this language (over other languages he masters up a certain level).
   * - **Comment:** This language is specifically identified for communicating healthcare information.
   * - **Requirements:** People that master multiple languages up to certain level may prefer one or more, i.e. feel more confident in communicating in a particular language making other languages sort of a fall back method.
   * - **FHIR Type:** \`boolean\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private preferred?: BooleanType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`language\` property value as a CodeableConcept object if defined; else null
   */
  public getLanguage(): CodeableConcept | null {
    return this.language;
  }

  /**
   * Assigns the provided CodeableConcept object value to the \`language\` property.
   *
   * @param value - the \`language\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setLanguage(value: CodeableConcept): this {
    assertIsDefined<CodeableConcept>(value, \`Patient.communication.language is required\`);
    const optErrMsg = \`Invalid Patient.communication.language; Provided element is not an instance of CodeableConcept.\`;
    assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
    this.language = value;
    return this;
  }

  /**
   * @returns \`true\` if the \`language\` property exists and has a value; \`false\` otherwise
   */
  public hasLanguage(): boolean {
    return isDefined<CodeableConcept>(this.language) && !this.language.isEmpty();
  }

  /**
   * @returns the \`preferred\` property value as a BooleanType object if defined; else an empty BooleanType object
   */
  public getPreferredElement(): BooleanType {
    return this.preferred ?? new BooleanType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`preferred\` property.
   *
   * @param element - the \`preferred\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPreferredElement(element: BooleanType | undefined): this {
    if (isDefined<BooleanType>(element)) {
      const optErrMsg = \`Invalid Patient.communication.preferred; Provided element is not an instance of BooleanType.\`;
      assertFhirType<BooleanType>(element, BooleanType, optErrMsg);
      this.preferred = element;
    } else {
      this.preferred = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`preferred\` property exists and has a value; \`false\` otherwise
   */
  public hasPreferredElement(): boolean {
    return isDefined<BooleanType>(this.preferred) && !this.preferred.isEmpty();
  }

  /**
   * @returns the \`preferred\` property value as a fhirBoolean if defined; else undefined
   */
  public getPreferred(): fhirBoolean | undefined {
    return this.preferred?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`preferred\` property.
   *
   * @param value - the \`preferred\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPreferred(value: fhirBoolean | undefined): this {
    if (isDefined<fhirBoolean>(value)) {
      const optErrMsg = \`Invalid Patient.communication.preferred (\${String(value)})\`;
      this.preferred = new BooleanType(parseFhirPrimitiveData(value, fhirBooleanSchema, optErrMsg));
    } else {
      this.preferred = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`preferred\` property exists and has a value; \`false\` otherwise
   */
  public hasPreferred(): boolean {
    return this.hasPreferredElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Patient.communication';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.language,
      this.preferred,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): PatientCommunicationComponent {
    const dest = new PatientCommunicationComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: PatientCommunicationComponent): void {
    super.copyValues(dest);
    dest.language = this.language ? this.language.copy() : null;
    dest.preferred = this.preferred?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasLanguage()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirComplexJson(this.getLanguage()!, 'language', jsonObj);
    } else {
      missingReqdProperties.push(\`Patient.communication.language\`);
    }

    if (this.hasPreferredElement()) {
      setFhirPrimitiveJson<fhirBoolean>(this.getPreferredElement(), 'preferred', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
/**
 * PatientLinkComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Link to another patient resource that concerns the same actual person
 * - **Definition:** Link to another patient resource that concerns the same actual patient.
 * - **Comment:** There is no assumption that linked patient records have mutual links.
 * - **Requirements:** There are multiple use cases:    * Duplicate patient records due to the clerical errors associated with the difficulties of identifying humans consistently, and  * Distribution of patient information across multiple servers.
 *
 * @category Data Models: Resource
 * @see [FHIR Patient](http://hl7.org/fhir/StructureDefinition/Patient)
 */
export class PatientLinkComponent extends BackboneElement implements IBackboneElement {
  constructor(other: Reference | null = null, type_: EnumCodeType | CodeType | fhirCode | null = null) {
    super();

    this.linkTypeEnum = new LinkTypeEnum();

    this.other = null;
    if (isDefined<Reference>(other)) {
      this.setOther(other);
    }

    this.type_ = constructorCodeValueAsEnumCodeType<LinkTypeEnum>(
      type_,
      LinkTypeEnum,
      this.linkTypeEnum,
      'Patient.link.type',
    );
  }

  /**
   * Parse the provided \`PatientLinkComponent\` JSON to instantiate the PatientLinkComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`PatientLinkComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to PatientLinkComponent
   * @returns PatientLinkComponent data model or undefined for \`PatientLinkComponent\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): PatientLinkComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'PatientLinkComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new PatientLinkComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    

    const missingReqdProperties: string[] = [];

    fieldName = 'other';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = Reference.parse(classJsonObj[fieldName]!, sourceField);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setOther(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'type';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setTypeElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Patient.link.other Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The other patient or related person resource that the link refers to
   * - **Definition:** The other patient resource that the link refers to.
   * - **Comment:** Referencing a RelatedPerson here removes the need to use a Person record to associate a Patient and RelatedPerson as the same individual.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Patient',
   *       'http://hl7.org/fhir/StructureDefinition/RelatedPerson',
   *     ]
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private other: Reference | null;

  /**
   * FHIR CodeSystem: LinkType
   *
   * @see {@link LinkTypeEnum }
   */
  private readonly linkTypeEnum: LinkTypeEnum;

  /**
   * Patient.link.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** replaced-by | replaces | refer | seealso
   * - **Definition:** The type of link between this patient resource and another patient resource.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link LinkTypeEnum }
   */
  private type_: EnumCodeType | null;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`other\` property value as a Reference object if defined; else null
   */
  public getOther(): Reference | null {
    return this.other;
  }

  /**
   * Assigns the provided Other object value to the \`other\` property.
   *
   * @decorator \`@ReferenceTargets('Patient.link.other', ['Patient','RelatedPerson',])\`
   *
   * @param value - the \`other\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('Patient.link.other', [
    'Patient',
  
    'RelatedPerson',
  ])
  public setOther(value: Reference): this {
    assertIsDefined<Reference>(value, \`Patient.link.other is required\`);
    // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
    this.other = value;
    return this;
  }

  /**
   * @returns \`true\` if the \`other\` property exists and has a value; \`false\` otherwise
   */
  public hasOther(): boolean {
    return isDefined<Reference>(this.other) && !this.other.isEmpty();
  }

  /**
   * @returns the \`type_\` property value as a EnumCodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link LinkTypeEnum }
   */
  public getTypeEnumType(): EnumCodeType | null {
    return this.type_;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`type_\` property.
   *
   * @param enumType - the \`type_\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link LinkTypeEnum }
   */
  public setTypeEnumType(enumType: EnumCodeType): this {
    assertIsDefined<EnumCodeType>(enumType, \`Patient.link.type is required\`);
    const errMsgPrefix = \`Invalid Patient.link.type\`;
    assertEnumCodeType<LinkTypeEnum>(enumType, LinkTypeEnum, errMsgPrefix);
    this.type_ = enumType;
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasTypeEnumType(): boolean {
    return isDefined<EnumCodeType>(this.type_) && !this.type_.isEmpty() && this.type_.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`type_\` property value as a CodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link LinkTypeEnum }
   */
  public getTypeElement(): CodeType | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_ as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`type_\` property.
   *
   * @param element - the \`type_\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link LinkTypeEnum }
   */
  public setTypeElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, \`Patient.link.type is required\`);
    const optErrMsg = \`Invalid Patient.link.type; Provided value is not an instance of CodeType.\`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.type_ = new EnumCodeType(element, this.linkTypeEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasTypeElement(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the \`type_\` property value as a fhirCode if defined; else null
   *
   * @see CodeSystem Enumeration: {@link LinkTypeEnum }
   */
  public getType(): fhirCode | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`type_\` property.
   *
   * @param value - the \`type_\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link LinkTypeEnum }
   */
  public setType(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, \`Patient.link.type is required\`);
    const optErrMsg = \`Invalid Patient.link.type (\${String(value)})\`;
    this.type_ = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.linkTypeEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`type_\` property exists and has a value; \`false\` otherwise
   */
  public hasType(): boolean {
    return this.hasTypeEnumType();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Patient.link';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.other,
      this.type_,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): PatientLinkComponent {
    const dest = new PatientLinkComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: PatientLinkComponent): void {
    super.copyValues(dest);
    dest.other = this.other ? this.other.copy() : null;
    dest.type_ = this.type_ ? this.type_.copy() : null;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasOther()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirComplexJson(this.getOther()!, 'other', jsonObj);
    } else {
      missingReqdProperties.push(\`Patient.link.other\`);
    }

    if (this.hasTypeElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getTypeElement()!, 'type', jsonObj);
    } else {
      missingReqdProperties.push(\`Patient.link.type\`);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
",
  "fileExtension": "ts",
  "filename": "Patient",
}
`;

exports[`generator-datamodel-ftest Functional Test Suite generator-app verify generated content should consistently create GeneratedContent[] 38`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/src",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/test/ftest-cache",
    "pkgName": "ftest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "Resource",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * Practitioner Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/Practitioner
 * StructureDefinition.name: Practitioner
 * StructureDefinition.description: A person who is directly or indirectly involved in the provisioning of healthcare.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  BackboneElement,
  BooleanType,
  CodeType,
  DateType,
  DomainResource,
  EnumCodeType,
  FhirError,
  FhirParser,
  IBackboneElement,
  IDomainResource,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  REQUIRED_PROPERTIES_DO_NOT_EXIST,
  REQUIRED_PROPERTIES_REQD_IN_JSON,
  ReferenceTargets,
  assertEnumCodeType,
  assertFhirType,
  assertFhirTypeList,
  assertIsDefined,
  copyListValues,
  fhirBoolean,
  fhirBooleanSchema,
  fhirCode,
  fhirCodeSchema,
  fhirDate,
  fhirDateSchema,
  getPrimitiveTypeJson,
  isDefined,
  isDefinedList,
  isElementEmpty,
  isEmpty,
  parseFhirPrimitiveData,
  setFhirBackboneElementListJson,
  setFhirComplexJson,
  setFhirComplexListJson,
  setFhirPrimitiveJson,
} from '@paq-ts-fhir/fhir-core';
import { Address, Attachment, CodeableConcept, ContactPoint, HumanName, Identifier, PARSABLE_DATATYPE_MAP, Period, Reference } from '../complex-types/complex-datatypes';
import { AdministrativeGenderEnum } from '../code-systems/AdministrativeGenderEnum';
import { PARSABLE_RESOURCE_MAP } from './parsable-resource-map';

/**
 * Practitioner Class
 *
 * @remarks
 * A person who is directly or indirectly involved in the provisioning of healthcare.
 *
 * Need to track doctors, staff, locums etc. for both healthcare practitioners, funders, etc.
 *
 * **FHIR Specification**
 * - **Short:** A person with a  formal responsibility in the provisioning of healthcare or related services
 * - **Definition:** A person who is directly or indirectly involved in the provisioning of healthcare.
 * - **FHIR Version:** 4.0.1
 *
 * @category Data Models: Resource
 * @see [FHIR Practitioner](http://hl7.org/fhir/StructureDefinition/Practitioner)
 */
export class Practitioner extends DomainResource implements IDomainResource {
  constructor() {
    super();

    this.administrativeGenderEnum = new AdministrativeGenderEnum();
  }

  /**
   * Parse the provided \`Practitioner\` JSON to instantiate the Practitioner data model.
   *
   * @param sourceJson - JSON representing FHIR \`Practitioner\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to Practitioner
   * @returns Practitioner data model or undefined for \`Practitioner\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static override parse(sourceJson: JSON.Value, optSourceField?: string): Practitioner | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Practitioner';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new Practitioner();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.verifyResourceType(classJsonObj, 'Practitioner');
    fhirParser.processDomainResourceJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'identifier';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Identifier | undefined = Identifier.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addIdentifier(datatype);
        }
      });
    }

    fieldName = 'active';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'boolean';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: BooleanType | undefined = fhirParser.parseBooleanType(dtJson, dtSiblingJson);
      instance.setActiveElement(datatype);
    }

    fieldName = 'name';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: HumanName | undefined = HumanName.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addName(datatype);
        }
      });
    }

    fieldName = 'telecom';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: ContactPoint | undefined = ContactPoint.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addTelecom(datatype);
        }
      });
    }

    fieldName = 'address';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Address | undefined = Address.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addAddress(datatype);
        }
      });
    }

    fieldName = 'gender';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setGenderElement(datatype);
    }

    fieldName = 'birthDate';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DateType | undefined = fhirParser.parseDateType(dtJson, dtSiblingJson);
      instance.setBirthDateElement(datatype);
    }

    fieldName = 'photo';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Attachment | undefined = Attachment.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addPhoto(datatype);
        }
      });
    }

    fieldName = 'qualification';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const componentJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      componentJsonArray.forEach((componentJson: JSON.Value, idx) => {
        const component: PractitionerQualificationComponent | undefined = PractitionerQualificationComponent.parse(componentJson, \`\${sourceField}[\${String(idx)}]\`);
        if (component !== undefined) {
          instance.addQualification(component);
        }
      });
    }

    fieldName = 'communication';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: CodeableConcept | undefined = CodeableConcept.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addCommunication(datatype);
        }
      });
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Practitioner.identifier Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** An identifier for the person as this agent
   * - **Definition:** An identifier that applies to this person in this role.
   * - **Requirements:** Often, specific identities are assigned for the agent.
   * - **FHIR Type:** \`Identifier\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private identifier?: Identifier[] | undefined;

  /**
   * Practitioner.active Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Whether this practitioner\\'s record is in active use
   * - **Definition:** Whether this practitioner\\'s record is in active use.
   * - **Comment:** If the practitioner is not in use by one organization, then it should mark the period on the PractitonerRole with an end date (even if they are active) as they may be active in another role.
   * - **Requirements:** Need to be able to mark a practitioner record as not to be used because it was created in error.
   * - **FHIR Type:** \`boolean\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private active?: BooleanType | undefined;

  /**
   * Practitioner.name Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The name(s) associated with the practitioner
   * - **Definition:** The name(s) associated with the practitioner.
   * - **Comment:** The selection of the use property should ensure that there is a single usual name specified, and others use the nickname (alias), old, or other values as appropriate.   In general, select the value to be used in the ResourceReference.display based on this: 1. There is more than 1 name 2. Use = usual 3. Period is current to the date of the usage 4. Use = official 5. Other order as decided by internal business rules.
   * - **Requirements:** The name(s) that a Practitioner is known by. Where there are multiple, the name that the practitioner is usually known as should be used in the display.
   * - **FHIR Type:** \`HumanName\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private name?: HumanName[] | undefined;

  /**
   * Practitioner.telecom Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A contact detail for the practitioner (that apply to all roles)
   * - **Definition:** A contact detail for the practitioner, e.g. a telephone number or an email address.
   * - **Comment:** Person may have multiple ways to be contacted with different uses or applicable periods.  May need to have options for contacting the person urgently and to help with identification.  These typically will have home numbers, or mobile numbers that are not role specific.
   * - **Requirements:** Need to know how to reach a practitioner independent to any roles the practitioner may have.
   * - **FHIR Type:** \`ContactPoint\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private telecom?: ContactPoint[] | undefined;

  /**
   * Practitioner.address Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Address(es) of the practitioner that are not role specific (typically home address)
   * - **Definition:** Address(es) of the practitioner that are not role specific (typically home address).  Work addresses are not typically entered in this property as they are usually role dependent.
   * - **Comment:** The PractitionerRole does not have an address value on it, as it is expected that the location property be used for this purpose (which has an address).
   * - **Requirements:** The home/mailing address of the practitioner is often required for employee administration purposes, and also for some rostering services where the start point (practitioners home) can be used in calculations.
   * - **FHIR Type:** \`Address\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private address?: Address[] | undefined;

  /**
   * FHIR CodeSystem: AdministrativeGender
   *
   * @see {@link AdministrativeGenderEnum }
   */
  private readonly administrativeGenderEnum: AdministrativeGenderEnum;

  /**
   * Practitioner.gender Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** male | female | other | unknown
   * - **Definition:** Administrative Gender - the gender that the person is considered to have for administration and record keeping purposes.
   * - **Requirements:** Needed to address the person correctly.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link AdministrativeGenderEnum }
   */
  private gender?: EnumCodeType | undefined;

  /**
   * Practitioner.birthDate Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The date  on which the practitioner was born
   * - **Definition:** The date of birth for the practitioner.
   * - **Requirements:** Needed for identification.
   * - **FHIR Type:** \`date\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private birthDate?: DateType | undefined;

  /**
   * Practitioner.photo Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Image of the person
   * - **Definition:** Image of the person.
   * - **Requirements:** Many EHR systems have the capability to capture an image of patients and personnel. Fits with newer social media usage too.
   * - **FHIR Type:** \`Attachment\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private photo?: Attachment[] | undefined;

  /**
   * Practitioner.qualification Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Certification, licenses, or training pertaining to the provision of care
   * - **Definition:** The official certifications, training, and licenses that authorize or otherwise pertain to the provision of care by the practitioner.  For example, a medical license issued by a medical board authorizing the practitioner to practice medicine within a certian locality.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private qualification?: PractitionerQualificationComponent[] | undefined;

  /**
   * Practitioner.communication Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A language the practitioner can use in patient communication
   * - **Definition:** A language the practitioner can use in patient communication.
   * - **Comment:** The structure aa-BB with this exact casing is one the most widely used notations for locale. However not all systems code this but instead have it as free text. Hence CodeableConcept instead of code as the data type.
   * - **Requirements:** Knowing which language a practitioner speaks can help in facilitating communication with patients.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private communication?: CodeableConcept[] | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`identifier\` property value as a Identifier array
   */
  public getIdentifier(): Identifier[] {
    return this.identifier ?? ([] as Identifier[]);
  }

  /**
   * Assigns the provided Identifier array value to the \`identifier\` property.
   *
   * @param value - the \`identifier\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setIdentifier(value: Identifier[] | undefined): this {
    if (isDefinedList<Identifier>(value)) {
      const optErrMsg = \`Invalid Practitioner.identifier; Provided value array has an element that is not an instance of Identifier.\`;
      assertFhirTypeList<Identifier>(value, Identifier, optErrMsg);
      this.identifier = value;
    } else {
      this.identifier = undefined;
    }
    return this;
  }

  /**
   * Add the provided Identifier value to the \`identifier\` array property.
   *
   * @param value - the \`identifier\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addIdentifier(value: Identifier | undefined): this {
    if (isDefined<Identifier>(value)) {
      const optErrMsg = \`Invalid Practitioner.identifier; Provided element is not an instance of Identifier.\`;
      assertFhirType<Identifier>(value, Identifier, optErrMsg);
      this.initIdentifier();
      this.identifier?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`identifier\` property exists and has a value; \`false\` otherwise
   */
  public hasIdentifier(): boolean {
    return isDefinedList<Identifier>(this.identifier) && this.identifier.some((item: Identifier) => !item.isEmpty());
  }

  /**
   * Initialize the \`identifier\` property
   */
  private initIdentifier(): void {
    if(!this.hasIdentifier()) {
      this.identifier = [] as Identifier[];
    }
  }

  /**
   * @returns the \`active\` property value as a BooleanType object if defined; else an empty BooleanType object
   */
  public getActiveElement(): BooleanType {
    return this.active ?? new BooleanType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`active\` property.
   *
   * @param element - the \`active\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setActiveElement(element: BooleanType | undefined): this {
    if (isDefined<BooleanType>(element)) {
      const optErrMsg = \`Invalid Practitioner.active; Provided element is not an instance of BooleanType.\`;
      assertFhirType<BooleanType>(element, BooleanType, optErrMsg);
      this.active = element;
    } else {
      this.active = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`active\` property exists and has a value; \`false\` otherwise
   */
  public hasActiveElement(): boolean {
    return isDefined<BooleanType>(this.active) && !this.active.isEmpty();
  }

  /**
   * @returns the \`active\` property value as a fhirBoolean if defined; else undefined
   */
  public getActive(): fhirBoolean | undefined {
    return this.active?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`active\` property.
   *
   * @param value - the \`active\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setActive(value: fhirBoolean | undefined): this {
    if (isDefined<fhirBoolean>(value)) {
      const optErrMsg = \`Invalid Practitioner.active (\${String(value)})\`;
      this.active = new BooleanType(parseFhirPrimitiveData(value, fhirBooleanSchema, optErrMsg));
    } else {
      this.active = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`active\` property exists and has a value; \`false\` otherwise
   */
  public hasActive(): boolean {
    return this.hasActiveElement();
  }

  /**
   * @returns the \`name\` property value as a HumanName array
   */
  public getName(): HumanName[] {
    return this.name ?? ([] as HumanName[]);
  }

  /**
   * Assigns the provided HumanName array value to the \`name\` property.
   *
   * @param value - the \`name\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setName(value: HumanName[] | undefined): this {
    if (isDefinedList<HumanName>(value)) {
      const optErrMsg = \`Invalid Practitioner.name; Provided value array has an element that is not an instance of HumanName.\`;
      assertFhirTypeList<HumanName>(value, HumanName, optErrMsg);
      this.name = value;
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * Add the provided HumanName value to the \`name\` array property.
   *
   * @param value - the \`name\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addName(value: HumanName | undefined): this {
    if (isDefined<HumanName>(value)) {
      const optErrMsg = \`Invalid Practitioner.name; Provided element is not an instance of HumanName.\`;
      assertFhirType<HumanName>(value, HumanName, optErrMsg);
      this.initName();
      this.name?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`name\` property exists and has a value; \`false\` otherwise
   */
  public hasName(): boolean {
    return isDefinedList<HumanName>(this.name) && this.name.some((item: HumanName) => !item.isEmpty());
  }

  /**
   * Initialize the \`name\` property
   */
  private initName(): void {
    if(!this.hasName()) {
      this.name = [] as HumanName[];
    }
  }

  /**
   * @returns the \`telecom\` property value as a ContactPoint array
   */
  public getTelecom(): ContactPoint[] {
    return this.telecom ?? ([] as ContactPoint[]);
  }

  /**
   * Assigns the provided ContactPoint array value to the \`telecom\` property.
   *
   * @param value - the \`telecom\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setTelecom(value: ContactPoint[] | undefined): this {
    if (isDefinedList<ContactPoint>(value)) {
      const optErrMsg = \`Invalid Practitioner.telecom; Provided value array has an element that is not an instance of ContactPoint.\`;
      assertFhirTypeList<ContactPoint>(value, ContactPoint, optErrMsg);
      this.telecom = value;
    } else {
      this.telecom = undefined;
    }
    return this;
  }

  /**
   * Add the provided ContactPoint value to the \`telecom\` array property.
   *
   * @param value - the \`telecom\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addTelecom(value: ContactPoint | undefined): this {
    if (isDefined<ContactPoint>(value)) {
      const optErrMsg = \`Invalid Practitioner.telecom; Provided element is not an instance of ContactPoint.\`;
      assertFhirType<ContactPoint>(value, ContactPoint, optErrMsg);
      this.initTelecom();
      this.telecom?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`telecom\` property exists and has a value; \`false\` otherwise
   */
  public hasTelecom(): boolean {
    return isDefinedList<ContactPoint>(this.telecom) && this.telecom.some((item: ContactPoint) => !item.isEmpty());
  }

  /**
   * Initialize the \`telecom\` property
   */
  private initTelecom(): void {
    if(!this.hasTelecom()) {
      this.telecom = [] as ContactPoint[];
    }
  }

  /**
   * @returns the \`address\` property value as a Address array
   */
  public getAddress(): Address[] {
    return this.address ?? ([] as Address[]);
  }

  /**
   * Assigns the provided Address array value to the \`address\` property.
   *
   * @param value - the \`address\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setAddress(value: Address[] | undefined): this {
    if (isDefinedList<Address>(value)) {
      const optErrMsg = \`Invalid Practitioner.address; Provided value array has an element that is not an instance of Address.\`;
      assertFhirTypeList<Address>(value, Address, optErrMsg);
      this.address = value;
    } else {
      this.address = undefined;
    }
    return this;
  }

  /**
   * Add the provided Address value to the \`address\` array property.
   *
   * @param value - the \`address\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addAddress(value: Address | undefined): this {
    if (isDefined<Address>(value)) {
      const optErrMsg = \`Invalid Practitioner.address; Provided element is not an instance of Address.\`;
      assertFhirType<Address>(value, Address, optErrMsg);
      this.initAddress();
      this.address?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`address\` property exists and has a value; \`false\` otherwise
   */
  public hasAddress(): boolean {
    return isDefinedList<Address>(this.address) && this.address.some((item: Address) => !item.isEmpty());
  }

  /**
   * Initialize the \`address\` property
   */
  private initAddress(): void {
    if(!this.hasAddress()) {
      this.address = [] as Address[];
    }
  }

  /**
   * @returns the \`gender\` property value as a EnumCodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link AdministrativeGenderEnum }
   */
  public getGenderEnumType(): EnumCodeType | undefined {
    return this.gender;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`gender\` property.
   *
   * @param enumType - the \`gender\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code values
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link AdministrativeGenderEnum }
   */
  public setGenderEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid Practitioner.gender';
      assertEnumCodeType<AdministrativeGenderEnum>(enumType, AdministrativeGenderEnum, errMsgPrefix);
      this.gender = enumType;
    } else {
      this.gender = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`gender\` property exists and has a value; \`false\` otherwise
   */
  public hasGenderEnumType(): boolean {
    return isDefined<EnumCodeType>(this.gender) && !this.gender.isEmpty() && this.gender.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`gender\` property value as a CodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link AdministrativeGenderEnum }
   */
  public getGenderElement(): CodeType | undefined {
    if (this.gender === undefined) {
      return undefined;
    }
    return this.gender as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`gender\` property.
   *
   * @param element - the \`gender\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link AdministrativeGenderEnum }
   */
  public setGenderElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid Practitioner.gender; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.gender = new EnumCodeType(element, this.administrativeGenderEnum);
    } else {
      this.gender = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`gender\` property exists and has a value; \`false\` otherwise
   */
  public hasGenderElement(): boolean {
    return this.hasGenderEnumType();
  }

  /**
   * @returns the \`gender\` property value as a fhirCode if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link AdministrativeGenderEnum }
   */
  public getGender(): fhirCode | undefined {
    if (this.gender === undefined) {
      return undefined;
    }
    return this.gender.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`gender\` property.
   *
   * @param value - the \`gender\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link AdministrativeGenderEnum }
   */
  public setGender(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid Practitioner.gender; Provided value is not an instance of fhirCode.\`;
      this.gender = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.administrativeGenderEnum);
    } else {
      this.gender = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`gender\` property exists and has a value; \`false\` otherwise
   */
  public hasGender(): boolean {
    return this.hasGenderEnumType();
  }

  /**
   * @returns the \`birthDate\` property value as a DateType object if defined; else an empty DateType object
   */
  public getBirthDateElement(): DateType {
    return this.birthDate ?? new DateType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`birthDate\` property.
   *
   * @param element - the \`birthDate\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setBirthDateElement(element: DateType | undefined): this {
    if (isDefined<DateType>(element)) {
      const optErrMsg = \`Invalid Practitioner.birthDate; Provided element is not an instance of DateType.\`;
      assertFhirType<DateType>(element, DateType, optErrMsg);
      this.birthDate = element;
    } else {
      this.birthDate = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`birthDate\` property exists and has a value; \`false\` otherwise
   */
  public hasBirthDateElement(): boolean {
    return isDefined<DateType>(this.birthDate) && !this.birthDate.isEmpty();
  }

  /**
   * @returns the \`birthDate\` property value as a fhirDate if defined; else undefined
   */
  public getBirthDate(): fhirDate | undefined {
    return this.birthDate?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`birthDate\` property.
   *
   * @param value - the \`birthDate\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setBirthDate(value: fhirDate | undefined): this {
    if (isDefined<fhirDate>(value)) {
      const optErrMsg = \`Invalid Practitioner.birthDate (\${String(value)})\`;
      this.birthDate = new DateType(parseFhirPrimitiveData(value, fhirDateSchema, optErrMsg));
    } else {
      this.birthDate = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`birthDate\` property exists and has a value; \`false\` otherwise
   */
  public hasBirthDate(): boolean {
    return this.hasBirthDateElement();
  }

  /**
   * @returns the \`photo\` property value as a Attachment array
   */
  public getPhoto(): Attachment[] {
    return this.photo ?? ([] as Attachment[]);
  }

  /**
   * Assigns the provided Attachment array value to the \`photo\` property.
   *
   * @param value - the \`photo\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setPhoto(value: Attachment[] | undefined): this {
    if (isDefinedList<Attachment>(value)) {
      const optErrMsg = \`Invalid Practitioner.photo; Provided value array has an element that is not an instance of Attachment.\`;
      assertFhirTypeList<Attachment>(value, Attachment, optErrMsg);
      this.photo = value;
    } else {
      this.photo = undefined;
    }
    return this;
  }

  /**
   * Add the provided Attachment value to the \`photo\` array property.
   *
   * @param value - the \`photo\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addPhoto(value: Attachment | undefined): this {
    if (isDefined<Attachment>(value)) {
      const optErrMsg = \`Invalid Practitioner.photo; Provided element is not an instance of Attachment.\`;
      assertFhirType<Attachment>(value, Attachment, optErrMsg);
      this.initPhoto();
      this.photo?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`photo\` property exists and has a value; \`false\` otherwise
   */
  public hasPhoto(): boolean {
    return isDefinedList<Attachment>(this.photo) && this.photo.some((item: Attachment) => !item.isEmpty());
  }

  /**
   * Initialize the \`photo\` property
   */
  private initPhoto(): void {
    if(!this.hasPhoto()) {
      this.photo = [] as Attachment[];
    }
  }

  /**
   * @returns the \`qualification\` property value as a PractitionerQualificationComponent array
   */
  public getQualification(): PractitionerQualificationComponent[] {
    return this.qualification ?? ([] as PractitionerQualificationComponent[]);
  }

  /**
   * Assigns the provided PractitionerQualificationComponent array value to the \`qualification\` property.
   *
   * @param value - the \`qualification\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setQualification(value: PractitionerQualificationComponent[] | undefined): this {
    if (isDefinedList<PractitionerQualificationComponent>(value)) {
      const optErrMsg = \`Invalid Practitioner.qualification; Provided value array has an element that is not an instance of PractitionerQualificationComponent.\`;
      assertFhirTypeList<PractitionerQualificationComponent>(value, PractitionerQualificationComponent, optErrMsg);
      this.qualification = value;
    } else {
      this.qualification = undefined;
    }
    return this;
  }

  /**
   * Add the provided PractitionerQualificationComponent value to the \`qualification\` array property.
   *
   * @param value - the \`qualification\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addQualification(value: PractitionerQualificationComponent | undefined): this {
    if (isDefined<PractitionerQualificationComponent>(value)) {
      const optErrMsg = \`Invalid Practitioner.qualification; Provided element is not an instance of PractitionerQualificationComponent.\`;
      assertFhirType<PractitionerQualificationComponent>(value, PractitionerQualificationComponent, optErrMsg);
      this.initQualification();
      this.qualification?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`qualification\` property exists and has a value; \`false\` otherwise
   */
  public hasQualification(): boolean {
    return isDefinedList<PractitionerQualificationComponent>(this.qualification) && this.qualification.some((item: PractitionerQualificationComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`qualification\` property
   */
  private initQualification(): void {
    if(!this.hasQualification()) {
      this.qualification = [] as PractitionerQualificationComponent[];
    }
  }

  /**
   * @returns the \`communication\` property value as a CodeableConcept array
   */
  public getCommunication(): CodeableConcept[] {
    return this.communication ?? ([] as CodeableConcept[]);
  }

  /**
   * Assigns the provided CodeableConcept array value to the \`communication\` property.
   *
   * @param value - the \`communication\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setCommunication(value: CodeableConcept[] | undefined): this {
    if (isDefinedList<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Practitioner.communication; Provided value array has an element that is not an instance of CodeableConcept.\`;
      assertFhirTypeList<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.communication = value;
    } else {
      this.communication = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeableConcept value to the \`communication\` array property.
   *
   * @param value - the \`communication\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addCommunication(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid Practitioner.communication; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.initCommunication();
      this.communication?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`communication\` property exists and has a value; \`false\` otherwise
   */
  public hasCommunication(): boolean {
    return isDefinedList<CodeableConcept>(this.communication) && this.communication.some((item: CodeableConcept) => !item.isEmpty());
  }

  /**
   * Initialize the \`communication\` property
   */
  private initCommunication(): void {
    if(!this.hasCommunication()) {
      this.communication = [] as CodeableConcept[];
    }
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Practitioner';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.identifier,
      this.active,
      this.name,
      this.telecom,
      this.address,
      this.gender,
      this.birthDate,
      this.photo,
      this.qualification,
      this.communication,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Practitioner {
    const dest = new Practitioner();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Practitioner): void {
    super.copyValues(dest);
    const identifierList = copyListValues<Identifier>(this.identifier);
    dest.identifier = identifierList.length === 0 ? undefined : identifierList;
    dest.active = this.active?.copy();
    const nameList = copyListValues<HumanName>(this.name);
    dest.name = nameList.length === 0 ? undefined : nameList;
    const telecomList = copyListValues<ContactPoint>(this.telecom);
    dest.telecom = telecomList.length === 0 ? undefined : telecomList;
    const addressList = copyListValues<Address>(this.address);
    dest.address = addressList.length === 0 ? undefined : addressList;
    dest.gender = this.gender?.copy();
    dest.birthDate = this.birthDate?.copy();
    const photoList = copyListValues<Attachment>(this.photo);
    dest.photo = photoList.length === 0 ? undefined : photoList;
    const qualificationList = copyListValues<PractitionerQualificationComponent>(this.qualification);
    dest.qualification = qualificationList.length === 0 ? undefined : qualificationList;
    const communicationList = copyListValues<CodeableConcept>(this.communication);
    dest.communication = communicationList.length === 0 ? undefined : communicationList;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasIdentifier()) {
      setFhirComplexListJson(this.getIdentifier(), 'identifier', jsonObj);
    }

    if (this.hasActiveElement()) {
      setFhirPrimitiveJson<fhirBoolean>(this.getActiveElement(), 'active', jsonObj);
    }

    if (this.hasName()) {
      setFhirComplexListJson(this.getName(), 'name', jsonObj);
    }

    if (this.hasTelecom()) {
      setFhirComplexListJson(this.getTelecom(), 'telecom', jsonObj);
    }

    if (this.hasAddress()) {
      setFhirComplexListJson(this.getAddress(), 'address', jsonObj);
    }

    if (this.hasGenderElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getGenderElement()!, 'gender', jsonObj);
    }

    if (this.hasBirthDateElement()) {
      setFhirPrimitiveJson<fhirDate>(this.getBirthDateElement(), 'birthDate', jsonObj);
    }

    if (this.hasPhoto()) {
      setFhirComplexListJson(this.getPhoto(), 'photo', jsonObj);
    }

    if (this.hasQualification()) {
      setFhirBackboneElementListJson(this.getQualification(), 'qualification', jsonObj);
    }

    if (this.hasCommunication()) {
      setFhirComplexListJson(this.getCommunication(), 'communication', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * PractitionerQualificationComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Certification, licenses, or training pertaining to the provision of care
 * - **Definition:** The official certifications, training, and licenses that authorize or otherwise pertain to the provision of care by the practitioner.  For example, a medical license issued by a medical board authorizing the practitioner to practice medicine within a certian locality.
 *
 * @category Data Models: Resource
 * @see [FHIR Practitioner](http://hl7.org/fhir/StructureDefinition/Practitioner)
 */
export class PractitionerQualificationComponent extends BackboneElement implements IBackboneElement {
  constructor(code: CodeableConcept | null = null) {
    super();

    this.code = null;
    if (isDefined<CodeableConcept>(code)) {
      this.setCode(code);
    }
  }

  /**
   * Parse the provided \`PractitionerQualificationComponent\` JSON to instantiate the PractitionerQualificationComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`PractitionerQualificationComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to PractitionerQualificationComponent
   * @returns PractitionerQualificationComponent data model or undefined for \`PractitionerQualificationComponent\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): PractitionerQualificationComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'PractitionerQualificationComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new PractitionerQualificationComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';

    const missingReqdProperties: string[] = [];

    fieldName = 'identifier';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Identifier | undefined = Identifier.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addIdentifier(datatype);
        }
      });
    }

    fieldName = 'code';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = CodeableConcept.parse(classJsonObj[fieldName]!, sourceField);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setCode(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'period';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Period | undefined = Period.parse(classJsonObj[fieldName]!, sourceField);
      instance.setPeriod(datatype);
    }

    fieldName = 'issuer';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = Reference.parse(classJsonObj[fieldName]!, sourceField);
      instance.setIssuer(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Practitioner.qualification.identifier Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** An identifier for this qualification for the practitioner
   * - **Definition:** An identifier that applies to this person\\'s qualification in this role.
   * - **Requirements:** Often, specific identities are assigned for the qualification.
   * - **FHIR Type:** \`Identifier\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private identifier?: Identifier[] | undefined;

  /**
   * Practitioner.qualification.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Coded representation of the qualification
   * - **Definition:** Coded representation of the qualification.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private code: CodeableConcept | null;

  /**
   * Practitioner.qualification.period Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Period during which the qualification is valid
   * - **Definition:** Period during which the qualification is valid.
   * - **Requirements:** Qualifications are often for a limited period of time, and can be revoked.
   * - **FHIR Type:** \`Period\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private period?: Period | undefined;

  /**
   * Practitioner.qualification.issuer Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Organization that regulates and issues the qualification
   * - **Definition:** Organization that regulates and issues the qualification.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Organization',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private issuer?: Reference | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`identifier\` property value as a Identifier array
   */
  public getIdentifier(): Identifier[] {
    return this.identifier ?? ([] as Identifier[]);
  }

  /**
   * Assigns the provided Identifier array value to the \`identifier\` property.
   *
   * @param value - the \`identifier\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setIdentifier(value: Identifier[] | undefined): this {
    if (isDefinedList<Identifier>(value)) {
      const optErrMsg = \`Invalid Practitioner.qualification.identifier; Provided value array has an element that is not an instance of Identifier.\`;
      assertFhirTypeList<Identifier>(value, Identifier, optErrMsg);
      this.identifier = value;
    } else {
      this.identifier = undefined;
    }
    return this;
  }

  /**
   * Add the provided Identifier value to the \`identifier\` array property.
   *
   * @param value - the \`identifier\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addIdentifier(value: Identifier | undefined): this {
    if (isDefined<Identifier>(value)) {
      const optErrMsg = \`Invalid Practitioner.qualification.identifier; Provided element is not an instance of Identifier.\`;
      assertFhirType<Identifier>(value, Identifier, optErrMsg);
      this.initIdentifier();
      this.identifier?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`identifier\` property exists and has a value; \`false\` otherwise
   */
  public hasIdentifier(): boolean {
    return isDefinedList<Identifier>(this.identifier) && this.identifier.some((item: Identifier) => !item.isEmpty());
  }

  /**
   * Initialize the \`identifier\` property
   */
  private initIdentifier(): void {
    if(!this.hasIdentifier()) {
      this.identifier = [] as Identifier[];
    }
  }

  /**
   * @returns the \`code\` property value as a CodeableConcept object if defined; else null
   */
  public getCode(): CodeableConcept | null {
    return this.code;
  }

  /**
   * Assigns the provided CodeableConcept object value to the \`code\` property.
   *
   * @param value - the \`code\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setCode(value: CodeableConcept): this {
    assertIsDefined<CodeableConcept>(value, \`Practitioner.qualification.code is required\`);
    const optErrMsg = \`Invalid Practitioner.qualification.code; Provided element is not an instance of CodeableConcept.\`;
    assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
    this.code = value;
    return this;
  }

  /**
   * @returns \`true\` if the \`code\` property exists and has a value; \`false\` otherwise
   */
  public hasCode(): boolean {
    return isDefined<CodeableConcept>(this.code) && !this.code.isEmpty();
  }

  /**
   * @returns the \`period\` property value as a Period object if defined; else an empty Period object
   */
  public getPeriod(): Period {
    return this.period ?? new Period();
  }

  /**
   * Assigns the provided Period object value to the \`period\` property.
   *
   * @param value - the \`period\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setPeriod(value: Period | undefined): this {
    if (isDefined<Period>(value)) {
      const optErrMsg = \`Invalid Practitioner.qualification.period; Provided element is not an instance of Period.\`;
      assertFhirType<Period>(value, Period, optErrMsg);
      this.period = value;
    } else {
      this.period = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`period\` property exists and has a value; \`false\` otherwise
   */
  public hasPeriod(): boolean {
    return isDefined<Period>(this.period) && !this.period.isEmpty();
  }

  /**
   * @returns the \`issuer\` property value as a Reference object; else an empty Reference object
   */
  public getIssuer(): Reference {
    return this.issuer ?? new Reference();
  }

  /**
   * Assigns the provided Issuer object value to the \`issuer\` property.
   *
   * @decorator \`@ReferenceTargets('Practitioner.qualification.issuer', ['Organization',])\`
   *
   * @param value - the \`issuer\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('Practitioner.qualification.issuer', [
    'Organization',
  ])
  public setIssuer(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.issuer = value;
    } else {
      this.issuer = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`issuer\` property exists and has a value; \`false\` otherwise
   */
  public hasIssuer(): boolean {
    return isDefined<Reference>(this.issuer) && !this.issuer.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Practitioner.qualification';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.identifier,
      this.code,
      this.period,
      this.issuer,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): PractitionerQualificationComponent {
    const dest = new PractitionerQualificationComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: PractitionerQualificationComponent): void {
    super.copyValues(dest);
    const identifierList = copyListValues<Identifier>(this.identifier);
    dest.identifier = identifierList.length === 0 ? undefined : identifierList;
    dest.code = this.code ? this.code.copy() : null;
    dest.period = this.period?.copy();
    dest.issuer = this.issuer?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasIdentifier()) {
      setFhirComplexListJson(this.getIdentifier(), 'identifier', jsonObj);
    }

    if (this.hasCode()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirComplexJson(this.getCode()!, 'code', jsonObj);
    } else {
      missingReqdProperties.push(\`Practitioner.qualification.code\`);
    }

    if (this.hasPeriod()) {
      setFhirComplexJson(this.getPeriod(), 'period', jsonObj);
    }

    if (this.hasIssuer()) {
      setFhirComplexJson(this.getIssuer(), 'issuer', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
",
  "fileExtension": "ts",
  "filename": "Practitioner",
}
`;

exports[`generator-datamodel-ftest Functional Test Suite generator-app verify generated content should consistently create GeneratedContent[] 39`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/src",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/test/ftest-cache",
    "pkgName": "ftest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "Resource",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * PractitionerRole Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/PractitionerRole
 * StructureDefinition.name: PractitionerRole
 * StructureDefinition.description: A specific set of Roles/Locations/specialties/services that a practitioner may perform at an organization for a period of time.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  BackboneElement,
  BooleanType,
  CodeType,
  DomainResource,
  EnumCodeType,
  FhirError,
  FhirParser,
  IBackboneElement,
  IDomainResource,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  PrimitiveType,
  PrimitiveTypeJson,
  REQUIRED_PROPERTIES_DO_NOT_EXIST,
  REQUIRED_PROPERTIES_REQD_IN_JSON,
  ReferenceTargets,
  StringType,
  TimeType,
  assertEnumCodeType,
  assertEnumCodeTypeList,
  assertFhirType,
  assertFhirTypeList,
  assertIsDefined,
  copyListValues,
  fhirBoolean,
  fhirBooleanSchema,
  fhirCode,
  fhirCodeSchema,
  fhirString,
  fhirStringSchema,
  fhirTime,
  fhirTimeSchema,
  getPrimitiveTypeJson,
  getPrimitiveTypeListJson,
  isDefined,
  isDefinedList,
  isElementEmpty,
  isEmpty,
  parseFhirPrimitiveData,
  setFhirBackboneElementListJson,
  setFhirComplexJson,
  setFhirComplexListJson,
  setFhirPrimitiveJson,
  setFhirPrimitiveListJson,
} from '@paq-ts-fhir/fhir-core';
import { CodeableConcept, ContactPoint, Identifier, PARSABLE_DATATYPE_MAP, Period, Reference } from '../complex-types/complex-datatypes';
import { DaysOfWeekEnum } from '../code-systems/DaysOfWeekEnum';
import { PARSABLE_RESOURCE_MAP } from './parsable-resource-map';

/**
 * PractitionerRole Class
 *
 * @remarks
 * A specific set of Roles/Locations/specialties/services that a practitioner may perform at an organization for a period of time.
 *
 * Need to track services that a healthcare provider is able to provide at an organization\\'s location, and the services that they can perform there.
 *
 * **FHIR Specification**
 * - **Short:** Roles/organizations the practitioner is associated with
 * - **Definition:** A specific set of Roles/Locations/specialties/services that a practitioner may perform at an organization for a period of time.
 * - **FHIR Version:** 4.0.1
 *
 * @category Data Models: Resource
 * @see [FHIR PractitionerRole](http://hl7.org/fhir/StructureDefinition/PractitionerRole)
 */
export class PractitionerRole extends DomainResource implements IDomainResource {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`PractitionerRole\` JSON to instantiate the PractitionerRole data model.
   *
   * @param sourceJson - JSON representing FHIR \`PractitionerRole\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to PractitionerRole
   * @returns PractitionerRole data model or undefined for \`PractitionerRole\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static override parse(sourceJson: JSON.Value, optSourceField?: string): PractitionerRole | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'PractitionerRole';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new PractitionerRole();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.verifyResourceType(classJsonObj, 'PractitionerRole');
    fhirParser.processDomainResourceJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'identifier';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Identifier | undefined = Identifier.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addIdentifier(datatype);
        }
      });
    }

    fieldName = 'active';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'boolean';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: BooleanType | undefined = fhirParser.parseBooleanType(dtJson, dtSiblingJson);
      instance.setActiveElement(datatype);
    }

    fieldName = 'period';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Period | undefined = Period.parse(classJsonObj[fieldName]!, sourceField);
      instance.setPeriod(datatype);
    }

    fieldName = 'practitioner';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = Reference.parse(classJsonObj[fieldName]!, sourceField);
      instance.setPractitioner(datatype);
    }

    fieldName = 'organization';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = Reference.parse(classJsonObj[fieldName]!, sourceField);
      instance.setOrganization(datatype);
    }

    fieldName = 'code';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: CodeableConcept | undefined = CodeableConcept.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addCode(datatype);
        }
      });
    }

    fieldName = 'specialty';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: CodeableConcept | undefined = CodeableConcept.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addSpecialty(datatype);
        }
      });
    }

    fieldName = 'location';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Reference | undefined = Reference.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addLocation(datatype);
        }
      });
  }

    fieldName = 'healthcareService';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Reference | undefined = Reference.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addHealthcareService(datatype);
        }
      });
  }

    fieldName = 'telecom';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: ContactPoint | undefined = ContactPoint.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addTelecom(datatype);
        }
      });
    }

    fieldName = 'availableTime';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const componentJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      componentJsonArray.forEach((componentJson: JSON.Value, idx) => {
        const component: PractitionerRoleAvailableTimeComponent | undefined = PractitionerRoleAvailableTimeComponent.parse(componentJson, \`\${sourceField}[\${String(idx)}]\`);
        if (component !== undefined) {
          instance.addAvailableTime(component);
        }
      });
    }

    fieldName = 'notAvailable';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const componentJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      componentJsonArray.forEach((componentJson: JSON.Value, idx) => {
        const component: PractitionerRoleNotAvailableComponent | undefined = PractitionerRoleNotAvailableComponent.parse(componentJson, \`\${sourceField}[\${String(idx)}]\`);
        if (component !== undefined) {
          instance.addNotAvailable(component);
        }
      });
    }

    fieldName = 'availabilityExceptions';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setAvailabilityExceptionsElement(datatype);
    }

    fieldName = 'endpoint';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Reference | undefined = Reference.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addEndpoint(datatype);
        }
      });
  }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * PractitionerRole.identifier Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Business Identifiers that are specific to a role/location
   * - **Definition:** Business Identifiers that are specific to a role/location.
   * - **Requirements:** Often, specific identities are assigned for the agent.
   * - **FHIR Type:** \`Identifier\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private identifier?: Identifier[] | undefined;

  /**
   * PractitionerRole.active Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Whether this practitioner role record is in active use
   * - **Definition:** Whether this practitioner role record is in active use.
   * - **Comment:** If this value is false, you may refer to the period to see when the role was in active use. If there is no period specified, no inference can be made about when it was active.
   * - **Requirements:** Need to be able to mark a practitioner role record as not to be used because it was created in error, or otherwise no longer in active use.
   * - **FHIR Type:** \`boolean\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private active?: BooleanType | undefined;

  /**
   * PractitionerRole.period Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The period during which the practitioner is authorized to perform in these role(s)
   * - **Definition:** The period during which the person is authorized to act as a practitioner in these role(s) for the organization.
   * - **Requirements:** Even after the agencies is revoked, the fact that it existed must still be recorded.
   * - **FHIR Type:** \`Period\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private period?: Period | undefined;

  /**
   * PractitionerRole.practitioner Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Practitioner that is able to provide the defined services for the organization
   * - **Definition:** Practitioner that is able to provide the defined services for the organization.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Practitioner',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private practitioner?: Reference | undefined;

  /**
   * PractitionerRole.organization Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Organization where the roles are available
   * - **Definition:** The organization where the Practitioner performs the roles associated.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Organization',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private organization?: Reference | undefined;

  /**
   * PractitionerRole.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Roles which this practitioner may perform
   * - **Definition:** Roles which this practitioner is authorized to perform for the organization.
   * - **Comment:** A person may have more than one role.
   * - **Requirements:** Need to know what authority the practitioner has - what can they do?
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code?: CodeableConcept[] | undefined;

  /**
   * PractitionerRole.specialty Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Specific specialty of the practitioner
   * - **Definition:** Specific specialty of the practitioner.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private specialty?: CodeableConcept[] | undefined;

  /**
   * PractitionerRole.location Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The location(s) at which this practitioner provides care
   * - **Definition:** The location(s) at which this practitioner provides care.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Location',
   *     ]
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private location?: Reference[] | undefined;

  /**
   * PractitionerRole.healthcareService Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The list of healthcare services that this worker provides for this role\\'s Organization/Location(s)
   * - **Definition:** The list of healthcare services that this worker provides for this role\\'s Organization/Location(s).
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/HealthcareService',
   *     ]
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private healthcareService?: Reference[] | undefined;

  /**
   * PractitionerRole.telecom Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Contact details that are specific to the role/location/service
   * - **Definition:** Contact details that are specific to the role/location/service.
   * - **Requirements:** Often practitioners have a dedicated line for each location (or service) that they work at, and need to be able to define separate contact details for each of these.
   * - **FHIR Type:** \`ContactPoint\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private telecom?: ContactPoint[] | undefined;

  /**
   * PractitionerRole.availableTime Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Times the Service Site is available
   * - **Definition:** A collection of times the practitioner is available or performing this role at the location and/or healthcareservice.
   * - **Comment:** More detailed availability information may be provided in associated Schedule/Slot resources.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private availableTime?: PractitionerRoleAvailableTimeComponent[] | undefined;

  /**
   * PractitionerRole.notAvailable Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Not available during this time due to provided reason
   * - **Definition:** The practitioner is not available or performing this role during this period of time due to the provided reason.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private notAvailable?: PractitionerRoleNotAvailableComponent[] | undefined;

  /**
   * PractitionerRole.availabilityExceptions Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Description of availability exceptions
   * - **Definition:** A description of site availability exceptions, e.g. public holiday availability. Succinctly describing all possible exceptions to normal site availability as details in the available Times and not available Times.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private availabilityExceptions?: StringType | undefined;

  /**
   * PractitionerRole.endpoint Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Technical endpoints providing access to services operated for the practitioner with this role
   * - **Definition:** Technical endpoints providing access to services operated for the practitioner with this role.
   * - **Requirements:** Organizations have multiple systems that provide various services and ,ay also be different for practitioners too. So the endpoint satisfies the need to be able to define the technical connection details for how to connect to them, and for what purpose.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Endpoint',
   *     ]
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private endpoint?: Reference[] | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`identifier\` property value as a Identifier array
   */
  public getIdentifier(): Identifier[] {
    return this.identifier ?? ([] as Identifier[]);
  }

  /**
   * Assigns the provided Identifier array value to the \`identifier\` property.
   *
   * @param value - the \`identifier\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setIdentifier(value: Identifier[] | undefined): this {
    if (isDefinedList<Identifier>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.identifier; Provided value array has an element that is not an instance of Identifier.\`;
      assertFhirTypeList<Identifier>(value, Identifier, optErrMsg);
      this.identifier = value;
    } else {
      this.identifier = undefined;
    }
    return this;
  }

  /**
   * Add the provided Identifier value to the \`identifier\` array property.
   *
   * @param value - the \`identifier\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addIdentifier(value: Identifier | undefined): this {
    if (isDefined<Identifier>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.identifier; Provided element is not an instance of Identifier.\`;
      assertFhirType<Identifier>(value, Identifier, optErrMsg);
      this.initIdentifier();
      this.identifier?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`identifier\` property exists and has a value; \`false\` otherwise
   */
  public hasIdentifier(): boolean {
    return isDefinedList<Identifier>(this.identifier) && this.identifier.some((item: Identifier) => !item.isEmpty());
  }

  /**
   * Initialize the \`identifier\` property
   */
  private initIdentifier(): void {
    if(!this.hasIdentifier()) {
      this.identifier = [] as Identifier[];
    }
  }

  /**
   * @returns the \`active\` property value as a BooleanType object if defined; else an empty BooleanType object
   */
  public getActiveElement(): BooleanType {
    return this.active ?? new BooleanType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`active\` property.
   *
   * @param element - the \`active\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setActiveElement(element: BooleanType | undefined): this {
    if (isDefined<BooleanType>(element)) {
      const optErrMsg = \`Invalid PractitionerRole.active; Provided element is not an instance of BooleanType.\`;
      assertFhirType<BooleanType>(element, BooleanType, optErrMsg);
      this.active = element;
    } else {
      this.active = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`active\` property exists and has a value; \`false\` otherwise
   */
  public hasActiveElement(): boolean {
    return isDefined<BooleanType>(this.active) && !this.active.isEmpty();
  }

  /**
   * @returns the \`active\` property value as a fhirBoolean if defined; else undefined
   */
  public getActive(): fhirBoolean | undefined {
    return this.active?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`active\` property.
   *
   * @param value - the \`active\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setActive(value: fhirBoolean | undefined): this {
    if (isDefined<fhirBoolean>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.active (\${String(value)})\`;
      this.active = new BooleanType(parseFhirPrimitiveData(value, fhirBooleanSchema, optErrMsg));
    } else {
      this.active = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`active\` property exists and has a value; \`false\` otherwise
   */
  public hasActive(): boolean {
    return this.hasActiveElement();
  }

  /**
   * @returns the \`period\` property value as a Period object if defined; else an empty Period object
   */
  public getPeriod(): Period {
    return this.period ?? new Period();
  }

  /**
   * Assigns the provided Period object value to the \`period\` property.
   *
   * @param value - the \`period\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setPeriod(value: Period | undefined): this {
    if (isDefined<Period>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.period; Provided element is not an instance of Period.\`;
      assertFhirType<Period>(value, Period, optErrMsg);
      this.period = value;
    } else {
      this.period = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`period\` property exists and has a value; \`false\` otherwise
   */
  public hasPeriod(): boolean {
    return isDefined<Period>(this.period) && !this.period.isEmpty();
  }

  /**
   * @returns the \`practitioner\` property value as a Reference object; else an empty Reference object
   */
  public getPractitioner(): Reference {
    return this.practitioner ?? new Reference();
  }

  /**
   * Assigns the provided Practitioner object value to the \`practitioner\` property.
   *
   * @decorator \`@ReferenceTargets('PractitionerRole.practitioner', ['Practitioner',])\`
   *
   * @param value - the \`practitioner\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('PractitionerRole.practitioner', [
    'Practitioner',
  ])
  public setPractitioner(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.practitioner = value;
    } else {
      this.practitioner = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`practitioner\` property exists and has a value; \`false\` otherwise
   */
  public hasPractitioner(): boolean {
    return isDefined<Reference>(this.practitioner) && !this.practitioner.isEmpty();
  }

  /**
   * @returns the \`organization\` property value as a Reference object; else an empty Reference object
   */
  public getOrganization(): Reference {
    return this.organization ?? new Reference();
  }

  /**
   * Assigns the provided Organization object value to the \`organization\` property.
   *
   * @decorator \`@ReferenceTargets('PractitionerRole.organization', ['Organization',])\`
   *
   * @param value - the \`organization\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('PractitionerRole.organization', [
    'Organization',
  ])
  public setOrganization(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.organization = value;
    } else {
      this.organization = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`organization\` property exists and has a value; \`false\` otherwise
   */
  public hasOrganization(): boolean {
    return isDefined<Reference>(this.organization) && !this.organization.isEmpty();
  }

  /**
   * @returns the \`code\` property value as a CodeableConcept array
   */
  public getCode(): CodeableConcept[] {
    return this.code ?? ([] as CodeableConcept[]);
  }

  /**
   * Assigns the provided CodeableConcept array value to the \`code\` property.
   *
   * @param value - the \`code\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setCode(value: CodeableConcept[] | undefined): this {
    if (isDefinedList<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.code; Provided value array has an element that is not an instance of CodeableConcept.\`;
      assertFhirTypeList<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.code = value;
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeableConcept value to the \`code\` array property.
   *
   * @param value - the \`code\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addCode(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.code; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.initCode();
      this.code?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`code\` property exists and has a value; \`false\` otherwise
   */
  public hasCode(): boolean {
    return isDefinedList<CodeableConcept>(this.code) && this.code.some((item: CodeableConcept) => !item.isEmpty());
  }

  /**
   * Initialize the \`code\` property
   */
  private initCode(): void {
    if(!this.hasCode()) {
      this.code = [] as CodeableConcept[];
    }
  }

  /**
   * @returns the \`specialty\` property value as a CodeableConcept array
   */
  public getSpecialty(): CodeableConcept[] {
    return this.specialty ?? ([] as CodeableConcept[]);
  }

  /**
   * Assigns the provided CodeableConcept array value to the \`specialty\` property.
   *
   * @param value - the \`specialty\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setSpecialty(value: CodeableConcept[] | undefined): this {
    if (isDefinedList<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.specialty; Provided value array has an element that is not an instance of CodeableConcept.\`;
      assertFhirTypeList<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.specialty = value;
    } else {
      this.specialty = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeableConcept value to the \`specialty\` array property.
   *
   * @param value - the \`specialty\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addSpecialty(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.specialty; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.initSpecialty();
      this.specialty?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`specialty\` property exists and has a value; \`false\` otherwise
   */
  public hasSpecialty(): boolean {
    return isDefinedList<CodeableConcept>(this.specialty) && this.specialty.some((item: CodeableConcept) => !item.isEmpty());
  }

  /**
   * Initialize the \`specialty\` property
   */
  private initSpecialty(): void {
    if(!this.hasSpecialty()) {
      this.specialty = [] as CodeableConcept[];
    }
  }

  /**
   * @returns the \`location\` property value as a Reference array
   */
  public getLocation(): Reference[] {
    return this.location ?? ([] as Reference[]);
  }

  /**
   * Assigns the provided Reference array value to the \`location\` property.
   *
   * @decorator \`@ReferenceTargets('PractitionerRole.location', ['Location',])\`
   *
   * @param value - the \`location\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('PractitionerRole.location', [
    'Location',
  ])
  public setLocation(value: Reference[] | undefined): this {
    if (isDefinedList<Reference>(value)) {
      // assertFhirTypeList<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.location = value;
    } else {
      this.location = undefined;
    }
    return this;
  }

  /**
   * Add the provided Reference value to the \`location\` array property.
   *
   * @decorator \`@ReferenceTargets('PractitionerRole.location', ['Location',])\`
   *
   * @param value - the \`location\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('PractitionerRole.location', [
    'Location',
  ])
  public addLocation(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.initLocation();
      this.location?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`location\` property exists and has a value; \`false\` otherwise
   */
  public hasLocation(): boolean {
    return isDefinedList<Reference>(this.location) && this.location.some((item: Reference) => !item.isEmpty());
  }

  /**
   * Initialize the \`location\` property
   */
  private initLocation(): void {
    if (!this.hasLocation()) {
      this.location = [] as Reference[];
    }
  }

  /**
   * @returns the \`healthcareService\` property value as a Reference array
   */
  public getHealthcareService(): Reference[] {
    return this.healthcareService ?? ([] as Reference[]);
  }

  /**
   * Assigns the provided Reference array value to the \`healthcareService\` property.
   *
   * @decorator \`@ReferenceTargets('PractitionerRole.healthcareService', ['HealthcareService',])\`
   *
   * @param value - the \`healthcareService\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('PractitionerRole.healthcareService', [
    'HealthcareService',
  ])
  public setHealthcareService(value: Reference[] | undefined): this {
    if (isDefinedList<Reference>(value)) {
      // assertFhirTypeList<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.healthcareService = value;
    } else {
      this.healthcareService = undefined;
    }
    return this;
  }

  /**
   * Add the provided Reference value to the \`healthcareService\` array property.
   *
   * @decorator \`@ReferenceTargets('PractitionerRole.healthcareService', ['HealthcareService',])\`
   *
   * @param value - the \`healthcareService\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('PractitionerRole.healthcareService', [
    'HealthcareService',
  ])
  public addHealthcareService(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.initHealthcareService();
      this.healthcareService?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`healthcareService\` property exists and has a value; \`false\` otherwise
   */
  public hasHealthcareService(): boolean {
    return isDefinedList<Reference>(this.healthcareService) && this.healthcareService.some((item: Reference) => !item.isEmpty());
  }

  /**
   * Initialize the \`healthcareService\` property
   */
  private initHealthcareService(): void {
    if (!this.hasHealthcareService()) {
      this.healthcareService = [] as Reference[];
    }
  }

  /**
   * @returns the \`telecom\` property value as a ContactPoint array
   */
  public getTelecom(): ContactPoint[] {
    return this.telecom ?? ([] as ContactPoint[]);
  }

  /**
   * Assigns the provided ContactPoint array value to the \`telecom\` property.
   *
   * @param value - the \`telecom\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setTelecom(value: ContactPoint[] | undefined): this {
    if (isDefinedList<ContactPoint>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.telecom; Provided value array has an element that is not an instance of ContactPoint.\`;
      assertFhirTypeList<ContactPoint>(value, ContactPoint, optErrMsg);
      this.telecom = value;
    } else {
      this.telecom = undefined;
    }
    return this;
  }

  /**
   * Add the provided ContactPoint value to the \`telecom\` array property.
   *
   * @param value - the \`telecom\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addTelecom(value: ContactPoint | undefined): this {
    if (isDefined<ContactPoint>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.telecom; Provided element is not an instance of ContactPoint.\`;
      assertFhirType<ContactPoint>(value, ContactPoint, optErrMsg);
      this.initTelecom();
      this.telecom?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`telecom\` property exists and has a value; \`false\` otherwise
   */
  public hasTelecom(): boolean {
    return isDefinedList<ContactPoint>(this.telecom) && this.telecom.some((item: ContactPoint) => !item.isEmpty());
  }

  /**
   * Initialize the \`telecom\` property
   */
  private initTelecom(): void {
    if(!this.hasTelecom()) {
      this.telecom = [] as ContactPoint[];
    }
  }

  /**
   * @returns the \`availableTime\` property value as a PractitionerRoleAvailableTimeComponent array
   */
  public getAvailableTime(): PractitionerRoleAvailableTimeComponent[] {
    return this.availableTime ?? ([] as PractitionerRoleAvailableTimeComponent[]);
  }

  /**
   * Assigns the provided PractitionerRoleAvailableTimeComponent array value to the \`availableTime\` property.
   *
   * @param value - the \`availableTime\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setAvailableTime(value: PractitionerRoleAvailableTimeComponent[] | undefined): this {
    if (isDefinedList<PractitionerRoleAvailableTimeComponent>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.availableTime; Provided value array has an element that is not an instance of PractitionerRoleAvailableTimeComponent.\`;
      assertFhirTypeList<PractitionerRoleAvailableTimeComponent>(value, PractitionerRoleAvailableTimeComponent, optErrMsg);
      this.availableTime = value;
    } else {
      this.availableTime = undefined;
    }
    return this;
  }

  /**
   * Add the provided PractitionerRoleAvailableTimeComponent value to the \`availableTime\` array property.
   *
   * @param value - the \`availableTime\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addAvailableTime(value: PractitionerRoleAvailableTimeComponent | undefined): this {
    if (isDefined<PractitionerRoleAvailableTimeComponent>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.availableTime; Provided element is not an instance of PractitionerRoleAvailableTimeComponent.\`;
      assertFhirType<PractitionerRoleAvailableTimeComponent>(value, PractitionerRoleAvailableTimeComponent, optErrMsg);
      this.initAvailableTime();
      this.availableTime?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`availableTime\` property exists and has a value; \`false\` otherwise
   */
  public hasAvailableTime(): boolean {
    return isDefinedList<PractitionerRoleAvailableTimeComponent>(this.availableTime) && this.availableTime.some((item: PractitionerRoleAvailableTimeComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`availableTime\` property
   */
  private initAvailableTime(): void {
    if(!this.hasAvailableTime()) {
      this.availableTime = [] as PractitionerRoleAvailableTimeComponent[];
    }
  }

  /**
   * @returns the \`notAvailable\` property value as a PractitionerRoleNotAvailableComponent array
   */
  public getNotAvailable(): PractitionerRoleNotAvailableComponent[] {
    return this.notAvailable ?? ([] as PractitionerRoleNotAvailableComponent[]);
  }

  /**
   * Assigns the provided PractitionerRoleNotAvailableComponent array value to the \`notAvailable\` property.
   *
   * @param value - the \`notAvailable\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setNotAvailable(value: PractitionerRoleNotAvailableComponent[] | undefined): this {
    if (isDefinedList<PractitionerRoleNotAvailableComponent>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.notAvailable; Provided value array has an element that is not an instance of PractitionerRoleNotAvailableComponent.\`;
      assertFhirTypeList<PractitionerRoleNotAvailableComponent>(value, PractitionerRoleNotAvailableComponent, optErrMsg);
      this.notAvailable = value;
    } else {
      this.notAvailable = undefined;
    }
    return this;
  }

  /**
   * Add the provided PractitionerRoleNotAvailableComponent value to the \`notAvailable\` array property.
   *
   * @param value - the \`notAvailable\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addNotAvailable(value: PractitionerRoleNotAvailableComponent | undefined): this {
    if (isDefined<PractitionerRoleNotAvailableComponent>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.notAvailable; Provided element is not an instance of PractitionerRoleNotAvailableComponent.\`;
      assertFhirType<PractitionerRoleNotAvailableComponent>(value, PractitionerRoleNotAvailableComponent, optErrMsg);
      this.initNotAvailable();
      this.notAvailable?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`notAvailable\` property exists and has a value; \`false\` otherwise
   */
  public hasNotAvailable(): boolean {
    return isDefinedList<PractitionerRoleNotAvailableComponent>(this.notAvailable) && this.notAvailable.some((item: PractitionerRoleNotAvailableComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`notAvailable\` property
   */
  private initNotAvailable(): void {
    if(!this.hasNotAvailable()) {
      this.notAvailable = [] as PractitionerRoleNotAvailableComponent[];
    }
  }

  /**
   * @returns the \`availabilityExceptions\` property value as a StringType object if defined; else an empty StringType object
   */
  public getAvailabilityExceptionsElement(): StringType {
    return this.availabilityExceptions ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`availabilityExceptions\` property.
   *
   * @param element - the \`availabilityExceptions\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAvailabilityExceptionsElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid PractitionerRole.availabilityExceptions; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.availabilityExceptions = element;
    } else {
      this.availabilityExceptions = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`availabilityExceptions\` property exists and has a value; \`false\` otherwise
   */
  public hasAvailabilityExceptionsElement(): boolean {
    return isDefined<StringType>(this.availabilityExceptions) && !this.availabilityExceptions.isEmpty();
  }

  /**
   * @returns the \`availabilityExceptions\` property value as a fhirString if defined; else undefined
   */
  public getAvailabilityExceptions(): fhirString | undefined {
    return this.availabilityExceptions?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`availabilityExceptions\` property.
   *
   * @param value - the \`availabilityExceptions\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAvailabilityExceptions(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.availabilityExceptions (\${String(value)})\`;
      this.availabilityExceptions = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.availabilityExceptions = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`availabilityExceptions\` property exists and has a value; \`false\` otherwise
   */
  public hasAvailabilityExceptions(): boolean {
    return this.hasAvailabilityExceptionsElement();
  }

  /**
   * @returns the \`endpoint\` property value as a Reference array
   */
  public getEndpoint(): Reference[] {
    return this.endpoint ?? ([] as Reference[]);
  }

  /**
   * Assigns the provided Reference array value to the \`endpoint\` property.
   *
   * @decorator \`@ReferenceTargets('PractitionerRole.endpoint', ['Endpoint',])\`
   *
   * @param value - the \`endpoint\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('PractitionerRole.endpoint', [
    'Endpoint',
  ])
  public setEndpoint(value: Reference[] | undefined): this {
    if (isDefinedList<Reference>(value)) {
      // assertFhirTypeList<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.endpoint = value;
    } else {
      this.endpoint = undefined;
    }
    return this;
  }

  /**
   * Add the provided Reference value to the \`endpoint\` array property.
   *
   * @decorator \`@ReferenceTargets('PractitionerRole.endpoint', ['Endpoint',])\`
   *
   * @param value - the \`endpoint\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('PractitionerRole.endpoint', [
    'Endpoint',
  ])
  public addEndpoint(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.initEndpoint();
      this.endpoint?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`endpoint\` property exists and has a value; \`false\` otherwise
   */
  public hasEndpoint(): boolean {
    return isDefinedList<Reference>(this.endpoint) && this.endpoint.some((item: Reference) => !item.isEmpty());
  }

  /**
   * Initialize the \`endpoint\` property
   */
  private initEndpoint(): void {
    if (!this.hasEndpoint()) {
      this.endpoint = [] as Reference[];
    }
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'PractitionerRole';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.identifier,
      this.active,
      this.period,
      this.practitioner,
      this.organization,
      this.code,
      this.specialty,
      this.location,
      this.healthcareService,
      this.telecom,
      this.availableTime,
      this.notAvailable,
      this.availabilityExceptions,
      this.endpoint,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): PractitionerRole {
    const dest = new PractitionerRole();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: PractitionerRole): void {
    super.copyValues(dest);
    const identifierList = copyListValues<Identifier>(this.identifier);
    dest.identifier = identifierList.length === 0 ? undefined : identifierList;
    dest.active = this.active?.copy();
    dest.period = this.period?.copy();
    dest.practitioner = this.practitioner?.copy();
    dest.organization = this.organization?.copy();
    const codeList = copyListValues<CodeableConcept>(this.code);
    dest.code = codeList.length === 0 ? undefined : codeList;
    const specialtyList = copyListValues<CodeableConcept>(this.specialty);
    dest.specialty = specialtyList.length === 0 ? undefined : specialtyList;
    const locationList = copyListValues<Reference>(this.location);
    dest.location = locationList.length === 0 ? undefined : locationList;
    const healthcareServiceList = copyListValues<Reference>(this.healthcareService);
    dest.healthcareService = healthcareServiceList.length === 0 ? undefined : healthcareServiceList;
    const telecomList = copyListValues<ContactPoint>(this.telecom);
    dest.telecom = telecomList.length === 0 ? undefined : telecomList;
    const availableTimeList = copyListValues<PractitionerRoleAvailableTimeComponent>(this.availableTime);
    dest.availableTime = availableTimeList.length === 0 ? undefined : availableTimeList;
    const notAvailableList = copyListValues<PractitionerRoleNotAvailableComponent>(this.notAvailable);
    dest.notAvailable = notAvailableList.length === 0 ? undefined : notAvailableList;
    dest.availabilityExceptions = this.availabilityExceptions?.copy();
    const endpointList = copyListValues<Reference>(this.endpoint);
    dest.endpoint = endpointList.length === 0 ? undefined : endpointList;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasIdentifier()) {
      setFhirComplexListJson(this.getIdentifier(), 'identifier', jsonObj);
    }

    if (this.hasActiveElement()) {
      setFhirPrimitiveJson<fhirBoolean>(this.getActiveElement(), 'active', jsonObj);
    }

    if (this.hasPeriod()) {
      setFhirComplexJson(this.getPeriod(), 'period', jsonObj);
    }

    if (this.hasPractitioner()) {
      setFhirComplexJson(this.getPractitioner(), 'practitioner', jsonObj);
    }

    if (this.hasOrganization()) {
      setFhirComplexJson(this.getOrganization(), 'organization', jsonObj);
    }

    if (this.hasCode()) {
      setFhirComplexListJson(this.getCode(), 'code', jsonObj);
    }

    if (this.hasSpecialty()) {
      setFhirComplexListJson(this.getSpecialty(), 'specialty', jsonObj);
    }

    if (this.hasLocation()) {
      setFhirComplexListJson(this.getLocation(), 'location', jsonObj);
    }

    if (this.hasHealthcareService()) {
      setFhirComplexListJson(this.getHealthcareService(), 'healthcareService', jsonObj);
    }

    if (this.hasTelecom()) {
      setFhirComplexListJson(this.getTelecom(), 'telecom', jsonObj);
    }

    if (this.hasAvailableTime()) {
      setFhirBackboneElementListJson(this.getAvailableTime(), 'availableTime', jsonObj);
    }

    if (this.hasNotAvailable()) {
      setFhirBackboneElementListJson(this.getNotAvailable(), 'notAvailable', jsonObj);
    }

    if (this.hasAvailabilityExceptionsElement()) {
      setFhirPrimitiveJson<fhirString>(this.getAvailabilityExceptionsElement(), 'availabilityExceptions', jsonObj);
    }

    if (this.hasEndpoint()) {
      setFhirComplexListJson(this.getEndpoint(), 'endpoint', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * PractitionerRoleAvailableTimeComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Times the Service Site is available
 * - **Definition:** A collection of times the practitioner is available or performing this role at the location and/or healthcareservice.
 * - **Comment:** More detailed availability information may be provided in associated Schedule/Slot resources.
 *
 * @category Data Models: Resource
 * @see [FHIR PractitionerRole](http://hl7.org/fhir/StructureDefinition/PractitionerRole)
 */
export class PractitionerRoleAvailableTimeComponent extends BackboneElement implements IBackboneElement {
  constructor() {
    super();

    this.daysOfWeekEnum = new DaysOfWeekEnum();
  }

  /**
   * Parse the provided \`PractitionerRoleAvailableTimeComponent\` JSON to instantiate the PractitionerRoleAvailableTimeComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`PractitionerRoleAvailableTimeComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to PractitionerRoleAvailableTimeComponent
   * @returns PractitionerRoleAvailableTimeComponent data model or undefined for \`PractitionerRoleAvailableTimeComponent\`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): PractitionerRoleAvailableTimeComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'PractitionerRoleAvailableTimeComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new PractitionerRoleAvailableTimeComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'daysOfWeek';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: CodeType | undefined = fhirParser.parseCodeType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addDaysOfWeekElement(datatype);
        }
      });
    }

    fieldName = 'allDay';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'boolean';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: BooleanType | undefined = fhirParser.parseBooleanType(dtJson, dtSiblingJson);
      instance.setAllDayElement(datatype);
    }

    fieldName = 'availableStartTime';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: TimeType | undefined = fhirParser.parseTimeType(dtJson, dtSiblingJson);
      instance.setAvailableStartTimeElement(datatype);
    }

    fieldName = 'availableEndTime';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: TimeType | undefined = fhirParser.parseTimeType(dtJson, dtSiblingJson);
      instance.setAvailableEndTimeElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: DaysOfWeek
   *
   * @see {@link DaysOfWeekEnum }
   */
  private readonly daysOfWeekEnum: DaysOfWeekEnum;

  /**
   * PractitionerRole.availableTime.daysOfWeek Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** mon | tue | wed | thu | fri | sat | sun
   * - **Definition:** Indicates which days of the week are available between the start and end Times.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  private daysOfWeek?: EnumCodeType[] | undefined;

  /**
   * PractitionerRole.availableTime.allDay Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Always available? e.g. 24 hour service
   * - **Definition:** Is this always available? (hence times are irrelevant) e.g. 24 hour service.
   * - **FHIR Type:** \`boolean\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private allDay?: BooleanType | undefined;

  /**
   * PractitionerRole.availableTime.availableStartTime Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Opening time of day (ignored if allDay = true)
   * - **Definition:** The opening time of day. Note: If the AllDay flag is set, then this time is ignored.
   * - **Comment:** The timezone is expected to be for where this HealthcareService is provided at.
   * - **FHIR Type:** \`time\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private availableStartTime?: TimeType | undefined;

  /**
   * PractitionerRole.availableTime.availableEndTime Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Closing time of day (ignored if allDay = true)
   * - **Definition:** The closing time of day. Note: If the AllDay flag is set, then this time is ignored.
   * - **Comment:** The timezone is expected to be for where this HealthcareService is provided at.
   * - **FHIR Type:** \`time\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private availableEndTime?: TimeType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`daysOfWeek\` property value as a EnumCodeType array
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public getDaysOfWeekEnumType(): EnumCodeType[] {
    return this.daysOfWeek ?? ([] as EnumCodeType[]);
  }

  /**
   * Assigns the provided EnumCodeType array value to the \`daysOfWeek\` property.
   *
   * @param enumType - the \`daysOfWeek\` array value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public setDaysOfWeekEnumType(enumType: EnumCodeType[] | undefined): this {
    if (isDefinedList<EnumCodeType>(enumType)) {
      const errMsgPrefix = \`Invalid PractitionerRole.availableTime.daysOfWeek\`;
      assertEnumCodeTypeList<DaysOfWeekEnum>(enumType, DaysOfWeekEnum, errMsgPrefix);
      this.daysOfWeek = enumType;
    } else {
      this.daysOfWeek = undefined;
    }
    return this;
  }

  /**
   * Add the provided EnumCodeType value to the \`daysOfWeek\` array property.
   *
   * @param enumType - the \`daysOfWeek\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public addDaysOfWeekEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = \`Invalid PractitionerRole.availableTime.daysOfWeek\`;
      assertEnumCodeType<DaysOfWeekEnum>(enumType, DaysOfWeekEnum, errMsgPrefix);
      this.initDaysOfWeek();
      this.daysOfWeek?.push(enumType);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`daysOfWeek\` property exists and has a value; \`false\` otherwise
   */
  public hasDaysOfWeekEnumType(): boolean {
    return isDefinedList<EnumCodeType>(this.daysOfWeek) && this.daysOfWeek.some((item: EnumCodeType) => !item.isEmpty()) && this.daysOfWeek.every((item: EnumCodeType) => item.fhirCodeEnumeration.length > 0);
  }

  /**
   * @returns the \`daysOfWeek\` property value as a CodeType array
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public getDaysOfWeekElement(): CodeType[] {
    if (this.daysOfWeek === undefined) {
      return [] as CodeType[];
    }
    return this.daysOfWeek as CodeType[];
  }

  /**
   * Assigns the provided PrimitiveType array value to the \`daysOfWeek\` property.
   *
   * @param element - the \`daysOfWeek\` array value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public setDaysOfWeekElement(element: CodeType[] | undefined): this {
    if (isDefinedList<CodeType>(element)) {
      const optErrMsg = \`Invalid PractitionerRole.availableTime.daysOfWeek; Provided element array has an element that is not an instance of CodeType.\`;
      assertFhirTypeList<CodeType>(element, CodeType, optErrMsg);
      const enumCodeTypes = [] as EnumCodeType[];
      element.forEach((type: CodeType) => {
        enumCodeTypes.push(new EnumCodeType(type, this.daysOfWeekEnum));
      });
      this.daysOfWeek = enumCodeTypes;
    } else {
      this.daysOfWeek = undefined;
    }
    return this;
  }

  /**
   * Add the provided PrimitiveType value to the \`daysOfWeek\` array property.
   *
   * @param element - the \`daysOfWeek\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public addDaysOfWeekElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid PractitionerRole.availableTime.daysOfWeek; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.initDaysOfWeek();
      this.daysOfWeek?.push(new EnumCodeType(element, this.daysOfWeekEnum));
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`daysOfWeek\` property exists and has a value; \`false\` otherwise
   */
  public hasDaysOfWeekElement(): boolean {
    return this.hasDaysOfWeekEnumType();
  }

  /**
   * @returns the \`daysOfWeek\` property value as a fhirCode array
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public getDaysOfWeek(): fhirCode[] {
    if (this.daysOfWeek === undefined) {
      return [] as fhirCode[];
    }
    const values = [] as fhirCode[];
    for (const item of this.daysOfWeek) {
      values.push(item.fhirCode.code);
    }
    return values;
  }

  /**
   * Assigns the provided primitive value array to the \`daysOfWeek\` property.
   *
   * @param value - the \`daysOfWeek\` value array
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public setDaysOfWeek(value: fhirCode[] | undefined): this {
    if (isDefinedList<fhirCode>(value)) {
      const enumCodeTypes = [] as EnumCodeType[];
      const optErrMsg = \`Invalid PractitionerRole.availableTime.daysOfWeek; Provided value is not an instance of fhirCode.\`;
      value.forEach((val: fhirCode) => {
        enumCodeTypes.push(new EnumCodeType(parseFhirPrimitiveData(val, fhirCodeSchema, optErrMsg), this.daysOfWeekEnum));
      });
      this.daysOfWeek = enumCodeTypes;
    } else {
      this.daysOfWeek = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`daysOfWeek\` array property.
   *
   * @param value - the \`daysOfWeek\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public addDaysOfWeek(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      this.initDaysOfWeek();
      const optErrMsg = \`Invalid PractitionerRole.availableTime.daysOfWeek; Provided value is not an instance of fhirCode.\`;
      this.daysOfWeek?.push(new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.daysOfWeekEnum));
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`daysOfWeek\` property exists and has a value; \`false\` otherwise
   */
  public hasDaysOfWeek(): boolean {
    return this.hasDaysOfWeekEnumType();
  }

  /**
   * Initialize the daysOfWeek property
   */
  private initDaysOfWeek(): void {
    if(!this.hasDaysOfWeekEnumType()) {
      this.daysOfWeek = [] as EnumCodeType[];
    }
  }

  /**
   * @returns the \`allDay\` property value as a BooleanType object if defined; else an empty BooleanType object
   */
  public getAllDayElement(): BooleanType {
    return this.allDay ?? new BooleanType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`allDay\` property.
   *
   * @param element - the \`allDay\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAllDayElement(element: BooleanType | undefined): this {
    if (isDefined<BooleanType>(element)) {
      const optErrMsg = \`Invalid PractitionerRole.availableTime.allDay; Provided element is not an instance of BooleanType.\`;
      assertFhirType<BooleanType>(element, BooleanType, optErrMsg);
      this.allDay = element;
    } else {
      this.allDay = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`allDay\` property exists and has a value; \`false\` otherwise
   */
  public hasAllDayElement(): boolean {
    return isDefined<BooleanType>(this.allDay) && !this.allDay.isEmpty();
  }

  /**
   * @returns the \`allDay\` property value as a fhirBoolean if defined; else undefined
   */
  public getAllDay(): fhirBoolean | undefined {
    return this.allDay?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`allDay\` property.
   *
   * @param value - the \`allDay\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAllDay(value: fhirBoolean | undefined): this {
    if (isDefined<fhirBoolean>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.availableTime.allDay (\${String(value)})\`;
      this.allDay = new BooleanType(parseFhirPrimitiveData(value, fhirBooleanSchema, optErrMsg));
    } else {
      this.allDay = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`allDay\` property exists and has a value; \`false\` otherwise
   */
  public hasAllDay(): boolean {
    return this.hasAllDayElement();
  }

  /**
   * @returns the \`availableStartTime\` property value as a TimeType object if defined; else an empty TimeType object
   */
  public getAvailableStartTimeElement(): TimeType {
    return this.availableStartTime ?? new TimeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`availableStartTime\` property.
   *
   * @param element - the \`availableStartTime\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAvailableStartTimeElement(element: TimeType | undefined): this {
    if (isDefined<TimeType>(element)) {
      const optErrMsg = \`Invalid PractitionerRole.availableTime.availableStartTime; Provided element is not an instance of TimeType.\`;
      assertFhirType<TimeType>(element, TimeType, optErrMsg);
      this.availableStartTime = element;
    } else {
      this.availableStartTime = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`availableStartTime\` property exists and has a value; \`false\` otherwise
   */
  public hasAvailableStartTimeElement(): boolean {
    return isDefined<TimeType>(this.availableStartTime) && !this.availableStartTime.isEmpty();
  }

  /**
   * @returns the \`availableStartTime\` property value as a fhirTime if defined; else undefined
   */
  public getAvailableStartTime(): fhirTime | undefined {
    return this.availableStartTime?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`availableStartTime\` property.
   *
   * @param value - the \`availableStartTime\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAvailableStartTime(value: fhirTime | undefined): this {
    if (isDefined<fhirTime>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.availableTime.availableStartTime (\${String(value)})\`;
      this.availableStartTime = new TimeType(parseFhirPrimitiveData(value, fhirTimeSchema, optErrMsg));
    } else {
      this.availableStartTime = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`availableStartTime\` property exists and has a value; \`false\` otherwise
   */
  public hasAvailableStartTime(): boolean {
    return this.hasAvailableStartTimeElement();
  }

  /**
   * @returns the \`availableEndTime\` property value as a TimeType object if defined; else an empty TimeType object
   */
  public getAvailableEndTimeElement(): TimeType {
    return this.availableEndTime ?? new TimeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`availableEndTime\` property.
   *
   * @param element - the \`availableEndTime\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAvailableEndTimeElement(element: TimeType | undefined): this {
    if (isDefined<TimeType>(element)) {
      const optErrMsg = \`Invalid PractitionerRole.availableTime.availableEndTime; Provided element is not an instance of TimeType.\`;
      assertFhirType<TimeType>(element, TimeType, optErrMsg);
      this.availableEndTime = element;
    } else {
      this.availableEndTime = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`availableEndTime\` property exists and has a value; \`false\` otherwise
   */
  public hasAvailableEndTimeElement(): boolean {
    return isDefined<TimeType>(this.availableEndTime) && !this.availableEndTime.isEmpty();
  }

  /**
   * @returns the \`availableEndTime\` property value as a fhirTime if defined; else undefined
   */
  public getAvailableEndTime(): fhirTime | undefined {
    return this.availableEndTime?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`availableEndTime\` property.
   *
   * @param value - the \`availableEndTime\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAvailableEndTime(value: fhirTime | undefined): this {
    if (isDefined<fhirTime>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.availableTime.availableEndTime (\${String(value)})\`;
      this.availableEndTime = new TimeType(parseFhirPrimitiveData(value, fhirTimeSchema, optErrMsg));
    } else {
      this.availableEndTime = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`availableEndTime\` property exists and has a value; \`false\` otherwise
   */
  public hasAvailableEndTime(): boolean {
    return this.hasAvailableEndTimeElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'PractitionerRole.availableTime';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.daysOfWeek,
      this.allDay,
      this.availableStartTime,
      this.availableEndTime,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): PractitionerRoleAvailableTimeComponent {
    const dest = new PractitionerRoleAvailableTimeComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: PractitionerRoleAvailableTimeComponent): void {
    super.copyValues(dest);
    const daysOfWeekList = copyListValues<EnumCodeType>(this.daysOfWeek);
    dest.daysOfWeek = daysOfWeekList.length === 0 ? undefined : daysOfWeekList;
    dest.allDay = this.allDay?.copy();
    dest.availableStartTime = this.availableStartTime?.copy();
    dest.availableEndTime = this.availableEndTime?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasDaysOfWeekElement()) {
      setFhirPrimitiveListJson<fhirCode>(this.getDaysOfWeekElement(), 'daysOfWeek', jsonObj);
    }

    if (this.hasAllDayElement()) {
      setFhirPrimitiveJson<fhirBoolean>(this.getAllDayElement(), 'allDay', jsonObj);
    }

    if (this.hasAvailableStartTimeElement()) {
      setFhirPrimitiveJson<fhirTime>(this.getAvailableStartTimeElement(), 'availableStartTime', jsonObj);
    }

    if (this.hasAvailableEndTimeElement()) {
      setFhirPrimitiveJson<fhirTime>(this.getAvailableEndTimeElement(), 'availableEndTime', jsonObj);
    }

    return jsonObj;
  }
}
/**
 * PractitionerRoleNotAvailableComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Not available during this time due to provided reason
 * - **Definition:** The practitioner is not available or performing this role during this period of time due to the provided reason.
 *
 * @category Data Models: Resource
 * @see [FHIR PractitionerRole](http://hl7.org/fhir/StructureDefinition/PractitionerRole)
 */
export class PractitionerRoleNotAvailableComponent extends BackboneElement implements IBackboneElement {
  constructor(description: StringType | fhirString | null = null) {
    super();

    this.description = null;
    if (isDefined<StringType | fhirString>(description)) {
      if (description instanceof PrimitiveType) {
        this.setDescriptionElement(description);
      } else {
        this.setDescription(description);
      }
    }
  }

  /**
   * Parse the provided \`PractitionerRoleNotAvailableComponent\` JSON to instantiate the PractitionerRoleNotAvailableComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`PractitionerRoleNotAvailableComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to PractitionerRoleNotAvailableComponent
   * @returns PractitionerRoleNotAvailableComponent data model or undefined for \`PractitionerRoleNotAvailableComponent\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): PractitionerRoleNotAvailableComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'PractitionerRoleNotAvailableComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new PractitionerRoleNotAvailableComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    

    const missingReqdProperties: string[] = [];

    fieldName = 'description';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setDescriptionElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'during';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Period | undefined = Period.parse(classJsonObj[fieldName]!, sourceField);
      instance.setDuring(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * PractitionerRole.notAvailable.description Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Reason presented to the user explaining why time not available
   * - **Definition:** The reason that can be presented to the user as to why this time is not available.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private description: StringType | null;

  /**
   * PractitionerRole.notAvailable.during Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Service not available from this date
   * - **Definition:** Service is not available (seasonally or for a public holiday) from this date.
   * - **FHIR Type:** \`Period\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private during?: Period | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`description\` property value as a StringType object if defined; else null
   */
  public getDescriptionElement(): StringType | null {
    return this.description;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`description\` property.
   *
   * @param element - the \`description\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDescriptionElement(element: StringType): this {
    assertIsDefined<StringType>(element, \`PractitionerRole.notAvailable.description is required\`);
    const optErrMsg = \`Invalid PractitionerRole.notAvailable.description; Provided value is not an instance of StringType.\`;
    assertFhirType<StringType>(element, StringType, optErrMsg);
    this.description = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`description\` property exists and has a value; \`false\` otherwise
   */
  public hasDescriptionElement(): boolean {
    return isDefined<StringType>(this.description) && !this.description.isEmpty();
  }

  /**
   * @returns the \`description\` property value as a fhirString if defined; else null
   */
  public getDescription(): fhirString | null {
    if (this.description?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.description.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`description\` property.
   *
   * @param value - the \`description\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDescription(value: fhirString): this {
    assertIsDefined<fhirString>(value, \`PractitionerRole.notAvailable.description is required\`);
    const optErrMsg = \`Invalid PractitionerRole.notAvailable.description (\${String(value)})\`;
    this.description = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`description\` property exists and has a value; \`false\` otherwise
   */
  public hasDescription(): boolean {
    return this.hasDescriptionElement();
  }

  /**
   * @returns the \`during\` property value as a Period object if defined; else an empty Period object
   */
  public getDuring(): Period {
    return this.during ?? new Period();
  }

  /**
   * Assigns the provided During object value to the \`during\` property.
   *
   * @param value - the \`during\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setDuring(value: Period | undefined): this {
    if (isDefined<Period>(value)) {
      const optErrMsg = \`Invalid PractitionerRole.notAvailable.during; Provided element is not an instance of Period.\`;
      assertFhirType<Period>(value, Period, optErrMsg);
      this.during = value;
    } else {
      this.during = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`during\` property exists and has a value; \`false\` otherwise
   */
  public hasDuring(): boolean {
    return isDefined<Period>(this.during) && !this.during.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'PractitionerRole.notAvailable';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.description,
      this.during,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): PractitionerRoleNotAvailableComponent {
    const dest = new PractitionerRoleNotAvailableComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: PractitionerRoleNotAvailableComponent): void {
    super.copyValues(dest);
    dest.description = this.description ? this.description.copy() : null;
    dest.during = this.during?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasDescriptionElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirString>(this.getDescriptionElement()!, 'description', jsonObj);
    } else {
      missingReqdProperties.push(\`PractitionerRole.notAvailable.description\`);
    }

    if (this.hasDuring()) {
      setFhirComplexJson(this.getDuring(), 'during', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
",
  "fileExtension": "ts",
  "filename": "PractitionerRole",
}
`;

exports[`generator-datamodel-ftest Functional Test Suite generator-app verify generated content should consistently create GeneratedContent[] 40`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/src",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/test/ftest-cache",
    "pkgName": "ftest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "Resource",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * RelatedPerson Module
 *
 * StructureDefinition.url: http://hl7.org/fhir/StructureDefinition/RelatedPerson
 * StructureDefinition.name: RelatedPerson
 * StructureDefinition.description: Information about a person that is involved in the care for a patient, but who is not the target of healthcare, nor has a formal responsibility in the care process.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  BackboneElement,
  BooleanType,
  CodeType,
  DateType,
  DomainResource,
  EnumCodeType,
  FhirError,
  FhirParser,
  IBackboneElement,
  IDomainResource,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  REQUIRED_PROPERTIES_DO_NOT_EXIST,
  REQUIRED_PROPERTIES_REQD_IN_JSON,
  ReferenceTargets,
  assertEnumCodeType,
  assertFhirType,
  assertFhirTypeList,
  assertIsDefined,
  copyListValues,
  fhirBoolean,
  fhirBooleanSchema,
  fhirCode,
  fhirCodeSchema,
  fhirDate,
  fhirDateSchema,
  getPrimitiveTypeJson,
  isDefined,
  isDefinedList,
  isElementEmpty,
  isEmpty,
  parseFhirPrimitiveData,
  setFhirBackboneElementListJson,
  setFhirComplexJson,
  setFhirComplexListJson,
  setFhirPrimitiveJson,
} from '@paq-ts-fhir/fhir-core';
import { Address, Attachment, CodeableConcept, ContactPoint, HumanName, Identifier, PARSABLE_DATATYPE_MAP, Period, Reference } from '../complex-types/complex-datatypes';
import { AdministrativeGenderEnum } from '../code-systems/AdministrativeGenderEnum';
import { PARSABLE_RESOURCE_MAP } from './parsable-resource-map';

/**
 * RelatedPerson Class
 *
 * @remarks
 * Information about a person that is involved in the care for a patient, but who is not the target of healthcare, nor has a formal responsibility in the care process.
 *
 * Need to track persons related to the patient or the healthcare process.
 *
 * **FHIR Specification**
 * - **Short:** A person that is related to a patient, but who is not a direct target of care
 * - **Definition:** Information about a person that is involved in the care for a patient, but who is not the target of healthcare, nor has a formal responsibility in the care process.
 * - **FHIR Version:** 4.0.1
 *
 * @category Data Models: Resource
 * @see [FHIR RelatedPerson](http://hl7.org/fhir/StructureDefinition/RelatedPerson)
 */
export class RelatedPerson extends DomainResource implements IDomainResource {
  constructor(patient: Reference | null = null) {
    super();

    this.administrativeGenderEnum = new AdministrativeGenderEnum();

    this.patient = null;
    if (isDefined<Reference>(patient)) {
      this.setPatient(patient);
    }
  }

  /**
   * Parse the provided \`RelatedPerson\` JSON to instantiate the RelatedPerson data model.
   *
   * @param sourceJson - JSON representing FHIR \`RelatedPerson\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to RelatedPerson
   * @returns RelatedPerson data model or undefined for \`RelatedPerson\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static override parse(sourceJson: JSON.Value, optSourceField?: string): RelatedPerson | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'RelatedPerson';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new RelatedPerson();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.verifyResourceType(classJsonObj, 'RelatedPerson');
    fhirParser.processDomainResourceJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'identifier';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Identifier | undefined = Identifier.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addIdentifier(datatype);
        }
      });
    }

    fieldName = 'active';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'boolean';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: BooleanType | undefined = fhirParser.parseBooleanType(dtJson, dtSiblingJson);
      instance.setActiveElement(datatype);
    }

    fieldName = 'patient';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = Reference.parse(classJsonObj[fieldName]!, sourceField);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setPatient(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'relationship';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: CodeableConcept | undefined = CodeableConcept.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addRelationship(datatype);
        }
      });
    }

    fieldName = 'name';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: HumanName | undefined = HumanName.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addName(datatype);
        }
      });
    }

    fieldName = 'telecom';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: ContactPoint | undefined = ContactPoint.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addTelecom(datatype);
        }
      });
    }

    fieldName = 'gender';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setGenderElement(datatype);
    }

    fieldName = 'birthDate';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DateType | undefined = fhirParser.parseDateType(dtJson, dtSiblingJson);
      instance.setBirthDateElement(datatype);
    }

    fieldName = 'address';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Address | undefined = Address.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addAddress(datatype);
        }
      });
    }

    fieldName = 'photo';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Attachment | undefined = Attachment.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addPhoto(datatype);
        }
      });
    }

    fieldName = 'period';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Period | undefined = Period.parse(classJsonObj[fieldName]!, sourceField);
      instance.setPeriod(datatype);
    }

    fieldName = 'communication';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const componentJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      componentJsonArray.forEach((componentJson: JSON.Value, idx) => {
        const component: RelatedPersonCommunicationComponent | undefined = RelatedPersonCommunicationComponent.parse(componentJson, \`\${sourceField}[\${String(idx)}]\`);
        if (component !== undefined) {
          instance.addCommunication(component);
        }
      });
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * RelatedPerson.identifier Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A human identifier for this person
   * - **Definition:** Identifier for a person within a particular scope.
   * - **Requirements:** People are known by a variety of ids. Some institutions maintain several, and most collect identifiers for exchange with other organizations concerning the patient. Examples are national person identifier and local identifier.
   * - **FHIR Type:** \`Identifier\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private identifier?: Identifier[] | undefined;

  /**
   * RelatedPerson.active Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Whether this related person\\'s record is in active use
   * - **Definition:** Whether this related person record is in active use.
   * - **Comment:** This element is labeled as a modifier because it may be used to mark that the resource was created in error.
   * - **Requirements:** Need to be able to mark a related person record as not to be used, such as if it was created in error.
   * - **FHIR Type:** \`boolean\`
   * - **Cardinality:** 0..1
   * - **isModifier:** true
   * - **isModifierReason:** This element is labelled as a modifier because it is a status element that can indicate that a record should not be treated as valid
   * - **isSummary:** true
   */
  private active?: BooleanType | undefined;

  /**
   * RelatedPerson.patient Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The patient this person is related to
   * - **Definition:** The patient this person is related to.
   * - **Requirements:** We need to know which patient this RelatedPerson is related to.
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Patient',
   *     ]
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private patient: Reference | null;

  /**
   * RelatedPerson.relationship Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The nature of the relationship
   * - **Definition:** The nature of the relationship between a patient and the related person.
   * - **Requirements:** We need to know the relationship with the patient since it influences the interpretation of the information attributed to this person.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private relationship?: CodeableConcept[] | undefined;

  /**
   * RelatedPerson.name Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A name associated with the person
   * - **Definition:** A name associated with the person.
   * - **Requirements:** Related persons need to be identified by name, but it is uncommon to need details about multiple other names for that person.
   * - **FHIR Type:** \`HumanName\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private name?: HumanName[] | undefined;

  /**
   * RelatedPerson.telecom Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A contact detail for the person
   * - **Definition:** A contact detail for the person, e.g. a telephone number or an email address.
   * - **Comment:** Person may have multiple ways to be contacted with different uses or applicable periods.  May need to have options for contacting the person urgently, and also to help with identification.
   * - **Requirements:** People have (primary) ways to contact them in some way such as phone, email.
   * - **FHIR Type:** \`ContactPoint\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private telecom?: ContactPoint[] | undefined;

  /**
   * FHIR CodeSystem: AdministrativeGender
   *
   * @see {@link AdministrativeGenderEnum }
   */
  private readonly administrativeGenderEnum: AdministrativeGenderEnum;

  /**
   * RelatedPerson.gender Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** male | female | other | unknown
   * - **Definition:** Administrative Gender - the gender that the person is considered to have for administration and record keeping purposes.
   * - **Requirements:** Needed for identification of the person, in combination with (at least) name and birth date.
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link AdministrativeGenderEnum }
   */
  private gender?: EnumCodeType | undefined;

  /**
   * RelatedPerson.birthDate Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The date on which the related person was born
   * - **Definition:** The date on which the related person was born.
   * - **FHIR Type:** \`date\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private birthDate?: DateType | undefined;

  /**
   * RelatedPerson.address Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Address where the related person can be contacted or visited
   * - **Definition:** Address where the related person can be contacted or visited.
   * - **Requirements:** Need to keep track where the related person can be contacted per postal mail or visited.
   * - **FHIR Type:** \`Address\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private address?: Address[] | undefined;

  /**
   * RelatedPerson.photo Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Image of the person
   * - **Definition:** Image of the person.
   * - **Requirements:** Many EHR systems have the capability to capture an image of persons. Fits with newer social media usage too.
   * - **FHIR Type:** \`Attachment\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private photo?: Attachment[] | undefined;

  /**
   * RelatedPerson.period Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Period of time that this relationship is considered valid
   * - **Definition:** The period of time during which this relationship is or was active. If there are no dates defined, then the interval is unknown.
   * - **FHIR Type:** \`Period\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private period?: Period | undefined;

  /**
   * RelatedPerson.communication Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A language which may be used to communicate with about the patient\\'s health
   * - **Definition:** A language which may be used to communicate with about the patient\\'s health.
   * - **Comment:** If no language is specified, this *implies* that the default local language is spoken.  If you need to convey proficiency for multiple modes, then you need multiple RelatedPerson.Communication associations.   If the RelatedPerson does not speak the default local language, then the Interpreter Required Standard can be used to explicitly declare that an interpreter is required.
   * - **Requirements:** If a related person does not speak the local language, interpreters may be required, so languages spoken and proficiency is an important things to keep track of both for patient and other persons of interest.
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private communication?: RelatedPersonCommunicationComponent[] | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`identifier\` property value as a Identifier array
   */
  public getIdentifier(): Identifier[] {
    return this.identifier ?? ([] as Identifier[]);
  }

  /**
   * Assigns the provided Identifier array value to the \`identifier\` property.
   *
   * @param value - the \`identifier\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setIdentifier(value: Identifier[] | undefined): this {
    if (isDefinedList<Identifier>(value)) {
      const optErrMsg = \`Invalid RelatedPerson.identifier; Provided value array has an element that is not an instance of Identifier.\`;
      assertFhirTypeList<Identifier>(value, Identifier, optErrMsg);
      this.identifier = value;
    } else {
      this.identifier = undefined;
    }
    return this;
  }

  /**
   * Add the provided Identifier value to the \`identifier\` array property.
   *
   * @param value - the \`identifier\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addIdentifier(value: Identifier | undefined): this {
    if (isDefined<Identifier>(value)) {
      const optErrMsg = \`Invalid RelatedPerson.identifier; Provided element is not an instance of Identifier.\`;
      assertFhirType<Identifier>(value, Identifier, optErrMsg);
      this.initIdentifier();
      this.identifier?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`identifier\` property exists and has a value; \`false\` otherwise
   */
  public hasIdentifier(): boolean {
    return isDefinedList<Identifier>(this.identifier) && this.identifier.some((item: Identifier) => !item.isEmpty());
  }

  /**
   * Initialize the \`identifier\` property
   */
  private initIdentifier(): void {
    if(!this.hasIdentifier()) {
      this.identifier = [] as Identifier[];
    }
  }

  /**
   * @returns the \`active\` property value as a BooleanType object if defined; else an empty BooleanType object
   */
  public getActiveElement(): BooleanType {
    return this.active ?? new BooleanType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`active\` property.
   *
   * @param element - the \`active\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setActiveElement(element: BooleanType | undefined): this {
    if (isDefined<BooleanType>(element)) {
      const optErrMsg = \`Invalid RelatedPerson.active; Provided element is not an instance of BooleanType.\`;
      assertFhirType<BooleanType>(element, BooleanType, optErrMsg);
      this.active = element;
    } else {
      this.active = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`active\` property exists and has a value; \`false\` otherwise
   */
  public hasActiveElement(): boolean {
    return isDefined<BooleanType>(this.active) && !this.active.isEmpty();
  }

  /**
   * @returns the \`active\` property value as a fhirBoolean if defined; else undefined
   */
  public getActive(): fhirBoolean | undefined {
    return this.active?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`active\` property.
   *
   * @param value - the \`active\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setActive(value: fhirBoolean | undefined): this {
    if (isDefined<fhirBoolean>(value)) {
      const optErrMsg = \`Invalid RelatedPerson.active (\${String(value)})\`;
      this.active = new BooleanType(parseFhirPrimitiveData(value, fhirBooleanSchema, optErrMsg));
    } else {
      this.active = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`active\` property exists and has a value; \`false\` otherwise
   */
  public hasActive(): boolean {
    return this.hasActiveElement();
  }

  /**
   * @returns the \`patient\` property value as a Reference object if defined; else null
   */
  public getPatient(): Reference | null {
    return this.patient;
  }

  /**
   * Assigns the provided Patient object value to the \`patient\` property.
   *
   * @decorator \`@ReferenceTargets('RelatedPerson.patient', ['Patient',])\`
   *
   * @param value - the \`patient\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('RelatedPerson.patient', [
    'Patient',
  ])
  public setPatient(value: Reference): this {
    assertIsDefined<Reference>(value, \`RelatedPerson.patient is required\`);
    // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
    this.patient = value;
    return this;
  }

  /**
   * @returns \`true\` if the \`patient\` property exists and has a value; \`false\` otherwise
   */
  public hasPatient(): boolean {
    return isDefined<Reference>(this.patient) && !this.patient.isEmpty();
  }

  /**
   * @returns the \`relationship\` property value as a CodeableConcept array
   */
  public getRelationship(): CodeableConcept[] {
    return this.relationship ?? ([] as CodeableConcept[]);
  }

  /**
   * Assigns the provided CodeableConcept array value to the \`relationship\` property.
   *
   * @param value - the \`relationship\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setRelationship(value: CodeableConcept[] | undefined): this {
    if (isDefinedList<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid RelatedPerson.relationship; Provided value array has an element that is not an instance of CodeableConcept.\`;
      assertFhirTypeList<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.relationship = value;
    } else {
      this.relationship = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeableConcept value to the \`relationship\` array property.
   *
   * @param value - the \`relationship\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addRelationship(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = \`Invalid RelatedPerson.relationship; Provided element is not an instance of CodeableConcept.\`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.initRelationship();
      this.relationship?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`relationship\` property exists and has a value; \`false\` otherwise
   */
  public hasRelationship(): boolean {
    return isDefinedList<CodeableConcept>(this.relationship) && this.relationship.some((item: CodeableConcept) => !item.isEmpty());
  }

  /**
   * Initialize the \`relationship\` property
   */
  private initRelationship(): void {
    if(!this.hasRelationship()) {
      this.relationship = [] as CodeableConcept[];
    }
  }

  /**
   * @returns the \`name\` property value as a HumanName array
   */
  public getName(): HumanName[] {
    return this.name ?? ([] as HumanName[]);
  }

  /**
   * Assigns the provided HumanName array value to the \`name\` property.
   *
   * @param value - the \`name\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setName(value: HumanName[] | undefined): this {
    if (isDefinedList<HumanName>(value)) {
      const optErrMsg = \`Invalid RelatedPerson.name; Provided value array has an element that is not an instance of HumanName.\`;
      assertFhirTypeList<HumanName>(value, HumanName, optErrMsg);
      this.name = value;
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * Add the provided HumanName value to the \`name\` array property.
   *
   * @param value - the \`name\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addName(value: HumanName | undefined): this {
    if (isDefined<HumanName>(value)) {
      const optErrMsg = \`Invalid RelatedPerson.name; Provided element is not an instance of HumanName.\`;
      assertFhirType<HumanName>(value, HumanName, optErrMsg);
      this.initName();
      this.name?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`name\` property exists and has a value; \`false\` otherwise
   */
  public hasName(): boolean {
    return isDefinedList<HumanName>(this.name) && this.name.some((item: HumanName) => !item.isEmpty());
  }

  /**
   * Initialize the \`name\` property
   */
  private initName(): void {
    if(!this.hasName()) {
      this.name = [] as HumanName[];
    }
  }

  /**
   * @returns the \`telecom\` property value as a ContactPoint array
   */
  public getTelecom(): ContactPoint[] {
    return this.telecom ?? ([] as ContactPoint[]);
  }

  /**
   * Assigns the provided ContactPoint array value to the \`telecom\` property.
   *
   * @param value - the \`telecom\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setTelecom(value: ContactPoint[] | undefined): this {
    if (isDefinedList<ContactPoint>(value)) {
      const optErrMsg = \`Invalid RelatedPerson.telecom; Provided value array has an element that is not an instance of ContactPoint.\`;
      assertFhirTypeList<ContactPoint>(value, ContactPoint, optErrMsg);
      this.telecom = value;
    } else {
      this.telecom = undefined;
    }
    return this;
  }

  /**
   * Add the provided ContactPoint value to the \`telecom\` array property.
   *
   * @param value - the \`telecom\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addTelecom(value: ContactPoint | undefined): this {
    if (isDefined<ContactPoint>(value)) {
      const optErrMsg = \`Invalid RelatedPerson.telecom; Provided element is not an instance of ContactPoint.\`;
      assertFhirType<ContactPoint>(value, ContactPoint, optErrMsg);
      this.initTelecom();
      this.telecom?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`telecom\` property exists and has a value; \`false\` otherwise
   */
  public hasTelecom(): boolean {
    return isDefinedList<ContactPoint>(this.telecom) && this.telecom.some((item: ContactPoint) => !item.isEmpty());
  }

  /**
   * Initialize the \`telecom\` property
   */
  private initTelecom(): void {
    if(!this.hasTelecom()) {
      this.telecom = [] as ContactPoint[];
    }
  }

  /**
   * @returns the \`gender\` property value as a EnumCodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link AdministrativeGenderEnum }
   */
  public getGenderEnumType(): EnumCodeType | undefined {
    return this.gender;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`gender\` property.
   *
   * @param enumType - the \`gender\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code values
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link AdministrativeGenderEnum }
   */
  public setGenderEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid RelatedPerson.gender';
      assertEnumCodeType<AdministrativeGenderEnum>(enumType, AdministrativeGenderEnum, errMsgPrefix);
      this.gender = enumType;
    } else {
      this.gender = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`gender\` property exists and has a value; \`false\` otherwise
   */
  public hasGenderEnumType(): boolean {
    return isDefined<EnumCodeType>(this.gender) && !this.gender.isEmpty() && this.gender.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`gender\` property value as a CodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link AdministrativeGenderEnum }
   */
  public getGenderElement(): CodeType | undefined {
    if (this.gender === undefined) {
      return undefined;
    }
    return this.gender as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`gender\` property.
   *
   * @param element - the \`gender\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link AdministrativeGenderEnum }
   */
  public setGenderElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid RelatedPerson.gender; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.gender = new EnumCodeType(element, this.administrativeGenderEnum);
    } else {
      this.gender = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`gender\` property exists and has a value; \`false\` otherwise
   */
  public hasGenderElement(): boolean {
    return this.hasGenderEnumType();
  }

  /**
   * @returns the \`gender\` property value as a fhirCode if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link AdministrativeGenderEnum }
   */
  public getGender(): fhirCode | undefined {
    if (this.gender === undefined) {
      return undefined;
    }
    return this.gender.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`gender\` property.
   *
   * @param value - the \`gender\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link AdministrativeGenderEnum }
   */
  public setGender(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid RelatedPerson.gender; Provided value is not an instance of fhirCode.\`;
      this.gender = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.administrativeGenderEnum);
    } else {
      this.gender = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`gender\` property exists and has a value; \`false\` otherwise
   */
  public hasGender(): boolean {
    return this.hasGenderEnumType();
  }

  /**
   * @returns the \`birthDate\` property value as a DateType object if defined; else an empty DateType object
   */
  public getBirthDateElement(): DateType {
    return this.birthDate ?? new DateType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`birthDate\` property.
   *
   * @param element - the \`birthDate\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setBirthDateElement(element: DateType | undefined): this {
    if (isDefined<DateType>(element)) {
      const optErrMsg = \`Invalid RelatedPerson.birthDate; Provided element is not an instance of DateType.\`;
      assertFhirType<DateType>(element, DateType, optErrMsg);
      this.birthDate = element;
    } else {
      this.birthDate = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`birthDate\` property exists and has a value; \`false\` otherwise
   */
  public hasBirthDateElement(): boolean {
    return isDefined<DateType>(this.birthDate) && !this.birthDate.isEmpty();
  }

  /**
   * @returns the \`birthDate\` property value as a fhirDate if defined; else undefined
   */
  public getBirthDate(): fhirDate | undefined {
    return this.birthDate?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`birthDate\` property.
   *
   * @param value - the \`birthDate\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setBirthDate(value: fhirDate | undefined): this {
    if (isDefined<fhirDate>(value)) {
      const optErrMsg = \`Invalid RelatedPerson.birthDate (\${String(value)})\`;
      this.birthDate = new DateType(parseFhirPrimitiveData(value, fhirDateSchema, optErrMsg));
    } else {
      this.birthDate = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`birthDate\` property exists and has a value; \`false\` otherwise
   */
  public hasBirthDate(): boolean {
    return this.hasBirthDateElement();
  }

  /**
   * @returns the \`address\` property value as a Address array
   */
  public getAddress(): Address[] {
    return this.address ?? ([] as Address[]);
  }

  /**
   * Assigns the provided Address array value to the \`address\` property.
   *
   * @param value - the \`address\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setAddress(value: Address[] | undefined): this {
    if (isDefinedList<Address>(value)) {
      const optErrMsg = \`Invalid RelatedPerson.address; Provided value array has an element that is not an instance of Address.\`;
      assertFhirTypeList<Address>(value, Address, optErrMsg);
      this.address = value;
    } else {
      this.address = undefined;
    }
    return this;
  }

  /**
   * Add the provided Address value to the \`address\` array property.
   *
   * @param value - the \`address\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addAddress(value: Address | undefined): this {
    if (isDefined<Address>(value)) {
      const optErrMsg = \`Invalid RelatedPerson.address; Provided element is not an instance of Address.\`;
      assertFhirType<Address>(value, Address, optErrMsg);
      this.initAddress();
      this.address?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`address\` property exists and has a value; \`false\` otherwise
   */
  public hasAddress(): boolean {
    return isDefinedList<Address>(this.address) && this.address.some((item: Address) => !item.isEmpty());
  }

  /**
   * Initialize the \`address\` property
   */
  private initAddress(): void {
    if(!this.hasAddress()) {
      this.address = [] as Address[];
    }
  }

  /**
   * @returns the \`photo\` property value as a Attachment array
   */
  public getPhoto(): Attachment[] {
    return this.photo ?? ([] as Attachment[]);
  }

  /**
   * Assigns the provided Attachment array value to the \`photo\` property.
   *
   * @param value - the \`photo\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setPhoto(value: Attachment[] | undefined): this {
    if (isDefinedList<Attachment>(value)) {
      const optErrMsg = \`Invalid RelatedPerson.photo; Provided value array has an element that is not an instance of Attachment.\`;
      assertFhirTypeList<Attachment>(value, Attachment, optErrMsg);
      this.photo = value;
    } else {
      this.photo = undefined;
    }
    return this;
  }

  /**
   * Add the provided Attachment value to the \`photo\` array property.
   *
   * @param value - the \`photo\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addPhoto(value: Attachment | undefined): this {
    if (isDefined<Attachment>(value)) {
      const optErrMsg = \`Invalid RelatedPerson.photo; Provided element is not an instance of Attachment.\`;
      assertFhirType<Attachment>(value, Attachment, optErrMsg);
      this.initPhoto();
      this.photo?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`photo\` property exists and has a value; \`false\` otherwise
   */
  public hasPhoto(): boolean {
    return isDefinedList<Attachment>(this.photo) && this.photo.some((item: Attachment) => !item.isEmpty());
  }

  /**
   * Initialize the \`photo\` property
   */
  private initPhoto(): void {
    if(!this.hasPhoto()) {
      this.photo = [] as Attachment[];
    }
  }

  /**
   * @returns the \`period\` property value as a Period object if defined; else an empty Period object
   */
  public getPeriod(): Period {
    return this.period ?? new Period();
  }

  /**
   * Assigns the provided Period object value to the \`period\` property.
   *
   * @param value - the \`period\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setPeriod(value: Period | undefined): this {
    if (isDefined<Period>(value)) {
      const optErrMsg = \`Invalid RelatedPerson.period; Provided element is not an instance of Period.\`;
      assertFhirType<Period>(value, Period, optErrMsg);
      this.period = value;
    } else {
      this.period = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`period\` property exists and has a value; \`false\` otherwise
   */
  public hasPeriod(): boolean {
    return isDefined<Period>(this.period) && !this.period.isEmpty();
  }

  /**
   * @returns the \`communication\` property value as a RelatedPersonCommunicationComponent array
   */
  public getCommunication(): RelatedPersonCommunicationComponent[] {
    return this.communication ?? ([] as RelatedPersonCommunicationComponent[]);
  }

  /**
   * Assigns the provided RelatedPersonCommunicationComponent array value to the \`communication\` property.
   *
   * @param value - the \`communication\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setCommunication(value: RelatedPersonCommunicationComponent[] | undefined): this {
    if (isDefinedList<RelatedPersonCommunicationComponent>(value)) {
      const optErrMsg = \`Invalid RelatedPerson.communication; Provided value array has an element that is not an instance of RelatedPersonCommunicationComponent.\`;
      assertFhirTypeList<RelatedPersonCommunicationComponent>(value, RelatedPersonCommunicationComponent, optErrMsg);
      this.communication = value;
    } else {
      this.communication = undefined;
    }
    return this;
  }

  /**
   * Add the provided RelatedPersonCommunicationComponent value to the \`communication\` array property.
   *
   * @param value - the \`communication\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addCommunication(value: RelatedPersonCommunicationComponent | undefined): this {
    if (isDefined<RelatedPersonCommunicationComponent>(value)) {
      const optErrMsg = \`Invalid RelatedPerson.communication; Provided element is not an instance of RelatedPersonCommunicationComponent.\`;
      assertFhirType<RelatedPersonCommunicationComponent>(value, RelatedPersonCommunicationComponent, optErrMsg);
      this.initCommunication();
      this.communication?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`communication\` property exists and has a value; \`false\` otherwise
   */
  public hasCommunication(): boolean {
    return isDefinedList<RelatedPersonCommunicationComponent>(this.communication) && this.communication.some((item: RelatedPersonCommunicationComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`communication\` property
   */
  private initCommunication(): void {
    if(!this.hasCommunication()) {
      this.communication = [] as RelatedPersonCommunicationComponent[];
    }
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'RelatedPerson';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.identifier,
      this.active,
      this.patient,
      this.relationship,
      this.name,
      this.telecom,
      this.gender,
      this.birthDate,
      this.address,
      this.photo,
      this.period,
      this.communication,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): RelatedPerson {
    const dest = new RelatedPerson();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: RelatedPerson): void {
    super.copyValues(dest);
    const identifierList = copyListValues<Identifier>(this.identifier);
    dest.identifier = identifierList.length === 0 ? undefined : identifierList;
    dest.active = this.active?.copy();
    dest.patient = this.patient ? this.patient.copy() : null;
    const relationshipList = copyListValues<CodeableConcept>(this.relationship);
    dest.relationship = relationshipList.length === 0 ? undefined : relationshipList;
    const nameList = copyListValues<HumanName>(this.name);
    dest.name = nameList.length === 0 ? undefined : nameList;
    const telecomList = copyListValues<ContactPoint>(this.telecom);
    dest.telecom = telecomList.length === 0 ? undefined : telecomList;
    dest.gender = this.gender?.copy();
    dest.birthDate = this.birthDate?.copy();
    const addressList = copyListValues<Address>(this.address);
    dest.address = addressList.length === 0 ? undefined : addressList;
    const photoList = copyListValues<Attachment>(this.photo);
    dest.photo = photoList.length === 0 ? undefined : photoList;
    dest.period = this.period?.copy();
    const communicationList = copyListValues<RelatedPersonCommunicationComponent>(this.communication);
    dest.communication = communicationList.length === 0 ? undefined : communicationList;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasIdentifier()) {
      setFhirComplexListJson(this.getIdentifier(), 'identifier', jsonObj);
    }

    if (this.hasActiveElement()) {
      setFhirPrimitiveJson<fhirBoolean>(this.getActiveElement(), 'active', jsonObj);
    }

    if (this.hasPatient()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirComplexJson(this.getPatient()!, 'patient', jsonObj);
    } else {
      missingReqdProperties.push(\`RelatedPerson.patient\`);
    }

    if (this.hasRelationship()) {
      setFhirComplexListJson(this.getRelationship(), 'relationship', jsonObj);
    }

    if (this.hasName()) {
      setFhirComplexListJson(this.getName(), 'name', jsonObj);
    }

    if (this.hasTelecom()) {
      setFhirComplexListJson(this.getTelecom(), 'telecom', jsonObj);
    }

    if (this.hasGenderElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getGenderElement()!, 'gender', jsonObj);
    }

    if (this.hasBirthDateElement()) {
      setFhirPrimitiveJson<fhirDate>(this.getBirthDateElement(), 'birthDate', jsonObj);
    }

    if (this.hasAddress()) {
      setFhirComplexListJson(this.getAddress(), 'address', jsonObj);
    }

    if (this.hasPhoto()) {
      setFhirComplexListJson(this.getPhoto(), 'photo', jsonObj);
    }

    if (this.hasPeriod()) {
      setFhirComplexJson(this.getPeriod(), 'period', jsonObj);
    }

    if (this.hasCommunication()) {
      setFhirBackboneElementListJson(this.getCommunication(), 'communication', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

/**
 * RelatedPersonCommunicationComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** A language which may be used to communicate with about the patient\\'s health
 * - **Definition:** A language which may be used to communicate with about the patient\\'s health.
 * - **Comment:** If no language is specified, this *implies* that the default local language is spoken.  If you need to convey proficiency for multiple modes, then you need multiple RelatedPerson.Communication associations.   If the RelatedPerson does not speak the default local language, then the Interpreter Required Standard can be used to explicitly declare that an interpreter is required.
 * - **Requirements:** If a related person does not speak the local language, interpreters may be required, so languages spoken and proficiency is an important things to keep track of both for patient and other persons of interest.
 *
 * @category Data Models: Resource
 * @see [FHIR RelatedPerson](http://hl7.org/fhir/StructureDefinition/RelatedPerson)
 */
export class RelatedPersonCommunicationComponent extends BackboneElement implements IBackboneElement {
  constructor(language: CodeableConcept | null = null) {
    super();

    this.language = null;
    if (isDefined<CodeableConcept>(language)) {
      this.setLanguage(language);
    }
  }

  /**
   * Parse the provided \`RelatedPersonCommunicationComponent\` JSON to instantiate the RelatedPersonCommunicationComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`RelatedPersonCommunicationComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to RelatedPersonCommunicationComponent
   * @returns RelatedPersonCommunicationComponent data model or undefined for \`RelatedPersonCommunicationComponent\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): RelatedPersonCommunicationComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'RelatedPersonCommunicationComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new RelatedPersonCommunicationComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    

    const missingReqdProperties: string[] = [];

    fieldName = 'language';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = CodeableConcept.parse(classJsonObj[fieldName]!, sourceField);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setLanguage(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'preferred';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const primitiveJsonType = 'boolean';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: BooleanType | undefined = fhirParser.parseBooleanType(dtJson, dtSiblingJson);
      instance.setPreferredElement(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * RelatedPerson.communication.language Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The language which can be used to communicate with the patient about his or her health
   * - **Definition:** The ISO-639-1 alpha 2 code in lower case for the language, optionally followed by a hyphen and the ISO-3166-1 alpha 2 code for the region in upper case; e.g. "en" for English, or "en-US" for American English versus "en-EN" for England English.
   * - **Comment:** The structure aa-BB with this exact casing is one the most widely used notations for locale. However not all systems actually code this but instead have it as free text. Hence CodeableConcept instead of code as the data type.
   * - **Requirements:** Most systems in multilingual countries will want to convey language. Not all systems actually need the regional dialect.
   * - **FHIR Type:** \`CodeableConcept\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private language: CodeableConcept | null;

  /**
   * RelatedPerson.communication.preferred Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Language preference indicator
   * - **Definition:** Indicates whether or not the patient prefers this language (over other languages he masters up a certain level).
   * - **Comment:** This language is specifically identified for communicating healthcare information.
   * - **Requirements:** People that master multiple languages up to certain level may prefer one or more, i.e. feel more confident in communicating in a particular language making other languages sort of a fall back method.
   * - **FHIR Type:** \`boolean\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private preferred?: BooleanType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`language\` property value as a CodeableConcept object if defined; else null
   */
  public getLanguage(): CodeableConcept | null {
    return this.language;
  }

  /**
   * Assigns the provided CodeableConcept object value to the \`language\` property.
   *
   * @param value - the \`language\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setLanguage(value: CodeableConcept): this {
    assertIsDefined<CodeableConcept>(value, \`RelatedPerson.communication.language is required\`);
    const optErrMsg = \`Invalid RelatedPerson.communication.language; Provided element is not an instance of CodeableConcept.\`;
    assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
    this.language = value;
    return this;
  }

  /**
   * @returns \`true\` if the \`language\` property exists and has a value; \`false\` otherwise
   */
  public hasLanguage(): boolean {
    return isDefined<CodeableConcept>(this.language) && !this.language.isEmpty();
  }

  /**
   * @returns the \`preferred\` property value as a BooleanType object if defined; else an empty BooleanType object
   */
  public getPreferredElement(): BooleanType {
    return this.preferred ?? new BooleanType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`preferred\` property.
   *
   * @param element - the \`preferred\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPreferredElement(element: BooleanType | undefined): this {
    if (isDefined<BooleanType>(element)) {
      const optErrMsg = \`Invalid RelatedPerson.communication.preferred; Provided element is not an instance of BooleanType.\`;
      assertFhirType<BooleanType>(element, BooleanType, optErrMsg);
      this.preferred = element;
    } else {
      this.preferred = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`preferred\` property exists and has a value; \`false\` otherwise
   */
  public hasPreferredElement(): boolean {
    return isDefined<BooleanType>(this.preferred) && !this.preferred.isEmpty();
  }

  /**
   * @returns the \`preferred\` property value as a fhirBoolean if defined; else undefined
   */
  public getPreferred(): fhirBoolean | undefined {
    return this.preferred?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`preferred\` property.
   *
   * @param value - the \`preferred\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPreferred(value: fhirBoolean | undefined): this {
    if (isDefined<fhirBoolean>(value)) {
      const optErrMsg = \`Invalid RelatedPerson.communication.preferred (\${String(value)})\`;
      this.preferred = new BooleanType(parseFhirPrimitiveData(value, fhirBooleanSchema, optErrMsg));
    } else {
      this.preferred = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`preferred\` property exists and has a value; \`false\` otherwise
   */
  public hasPreferred(): boolean {
    return this.hasPreferredElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'RelatedPerson.communication';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.language,
      this.preferred,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): RelatedPersonCommunicationComponent {
    const dest = new RelatedPersonCommunicationComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: RelatedPersonCommunicationComponent): void {
    super.copyValues(dest);
    dest.language = this.language ? this.language.copy() : null;
    dest.preferred = this.preferred?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasLanguage()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirComplexJson(this.getLanguage()!, 'language', jsonObj);
    } else {
      missingReqdProperties.push(\`RelatedPerson.communication.language\`);
    }

    if (this.hasPreferredElement()) {
      setFhirPrimitiveJson<fhirBoolean>(this.getPreferredElement(), 'preferred', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
",
  "fileExtension": "ts",
  "filename": "RelatedPerson",
}
`;

exports[`generator-datamodel-ftest Functional Test Suite generator-app verify generated content should consistently create GeneratedContent[] 41`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/src",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/test/ftest-cache",
    "pkgName": "ftest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "Resource",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * SimplePersonModel Module
 *
 * StructureDefinition.url: https://test.ts-fhir-datamodels.com/StructureDefinition/SimplePersonModel
 * StructureDefinition.name: SimplePersonModel
 * StructureDefinition.description: Represents a very simple FHIR data model for a custom FHIR StructureDefinition.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  DomainResource,
  FhirParser,
  IDomainResource,
  INSTANCE_EMPTY_ERROR_MSG,
  JSON,
  StringType,
  assertFhirType,
  assertFhirTypeList,
  copyListValues,
  fhirString,
  fhirStringSchema,
  getPrimitiveTypeJson,
  isDefined,
  isDefinedList,
  isElementEmpty,
  isEmpty,
  parseFhirPrimitiveData,
  setFhirComplexJson,
  setFhirComplexListJson,
  setFhirPrimitiveJson,
} from '@paq-ts-fhir/fhir-core';
import { Address, HumanName, Identifier, PARSABLE_DATATYPE_MAP } from '../complex-types/complex-datatypes';
import { PARSABLE_RESOURCE_MAP } from './parsable-resource-map';

/**
 * SimplePersonModel Class
 *
 * @remarks
 * Represents a very simple FHIR data model for a custom FHIR StructureDefinition.
 *
 * Provide a test (mock) data model to be used in testing the TestDataModel\\'s \`DomainResource.contained\` feature.
 *
 * **FHIR Specification**
 * - **Short:** Simple Person Model
 * - **Definition:** Represents a very simple FHIR data model for a custom FHIR StructureDefinition.
 * - **FHIR Version:** 4.0.1
 *
 * @category Data Models: Resource
 * @see [FHIR SimplePersonModel](https://test.ts-fhir-datamodels.com/StructureDefinition/SimplePersonModel)
 */
export class SimplePersonModel extends DomainResource implements IDomainResource {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`SimplePersonModel\` JSON to instantiate the SimplePersonModel data model.
   *
   * @param sourceJson - JSON representing FHIR \`SimplePersonModel\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to SimplePersonModel
   * @returns SimplePersonModel data model or undefined for \`SimplePersonModel\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static override parse(sourceJson: JSON.Value, optSourceField?: string): SimplePersonModel | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'SimplePersonModel';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new SimplePersonModel();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.verifyResourceType(classJsonObj, 'SimplePersonModel');
    fhirParser.processDomainResourceJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    

    fieldName = 'identifier';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Identifier | undefined = Identifier.parse(classJsonObj[fieldName]!, sourceField);
      instance.setIdentifier(datatype);
    }

    fieldName = 'name';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: HumanName | undefined = HumanName.parse(classJsonObj[fieldName]!, sourceField);
      instance.setName(datatype);
    }

    fieldName = 'address';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Address | undefined = Address.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addAddress(datatype);
        }
      });
    }

    fieldName = 'phone';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setPhoneElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * SimplePersonModel.identifier Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A human identifier for this person
   * - **Definition:** Identifier for a person within a particular scope.
   * - **Requirements:** People are known by a variety of ids. Some institutions maintain several, and most collect identifiers for exchange with other organizations concerning the person. Examples are national person identifier and local identifier.
   * - **FHIR Type:** \`Identifier\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private identifier?: Identifier | undefined;

  /**
   * SimplePersonModel.name Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A name associated with the person
   * - **Definition:** A name associated with the person.
   * - **FHIR Type:** \`HumanName\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private name?: HumanName | undefined;

  /**
   * SimplePersonModel.address Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** An addresses for the person
   * - **Definition:** One or more addresses for the person.
   * - **Requirements:** May need to keep track of person\\'s addresses for contacting, billing or reporting requirements and also to help with identification.
   * - **FHIR Type:** \`Address\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private address?: Address[] | undefined;

  /**
   * SimplePersonModel.phone Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A phone number for this person
   * - **Definition:** A phone number for this person.
   * - **Comment:** Represents the person\\'s primary phone number.
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private phone?: StringType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`identifier\` property value as a Identifier object if defined; else an empty Identifier object
   */
  public getIdentifier(): Identifier {
    return this.identifier ?? new Identifier();
  }

  /**
   * Assigns the provided Identifier object value to the \`identifier\` property.
   *
   * @param value - the \`identifier\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setIdentifier(value: Identifier | undefined): this {
    if (isDefined<Identifier>(value)) {
      const optErrMsg = \`Invalid SimplePersonModel.identifier; Provided element is not an instance of Identifier.\`;
      assertFhirType<Identifier>(value, Identifier, optErrMsg);
      this.identifier = value;
    } else {
      this.identifier = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`identifier\` property exists and has a value; \`false\` otherwise
   */
  public hasIdentifier(): boolean {
    return isDefined<Identifier>(this.identifier) && !this.identifier.isEmpty();
  }

  /**
   * @returns the \`name\` property value as a HumanName object if defined; else an empty HumanName object
   */
  public getName(): HumanName {
    return this.name ?? new HumanName();
  }

  /**
   * Assigns the provided Name object value to the \`name\` property.
   *
   * @param value - the \`name\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setName(value: HumanName | undefined): this {
    if (isDefined<HumanName>(value)) {
      const optErrMsg = \`Invalid SimplePersonModel.name; Provided element is not an instance of HumanName.\`;
      assertFhirType<HumanName>(value, HumanName, optErrMsg);
      this.name = value;
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`name\` property exists and has a value; \`false\` otherwise
   */
  public hasName(): boolean {
    return isDefined<HumanName>(this.name) && !this.name.isEmpty();
  }

  /**
   * @returns the \`address\` property value as a Address array
   */
  public getAddress(): Address[] {
    return this.address ?? ([] as Address[]);
  }

  /**
   * Assigns the provided Address array value to the \`address\` property.
   *
   * @param value - the \`address\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setAddress(value: Address[] | undefined): this {
    if (isDefinedList<Address>(value)) {
      const optErrMsg = \`Invalid SimplePersonModel.address; Provided value array has an element that is not an instance of Address.\`;
      assertFhirTypeList<Address>(value, Address, optErrMsg);
      this.address = value;
    } else {
      this.address = undefined;
    }
    return this;
  }

  /**
   * Add the provided Address value to the \`address\` array property.
   *
   * @param value - the \`address\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addAddress(value: Address | undefined): this {
    if (isDefined<Address>(value)) {
      const optErrMsg = \`Invalid SimplePersonModel.address; Provided element is not an instance of Address.\`;
      assertFhirType<Address>(value, Address, optErrMsg);
      this.initAddress();
      this.address?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`address\` property exists and has a value; \`false\` otherwise
   */
  public hasAddress(): boolean {
    return isDefinedList<Address>(this.address) && this.address.some((item: Address) => !item.isEmpty());
  }

  /**
   * Initialize the \`address\` property
   */
  private initAddress(): void {
    if(!this.hasAddress()) {
      this.address = [] as Address[];
    }
  }

  /**
   * @returns the \`phone\` property value as a StringType object if defined; else an empty StringType object
   */
  public getPhoneElement(): StringType {
    return this.phone ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`phone\` property.
   *
   * @param element - the \`phone\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPhoneElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid SimplePersonModel.phone; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.phone = element;
    } else {
      this.phone = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`phone\` property exists and has a value; \`false\` otherwise
   */
  public hasPhoneElement(): boolean {
    return isDefined<StringType>(this.phone) && !this.phone.isEmpty();
  }

  /**
   * @returns the \`phone\` property value as a fhirString if defined; else undefined
   */
  public getPhone(): fhirString | undefined {
    return this.phone?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`phone\` property.
   *
   * @param value - the \`phone\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPhone(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid SimplePersonModel.phone (\${String(value)})\`;
      this.phone = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.phone = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`phone\` property exists and has a value; \`false\` otherwise
   */
  public hasPhone(): boolean {
    return this.hasPhoneElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'SimplePersonModel';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.identifier,
      this.name,
      this.address,
      this.phone,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): SimplePersonModel {
    const dest = new SimplePersonModel();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: SimplePersonModel): void {
    super.copyValues(dest);
    dest.identifier = this.identifier?.copy();
    dest.name = this.name?.copy();
    const addressList = copyListValues<Address>(this.address);
    dest.address = addressList.length === 0 ? undefined : addressList;
    dest.phone = this.phone?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasIdentifier()) {
      setFhirComplexJson(this.getIdentifier(), 'identifier', jsonObj);
    }

    if (this.hasName()) {
      setFhirComplexJson(this.getName(), 'name', jsonObj);
    }

    if (this.hasAddress()) {
      setFhirComplexListJson(this.getAddress(), 'address', jsonObj);
    }

    if (this.hasPhoneElement()) {
      setFhirPrimitiveJson<fhirString>(this.getPhoneElement(), 'phone', jsonObj);
    }

    return jsonObj;
  }
}

",
  "fileExtension": "ts",
  "filename": "SimplePersonModel",
}
`;

exports[`generator-datamodel-ftest Functional Test Suite generator-app verify generated content should consistently create GeneratedContent[] 42`] = `
{
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/src",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/test/ftest-cache",
    "pkgName": "ftest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "Resource",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinition.
 * DO NOT make any modifications!
 *
 * TestModel Module
 *
 * StructureDefinition.url: https://test.ts-fhir-datamodels.com/StructureDefinition/TestModel
 * StructureDefinition.name: TestModel
 * StructureDefinition.description: Represents a FHIR data model for a custom FHIR StructureDefinition. This class will be tested by a comprehensive test suite covering all possible FHIR patterns.
 * StructureDefinition.fhirVersion: 4.0.1
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  BackboneElement,
  BooleanType,
  ChoiceDataTypes,
  ChoiceDataTypesMeta,
  CodeType,
  DateTimeType,
  DomainResource,
  EnumCodeType,
  FhirError,
  FhirParser,
  IBackboneElement,
  IDataType,
  IDomainResource,
  INSTANCE_EMPTY_ERROR_MSG,
  IResource,
  IntegerType,
  InvalidTypeError,
  JSON,
  PrimitiveType,
  PrimitiveTypeJson,
  REQUIRED_PROPERTIES_DO_NOT_EXIST,
  REQUIRED_PROPERTIES_REQD_IN_JSON,
  ReferenceTargets,
  StringType,
  UriType,
  assertEnumCodeType,
  assertEnumCodeTypeList,
  assertFhirResourceType,
  assertFhirType,
  assertFhirTypeList,
  assertIsDefined,
  assertIsDefinedList,
  constructorCodeValueAsEnumCodeType,
  constructorCodeValueAsEnumCodeTypeList,
  copyListValues,
  fhirBoolean,
  fhirBooleanSchema,
  fhirCode,
  fhirCodeSchema,
  fhirDateTime,
  fhirDateTimeSchema,
  fhirInteger,
  fhirIntegerSchema,
  fhirString,
  fhirStringSchema,
  getPrimitiveTypeJson,
  getPrimitiveTypeListJson,
  isDefined,
  isDefinedList,
  isElementEmpty,
  isEmpty,
  parseFhirPrimitiveData,
  setFhirBackboneElementJson,
  setFhirBackboneElementListJson,
  setFhirComplexJson,
  setFhirComplexListJson,
  setFhirPrimitiveJson,
  setFhirPrimitiveListJson,
  setFhirResourceJson,
  setPolymorphicValueJson,
} from '@paq-ts-fhir/fhir-core';
import { Address, Dosage, HumanName, PARSABLE_DATATYPE_MAP, Period, Quantity, Range, Reference } from '../complex-types/complex-datatypes';
import { ConsentStateCodesEnum } from '../code-systems/ConsentStateCodesEnum';
import { ContributorTypeEnum } from '../code-systems/ContributorTypeEnum';
import { PARSABLE_RESOURCE_MAP } from './parsable-resource-map';
import { TaskCodeEnum } from '../code-systems/TaskCodeEnum';
import { TaskStatusEnum } from '../code-systems/TaskStatusEnum';

// eslint-disable-next-line @typescript-eslint/no-explicit-any -- Symbol.metadata polyfill secret sauce for decorator metadata
(Symbol.metadata as any) ??= Symbol('Symbol.metadata');

/**
 * TestModel Class
 *
 * @remarks
 * Represents a FHIR data model for a custom FHIR StructureDefinition. This class will be tested by a comprehensive test suite covering all possible FHIR patterns.
 *
 * Provide a test (mock) data model that contains all possible FHIR patterns for data model elements representing all types of FHIR data types having each possible cardinality type. The BackboneElement classes will handle a subset of FHIR data types. This class includes choice and Resource data types along with nested BackboneElement data types.
 *
 * **FHIR Specification**
 * - **Short:** Test Data Model
 * - **Definition:** Represents a FHIR data model for a custom FHIR StructureDefinition. This class will be tested by a comprehensive test suite covering all possible FHIR patterns.
 * - **FHIR Version:** 4.0.1
 *
 * @category Data Models: Resource
 * @see [FHIR TestModel](https://test.ts-fhir-datamodels.com/StructureDefinition/TestModel)
 */
export class TestModel extends DomainResource implements IDomainResource {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided \`TestModel\` JSON to instantiate the TestModel data model.
   *
   * @param sourceJson - JSON representing FHIR \`TestModel\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to TestModel
   * @returns TestModel data model or undefined for \`TestModel\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static override parse(sourceJson: JSON.Value, optSourceField?: string): TestModel | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'TestModel';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new TestModel();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.verifyResourceType(classJsonObj, 'TestModel');
    fhirParser.processDomainResourceJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';

    const classMetadata: DecoratorMetadataObject | null = TestModel[Symbol.metadata];
    const errorMessage = \`DecoratorMetadataObject does not exist for TestModel\`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    fieldName = 'choice01[x]';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const choice01: IDataType | undefined = fhirParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setChoice01(choice01);

    fieldName = 'resource01';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      const resource01: IResource | undefined = fhirParser.parseInlineResource(classJsonObj[fieldName], sourceField);
      instance.setResource01(resource01);
    }

    fieldName = 'primitive';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const componentJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      componentJsonArray.forEach((componentJson: JSON.Value, idx) => {
        const component: TestModelPrimitiveComponent | undefined = TestModelPrimitiveComponent.parse(componentJson, \`\${sourceField}[\${String(idx)}]\`);
        if (component !== undefined) {
          instance.addPrimitive(component);
        }
      });
    }

    fieldName = 'complex';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const component: TestModelComplexComponent | undefined = TestModelComplexComponent.parse(classJsonObj[fieldName]!, sourceField);
      instance.setComplex(component);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * TestModel.choice01[x] Element
   *
   * @decorator \`@ChoiceDataTypesMeta('TestModel.choice01[x]', ['Range','Quantity',]\`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** choice01
   * - **Definition:** choice01
   * - **Requirements:** Optional single \\'choice\\' data type supporting \\'Range\\' or \\'Quantity\\'
   * - **FHIR Types:**
   *     'Range',
   *     'Quantity',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  @ChoiceDataTypesMeta('TestModel.choice01[x]',[
    'Range',
    'Quantity',
  ])
  private choice01?: IDataType | undefined;

  /**
   * TestModel.resource01 Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** resource01
   * - **Definition:** resource01
   * - **Requirements:** Optional single \\'Resource\\' data type
   * - **FHIR Type:** \`Resource\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private resource01?: IResource | undefined;

  /**
   * TestModel.primitive Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** BackboneElement containing primitive datatype patterns
   * - **Definition:** BackboneElement containing primitive datatype patterns
   * - **Requirements:** Optional list of TestModelPrimitiveComponent \\'BackboneElement\\'
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private primitive?: TestModelPrimitiveComponent[] | undefined;

  /**
   * TestModel.complex Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** BackboneElement containing complex datatype patterns
   * - **Definition:** BackboneElement containing complex datatype patterns
   * - **Requirements:** Optional single TestModelComplexComponent \\'BackboneElement\\'
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private complex?: TestModelComplexComponent | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`choice01\` property value as a DataType object if defined; else undefined
   */
  public getChoice01(): IDataType | undefined {
    return this.choice01;
  }

  /**
   * Assigns the provided DataType object value to the \`choice01\` property.
   *
   * @decorator \`@ChoiceDataTypes('TestModel.choice01[x]')\`
   *
   * @param value - the \`choice01\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  @ChoiceDataTypes('TestModel.choice01[x]')
  public setChoice01(value: IDataType | undefined): this {
    if (isDefined<IDataType>(value)) {
      // assertFhirType<IDataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.choice01 = value;
    } else {
      this.choice01 = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`choice01\` property exists and has a value; \`false\` otherwise
   */
  public hasChoice01(): boolean {
    return isDefined<IDataType>(this.choice01) && !this.choice01.isEmpty();
  }

  // *** NOTE ***
  // Following choice datatype-specific "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the \`choice01\` property value as a Range object if defined; else undefined
   */
  public getChoice01Range(): Range | undefined {
    if (!isDefined<IDataType | undefined>(this.choice01)) {
      return undefined;
    }
    if (!(this.choice01 instanceof Range)) {
      throw new InvalidTypeError(
        \`DataType mismatch for TestModel.choice01[x]: Expected Range but encountered \${this.choice01.fhirType()}\`,
      );
    }
    return this.choice01;
  }

  /**
   * @returns \`true\` if the \`choice01\` property exists as a Range and has a value; \`false\` otherwise
   */
  public hasChoice01Range(): boolean {
    return this.hasChoice01() && this.choice01 instanceof Range;
  }

  /**
   * @returns the \`choice01\` property value as a Quantity object if defined; else undefined
   */
  public getChoice01Quantity(): Quantity | undefined {
    if (!isDefined<IDataType | undefined>(this.choice01)) {
      return undefined;
    }
    if (!(this.choice01 instanceof Quantity)) {
      throw new InvalidTypeError(
        \`DataType mismatch for TestModel.choice01[x]: Expected Quantity but encountered \${this.choice01.fhirType()}\`,
      );
    }
    return this.choice01;
  }

  /**
   * @returns \`true\` if the \`choice01\` property exists as a Quantity and has a value; \`false\` otherwise
   */
  public hasChoice01Quantity(): boolean {
    return this.hasChoice01() && this.choice01 instanceof Quantity;
  }

  // End of choice datatype-specific "get"/"has" methods

  /**
   * @returns the \`resource01\` property value as a Resource object if defined; else undefined
   */
  public getResource01(): IResource | undefined {
    return this.resource01;
  }

  /**
   * Assigns the provided Resource object value to the \`resource01\` property.
   *
   * @param value - the \`resource01\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid resource type
   */
  public setResource01(value: IResource | undefined): this {
    if (isDefined<IResource>(value)) {
      const optErrMsg = \`Invalid TestModel.resource01; Provided element is not an instance of Resource.\`;
      assertFhirResourceType(value, optErrMsg);
      this.resource01 = value;
    } else {
      this.resource01 = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`resource01\` property exists and has a value; \`false\` otherwise
   */
  public hasResource01(): boolean {
    return isDefined<IResource>(this.resource01) && !this.resource01.isEmpty();
  }

  /**
   * @returns the \`primitive\` property value as a TestModelPrimitiveComponent array
   */
  public getPrimitive(): TestModelPrimitiveComponent[] {
    return this.primitive ?? ([] as TestModelPrimitiveComponent[]);
  }

  /**
   * Assigns the provided TestModelPrimitiveComponent array value to the \`primitive\` property.
   *
   * @param value - the \`primitive\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setPrimitive(value: TestModelPrimitiveComponent[] | undefined): this {
    if (isDefinedList<TestModelPrimitiveComponent>(value)) {
      const optErrMsg = \`Invalid TestModel.primitive; Provided value array has an element that is not an instance of TestModelPrimitiveComponent.\`;
      assertFhirTypeList<TestModelPrimitiveComponent>(value, TestModelPrimitiveComponent, optErrMsg);
      this.primitive = value;
    } else {
      this.primitive = undefined;
    }
    return this;
  }

  /**
   * Add the provided TestModelPrimitiveComponent value to the \`primitive\` array property.
   *
   * @param value - the \`primitive\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addPrimitive(value: TestModelPrimitiveComponent | undefined): this {
    if (isDefined<TestModelPrimitiveComponent>(value)) {
      const optErrMsg = \`Invalid TestModel.primitive; Provided element is not an instance of TestModelPrimitiveComponent.\`;
      assertFhirType<TestModelPrimitiveComponent>(value, TestModelPrimitiveComponent, optErrMsg);
      this.initPrimitive();
      this.primitive?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`primitive\` property exists and has a value; \`false\` otherwise
   */
  public hasPrimitive(): boolean {
    return isDefinedList<TestModelPrimitiveComponent>(this.primitive) && this.primitive.some((item: TestModelPrimitiveComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`primitive\` property
   */
  private initPrimitive(): void {
    if(!this.hasPrimitive()) {
      this.primitive = [] as TestModelPrimitiveComponent[];
    }
  }

  /**
   * @returns the \`complex\` property value as a TestModelComplexComponent object if defined; else an empty TestModelComplexComponent object
   */
  public getComplex(): TestModelComplexComponent {
    return this.complex ?? new TestModelComplexComponent();
  }

  /**
   * Assigns the provided Complex object value to the \`complex\` property.
   *
   * @param value - the \`complex\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setComplex(value: TestModelComplexComponent | undefined): this {
    if (isDefined<TestModelComplexComponent>(value)) {
      const optErrMsg = \`Invalid TestModel.complex; Provided element is not an instance of TestModelComplexComponent.\`;
      assertFhirType<TestModelComplexComponent>(value, TestModelComplexComponent, optErrMsg);
      this.complex = value;
    } else {
      this.complex = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`complex\` property exists and has a value; \`false\` otherwise
   */
  public hasComplex(): boolean {
    return isDefined<TestModelComplexComponent>(this.complex) && !this.complex.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'TestModel';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.choice01,
      this.resource01,
      this.primitive,
      this.complex,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): TestModel {
    const dest = new TestModel();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: TestModel): void {
    super.copyValues(dest);
    dest.choice01 = this.choice01?.copy() as IDataType;
    dest.resource01 = this.resource01?.copy() as IResource;
    const primitiveList = copyListValues<TestModelPrimitiveComponent>(this.primitive);
    dest.primitive = primitiveList.length === 0 ? undefined : primitiveList;
    dest.complex = this.complex?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasChoice01()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getChoice01()!, 'choice01', jsonObj);
    }

    if (this.hasResource01()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirResourceJson(this.getResource01()!, 'resource01', jsonObj);
    }

    if (this.hasPrimitive()) {
      setFhirBackboneElementListJson(this.getPrimitive(), 'primitive', jsonObj);
    }

    if (this.hasComplex()) {
      setFhirBackboneElementJson(this.getComplex(), 'complex', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * TestModelPrimitiveComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** BackboneElement containing primitive datatype patterns
 * - **Definition:** BackboneElement containing primitive datatype patterns
 * - **Requirements:** Optional list of TestModelPrimitiveComponent \\'BackboneElement\\'
 *
 * @category Data Models: Resource
 * @see [FHIR TestModel](https://test.ts-fhir-datamodels.com/StructureDefinition/TestModel)
 */
export class TestModelPrimitiveComponent extends BackboneElement implements IBackboneElement {
  constructor(primitive11: BooleanType | fhirBoolean | null = null, primitive1x: StringType[] | fhirString[] | null = null, choice11: IDataType | null = null) {
    super();

    this.primitive11 = null;
    if (isDefined<BooleanType | fhirBoolean>(primitive11)) {
      if (primitive11 instanceof PrimitiveType) {
        this.setPrimitive11Element(primitive11);
      } else {
        this.setPrimitive11(primitive11);
      }
    }

    this.primitive1x = null;
    if (isDefinedList<StringType | fhirString>(primitive1x)) {
      if (primitive1x[0] instanceof PrimitiveType) {
        this.setPrimitive1xElement(primitive1x as StringType[]);
      } else {
        this.setPrimitive1x(primitive1x as fhirString[]);
      }
    }

    this.choice11 = null;
    if (isDefined<IDataType>(choice11)) {
      this.setChoice11(choice11);
    }

  }

  /**
   * Parse the provided \`TestModelPrimitiveComponent\` JSON to instantiate the TestModelPrimitiveComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`TestModelPrimitiveComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to TestModelPrimitiveComponent
   * @returns TestModelPrimitiveComponent data model or undefined for \`TestModelPrimitiveComponent\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): TestModelPrimitiveComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'TestModelPrimitiveComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new TestModelPrimitiveComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const classMetadata: DecoratorMetadataObject | null = TestModelPrimitiveComponent[Symbol.metadata];
    const errorMessage = \`DecoratorMetadataObject does not exist for TestModelPrimitiveComponent\`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    const missingReqdProperties: string[] = [];

    fieldName = 'primitive01';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DateTimeType | undefined = fhirParser.parseDateTimeType(dtJson, dtSiblingJson);
      instance.setPrimitive01Element(datatype);
    }

    fieldName = 'primitive0x';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: IntegerType | undefined = fhirParser.parseIntegerType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addPrimitive0xElement(datatype);
        }
      });
    }

    fieldName = 'primitive11';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'boolean';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: BooleanType | undefined = fhirParser.parseBooleanType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setPrimitive11Element(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'primitive1x';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson, idx) => {
        const datatype: StringType | undefined = fhirParser.parseStringType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype === undefined) {
          missingReqdProperties.push(\`\${sourceField}[\${String(idx)}]\`);
        } else {
          instance.addPrimitive1xElement(datatype);
        }
      });
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'choice11[x]';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    const choice11: IDataType | undefined = fhirParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    if (choice11 === undefined) {
      missingReqdProperties.push(sourceField);
    } else {
      instance.setChoice11(choice11);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * TestModel.primitive.primitive01 Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** primitive01
   * - **Definition:** primitive01
   * - **Requirements:** Optional single \\'dateTime\\' data type
   * - **FHIR Type:** \`dateTime\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private primitive01?: DateTimeType | undefined;

  /**
   * TestModel.primitive.primitive0x Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** primitive0x
   * - **Definition:** primitive0x
   * - **Requirements:** Optional list of \\'integer\\' data type
   * - **FHIR Type:** \`integer\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private primitive0x?: IntegerType[] | undefined;

  /**
   * TestModel.primitive.primitive11 Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** primitive11
   * - **Definition:** primitive11
   * - **Requirements:** Required single \\'boolean\\' data type
   * - **FHIR Type:** \`boolean\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private primitive11: BooleanType | null;

  /**
   * TestModel.primitive.primitive1x Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** primitive1x
   * - **Definition:** primitive1x
   * - **Requirements:** Required list of \\'string\\' data type
   * - **FHIR Type:** \`string\`
   * - **Cardinality:** 1..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private primitive1x: StringType[] | null;

  /**
   * TestModel.primitive.choice11[x] Element
   *
   * @decorator \`@ChoiceDataTypesMeta('TestModel.primitive.choice11[x]', ['uri','string',]\`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** choice11
   * - **Definition:** choice11
   * - **Requirements:** Required single \\'choice\\' data type supporting \\'uri\\' or \\'string\\'
   * - **FHIR Types:**
   *     'uri',
   *     'string',
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  @ChoiceDataTypesMeta('TestModel.primitive.choice11[x]',[
    'uri',
    'string',
  ])
  private choice11: IDataType | null;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`primitive01\` property value as a DateTimeType object if defined; else an empty DateTimeType object
   */
  public getPrimitive01Element(): DateTimeType {
    return this.primitive01 ?? new DateTimeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the \`primitive01\` property.
   *
   * @param element - the \`primitive01\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPrimitive01Element(element: DateTimeType | undefined): this {
    if (isDefined<DateTimeType>(element)) {
      const optErrMsg = \`Invalid TestModel.primitive.primitive01; Provided element is not an instance of DateTimeType.\`;
      assertFhirType<DateTimeType>(element, DateTimeType, optErrMsg);
      this.primitive01 = element;
    } else {
      this.primitive01 = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`primitive01\` property exists and has a value; \`false\` otherwise
   */
  public hasPrimitive01Element(): boolean {
    return isDefined<DateTimeType>(this.primitive01) && !this.primitive01.isEmpty();
  }

  /**
   * @returns the \`primitive01\` property value as a fhirDateTime if defined; else undefined
   */
  public getPrimitive01(): fhirDateTime | undefined {
    return this.primitive01?.getValue();
  }

  /**
   * Assigns the provided primitive value to the \`primitive01\` property.
   *
   * @param value - the \`primitive01\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPrimitive01(value: fhirDateTime | undefined): this {
    if (isDefined<fhirDateTime>(value)) {
      const optErrMsg = \`Invalid TestModel.primitive.primitive01 (\${String(value)})\`;
      this.primitive01 = new DateTimeType(parseFhirPrimitiveData(value, fhirDateTimeSchema, optErrMsg));
    } else {
      this.primitive01 = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`primitive01\` property exists and has a value; \`false\` otherwise
   */
  public hasPrimitive01(): boolean {
    return this.hasPrimitive01Element();
  }

  /**
   * @returns the \`primitive0x\` property value as a IntegerType array
   */
  public getPrimitive0xElement(): IntegerType[] {
    return this.primitive0x ?? ([] as IntegerType[]);
  }

  /**
   * Assigns the provided IntegerType array value to the \`primitive0x\` property.
   *
   * @param element - the \`primitive0x\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPrimitive0xElement(element: IntegerType[] | undefined): this {
    if (isDefinedList<IntegerType>(element)) {
      const optErrMsg = \`Invalid TestModel.primitive.primitive0x; Provided value array has an element that is not an instance of IntegerType.\`;
      assertFhirTypeList<IntegerType>(element, IntegerType, optErrMsg);
      this.primitive0x = element;
    } else {
      this.primitive0x = undefined;
    }
    return this;
  }

  /**
   * Add the provided IntegerType value to the \`primitive0x\` array property.
   *
   * @param element - the \`primitive0x\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addPrimitive0xElement(element: IntegerType | undefined): this {
    if (isDefined<IntegerType>(element)) {
      const optErrMsg = \`Invalid TestModel.primitive.primitive0x; Provided element is not an instance of IntegerType.\`;
      assertFhirType<IntegerType>(element, IntegerType, optErrMsg);
      this.initPrimitive0x();
      this.primitive0x?.push(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`primitive0x\` property exists and has a value; \`false\` otherwise
   */
  public hasPrimitive0xElement(): boolean {
    return isDefinedList<IntegerType>(this.primitive0x) && this.primitive0x.some((item: IntegerType) => !item.isEmpty());
  }

  /**
   * @returns the \`primitive0x\` property value as a fhirInteger array
   */
  public getPrimitive0x(): fhirInteger[] {
    this.initPrimitive0x();
    const primitive0xValues = [] as fhirInteger[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.primitive0x!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        primitive0xValues.push(value);
      }
    }
    return primitive0xValues;
  }

  /**
   * Assigns the provided primitive value array to the \`primitive0x\` property.
   *
   * @param value - the \`primitive0x\` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPrimitive0x(value: fhirInteger[] | undefined): this {
    if (isDefinedList<fhirInteger>(value)) {
      const primitive0xElements = [] as IntegerType[];
      for (const primitive0xValue of value) {
        const optErrMsg = \`Invalid TestModel.primitive.primitive0x array item (\${String(primitive0xValue)})\`;
        const element = new IntegerType(parseFhirPrimitiveData(primitive0xValue, fhirIntegerSchema, optErrMsg));
        primitive0xElements.push(element);
      }
      this.primitive0x = primitive0xElements;
    } else {
      this.primitive0x = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`primitive0x\` array property.
   *
   * @param value - the \`primitive0x\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addPrimitive0x(value: fhirInteger | undefined): this {
    if (isDefined<fhirInteger>(value)) {
      const optErrMsg = \`Invalid TestModel.primitive.primitive0x array item (\${String(value)})\`;
      const element = new IntegerType(parseFhirPrimitiveData(value, fhirIntegerSchema, optErrMsg));
      this.initPrimitive0x();
      this.addPrimitive0xElement(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`primitive0x\` property exists and has a value; \`false\` otherwise
   */
  public hasPrimitive0x(): boolean {
    return this.hasPrimitive0xElement();
  }

  /**
   * Initialize the \`primitive0x\` property
   */
  private initPrimitive0x(): void {
    if (!this.hasPrimitive0x()) {
      this.primitive0x = [] as IntegerType[];
    }
  }

  /**
   * @returns the \`primitive11\` property value as a BooleanType object if defined; else null
   */
  public getPrimitive11Element(): BooleanType | null {
    return this.primitive11;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`primitive11\` property.
   *
   * @param element - the \`primitive11\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPrimitive11Element(element: BooleanType): this {
    assertIsDefined<BooleanType>(element, \`TestModel.primitive.primitive11 is required\`);
    const optErrMsg = \`Invalid TestModel.primitive.primitive11; Provided value is not an instance of BooleanType.\`;
    assertFhirType<BooleanType>(element, BooleanType, optErrMsg);
    this.primitive11 = element;
    return this;
  }

  /**
   * @returns \`true\` if the \`primitive11\` property exists and has a value; \`false\` otherwise
   */
  public hasPrimitive11Element(): boolean {
    return isDefined<BooleanType>(this.primitive11) && !this.primitive11.isEmpty();
  }

  /**
   * @returns the \`primitive11\` property value as a fhirBoolean if defined; else null
   */
  public getPrimitive11(): fhirBoolean | null {
    if (this.primitive11?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.primitive11.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the \`primitive11\` property.
   *
   * @param value - the \`primitive11\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPrimitive11(value: fhirBoolean): this {
    assertIsDefined<fhirBoolean>(value, \`TestModel.primitive.primitive11 is required\`);
    const optErrMsg = \`Invalid TestModel.primitive.primitive11 (\${String(value)})\`;
    this.primitive11 = new BooleanType(parseFhirPrimitiveData(value, fhirBooleanSchema, optErrMsg));
    return this;
  }

  /**
   * @returns \`true\` if the \`primitive11\` property exists and has a value; \`false\` otherwise
   */
  public hasPrimitive11(): boolean {
    return this.hasPrimitive11Element();
  }

  /**
   * @returns the \`primitive1x\` property value as a StringType array
   */
  public getPrimitive1xElement(): StringType[] {
    return this.primitive1x ?? ([] as StringType[]);
  }

  /**
   * Assigns the provided StringType array value to the \`primitive1x\` property.
   *
   * @param element - the \`primitive1x\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPrimitive1xElement(element: StringType[]): this {
    assertIsDefinedList<StringType>(element, \`TestModel.primitive.primitive1x is required\`);
    const optErrMsg = \`Invalid TestModel.primitive.primitive1x; Provided value array has an element that is not an instance of StringType.\`;
    assertFhirTypeList<StringType>(element, StringType, optErrMsg);
    this.primitive1x = element;
    return this;
  }

  /**
   * Add the provided StringType value to the \`primitive1x\` array property.
   *
   * @param element - the \`primitive1x\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addPrimitive1xElement(element: StringType): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = \`Invalid TestModel.primitive.primitive1x; Provided element is not an instance of StringType.\`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.initPrimitive1x();
      this.primitive1x?.push(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`primitive1x\` property exists and has a value; \`false\` otherwise
   */
  public hasPrimitive1xElement(): boolean {
    return isDefinedList<StringType>(this.primitive1x) && this.primitive1x.some((item: StringType) => !item.isEmpty());
  }

  /**
   * @returns the \`primitive1x\` property value as a fhirString array
   */
  public getPrimitive1x(): fhirString[] {
    this.initPrimitive1x();
    const primitive1xValues = [] as fhirString[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.primitive1x!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        primitive1xValues.push(value);
      }
    }
    return primitive1xValues;
  }

  /**
   * Assigns the provided primitive value array to the \`primitive1x\` property.
   *
   * @param value - the \`primitive1x\` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPrimitive1x(value: fhirString[]): this {
    assertIsDefinedList<fhirString>(value, \`TestModel.primitive.primitive1x is required\`);
    const primitive1xElements = [] as StringType[];
    for (const primitive1xValue of value) {
      const optErrMsg = \`Invalid TestModel.primitive.primitive1x array item (\${String(primitive1xValue)})\`;
      const element = new StringType(parseFhirPrimitiveData(primitive1xValue, fhirStringSchema, optErrMsg));
      primitive1xElements.push(element);
    }
    this.primitive1x = primitive1xElements;
    return this;
  }

  /**
   * Add the provided primitive value to the \`primitive1x\` array property.
   *
   * @param value - the \`primitive1x\` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addPrimitive1x(value: fhirString): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = \`Invalid TestModel.primitive.primitive1x array item (\${String(value)})\`;
      const element = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
      this.initPrimitive1x();
      this.addPrimitive1xElement(element);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`primitive1x\` property exists and has a value; \`false\` otherwise
   */
  public hasPrimitive1x(): boolean {
    return this.hasPrimitive1xElement();
  }

  /**
   * Initialize the \`primitive1x\` property
   */
  private initPrimitive1x(): void {
    if (!this.hasPrimitive1x()) {
      this.primitive1x = [] as StringType[];
    }
  }

  /**
   * @returns the \`choice11\` property value as a DataType object; else null
   */
  public getChoice11(): IDataType | null {
    return this.choice11;
  }

  /**
   * Assigns the provided DataType object value to the \`choice11\` property.
   *
   * @decorator \`@ChoiceDataTypes('TestModel.primitive.choice11[x]')\`
   *
   * @param value - the \`choice11\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  @ChoiceDataTypes('TestModel.primitive.choice11[x]')
  public setChoice11(value: IDataType): this {
    assertIsDefined<IDataType>(value, \`TestModel.primitive.choice11[x] is required\`);
    // assertFhirType<IDataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
    this.choice11 = value;
    return this;
  }

  /**
   * @returns \`true\` if the \`choice11\` property exists and has a value; \`false\` otherwise
   */
  public hasChoice11(): boolean {
    return isDefined<IDataType>(this.choice11) && !this.choice11.isEmpty();
  }

  // *** NOTE ***
  // Following choice datatype-specific "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the \`choice11\` property value as a UriType object if defined; else null
   */
  public getChoice11UriType(): UriType | null {
    if (!isDefined<IDataType>(this.choice11)) {
      return null;
    }
    if (!(this.choice11 instanceof UriType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for TestModel.primitive.choice11[x]: Expected UriType but encountered \${this.choice11.fhirType()}\`,
      );
    }
    return this.choice11;
  }

  /**
   * @returns \`true\` if the \`\` property exists as a UriType and has a value; \`false\` otherwise
   */
  public hasChoice11UriType(): boolean {
    return this.hasChoice11() && this.choice11 instanceof UriType;
  }

  /**
   * @returns the \`choice11\` property value as a StringType object if defined; else null
   */
  public getChoice11StringType(): StringType | null {
    if (!isDefined<IDataType>(this.choice11)) {
      return null;
    }
    if (!(this.choice11 instanceof StringType)) {
      throw new InvalidTypeError(
        \`DataType mismatch for TestModel.primitive.choice11[x]: Expected StringType but encountered \${this.choice11.fhirType()}\`,
      );
    }
    return this.choice11;
  }

  /**
   * @returns \`true\` if the \`\` property exists as a StringType and has a value; \`false\` otherwise
   */
  public hasChoice11StringType(): boolean {
    return this.hasChoice11() && this.choice11 instanceof StringType;
  }

  // End of choice datatype-specific "get"/"has" methods

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'TestModel.primitive';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.primitive01,
      this.primitive0x,
      this.primitive11,
      this.primitive1x,
      this.choice11,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): TestModelPrimitiveComponent {
    const dest = new TestModelPrimitiveComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: TestModelPrimitiveComponent): void {
    super.copyValues(dest);
    dest.primitive01 = this.primitive01?.copy();
    const primitive0xList = copyListValues<IntegerType>(this.primitive0x);
    dest.primitive0x = primitive0xList.length === 0 ? undefined : primitive0xList;
    dest.primitive11 = this.primitive11 ? this.primitive11.copy() : null;
    const primitive1xList = copyListValues<StringType>(this.primitive1x);
    dest.primitive1x = primitive1xList.length === 0 ? null : primitive1xList;
    dest.choice11 = this.choice11 ? this.choice11.copy() as IDataType : null;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasPrimitive01Element()) {
      setFhirPrimitiveJson<fhirDateTime>(this.getPrimitive01Element(), 'primitive01', jsonObj);
    }

    if (this.hasPrimitive0x()) {
      setFhirPrimitiveListJson(this.getPrimitive0xElement(), 'primitive0x', jsonObj);
    }

    if (this.hasPrimitive11Element()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirBoolean>(this.getPrimitive11Element()!, 'primitive11', jsonObj);
    } else {
      missingReqdProperties.push(\`TestModel.primitive.primitive11\`);
    }

    if (this.hasPrimitive1xElement()) {
      setFhirPrimitiveListJson(this.getPrimitive1xElement(), 'primitive1x', jsonObj);
    } else {
      missingReqdProperties.push(\`TestModel.primitive.primitive1x\`);
    }

    if (this.hasChoice11()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getChoice11()!, 'choice11', jsonObj);
    } else {
      missingReqdProperties.push(\`TestModel.primitive.choice11[x]\`);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
/**
 * TestModelComplexComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** BackboneElement containing complex datatype patterns
 * - **Definition:** BackboneElement containing complex datatype patterns
 * - **Requirements:** Optional single TestModelComplexComponent \\'BackboneElement\\'
 *
 * @category Data Models: Resource
 * @see [FHIR TestModel](https://test.ts-fhir-datamodels.com/StructureDefinition/TestModel)
 */
export class TestModelComplexComponent extends BackboneElement implements IBackboneElement {
  constructor(complex11: Dosage | null = null, complex1x: Period[] | null = null, reference: TestModelComplexReferenceComponent | null = null) {
    super();

    this.complex11 = null;
    if (isDefined<Dosage>(complex11)) {
      this.setComplex11(complex11);
    }

    this.complex1x = null;
    if (isDefinedList<Period>(complex1x)) {
      this.setComplex1x(complex1x);
    }

    this.reference = null;
    if (isDefined<TestModelComplexReferenceComponent>(reference)) {
      this.setReference(reference);
    }
  }

  /**
   * Parse the provided \`TestModelComplexComponent\` JSON to instantiate the TestModelComplexComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`TestModelComplexComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to TestModelComplexComponent
   * @returns TestModelComplexComponent data model or undefined for \`TestModelComplexComponent\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): TestModelComplexComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'TestModelComplexComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new TestModelComplexComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';

    const missingReqdProperties: string[] = [];

    fieldName = 'complex01';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: HumanName | undefined = HumanName.parse(classJsonObj[fieldName]!, sourceField);
      instance.setComplex01(datatype);
    }

    fieldName = 'complex0x';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Address | undefined = Address.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addComplex0x(datatype);
        }
      });
    }

    fieldName = 'complex11';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Dosage | undefined = Dosage.parse(classJsonObj[fieldName]!, sourceField);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setComplex11(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'complex1x';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Period | undefined = Period.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype === undefined) {
          missingReqdProperties.push(\`\${sourceField}[\${String(idx)}]\`);
        } else {
          instance.addComplex1x(datatype);
        }
      });
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'reference';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const component: TestModelComplexReferenceComponent | undefined = TestModelComplexReferenceComponent.parse(classJsonObj[fieldName]!, sourceField);
      if (component === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setReference(component);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * TestModel.complex.complex01 Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** complex01
   * - **Definition:** complex01
   * - **Requirements:** Optional single \\'HumanName\\' data type
   * - **FHIR Type:** \`HumanName\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private complex01?: HumanName | undefined;

  /**
   * TestModel.complex.complex0x Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** complex0x
   * - **Definition:** complex0x
   * - **Requirements:** Optional list of \\'Address\\' data type
   * - **FHIR Type:** \`Address\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private complex0x?: Address[] | undefined;

  /**
   * TestModel.complex.complex11 Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** complex11
   * - **Definition:** complex11
   * - **Requirements:** Required single \\'Dosage\\' data type
   * - **FHIR Type:** \`Dosage\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private complex11: Dosage | null;

  /**
   * TestModel.complex.complex1x Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** complex1x
   * - **Definition:** complex1x
   * - **Requirements:** Required list of \\'Period\\' data type
   * - **FHIR Type:** \`Period\`
   * - **Cardinality:** 1..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private complex1x: Period[] | null;

  /**
   * TestModel.complex.reference Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** BackboneElement containing reference datatype patterns
   * - **Definition:** BackboneElement containing reference datatype patterns
   * - **Requirements:** Required single TestModelComplexReferenceComponent \\'BackboneElement\\'
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private reference: TestModelComplexReferenceComponent | null;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`complex01\` property value as a HumanName object if defined; else an empty HumanName object
   */
  public getComplex01(): HumanName {
    return this.complex01 ?? new HumanName();
  }

  /**
   * Assigns the provided Complex01 object value to the \`complex01\` property.
   *
   * @param value - the \`complex01\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setComplex01(value: HumanName | undefined): this {
    if (isDefined<HumanName>(value)) {
      const optErrMsg = \`Invalid TestModel.complex.complex01; Provided element is not an instance of HumanName.\`;
      assertFhirType<HumanName>(value, HumanName, optErrMsg);
      this.complex01 = value;
    } else {
      this.complex01 = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`complex01\` property exists and has a value; \`false\` otherwise
   */
  public hasComplex01(): boolean {
    return isDefined<HumanName>(this.complex01) && !this.complex01.isEmpty();
  }

  /**
   * @returns the \`complex0x\` property value as a Address array
   */
  public getComplex0x(): Address[] {
    return this.complex0x ?? ([] as Address[]);
  }

  /**
   * Assigns the provided Address array value to the \`complex0x\` property.
   *
   * @param value - the \`complex0x\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setComplex0x(value: Address[] | undefined): this {
    if (isDefinedList<Address>(value)) {
      const optErrMsg = \`Invalid TestModel.complex.complex0x; Provided value array has an element that is not an instance of Address.\`;
      assertFhirTypeList<Address>(value, Address, optErrMsg);
      this.complex0x = value;
    } else {
      this.complex0x = undefined;
    }
    return this;
  }

  /**
   * Add the provided Address value to the \`complex0x\` array property.
   *
   * @param value - the \`complex0x\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addComplex0x(value: Address | undefined): this {
    if (isDefined<Address>(value)) {
      const optErrMsg = \`Invalid TestModel.complex.complex0x; Provided element is not an instance of Address.\`;
      assertFhirType<Address>(value, Address, optErrMsg);
      this.initComplex0x();
      this.complex0x?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`complex0x\` property exists and has a value; \`false\` otherwise
   */
  public hasComplex0x(): boolean {
    return isDefinedList<Address>(this.complex0x) && this.complex0x.some((item: Address) => !item.isEmpty());
  }

  /**
   * Initialize the \`complex0x\` property
   */
  private initComplex0x(): void {
    if(!this.hasComplex0x()) {
      this.complex0x = [] as Address[];
    }
  }

  /**
   * @returns the \`complex11\` property value as a Dosage object if defined; else null
   */
  public getComplex11(): Dosage | null {
    return this.complex11;
  }

  /**
   * Assigns the provided Dosage object value to the \`complex11\` property.
   *
   * @param value - the \`complex11\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setComplex11(value: Dosage): this {
    assertIsDefined<Dosage>(value, \`TestModel.complex.complex11 is required\`);
    const optErrMsg = \`Invalid TestModel.complex.complex11; Provided element is not an instance of Dosage.\`;
    assertFhirType<Dosage>(value, Dosage, optErrMsg);
    this.complex11 = value;
    return this;
  }

  /**
   * @returns \`true\` if the \`complex11\` property exists and has a value; \`false\` otherwise
   */
  public hasComplex11(): boolean {
    return isDefined<Dosage>(this.complex11) && !this.complex11.isEmpty();
  }

  /**
   * @returns the \`complex1x\` property value as a Period array
   */
  public getComplex1x(): Period[] {
    return this.complex1x ?? ([] as Period[]);
  }

  /**
   * Assigns the provided Period array value to the \`complex1x\` property.
   *
   * @param value - the \`complex1x\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setComplex1x(value: Period[]): this {
    assertIsDefinedList<Period>(value, \`TestModel.complex.complex1x is required\`);
    const optErrMsg = \`Invalid TestModel.complex.complex1x; Provided value array has an element that is not an instance of Period.\`;
    assertFhirTypeList<Period>(value, Period, optErrMsg);
    this.complex1x = value;
    return this;
  }

  /**
   * Add the provided Period value to the \`complex1x\` array property.
   *
   * @param value - the \`complex1x\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addComplex1x(value: Period | undefined): this {
    if (isDefined<Period>(value)) {
      const optErrMsg = \`Invalid TestModel.complex.complex1x; Provided element is not an instance of Period.\`;
      assertFhirType<Period>(value, Period, optErrMsg);
      this.initComplex1x();
      this.complex1x?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`complex1x\` property exists and has a value; \`false\` otherwise
   */
  public hasComplex1x(): boolean {
    return isDefinedList<Period>(this.complex1x) && this.complex1x.some((item: Period) => !item.isEmpty());
  }

  /**
   * Initialize the \`complex1x\` property
   */
  private initComplex1x(): void {
    if(!this.hasComplex1x()) {
      this.complex1x = [] as Period[];
    }
  }

  /**
   * @returns the \`reference\` property value as a TestModelComplexReferenceComponent object if defined; else null
   */
  public getReference(): TestModelComplexReferenceComponent | null {
    return this.reference;
  }

  /**
   * Assigns the provided TestModelComplexReferenceComponent object value to the \`reference\` property.
   *
   * @param value - the \`reference\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setReference(value: TestModelComplexReferenceComponent): this {
    assertIsDefined<TestModelComplexReferenceComponent>(value, \`TestModel.complex.reference is required\`);
    const optErrMsg = \`Invalid TestModel.complex.reference; Provided element is not an instance of TestModelComplexReferenceComponent.\`;
    assertFhirType<TestModelComplexReferenceComponent>(value, TestModelComplexReferenceComponent, optErrMsg);
    this.reference = value;
    return this;
  }

  /**
   * @returns \`true\` if the \`reference\` property exists and has a value; \`false\` otherwise
   */
  public hasReference(): boolean {
    return isDefined<TestModelComplexReferenceComponent>(this.reference) && !this.reference.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'TestModel.complex';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.complex01,
      this.complex0x,
      this.complex11,
      this.complex1x,
      this.reference,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): TestModelComplexComponent {
    const dest = new TestModelComplexComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: TestModelComplexComponent): void {
    super.copyValues(dest);
    dest.complex01 = this.complex01?.copy();
    const complex0xList = copyListValues<Address>(this.complex0x);
    dest.complex0x = complex0xList.length === 0 ? undefined : complex0xList;
    dest.complex11 = this.complex11 ? this.complex11.copy() : null;
    const complex1xList = copyListValues<Period>(this.complex1x);
    dest.complex1x = complex1xList.length === 0 ? null : complex1xList;
    dest.reference = this.reference ? this.reference.copy() : null;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasComplex01()) {
      setFhirComplexJson(this.getComplex01(), 'complex01', jsonObj);
    }

    if (this.hasComplex0x()) {
      setFhirComplexListJson(this.getComplex0x(), 'complex0x', jsonObj);
    }

    if (this.hasComplex11()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirComplexJson(this.getComplex11()!, 'complex11', jsonObj);
    } else {
      missingReqdProperties.push(\`TestModel.complex.complex11\`);
    }

    if (this.hasComplex1x()) {
      setFhirComplexListJson(this.getComplex1x(), 'complex1x', jsonObj);
    } else {
      missingReqdProperties.push(\`TestModel.complex.complex1x\`);
    }

    if (this.hasReference()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirBackboneElementJson(this.getReference()!, 'reference', jsonObj);
    } else {
      missingReqdProperties.push(\`TestModel.complex.reference\`);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
/**
 * TestModelComplexReferenceComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** BackboneElement containing reference datatype patterns
 * - **Definition:** BackboneElement containing reference datatype patterns
 * - **Requirements:** Required single TestModelComplexReferenceComponent \\'BackboneElement\\'
 *
 * @category Data Models: Resource
 * @see [FHIR TestModel](https://test.ts-fhir-datamodels.com/StructureDefinition/TestModel)
 */
export class TestModelComplexReferenceComponent extends BackboneElement implements IBackboneElement {
  constructor(reference11: Reference | null = null, reference1x: Reference[] | null = null, enumCode: TestModelComplexReferenceEnumCodeComponent[] | null = null) {
    super();

    this.reference11 = null;
    if (isDefined<Reference>(reference11)) {
      this.setReference11(reference11);
    }

    this.reference1x = null;
    if (isDefinedList<Reference>(reference1x)) {
      this.setReference1x(reference1x);
    }

    this.enumCode = null;
    if (isDefinedList<TestModelComplexReferenceEnumCodeComponent>(enumCode)) {
      this.setEnumCode(enumCode);
    }
  }

  /**
   * Parse the provided \`TestModelComplexReferenceComponent\` JSON to instantiate the TestModelComplexReferenceComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`TestModelComplexReferenceComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to TestModelComplexReferenceComponent
   * @returns TestModelComplexReferenceComponent data model or undefined for \`TestModelComplexReferenceComponent\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): TestModelComplexReferenceComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'TestModelComplexReferenceComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new TestModelComplexReferenceComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';

    const missingReqdProperties: string[] = [];

    fieldName = 'reference01';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = Reference.parse(classJsonObj[fieldName]!, sourceField);
      instance.setReference01(datatype);
    }

    fieldName = 'reference0x';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Reference | undefined = Reference.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype !== undefined) {
          instance.addReference0x(datatype);
        }
      });
  }

    fieldName = 'reference11';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = Reference.parse(classJsonObj[fieldName]!, sourceField);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setReference11(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'reference1x';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Reference | undefined = Reference.parse(dataElementJson, \`\${sourceField}[\${String(idx)}]\`);
        if (datatype === undefined) {
          missingReqdProperties.push(\`\${sourceField}[\${String(idx)}]\`);
        } else {
          instance.addReference1x(datatype);
        }
      });
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'enumCode';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const componentJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      componentJsonArray.forEach((componentJson: JSON.Value, idx) => {
        const component: TestModelComplexReferenceEnumCodeComponent | undefined = TestModelComplexReferenceEnumCodeComponent.parse(componentJson, \`\${sourceField}[\${String(idx)}]\`);
        if (component === undefined) {
          missingReqdProperties.push(\`\${sourceField}[\${String(idx)}]\`);
        } else {
          instance.addEnumCode(component);
        }
      });
    } else {
      missingReqdProperties.push(sourceField);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * TestModel.complex.reference.reference01 Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** reference.reference01
   * - **Definition:** reference.reference01
   * - **Requirements:** Optional single \\'Reference(any)\\' data type
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Location',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private reference01?: Reference | undefined;

  /**
   * TestModel.complex.reference.reference0x Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** reference.reference0x
   * - **Definition:** reference.reference0x
   * - **Requirements:** Optional list of \\'Reference(Practitioner or PractitionerRole or Organization)\\' data type
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Practitioner',
   *       'http://hl7.org/fhir/StructureDefinition/PractitionerRole',
   *       'http://hl7.org/fhir/StructureDefinition/Organization',
   *     ]
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private reference0x?: Reference[] | undefined;

  /**
   * TestModel.complex.reference.reference11 Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** reference.reference11
   * - **Definition:** reference.reference11
   * - **Requirements:** Required single \\'Reference(Patient or SimplePersonModel)\\' data type
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'https://test.ts-fhir-datamodels.com/StructureDefinition/SimplePersonModel',
   *     ]
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private reference11: Reference | null;

  /**
   * TestModel.complex.reference.reference1x Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** reference.reference1x
   * - **Definition:** reference.reference1x
   * - **Requirements:** Required list of \\'Reference(Condition)\\' data type
   * - **FHIR Type:** \`Reference\`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/HealthcareService',
   *     ]
   * - **Cardinality:** 1..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private reference1x: Reference[] | null;

  /**
   * TestModel.complex.reference.enumCode Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** BackboneElement containing EnumCode datatype patterns
   * - **Definition:** BackboneElement containing EnumCode datatype patterns
   * - **Requirements:** Required list of TestModelComplexReferenceEnumCodeComponent \\'BackboneElement\\'
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 1..*
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private enumCode: TestModelComplexReferenceEnumCodeComponent[] | null;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`reference01\` property value as a Reference object; else an empty Reference object
   */
  public getReference01(): Reference {
    return this.reference01 ?? new Reference();
  }

  /**
   * Assigns the provided Reference01 object value to the \`reference01\` property.
   *
   * @decorator \`@ReferenceTargets('TestModel.complex.reference.reference01', ['Location',])\`
   *
   * @param value - the \`reference01\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('TestModel.complex.reference.reference01', [
    'Location',
  ])
  public setReference01(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.reference01 = value;
    } else {
      this.reference01 = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`reference01\` property exists and has a value; \`false\` otherwise
   */
  public hasReference01(): boolean {
    return isDefined<Reference>(this.reference01) && !this.reference01.isEmpty();
  }

  /**
   * @returns the \`reference0x\` property value as a Reference array
   */
  public getReference0x(): Reference[] {
    return this.reference0x ?? ([] as Reference[]);
  }

  /**
   * Assigns the provided Reference array value to the \`reference0x\` property.
   *
   * @decorator \`@ReferenceTargets('TestModel.complex.reference.reference0x', ['Practitioner','PractitionerRole','Organization',])\`
   *
   * @param value - the \`reference0x\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('TestModel.complex.reference.reference0x', [
    'Practitioner',
  
    'PractitionerRole',
  
    'Organization',
  ])
  public setReference0x(value: Reference[] | undefined): this {
    if (isDefinedList<Reference>(value)) {
      // assertFhirTypeList<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.reference0x = value;
    } else {
      this.reference0x = undefined;
    }
    return this;
  }

  /**
   * Add the provided Reference value to the \`reference0x\` array property.
   *
   * @decorator \`@ReferenceTargets('TestModel.complex.reference.reference0x', ['Practitioner','PractitionerRole','Organization',])\`
   *
   * @param value - the \`reference0x\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('TestModel.complex.reference.reference0x', [
    'Practitioner',
  
    'PractitionerRole',
  
    'Organization',
  ])
  public addReference0x(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.initReference0x();
      this.reference0x?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`reference0x\` property exists and has a value; \`false\` otherwise
   */
  public hasReference0x(): boolean {
    return isDefinedList<Reference>(this.reference0x) && this.reference0x.some((item: Reference) => !item.isEmpty());
  }

  /**
   * Initialize the \`reference0x\` property
   */
  private initReference0x(): void {
    if (!this.hasReference0x()) {
      this.reference0x = [] as Reference[];
    }
  }

  /**
   * @returns the \`reference11\` property value as a Reference object if defined; else null
   */
  public getReference11(): Reference | null {
    return this.reference11;
  }

  /**
   * Assigns the provided Reference11 object value to the \`reference11\` property.
   *
   * @decorator \`@ReferenceTargets('TestModel.complex.reference.reference11', ['SimplePersonModel',])\`
   *
   * @param value - the \`reference11\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('TestModel.complex.reference.reference11', [
    'SimplePersonModel',
  ])
  public setReference11(value: Reference): this {
    assertIsDefined<Reference>(value, \`TestModel.complex.reference.reference11 is required\`);
    // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
    this.reference11 = value;
    return this;
  }

  /**
   * @returns \`true\` if the \`reference11\` property exists and has a value; \`false\` otherwise
   */
  public hasReference11(): boolean {
    return isDefined<Reference>(this.reference11) && !this.reference11.isEmpty();
  }

  /**
   * @returns the \`reference1x\` property value as a Reference array
   */
  public getReference1x(): Reference[] {
    return this.reference1x ?? ([] as Reference[]);
  }

  /**
   * Assigns the provided Reference array value to the \`reference1x\` property.
   *
   * @decorator \`@ReferenceTargets('TestModel.complex.reference.reference1x', ['HealthcareService',])\`
   *
   * @param value - the \`reference1x\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('TestModel.complex.reference.reference1x', [
    'HealthcareService',
  ])
  public setReference1x(value: Reference[]): this {
    assertIsDefinedList<Reference>(value, \`TestModel.complex.reference.reference1x is required\`);
    // assertFhirTypeList<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
    this.reference1x = value;
    return this;
  }

  /**
   * Add the provided Reference value to the \`reference1x\` array property.
   *
   * @decorator \`@ReferenceTargets('TestModel.complex.reference.reference1x', ['HealthcareService',])\`
   *
   * @param value - the \`reference1x\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('TestModel.complex.reference.reference1x', [
    'HealthcareService',
  ])
  public addReference1x(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.initReference1x();
      this.reference1x?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`reference1x\` property exists and has a value; \`false\` otherwise
   */
  public hasReference1x(): boolean {
    return isDefinedList<Reference>(this.reference1x) && this.reference1x.some((item: Reference) => !item.isEmpty());
  }

  /**
   * Initialize the \`reference1x\` property
   */
  private initReference1x(): void {
    if (!this.hasReference1x()) {
      this.reference1x = [] as Reference[];
    }
  }

  /**
   * @returns the \`enumCode\` property value as a TestModelComplexReferenceEnumCodeComponent array
   */
  public getEnumCode(): TestModelComplexReferenceEnumCodeComponent[] {
    return this.enumCode ?? ([] as TestModelComplexReferenceEnumCodeComponent[]);
  }

  /**
   * Assigns the provided TestModelComplexReferenceEnumCodeComponent array value to the \`enumCode\` property.
   *
   * @param value - the \`enumCode\` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setEnumCode(value: TestModelComplexReferenceEnumCodeComponent[]): this {
    assertIsDefinedList<TestModelComplexReferenceEnumCodeComponent>(value, \`TestModel.complex.reference.enumCode is required\`);
    const optErrMsg = \`Invalid TestModel.complex.reference.enumCode; Provided value array has an element that is not an instance of TestModelComplexReferenceEnumCodeComponent.\`;
    assertFhirTypeList<TestModelComplexReferenceEnumCodeComponent>(value, TestModelComplexReferenceEnumCodeComponent, optErrMsg);
    this.enumCode = value;
    return this;
  }

  /**
   * Add the provided TestModelComplexReferenceEnumCodeComponent value to the \`enumCode\` array property.
   *
   * @param value - the \`enumCode\` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addEnumCode(value: TestModelComplexReferenceEnumCodeComponent | undefined): this {
    if (isDefined<TestModelComplexReferenceEnumCodeComponent>(value)) {
      const optErrMsg = \`Invalid TestModel.complex.reference.enumCode; Provided element is not an instance of TestModelComplexReferenceEnumCodeComponent.\`;
      assertFhirType<TestModelComplexReferenceEnumCodeComponent>(value, TestModelComplexReferenceEnumCodeComponent, optErrMsg);
      this.initEnumCode();
      this.enumCode?.push(value);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`enumCode\` property exists and has a value; \`false\` otherwise
   */
  public hasEnumCode(): boolean {
    return isDefinedList<TestModelComplexReferenceEnumCodeComponent>(this.enumCode) && this.enumCode.some((item: TestModelComplexReferenceEnumCodeComponent) => !item.isEmpty());
  }

  /**
   * Initialize the \`enumCode\` property
   */
  private initEnumCode(): void {
    if(!this.hasEnumCode()) {
      this.enumCode = [] as TestModelComplexReferenceEnumCodeComponent[];
    }
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'TestModel.complex.reference';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.reference01,
      this.reference0x,
      this.reference11,
      this.reference1x,
      this.enumCode,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): TestModelComplexReferenceComponent {
    const dest = new TestModelComplexReferenceComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: TestModelComplexReferenceComponent): void {
    super.copyValues(dest);
    dest.reference01 = this.reference01?.copy();
    const reference0xList = copyListValues<Reference>(this.reference0x);
    dest.reference0x = reference0xList.length === 0 ? undefined : reference0xList;
    dest.reference11 = this.reference11 ? this.reference11.copy() : null;
    const reference1xList = copyListValues<Reference>(this.reference1x);
    dest.reference1x = reference1xList.length === 0 ? null : reference1xList;
    const enumCodeList = copyListValues<TestModelComplexReferenceEnumCodeComponent>(this.enumCode);
    dest.enumCode = enumCodeList.length === 0 ? null : enumCodeList;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasReference01()) {
      setFhirComplexJson(this.getReference01(), 'reference01', jsonObj);
    }

    if (this.hasReference0x()) {
      setFhirComplexListJson(this.getReference0x(), 'reference0x', jsonObj);
    }

    if (this.hasReference11()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirComplexJson(this.getReference11()!, 'reference11', jsonObj);
    } else {
      missingReqdProperties.push(\`TestModel.complex.reference.reference11\`);
    }

    if (this.hasReference1x()) {
      setFhirComplexListJson(this.getReference1x(), 'reference1x', jsonObj);
    } else {
      missingReqdProperties.push(\`TestModel.complex.reference.reference1x\`);
    }

    if (this.hasEnumCode()) {
      setFhirBackboneElementListJson(this.getEnumCode(), 'enumCode', jsonObj);
    } else {
      missingReqdProperties.push(\`TestModel.complex.reference.enumCode\`);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
/**
 * TestModelComplexReferenceEnumCodeComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** BackboneElement containing EnumCode datatype patterns
 * - **Definition:** BackboneElement containing EnumCode datatype patterns
 * - **Requirements:** Required list of TestModelComplexReferenceEnumCodeComponent \\'BackboneElement\\'
 *
 * @category Data Models: Resource
 * @see [FHIR TestModel](https://test.ts-fhir-datamodels.com/StructureDefinition/TestModel)
 */
export class TestModelComplexReferenceEnumCodeComponent extends BackboneElement implements IBackboneElement {
  constructor(enumCode11: EnumCodeType | CodeType | fhirCode | null = null, enumCode1x: EnumCodeType[] | CodeType[] | fhirCode[] | null = null) {
    super();

    this.taskCodeEnum = new TaskCodeEnum();
    this.contributorTypeEnum = new ContributorTypeEnum();
    this.taskStatusEnum = new TaskStatusEnum();
    this.consentStateCodesEnum = new ConsentStateCodesEnum();

    this.enumCode11 = constructorCodeValueAsEnumCodeType<ContributorTypeEnum>(
      enumCode11,
      ContributorTypeEnum,
      this.contributorTypeEnum,
      'TestModel.complex.reference.enumCode.enumCode11',
    );

    this.enumCode1x = constructorCodeValueAsEnumCodeTypeList<ConsentStateCodesEnum>(
      enumCode1x,
      ConsentStateCodesEnum,
      this.consentStateCodesEnum,
      'TestModel.complex.reference.enumCode.enumCode1x',
    );
  }

  /**
   * Parse the provided \`TestModelComplexReferenceEnumCodeComponent\` JSON to instantiate the TestModelComplexReferenceEnumCodeComponent data model.
   *
   * @param sourceJson - JSON representing FHIR \`TestModelComplexReferenceEnumCodeComponent\`
   * @param optSourceField - Optional data source field (e.g. \`<complexTypeName>.<complexTypeFieldName>\`); defaults to TestModelComplexReferenceEnumCodeComponent
   * @returns TestModelComplexReferenceEnumCodeComponent data model or undefined for \`TestModelComplexReferenceEnumCodeComponent\`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): TestModelComplexReferenceEnumCodeComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'TestModelComplexReferenceEnumCodeComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, \`\${optSourceValue} JSON\`);
    const instance = new TestModelComplexReferenceEnumCodeComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'enumCode01';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setEnumCode01Element(datatype);
    }

    fieldName = 'enumCode11';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setEnumCode11Element(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'enumCode0x';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: CodeType | undefined = fhirParser.parseCodeType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addEnumCode0xElement(datatype);
        }
      });
    }

    fieldName = 'enumCode1x';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson, idx) => {
        const datatype: CodeType | undefined = fhirParser.parseCodeType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype === undefined) {
          missingReqdProperties.push(\`\${sourceField}[\${String(idx)}]\`);
        } else {
          instance.addEnumCode1xElement(datatype);
        }
      });
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'primitive';
    sourceField = \`\${optSourceValue}.\${fieldName}\`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const component: TestModelPrimitiveComponent | undefined = TestModelPrimitiveComponent.parse(classJsonObj[fieldName]!, sourceField);
      instance.setPrimitive(component);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_REQD_IN_JSON} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: TaskCode
   *
   * @see {@link TaskCodeEnum }
   */
  private readonly taskCodeEnum: TaskCodeEnum;

  /**
   * TestModel.complex.reference.enumCode.enumCode01 Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** enumCode.enumCode01
   * - **Definition:** enumCode.enumCode01
   * - **Requirements:** Optional single \\'code\\' data type with required ValueSet
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   *
   * @see CodeSystem Enumeration: {@link TaskCodeEnum }
   */
  private enumCode01?: EnumCodeType | undefined;

  /**
   * FHIR CodeSystem: ContributorType
   *
   * @see {@link ContributorTypeEnum }
   */
  private readonly contributorTypeEnum: ContributorTypeEnum;

  /**
   * TestModel.complex.reference.enumCode.enumCode11 Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** enumCode.enumCode11
   * - **Definition:** enumCode.enumCode11
   * - **Requirements:** Required single \\'code\\' data type with required ValueSet
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** false
   *
   * @see CodeSystem Enumeration: {@link ContributorTypeEnum }
   */
  private enumCode11: EnumCodeType | null;

  /**
   * FHIR CodeSystem: TaskStatus
   *
   * @see {@link TaskStatusEnum }
   */
  private readonly taskStatusEnum: TaskStatusEnum;

  /**
   * TestModel.complex.reference.enumCode.enumCode0x Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** enumCode.enumCode0x
   * - **Definition:** enumCode.enumCode0x
   * - **Requirements:** Optional list of \\'code\\' data type with required ValueSet
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** false
   *
   * @see CodeSystem Enumeration: {@link TaskStatusEnum }
   */
  private enumCode0x?: EnumCodeType[] | undefined;

  /**
   * FHIR CodeSystem: ConsentStateCodes
   *
   * @see {@link ConsentStateCodesEnum }
   */
  private readonly consentStateCodesEnum: ConsentStateCodesEnum;

  /**
   * TestModel.complex.reference.enumCode.enumCode1x Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** enumCode.enumCode1x
   * - **Definition:** enumCode.enumCode1x
   * - **Requirements:** Required list of \\'code\\' data type with required ValueSet
   * - **FHIR Type:** \`code\`
   * - **Cardinality:** 1..*
   * - **isModifier:** false
   * - **isSummary:** false
   *
   * @see CodeSystem Enumeration: {@link ConsentStateCodesEnum }
   */
  private enumCode1x: EnumCodeType[] | null;

  /**
   * TestModel.complex.reference.enumCode.primitive Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** enumCode.primitive
   * - **Definition:** enumCode.primitive
   * - **Requirements:** Optional single TestModelPrimitiveComponent \\'BackboneElement\\'
   * - **FHIR Type:** \`BackboneElement\`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private primitive?: TestModelPrimitiveComponent | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the \`enumCode01\` property value as a EnumCodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link TaskCodeEnum }
   */
  public getEnumCode01EnumType(): EnumCodeType | undefined {
    return this.enumCode01;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`enumCode01\` property.
   *
   * @param enumType - the \`enumCode01\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code values
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link TaskCodeEnum }
   */
  public setEnumCode01EnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid TestModel.complex.reference.enumCode.enumCode01';
      assertEnumCodeType<TaskCodeEnum>(enumType, TaskCodeEnum, errMsgPrefix);
      this.enumCode01 = enumType;
    } else {
      this.enumCode01 = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`enumCode01\` property exists and has a value; \`false\` otherwise
   */
  public hasEnumCode01EnumType(): boolean {
    return isDefined<EnumCodeType>(this.enumCode01) && !this.enumCode01.isEmpty() && this.enumCode01.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`enumCode01\` property value as a CodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link TaskCodeEnum }
   */
  public getEnumCode01Element(): CodeType | undefined {
    if (this.enumCode01 === undefined) {
      return undefined;
    }
    return this.enumCode01 as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`enumCode01\` property.
   *
   * @param element - the \`enumCode01\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link TaskCodeEnum }
   */
  public setEnumCode01Element(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid TestModel.complex.reference.enumCode.enumCode01; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.enumCode01 = new EnumCodeType(element, this.taskCodeEnum);
    } else {
      this.enumCode01 = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`enumCode01\` property exists and has a value; \`false\` otherwise
   */
  public hasEnumCode01Element(): boolean {
    return this.hasEnumCode01EnumType();
  }

  /**
   * @returns the \`enumCode01\` property value as a fhirCode if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link TaskCodeEnum }
   */
  public getEnumCode01(): fhirCode | undefined {
    if (this.enumCode01 === undefined) {
      return undefined;
    }
    return this.enumCode01.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`enumCode01\` property.
   *
   * @param value - the \`enumCode01\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link TaskCodeEnum }
   */
  public setEnumCode01(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = \`Invalid TestModel.complex.reference.enumCode.enumCode01; Provided value is not an instance of fhirCode.\`;
      this.enumCode01 = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.taskCodeEnum);
    } else {
      this.enumCode01 = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`enumCode01\` property exists and has a value; \`false\` otherwise
   */
  public hasEnumCode01(): boolean {
    return this.hasEnumCode01EnumType();
  }

  /**
   * @returns the \`enumCode11\` property value as a EnumCodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link ContributorTypeEnum }
   */
  public getEnumCode11EnumType(): EnumCodeType | null {
    return this.enumCode11;
  }

  /**
   * Assigns the provided EnumCodeType value to the \`enumCode11\` property.
   *
   * @param enumType - the \`enumCode11\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ContributorTypeEnum }
   */
  public setEnumCode11EnumType(enumType: EnumCodeType): this {
    assertIsDefined<EnumCodeType>(enumType, \`TestModel.complex.reference.enumCode.enumCode11 is required\`);
    const errMsgPrefix = \`Invalid TestModel.complex.reference.enumCode.enumCode11\`;
    assertEnumCodeType<ContributorTypeEnum>(enumType, ContributorTypeEnum, errMsgPrefix);
    this.enumCode11 = enumType;
    return this;
  }

  /**
   * @returns \`true\` if the \`enumCode11\` property exists and has a value; \`false\` otherwise
   */
  public hasEnumCode11EnumType(): boolean {
    return isDefined<EnumCodeType>(this.enumCode11) && !this.enumCode11.isEmpty() && this.enumCode11.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the \`enumCode11\` property value as a CodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link ContributorTypeEnum }
   */
  public getEnumCode11Element(): CodeType | null {
    if (this.enumCode11 === null) {
      return null;
    }
    return this.enumCode11 as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the \`enumCode11\` property.
   *
   * @param element - the \`enumCode11\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ContributorTypeEnum }
   */
  public setEnumCode11Element(element: CodeType): this {
    assertIsDefined<CodeType>(element, \`TestModel.complex.reference.enumCode.enumCode11 is required\`);
    const optErrMsg = \`Invalid TestModel.complex.reference.enumCode.enumCode11; Provided value is not an instance of CodeType.\`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.enumCode11 = new EnumCodeType(element, this.contributorTypeEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`enumCode11\` property exists and has a value; \`false\` otherwise
   */
  public hasEnumCode11Element(): boolean {
    return this.hasEnumCode11EnumType();
  }

  /**
   * @returns the \`enumCode11\` property value as a fhirCode if defined; else null
   *
   * @see CodeSystem Enumeration: {@link ContributorTypeEnum }
   */
  public getEnumCode11(): fhirCode | null {
    if (this.enumCode11 === null) {
      return null;
    }
    return this.enumCode11.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the \`enumCode11\` property.
   *
   * @param value - the \`enumCode11\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link ContributorTypeEnum }
   */
  public setEnumCode11(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, \`TestModel.complex.reference.enumCode.enumCode11 is required\`);
    const optErrMsg = \`Invalid TestModel.complex.reference.enumCode.enumCode11 (\${String(value)})\`;
    this.enumCode11 = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.contributorTypeEnum);
    return this;
  }

  /**
   * @returns \`true\` if the \`enumCode11\` property exists and has a value; \`false\` otherwise
   */
  public hasEnumCode11(): boolean {
    return this.hasEnumCode11EnumType();
  }

  /**
   * @returns the \`enumCode0x\` property value as a EnumCodeType array
   *
   * @see CodeSystem Enumeration: {@link TaskStatusEnum }
   */
  public getEnumCode0xEnumType(): EnumCodeType[] {
    return this.enumCode0x ?? ([] as EnumCodeType[]);
  }

  /**
   * Assigns the provided EnumCodeType array value to the \`enumCode0x\` property.
   *
   * @param enumType - the \`enumCode0x\` array value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link TaskStatusEnum }
   */
  public setEnumCode0xEnumType(enumType: EnumCodeType[] | undefined): this {
    if (isDefinedList<EnumCodeType>(enumType)) {
      const errMsgPrefix = \`Invalid TestModel.complex.reference.enumCode.enumCode0x\`;
      assertEnumCodeTypeList<TaskStatusEnum>(enumType, TaskStatusEnum, errMsgPrefix);
      this.enumCode0x = enumType;
    } else {
      this.enumCode0x = undefined;
    }
    return this;
  }

  /**
   * Add the provided EnumCodeType value to the \`enumCode0x\` array property.
   *
   * @param enumType - the \`enumCode0x\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   *
   * @see CodeSystem Enumeration: {@link TaskStatusEnum }
   */
  public addEnumCode0xEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = \`Invalid TestModel.complex.reference.enumCode.enumCode0x\`;
      assertEnumCodeType<TaskStatusEnum>(enumType, TaskStatusEnum, errMsgPrefix);
      this.initEnumCode0x();
      this.enumCode0x?.push(enumType);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`enumCode0x\` property exists and has a value; \`false\` otherwise
   */
  public hasEnumCode0xEnumType(): boolean {
    return isDefinedList<EnumCodeType>(this.enumCode0x) && this.enumCode0x.some((item: EnumCodeType) => !item.isEmpty()) && this.enumCode0x.every((item: EnumCodeType) => item.fhirCodeEnumeration.length > 0);
  }

  /**
   * @returns the \`enumCode0x\` property value as a CodeType array
   *
   * @see CodeSystem Enumeration: {@link TaskStatusEnum }
   */
  public getEnumCode0xElement(): CodeType[] {
    if (this.enumCode0x === undefined) {
      return [] as CodeType[];
    }
    return this.enumCode0x as CodeType[];
  }

  /**
   * Assigns the provided PrimitiveType array value to the \`enumCode0x\` property.
   *
   * @param element - the \`enumCode0x\` array value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link TaskStatusEnum }
   */
  public setEnumCode0xElement(element: CodeType[] | undefined): this {
    if (isDefinedList<CodeType>(element)) {
      const optErrMsg = \`Invalid TestModel.complex.reference.enumCode.enumCode0x; Provided element array has an element that is not an instance of CodeType.\`;
      assertFhirTypeList<CodeType>(element, CodeType, optErrMsg);
      const enumCodeTypes = [] as EnumCodeType[];
      element.forEach((type: CodeType) => {
        enumCodeTypes.push(new EnumCodeType(type, this.taskStatusEnum));
      });
      this.enumCode0x = enumCodeTypes;
    } else {
      this.enumCode0x = undefined;
    }
    return this;
  }

  /**
   * Add the provided PrimitiveType value to the \`enumCode0x\` array property.
   *
   * @param element - the \`enumCode0x\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link TaskStatusEnum }
   */
  public addEnumCode0xElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid TestModel.complex.reference.enumCode.enumCode0x; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.initEnumCode0x();
      this.enumCode0x?.push(new EnumCodeType(element, this.taskStatusEnum));
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`enumCode0x\` property exists and has a value; \`false\` otherwise
   */
  public hasEnumCode0xElement(): boolean {
    return this.hasEnumCode0xEnumType();
  }

  /**
   * @returns the \`enumCode0x\` property value as a fhirCode array
   *
   * @see CodeSystem Enumeration: {@link TaskStatusEnum }
   */
  public getEnumCode0x(): fhirCode[] {
    if (this.enumCode0x === undefined) {
      return [] as fhirCode[];
    }
    const values = [] as fhirCode[];
    for (const item of this.enumCode0x) {
      values.push(item.fhirCode.code);
    }
    return values;
  }

  /**
   * Assigns the provided primitive value array to the \`enumCode0x\` property.
   *
   * @param value - the \`enumCode0x\` value array
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link TaskStatusEnum }
   */
  public setEnumCode0x(value: fhirCode[] | undefined): this {
    if (isDefinedList<fhirCode>(value)) {
      const enumCodeTypes = [] as EnumCodeType[];
      const optErrMsg = \`Invalid TestModel.complex.reference.enumCode.enumCode0x; Provided value is not an instance of fhirCode.\`;
      value.forEach((val: fhirCode) => {
        enumCodeTypes.push(new EnumCodeType(parseFhirPrimitiveData(val, fhirCodeSchema, optErrMsg), this.taskStatusEnum));
      });
      this.enumCode0x = enumCodeTypes;
    } else {
      this.enumCode0x = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the \`enumCode0x\` array property.
   *
   * @param value - the \`enumCode0x\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link TaskStatusEnum }
   */
  public addEnumCode0x(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      this.initEnumCode0x();
      const optErrMsg = \`Invalid TestModel.complex.reference.enumCode.enumCode0x; Provided value is not an instance of fhirCode.\`;
      this.enumCode0x?.push(new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.taskStatusEnum));
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`enumCode0x\` property exists and has a value; \`false\` otherwise
   */
  public hasEnumCode0x(): boolean {
    return this.hasEnumCode0xEnumType();
  }

  /**
   * Initialize the enumCode0x property
   */
  private initEnumCode0x(): void {
    if(!this.hasEnumCode0xEnumType()) {
      this.enumCode0x = [] as EnumCodeType[];
    }
  }

  /**
   * @returns the \`enumCode1x\` property value as a EnumCodeType array
   *
   * @see CodeSystem Enumeration: {@link ConsentStateCodesEnum }
   */
  public getEnumCode1xEnumType(): EnumCodeType[] {
    return this.enumCode1x ?? ([] as EnumCodeType[]);
  }

  /**
   * Assigns the provided EnumCodeType array value to the \`enumCode1x\` property.
   *
   * @param enumType - the \`enumCode1x\` array value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ConsentStateCodesEnum }
   */
  public setEnumCode1xEnumType(enumType: EnumCodeType[]): this {
    assertIsDefinedList<EnumCodeType>(enumType, \`TestModel.complex.reference.enumCode.enumCode1x is required\`);
    const errMsgPrefix = \`Invalid TestModel.complex.reference.enumCode.enumCode1x\`;
    assertEnumCodeTypeList<ConsentStateCodesEnum>(enumType, ConsentStateCodesEnum, errMsgPrefix);
    this.enumCode1x = enumType;
    return this;
  }

  /**
   * Add the provided EnumCodeType value to the \`enumCode1x\` array property.
   *
   * @param enumType - the \`enumCode1x\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ConsentStateCodesEnum }
   */
  public addEnumCode1xEnumType(enumType: EnumCodeType): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = \`Invalid TestModel.complex.reference.enumCode.enumCode1x\`;
      assertEnumCodeType<ConsentStateCodesEnum>(enumType, ConsentStateCodesEnum, errMsgPrefix);
      this.initEnumCode1x();
      this.enumCode1x?.push(enumType);
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`enumCode1x\` property exists and has a value; \`false\` otherwise
   */
  public hasEnumCode1xEnumType(): boolean {
    return isDefinedList<EnumCodeType>(this.enumCode1x) && this.enumCode1x.some((item: EnumCodeType) => !item.isEmpty()) && this.enumCode1x.every((item: EnumCodeType) => item.fhirCodeEnumeration.length > 0);
  }

  /**
   * @returns the \`enumCode1x\` property value as a CodeType array
   *
   * @see CodeSystem Enumeration: {@link ConsentStateCodesEnum }
   */
  public getEnumCode1xElement(): CodeType[] {
    if (this.enumCode1x === null) {
      return [] as CodeType[];
    }
    return this.enumCode1x as CodeType[];
  }

  /**
   * Assigns the provided PrimitiveType array value to the \`enumCode1x\` property.
   *
   * @param element - the \`enumCode1x\` array value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ConsentStateCodesEnum }
   */
  public setEnumCode1xElement(element: CodeType[]): this {
    assertIsDefinedList<CodeType>(element, \`TestModel.complex.reference.enumCode.enumCode1x is required\`);
    const optErrMsg = \`Invalid TestModel.complex.reference.enumCode.enumCode1x; Provided element array has an element that is not an instance of CodeType.\`;
    assertFhirTypeList<CodeType>(element, CodeType, optErrMsg);
    const enumCodeTypes = [] as EnumCodeType[];
    element.forEach((type: CodeType) => {
      enumCodeTypes.push(new EnumCodeType(type, this.consentStateCodesEnum));
    });
    this.enumCode1x = enumCodeTypes;
    return this;
  }

  /**
   * Add the provided PrimitiveType value to the \`enumCode1x\` array property.
   *
   * @param element - the \`enumCode1x\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ConsentStateCodesEnum }
   */
  public addEnumCode1xElement(element: CodeType): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = \`Invalid TestModel.complex.reference.enumCode.enumCode1x; Provided element is not an instance of CodeType.\`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.initEnumCode1x();
      this.enumCode1x?.push(new EnumCodeType(element, this.consentStateCodesEnum));
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`enumCode1x\` property exists and has a value; \`false\` otherwise
   */
  public hasEnumCode1xElement(): boolean {
    return this.hasEnumCode1xEnumType();
  }

  /**
   * @returns the \`enumCode1x\` property value as a fhirCode array
   *
   * @see CodeSystem Enumeration: {@link ConsentStateCodesEnum }
   */
  public getEnumCode1x(): fhirCode[] {
    if (this.enumCode1x === null) {
      return [] as fhirCode[];
    }
    const values = [] as fhirCode[];
    for (const item of this.enumCode1x) {
      values.push(item.fhirCode.code);
    }
    return values;
  }

  /**
   * Assigns the provided primitive value array to the \`enumCode1x\` property.
   *
   * @param value - the \`enumCode1x\` value array
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link ConsentStateCodesEnum }
   */
  public setEnumCode1x(value: fhirCode[]): this {
    assertIsDefinedList<fhirCode>(value, \`TestModel.complex.reference.enumCode.enumCode1x is required\`);
    const enumCodeTypes = [] as EnumCodeType[];
    const optErrMsg = \`Invalid TestModel.complex.reference.enumCode.enumCode1x; Provided value is not an instance of fhirCode.\`;
    value.forEach((val: fhirCode) => {
      enumCodeTypes.push(new EnumCodeType(parseFhirPrimitiveData(val, fhirCodeSchema, optErrMsg), this.consentStateCodesEnum));
    });
    this.enumCode1x = enumCodeTypes;
    return this;
  }

  /**
   * Add the provided primitive value to the \`enumCode1x\` array property.
   *
   * @param value - the \`enumCode1x\` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link ConsentStateCodesEnum }
   */
  public addEnumCode1x(value: fhirCode): this {
    if (isDefined<fhirCode>(value)) {
      this.initEnumCode1x();
      const optErrMsg = \`Invalid TestModel.complex.reference.enumCode.enumCode1x; Provided value is not an instance of fhirCode.\`;
      this.enumCode1x?.push(new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.consentStateCodesEnum));
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`enumCode1x\` property exists and has a value; \`false\` otherwise
   */
  public hasEnumCode1x(): boolean {
    return this.hasEnumCode1xEnumType();
  }

  /**
   * Initialize the enumCode1x property
   */
  private initEnumCode1x(): void {
    if(!this.hasEnumCode1xEnumType()) {
      this.enumCode1x = [] as EnumCodeType[];
    }
  }

  /**
   * @returns the \`primitive\` property value as a TestModelPrimitiveComponent object if defined; else an empty TestModelPrimitiveComponent object
   */
  public getPrimitive(): TestModelPrimitiveComponent {
    return this.primitive ?? new TestModelPrimitiveComponent();
  }

  /**
   * Assigns the provided Primitive object value to the \`primitive\` property.
   *
   * @param value - the \`primitive\` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setPrimitive(value: TestModelPrimitiveComponent | undefined): this {
    if (isDefined<TestModelPrimitiveComponent>(value)) {
      const optErrMsg = \`Invalid TestModel.complex.reference.enumCode.primitive; Provided element is not an instance of TestModelPrimitiveComponent.\`;
      assertFhirType<TestModelPrimitiveComponent>(value, TestModelPrimitiveComponent, optErrMsg);
      this.primitive = value;
    } else {
      this.primitive = undefined;
    }
    return this;
  }

  /**
   * @returns \`true\` if the \`primitive\` property exists and has a value; \`false\` otherwise
   */
  public hasPrimitive(): boolean {
    return isDefined<TestModelPrimitiveComponent>(this.primitive) && !this.primitive.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'TestModel.complex.reference.enumCode';
  }

  /**
   * @returns \`true\` if the instance is empty; \`false\` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.enumCode01,
      this.enumCode11,
      this.enumCode0x,
      this.enumCode1x,
      this.primitive,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): TestModelComplexReferenceEnumCodeComponent {
    const dest = new TestModelComplexReferenceEnumCodeComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: TestModelComplexReferenceEnumCodeComponent): void {
    super.copyValues(dest);
    dest.enumCode01 = this.enumCode01?.copy();
    dest.enumCode11 = this.enumCode11 ? this.enumCode11.copy() : null;
    const enumCode0xList = copyListValues<EnumCodeType>(this.enumCode0x);
    dest.enumCode0x = enumCode0xList.length === 0 ? undefined : enumCode0xList;
    const enumCode1xList = copyListValues<EnumCodeType>(this.enumCode1x);
    dest.enumCode1x = enumCode1xList.length === 0 ? null : enumCode1xList;
    dest.primitive = this.primitive?.copy();
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasEnumCode01Element()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getEnumCode01Element()!, 'enumCode01', jsonObj);
    }

    if (this.hasEnumCode11Element()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getEnumCode11Element()!, 'enumCode11', jsonObj);
    } else {
      missingReqdProperties.push(\`TestModel.complex.reference.enumCode.enumCode11\`);
    }

    if (this.hasEnumCode0xElement()) {
      setFhirPrimitiveListJson<fhirCode>(this.getEnumCode0xElement(), 'enumCode0x', jsonObj);
    }

    if (this.hasEnumCode1xElement()) {
      setFhirPrimitiveListJson<fhirCode>(this.getEnumCode1xElement(), 'enumCode1x', jsonObj);
    } else {
      missingReqdProperties.push(\`TestModel.complex.reference.enumCode.enumCode1x\`);
    }

    if (this.hasPrimitive()) {
      setFhirBackboneElementJson(this.getPrimitive(), 'primitive', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = \`\${REQUIRED_PROPERTIES_DO_NOT_EXIST} \${missingReqdProperties.join(', ')}\`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
",
  "fileExtension": "ts",
  "filename": "TestModel",
}
`;

exports[`generator-datamodel-ftest Functional Test Suite generator-app verify generated content should consistently create GeneratedContent[] 43`] = `
{
  "fhirCoreImports": Set {
    "import { Resource, ParsableResource } from '@paq-ts-fhir/fhir-core';",
  },
  "fhirPackage": {
    "baseOutputPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/src",
    "isFunctionalTest": true,
    "pkgLoaderCacheRootPath": "/home/jpaquette/DevNode/ts-fhir-datamodels/app/generator-datamodel-ftest/test/ftest-cache",
    "pkgName": "ftest.fhir.r4",
    "pkgVersion": "4.0.1",
    "release": "R4",
  },
  "fhirType": "Resource",
  "fileContents": "/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated by the FHIR Data Model Generator.
 * DO NOT make any modifications!
 * 
 * parsable-resource-map.ts Module
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { Resource, ParsableResource } from '@paq-ts-fhir/fhir-core';
import { Bundle } from './Bundle';
import { Device } from './Device';
import { DeviceDefinition } from './DeviceDefinition';
import { Endpoint } from './Endpoint';
import { HealthcareService } from './HealthcareService';
import { Location } from './Location';
import { Organization } from './Organization';
import { Patient } from './Patient';
import { Practitioner } from './Practitioner';
import { PractitionerRole } from './PractitionerRole';
import { RelatedPerson } from './RelatedPerson';
import { SimplePersonModel } from './SimplePersonModel';
import { TestModel } from './TestModel';

/**
 * PARSABLE_RESOURCE_MAP
 *
 * @remarks
 * Map of all parsable Resources where the key is the name of the Resource and the value is its ParsableResource<Resource> class.
 *
 * @internal
 */
export const PARSABLE_RESOURCE_MAP = new Map<string, ParsableResource<Resource>>();
PARSABLE_RESOURCE_MAP.set('Bundle', Bundle);
PARSABLE_RESOURCE_MAP.set('Device', Device);
PARSABLE_RESOURCE_MAP.set('DeviceDefinition', DeviceDefinition);
PARSABLE_RESOURCE_MAP.set('Endpoint', Endpoint);
PARSABLE_RESOURCE_MAP.set('HealthcareService', HealthcareService);
PARSABLE_RESOURCE_MAP.set('Location', Location);
PARSABLE_RESOURCE_MAP.set('Organization', Organization);
PARSABLE_RESOURCE_MAP.set('Patient', Patient);
PARSABLE_RESOURCE_MAP.set('Practitioner', Practitioner);
PARSABLE_RESOURCE_MAP.set('PractitionerRole', PractitionerRole);
PARSABLE_RESOURCE_MAP.set('RelatedPerson', RelatedPerson);
PARSABLE_RESOURCE_MAP.set('SimplePersonModel', SimplePersonModel);
PARSABLE_RESOURCE_MAP.set('TestModel', TestModel);
",
  "fileExtension": "ts",
  "filename": "parsable-resource-map",
  "generatedImports": Set {
    "import { Bundle } from './Bundle';",
    "import { Device } from './Device';",
    "import { DeviceDefinition } from './DeviceDefinition';",
    "import { Endpoint } from './Endpoint';",
    "import { HealthcareService } from './HealthcareService';",
    "import { Location } from './Location';",
    "import { Organization } from './Organization';",
    "import { Patient } from './Patient';",
    "import { Practitioner } from './Practitioner';",
    "import { PractitionerRole } from './PractitionerRole';",
    "import { RelatedPerson } from './RelatedPerson';",
    "import { SimplePersonModel } from './SimplePersonModel';",
    "import { TestModel } from './TestModel';",
  },
}
`;
