/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinitions for FHIR complex datatypes.
 * DO NOT make any modifications!
 *
 * Combined FHIR Complex Datatypes Module
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  BackboneType,
  Base64BinaryType,
  BooleanType,
  CanonicalType,
  ChoiceDataTypes,
  ChoiceDataTypesMeta,
  CodeType,
  CodeableConcept,
  Coding,
  DataType,
  DateTimeType,
  DateType,
  DecimalType,
  EnumCodeType,
  FhirError,
  FhirParser,
  IBackboneType,
  IDataType,
  INSTANCE_EMPTY_ERROR_MSG,
  IdType,
  Identifier,
  InstantType,
  Integer64Type,
  IntegerType,
  InvalidTypeError,
  JSON,
  MarkdownType,
  Meta,
  Narrative,
  OidType,
  ParsableDataType,
  Period,
  PositiveIntType,
  PrimitiveType,
  PrimitiveTypeJson,
  REQUIRED_PROPERTIES_DO_NOT_EXIST,
  REQUIRED_PROPERTIES_REQD_IN_JSON,
  Reference,
  ReferenceTargets,
  StringType,
  TimeType,
  UnsignedIntType,
  UriType,
  UrlType,
  UuidType,
  assertEnumCodeType,
  assertEnumCodeTypeList,
  assertFhirType,
  assertFhirTypeList,
  assertIsDefined,
  constructorCodeValueAsEnumCodeType,
  copyListValues,
  fhirBase64Binary,
  fhirBase64BinarySchema,
  fhirBoolean,
  fhirBooleanSchema,
  fhirCanonical,
  fhirCanonicalSchema,
  fhirCode,
  fhirCodeSchema,
  fhirDate,
  fhirDateSchema,
  fhirDateTime,
  fhirDateTimeSchema,
  fhirDecimal,
  fhirDecimalSchema,
  fhirId,
  fhirIdSchema,
  fhirInstant,
  fhirInstantSchema,
  fhirInteger,
  fhirInteger64,
  fhirInteger64Schema,
  fhirIntegerSchema,
  fhirMarkdown,
  fhirMarkdownSchema,
  fhirPositiveInt,
  fhirPositiveIntSchema,
  fhirString,
  fhirStringSchema,
  fhirTime,
  fhirTimeSchema,
  fhirUnsignedInt,
  fhirUnsignedIntSchema,
  fhirUri,
  fhirUriSchema,
  fhirUrl,
  fhirUrlSchema,
  getPrimitiveTypeJson,
  getPrimitiveTypeListJson,
  isDefined,
  isDefinedList,
  isElementEmpty,
  isEmpty,
  parseFhirPrimitiveData,
  setFhirComplexJson,
  setFhirComplexListJson,
  setFhirPrimitiveJson,
  setFhirPrimitiveListJson,
  setPolymorphicValueJson,
} from '@paq-ts-fhir/fhir-core';
import { AdditionalBindingPurposeEnum } from '../code-systems/AdditionalBindingPurposeEnum';
import { AddressTypeEnum } from '../code-systems/AddressTypeEnum';
import { AddressUseEnum } from '../code-systems/AddressUseEnum';
import { BindingStrengthEnum } from '../code-systems/BindingStrengthEnum';
import { ConstraintSeverityEnum } from '../code-systems/ConstraintSeverityEnum';
import { ContactPointSystemEnum } from '../code-systems/ContactPointSystemEnum';
import { ContactPointUseEnum } from '../code-systems/ContactPointUseEnum';
import { ContributorTypeEnum } from '../code-systems/ContributorTypeEnum';
import { DaysOfWeekEnum } from '../code-systems/DaysOfWeekEnum';
import { DiscriminatorTypeEnum } from '../code-systems/DiscriminatorTypeEnum';
import { FhirTypesEnum } from '../code-systems/FhirTypesEnum';
import { NameUseEnum } from '../code-systems/NameUseEnum';
import { OperationParameterUseEnum } from '../code-systems/OperationParameterUseEnum';
import { PARSABLE_RESOURCE_MAP } from '../resources/parsable-resource-map';
import { PriceComponentTypeEnum } from '../code-systems/PriceComponentTypeEnum';
import { PropertyRepresentationEnum } from '../code-systems/PropertyRepresentationEnum';
import { PublicationStatusEnum } from '../code-systems/PublicationStatusEnum';
import { QuantityComparatorEnum } from '../code-systems/QuantityComparatorEnum';
import { ReferenceVersionRulesEnum } from '../code-systems/ReferenceVersionRulesEnum';
import { RelatedArtifactTypeEnum } from '../code-systems/RelatedArtifactTypeEnum';
import { ResourceAggregationModeEnum } from '../code-systems/ResourceAggregationModeEnum';
import { ResourceSlicingRulesEnum } from '../code-systems/ResourceSlicingRulesEnum';
import { SearchComparatorEnum } from '../code-systems/SearchComparatorEnum';
import { SortDirectionEnum } from '../code-systems/SortDirectionEnum';
import { TriggerTypeEnum } from '../code-systems/TriggerTypeEnum';

// eslint-disable-next-line @typescript-eslint/no-explicit-any -- Symbol.metadata polyfill secret sauce for decorator metadata
(Symbol.metadata as any) ??= Symbol('Symbol.metadata');

// The fhir-core complex types must be exported from @paq-ts-fhir/fhir-core rather than using the generated complex types.
export { CodeableConcept, Coding, Identifier, Meta, Narrative, Period, Reference } from '@paq-ts-fhir/fhir-core';


/**
 * Address Class
 *
 * @remarks
 * Address Type: An address expressed using postal conventions (as opposed to GPS or other location definition formats).  This data type may be used to convey addresses for use in delivering mail as well as for visiting locations which might not be valid for mail delivery.  There are a variety of postal address formats defined around the world. The ISO21090-codedString may be used to provide a coded representation of the contents of strings in an Address.
 *
 * Need to be able to record postal addresses, along with notes about their use.
 *
 * **FHIR Specification**
 * - **Short:** An address expressed using postal conventions (as opposed to GPS or other location definition formats)
 * - **Definition:** An address expressed using postal conventions (as opposed to GPS or other location definition formats).  This data type may be used to convey addresses for use in delivering mail as well as for visiting locations which might not be valid for mail delivery.  There are a variety of postal address formats defined around the world. The ISO21090-codedString may be used to provide a coded representation of the contents of strings in an Address.
 * - **Comment:** Note: address is intended to describe postal addresses for administrative purposes, not to describe absolute geographical coordinates.  Postal addresses are often used as proxies for physical locations (also see the [Location](https://hl7.org/fhir/location.html#) resource).
 * - **FHIR Version:** 5.0.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR Address](http://hl7.org/fhir/StructureDefinition/Address)
 */
export class Address extends DataType implements IDataType {
  constructor() {
    super();

    this.addressUseEnum = new AddressUseEnum();
    this.addressTypeEnum = new AddressTypeEnum();
  }

  /**
   * Parse the provided `Address` JSON to instantiate the Address data model.
   *
   * @param sourceJson - JSON representing FHIR `Address`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to Address
   * @returns Address data model or undefined for `Address`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Address | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Address';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new Address();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'use';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setUseElement(datatype);
    }

    fieldName = 'type';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setTypeElement(datatype);
    }

    fieldName = 'text';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setTextElement(datatype);
    }

    fieldName = 'line';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: StringType | undefined = fhirParser.parseStringType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addLineElement(datatype);
        }
      });
    }

    fieldName = 'city';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setCityElement(datatype);
    }

    fieldName = 'district';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setDistrictElement(datatype);
    }

    fieldName = 'state';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setStateElement(datatype);
    }

    fieldName = 'postalCode';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setPostalCodeElement(datatype);
    }

    fieldName = 'country';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setCountryElement(datatype);
    }

    fieldName = 'period';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Period | undefined = Period.parse(classJsonObj[fieldName]!, sourceField);
      instance.setPeriod(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: AddressUse
   *
   * @see {@link AddressUseEnum }
   */
  private readonly addressUseEnum: AddressUseEnum;

  /**
   * Address.use Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** home | work | temp | old | billing - purpose of this address
   * - **Definition:** The purpose of this address.
   * - **Comment:** Applications can assume that an address is current unless it explicitly says that it is temporary or old.
   * - **Requirements:** Allows an appropriate address to be chosen from a list of many.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** true
   * - **isModifierReason:** This is labeled as &quot;Is Modifier&quot; because applications should not mistake a temporary or old address etc.for a current/permanent one
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link AddressUseEnum }
   */
  private use?: EnumCodeType | undefined;

  /**
   * FHIR CodeSystem: AddressType
   *
   * @see {@link AddressTypeEnum }
   */
  private readonly addressTypeEnum: AddressTypeEnum;

  /**
   * Address.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** postal | physical | both
   * - **Definition:** Distinguishes between physical addresses (those you can visit) and mailing addresses (e.g. PO Boxes and care-of addresses). Most addresses are both.
   * - **Comment:** The definition of Address states that "address is intended to describe postal addresses, not physical locations". However, many applications track whether an address has a dual purpose of being a location that can be visited as well as being a valid delivery destination, and Postal addresses are often used as proxies for physical locations (also see the [Location](https://hl7.org/fhir/location.html#) resource).
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link AddressTypeEnum }
   */
  private type_?: EnumCodeType | undefined;

  /**
   * Address.text Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Text representation of the address
   * - **Definition:** Specifies the entire address as it should be displayed e.g. on a postal label. This may be provided instead of or as well as the specific parts.
   * - **Comment:** Can provide both a text representation and parts. Applications updating an address SHALL ensure that  when both text and parts are present,  no content is included in the text that isn\'t found in a part.
   * - **Requirements:** A renderable, unencoded form.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private text?: StringType | undefined;

  /**
   * Address.line Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Street name, number, direction & P.O. Box etc.
   * - **Definition:** This component contains the house number, apartment number, street name, street direction,  P.O. Box number, delivery hints, and similar address information.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private line?: StringType[] | undefined;

  /**
   * Address.city Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Name of city, town etc.
   * - **Definition:** The name of the city, town, suburb, village or other community or delivery center.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private city?: StringType | undefined;

  /**
   * Address.district Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** District name (aka county)
   * - **Definition:** The name of the administrative area (county).
   * - **Comment:** District is sometimes known as county, but in some regions \'county\' is used in place of city (municipality), so county name should be conveyed in city instead.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private district?: StringType | undefined;

  /**
   * Address.state Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Sub-unit of country (abbreviations ok)
   * - **Definition:** Sub-unit of a country with limited sovereignty in a federally organized country. A code may be used if codes are in common use (e.g. US 2 letter state codes).
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private state?: StringType | undefined;

  /**
   * Address.postalCode Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Postal code for area
   * - **Definition:** A postal code designating a region defined by the postal service.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private postalCode?: StringType | undefined;

  /**
   * Address.country Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Country (e.g. may be ISO 3166 2 or 3 letter code)
   * - **Definition:** Country - a nation as commonly understood or generally accepted.
   * - **Comment:** ISO 3166 2- or 3- letter codes MAY be used in place of a human readable country name.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private country?: StringType | undefined;

  /**
   * Address.period Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Time period when address was/is in use
   * - **Definition:** Time period when address was/is in use.
   * - **Requirements:** Allows addresses to be placed in historical context.
   * - **FHIR Type:** `Period`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private period?: Period | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `use` property value as a EnumCodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link AddressUseEnum }
   */
  public getUseEnumType(): EnumCodeType | undefined {
    return this.use;
  }

  /**
   * Assigns the provided EnumCodeType value to the `use` property.
   *
   * @param enumType - the `use` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code values
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link AddressUseEnum }
   */
  public setUseEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid Address.use';
      assertEnumCodeType<AddressUseEnum>(enumType, AddressUseEnum, errMsgPrefix);
      this.use = enumType;
    } else {
      this.use = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `use` property exists and has a value; `false` otherwise
   */
  public hasUseEnumType(): boolean {
    return isDefined<EnumCodeType>(this.use) && !this.use.isEmpty() && this.use.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the `use` property value as a CodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link AddressUseEnum }
   */
  public getUseElement(): CodeType | undefined {
    if (this.use === undefined) {
      return undefined;
    }
    return this.use as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the `use` property.
   *
   * @param element - the `use` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link AddressUseEnum }
   */
  public setUseElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid Address.use; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.use = new EnumCodeType(element, this.addressUseEnum);
    } else {
      this.use = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `use` property exists and has a value; `false` otherwise
   */
  public hasUseElement(): boolean {
    return this.hasUseEnumType();
  }

  /**
   * @returns the `use` property value as a fhirCode if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link AddressUseEnum }
   */
  public getUse(): fhirCode | undefined {
    if (this.use === undefined) {
      return undefined;
    }
    return this.use.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the `use` property.
   *
   * @param value - the `use` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link AddressUseEnum }
   */
  public setUse(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid Address.use; Provided value is not an instance of fhirCode.`;
      this.use = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.addressUseEnum);
    } else {
      this.use = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `use` property exists and has a value; `false` otherwise
   */
  public hasUse(): boolean {
    return this.hasUseEnumType();
  }

  /**
   * @returns the `type_` property value as a EnumCodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link AddressTypeEnum }
   */
  public getTypeEnumType(): EnumCodeType | undefined {
    return this.type_;
  }

  /**
   * Assigns the provided EnumCodeType value to the `type_` property.
   *
   * @param enumType - the `type_` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code values
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link AddressTypeEnum }
   */
  public setTypeEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid Address.type';
      assertEnumCodeType<AddressTypeEnum>(enumType, AddressTypeEnum, errMsgPrefix);
      this.type_ = enumType;
    } else {
      this.type_ = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasTypeEnumType(): boolean {
    return isDefined<EnumCodeType>(this.type_) && !this.type_.isEmpty() && this.type_.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the `type_` property value as a CodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link AddressTypeEnum }
   */
  public getTypeElement(): CodeType | undefined {
    if (this.type_ === undefined) {
      return undefined;
    }
    return this.type_ as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the `type_` property.
   *
   * @param element - the `type_` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link AddressTypeEnum }
   */
  public setTypeElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid Address.type; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.type_ = new EnumCodeType(element, this.addressTypeEnum);
    } else {
      this.type_ = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasTypeElement(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the `type_` property value as a fhirCode if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link AddressTypeEnum }
   */
  public getType(): fhirCode | undefined {
    if (this.type_ === undefined) {
      return undefined;
    }
    return this.type_.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the `type_` property.
   *
   * @param value - the `type_` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link AddressTypeEnum }
   */
  public setType(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid Address.type; Provided value is not an instance of fhirCode.`;
      this.type_ = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.addressTypeEnum);
    } else {
      this.type_ = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasType(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the `text` property value as a StringType object if defined; else an empty StringType object
   */
  public getTextElement(): StringType {
    return this.text ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `text` property.
   *
   * @param element - the `text` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTextElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid Address.text; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.text = element;
    } else {
      this.text = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `text` property exists and has a value; `false` otherwise
   */
  public hasTextElement(): boolean {
    return isDefined<StringType>(this.text) && !this.text.isEmpty();
  }

  /**
   * @returns the `text` property value as a fhirString if defined; else undefined
   */
  public getText(): fhirString | undefined {
    return this.text?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `text` property.
   *
   * @param value - the `text` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setText(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid Address.text (${String(value)})`;
      this.text = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.text = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `text` property exists and has a value; `false` otherwise
   */
  public hasText(): boolean {
    return this.hasTextElement();
  }

  /**
   * @returns the `line` property value as a StringType array
   */
  public getLineElement(): StringType[] {
    return this.line ?? ([] as StringType[]);
  }

  /**
   * Assigns the provided StringType array value to the `line` property.
   *
   * @param element - the `line` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLineElement(element: StringType[] | undefined): this {
    if (isDefinedList<StringType>(element)) {
      const optErrMsg = `Invalid Address.line; Provided value array has an element that is not an instance of StringType.`;
      assertFhirTypeList<StringType>(element, StringType, optErrMsg);
      this.line = element;
    } else {
      this.line = undefined;
    }
    return this;
  }

  /**
   * Add the provided StringType value to the `line` array property.
   *
   * @param element - the `line` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addLineElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid Address.line; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.initLine();
      this.line?.push(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `line` property exists and has a value; `false` otherwise
   */
  public hasLineElement(): boolean {
    return isDefinedList<StringType>(this.line) && this.line.some((item: StringType) => !item.isEmpty());
  }

  /**
   * @returns the `line` property value as a fhirString array
   */
  public getLine(): fhirString[] {
    this.initLine();
    const lineValues = [] as fhirString[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.line!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        lineValues.push(value);
      }
    }
    return lineValues;
  }

  /**
   * Assigns the provided primitive value array to the `line` property.
   *
   * @param value - the `line` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLine(value: fhirString[] | undefined): this {
    if (isDefinedList<fhirString>(value)) {
      const lineElements = [] as StringType[];
      for (const lineValue of value) {
        const optErrMsg = `Invalid Address.line array item (${String(lineValue)})`;
        const element = new StringType(parseFhirPrimitiveData(lineValue, fhirStringSchema, optErrMsg));
        lineElements.push(element);
      }
      this.line = lineElements;
    } else {
      this.line = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the `line` array property.
   *
   * @param value - the `line` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addLine(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid Address.line array item (${String(value)})`;
      const element = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
      this.initLine();
      this.addLineElement(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `line` property exists and has a value; `false` otherwise
   */
  public hasLine(): boolean {
    return this.hasLineElement();
  }

  /**
   * Initialize the `line` property
   */
  private initLine(): void {
    if (!this.hasLine()) {
      this.line = [] as StringType[];
    }
  }

  /**
   * @returns the `city` property value as a StringType object if defined; else an empty StringType object
   */
  public getCityElement(): StringType {
    return this.city ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `city` property.
   *
   * @param element - the `city` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCityElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid Address.city; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.city = element;
    } else {
      this.city = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `city` property exists and has a value; `false` otherwise
   */
  public hasCityElement(): boolean {
    return isDefined<StringType>(this.city) && !this.city.isEmpty();
  }

  /**
   * @returns the `city` property value as a fhirString if defined; else undefined
   */
  public getCity(): fhirString | undefined {
    return this.city?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `city` property.
   *
   * @param value - the `city` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCity(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid Address.city (${String(value)})`;
      this.city = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.city = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `city` property exists and has a value; `false` otherwise
   */
  public hasCity(): boolean {
    return this.hasCityElement();
  }

  /**
   * @returns the `district` property value as a StringType object if defined; else an empty StringType object
   */
  public getDistrictElement(): StringType {
    return this.district ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `district` property.
   *
   * @param element - the `district` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDistrictElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid Address.district; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.district = element;
    } else {
      this.district = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `district` property exists and has a value; `false` otherwise
   */
  public hasDistrictElement(): boolean {
    return isDefined<StringType>(this.district) && !this.district.isEmpty();
  }

  /**
   * @returns the `district` property value as a fhirString if defined; else undefined
   */
  public getDistrict(): fhirString | undefined {
    return this.district?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `district` property.
   *
   * @param value - the `district` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDistrict(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid Address.district (${String(value)})`;
      this.district = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.district = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `district` property exists and has a value; `false` otherwise
   */
  public hasDistrict(): boolean {
    return this.hasDistrictElement();
  }

  /**
   * @returns the `state` property value as a StringType object if defined; else an empty StringType object
   */
  public getStateElement(): StringType {
    return this.state ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `state` property.
   *
   * @param element - the `state` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setStateElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid Address.state; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.state = element;
    } else {
      this.state = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `state` property exists and has a value; `false` otherwise
   */
  public hasStateElement(): boolean {
    return isDefined<StringType>(this.state) && !this.state.isEmpty();
  }

  /**
   * @returns the `state` property value as a fhirString if defined; else undefined
   */
  public getState(): fhirString | undefined {
    return this.state?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `state` property.
   *
   * @param value - the `state` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setState(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid Address.state (${String(value)})`;
      this.state = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.state = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `state` property exists and has a value; `false` otherwise
   */
  public hasState(): boolean {
    return this.hasStateElement();
  }

  /**
   * @returns the `postalCode` property value as a StringType object if defined; else an empty StringType object
   */
  public getPostalCodeElement(): StringType {
    return this.postalCode ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `postalCode` property.
   *
   * @param element - the `postalCode` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPostalCodeElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid Address.postalCode; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.postalCode = element;
    } else {
      this.postalCode = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `postalCode` property exists and has a value; `false` otherwise
   */
  public hasPostalCodeElement(): boolean {
    return isDefined<StringType>(this.postalCode) && !this.postalCode.isEmpty();
  }

  /**
   * @returns the `postalCode` property value as a fhirString if defined; else undefined
   */
  public getPostalCode(): fhirString | undefined {
    return this.postalCode?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `postalCode` property.
   *
   * @param value - the `postalCode` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPostalCode(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid Address.postalCode (${String(value)})`;
      this.postalCode = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.postalCode = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `postalCode` property exists and has a value; `false` otherwise
   */
  public hasPostalCode(): boolean {
    return this.hasPostalCodeElement();
  }

  /**
   * @returns the `country` property value as a StringType object if defined; else an empty StringType object
   */
  public getCountryElement(): StringType {
    return this.country ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `country` property.
   *
   * @param element - the `country` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCountryElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid Address.country; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.country = element;
    } else {
      this.country = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `country` property exists and has a value; `false` otherwise
   */
  public hasCountryElement(): boolean {
    return isDefined<StringType>(this.country) && !this.country.isEmpty();
  }

  /**
   * @returns the `country` property value as a fhirString if defined; else undefined
   */
  public getCountry(): fhirString | undefined {
    return this.country?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `country` property.
   *
   * @param value - the `country` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCountry(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid Address.country (${String(value)})`;
      this.country = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.country = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `country` property exists and has a value; `false` otherwise
   */
  public hasCountry(): boolean {
    return this.hasCountryElement();
  }

  /**
   * @returns the `period` property value as a Period object if defined; else an empty Period object
   */
  public getPeriod(): Period {
    return this.period ?? new Period();
  }

  /**
   * Assigns the provided Period object value to the `period` property.
   *
   * @param value - the `period` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setPeriod(value: Period | undefined): this {
    if (isDefined<Period>(value)) {
      const optErrMsg = `Invalid Address.period; Provided element is not an instance of Period.`;
      assertFhirType<Period>(value, Period, optErrMsg);
      this.period = value;
    } else {
      this.period = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `period` property exists and has a value; `false` otherwise
   */
  public hasPeriod(): boolean {
    return isDefined<Period>(this.period) && !this.period.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Address';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.use,
      this.type_,
      this.text,
      this.line,
      this.city,
      this.district,
      this.state,
      this.postalCode,
      this.country,
      this.period,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Address {
    const dest = new Address();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Address): void {
    super.copyValues(dest);
    dest.use = this.use?.copy();
    dest.type_ = this.type_?.copy();
    dest.text = this.text?.copy();
    const lineList = copyListValues<StringType>(this.line);
    dest.line = lineList.length === 0 ? undefined : lineList;
    dest.city = this.city?.copy();
    dest.district = this.district?.copy();
    dest.state = this.state?.copy();
    dest.postalCode = this.postalCode?.copy();
    dest.country = this.country?.copy();
    dest.period = this.period?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasUseElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getUseElement()!, 'use', jsonObj);
    }

    if (this.hasTypeElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getTypeElement()!, 'type', jsonObj);
    }

    if (this.hasTextElement()) {
      setFhirPrimitiveJson<fhirString>(this.getTextElement(), 'text', jsonObj);
    }

    if (this.hasLine()) {
      setFhirPrimitiveListJson(this.getLineElement(), 'line', jsonObj);
    }

    if (this.hasCityElement()) {
      setFhirPrimitiveJson<fhirString>(this.getCityElement(), 'city', jsonObj);
    }

    if (this.hasDistrictElement()) {
      setFhirPrimitiveJson<fhirString>(this.getDistrictElement(), 'district', jsonObj);
    }

    if (this.hasStateElement()) {
      setFhirPrimitiveJson<fhirString>(this.getStateElement(), 'state', jsonObj);
    }

    if (this.hasPostalCodeElement()) {
      setFhirPrimitiveJson<fhirString>(this.getPostalCodeElement(), 'postalCode', jsonObj);
    }

    if (this.hasCountryElement()) {
      setFhirPrimitiveJson<fhirString>(this.getCountryElement(), 'country', jsonObj);
    }

    if (this.hasPeriod()) {
      setFhirComplexJson(this.getPeriod(), 'period', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * Age Class
 *
 * @remarks
 * Age Type: A duration of time during which an organism (or a process) has existed.
 *
 * **FHIR Specification**
 * - **Short:** A duration of time during which an organism (or a process) has existed
 * - **Definition:** A duration of time during which an organism (or a process) has existed.
 * - **Comment:** The context of use may frequently define what kind of quantity this is and therefore what kind of units can be used. The context of use may also restrict the values for the comparator.
 * - **FHIR Version:** 5.0.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR Age](http://hl7.org/fhir/StructureDefinition/Age)
 */
export class Age extends DataType implements IDataType {
  constructor() {
    super();

    this.quantityComparatorEnum = new QuantityComparatorEnum();
  }

  /**
   * Parse the provided `Age` JSON to instantiate the Age data model.
   *
   * @param sourceJson - JSON representing FHIR `Age`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to Age
   * @returns Age data model or undefined for `Age`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Age | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Age';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new Age();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'value';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setValueElement(datatype);
    }

    fieldName = 'comparator';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setComparatorElement(datatype);
    }

    fieldName = 'unit';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setUnitElement(datatype);
    }

    fieldName = 'system';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = fhirParser.parseUriType(dtJson, dtSiblingJson);
      instance.setSystemElement(datatype);
    }

    fieldName = 'code';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setCodeElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Age.value Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Numerical value (with implicit precision)
   * - **Definition:** The value of the measured amount. The value includes an implicit precision in the presentation of the value.
   * - **Comment:** The implicit precision in the value should always be honored. Monetary values have their own rules for handling precision (refer to standard accounting text books).
   * - **Requirements:** Precision is handled implicitly in almost all cases of measurement.
   * - **FHIR Type:** `decimal`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private value?: DecimalType | undefined;

  /**
   * FHIR CodeSystem: QuantityComparator
   *
   * @see {@link QuantityComparatorEnum }
   */
  private readonly quantityComparatorEnum: QuantityComparatorEnum;

  /**
   * Age.comparator Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** < | <= | >= | > | ad - how to understand the value
   * - **Definition:** How the value should be understood and represented - whether the actual value is greater or less than the stated value due to measurement issues; e.g. if the comparator is "<" , then the real value is < stated value.
   * - **Requirements:** Need a framework for handling measures where the value is <5ug/L or >400mg/L due to the limitations of measuring methodology.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** true
   * - **isModifierReason:** This is labeled as &quot;Is Modifier&quot; because the comparator modifies the interpretation of the value significantly. If there is no comparator, then there is no modification of the value
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  private comparator?: EnumCodeType | undefined;

  /**
   * Age.unit Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Unit representation
   * - **Definition:** A human-readable form of the unit.
   * - **Requirements:** There are many representations for units of measure and in many contexts, particular representations are fixed and required. I.e. mcg for micrograms.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private unit?: StringType | undefined;

  /**
   * Age.system Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** System that defines coded unit form
   * - **Definition:** The identification of the system that provides the coded form of the unit.
   * - **Requirements:** Need to know the system that defines the coded form of the unit.
   * - **FHIR Type:** `uri`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private system?: UriType | undefined;

  /**
   * Age.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Coded form of the unit
   * - **Definition:** A computer processable form of the unit in some unit representation system.
   * - **Comment:** The preferred system is UCUM, but SNOMED CT can also be used (for customary units) or ISO 4217 for currency.  The context of use may additionally require a code from a particular system.
   * - **Requirements:** Need a computable form of the unit that is fixed across all forms. UCUM provides this for quantities, but SNOMED CT provides many units of interest.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code?: CodeType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `value` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getValueElement(): DecimalType {
    return this.value ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `value` property.
   *
   * @param element - the `value` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValueElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = `Invalid Age.value; Provided element is not an instance of DecimalType.`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.value = element;
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `value` property exists and has a value; `false` otherwise
   */
  public hasValueElement(): boolean {
    return isDefined<DecimalType>(this.value) && !this.value.isEmpty();
  }

  /**
   * @returns the `value` property value as a fhirDecimal if defined; else undefined
   */
  public getValue(): fhirDecimal | undefined {
    return this.value?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `value` property.
   *
   * @param value - the `value` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValue(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = `Invalid Age.value (${String(value)})`;
      this.value = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `value` property exists and has a value; `false` otherwise
   */
  public hasValue(): boolean {
    return this.hasValueElement();
  }

  /**
   * @returns the `comparator` property value as a EnumCodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public getComparatorEnumType(): EnumCodeType | undefined {
    return this.comparator;
  }

  /**
   * Assigns the provided EnumCodeType value to the `comparator` property.
   *
   * @param enumType - the `comparator` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code values
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public setComparatorEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid Age.comparator';
      assertEnumCodeType<QuantityComparatorEnum>(enumType, QuantityComparatorEnum, errMsgPrefix);
      this.comparator = enumType;
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `comparator` property exists and has a value; `false` otherwise
   */
  public hasComparatorEnumType(): boolean {
    return isDefined<EnumCodeType>(this.comparator) && !this.comparator.isEmpty() && this.comparator.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the `comparator` property value as a CodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public getComparatorElement(): CodeType | undefined {
    if (this.comparator === undefined) {
      return undefined;
    }
    return this.comparator as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the `comparator` property.
   *
   * @param element - the `comparator` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public setComparatorElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid Age.comparator; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.comparator = new EnumCodeType(element, this.quantityComparatorEnum);
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `comparator` property exists and has a value; `false` otherwise
   */
  public hasComparatorElement(): boolean {
    return this.hasComparatorEnumType();
  }

  /**
   * @returns the `comparator` property value as a fhirCode if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public getComparator(): fhirCode | undefined {
    if (this.comparator === undefined) {
      return undefined;
    }
    return this.comparator.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the `comparator` property.
   *
   * @param value - the `comparator` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public setComparator(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid Age.comparator; Provided value is not an instance of fhirCode.`;
      this.comparator = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.quantityComparatorEnum);
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `comparator` property exists and has a value; `false` otherwise
   */
  public hasComparator(): boolean {
    return this.hasComparatorEnumType();
  }

  /**
   * @returns the `unit` property value as a StringType object if defined; else an empty StringType object
   */
  public getUnitElement(): StringType {
    return this.unit ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `unit` property.
   *
   * @param element - the `unit` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUnitElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid Age.unit; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.unit = element;
    } else {
      this.unit = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `unit` property exists and has a value; `false` otherwise
   */
  public hasUnitElement(): boolean {
    return isDefined<StringType>(this.unit) && !this.unit.isEmpty();
  }

  /**
   * @returns the `unit` property value as a fhirString if defined; else undefined
   */
  public getUnit(): fhirString | undefined {
    return this.unit?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `unit` property.
   *
   * @param value - the `unit` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUnit(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid Age.unit (${String(value)})`;
      this.unit = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.unit = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `unit` property exists and has a value; `false` otherwise
   */
  public hasUnit(): boolean {
    return this.hasUnitElement();
  }

  /**
   * @returns the `system` property value as a UriType object if defined; else an empty UriType object
   */
  public getSystemElement(): UriType {
    return this.system ?? new UriType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `system` property.
   *
   * @param element - the `system` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSystemElement(element: UriType | undefined): this {
    if (isDefined<UriType>(element)) {
      const optErrMsg = `Invalid Age.system; Provided element is not an instance of UriType.`;
      assertFhirType<UriType>(element, UriType, optErrMsg);
      this.system = element;
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `system` property exists and has a value; `false` otherwise
   */
  public hasSystemElement(): boolean {
    return isDefined<UriType>(this.system) && !this.system.isEmpty();
  }

  /**
   * @returns the `system` property value as a fhirUri if defined; else undefined
   */
  public getSystem(): fhirUri | undefined {
    return this.system?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `system` property.
   *
   * @param value - the `system` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSystem(value: fhirUri | undefined): this {
    if (isDefined<fhirUri>(value)) {
      const optErrMsg = `Invalid Age.system (${String(value)})`;
      this.system = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `system` property exists and has a value; `false` otherwise
   */
  public hasSystem(): boolean {
    return this.hasSystemElement();
  }

  /**
   * @returns the `code` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getCodeElement(): CodeType {
    return this.code ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `code` property.
   *
   * @param element - the `code` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCodeElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid Age.code; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.code = element;
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `code` property exists and has a value; `false` otherwise
   */
  public hasCodeElement(): boolean {
    return isDefined<CodeType>(this.code) && !this.code.isEmpty();
  }

  /**
   * @returns the `code` property value as a fhirCode if defined; else undefined
   */
  public getCode(): fhirCode | undefined {
    return this.code?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `code` property.
   *
   * @param value - the `code` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCode(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid Age.code (${String(value)})`;
      this.code = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `code` property exists and has a value; `false` otherwise
   */
  public hasCode(): boolean {
    return this.hasCodeElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Age';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.value,
      this.comparator,
      this.unit,
      this.system,
      this.code,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Age {
    const dest = new Age();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Age): void {
    super.copyValues(dest);
    dest.value = this.value?.copy();
    dest.comparator = this.comparator?.copy();
    dest.unit = this.unit?.copy();
    dest.system = this.system?.copy();
    dest.code = this.code?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasValueElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getValueElement(), 'value', jsonObj);
    }

    if (this.hasComparatorElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getComparatorElement()!, 'comparator', jsonObj);
    }

    if (this.hasUnitElement()) {
      setFhirPrimitiveJson<fhirString>(this.getUnitElement(), 'unit', jsonObj);
    }

    if (this.hasSystemElement()) {
      setFhirPrimitiveJson<fhirUri>(this.getSystemElement(), 'system', jsonObj);
    }

    if (this.hasCodeElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getCodeElement(), 'code', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * Annotation Class
 *
 * @remarks
 * Annotation Type: A  text note which also  contains information about who made the statement and when.
 *
 * **FHIR Specification**
 * - **Short:** Text node with attribution
 * - **Definition:** A  text note which also  contains information about who made the statement and when.
 * - **Comment:** For systems that do not have structured annotations, they can simply communicate a single annotation with no author or time.  This element may need to be included in narrative because of the potential for modifying information.  *Annotations SHOULD NOT* be used to communicate "modifying" information that could be computable. (This is a SHOULD because enforcing user behavior is nearly impossible).
 * - **FHIR Version:** 5.0.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR Annotation](http://hl7.org/fhir/StructureDefinition/Annotation)
 */
export class Annotation extends DataType implements IDataType {
  constructor(text: MarkdownType | fhirMarkdown | null = null) {
    super();

    this.text = null;
    if (isDefined<MarkdownType | fhirMarkdown>(text)) {
      if (text instanceof PrimitiveType) {
        this.setTextElement(text);
      } else {
        this.setText(text);
      }
    }
  }

  /**
   * Parse the provided `Annotation` JSON to instantiate the Annotation data model.
   *
   * @param sourceJson - JSON representing FHIR `Annotation`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to Annotation
   * @returns Annotation data model or undefined for `Annotation`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Annotation | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Annotation';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new Annotation();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const classMetadata: DecoratorMetadataObject | null = Annotation[Symbol.metadata];
    const errorMessage = `DecoratorMetadataObject does not exist for Annotation`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    const missingReqdProperties: string[] = [];

    fieldName = 'author[x]';
    sourceField = `${optSourceValue}.${fieldName}`;
    const author: IDataType | undefined = fhirParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setAuthor(author);

    fieldName = 'time';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DateTimeType | undefined = fhirParser.parseDateTimeType(dtJson, dtSiblingJson);
      instance.setTimeElement(datatype);
    }

    fieldName = 'text';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: MarkdownType | undefined = fhirParser.parseMarkdownType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setTextElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_REQD_IN_JSON} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Annotation.author[x] Element
   *
   * @decorator `@ChoiceDataTypesMeta('Annotation.author[x]', ['Reference','string',]`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Individual responsible for the annotation
   * - **Definition:** The individual responsible for making the annotation.
   * - **Comment:** Organization is used when there\'s no need for specific attribution as to who made the comment.
   * - **FHIR Types:**
   *     'Reference',
   *     'string',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('Annotation.author[x]',[
    'Reference',
    'string',
  ])
  private author?: IDataType | undefined;

  /**
   * Annotation.time Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** When the annotation was made
   * - **Definition:** Indicates when this particular annotation was made.
   * - **FHIR Type:** `dateTime`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private time?: DateTimeType | undefined;

  /**
   * Annotation.text Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The annotation  - text content (as markdown)
   * - **Definition:** The text of the annotation in markdown format.
   * - **FHIR Type:** `markdown`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private text: MarkdownType | null;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `author` property value as a DataType object if defined; else undefined
   */
  public getAuthor(): IDataType | undefined {
    return this.author;
  }

  /**
   * Assigns the provided DataType object value to the `author` property.
   *
   * @decorator `@ChoiceDataTypes('Annotation.author[x]')`
   *
   * @param value - the `author` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  @ChoiceDataTypes('Annotation.author[x]')
  public setAuthor(value: IDataType | undefined): this {
    if (isDefined<IDataType>(value)) {
      // assertFhirType<IDataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.author = value;
    } else {
      this.author = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `author` property exists and has a value; `false` otherwise
   */
  public hasAuthor(): boolean {
    return isDefined<IDataType>(this.author) && !this.author.isEmpty();
  }

  // *** NOTE ***
  // Following choice datatype-specific "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the `author` property value as a Reference object if defined; else undefined
   */
  public getAuthorReference(): Reference | undefined {
    if (!isDefined<IDataType | undefined>(this.author)) {
      return undefined;
    }
    if (!(this.author instanceof Reference)) {
      throw new InvalidTypeError(
        `DataType mismatch for Annotation.author[x]: Expected Reference but encountered ${this.author.fhirType()}`,
      );
    }
    return this.author;
  }

  /**
   * @returns `true` if the `author` property exists as a Reference and has a value; `false` otherwise
   */
  public hasAuthorReference(): boolean {
    return this.hasAuthor() && this.author instanceof Reference;
  }

  /**
   * @returns the `author` property value as a StringType object if defined; else undefined
   */
  public getAuthorStringType(): StringType | undefined {
    if (!isDefined<IDataType | undefined>(this.author)) {
      return undefined;
    }
    if (!(this.author instanceof StringType)) {
      throw new InvalidTypeError(
        `DataType mismatch for Annotation.author[x]: Expected StringType but encountered ${this.author.fhirType()}`,
      );
    }
    return this.author;
  }

  /**
   * @returns `true` if the `author` property exists as a StringType and has a value; `false` otherwise
   */
  public hasAuthorStringType(): boolean {
    return this.hasAuthor() && this.author instanceof StringType;
  }

  // End of choice datatype-specific "get"/"has" methods

  /**
   * @returns the `time` property value as a DateTimeType object if defined; else an empty DateTimeType object
   */
  public getTimeElement(): DateTimeType {
    return this.time ?? new DateTimeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `time` property.
   *
   * @param element - the `time` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTimeElement(element: DateTimeType | undefined): this {
    if (isDefined<DateTimeType>(element)) {
      const optErrMsg = `Invalid Annotation.time; Provided element is not an instance of DateTimeType.`;
      assertFhirType<DateTimeType>(element, DateTimeType, optErrMsg);
      this.time = element;
    } else {
      this.time = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `time` property exists and has a value; `false` otherwise
   */
  public hasTimeElement(): boolean {
    return isDefined<DateTimeType>(this.time) && !this.time.isEmpty();
  }

  /**
   * @returns the `time` property value as a fhirDateTime if defined; else undefined
   */
  public getTime(): fhirDateTime | undefined {
    return this.time?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `time` property.
   *
   * @param value - the `time` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTime(value: fhirDateTime | undefined): this {
    if (isDefined<fhirDateTime>(value)) {
      const optErrMsg = `Invalid Annotation.time (${String(value)})`;
      this.time = new DateTimeType(parseFhirPrimitiveData(value, fhirDateTimeSchema, optErrMsg));
    } else {
      this.time = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `time` property exists and has a value; `false` otherwise
   */
  public hasTime(): boolean {
    return this.hasTimeElement();
  }

  /**
   * @returns the `text` property value as a MarkdownType object if defined; else null
   */
  public getTextElement(): MarkdownType | null {
    return this.text;
  }

  /**
   * Assigns the provided PrimitiveType value to the `text` property.
   *
   * @param element - the `text` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTextElement(element: MarkdownType): this {
    assertIsDefined<MarkdownType>(element, `Annotation.text is required`);
    const optErrMsg = `Invalid Annotation.text; Provided value is not an instance of MarkdownType.`;
    assertFhirType<MarkdownType>(element, MarkdownType, optErrMsg);
    this.text = element;
    return this;
  }

  /**
   * @returns `true` if the `text` property exists and has a value; `false` otherwise
   */
  public hasTextElement(): boolean {
    return isDefined<MarkdownType>(this.text) && !this.text.isEmpty();
  }

  /**
   * @returns the `text` property value as a fhirMarkdown if defined; else null
   */
  public getText(): fhirMarkdown | null {
    if (this.text?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.text.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the `text` property.
   *
   * @param value - the `text` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setText(value: fhirMarkdown): this {
    assertIsDefined<fhirMarkdown>(value, `Annotation.text is required`);
    const optErrMsg = `Invalid Annotation.text (${String(value)})`;
    this.text = new MarkdownType(parseFhirPrimitiveData(value, fhirMarkdownSchema, optErrMsg));
    return this;
  }

  /**
   * @returns `true` if the `text` property exists and has a value; `false` otherwise
   */
  public hasText(): boolean {
    return this.hasTextElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Annotation';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.author,
      this.time,
      this.text,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Annotation {
    const dest = new Annotation();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Annotation): void {
    super.copyValues(dest);
    dest.author = this.author?.copy() as IDataType;
    dest.time = this.time?.copy();
    dest.text = this.text ? this.text.copy() : null;
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasAuthor()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getAuthor()!, 'author', jsonObj);
    }

    if (this.hasTimeElement()) {
      setFhirPrimitiveJson<fhirDateTime>(this.getTimeElement(), 'time', jsonObj);
    }

    if (this.hasTextElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirMarkdown>(this.getTextElement()!, 'text', jsonObj);
    } else {
      missingReqdProperties.push(`Annotation.text`);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_DO_NOT_EXIST} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

/**
 * Attachment Class
 *
 * @remarks
 * Attachment Type: For referring to data content defined in other formats.
 *
 * Many models need to include data defined in other specifications that is complex and opaque to the healthcare model. This includes documents, media recordings, structured data, etc.
 *
 * **FHIR Specification**
 * - **Short:** Content in a format defined elsewhere
 * - **Definition:** For referring to data content defined in other formats.
 * - **Comment:** When providing a summary view (for example with Observation.value[x]) Attachment should be represented with a brief display text such as "Signed Procedure Consent".
 * - **FHIR Version:** 5.0.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR Attachment](http://hl7.org/fhir/StructureDefinition/Attachment)
 */
export class Attachment extends DataType implements IDataType {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided `Attachment` JSON to instantiate the Attachment data model.
   *
   * @param sourceJson - JSON representing FHIR `Attachment`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to Attachment
   * @returns Attachment data model or undefined for `Attachment`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Attachment | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Attachment';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new Attachment();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'contentType';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setContentTypeElement(datatype);
    }

    fieldName = 'language';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setLanguageElement(datatype);
    }

    fieldName = 'data';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: Base64BinaryType | undefined = fhirParser.parseBase64BinaryType(dtJson, dtSiblingJson);
      instance.setDataElement(datatype);
    }

    fieldName = 'url';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UrlType | undefined = fhirParser.parseUrlType(dtJson, dtSiblingJson);
      instance.setUrlElement(datatype);
    }

    fieldName = 'size';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: Integer64Type | undefined = fhirParser.parseInteger64Type(dtJson, dtSiblingJson);
      instance.setSizeElement(datatype);
    }

    fieldName = 'hash';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: Base64BinaryType | undefined = fhirParser.parseBase64BinaryType(dtJson, dtSiblingJson);
      instance.setHashElement(datatype);
    }

    fieldName = 'title';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setTitleElement(datatype);
    }

    fieldName = 'creation';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DateTimeType | undefined = fhirParser.parseDateTimeType(dtJson, dtSiblingJson);
      instance.setCreationElement(datatype);
    }

    fieldName = 'height';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = fhirParser.parsePositiveIntType(dtJson, dtSiblingJson);
      instance.setHeightElement(datatype);
    }

    fieldName = 'width';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = fhirParser.parsePositiveIntType(dtJson, dtSiblingJson);
      instance.setWidthElement(datatype);
    }

    fieldName = 'frames';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = fhirParser.parsePositiveIntType(dtJson, dtSiblingJson);
      instance.setFramesElement(datatype);
    }

    fieldName = 'duration';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setDurationElement(datatype);
    }

    fieldName = 'pages';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = fhirParser.parsePositiveIntType(dtJson, dtSiblingJson);
      instance.setPagesElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Attachment.contentType Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Mime type of the content, with charset etc.
   * - **Definition:** Identifies the type of the data in the attachment and allows a method to be chosen to interpret or render the data. Includes mime type parameters such as charset where appropriate.
   * - **Requirements:** Processors of the data need to be able to know how to interpret the data.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private contentType?: CodeType | undefined;

  /**
   * Attachment.language Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Human language of the content (BCP-47)
   * - **Definition:** The human language of the content. The value can be any valid value according to BCP 47.
   * - **Requirements:** Users need to be able to choose between the languages in a set of attachments.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private language?: CodeType | undefined;

  /**
   * Attachment.data Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Data inline, base64ed
   * - **Definition:** The actual data of the attachment - a sequence of bytes, base64 encoded.
   * - **Comment:** The base64-encoded data SHALL be expressed in the same character set as the base resource XML or JSON.
   * - **Requirements:** The data needs to able to be transmitted inline.
   * - **FHIR Type:** `base64Binary`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private data?: Base64BinaryType | undefined;

  /**
   * Attachment.url Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Uri where the data can be found
   * - **Definition:** A location where the data can be accessed.
   * - **Comment:** If both data and url are provided, the url SHALL point to the same content as the data contains. Urls may be relative references or may reference transient locations such as a wrapping envelope using cid: though this has ramifications for using signatures. Relative URLs are interpreted relative to the service url, like a resource reference, rather than relative to the resource itself. If a URL is provided, it SHALL resolve to actual data.
   * - **Requirements:** The data needs to be transmitted by reference.
   * - **FHIR Type:** `url`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private url?: UrlType | undefined;

  /**
   * Attachment.size Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Number of bytes of content (if url provided)
   * - **Definition:** The number of bytes of data that make up this attachment (before base64 encoding, if that is done).
   * - **Comment:** The number of bytes is redundant if the data is provided as a base64binary, but is useful if the data is provided as a url reference.
   * - **Requirements:** Representing the size allows applications to determine whether they should fetch the content automatically in advance, or refuse to fetch it at all.
   * - **FHIR Type:** `integer64`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private size?: Integer64Type | undefined;

  /**
   * Attachment.hash Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Hash of the data (sha-1, base64ed)
   * - **Definition:** The calculated hash of the data using SHA-1. Represented using base64.
   * - **Comment:** The hash is calculated on the data prior to base64 encoding, if the data is based64 encoded. The hash is not intended to support digital signatures. Where protection against malicious threats a digital signature should be considered, see [Provenance.signature](https://hl7.org/fhir/provenance-definitions.html#Provenance.signature) for mechanism to protect a resource with a digital signature.
   * - **Requirements:** Included so that applications can verify that the contents of a location have not changed due to technical failures (e.g., storage rot, transport glitch, incorrect version).
   * - **FHIR Type:** `base64Binary`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private hash?: Base64BinaryType | undefined;

  /**
   * Attachment.title Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Label to display in place of the data
   * - **Definition:** A label or set of text to display in place of the data.
   * - **Comment:** May sometimes be derived from the source filename.
   * - **Requirements:** Applications need a label to display to a human user in place of the actual data if the data cannot be rendered or perceived by the viewer.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private title?: StringType | undefined;

  /**
   * Attachment.creation Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Date attachment was first created
   * - **Definition:** The date that the attachment was first created.
   * - **Requirements:** This is often tracked as an integrity issue for use of the attachment.
   * - **FHIR Type:** `dateTime`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private creation?: DateTimeType | undefined;

  /**
   * Attachment.height Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Height of the image in pixels (photo/video)
   * - **Definition:** Height of the image in pixels (photo/video).
   * - **FHIR Type:** `positiveInt`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private height?: PositiveIntType | undefined;

  /**
   * Attachment.width Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Width of the image in pixels (photo/video)
   * - **Definition:** Width of the image in pixels (photo/video).
   * - **FHIR Type:** `positiveInt`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private width?: PositiveIntType | undefined;

  /**
   * Attachment.frames Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Number of frames if > 1 (photo)
   * - **Definition:** The number of frames in a photo. This is used with a multi-page fax, or an imaging acquisition context that takes multiple slices in a single image, or an animated gif. If there is more than one frame, this SHALL have a value in order to alert interface software that a multi-frame capable rendering widget is required.
   * - **Comment:** if the number of frames is not supplied, the value may be unknown. Applications should not assume that there is only one frame unless it is explicitly stated.
   * - **FHIR Type:** `positiveInt`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private frames?: PositiveIntType | undefined;

  /**
   * Attachment.duration Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Length in seconds (audio / video)
   * - **Definition:** The duration of the recording in seconds - for audio and video.
   * - **Comment:** The duration might differ from occurrencePeriod if recording was paused.
   * - **FHIR Type:** `decimal`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private duration?: DecimalType | undefined;

  /**
   * Attachment.pages Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Number of printed pages
   * - **Definition:** The number of pages when printed.
   * - **FHIR Type:** `positiveInt`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private pages?: PositiveIntType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `contentType` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getContentTypeElement(): CodeType {
    return this.contentType ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `contentType` property.
   *
   * @param element - the `contentType` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setContentTypeElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid Attachment.contentType; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.contentType = element;
    } else {
      this.contentType = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `contentType` property exists and has a value; `false` otherwise
   */
  public hasContentTypeElement(): boolean {
    return isDefined<CodeType>(this.contentType) && !this.contentType.isEmpty();
  }

  /**
   * @returns the `contentType` property value as a fhirCode if defined; else undefined
   */
  public getContentType(): fhirCode | undefined {
    return this.contentType?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `contentType` property.
   *
   * @param value - the `contentType` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setContentType(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid Attachment.contentType (${String(value)})`;
      this.contentType = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.contentType = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `contentType` property exists and has a value; `false` otherwise
   */
  public hasContentType(): boolean {
    return this.hasContentTypeElement();
  }

  /**
   * @returns the `language` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getLanguageElement(): CodeType {
    return this.language ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `language` property.
   *
   * @param element - the `language` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLanguageElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid Attachment.language; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.language = element;
    } else {
      this.language = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `language` property exists and has a value; `false` otherwise
   */
  public hasLanguageElement(): boolean {
    return isDefined<CodeType>(this.language) && !this.language.isEmpty();
  }

  /**
   * @returns the `language` property value as a fhirCode if defined; else undefined
   */
  public getLanguage(): fhirCode | undefined {
    return this.language?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `language` property.
   *
   * @param value - the `language` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLanguage(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid Attachment.language (${String(value)})`;
      this.language = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.language = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `language` property exists and has a value; `false` otherwise
   */
  public hasLanguage(): boolean {
    return this.hasLanguageElement();
  }

  /**
   * @returns the `data` property value as a Base64BinaryType object if defined; else an empty Base64BinaryType object
   */
  public getDataElement(): Base64BinaryType {
    return this.data ?? new Base64BinaryType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `data` property.
   *
   * @param element - the `data` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDataElement(element: Base64BinaryType | undefined): this {
    if (isDefined<Base64BinaryType>(element)) {
      const optErrMsg = `Invalid Attachment.data; Provided element is not an instance of Base64BinaryType.`;
      assertFhirType<Base64BinaryType>(element, Base64BinaryType, optErrMsg);
      this.data = element;
    } else {
      this.data = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `data` property exists and has a value; `false` otherwise
   */
  public hasDataElement(): boolean {
    return isDefined<Base64BinaryType>(this.data) && !this.data.isEmpty();
  }

  /**
   * @returns the `data` property value as a fhirBase64Binary if defined; else undefined
   */
  public getData(): fhirBase64Binary | undefined {
    return this.data?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `data` property.
   *
   * @param value - the `data` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setData(value: fhirBase64Binary | undefined): this {
    if (isDefined<fhirBase64Binary>(value)) {
      const optErrMsg = `Invalid Attachment.data (${String(value)})`;
      this.data = new Base64BinaryType(parseFhirPrimitiveData(value, fhirBase64BinarySchema, optErrMsg));
    } else {
      this.data = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `data` property exists and has a value; `false` otherwise
   */
  public hasData(): boolean {
    return this.hasDataElement();
  }

  /**
   * @returns the `url` property value as a UrlType object if defined; else an empty UrlType object
   */
  public getUrlElement(): UrlType {
    return this.url ?? new UrlType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `url` property.
   *
   * @param element - the `url` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUrlElement(element: UrlType | undefined): this {
    if (isDefined<UrlType>(element)) {
      const optErrMsg = `Invalid Attachment.url; Provided element is not an instance of UrlType.`;
      assertFhirType<UrlType>(element, UrlType, optErrMsg);
      this.url = element;
    } else {
      this.url = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `url` property exists and has a value; `false` otherwise
   */
  public hasUrlElement(): boolean {
    return isDefined<UrlType>(this.url) && !this.url.isEmpty();
  }

  /**
   * @returns the `url` property value as a fhirUrl if defined; else undefined
   */
  public getUrl(): fhirUrl | undefined {
    return this.url?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `url` property.
   *
   * @param value - the `url` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUrl(value: fhirUrl | undefined): this {
    if (isDefined<fhirUrl>(value)) {
      const optErrMsg = `Invalid Attachment.url (${String(value)})`;
      this.url = new UrlType(parseFhirPrimitiveData(value, fhirUrlSchema, optErrMsg));
    } else {
      this.url = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `url` property exists and has a value; `false` otherwise
   */
  public hasUrl(): boolean {
    return this.hasUrlElement();
  }

  /**
   * @returns the `size` property value as a Integer64Type object if defined; else an empty Integer64Type object
   */
  public getSizeElement(): Integer64Type {
    return this.size ?? new Integer64Type();
  }

  /**
   * Assigns the provided PrimitiveType value to the `size` property.
   *
   * @param element - the `size` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSizeElement(element: Integer64Type | undefined): this {
    if (isDefined<Integer64Type>(element)) {
      const optErrMsg = `Invalid Attachment.size; Provided element is not an instance of Integer64Type.`;
      assertFhirType<Integer64Type>(element, Integer64Type, optErrMsg);
      this.size = element;
    } else {
      this.size = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `size` property exists and has a value; `false` otherwise
   */
  public hasSizeElement(): boolean {
    return isDefined<Integer64Type>(this.size) && !this.size.isEmpty();
  }

  /**
   * @returns the `size` property value as a fhirInteger64 if defined; else undefined
   */
  public getSize(): fhirInteger64 | undefined {
    return this.size?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `size` property.
   *
   * @param value - the `size` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSize(value: fhirInteger64 | undefined): this {
    if (isDefined<fhirInteger64>(value)) {
      const optErrMsg = `Invalid Attachment.size (${String(value)})`;
      this.size = new Integer64Type(parseFhirPrimitiveData(value, fhirInteger64Schema, optErrMsg));
    } else {
      this.size = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `size` property exists and has a value; `false` otherwise
   */
  public hasSize(): boolean {
    return this.hasSizeElement();
  }

  /**
   * @returns the `hash` property value as a Base64BinaryType object if defined; else an empty Base64BinaryType object
   */
  public getHashElement(): Base64BinaryType {
    return this.hash ?? new Base64BinaryType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `hash` property.
   *
   * @param element - the `hash` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setHashElement(element: Base64BinaryType | undefined): this {
    if (isDefined<Base64BinaryType>(element)) {
      const optErrMsg = `Invalid Attachment.hash; Provided element is not an instance of Base64BinaryType.`;
      assertFhirType<Base64BinaryType>(element, Base64BinaryType, optErrMsg);
      this.hash = element;
    } else {
      this.hash = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `hash` property exists and has a value; `false` otherwise
   */
  public hasHashElement(): boolean {
    return isDefined<Base64BinaryType>(this.hash) && !this.hash.isEmpty();
  }

  /**
   * @returns the `hash` property value as a fhirBase64Binary if defined; else undefined
   */
  public getHash(): fhirBase64Binary | undefined {
    return this.hash?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `hash` property.
   *
   * @param value - the `hash` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setHash(value: fhirBase64Binary | undefined): this {
    if (isDefined<fhirBase64Binary>(value)) {
      const optErrMsg = `Invalid Attachment.hash (${String(value)})`;
      this.hash = new Base64BinaryType(parseFhirPrimitiveData(value, fhirBase64BinarySchema, optErrMsg));
    } else {
      this.hash = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `hash` property exists and has a value; `false` otherwise
   */
  public hasHash(): boolean {
    return this.hasHashElement();
  }

  /**
   * @returns the `title` property value as a StringType object if defined; else an empty StringType object
   */
  public getTitleElement(): StringType {
    return this.title ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `title` property.
   *
   * @param element - the `title` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTitleElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid Attachment.title; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.title = element;
    } else {
      this.title = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `title` property exists and has a value; `false` otherwise
   */
  public hasTitleElement(): boolean {
    return isDefined<StringType>(this.title) && !this.title.isEmpty();
  }

  /**
   * @returns the `title` property value as a fhirString if defined; else undefined
   */
  public getTitle(): fhirString | undefined {
    return this.title?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `title` property.
   *
   * @param value - the `title` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTitle(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid Attachment.title (${String(value)})`;
      this.title = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.title = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `title` property exists and has a value; `false` otherwise
   */
  public hasTitle(): boolean {
    return this.hasTitleElement();
  }

  /**
   * @returns the `creation` property value as a DateTimeType object if defined; else an empty DateTimeType object
   */
  public getCreationElement(): DateTimeType {
    return this.creation ?? new DateTimeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `creation` property.
   *
   * @param element - the `creation` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCreationElement(element: DateTimeType | undefined): this {
    if (isDefined<DateTimeType>(element)) {
      const optErrMsg = `Invalid Attachment.creation; Provided element is not an instance of DateTimeType.`;
      assertFhirType<DateTimeType>(element, DateTimeType, optErrMsg);
      this.creation = element;
    } else {
      this.creation = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `creation` property exists and has a value; `false` otherwise
   */
  public hasCreationElement(): boolean {
    return isDefined<DateTimeType>(this.creation) && !this.creation.isEmpty();
  }

  /**
   * @returns the `creation` property value as a fhirDateTime if defined; else undefined
   */
  public getCreation(): fhirDateTime | undefined {
    return this.creation?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `creation` property.
   *
   * @param value - the `creation` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCreation(value: fhirDateTime | undefined): this {
    if (isDefined<fhirDateTime>(value)) {
      const optErrMsg = `Invalid Attachment.creation (${String(value)})`;
      this.creation = new DateTimeType(parseFhirPrimitiveData(value, fhirDateTimeSchema, optErrMsg));
    } else {
      this.creation = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `creation` property exists and has a value; `false` otherwise
   */
  public hasCreation(): boolean {
    return this.hasCreationElement();
  }

  /**
   * @returns the `height` property value as a PositiveIntType object if defined; else an empty PositiveIntType object
   */
  public getHeightElement(): PositiveIntType {
    return this.height ?? new PositiveIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `height` property.
   *
   * @param element - the `height` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setHeightElement(element: PositiveIntType | undefined): this {
    if (isDefined<PositiveIntType>(element)) {
      const optErrMsg = `Invalid Attachment.height; Provided element is not an instance of PositiveIntType.`;
      assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
      this.height = element;
    } else {
      this.height = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `height` property exists and has a value; `false` otherwise
   */
  public hasHeightElement(): boolean {
    return isDefined<PositiveIntType>(this.height) && !this.height.isEmpty();
  }

  /**
   * @returns the `height` property value as a fhirPositiveInt if defined; else undefined
   */
  public getHeight(): fhirPositiveInt | undefined {
    return this.height?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `height` property.
   *
   * @param value - the `height` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setHeight(value: fhirPositiveInt | undefined): this {
    if (isDefined<fhirPositiveInt>(value)) {
      const optErrMsg = `Invalid Attachment.height (${String(value)})`;
      this.height = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    } else {
      this.height = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `height` property exists and has a value; `false` otherwise
   */
  public hasHeight(): boolean {
    return this.hasHeightElement();
  }

  /**
   * @returns the `width` property value as a PositiveIntType object if defined; else an empty PositiveIntType object
   */
  public getWidthElement(): PositiveIntType {
    return this.width ?? new PositiveIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `width` property.
   *
   * @param element - the `width` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setWidthElement(element: PositiveIntType | undefined): this {
    if (isDefined<PositiveIntType>(element)) {
      const optErrMsg = `Invalid Attachment.width; Provided element is not an instance of PositiveIntType.`;
      assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
      this.width = element;
    } else {
      this.width = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `width` property exists and has a value; `false` otherwise
   */
  public hasWidthElement(): boolean {
    return isDefined<PositiveIntType>(this.width) && !this.width.isEmpty();
  }

  /**
   * @returns the `width` property value as a fhirPositiveInt if defined; else undefined
   */
  public getWidth(): fhirPositiveInt | undefined {
    return this.width?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `width` property.
   *
   * @param value - the `width` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setWidth(value: fhirPositiveInt | undefined): this {
    if (isDefined<fhirPositiveInt>(value)) {
      const optErrMsg = `Invalid Attachment.width (${String(value)})`;
      this.width = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    } else {
      this.width = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `width` property exists and has a value; `false` otherwise
   */
  public hasWidth(): boolean {
    return this.hasWidthElement();
  }

  /**
   * @returns the `frames` property value as a PositiveIntType object if defined; else an empty PositiveIntType object
   */
  public getFramesElement(): PositiveIntType {
    return this.frames ?? new PositiveIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `frames` property.
   *
   * @param element - the `frames` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setFramesElement(element: PositiveIntType | undefined): this {
    if (isDefined<PositiveIntType>(element)) {
      const optErrMsg = `Invalid Attachment.frames; Provided element is not an instance of PositiveIntType.`;
      assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
      this.frames = element;
    } else {
      this.frames = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `frames` property exists and has a value; `false` otherwise
   */
  public hasFramesElement(): boolean {
    return isDefined<PositiveIntType>(this.frames) && !this.frames.isEmpty();
  }

  /**
   * @returns the `frames` property value as a fhirPositiveInt if defined; else undefined
   */
  public getFrames(): fhirPositiveInt | undefined {
    return this.frames?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `frames` property.
   *
   * @param value - the `frames` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setFrames(value: fhirPositiveInt | undefined): this {
    if (isDefined<fhirPositiveInt>(value)) {
      const optErrMsg = `Invalid Attachment.frames (${String(value)})`;
      this.frames = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    } else {
      this.frames = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `frames` property exists and has a value; `false` otherwise
   */
  public hasFrames(): boolean {
    return this.hasFramesElement();
  }

  /**
   * @returns the `duration` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getDurationElement(): DecimalType {
    return this.duration ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `duration` property.
   *
   * @param element - the `duration` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDurationElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = `Invalid Attachment.duration; Provided element is not an instance of DecimalType.`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.duration = element;
    } else {
      this.duration = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `duration` property exists and has a value; `false` otherwise
   */
  public hasDurationElement(): boolean {
    return isDefined<DecimalType>(this.duration) && !this.duration.isEmpty();
  }

  /**
   * @returns the `duration` property value as a fhirDecimal if defined; else undefined
   */
  public getDuration(): fhirDecimal | undefined {
    return this.duration?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `duration` property.
   *
   * @param value - the `duration` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDuration(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = `Invalid Attachment.duration (${String(value)})`;
      this.duration = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.duration = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `duration` property exists and has a value; `false` otherwise
   */
  public hasDuration(): boolean {
    return this.hasDurationElement();
  }

  /**
   * @returns the `pages` property value as a PositiveIntType object if defined; else an empty PositiveIntType object
   */
  public getPagesElement(): PositiveIntType {
    return this.pages ?? new PositiveIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `pages` property.
   *
   * @param element - the `pages` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPagesElement(element: PositiveIntType | undefined): this {
    if (isDefined<PositiveIntType>(element)) {
      const optErrMsg = `Invalid Attachment.pages; Provided element is not an instance of PositiveIntType.`;
      assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
      this.pages = element;
    } else {
      this.pages = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `pages` property exists and has a value; `false` otherwise
   */
  public hasPagesElement(): boolean {
    return isDefined<PositiveIntType>(this.pages) && !this.pages.isEmpty();
  }

  /**
   * @returns the `pages` property value as a fhirPositiveInt if defined; else undefined
   */
  public getPages(): fhirPositiveInt | undefined {
    return this.pages?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `pages` property.
   *
   * @param value - the `pages` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPages(value: fhirPositiveInt | undefined): this {
    if (isDefined<fhirPositiveInt>(value)) {
      const optErrMsg = `Invalid Attachment.pages (${String(value)})`;
      this.pages = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    } else {
      this.pages = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `pages` property exists and has a value; `false` otherwise
   */
  public hasPages(): boolean {
    return this.hasPagesElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Attachment';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.contentType,
      this.language,
      this.data,
      this.url,
      this.size,
      this.hash,
      this.title,
      this.creation,
      this.height,
      this.width,
      this.frames,
      this.duration,
      this.pages,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Attachment {
    const dest = new Attachment();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Attachment): void {
    super.copyValues(dest);
    dest.contentType = this.contentType?.copy();
    dest.language = this.language?.copy();
    dest.data = this.data?.copy();
    dest.url = this.url?.copy();
    dest.size = this.size?.copy();
    dest.hash = this.hash?.copy();
    dest.title = this.title?.copy();
    dest.creation = this.creation?.copy();
    dest.height = this.height?.copy();
    dest.width = this.width?.copy();
    dest.frames = this.frames?.copy();
    dest.duration = this.duration?.copy();
    dest.pages = this.pages?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasContentTypeElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getContentTypeElement(), 'contentType', jsonObj);
    }

    if (this.hasLanguageElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getLanguageElement(), 'language', jsonObj);
    }

    if (this.hasDataElement()) {
      setFhirPrimitiveJson<fhirBase64Binary>(this.getDataElement(), 'data', jsonObj);
    }

    if (this.hasUrlElement()) {
      setFhirPrimitiveJson<fhirUrl>(this.getUrlElement(), 'url', jsonObj);
    }

    if (this.hasSizeElement()) {
      setFhirPrimitiveJson<fhirInteger64>(this.getSizeElement(), 'size', jsonObj);
    }

    if (this.hasHashElement()) {
      setFhirPrimitiveJson<fhirBase64Binary>(this.getHashElement(), 'hash', jsonObj);
    }

    if (this.hasTitleElement()) {
      setFhirPrimitiveJson<fhirString>(this.getTitleElement(), 'title', jsonObj);
    }

    if (this.hasCreationElement()) {
      setFhirPrimitiveJson<fhirDateTime>(this.getCreationElement(), 'creation', jsonObj);
    }

    if (this.hasHeightElement()) {
      setFhirPrimitiveJson<fhirPositiveInt>(this.getHeightElement(), 'height', jsonObj);
    }

    if (this.hasWidthElement()) {
      setFhirPrimitiveJson<fhirPositiveInt>(this.getWidthElement(), 'width', jsonObj);
    }

    if (this.hasFramesElement()) {
      setFhirPrimitiveJson<fhirPositiveInt>(this.getFramesElement(), 'frames', jsonObj);
    }

    if (this.hasDurationElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getDurationElement(), 'duration', jsonObj);
    }

    if (this.hasPagesElement()) {
      setFhirPrimitiveJson<fhirPositiveInt>(this.getPagesElement(), 'pages', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * Availability Class
 *
 * @remarks
 * Availability Type: Availability data for an {item}.
 *
 * **FHIR Specification**
 * - **Short:** Availability data for an {item}
 * - **Definition:** Availability data for an {item}.
 * - **FHIR Version:** 5.0.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR Availability](http://hl7.org/fhir/StructureDefinition/Availability)
 */
export class Availability extends DataType implements IDataType {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided `Availability` JSON to instantiate the Availability data model.
   *
   * @param sourceJson - JSON representing FHIR `Availability`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to Availability
   * @returns Availability data model or undefined for `Availability`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Availability | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Availability';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new Availability();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';

    fieldName = 'availableTime';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: AvailabilityAvailableTimeComponent | undefined = AvailabilityAvailableTimeComponent.parse(dataElementJson, `${sourceField}[${String(idx)}]`);
        if (datatype !== undefined) {
          instance.addAvailableTime(datatype);
        }
      });
    }

    fieldName = 'notAvailableTime';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: AvailabilityNotAvailableTimeComponent | undefined = AvailabilityNotAvailableTimeComponent.parse(dataElementJson, `${sourceField}[${String(idx)}]`);
        if (datatype !== undefined) {
          instance.addNotAvailableTime(datatype);
        }
      });
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Availability.availableTime Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Times the {item} is available
   * - **Definition:** Times the {item} is available.
   * - **Requirements:** A collection of times that the {item} is available.
   * - **FHIR Type:** `Element`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private availableTime?: AvailabilityAvailableTimeComponent[] | undefined;

  /**
   * Availability.notAvailableTime Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Not available during this time due to provided reason
   * - **Definition:** Not available during this time due to provided reason.
   * - **Requirements:** The {item} is not available during this period of time due to the provided reason.
   * - **FHIR Type:** `Element`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private notAvailableTime?: AvailabilityNotAvailableTimeComponent[] | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `availableTime` property value as a AvailabilityAvailableTimeComponent array
   */
  public getAvailableTime(): AvailabilityAvailableTimeComponent[] {
    return this.availableTime ?? ([] as AvailabilityAvailableTimeComponent[]);
  }

  /**
   * Assigns the provided AvailabilityAvailableTimeComponent array value to the `availableTime` property.
   *
   * @param value - the `availableTime` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setAvailableTime(value: AvailabilityAvailableTimeComponent[] | undefined): this {
    if (isDefinedList<AvailabilityAvailableTimeComponent>(value)) {
      const optErrMsg = `Invalid Availability.availableTime; Provided value array has an element that is not an instance of AvailabilityAvailableTimeComponent.`;
      assertFhirTypeList<AvailabilityAvailableTimeComponent>(value, AvailabilityAvailableTimeComponent, optErrMsg);
      this.availableTime = value;
    } else {
      this.availableTime = undefined;
    }
    return this;
  }

  /**
   * Add the provided AvailabilityAvailableTimeComponent value to the `availableTime` array property.
   *
   * @param value - the `availableTime` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addAvailableTime(value: AvailabilityAvailableTimeComponent | undefined): this {
    if (isDefined<AvailabilityAvailableTimeComponent>(value)) {
      const optErrMsg = `Invalid Availability.availableTime; Provided element is not an instance of AvailabilityAvailableTimeComponent.`;
      assertFhirType<AvailabilityAvailableTimeComponent>(value, AvailabilityAvailableTimeComponent, optErrMsg);
      this.initAvailableTime();
      this.availableTime?.push(value);
    }
    return this;
  }

  /**
   * @returns `true` if the `availableTime` property exists and has a value; `false` otherwise
   */
  public hasAvailableTime(): boolean {
    return isDefinedList<AvailabilityAvailableTimeComponent>(this.availableTime) && this.availableTime.some((item: AvailabilityAvailableTimeComponent) => !item.isEmpty());
  }

  /**
   * Initialize the `availableTime` property
   */
  private initAvailableTime(): void {
    if(!this.hasAvailableTime()) {
      this.availableTime = [] as AvailabilityAvailableTimeComponent[];
    }
  }

  /**
   * @returns the `notAvailableTime` property value as a AvailabilityNotAvailableTimeComponent array
   */
  public getNotAvailableTime(): AvailabilityNotAvailableTimeComponent[] {
    return this.notAvailableTime ?? ([] as AvailabilityNotAvailableTimeComponent[]);
  }

  /**
   * Assigns the provided AvailabilityNotAvailableTimeComponent array value to the `notAvailableTime` property.
   *
   * @param value - the `notAvailableTime` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setNotAvailableTime(value: AvailabilityNotAvailableTimeComponent[] | undefined): this {
    if (isDefinedList<AvailabilityNotAvailableTimeComponent>(value)) {
      const optErrMsg = `Invalid Availability.notAvailableTime; Provided value array has an element that is not an instance of AvailabilityNotAvailableTimeComponent.`;
      assertFhirTypeList<AvailabilityNotAvailableTimeComponent>(value, AvailabilityNotAvailableTimeComponent, optErrMsg);
      this.notAvailableTime = value;
    } else {
      this.notAvailableTime = undefined;
    }
    return this;
  }

  /**
   * Add the provided AvailabilityNotAvailableTimeComponent value to the `notAvailableTime` array property.
   *
   * @param value - the `notAvailableTime` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addNotAvailableTime(value: AvailabilityNotAvailableTimeComponent | undefined): this {
    if (isDefined<AvailabilityNotAvailableTimeComponent>(value)) {
      const optErrMsg = `Invalid Availability.notAvailableTime; Provided element is not an instance of AvailabilityNotAvailableTimeComponent.`;
      assertFhirType<AvailabilityNotAvailableTimeComponent>(value, AvailabilityNotAvailableTimeComponent, optErrMsg);
      this.initNotAvailableTime();
      this.notAvailableTime?.push(value);
    }
    return this;
  }

  /**
   * @returns `true` if the `notAvailableTime` property exists and has a value; `false` otherwise
   */
  public hasNotAvailableTime(): boolean {
    return isDefinedList<AvailabilityNotAvailableTimeComponent>(this.notAvailableTime) && this.notAvailableTime.some((item: AvailabilityNotAvailableTimeComponent) => !item.isEmpty());
  }

  /**
   * Initialize the `notAvailableTime` property
   */
  private initNotAvailableTime(): void {
    if(!this.hasNotAvailableTime()) {
      this.notAvailableTime = [] as AvailabilityNotAvailableTimeComponent[];
    }
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Availability';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.availableTime,
      this.notAvailableTime,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Availability {
    const dest = new Availability();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Availability): void {
    super.copyValues(dest);
    const availableTimeList = copyListValues<AvailabilityAvailableTimeComponent>(this.availableTime);
    dest.availableTime = availableTimeList.length === 0 ? undefined : availableTimeList;
    const notAvailableTimeList = copyListValues<AvailabilityNotAvailableTimeComponent>(this.notAvailableTime);
    dest.notAvailableTime = notAvailableTimeList.length === 0 ? undefined : notAvailableTimeList;
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasAvailableTime()) {
      setFhirComplexListJson(this.getAvailableTime(), 'availableTime', jsonObj);
    }

    if (this.hasNotAvailableTime()) {
      setFhirComplexListJson(this.getNotAvailableTime(), 'notAvailableTime', jsonObj);
    }

    return jsonObj;
  }
}
/**
 * AvailabilityAvailableTimeComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Times the {item} is available
 * - **Definition:** Times the {item} is available.
 * - **Requirements:** A collection of times that the {item} is available.
 *
 * @category Data Models: ComplexType
 * @see [FHIR Availability](http://hl7.org/fhir/StructureDefinition/Availability)
 */
export class AvailabilityAvailableTimeComponent extends DataType implements IDataType {
  constructor() {
    super();

    this.daysOfWeekEnum = new DaysOfWeekEnum();
  }

  /**
   * Parse the provided `AvailabilityAvailableTimeComponent` JSON to instantiate the AvailabilityAvailableTimeComponent data model.
   *
   * @param sourceJson - JSON representing FHIR `AvailabilityAvailableTimeComponent`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to AvailabilityAvailableTimeComponent
   * @returns AvailabilityAvailableTimeComponent data model or undefined for `AvailabilityAvailableTimeComponent`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): AvailabilityAvailableTimeComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'AvailabilityAvailableTimeComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new AvailabilityAvailableTimeComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'daysOfWeek';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: CodeType | undefined = fhirParser.parseCodeType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addDaysOfWeekElement(datatype);
        }
      });
    }

    fieldName = 'allDay';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'boolean';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: BooleanType | undefined = fhirParser.parseBooleanType(dtJson, dtSiblingJson);
      instance.setAllDayElement(datatype);
    }

    fieldName = 'availableStartTime';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: TimeType | undefined = fhirParser.parseTimeType(dtJson, dtSiblingJson);
      instance.setAvailableStartTimeElement(datatype);
    }

    fieldName = 'availableEndTime';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: TimeType | undefined = fhirParser.parseTimeType(dtJson, dtSiblingJson);
      instance.setAvailableEndTimeElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: DaysOfWeek
   *
   * @see {@link DaysOfWeekEnum }
   */
  private readonly daysOfWeekEnum: DaysOfWeekEnum;

  /**
   * Availability.availableTime.daysOfWeek Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** mon | tue | wed | thu | fri | sat | sun
   * - **Definition:** mon | tue | wed | thu | fri | sat | sun.
   * - **Requirements:** Indicates which days of the week are available between the start and end Times.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  private daysOfWeek?: EnumCodeType[] | undefined;

  /**
   * Availability.availableTime.allDay Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Always available? i.e. 24 hour service
   * - **Definition:** Always available? i.e. 24 hour service.
   * - **Requirements:** Is this always available? (hence times are irrelevant) i.e. 24 hour service.
   * - **FHIR Type:** `boolean`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private allDay?: BooleanType | undefined;

  /**
   * Availability.availableTime.availableStartTime Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Opening time of day (ignored if allDay = true)
   * - **Definition:** Opening time of day (ignored if allDay = true).
   * - **Comment:** The timezone is expected to be specified or implied by the context this datatype is used.
   * - **Requirements:** The opening time of day. Note: If the AllDay flag is set, then this time is ignored.
   * - **FHIR Type:** `time`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private availableStartTime?: TimeType | undefined;

  /**
   * Availability.availableTime.availableEndTime Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Closing time of day (ignored if allDay = true)
   * - **Definition:** Closing time of day (ignored if allDay = true).
   * - **Comment:** The timezone is expected to be specified or implied by the context this datatype is used.
   * - **Requirements:** The closing time of day. Note: If the AllDay flag is set, then this time is ignored.
   * - **FHIR Type:** `time`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private availableEndTime?: TimeType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `daysOfWeek` property value as a EnumCodeType array
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public getDaysOfWeekEnumType(): EnumCodeType[] {
    return this.daysOfWeek ?? ([] as EnumCodeType[]);
  }

  /**
   * Assigns the provided EnumCodeType array value to the `daysOfWeek` property.
   *
   * @param enumType - the `daysOfWeek` array value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public setDaysOfWeekEnumType(enumType: EnumCodeType[] | undefined): this {
    if (isDefinedList<EnumCodeType>(enumType)) {
      const errMsgPrefix = `Invalid Availability.availableTime.daysOfWeek`;
      assertEnumCodeTypeList<DaysOfWeekEnum>(enumType, DaysOfWeekEnum, errMsgPrefix);
      this.daysOfWeek = enumType;
    } else {
      this.daysOfWeek = undefined;
    }
    return this;
  }

  /**
   * Add the provided EnumCodeType value to the `daysOfWeek` array property.
   *
   * @param enumType - the `daysOfWeek` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public addDaysOfWeekEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = `Invalid Availability.availableTime.daysOfWeek`;
      assertEnumCodeType<DaysOfWeekEnum>(enumType, DaysOfWeekEnum, errMsgPrefix);
      this.initDaysOfWeek();
      this.daysOfWeek?.push(enumType);
    }
    return this;
  }

  /**
   * @returns `true` if the `daysOfWeek` property exists and has a value; `false` otherwise
   */
  public hasDaysOfWeekEnumType(): boolean {
    return isDefinedList<EnumCodeType>(this.daysOfWeek) && this.daysOfWeek.some((item: EnumCodeType) => !item.isEmpty()) && this.daysOfWeek.every((item: EnumCodeType) => item.fhirCodeEnumeration.length > 0);
  }

  /**
   * @returns the `daysOfWeek` property value as a CodeType array
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public getDaysOfWeekElement(): CodeType[] {
    if (this.daysOfWeek === undefined) {
      return [] as CodeType[];
    }
    return this.daysOfWeek as CodeType[];
  }

  /**
   * Assigns the provided PrimitiveType array value to the `daysOfWeek` property.
   *
   * @param element - the `daysOfWeek` array value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public setDaysOfWeekElement(element: CodeType[] | undefined): this {
    if (isDefinedList<CodeType>(element)) {
      const optErrMsg = `Invalid Availability.availableTime.daysOfWeek; Provided element array has an element that is not an instance of CodeType.`;
      assertFhirTypeList<CodeType>(element, CodeType, optErrMsg);
      const enumCodeTypes = [] as EnumCodeType[];
      element.forEach((type: CodeType) => {
        enumCodeTypes.push(new EnumCodeType(type, this.daysOfWeekEnum));
      });
      this.daysOfWeek = enumCodeTypes;
    } else {
      this.daysOfWeek = undefined;
    }
    return this;
  }

  /**
   * Add the provided PrimitiveType value to the `daysOfWeek` array property.
   *
   * @param element - the `daysOfWeek` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public addDaysOfWeekElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid Availability.availableTime.daysOfWeek; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.initDaysOfWeek();
      this.daysOfWeek?.push(new EnumCodeType(element, this.daysOfWeekEnum));
    }
    return this;
  }

  /**
   * @returns `true` if the `daysOfWeek` property exists and has a value; `false` otherwise
   */
  public hasDaysOfWeekElement(): boolean {
    return this.hasDaysOfWeekEnumType();
  }

  /**
   * @returns the `daysOfWeek` property value as a fhirCode array
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public getDaysOfWeek(): fhirCode[] {
    if (this.daysOfWeek === undefined) {
      return [] as fhirCode[];
    }
    const values = [] as fhirCode[];
    for (const item of this.daysOfWeek) {
      values.push(item.fhirCode.code);
    }
    return values;
  }

  /**
   * Assigns the provided primitive value array to the `daysOfWeek` property.
   *
   * @param value - the `daysOfWeek` value array
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public setDaysOfWeek(value: fhirCode[] | undefined): this {
    if (isDefinedList<fhirCode>(value)) {
      const enumCodeTypes = [] as EnumCodeType[];
      const optErrMsg = `Invalid Availability.availableTime.daysOfWeek; Provided value is not an instance of fhirCode.`;
      value.forEach((val: fhirCode) => {
        enumCodeTypes.push(new EnumCodeType(parseFhirPrimitiveData(val, fhirCodeSchema, optErrMsg), this.daysOfWeekEnum));
      });
      this.daysOfWeek = enumCodeTypes;
    } else {
      this.daysOfWeek = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the `daysOfWeek` array property.
   *
   * @param value - the `daysOfWeek` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public addDaysOfWeek(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      this.initDaysOfWeek();
      const optErrMsg = `Invalid Availability.availableTime.daysOfWeek; Provided value is not an instance of fhirCode.`;
      this.daysOfWeek?.push(new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.daysOfWeekEnum));
    }
    return this;
  }

  /**
   * @returns `true` if the `daysOfWeek` property exists and has a value; `false` otherwise
   */
  public hasDaysOfWeek(): boolean {
    return this.hasDaysOfWeekEnumType();
  }

  /**
   * Initialize the daysOfWeek property
   */
  private initDaysOfWeek(): void {
    if(!this.hasDaysOfWeekEnumType()) {
      this.daysOfWeek = [] as EnumCodeType[];
    }
  }

  /**
   * @returns the `allDay` property value as a BooleanType object if defined; else an empty BooleanType object
   */
  public getAllDayElement(): BooleanType {
    return this.allDay ?? new BooleanType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `allDay` property.
   *
   * @param element - the `allDay` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAllDayElement(element: BooleanType | undefined): this {
    if (isDefined<BooleanType>(element)) {
      const optErrMsg = `Invalid Availability.availableTime.allDay; Provided element is not an instance of BooleanType.`;
      assertFhirType<BooleanType>(element, BooleanType, optErrMsg);
      this.allDay = element;
    } else {
      this.allDay = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `allDay` property exists and has a value; `false` otherwise
   */
  public hasAllDayElement(): boolean {
    return isDefined<BooleanType>(this.allDay) && !this.allDay.isEmpty();
  }

  /**
   * @returns the `allDay` property value as a fhirBoolean if defined; else undefined
   */
  public getAllDay(): fhirBoolean | undefined {
    return this.allDay?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `allDay` property.
   *
   * @param value - the `allDay` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAllDay(value: fhirBoolean | undefined): this {
    if (isDefined<fhirBoolean>(value)) {
      const optErrMsg = `Invalid Availability.availableTime.allDay (${String(value)})`;
      this.allDay = new BooleanType(parseFhirPrimitiveData(value, fhirBooleanSchema, optErrMsg));
    } else {
      this.allDay = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `allDay` property exists and has a value; `false` otherwise
   */
  public hasAllDay(): boolean {
    return this.hasAllDayElement();
  }

  /**
   * @returns the `availableStartTime` property value as a TimeType object if defined; else an empty TimeType object
   */
  public getAvailableStartTimeElement(): TimeType {
    return this.availableStartTime ?? new TimeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `availableStartTime` property.
   *
   * @param element - the `availableStartTime` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAvailableStartTimeElement(element: TimeType | undefined): this {
    if (isDefined<TimeType>(element)) {
      const optErrMsg = `Invalid Availability.availableTime.availableStartTime; Provided element is not an instance of TimeType.`;
      assertFhirType<TimeType>(element, TimeType, optErrMsg);
      this.availableStartTime = element;
    } else {
      this.availableStartTime = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `availableStartTime` property exists and has a value; `false` otherwise
   */
  public hasAvailableStartTimeElement(): boolean {
    return isDefined<TimeType>(this.availableStartTime) && !this.availableStartTime.isEmpty();
  }

  /**
   * @returns the `availableStartTime` property value as a fhirTime if defined; else undefined
   */
  public getAvailableStartTime(): fhirTime | undefined {
    return this.availableStartTime?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `availableStartTime` property.
   *
   * @param value - the `availableStartTime` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAvailableStartTime(value: fhirTime | undefined): this {
    if (isDefined<fhirTime>(value)) {
      const optErrMsg = `Invalid Availability.availableTime.availableStartTime (${String(value)})`;
      this.availableStartTime = new TimeType(parseFhirPrimitiveData(value, fhirTimeSchema, optErrMsg));
    } else {
      this.availableStartTime = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `availableStartTime` property exists and has a value; `false` otherwise
   */
  public hasAvailableStartTime(): boolean {
    return this.hasAvailableStartTimeElement();
  }

  /**
   * @returns the `availableEndTime` property value as a TimeType object if defined; else an empty TimeType object
   */
  public getAvailableEndTimeElement(): TimeType {
    return this.availableEndTime ?? new TimeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `availableEndTime` property.
   *
   * @param element - the `availableEndTime` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAvailableEndTimeElement(element: TimeType | undefined): this {
    if (isDefined<TimeType>(element)) {
      const optErrMsg = `Invalid Availability.availableTime.availableEndTime; Provided element is not an instance of TimeType.`;
      assertFhirType<TimeType>(element, TimeType, optErrMsg);
      this.availableEndTime = element;
    } else {
      this.availableEndTime = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `availableEndTime` property exists and has a value; `false` otherwise
   */
  public hasAvailableEndTimeElement(): boolean {
    return isDefined<TimeType>(this.availableEndTime) && !this.availableEndTime.isEmpty();
  }

  /**
   * @returns the `availableEndTime` property value as a fhirTime if defined; else undefined
   */
  public getAvailableEndTime(): fhirTime | undefined {
    return this.availableEndTime?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `availableEndTime` property.
   *
   * @param value - the `availableEndTime` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAvailableEndTime(value: fhirTime | undefined): this {
    if (isDefined<fhirTime>(value)) {
      const optErrMsg = `Invalid Availability.availableTime.availableEndTime (${String(value)})`;
      this.availableEndTime = new TimeType(parseFhirPrimitiveData(value, fhirTimeSchema, optErrMsg));
    } else {
      this.availableEndTime = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `availableEndTime` property exists and has a value; `false` otherwise
   */
  public hasAvailableEndTime(): boolean {
    return this.hasAvailableEndTimeElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Availability.availableTime';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.daysOfWeek,
      this.allDay,
      this.availableStartTime,
      this.availableEndTime,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): AvailabilityAvailableTimeComponent {
    const dest = new AvailabilityAvailableTimeComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: AvailabilityAvailableTimeComponent): void {
    super.copyValues(dest);
    const daysOfWeekList = copyListValues<EnumCodeType>(this.daysOfWeek);
    dest.daysOfWeek = daysOfWeekList.length === 0 ? undefined : daysOfWeekList;
    dest.allDay = this.allDay?.copy();
    dest.availableStartTime = this.availableStartTime?.copy();
    dest.availableEndTime = this.availableEndTime?.copy();
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasDaysOfWeekElement()) {
      setFhirPrimitiveListJson<fhirCode>(this.getDaysOfWeekElement(), 'daysOfWeek', jsonObj);
    }

    if (this.hasAllDayElement()) {
      setFhirPrimitiveJson<fhirBoolean>(this.getAllDayElement(), 'allDay', jsonObj);
    }

    if (this.hasAvailableStartTimeElement()) {
      setFhirPrimitiveJson<fhirTime>(this.getAvailableStartTimeElement(), 'availableStartTime', jsonObj);
    }

    if (this.hasAvailableEndTimeElement()) {
      setFhirPrimitiveJson<fhirTime>(this.getAvailableEndTimeElement(), 'availableEndTime', jsonObj);
    }

    return jsonObj;
  }
}
/**
 * AvailabilityNotAvailableTimeComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Not available during this time due to provided reason
 * - **Definition:** Not available during this time due to provided reason.
 * - **Requirements:** The {item} is not available during this period of time due to the provided reason.
 *
 * @category Data Models: ComplexType
 * @see [FHIR Availability](http://hl7.org/fhir/StructureDefinition/Availability)
 */
export class AvailabilityNotAvailableTimeComponent extends DataType implements IDataType {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided `AvailabilityNotAvailableTimeComponent` JSON to instantiate the AvailabilityNotAvailableTimeComponent data model.
   *
   * @param sourceJson - JSON representing FHIR `AvailabilityNotAvailableTimeComponent`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to AvailabilityNotAvailableTimeComponent
   * @returns AvailabilityNotAvailableTimeComponent data model or undefined for `AvailabilityNotAvailableTimeComponent`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): AvailabilityNotAvailableTimeComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'AvailabilityNotAvailableTimeComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new AvailabilityNotAvailableTimeComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    

    fieldName = 'description';
    sourceField = `${optSourceValue}.${fieldName}`;
    const primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setDescriptionElement(datatype);
    }

    fieldName = 'during';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Period | undefined = Period.parse(classJsonObj[fieldName]!, sourceField);
      instance.setDuring(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Availability.notAvailableTime.description Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Reason presented to the user explaining why time not available
   * - **Definition:** Reason presented to the user explaining why time not available.
   * - **Comment:** The reason will generally be provided to give the textual reason for displaying when the {item} is not available, e.g. \'Closed public holidays\' or \'Independence Day\'. In cases such as this, the `during` might not be included and local knowledge would be required in such cases (as don\'t desire to keep updating when the holiday occurs each year). e.g.2: \'Closed for maintenance over the summer\' for this example you would want to include the `during` period, unless this was a university hospital and the "summer" period was well known, but would recommend its inclusion anyway.
   * - **Requirements:** The reason that can be presented to the user as to why this time is not available.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private description?: StringType | undefined;

  /**
   * Availability.notAvailableTime.during Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Service not available during this period
   * - **Definition:** Service not available during this period.
   * - **Requirements:** The {item} is not available (seasonally or for a public holiday) during this period.
   * - **FHIR Type:** `Period`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private during?: Period | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `description` property value as a StringType object if defined; else an empty StringType object
   */
  public getDescriptionElement(): StringType {
    return this.description ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `description` property.
   *
   * @param element - the `description` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDescriptionElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid Availability.notAvailableTime.description; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.description = element;
    } else {
      this.description = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `description` property exists and has a value; `false` otherwise
   */
  public hasDescriptionElement(): boolean {
    return isDefined<StringType>(this.description) && !this.description.isEmpty();
  }

  /**
   * @returns the `description` property value as a fhirString if defined; else undefined
   */
  public getDescription(): fhirString | undefined {
    return this.description?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `description` property.
   *
   * @param value - the `description` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDescription(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid Availability.notAvailableTime.description (${String(value)})`;
      this.description = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.description = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `description` property exists and has a value; `false` otherwise
   */
  public hasDescription(): boolean {
    return this.hasDescriptionElement();
  }

  /**
   * @returns the `during` property value as a Period object if defined; else an empty Period object
   */
  public getDuring(): Period {
    return this.during ?? new Period();
  }

  /**
   * Assigns the provided During object value to the `during` property.
   *
   * @param value - the `during` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setDuring(value: Period | undefined): this {
    if (isDefined<Period>(value)) {
      const optErrMsg = `Invalid Availability.notAvailableTime.during; Provided element is not an instance of Period.`;
      assertFhirType<Period>(value, Period, optErrMsg);
      this.during = value;
    } else {
      this.during = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `during` property exists and has a value; `false` otherwise
   */
  public hasDuring(): boolean {
    return isDefined<Period>(this.during) && !this.during.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Availability.notAvailableTime';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.description,
      this.during,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): AvailabilityNotAvailableTimeComponent {
    const dest = new AvailabilityNotAvailableTimeComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: AvailabilityNotAvailableTimeComponent): void {
    super.copyValues(dest);
    dest.description = this.description?.copy();
    dest.during = this.during?.copy();
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasDescriptionElement()) {
      setFhirPrimitiveJson<fhirString>(this.getDescriptionElement(), 'description', jsonObj);
    }

    if (this.hasDuring()) {
      setFhirComplexJson(this.getDuring(), 'during', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * CodeableReference Class
 *
 * @remarks
 * CodeableReference Type: A reference to a resource (by instance), or instead, a reference to a concept defined in a terminology or ontology (by class).
 *
 * This is a common pattern in record keeping - a reference may be made to a specific condition, observation, plan, or definition, or a reference may be made to a general concept defined in a knowledge base somewhere.
 *
 * **FHIR Specification**
 * - **Short:** Reference to a resource or a concept
 * - **Definition:** A reference to a resource (by instance), or instead, a reference to a concept defined in a terminology or ontology (by class).
 * - **FHIR Version:** 5.0.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR CodeableReference](http://hl7.org/fhir/StructureDefinition/CodeableReference)
 */
export class CodeableReference extends DataType implements IDataType {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided `CodeableReference` JSON to instantiate the CodeableReference data model.
   *
   * @param sourceJson - JSON representing FHIR `CodeableReference`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to CodeableReference
   * @returns CodeableReference data model or undefined for `CodeableReference`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): CodeableReference | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'CodeableReference';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new CodeableReference();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';

    fieldName = 'concept';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = CodeableConcept.parse(classJsonObj[fieldName]!, sourceField);
      instance.setConcept(datatype);
    }

    fieldName = 'reference';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = Reference.parse(classJsonObj[fieldName]!, sourceField);
      instance.setReference(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * CodeableReference.concept Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Reference to a concept (by class)
   * - **Definition:** A reference to a concept - e.g. the information is identified by its general class to the degree of precision found in the terminology.
   * - **FHIR Type:** `CodeableConcept`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private concept?: CodeableConcept | undefined;

  /**
   * CodeableReference.reference Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Reference to a resource (by instance)
   * - **Definition:** A reference to a resource the provides exact details about the information being referenced.
   * - **FHIR Type:** `Reference`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private reference?: Reference | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `concept` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getConcept(): CodeableConcept {
    return this.concept ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Concept object value to the `concept` property.
   *
   * @param value - the `concept` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setConcept(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = `Invalid CodeableReference.concept; Provided element is not an instance of CodeableConcept.`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.concept = value;
    } else {
      this.concept = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `concept` property exists and has a value; `false` otherwise
   */
  public hasConcept(): boolean {
    return isDefined<CodeableConcept>(this.concept) && !this.concept.isEmpty();
  }

  /**
   * @returns the `reference` property value as a Reference object; else an empty Reference object
   */
  public getReference(): Reference {
    return this.reference ?? new Reference();
  }

  /**
   * Assigns the provided Reference object value to the `reference` property.
   *
   * @decorator `@ReferenceTargets('CodeableReference.reference', [])`
   *
   * @param value - the `reference` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('CodeableReference.reference', [])
  public setReference(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.reference = value;
    } else {
      this.reference = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `reference` property exists and has a value; `false` otherwise
   */
  public hasReference(): boolean {
    return isDefined<Reference>(this.reference) && !this.reference.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'CodeableReference';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.concept,
      this.reference,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): CodeableReference {
    const dest = new CodeableReference();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: CodeableReference): void {
    super.copyValues(dest);
    dest.concept = this.concept?.copy();
    dest.reference = this.reference?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasConcept()) {
      setFhirComplexJson(this.getConcept(), 'concept', jsonObj);
    }

    if (this.hasReference()) {
      setFhirComplexJson(this.getReference(), 'reference', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * ContactDetail Class
 *
 * @remarks
 * ContactDetail Type: Specifies contact information for a person or organization.
 *
 * Need to track contact information in the same way across multiple resources.
 *
 * **FHIR Specification**
 * - **Short:** Contact information
 * - **Definition:** Specifies contact information for a person or organization.
 * - **FHIR Version:** 5.0.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR ContactDetail](http://hl7.org/fhir/StructureDefinition/ContactDetail)
 */
export class ContactDetail extends DataType implements IDataType {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided `ContactDetail` JSON to instantiate the ContactDetail data model.
   *
   * @param sourceJson - JSON representing FHIR `ContactDetail`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to ContactDetail
   * @returns ContactDetail data model or undefined for `ContactDetail`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): ContactDetail | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'ContactDetail';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new ContactDetail();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    

    fieldName = 'name';
    sourceField = `${optSourceValue}.${fieldName}`;
    const primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setNameElement(datatype);
    }

    fieldName = 'telecom';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: ContactPoint | undefined = ContactPoint.parse(dataElementJson, `${sourceField}[${String(idx)}]`);
        if (datatype !== undefined) {
          instance.addTelecom(datatype);
        }
      });
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * ContactDetail.name Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Name of an individual to contact
   * - **Definition:** The name of an individual to contact.
   * - **Comment:** If there is no named individual, the telecom information is for the organization as a whole.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private name?: StringType | undefined;

  /**
   * ContactDetail.telecom Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Contact details for individual or organization
   * - **Definition:** The contact details for the individual (if a name was provided) or the organization.
   * - **FHIR Type:** `ContactPoint`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private telecom?: ContactPoint[] | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `name` property value as a StringType object if defined; else an empty StringType object
   */
  public getNameElement(): StringType {
    return this.name ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `name` property.
   *
   * @param element - the `name` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setNameElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid ContactDetail.name; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.name = element;
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `name` property exists and has a value; `false` otherwise
   */
  public hasNameElement(): boolean {
    return isDefined<StringType>(this.name) && !this.name.isEmpty();
  }

  /**
   * @returns the `name` property value as a fhirString if defined; else undefined
   */
  public getName(): fhirString | undefined {
    return this.name?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `name` property.
   *
   * @param value - the `name` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setName(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid ContactDetail.name (${String(value)})`;
      this.name = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `name` property exists and has a value; `false` otherwise
   */
  public hasName(): boolean {
    return this.hasNameElement();
  }

  /**
   * @returns the `telecom` property value as a ContactPoint array
   */
  public getTelecom(): ContactPoint[] {
    return this.telecom ?? ([] as ContactPoint[]);
  }

  /**
   * Assigns the provided ContactPoint array value to the `telecom` property.
   *
   * @param value - the `telecom` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setTelecom(value: ContactPoint[] | undefined): this {
    if (isDefinedList<ContactPoint>(value)) {
      const optErrMsg = `Invalid ContactDetail.telecom; Provided value array has an element that is not an instance of ContactPoint.`;
      assertFhirTypeList<ContactPoint>(value, ContactPoint, optErrMsg);
      this.telecom = value;
    } else {
      this.telecom = undefined;
    }
    return this;
  }

  /**
   * Add the provided ContactPoint value to the `telecom` array property.
   *
   * @param value - the `telecom` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addTelecom(value: ContactPoint | undefined): this {
    if (isDefined<ContactPoint>(value)) {
      const optErrMsg = `Invalid ContactDetail.telecom; Provided element is not an instance of ContactPoint.`;
      assertFhirType<ContactPoint>(value, ContactPoint, optErrMsg);
      this.initTelecom();
      this.telecom?.push(value);
    }
    return this;
  }

  /**
   * @returns `true` if the `telecom` property exists and has a value; `false` otherwise
   */
  public hasTelecom(): boolean {
    return isDefinedList<ContactPoint>(this.telecom) && this.telecom.some((item: ContactPoint) => !item.isEmpty());
  }

  /**
   * Initialize the `telecom` property
   */
  private initTelecom(): void {
    if(!this.hasTelecom()) {
      this.telecom = [] as ContactPoint[];
    }
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'ContactDetail';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.name,
      this.telecom,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): ContactDetail {
    const dest = new ContactDetail();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: ContactDetail): void {
    super.copyValues(dest);
    dest.name = this.name?.copy();
    const telecomList = copyListValues<ContactPoint>(this.telecom);
    dest.telecom = telecomList.length === 0 ? undefined : telecomList;
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasNameElement()) {
      setFhirPrimitiveJson<fhirString>(this.getNameElement(), 'name', jsonObj);
    }

    if (this.hasTelecom()) {
      setFhirComplexListJson(this.getTelecom(), 'telecom', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * ContactPoint Class
 *
 * @remarks
 * ContactPoint Type: Details for all kinds of technology mediated contact points for a person or organization, including telephone, email, etc.
 *
 * Need to track phone, fax, mobile, sms numbers, email addresses, twitter tags, etc.
 *
 * **FHIR Specification**
 * - **Short:** Details of a Technology mediated contact point (phone, fax, email, etc.)
 * - **Definition:** Details for all kinds of technology mediated contact points for a person or organization, including telephone, email, etc.
 * - **FHIR Version:** 5.0.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR ContactPoint](http://hl7.org/fhir/StructureDefinition/ContactPoint)
 */
export class ContactPoint extends DataType implements IDataType {
  constructor() {
    super();

    this.contactPointSystemEnum = new ContactPointSystemEnum();
    this.contactPointUseEnum = new ContactPointUseEnum();
  }

  /**
   * Parse the provided `ContactPoint` JSON to instantiate the ContactPoint data model.
   *
   * @param sourceJson - JSON representing FHIR `ContactPoint`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to ContactPoint
   * @returns ContactPoint data model or undefined for `ContactPoint`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): ContactPoint | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'ContactPoint';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new ContactPoint();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'system';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setSystemElement(datatype);
    }

    fieldName = 'value';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setValueElement(datatype);
    }

    fieldName = 'use';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setUseElement(datatype);
    }

    fieldName = 'rank';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = fhirParser.parsePositiveIntType(dtJson, dtSiblingJson);
      instance.setRankElement(datatype);
    }

    fieldName = 'period';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Period | undefined = Period.parse(classJsonObj[fieldName]!, sourceField);
      instance.setPeriod(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: ContactPointSystem
   *
   * @see {@link ContactPointSystemEnum }
   */
  private readonly contactPointSystemEnum: ContactPointSystemEnum;

  /**
   * ContactPoint.system Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** phone | fax | email | pager | url | sms | other
   * - **Definition:** Telecommunications form for contact point - what communications system is required to make use of the contact.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link ContactPointSystemEnum }
   */
  private system?: EnumCodeType | undefined;

  /**
   * ContactPoint.value Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The actual contact point details
   * - **Definition:** The actual contact point details, in a form that is meaningful to the designated communication system (i.e. phone number or email address).
   * - **Comment:** Additional text data such as phone extension numbers, or notes about use of the contact are sometimes included in the value.
   * - **Requirements:** Need to support legacy numbers that are not in a tightly controlled format.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private value?: StringType | undefined;

  /**
   * FHIR CodeSystem: ContactPointUse
   *
   * @see {@link ContactPointUseEnum }
   */
  private readonly contactPointUseEnum: ContactPointUseEnum;

  /**
   * ContactPoint.use Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** home | work | temp | old | mobile - purpose of this contact point
   * - **Definition:** Identifies the purpose for the contact point.
   * - **Comment:** Applications can assume that a contact is current unless it explicitly says that it is temporary or old.
   * - **Requirements:** Need to track the way a person uses this contact, so a user can choose which is appropriate for their purpose.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** true
   * - **isModifierReason:** This is labeled as &quot;Is Modifier&quot; because applications should not mistake a temporary or old contact etc.for a current/permanent one
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link ContactPointUseEnum }
   */
  private use?: EnumCodeType | undefined;

  /**
   * ContactPoint.rank Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Specify preferred order of use (1 = highest)
   * - **Definition:** Specifies a preferred order in which to use a set of contacts. ContactPoints with lower rank values are more preferred than those with higher rank values.
   * - **Comment:** Note that rank does not necessarily follow the order in which the contacts are represented in the instance. Ranks need not be unique.  E.g. it\'s possible to have multiple contacts with rank=1.  If the ranks have different systems or uses, this would be interpreted to mean "X is my most preferred phone number, Y is my most preferred email address" or "X is my preferred home email and Y is my preferred work email".  If the system and use for equally-ranked contacts are the same, then the level of preference is equivalent for both repetitions.  Ranks need not be sequential and not all repetitions must have a rank.  For example, it\'s possible to have 4 contacts with ranks of 2, 5 and two with no rank specified.  That would be interpreted to mean the first is preferred over the second and no preference stated for the remaining contacts.
   * - **FHIR Type:** `positiveInt`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private rank?: PositiveIntType | undefined;

  /**
   * ContactPoint.period Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Time period when the contact point was/is in use
   * - **Definition:** Time period when the contact point was/is in use.
   * - **FHIR Type:** `Period`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private period?: Period | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `system` property value as a EnumCodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link ContactPointSystemEnum }
   */
  public getSystemEnumType(): EnumCodeType | undefined {
    return this.system;
  }

  /**
   * Assigns the provided EnumCodeType value to the `system` property.
   *
   * @param enumType - the `system` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code values
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ContactPointSystemEnum }
   */
  public setSystemEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid ContactPoint.system';
      assertEnumCodeType<ContactPointSystemEnum>(enumType, ContactPointSystemEnum, errMsgPrefix);
      this.system = enumType;
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `system` property exists and has a value; `false` otherwise
   */
  public hasSystemEnumType(): boolean {
    return isDefined<EnumCodeType>(this.system) && !this.system.isEmpty() && this.system.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the `system` property value as a CodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link ContactPointSystemEnum }
   */
  public getSystemElement(): CodeType | undefined {
    if (this.system === undefined) {
      return undefined;
    }
    return this.system as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the `system` property.
   *
   * @param element - the `system` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ContactPointSystemEnum }
   */
  public setSystemElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid ContactPoint.system; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.system = new EnumCodeType(element, this.contactPointSystemEnum);
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `system` property exists and has a value; `false` otherwise
   */
  public hasSystemElement(): boolean {
    return this.hasSystemEnumType();
  }

  /**
   * @returns the `system` property value as a fhirCode if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link ContactPointSystemEnum }
   */
  public getSystem(): fhirCode | undefined {
    if (this.system === undefined) {
      return undefined;
    }
    return this.system.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the `system` property.
   *
   * @param value - the `system` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link ContactPointSystemEnum }
   */
  public setSystem(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid ContactPoint.system; Provided value is not an instance of fhirCode.`;
      this.system = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.contactPointSystemEnum);
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `system` property exists and has a value; `false` otherwise
   */
  public hasSystem(): boolean {
    return this.hasSystemEnumType();
  }

  /**
   * @returns the `value` property value as a StringType object if defined; else an empty StringType object
   */
  public getValueElement(): StringType {
    return this.value ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `value` property.
   *
   * @param element - the `value` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValueElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid ContactPoint.value; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.value = element;
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `value` property exists and has a value; `false` otherwise
   */
  public hasValueElement(): boolean {
    return isDefined<StringType>(this.value) && !this.value.isEmpty();
  }

  /**
   * @returns the `value` property value as a fhirString if defined; else undefined
   */
  public getValue(): fhirString | undefined {
    return this.value?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `value` property.
   *
   * @param value - the `value` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValue(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid ContactPoint.value (${String(value)})`;
      this.value = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `value` property exists and has a value; `false` otherwise
   */
  public hasValue(): boolean {
    return this.hasValueElement();
  }

  /**
   * @returns the `use` property value as a EnumCodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link ContactPointUseEnum }
   */
  public getUseEnumType(): EnumCodeType | undefined {
    return this.use;
  }

  /**
   * Assigns the provided EnumCodeType value to the `use` property.
   *
   * @param enumType - the `use` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code values
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ContactPointUseEnum }
   */
  public setUseEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid ContactPoint.use';
      assertEnumCodeType<ContactPointUseEnum>(enumType, ContactPointUseEnum, errMsgPrefix);
      this.use = enumType;
    } else {
      this.use = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `use` property exists and has a value; `false` otherwise
   */
  public hasUseEnumType(): boolean {
    return isDefined<EnumCodeType>(this.use) && !this.use.isEmpty() && this.use.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the `use` property value as a CodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link ContactPointUseEnum }
   */
  public getUseElement(): CodeType | undefined {
    if (this.use === undefined) {
      return undefined;
    }
    return this.use as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the `use` property.
   *
   * @param element - the `use` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ContactPointUseEnum }
   */
  public setUseElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid ContactPoint.use; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.use = new EnumCodeType(element, this.contactPointUseEnum);
    } else {
      this.use = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `use` property exists and has a value; `false` otherwise
   */
  public hasUseElement(): boolean {
    return this.hasUseEnumType();
  }

  /**
   * @returns the `use` property value as a fhirCode if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link ContactPointUseEnum }
   */
  public getUse(): fhirCode | undefined {
    if (this.use === undefined) {
      return undefined;
    }
    return this.use.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the `use` property.
   *
   * @param value - the `use` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link ContactPointUseEnum }
   */
  public setUse(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid ContactPoint.use; Provided value is not an instance of fhirCode.`;
      this.use = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.contactPointUseEnum);
    } else {
      this.use = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `use` property exists and has a value; `false` otherwise
   */
  public hasUse(): boolean {
    return this.hasUseEnumType();
  }

  /**
   * @returns the `rank` property value as a PositiveIntType object if defined; else an empty PositiveIntType object
   */
  public getRankElement(): PositiveIntType {
    return this.rank ?? new PositiveIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `rank` property.
   *
   * @param element - the `rank` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setRankElement(element: PositiveIntType | undefined): this {
    if (isDefined<PositiveIntType>(element)) {
      const optErrMsg = `Invalid ContactPoint.rank; Provided element is not an instance of PositiveIntType.`;
      assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
      this.rank = element;
    } else {
      this.rank = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `rank` property exists and has a value; `false` otherwise
   */
  public hasRankElement(): boolean {
    return isDefined<PositiveIntType>(this.rank) && !this.rank.isEmpty();
  }

  /**
   * @returns the `rank` property value as a fhirPositiveInt if defined; else undefined
   */
  public getRank(): fhirPositiveInt | undefined {
    return this.rank?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `rank` property.
   *
   * @param value - the `rank` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setRank(value: fhirPositiveInt | undefined): this {
    if (isDefined<fhirPositiveInt>(value)) {
      const optErrMsg = `Invalid ContactPoint.rank (${String(value)})`;
      this.rank = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    } else {
      this.rank = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `rank` property exists and has a value; `false` otherwise
   */
  public hasRank(): boolean {
    return this.hasRankElement();
  }

  /**
   * @returns the `period` property value as a Period object if defined; else an empty Period object
   */
  public getPeriod(): Period {
    return this.period ?? new Period();
  }

  /**
   * Assigns the provided Period object value to the `period` property.
   *
   * @param value - the `period` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setPeriod(value: Period | undefined): this {
    if (isDefined<Period>(value)) {
      const optErrMsg = `Invalid ContactPoint.period; Provided element is not an instance of Period.`;
      assertFhirType<Period>(value, Period, optErrMsg);
      this.period = value;
    } else {
      this.period = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `period` property exists and has a value; `false` otherwise
   */
  public hasPeriod(): boolean {
    return isDefined<Period>(this.period) && !this.period.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'ContactPoint';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.system,
      this.value,
      this.use,
      this.rank,
      this.period,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): ContactPoint {
    const dest = new ContactPoint();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: ContactPoint): void {
    super.copyValues(dest);
    dest.system = this.system?.copy();
    dest.value = this.value?.copy();
    dest.use = this.use?.copy();
    dest.rank = this.rank?.copy();
    dest.period = this.period?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasSystemElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getSystemElement()!, 'system', jsonObj);
    }

    if (this.hasValueElement()) {
      setFhirPrimitiveJson<fhirString>(this.getValueElement(), 'value', jsonObj);
    }

    if (this.hasUseElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getUseElement()!, 'use', jsonObj);
    }

    if (this.hasRankElement()) {
      setFhirPrimitiveJson<fhirPositiveInt>(this.getRankElement(), 'rank', jsonObj);
    }

    if (this.hasPeriod()) {
      setFhirComplexJson(this.getPeriod(), 'period', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * Contributor Class
 *
 * @remarks
 * Contributor Type: A contributor to the content of a knowledge asset, including authors, editors, reviewers, and endorsers.
 *
 * Need to track contributor information in the same way across multiple resources.
 *
 * **FHIR Specification**
 * - **Short:** Contributor information
 * - **Definition:** A contributor to the content of a knowledge asset, including authors, editors, reviewers, and endorsers.
 * - **FHIR Version:** 5.0.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR Contributor](http://hl7.org/fhir/StructureDefinition/Contributor)
 */
export class Contributor extends DataType implements IDataType {
  constructor(type_: EnumCodeType | CodeType | fhirCode | null = null, name: StringType | fhirString | null = null) {
    super();

    this.contributorTypeEnum = new ContributorTypeEnum();

    this.type_ = constructorCodeValueAsEnumCodeType<ContributorTypeEnum>(
      type_,
      ContributorTypeEnum,
      this.contributorTypeEnum,
      'Contributor.type',
    );

    this.name = null;
    if (isDefined<StringType | fhirString>(name)) {
      if (name instanceof PrimitiveType) {
        this.setNameElement(name);
      } else {
        this.setName(name);
      }
    }
  }

  /**
   * Parse the provided `Contributor` JSON to instantiate the Contributor data model.
   *
   * @param sourceJson - JSON representing FHIR `Contributor`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to Contributor
   * @returns Contributor data model or undefined for `Contributor`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Contributor | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Contributor';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new Contributor();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'type';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setTypeElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'name';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setNameElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'contact';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: ContactDetail | undefined = ContactDetail.parse(dataElementJson, `${sourceField}[${String(idx)}]`);
        if (datatype !== undefined) {
          instance.addContact(datatype);
        }
      });
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_REQD_IN_JSON} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: ContributorType
   *
   * @see {@link ContributorTypeEnum }
   */
  private readonly contributorTypeEnum: ContributorTypeEnum;

  /**
   * Contributor.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** author | editor | reviewer | endorser
   * - **Definition:** The type of contributor.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link ContributorTypeEnum }
   */
  private type_: EnumCodeType | null;

  /**
   * Contributor.name Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Who contributed the content
   * - **Definition:** The name of the individual or organization responsible for the contribution.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private name: StringType | null;

  /**
   * Contributor.contact Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Contact details of the contributor
   * - **Definition:** Contact details to assist a user in finding and communicating with the contributor.
   * - **FHIR Type:** `ContactDetail`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private contact?: ContactDetail[] | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `type_` property value as a EnumCodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link ContributorTypeEnum }
   */
  public getTypeEnumType(): EnumCodeType | null {
    return this.type_;
  }

  /**
   * Assigns the provided EnumCodeType value to the `type_` property.
   *
   * @param enumType - the `type_` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ContributorTypeEnum }
   */
  public setTypeEnumType(enumType: EnumCodeType): this {
    assertIsDefined<EnumCodeType>(enumType, `Contributor.type is required`);
    const errMsgPrefix = `Invalid Contributor.type`;
    assertEnumCodeType<ContributorTypeEnum>(enumType, ContributorTypeEnum, errMsgPrefix);
    this.type_ = enumType;
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasTypeEnumType(): boolean {
    return isDefined<EnumCodeType>(this.type_) && !this.type_.isEmpty() && this.type_.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the `type_` property value as a CodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link ContributorTypeEnum }
   */
  public getTypeElement(): CodeType | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_ as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the `type_` property.
   *
   * @param element - the `type_` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ContributorTypeEnum }
   */
  public setTypeElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, `Contributor.type is required`);
    const optErrMsg = `Invalid Contributor.type; Provided value is not an instance of CodeType.`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.type_ = new EnumCodeType(element, this.contributorTypeEnum);
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasTypeElement(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the `type_` property value as a fhirCode if defined; else null
   *
   * @see CodeSystem Enumeration: {@link ContributorTypeEnum }
   */
  public getType(): fhirCode | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the `type_` property.
   *
   * @param value - the `type_` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link ContributorTypeEnum }
   */
  public setType(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, `Contributor.type is required`);
    const optErrMsg = `Invalid Contributor.type (${String(value)})`;
    this.type_ = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.contributorTypeEnum);
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasType(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the `name` property value as a StringType object if defined; else null
   */
  public getNameElement(): StringType | null {
    return this.name;
  }

  /**
   * Assigns the provided PrimitiveType value to the `name` property.
   *
   * @param element - the `name` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setNameElement(element: StringType): this {
    assertIsDefined<StringType>(element, `Contributor.name is required`);
    const optErrMsg = `Invalid Contributor.name; Provided value is not an instance of StringType.`;
    assertFhirType<StringType>(element, StringType, optErrMsg);
    this.name = element;
    return this;
  }

  /**
   * @returns `true` if the `name` property exists and has a value; `false` otherwise
   */
  public hasNameElement(): boolean {
    return isDefined<StringType>(this.name) && !this.name.isEmpty();
  }

  /**
   * @returns the `name` property value as a fhirString if defined; else null
   */
  public getName(): fhirString | null {
    if (this.name?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.name.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the `name` property.
   *
   * @param value - the `name` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setName(value: fhirString): this {
    assertIsDefined<fhirString>(value, `Contributor.name is required`);
    const optErrMsg = `Invalid Contributor.name (${String(value)})`;
    this.name = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    return this;
  }

  /**
   * @returns `true` if the `name` property exists and has a value; `false` otherwise
   */
  public hasName(): boolean {
    return this.hasNameElement();
  }

  /**
   * @returns the `contact` property value as a ContactDetail array
   */
  public getContact(): ContactDetail[] {
    return this.contact ?? ([] as ContactDetail[]);
  }

  /**
   * Assigns the provided ContactDetail array value to the `contact` property.
   *
   * @param value - the `contact` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setContact(value: ContactDetail[] | undefined): this {
    if (isDefinedList<ContactDetail>(value)) {
      const optErrMsg = `Invalid Contributor.contact; Provided value array has an element that is not an instance of ContactDetail.`;
      assertFhirTypeList<ContactDetail>(value, ContactDetail, optErrMsg);
      this.contact = value;
    } else {
      this.contact = undefined;
    }
    return this;
  }

  /**
   * Add the provided ContactDetail value to the `contact` array property.
   *
   * @param value - the `contact` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addContact(value: ContactDetail | undefined): this {
    if (isDefined<ContactDetail>(value)) {
      const optErrMsg = `Invalid Contributor.contact; Provided element is not an instance of ContactDetail.`;
      assertFhirType<ContactDetail>(value, ContactDetail, optErrMsg);
      this.initContact();
      this.contact?.push(value);
    }
    return this;
  }

  /**
   * @returns `true` if the `contact` property exists and has a value; `false` otherwise
   */
  public hasContact(): boolean {
    return isDefinedList<ContactDetail>(this.contact) && this.contact.some((item: ContactDetail) => !item.isEmpty());
  }

  /**
   * Initialize the `contact` property
   */
  private initContact(): void {
    if(!this.hasContact()) {
      this.contact = [] as ContactDetail[];
    }
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Contributor';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.type_,
      this.name,
      this.contact,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Contributor {
    const dest = new Contributor();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Contributor): void {
    super.copyValues(dest);
    dest.type_ = this.type_ ? this.type_.copy() : null;
    dest.name = this.name ? this.name.copy() : null;
    const contactList = copyListValues<ContactDetail>(this.contact);
    dest.contact = contactList.length === 0 ? undefined : contactList;
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasTypeElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getTypeElement()!, 'type', jsonObj);
    } else {
      missingReqdProperties.push(`Contributor.type`);
    }

    if (this.hasNameElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirString>(this.getNameElement()!, 'name', jsonObj);
    } else {
      missingReqdProperties.push(`Contributor.name`);
    }

    if (this.hasContact()) {
      setFhirComplexListJson(this.getContact(), 'contact', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_DO_NOT_EXIST} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

/**
 * Count Class
 *
 * @remarks
 * Count Type: A measured amount (or an amount that can potentially be measured). Note that measured amounts include amounts that are not precisely quantified, including amounts involving arbitrary units and floating currencies.
 *
 * Need to able to capture all sorts of measured values, even if the measured value are not precisely quantified. Values include exact measures such as 3.51g, customary units such as 3 tablets, and currencies such as $100.32USD.
 *
 * **FHIR Specification**
 * - **Short:** A measured or measurable amount
 * - **Definition:** A measured amount (or an amount that can potentially be measured). Note that measured amounts include amounts that are not precisely quantified, including amounts involving arbitrary units and floating currencies.
 * - **Comment:** The context of use may frequently define what kind of quantity this is and therefore what kind of units can be used. The context of use may also restrict the values for the comparator.
 * - **FHIR Version:** 5.0.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR Count](http://hl7.org/fhir/StructureDefinition/Count)
 */
export class Count extends DataType implements IDataType {
  constructor() {
    super();

    this.quantityComparatorEnum = new QuantityComparatorEnum();
  }

  /**
   * Parse the provided `Count` JSON to instantiate the Count data model.
   *
   * @param sourceJson - JSON representing FHIR `Count`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to Count
   * @returns Count data model or undefined for `Count`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Count | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Count';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new Count();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'value';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setValueElement(datatype);
    }

    fieldName = 'comparator';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setComparatorElement(datatype);
    }

    fieldName = 'unit';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setUnitElement(datatype);
    }

    fieldName = 'system';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = fhirParser.parseUriType(dtJson, dtSiblingJson);
      instance.setSystemElement(datatype);
    }

    fieldName = 'code';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setCodeElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Count.value Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Numerical value (with implicit precision)
   * - **Definition:** The value of the measured amount. The value includes an implicit precision in the presentation of the value.
   * - **Comment:** The implicit precision in the value should always be honored. Monetary values have their own rules for handling precision (refer to standard accounting text books).
   * - **Requirements:** Precision is handled implicitly in almost all cases of measurement.
   * - **FHIR Type:** `decimal`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private value?: DecimalType | undefined;

  /**
   * FHIR CodeSystem: QuantityComparator
   *
   * @see {@link QuantityComparatorEnum }
   */
  private readonly quantityComparatorEnum: QuantityComparatorEnum;

  /**
   * Count.comparator Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** < | <= | >= | > | ad - how to understand the value
   * - **Definition:** How the value should be understood and represented - whether the actual value is greater or less than the stated value due to measurement issues; e.g. if the comparator is "<" , then the real value is < stated value.
   * - **Requirements:** Need a framework for handling measures where the value is <5ug/L or >400mg/L due to the limitations of measuring methodology.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** true
   * - **isModifierReason:** This is labeled as &quot;Is Modifier&quot; because the comparator modifies the interpretation of the value significantly. If there is no comparator, then there is no modification of the value
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  private comparator?: EnumCodeType | undefined;

  /**
   * Count.unit Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Unit representation
   * - **Definition:** A human-readable form of the unit.
   * - **Requirements:** There are many representations for units of measure and in many contexts, particular representations are fixed and required. I.e. mcg for micrograms.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private unit?: StringType | undefined;

  /**
   * Count.system Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** System that defines coded unit form
   * - **Definition:** The identification of the system that provides the coded form of the unit.
   * - **Requirements:** Need to know the system that defines the coded form of the unit.
   * - **FHIR Type:** `uri`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private system?: UriType | undefined;

  /**
   * Count.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Coded form of the unit
   * - **Definition:** A computer processable form of the unit in some unit representation system.
   * - **Comment:** The preferred system is UCUM, but SNOMED CT can also be used (for customary units) or ISO 4217 for currency.  The context of use may additionally require a code from a particular system.
   * - **Requirements:** Need a computable form of the unit that is fixed across all forms. UCUM provides this for quantities, but SNOMED CT provides many units of interest.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code?: CodeType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `value` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getValueElement(): DecimalType {
    return this.value ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `value` property.
   *
   * @param element - the `value` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValueElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = `Invalid Count.value; Provided element is not an instance of DecimalType.`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.value = element;
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `value` property exists and has a value; `false` otherwise
   */
  public hasValueElement(): boolean {
    return isDefined<DecimalType>(this.value) && !this.value.isEmpty();
  }

  /**
   * @returns the `value` property value as a fhirDecimal if defined; else undefined
   */
  public getValue(): fhirDecimal | undefined {
    return this.value?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `value` property.
   *
   * @param value - the `value` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValue(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = `Invalid Count.value (${String(value)})`;
      this.value = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `value` property exists and has a value; `false` otherwise
   */
  public hasValue(): boolean {
    return this.hasValueElement();
  }

  /**
   * @returns the `comparator` property value as a EnumCodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public getComparatorEnumType(): EnumCodeType | undefined {
    return this.comparator;
  }

  /**
   * Assigns the provided EnumCodeType value to the `comparator` property.
   *
   * @param enumType - the `comparator` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code values
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public setComparatorEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid Count.comparator';
      assertEnumCodeType<QuantityComparatorEnum>(enumType, QuantityComparatorEnum, errMsgPrefix);
      this.comparator = enumType;
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `comparator` property exists and has a value; `false` otherwise
   */
  public hasComparatorEnumType(): boolean {
    return isDefined<EnumCodeType>(this.comparator) && !this.comparator.isEmpty() && this.comparator.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the `comparator` property value as a CodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public getComparatorElement(): CodeType | undefined {
    if (this.comparator === undefined) {
      return undefined;
    }
    return this.comparator as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the `comparator` property.
   *
   * @param element - the `comparator` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public setComparatorElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid Count.comparator; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.comparator = new EnumCodeType(element, this.quantityComparatorEnum);
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `comparator` property exists and has a value; `false` otherwise
   */
  public hasComparatorElement(): boolean {
    return this.hasComparatorEnumType();
  }

  /**
   * @returns the `comparator` property value as a fhirCode if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public getComparator(): fhirCode | undefined {
    if (this.comparator === undefined) {
      return undefined;
    }
    return this.comparator.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the `comparator` property.
   *
   * @param value - the `comparator` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public setComparator(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid Count.comparator; Provided value is not an instance of fhirCode.`;
      this.comparator = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.quantityComparatorEnum);
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `comparator` property exists and has a value; `false` otherwise
   */
  public hasComparator(): boolean {
    return this.hasComparatorEnumType();
  }

  /**
   * @returns the `unit` property value as a StringType object if defined; else an empty StringType object
   */
  public getUnitElement(): StringType {
    return this.unit ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `unit` property.
   *
   * @param element - the `unit` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUnitElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid Count.unit; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.unit = element;
    } else {
      this.unit = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `unit` property exists and has a value; `false` otherwise
   */
  public hasUnitElement(): boolean {
    return isDefined<StringType>(this.unit) && !this.unit.isEmpty();
  }

  /**
   * @returns the `unit` property value as a fhirString if defined; else undefined
   */
  public getUnit(): fhirString | undefined {
    return this.unit?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `unit` property.
   *
   * @param value - the `unit` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUnit(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid Count.unit (${String(value)})`;
      this.unit = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.unit = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `unit` property exists and has a value; `false` otherwise
   */
  public hasUnit(): boolean {
    return this.hasUnitElement();
  }

  /**
   * @returns the `system` property value as a UriType object if defined; else an empty UriType object
   */
  public getSystemElement(): UriType {
    return this.system ?? new UriType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `system` property.
   *
   * @param element - the `system` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSystemElement(element: UriType | undefined): this {
    if (isDefined<UriType>(element)) {
      const optErrMsg = `Invalid Count.system; Provided element is not an instance of UriType.`;
      assertFhirType<UriType>(element, UriType, optErrMsg);
      this.system = element;
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `system` property exists and has a value; `false` otherwise
   */
  public hasSystemElement(): boolean {
    return isDefined<UriType>(this.system) && !this.system.isEmpty();
  }

  /**
   * @returns the `system` property value as a fhirUri if defined; else undefined
   */
  public getSystem(): fhirUri | undefined {
    return this.system?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `system` property.
   *
   * @param value - the `system` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSystem(value: fhirUri | undefined): this {
    if (isDefined<fhirUri>(value)) {
      const optErrMsg = `Invalid Count.system (${String(value)})`;
      this.system = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `system` property exists and has a value; `false` otherwise
   */
  public hasSystem(): boolean {
    return this.hasSystemElement();
  }

  /**
   * @returns the `code` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getCodeElement(): CodeType {
    return this.code ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `code` property.
   *
   * @param element - the `code` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCodeElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid Count.code; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.code = element;
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `code` property exists and has a value; `false` otherwise
   */
  public hasCodeElement(): boolean {
    return isDefined<CodeType>(this.code) && !this.code.isEmpty();
  }

  /**
   * @returns the `code` property value as a fhirCode if defined; else undefined
   */
  public getCode(): fhirCode | undefined {
    return this.code?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `code` property.
   *
   * @param value - the `code` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCode(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid Count.code (${String(value)})`;
      this.code = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `code` property exists and has a value; `false` otherwise
   */
  public hasCode(): boolean {
    return this.hasCodeElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Count';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.value,
      this.comparator,
      this.unit,
      this.system,
      this.code,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Count {
    const dest = new Count();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Count): void {
    super.copyValues(dest);
    dest.value = this.value?.copy();
    dest.comparator = this.comparator?.copy();
    dest.unit = this.unit?.copy();
    dest.system = this.system?.copy();
    dest.code = this.code?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasValueElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getValueElement(), 'value', jsonObj);
    }

    if (this.hasComparatorElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getComparatorElement()!, 'comparator', jsonObj);
    }

    if (this.hasUnitElement()) {
      setFhirPrimitiveJson<fhirString>(this.getUnitElement(), 'unit', jsonObj);
    }

    if (this.hasSystemElement()) {
      setFhirPrimitiveJson<fhirUri>(this.getSystemElement(), 'system', jsonObj);
    }

    if (this.hasCodeElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getCodeElement(), 'code', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * DataRequirement Class
 *
 * @remarks
 * DataRequirement Type: Describes a required data item for evaluation in terms of the type of data, and optional code or date-based filters of the data.
 *
 * **FHIR Specification**
 * - **Short:** Describes a required data item
 * - **Definition:** Describes a required data item for evaluation in terms of the type of data, and optional code or date-based filters of the data.
 * - **FHIR Version:** 5.0.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR DataRequirement](http://hl7.org/fhir/StructureDefinition/DataRequirement)
 */
export class DataRequirement extends DataType implements IDataType {
  constructor(type_: EnumCodeType | CodeType | fhirCode | null = null) {
    super();

    this.fhirTypesEnum = new FhirTypesEnum();

    this.type_ = constructorCodeValueAsEnumCodeType<FhirTypesEnum>(
      type_,
      FhirTypesEnum,
      this.fhirTypesEnum,
      'DataRequirement.type',
    );
  }

  /**
   * Parse the provided `DataRequirement` JSON to instantiate the DataRequirement data model.
   *
   * @param sourceJson - JSON representing FHIR `DataRequirement`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to DataRequirement
   * @returns DataRequirement data model or undefined for `DataRequirement`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): DataRequirement | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'DataRequirement';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new DataRequirement();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const classMetadata: DecoratorMetadataObject | null = DataRequirement[Symbol.metadata];
    const errorMessage = `DecoratorMetadataObject does not exist for DataRequirement`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    const missingReqdProperties: string[] = [];

    fieldName = 'type';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setTypeElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'profile';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: CanonicalType | undefined = fhirParser.parseCanonicalType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addProfileElement(datatype);
        }
      });
    }

    fieldName = 'subject[x]';
    sourceField = `${optSourceValue}.${fieldName}`;
    const subject: IDataType | undefined = fhirParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setSubject(subject);

    fieldName = 'mustSupport';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: StringType | undefined = fhirParser.parseStringType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addMustSupportElement(datatype);
        }
      });
    }

    fieldName = 'codeFilter';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: DataRequirementCodeFilterComponent | undefined = DataRequirementCodeFilterComponent.parse(dataElementJson, `${sourceField}[${String(idx)}]`);
        if (datatype !== undefined) {
          instance.addCodeFilter(datatype);
        }
      });
    }

    fieldName = 'dateFilter';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: DataRequirementDateFilterComponent | undefined = DataRequirementDateFilterComponent.parse(dataElementJson, `${sourceField}[${String(idx)}]`);
        if (datatype !== undefined) {
          instance.addDateFilter(datatype);
        }
      });
    }

    fieldName = 'valueFilter';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: DataRequirementValueFilterComponent | undefined = DataRequirementValueFilterComponent.parse(dataElementJson, `${sourceField}[${String(idx)}]`);
        if (datatype !== undefined) {
          instance.addValueFilter(datatype);
        }
      });
    }

    fieldName = 'limit';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = fhirParser.parsePositiveIntType(dtJson, dtSiblingJson);
      instance.setLimitElement(datatype);
    }

    fieldName = 'sort';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: DataRequirementSortComponent | undefined = DataRequirementSortComponent.parse(dataElementJson, `${sourceField}[${String(idx)}]`);
        if (datatype !== undefined) {
          instance.addSort(datatype);
        }
      });
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_REQD_IN_JSON} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: FhirTypes
   *
   * @see {@link FhirTypesEnum }
   */
  private readonly fhirTypesEnum: FhirTypesEnum;

  /**
   * DataRequirement.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The type of the required data
   * - **Definition:** The type of the required data, specified as the type name of a resource. For profiles, this value is set to the type of the base resource of the profile.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link FhirTypesEnum }
   */
  private type_: EnumCodeType | null;

  /**
   * DataRequirement.profile Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The profile of the required data
   * - **Definition:** The profile of the required data, specified as the uri of the profile definition.
   * - **FHIR Type:** `canonical`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/StructureDefinition',
   *     ]
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private profile?: CanonicalType[] | undefined;

  /**
   * DataRequirement.subject[x] Element
   *
   * @decorator `@ChoiceDataTypesMeta('DataRequirement.subject[x]', ['CodeableConcept','Reference',]`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** E.g. Patient, Practitioner, RelatedPerson, Organization, Location, Device
   * - **Definition:** The intended subjects of the data requirement. If this element is not provided, a Patient subject is assumed.
   * - **Comment:** The subject of a data requirement is critical, as the data being specified is determined with respect to a particular subject. This corresponds roughly to the notion of a Compartment in that it limits what data is available based on its relationship to the subject. In CQL, this corresponds to the context declaration.
   * - **FHIR Types:**
   *     'CodeableConcept',
   *     'Reference',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('DataRequirement.subject[x]',[
    'CodeableConcept',
    'Reference',
  ])
  private subject?: IDataType | undefined;

  /**
   * DataRequirement.mustSupport Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Indicates specific structure elements that are referenced by the knowledge module
   * - **Definition:** Indicates that specific elements of the type are referenced by the knowledge module and must be supported by the consumer in order to obtain an effective evaluation. This does not mean that a value is required for this element, only that the consuming system must understand the element and be able to provide values for it if they are available.  The value of mustSupport SHALL be a FHIRPath resolvable on the type of the DataRequirement. The path SHALL consist only of identifiers, constant indexers, and .resolve() (see the [Simple FHIRPath Profile](https://hl7.org/fhir/fhirpath.html#simple) for full details).
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private mustSupport?: StringType[] | undefined;

  /**
   * DataRequirement.codeFilter Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** What codes are expected
   * - **Definition:** Code filters specify additional constraints on the data, specifying the value set of interest for a particular element of the data. Each code filter defines an additional constraint on the data, i.e. code filters are AND\'ed, not OR\'ed.
   * - **FHIR Type:** `Element`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private codeFilter?: DataRequirementCodeFilterComponent[] | undefined;

  /**
   * DataRequirement.dateFilter Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** What dates/date ranges are expected
   * - **Definition:** Date filters specify additional constraints on the data in terms of the applicable date range for specific elements. Each date filter specifies an additional constraint on the data, i.e. date filters are AND\'ed, not OR\'ed.
   * - **FHIR Type:** `Element`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private dateFilter?: DataRequirementDateFilterComponent[] | undefined;

  /**
   * DataRequirement.valueFilter Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** What values are expected
   * - **Definition:** Value filters specify additional constraints on the data for elements other than code-valued or date-valued. Each value filter specifies an additional constraint on the data (i.e. valueFilters are AND\'ed, not OR\'ed).
   * - **FHIR Type:** `Element`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private valueFilter?: DataRequirementValueFilterComponent[] | undefined;

  /**
   * DataRequirement.limit Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Number of results
   * - **Definition:** Specifies a maximum number of results that are required (uses the _count search parameter).
   * - **Comment:** This element can be used in combination with the sort element to specify quota requirements such as "the most recent 5" or "the highest 5".
   * - **Requirements:** Enables the requirement "most recent 5 results" to be expressed.
   * - **FHIR Type:** `positiveInt`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private limit?: PositiveIntType | undefined;

  /**
   * DataRequirement.sort Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Order of the results
   * - **Definition:** Specifies the order of the results to be returned.
   * - **Comment:** This element can be used in combination with the sort element to specify quota requirements such as "the most recent 5" or "the highest 5". When multiple sorts are specified, they are applied in the order they appear in the resource.
   * - **Requirements:** Enables the requirement "most recent 5 results" to be expressed.
   * - **FHIR Type:** `Element`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private sort?: DataRequirementSortComponent[] | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `type_` property value as a EnumCodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link FhirTypesEnum }
   */
  public getTypeEnumType(): EnumCodeType | null {
    return this.type_;
  }

  /**
   * Assigns the provided EnumCodeType value to the `type_` property.
   *
   * @param enumType - the `type_` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link FhirTypesEnum }
   */
  public setTypeEnumType(enumType: EnumCodeType): this {
    assertIsDefined<EnumCodeType>(enumType, `DataRequirement.type is required`);
    const errMsgPrefix = `Invalid DataRequirement.type`;
    assertEnumCodeType<FhirTypesEnum>(enumType, FhirTypesEnum, errMsgPrefix);
    this.type_ = enumType;
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasTypeEnumType(): boolean {
    return isDefined<EnumCodeType>(this.type_) && !this.type_.isEmpty() && this.type_.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the `type_` property value as a CodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link FhirTypesEnum }
   */
  public getTypeElement(): CodeType | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_ as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the `type_` property.
   *
   * @param element - the `type_` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link FhirTypesEnum }
   */
  public setTypeElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, `DataRequirement.type is required`);
    const optErrMsg = `Invalid DataRequirement.type; Provided value is not an instance of CodeType.`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.type_ = new EnumCodeType(element, this.fhirTypesEnum);
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasTypeElement(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the `type_` property value as a fhirCode if defined; else null
   *
   * @see CodeSystem Enumeration: {@link FhirTypesEnum }
   */
  public getType(): fhirCode | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the `type_` property.
   *
   * @param value - the `type_` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link FhirTypesEnum }
   */
  public setType(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, `DataRequirement.type is required`);
    const optErrMsg = `Invalid DataRequirement.type (${String(value)})`;
    this.type_ = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.fhirTypesEnum);
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasType(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the `profile` property value as a CanonicalType array
   */
  public getProfileElement(): CanonicalType[] {
    return this.profile ?? ([] as CanonicalType[]);
  }

  /**
   * Assigns the provided CanonicalType array value to the `profile` property.
   *
   * @param element - the `profile` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setProfileElement(element: CanonicalType[] | undefined): this {
    if (isDefinedList<CanonicalType>(element)) {
      const optErrMsg = `Invalid DataRequirement.profile; Provided value array has an element that is not an instance of CanonicalType.`;
      assertFhirTypeList<CanonicalType>(element, CanonicalType, optErrMsg);
      this.profile = element;
    } else {
      this.profile = undefined;
    }
    return this;
  }

  /**
   * Add the provided CanonicalType value to the `profile` array property.
   *
   * @param element - the `profile` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addProfileElement(element: CanonicalType | undefined): this {
    if (isDefined<CanonicalType>(element)) {
      const optErrMsg = `Invalid DataRequirement.profile; Provided element is not an instance of CanonicalType.`;
      assertFhirType<CanonicalType>(element, CanonicalType, optErrMsg);
      this.initProfile();
      this.profile?.push(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `profile` property exists and has a value; `false` otherwise
   */
  public hasProfileElement(): boolean {
    return isDefinedList<CanonicalType>(this.profile) && this.profile.some((item: CanonicalType) => !item.isEmpty());
  }

  /**
   * @returns the `profile` property value as a fhirCanonical array
   */
  public getProfile(): fhirCanonical[] {
    this.initProfile();
    const profileValues = [] as fhirCanonical[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.profile!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        profileValues.push(value);
      }
    }
    return profileValues;
  }

  /**
   * Assigns the provided primitive value array to the `profile` property.
   *
   * @param value - the `profile` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setProfile(value: fhirCanonical[] | undefined): this {
    if (isDefinedList<fhirCanonical>(value)) {
      const profileElements = [] as CanonicalType[];
      for (const profileValue of value) {
        const optErrMsg = `Invalid DataRequirement.profile array item (${String(profileValue)})`;
        const element = new CanonicalType(parseFhirPrimitiveData(profileValue, fhirCanonicalSchema, optErrMsg));
        profileElements.push(element);
      }
      this.profile = profileElements;
    } else {
      this.profile = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the `profile` array property.
   *
   * @param value - the `profile` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addProfile(value: fhirCanonical | undefined): this {
    if (isDefined<fhirCanonical>(value)) {
      const optErrMsg = `Invalid DataRequirement.profile array item (${String(value)})`;
      const element = new CanonicalType(parseFhirPrimitiveData(value, fhirCanonicalSchema, optErrMsg));
      this.initProfile();
      this.addProfileElement(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `profile` property exists and has a value; `false` otherwise
   */
  public hasProfile(): boolean {
    return this.hasProfileElement();
  }

  /**
   * Initialize the `profile` property
   */
  private initProfile(): void {
    if (!this.hasProfile()) {
      this.profile = [] as CanonicalType[];
    }
  }

  /**
   * @returns the `subject` property value as a DataType object if defined; else undefined
   */
  public getSubject(): IDataType | undefined {
    return this.subject;
  }

  /**
   * Assigns the provided DataType object value to the `subject` property.
   *
   * @decorator `@ChoiceDataTypes('DataRequirement.subject[x]')`
   *
   * @param value - the `subject` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  @ChoiceDataTypes('DataRequirement.subject[x]')
  public setSubject(value: IDataType | undefined): this {
    if (isDefined<IDataType>(value)) {
      // assertFhirType<IDataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.subject = value;
    } else {
      this.subject = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `subject` property exists and has a value; `false` otherwise
   */
  public hasSubject(): boolean {
    return isDefined<IDataType>(this.subject) && !this.subject.isEmpty();
  }

  // *** NOTE ***
  // Following choice datatype-specific "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the `subject` property value as a CodeableConcept object if defined; else undefined
   */
  public getSubjectCodeableConcept(): CodeableConcept | undefined {
    if (!isDefined<IDataType | undefined>(this.subject)) {
      return undefined;
    }
    if (!(this.subject instanceof CodeableConcept)) {
      throw new InvalidTypeError(
        `DataType mismatch for DataRequirement.subject[x]: Expected CodeableConcept but encountered ${this.subject.fhirType()}`,
      );
    }
    return this.subject;
  }

  /**
   * @returns `true` if the `subject` property exists as a CodeableConcept and has a value; `false` otherwise
   */
  public hasSubjectCodeableConcept(): boolean {
    return this.hasSubject() && this.subject instanceof CodeableConcept;
  }

  /**
   * @returns the `subject` property value as a Reference object if defined; else undefined
   */
  public getSubjectReference(): Reference | undefined {
    if (!isDefined<IDataType | undefined>(this.subject)) {
      return undefined;
    }
    if (!(this.subject instanceof Reference)) {
      throw new InvalidTypeError(
        `DataType mismatch for DataRequirement.subject[x]: Expected Reference but encountered ${this.subject.fhirType()}`,
      );
    }
    return this.subject;
  }

  /**
   * @returns `true` if the `subject` property exists as a Reference and has a value; `false` otherwise
   */
  public hasSubjectReference(): boolean {
    return this.hasSubject() && this.subject instanceof Reference;
  }

  // End of choice datatype-specific "get"/"has" methods

  /**
   * @returns the `mustSupport` property value as a StringType array
   */
  public getMustSupportElement(): StringType[] {
    return this.mustSupport ?? ([] as StringType[]);
  }

  /**
   * Assigns the provided StringType array value to the `mustSupport` property.
   *
   * @param element - the `mustSupport` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMustSupportElement(element: StringType[] | undefined): this {
    if (isDefinedList<StringType>(element)) {
      const optErrMsg = `Invalid DataRequirement.mustSupport; Provided value array has an element that is not an instance of StringType.`;
      assertFhirTypeList<StringType>(element, StringType, optErrMsg);
      this.mustSupport = element;
    } else {
      this.mustSupport = undefined;
    }
    return this;
  }

  /**
   * Add the provided StringType value to the `mustSupport` array property.
   *
   * @param element - the `mustSupport` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addMustSupportElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid DataRequirement.mustSupport; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.initMustSupport();
      this.mustSupport?.push(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `mustSupport` property exists and has a value; `false` otherwise
   */
  public hasMustSupportElement(): boolean {
    return isDefinedList<StringType>(this.mustSupport) && this.mustSupport.some((item: StringType) => !item.isEmpty());
  }

  /**
   * @returns the `mustSupport` property value as a fhirString array
   */
  public getMustSupport(): fhirString[] {
    this.initMustSupport();
    const mustSupportValues = [] as fhirString[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.mustSupport!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        mustSupportValues.push(value);
      }
    }
    return mustSupportValues;
  }

  /**
   * Assigns the provided primitive value array to the `mustSupport` property.
   *
   * @param value - the `mustSupport` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMustSupport(value: fhirString[] | undefined): this {
    if (isDefinedList<fhirString>(value)) {
      const mustSupportElements = [] as StringType[];
      for (const mustSupportValue of value) {
        const optErrMsg = `Invalid DataRequirement.mustSupport array item (${String(mustSupportValue)})`;
        const element = new StringType(parseFhirPrimitiveData(mustSupportValue, fhirStringSchema, optErrMsg));
        mustSupportElements.push(element);
      }
      this.mustSupport = mustSupportElements;
    } else {
      this.mustSupport = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the `mustSupport` array property.
   *
   * @param value - the `mustSupport` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addMustSupport(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid DataRequirement.mustSupport array item (${String(value)})`;
      const element = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
      this.initMustSupport();
      this.addMustSupportElement(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `mustSupport` property exists and has a value; `false` otherwise
   */
  public hasMustSupport(): boolean {
    return this.hasMustSupportElement();
  }

  /**
   * Initialize the `mustSupport` property
   */
  private initMustSupport(): void {
    if (!this.hasMustSupport()) {
      this.mustSupport = [] as StringType[];
    }
  }

  /**
   * @returns the `codeFilter` property value as a DataRequirementCodeFilterComponent array
   */
  public getCodeFilter(): DataRequirementCodeFilterComponent[] {
    return this.codeFilter ?? ([] as DataRequirementCodeFilterComponent[]);
  }

  /**
   * Assigns the provided DataRequirementCodeFilterComponent array value to the `codeFilter` property.
   *
   * @param value - the `codeFilter` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setCodeFilter(value: DataRequirementCodeFilterComponent[] | undefined): this {
    if (isDefinedList<DataRequirementCodeFilterComponent>(value)) {
      const optErrMsg = `Invalid DataRequirement.codeFilter; Provided value array has an element that is not an instance of DataRequirementCodeFilterComponent.`;
      assertFhirTypeList<DataRequirementCodeFilterComponent>(value, DataRequirementCodeFilterComponent, optErrMsg);
      this.codeFilter = value;
    } else {
      this.codeFilter = undefined;
    }
    return this;
  }

  /**
   * Add the provided DataRequirementCodeFilterComponent value to the `codeFilter` array property.
   *
   * @param value - the `codeFilter` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addCodeFilter(value: DataRequirementCodeFilterComponent | undefined): this {
    if (isDefined<DataRequirementCodeFilterComponent>(value)) {
      const optErrMsg = `Invalid DataRequirement.codeFilter; Provided element is not an instance of DataRequirementCodeFilterComponent.`;
      assertFhirType<DataRequirementCodeFilterComponent>(value, DataRequirementCodeFilterComponent, optErrMsg);
      this.initCodeFilter();
      this.codeFilter?.push(value);
    }
    return this;
  }

  /**
   * @returns `true` if the `codeFilter` property exists and has a value; `false` otherwise
   */
  public hasCodeFilter(): boolean {
    return isDefinedList<DataRequirementCodeFilterComponent>(this.codeFilter) && this.codeFilter.some((item: DataRequirementCodeFilterComponent) => !item.isEmpty());
  }

  /**
   * Initialize the `codeFilter` property
   */
  private initCodeFilter(): void {
    if(!this.hasCodeFilter()) {
      this.codeFilter = [] as DataRequirementCodeFilterComponent[];
    }
  }

  /**
   * @returns the `dateFilter` property value as a DataRequirementDateFilterComponent array
   */
  public getDateFilter(): DataRequirementDateFilterComponent[] {
    return this.dateFilter ?? ([] as DataRequirementDateFilterComponent[]);
  }

  /**
   * Assigns the provided DataRequirementDateFilterComponent array value to the `dateFilter` property.
   *
   * @param value - the `dateFilter` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setDateFilter(value: DataRequirementDateFilterComponent[] | undefined): this {
    if (isDefinedList<DataRequirementDateFilterComponent>(value)) {
      const optErrMsg = `Invalid DataRequirement.dateFilter; Provided value array has an element that is not an instance of DataRequirementDateFilterComponent.`;
      assertFhirTypeList<DataRequirementDateFilterComponent>(value, DataRequirementDateFilterComponent, optErrMsg);
      this.dateFilter = value;
    } else {
      this.dateFilter = undefined;
    }
    return this;
  }

  /**
   * Add the provided DataRequirementDateFilterComponent value to the `dateFilter` array property.
   *
   * @param value - the `dateFilter` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addDateFilter(value: DataRequirementDateFilterComponent | undefined): this {
    if (isDefined<DataRequirementDateFilterComponent>(value)) {
      const optErrMsg = `Invalid DataRequirement.dateFilter; Provided element is not an instance of DataRequirementDateFilterComponent.`;
      assertFhirType<DataRequirementDateFilterComponent>(value, DataRequirementDateFilterComponent, optErrMsg);
      this.initDateFilter();
      this.dateFilter?.push(value);
    }
    return this;
  }

  /**
   * @returns `true` if the `dateFilter` property exists and has a value; `false` otherwise
   */
  public hasDateFilter(): boolean {
    return isDefinedList<DataRequirementDateFilterComponent>(this.dateFilter) && this.dateFilter.some((item: DataRequirementDateFilterComponent) => !item.isEmpty());
  }

  /**
   * Initialize the `dateFilter` property
   */
  private initDateFilter(): void {
    if(!this.hasDateFilter()) {
      this.dateFilter = [] as DataRequirementDateFilterComponent[];
    }
  }

  /**
   * @returns the `valueFilter` property value as a DataRequirementValueFilterComponent array
   */
  public getValueFilter(): DataRequirementValueFilterComponent[] {
    return this.valueFilter ?? ([] as DataRequirementValueFilterComponent[]);
  }

  /**
   * Assigns the provided DataRequirementValueFilterComponent array value to the `valueFilter` property.
   *
   * @param value - the `valueFilter` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setValueFilter(value: DataRequirementValueFilterComponent[] | undefined): this {
    if (isDefinedList<DataRequirementValueFilterComponent>(value)) {
      const optErrMsg = `Invalid DataRequirement.valueFilter; Provided value array has an element that is not an instance of DataRequirementValueFilterComponent.`;
      assertFhirTypeList<DataRequirementValueFilterComponent>(value, DataRequirementValueFilterComponent, optErrMsg);
      this.valueFilter = value;
    } else {
      this.valueFilter = undefined;
    }
    return this;
  }

  /**
   * Add the provided DataRequirementValueFilterComponent value to the `valueFilter` array property.
   *
   * @param value - the `valueFilter` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addValueFilter(value: DataRequirementValueFilterComponent | undefined): this {
    if (isDefined<DataRequirementValueFilterComponent>(value)) {
      const optErrMsg = `Invalid DataRequirement.valueFilter; Provided element is not an instance of DataRequirementValueFilterComponent.`;
      assertFhirType<DataRequirementValueFilterComponent>(value, DataRequirementValueFilterComponent, optErrMsg);
      this.initValueFilter();
      this.valueFilter?.push(value);
    }
    return this;
  }

  /**
   * @returns `true` if the `valueFilter` property exists and has a value; `false` otherwise
   */
  public hasValueFilter(): boolean {
    return isDefinedList<DataRequirementValueFilterComponent>(this.valueFilter) && this.valueFilter.some((item: DataRequirementValueFilterComponent) => !item.isEmpty());
  }

  /**
   * Initialize the `valueFilter` property
   */
  private initValueFilter(): void {
    if(!this.hasValueFilter()) {
      this.valueFilter = [] as DataRequirementValueFilterComponent[];
    }
  }

  /**
   * @returns the `limit` property value as a PositiveIntType object if defined; else an empty PositiveIntType object
   */
  public getLimitElement(): PositiveIntType {
    return this.limit ?? new PositiveIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `limit` property.
   *
   * @param element - the `limit` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLimitElement(element: PositiveIntType | undefined): this {
    if (isDefined<PositiveIntType>(element)) {
      const optErrMsg = `Invalid DataRequirement.limit; Provided element is not an instance of PositiveIntType.`;
      assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
      this.limit = element;
    } else {
      this.limit = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `limit` property exists and has a value; `false` otherwise
   */
  public hasLimitElement(): boolean {
    return isDefined<PositiveIntType>(this.limit) && !this.limit.isEmpty();
  }

  /**
   * @returns the `limit` property value as a fhirPositiveInt if defined; else undefined
   */
  public getLimit(): fhirPositiveInt | undefined {
    return this.limit?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `limit` property.
   *
   * @param value - the `limit` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLimit(value: fhirPositiveInt | undefined): this {
    if (isDefined<fhirPositiveInt>(value)) {
      const optErrMsg = `Invalid DataRequirement.limit (${String(value)})`;
      this.limit = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    } else {
      this.limit = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `limit` property exists and has a value; `false` otherwise
   */
  public hasLimit(): boolean {
    return this.hasLimitElement();
  }

  /**
   * @returns the `sort` property value as a DataRequirementSortComponent array
   */
  public getSort(): DataRequirementSortComponent[] {
    return this.sort ?? ([] as DataRequirementSortComponent[]);
  }

  /**
   * Assigns the provided DataRequirementSortComponent array value to the `sort` property.
   *
   * @param value - the `sort` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setSort(value: DataRequirementSortComponent[] | undefined): this {
    if (isDefinedList<DataRequirementSortComponent>(value)) {
      const optErrMsg = `Invalid DataRequirement.sort; Provided value array has an element that is not an instance of DataRequirementSortComponent.`;
      assertFhirTypeList<DataRequirementSortComponent>(value, DataRequirementSortComponent, optErrMsg);
      this.sort = value;
    } else {
      this.sort = undefined;
    }
    return this;
  }

  /**
   * Add the provided DataRequirementSortComponent value to the `sort` array property.
   *
   * @param value - the `sort` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addSort(value: DataRequirementSortComponent | undefined): this {
    if (isDefined<DataRequirementSortComponent>(value)) {
      const optErrMsg = `Invalid DataRequirement.sort; Provided element is not an instance of DataRequirementSortComponent.`;
      assertFhirType<DataRequirementSortComponent>(value, DataRequirementSortComponent, optErrMsg);
      this.initSort();
      this.sort?.push(value);
    }
    return this;
  }

  /**
   * @returns `true` if the `sort` property exists and has a value; `false` otherwise
   */
  public hasSort(): boolean {
    return isDefinedList<DataRequirementSortComponent>(this.sort) && this.sort.some((item: DataRequirementSortComponent) => !item.isEmpty());
  }

  /**
   * Initialize the `sort` property
   */
  private initSort(): void {
    if(!this.hasSort()) {
      this.sort = [] as DataRequirementSortComponent[];
    }
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'DataRequirement';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.type_,
      this.profile,
      this.subject,
      this.mustSupport,
      this.codeFilter,
      this.dateFilter,
      this.valueFilter,
      this.limit,
      this.sort,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): DataRequirement {
    const dest = new DataRequirement();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: DataRequirement): void {
    super.copyValues(dest);
    dest.type_ = this.type_ ? this.type_.copy() : null;
    const profileList = copyListValues<CanonicalType>(this.profile);
    dest.profile = profileList.length === 0 ? undefined : profileList;
    dest.subject = this.subject?.copy() as IDataType;
    const mustSupportList = copyListValues<StringType>(this.mustSupport);
    dest.mustSupport = mustSupportList.length === 0 ? undefined : mustSupportList;
    const codeFilterList = copyListValues<DataRequirementCodeFilterComponent>(this.codeFilter);
    dest.codeFilter = codeFilterList.length === 0 ? undefined : codeFilterList;
    const dateFilterList = copyListValues<DataRequirementDateFilterComponent>(this.dateFilter);
    dest.dateFilter = dateFilterList.length === 0 ? undefined : dateFilterList;
    const valueFilterList = copyListValues<DataRequirementValueFilterComponent>(this.valueFilter);
    dest.valueFilter = valueFilterList.length === 0 ? undefined : valueFilterList;
    dest.limit = this.limit?.copy();
    const sortList = copyListValues<DataRequirementSortComponent>(this.sort);
    dest.sort = sortList.length === 0 ? undefined : sortList;
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasTypeElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getTypeElement()!, 'type', jsonObj);
    } else {
      missingReqdProperties.push(`DataRequirement.type`);
    }

    if (this.hasProfile()) {
      setFhirPrimitiveListJson(this.getProfileElement(), 'profile', jsonObj);
    }

    if (this.hasSubject()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getSubject()!, 'subject', jsonObj);
    }

    if (this.hasMustSupport()) {
      setFhirPrimitiveListJson(this.getMustSupportElement(), 'mustSupport', jsonObj);
    }

    if (this.hasCodeFilter()) {
      setFhirComplexListJson(this.getCodeFilter(), 'codeFilter', jsonObj);
    }

    if (this.hasDateFilter()) {
      setFhirComplexListJson(this.getDateFilter(), 'dateFilter', jsonObj);
    }

    if (this.hasValueFilter()) {
      setFhirComplexListJson(this.getValueFilter(), 'valueFilter', jsonObj);
    }

    if (this.hasLimitElement()) {
      setFhirPrimitiveJson<fhirPositiveInt>(this.getLimitElement(), 'limit', jsonObj);
    }

    if (this.hasSort()) {
      setFhirComplexListJson(this.getSort(), 'sort', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_DO_NOT_EXIST} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
/**
 * DataRequirementCodeFilterComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** What codes are expected
 * - **Definition:** Code filters specify additional constraints on the data, specifying the value set of interest for a particular element of the data. Each code filter defines an additional constraint on the data, i.e. code filters are AND\'ed, not OR\'ed.
 *
 * @category Data Models: ComplexType
 * @see [FHIR DataRequirement](http://hl7.org/fhir/StructureDefinition/DataRequirement)
 */
export class DataRequirementCodeFilterComponent extends DataType implements IDataType {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided `DataRequirementCodeFilterComponent` JSON to instantiate the DataRequirementCodeFilterComponent data model.
   *
   * @param sourceJson - JSON representing FHIR `DataRequirementCodeFilterComponent`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to DataRequirementCodeFilterComponent
   * @returns DataRequirementCodeFilterComponent data model or undefined for `DataRequirementCodeFilterComponent`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): DataRequirementCodeFilterComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'DataRequirementCodeFilterComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new DataRequirementCodeFilterComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'path';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setPathElement(datatype);
    }

    fieldName = 'searchParam';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setSearchParamElement(datatype);
    }

    fieldName = 'valueSet';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CanonicalType | undefined = fhirParser.parseCanonicalType(dtJson, dtSiblingJson);
      instance.setValueSetElement(datatype);
    }

    fieldName = 'code';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Coding | undefined = Coding.parse(dataElementJson, `${sourceField}[${String(idx)}]`);
        if (datatype !== undefined) {
          instance.addCode(datatype);
        }
      });
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * DataRequirement.codeFilter.path Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A code-valued attribute to filter on
   * - **Definition:** The code-valued attribute of the filter. The specified path SHALL be a FHIRPath resolvable on the specified type of the DataRequirement, and SHALL consist only of identifiers, constant indexers, and .resolve(). The path is allowed to contain qualifiers (.) to traverse sub-elements, as well as indexers ([x]) to traverse multiple-cardinality sub-elements (see the [Simple FHIRPath Profile](https://hl7.org/fhir/fhirpath.html#simple) for full details). Note that the index must be an integer constant. The path must resolve to an element of type code, Coding, or CodeableConcept.
   * - **Comment:** The path attribute contains a [Simple FHIRPath Subset](https://hl7.org/fhir/fhirpath.html#simple) that allows path traversal, but not calculation.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private path?: StringType | undefined;

  /**
   * DataRequirement.codeFilter.searchParam Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A coded (token) parameter to search on
   * - **Definition:** A token parameter that refers to a search parameter defined on the specified type of the DataRequirement, and which searches on elements of type code, Coding, or CodeableConcept.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private searchParam?: StringType | undefined;

  /**
   * DataRequirement.codeFilter.valueSet Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** ValueSet for the filter
   * - **Definition:** The valueset for the code filter. The valueSet and code elements are additive. If valueSet is specified, the filter will return only those data items for which the value of the code-valued element specified in the path is a member of the specified valueset.
   * - **FHIR Type:** `canonical`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/ValueSet',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private valueSet?: CanonicalType | undefined;

  /**
   * DataRequirement.codeFilter.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** What code is expected
   * - **Definition:** The codes for the code filter. If values are given, the filter will return only those data items for which the code-valued attribute specified by the path has a value that is one of the specified codes. If codes are specified in addition to a value set, the filter returns items matching a code in the value set or one of the specified codes.
   * - **FHIR Type:** `Coding`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code?: Coding[] | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `path` property value as a StringType object if defined; else an empty StringType object
   */
  public getPathElement(): StringType {
    return this.path ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `path` property.
   *
   * @param element - the `path` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPathElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid DataRequirement.codeFilter.path; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.path = element;
    } else {
      this.path = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `path` property exists and has a value; `false` otherwise
   */
  public hasPathElement(): boolean {
    return isDefined<StringType>(this.path) && !this.path.isEmpty();
  }

  /**
   * @returns the `path` property value as a fhirString if defined; else undefined
   */
  public getPath(): fhirString | undefined {
    return this.path?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `path` property.
   *
   * @param value - the `path` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPath(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid DataRequirement.codeFilter.path (${String(value)})`;
      this.path = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.path = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `path` property exists and has a value; `false` otherwise
   */
  public hasPath(): boolean {
    return this.hasPathElement();
  }

  /**
   * @returns the `searchParam` property value as a StringType object if defined; else an empty StringType object
   */
  public getSearchParamElement(): StringType {
    return this.searchParam ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `searchParam` property.
   *
   * @param element - the `searchParam` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSearchParamElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid DataRequirement.codeFilter.searchParam; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.searchParam = element;
    } else {
      this.searchParam = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `searchParam` property exists and has a value; `false` otherwise
   */
  public hasSearchParamElement(): boolean {
    return isDefined<StringType>(this.searchParam) && !this.searchParam.isEmpty();
  }

  /**
   * @returns the `searchParam` property value as a fhirString if defined; else undefined
   */
  public getSearchParam(): fhirString | undefined {
    return this.searchParam?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `searchParam` property.
   *
   * @param value - the `searchParam` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSearchParam(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid DataRequirement.codeFilter.searchParam (${String(value)})`;
      this.searchParam = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.searchParam = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `searchParam` property exists and has a value; `false` otherwise
   */
  public hasSearchParam(): boolean {
    return this.hasSearchParamElement();
  }

  /**
   * @returns the `valueSet` property value as a CanonicalType object if defined; else an empty CanonicalType object
   */
  public getValueSetElement(): CanonicalType {
    return this.valueSet ?? new CanonicalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `valueSet` property.
   *
   * @param element - the `valueSet` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValueSetElement(element: CanonicalType | undefined): this {
    if (isDefined<CanonicalType>(element)) {
      const optErrMsg = `Invalid DataRequirement.codeFilter.valueSet; Provided element is not an instance of CanonicalType.`;
      assertFhirType<CanonicalType>(element, CanonicalType, optErrMsg);
      this.valueSet = element;
    } else {
      this.valueSet = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `valueSet` property exists and has a value; `false` otherwise
   */
  public hasValueSetElement(): boolean {
    return isDefined<CanonicalType>(this.valueSet) && !this.valueSet.isEmpty();
  }

  /**
   * @returns the `valueSet` property value as a fhirCanonical if defined; else undefined
   */
  public getValueSet(): fhirCanonical | undefined {
    return this.valueSet?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `valueSet` property.
   *
   * @param value - the `valueSet` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValueSet(value: fhirCanonical | undefined): this {
    if (isDefined<fhirCanonical>(value)) {
      const optErrMsg = `Invalid DataRequirement.codeFilter.valueSet (${String(value)})`;
      this.valueSet = new CanonicalType(parseFhirPrimitiveData(value, fhirCanonicalSchema, optErrMsg));
    } else {
      this.valueSet = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `valueSet` property exists and has a value; `false` otherwise
   */
  public hasValueSet(): boolean {
    return this.hasValueSetElement();
  }

  /**
   * @returns the `code` property value as a Coding array
   */
  public getCode(): Coding[] {
    return this.code ?? ([] as Coding[]);
  }

  /**
   * Assigns the provided Coding array value to the `code` property.
   *
   * @param value - the `code` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setCode(value: Coding[] | undefined): this {
    if (isDefinedList<Coding>(value)) {
      const optErrMsg = `Invalid DataRequirement.codeFilter.code; Provided value array has an element that is not an instance of Coding.`;
      assertFhirTypeList<Coding>(value, Coding, optErrMsg);
      this.code = value;
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * Add the provided Coding value to the `code` array property.
   *
   * @param value - the `code` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addCode(value: Coding | undefined): this {
    if (isDefined<Coding>(value)) {
      const optErrMsg = `Invalid DataRequirement.codeFilter.code; Provided element is not an instance of Coding.`;
      assertFhirType<Coding>(value, Coding, optErrMsg);
      this.initCode();
      this.code?.push(value);
    }
    return this;
  }

  /**
   * @returns `true` if the `code` property exists and has a value; `false` otherwise
   */
  public hasCode(): boolean {
    return isDefinedList<Coding>(this.code) && this.code.some((item: Coding) => !item.isEmpty());
  }

  /**
   * Initialize the `code` property
   */
  private initCode(): void {
    if(!this.hasCode()) {
      this.code = [] as Coding[];
    }
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'DataRequirement.codeFilter';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.path,
      this.searchParam,
      this.valueSet,
      this.code,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): DataRequirementCodeFilterComponent {
    const dest = new DataRequirementCodeFilterComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: DataRequirementCodeFilterComponent): void {
    super.copyValues(dest);
    dest.path = this.path?.copy();
    dest.searchParam = this.searchParam?.copy();
    dest.valueSet = this.valueSet?.copy();
    const codeList = copyListValues<Coding>(this.code);
    dest.code = codeList.length === 0 ? undefined : codeList;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasPathElement()) {
      setFhirPrimitiveJson<fhirString>(this.getPathElement(), 'path', jsonObj);
    }

    if (this.hasSearchParamElement()) {
      setFhirPrimitiveJson<fhirString>(this.getSearchParamElement(), 'searchParam', jsonObj);
    }

    if (this.hasValueSetElement()) {
      setFhirPrimitiveJson<fhirCanonical>(this.getValueSetElement(), 'valueSet', jsonObj);
    }

    if (this.hasCode()) {
      setFhirComplexListJson(this.getCode(), 'code', jsonObj);
    }

    return jsonObj;
  }
}
/**
 * DataRequirementDateFilterComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** What dates/date ranges are expected
 * - **Definition:** Date filters specify additional constraints on the data in terms of the applicable date range for specific elements. Each date filter specifies an additional constraint on the data, i.e. date filters are AND\'ed, not OR\'ed.
 *
 * @category Data Models: ComplexType
 * @see [FHIR DataRequirement](http://hl7.org/fhir/StructureDefinition/DataRequirement)
 */
export class DataRequirementDateFilterComponent extends DataType implements IDataType {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided `DataRequirementDateFilterComponent` JSON to instantiate the DataRequirementDateFilterComponent data model.
   *
   * @param sourceJson - JSON representing FHIR `DataRequirementDateFilterComponent`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to DataRequirementDateFilterComponent
   * @returns DataRequirementDateFilterComponent data model or undefined for `DataRequirementDateFilterComponent`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): DataRequirementDateFilterComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'DataRequirementDateFilterComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new DataRequirementDateFilterComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const classMetadata: DecoratorMetadataObject | null = DataRequirementDateFilterComponent[Symbol.metadata];
    const errorMessage = `DecoratorMetadataObject does not exist for DataRequirementDateFilterComponent`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    fieldName = 'path';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setPathElement(datatype);
    }

    fieldName = 'searchParam';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setSearchParamElement(datatype);
    }

    fieldName = 'value[x]';
    sourceField = `${optSourceValue}.${fieldName}`;
    const value: IDataType | undefined = fhirParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setValue(value);

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * DataRequirement.dateFilter.path Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A date-valued attribute to filter on
   * - **Definition:** The date-valued attribute of the filter. The specified path SHALL be a FHIRPath resolvable on the specified type of the DataRequirement, and SHALL consist only of identifiers, constant indexers, and .resolve(). The path is allowed to contain qualifiers (.) to traverse sub-elements, as well as indexers ([x]) to traverse multiple-cardinality sub-elements (see the [Simple FHIRPath Profile](https://hl7.org/fhir/fhirpath.html#simple) for full details). Note that the index must be an integer constant. The path must resolve to an element of type date, dateTime, Period, Schedule, or Timing.
   * - **Comment:** The path attribute contains a [Simple FHIR Subset](https://hl7.org/fhir/fhirpath.html#simple) that allows path traversal, but not calculation.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private path?: StringType | undefined;

  /**
   * DataRequirement.dateFilter.searchParam Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A date valued parameter to search on
   * - **Definition:** A date parameter that refers to a search parameter defined on the specified type of the DataRequirement, and which searches on elements of type date, dateTime, Period, Schedule, or Timing.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private searchParam?: StringType | undefined;

  /**
   * DataRequirement.dateFilter.value[x] Element
   *
   * @decorator `@ChoiceDataTypesMeta('DataRequirement.dateFilter.value[x]', ['dateTime','Period','Duration',]`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The value of the filter, as a Period, DateTime, or Duration value
   * - **Definition:** The value of the filter. If period is specified, the filter will return only those data items that fall within the bounds determined by the Period, inclusive of the period boundaries. If dateTime is specified, the filter will return only those data items that are equal to the specified dateTime. If a Duration is specified, the filter will return only those data items that fall within Duration before now.
   * - **FHIR Types:**
   *     'dateTime',
   *     'Period',
   *     'Duration',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('DataRequirement.dateFilter.value[x]',[
    'dateTime',
    'Period',
    'Duration',
  ])
  private value?: IDataType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `path` property value as a StringType object if defined; else an empty StringType object
   */
  public getPathElement(): StringType {
    return this.path ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `path` property.
   *
   * @param element - the `path` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPathElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid DataRequirement.dateFilter.path; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.path = element;
    } else {
      this.path = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `path` property exists and has a value; `false` otherwise
   */
  public hasPathElement(): boolean {
    return isDefined<StringType>(this.path) && !this.path.isEmpty();
  }

  /**
   * @returns the `path` property value as a fhirString if defined; else undefined
   */
  public getPath(): fhirString | undefined {
    return this.path?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `path` property.
   *
   * @param value - the `path` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPath(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid DataRequirement.dateFilter.path (${String(value)})`;
      this.path = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.path = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `path` property exists and has a value; `false` otherwise
   */
  public hasPath(): boolean {
    return this.hasPathElement();
  }

  /**
   * @returns the `searchParam` property value as a StringType object if defined; else an empty StringType object
   */
  public getSearchParamElement(): StringType {
    return this.searchParam ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `searchParam` property.
   *
   * @param element - the `searchParam` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSearchParamElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid DataRequirement.dateFilter.searchParam; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.searchParam = element;
    } else {
      this.searchParam = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `searchParam` property exists and has a value; `false` otherwise
   */
  public hasSearchParamElement(): boolean {
    return isDefined<StringType>(this.searchParam) && !this.searchParam.isEmpty();
  }

  /**
   * @returns the `searchParam` property value as a fhirString if defined; else undefined
   */
  public getSearchParam(): fhirString | undefined {
    return this.searchParam?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `searchParam` property.
   *
   * @param value - the `searchParam` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSearchParam(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid DataRequirement.dateFilter.searchParam (${String(value)})`;
      this.searchParam = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.searchParam = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `searchParam` property exists and has a value; `false` otherwise
   */
  public hasSearchParam(): boolean {
    return this.hasSearchParamElement();
  }

  /**
   * @returns the `value` property value as a DataType object if defined; else undefined
   */
  public getValue(): IDataType | undefined {
    return this.value;
  }

  /**
   * Assigns the provided DataType object value to the `value` property.
   *
   * @decorator `@ChoiceDataTypes('DataRequirement.dateFilter.value[x]')`
   *
   * @param value - the `value` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  @ChoiceDataTypes('DataRequirement.dateFilter.value[x]')
  public setValue(value: IDataType | undefined): this {
    if (isDefined<IDataType>(value)) {
      // assertFhirType<IDataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.value = value;
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `value` property exists and has a value; `false` otherwise
   */
  public hasValue(): boolean {
    return isDefined<IDataType>(this.value) && !this.value.isEmpty();
  }

  // *** NOTE ***
  // Following choice datatype-specific "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the `value` property value as a DateTimeType object if defined; else undefined
   */
  public getValueDateTimeType(): DateTimeType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof DateTimeType)) {
      throw new InvalidTypeError(
        `DataType mismatch for DataRequirement.dateFilter.value[x]: Expected DateTimeType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a DateTimeType and has a value; `false` otherwise
   */
  public hasValueDateTimeType(): boolean {
    return this.hasValue() && this.value instanceof DateTimeType;
  }

  /**
   * @returns the `value` property value as a Period object if defined; else undefined
   */
  public getValuePeriod(): Period | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Period)) {
      throw new InvalidTypeError(
        `DataType mismatch for DataRequirement.dateFilter.value[x]: Expected Period but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a Period and has a value; `false` otherwise
   */
  public hasValuePeriod(): boolean {
    return this.hasValue() && this.value instanceof Period;
  }

  /**
   * @returns the `value` property value as a Duration object if defined; else undefined
   */
  public getValueDuration(): Duration | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Duration)) {
      throw new InvalidTypeError(
        `DataType mismatch for DataRequirement.dateFilter.value[x]: Expected Duration but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a Duration and has a value; `false` otherwise
   */
  public hasValueDuration(): boolean {
    return this.hasValue() && this.value instanceof Duration;
  }

  // End of choice datatype-specific "get"/"has" methods

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'DataRequirement.dateFilter';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.path,
      this.searchParam,
      this.value,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): DataRequirementDateFilterComponent {
    const dest = new DataRequirementDateFilterComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: DataRequirementDateFilterComponent): void {
    super.copyValues(dest);
    dest.path = this.path?.copy();
    dest.searchParam = this.searchParam?.copy();
    dest.value = this.value?.copy() as IDataType;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasPathElement()) {
      setFhirPrimitiveJson<fhirString>(this.getPathElement(), 'path', jsonObj);
    }

    if (this.hasSearchParamElement()) {
      setFhirPrimitiveJson<fhirString>(this.getSearchParamElement(), 'searchParam', jsonObj);
    }

    if (this.hasValue()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getValue()!, 'value', jsonObj);
    }

    return jsonObj;
  }
}
/**
 * DataRequirementValueFilterComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** What values are expected
 * - **Definition:** Value filters specify additional constraints on the data for elements other than code-valued or date-valued. Each value filter specifies an additional constraint on the data (i.e. valueFilters are AND\'ed, not OR\'ed).
 *
 * @category Data Models: ComplexType
 * @see [FHIR DataRequirement](http://hl7.org/fhir/StructureDefinition/DataRequirement)
 */
export class DataRequirementValueFilterComponent extends DataType implements IDataType {
  constructor() {
    super();

    this.searchComparatorEnum = new SearchComparatorEnum();
  }

  /**
   * Parse the provided `DataRequirementValueFilterComponent` JSON to instantiate the DataRequirementValueFilterComponent data model.
   *
   * @param sourceJson - JSON representing FHIR `DataRequirementValueFilterComponent`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to DataRequirementValueFilterComponent
   * @returns DataRequirementValueFilterComponent data model or undefined for `DataRequirementValueFilterComponent`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): DataRequirementValueFilterComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'DataRequirementValueFilterComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new DataRequirementValueFilterComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const classMetadata: DecoratorMetadataObject | null = DataRequirementValueFilterComponent[Symbol.metadata];
    const errorMessage = `DecoratorMetadataObject does not exist for DataRequirementValueFilterComponent`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    fieldName = 'path';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setPathElement(datatype);
    }

    fieldName = 'searchParam';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setSearchParamElement(datatype);
    }

    fieldName = 'comparator';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setComparatorElement(datatype);
    }

    fieldName = 'value[x]';
    sourceField = `${optSourceValue}.${fieldName}`;
    const value: IDataType | undefined = fhirParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setValue(value);

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * DataRequirement.valueFilter.path Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** An attribute to filter on
   * - **Definition:** The attribute of the filter. The specified path SHALL be a FHIRPath resolvable on the specified type of the DataRequirement, and SHALL consist only of identifiers, constant indexers, and .resolve(). The path is allowed to contain qualifiers (.) to traverse sub-elements, as well as indexers ([x]) to traverse multiple-cardinality sub-elements (see the [Simple FHIRPath Profile](https://hl7.org/fhir/fhirpath.html#simple) for full details). Note that the index must be an integer constant. The path must resolve to an element of a type that is comparable to the valueFilter.value[x] element for the filter.
   * - **Comment:** The path attribute contains a [Simple FHIR Subset](https://hl7.org/fhir/fhirpath.html#simple) that allows path traversal, but not calculation.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private path?: StringType | undefined;

  /**
   * DataRequirement.valueFilter.searchParam Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A parameter to search on
   * - **Definition:** A search parameter defined on the specified type of the DataRequirement, and which searches on elements of a type compatible with the type of the valueFilter.value[x] for the filter.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private searchParam?: StringType | undefined;

  /**
   * FHIR CodeSystem: SearchComparator
   *
   * @see {@link SearchComparatorEnum }
   */
  private readonly searchComparatorEnum: SearchComparatorEnum;

  /**
   * DataRequirement.valueFilter.comparator Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** eq | gt | lt | ge | le | sa | eb
   * - **Definition:** The comparator to be used to determine whether the value is matching.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link SearchComparatorEnum }
   */
  private comparator?: EnumCodeType | undefined;

  /**
   * DataRequirement.valueFilter.value[x] Element
   *
   * @decorator `@ChoiceDataTypesMeta('DataRequirement.valueFilter.value[x]', ['dateTime','Period','Duration',]`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The value of the filter, as a Period, DateTime, or Duration value
   * - **Definition:** The value of the filter.
   * - **FHIR Types:**
   *     'dateTime',
   *     'Period',
   *     'Duration',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('DataRequirement.valueFilter.value[x]',[
    'dateTime',
    'Period',
    'Duration',
  ])
  private value?: IDataType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `path` property value as a StringType object if defined; else an empty StringType object
   */
  public getPathElement(): StringType {
    return this.path ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `path` property.
   *
   * @param element - the `path` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPathElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid DataRequirement.valueFilter.path; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.path = element;
    } else {
      this.path = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `path` property exists and has a value; `false` otherwise
   */
  public hasPathElement(): boolean {
    return isDefined<StringType>(this.path) && !this.path.isEmpty();
  }

  /**
   * @returns the `path` property value as a fhirString if defined; else undefined
   */
  public getPath(): fhirString | undefined {
    return this.path?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `path` property.
   *
   * @param value - the `path` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPath(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid DataRequirement.valueFilter.path (${String(value)})`;
      this.path = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.path = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `path` property exists and has a value; `false` otherwise
   */
  public hasPath(): boolean {
    return this.hasPathElement();
  }

  /**
   * @returns the `searchParam` property value as a StringType object if defined; else an empty StringType object
   */
  public getSearchParamElement(): StringType {
    return this.searchParam ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `searchParam` property.
   *
   * @param element - the `searchParam` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSearchParamElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid DataRequirement.valueFilter.searchParam; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.searchParam = element;
    } else {
      this.searchParam = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `searchParam` property exists and has a value; `false` otherwise
   */
  public hasSearchParamElement(): boolean {
    return isDefined<StringType>(this.searchParam) && !this.searchParam.isEmpty();
  }

  /**
   * @returns the `searchParam` property value as a fhirString if defined; else undefined
   */
  public getSearchParam(): fhirString | undefined {
    return this.searchParam?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `searchParam` property.
   *
   * @param value - the `searchParam` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSearchParam(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid DataRequirement.valueFilter.searchParam (${String(value)})`;
      this.searchParam = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.searchParam = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `searchParam` property exists and has a value; `false` otherwise
   */
  public hasSearchParam(): boolean {
    return this.hasSearchParamElement();
  }

  /**
   * @returns the `comparator` property value as a EnumCodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link SearchComparatorEnum }
   */
  public getComparatorEnumType(): EnumCodeType | undefined {
    return this.comparator;
  }

  /**
   * Assigns the provided EnumCodeType value to the `comparator` property.
   *
   * @param enumType - the `comparator` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code values
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link SearchComparatorEnum }
   */
  public setComparatorEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid DataRequirement.valueFilter.comparator';
      assertEnumCodeType<SearchComparatorEnum>(enumType, SearchComparatorEnum, errMsgPrefix);
      this.comparator = enumType;
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `comparator` property exists and has a value; `false` otherwise
   */
  public hasComparatorEnumType(): boolean {
    return isDefined<EnumCodeType>(this.comparator) && !this.comparator.isEmpty() && this.comparator.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the `comparator` property value as a CodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link SearchComparatorEnum }
   */
  public getComparatorElement(): CodeType | undefined {
    if (this.comparator === undefined) {
      return undefined;
    }
    return this.comparator as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the `comparator` property.
   *
   * @param element - the `comparator` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link SearchComparatorEnum }
   */
  public setComparatorElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid DataRequirement.valueFilter.comparator; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.comparator = new EnumCodeType(element, this.searchComparatorEnum);
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `comparator` property exists and has a value; `false` otherwise
   */
  public hasComparatorElement(): boolean {
    return this.hasComparatorEnumType();
  }

  /**
   * @returns the `comparator` property value as a fhirCode if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link SearchComparatorEnum }
   */
  public getComparator(): fhirCode | undefined {
    if (this.comparator === undefined) {
      return undefined;
    }
    return this.comparator.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the `comparator` property.
   *
   * @param value - the `comparator` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link SearchComparatorEnum }
   */
  public setComparator(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid DataRequirement.valueFilter.comparator; Provided value is not an instance of fhirCode.`;
      this.comparator = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.searchComparatorEnum);
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `comparator` property exists and has a value; `false` otherwise
   */
  public hasComparator(): boolean {
    return this.hasComparatorEnumType();
  }

  /**
   * @returns the `value` property value as a DataType object if defined; else undefined
   */
  public getValue(): IDataType | undefined {
    return this.value;
  }

  /**
   * Assigns the provided DataType object value to the `value` property.
   *
   * @decorator `@ChoiceDataTypes('DataRequirement.valueFilter.value[x]')`
   *
   * @param value - the `value` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  @ChoiceDataTypes('DataRequirement.valueFilter.value[x]')
  public setValue(value: IDataType | undefined): this {
    if (isDefined<IDataType>(value)) {
      // assertFhirType<IDataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.value = value;
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `value` property exists and has a value; `false` otherwise
   */
  public hasValue(): boolean {
    return isDefined<IDataType>(this.value) && !this.value.isEmpty();
  }

  // *** NOTE ***
  // Following choice datatype-specific "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the `value` property value as a DateTimeType object if defined; else undefined
   */
  public getValueDateTimeType(): DateTimeType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof DateTimeType)) {
      throw new InvalidTypeError(
        `DataType mismatch for DataRequirement.valueFilter.value[x]: Expected DateTimeType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a DateTimeType and has a value; `false` otherwise
   */
  public hasValueDateTimeType(): boolean {
    return this.hasValue() && this.value instanceof DateTimeType;
  }

  /**
   * @returns the `value` property value as a Period object if defined; else undefined
   */
  public getValuePeriod(): Period | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Period)) {
      throw new InvalidTypeError(
        `DataType mismatch for DataRequirement.valueFilter.value[x]: Expected Period but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a Period and has a value; `false` otherwise
   */
  public hasValuePeriod(): boolean {
    return this.hasValue() && this.value instanceof Period;
  }

  /**
   * @returns the `value` property value as a Duration object if defined; else undefined
   */
  public getValueDuration(): Duration | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Duration)) {
      throw new InvalidTypeError(
        `DataType mismatch for DataRequirement.valueFilter.value[x]: Expected Duration but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a Duration and has a value; `false` otherwise
   */
  public hasValueDuration(): boolean {
    return this.hasValue() && this.value instanceof Duration;
  }

  // End of choice datatype-specific "get"/"has" methods

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'DataRequirement.valueFilter';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.path,
      this.searchParam,
      this.comparator,
      this.value,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): DataRequirementValueFilterComponent {
    const dest = new DataRequirementValueFilterComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: DataRequirementValueFilterComponent): void {
    super.copyValues(dest);
    dest.path = this.path?.copy();
    dest.searchParam = this.searchParam?.copy();
    dest.comparator = this.comparator?.copy();
    dest.value = this.value?.copy() as IDataType;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasPathElement()) {
      setFhirPrimitiveJson<fhirString>(this.getPathElement(), 'path', jsonObj);
    }

    if (this.hasSearchParamElement()) {
      setFhirPrimitiveJson<fhirString>(this.getSearchParamElement(), 'searchParam', jsonObj);
    }

    if (this.hasComparatorElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getComparatorElement()!, 'comparator', jsonObj);
    }

    if (this.hasValue()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getValue()!, 'value', jsonObj);
    }

    return jsonObj;
  }
}
/**
 * DataRequirementSortComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Order of the results
 * - **Definition:** Specifies the order of the results to be returned.
 * - **Comment:** This element can be used in combination with the sort element to specify quota requirements such as "the most recent 5" or "the highest 5". When multiple sorts are specified, they are applied in the order they appear in the resource.
 * - **Requirements:** Enables the requirement "most recent 5 results" to be expressed.
 *
 * @category Data Models: ComplexType
 * @see [FHIR DataRequirement](http://hl7.org/fhir/StructureDefinition/DataRequirement)
 */
export class DataRequirementSortComponent extends DataType implements IDataType {
  constructor(path: StringType | fhirString | null = null, direction: EnumCodeType | CodeType | fhirCode | null = null) {
    super();

    this.sortDirectionEnum = new SortDirectionEnum();

    this.path = null;
    if (isDefined<StringType | fhirString>(path)) {
      if (path instanceof PrimitiveType) {
        this.setPathElement(path);
      } else {
        this.setPath(path);
      }
    }

    this.direction = constructorCodeValueAsEnumCodeType<SortDirectionEnum>(
      direction,
      SortDirectionEnum,
      this.sortDirectionEnum,
      'DataRequirement.sort.direction',
    );
  }

  /**
   * Parse the provided `DataRequirementSortComponent` JSON to instantiate the DataRequirementSortComponent data model.
   *
   * @param sourceJson - JSON representing FHIR `DataRequirementSortComponent`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to DataRequirementSortComponent
   * @returns DataRequirementSortComponent data model or undefined for `DataRequirementSortComponent`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): DataRequirementSortComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'DataRequirementSortComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new DataRequirementSortComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'path';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setPathElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'direction';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setDirectionElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_REQD_IN_JSON} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * DataRequirement.sort.path Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The name of the attribute to perform the sort
   * - **Definition:** The attribute of the sort. The specified path must be resolvable from the type of the required data. The path is allowed to contain qualifiers (.) to traverse sub-elements, as well as indexers ([x]) to traverse multiple-cardinality sub-elements. Note that the index must be an integer constant.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private path: StringType | null;

  /**
   * FHIR CodeSystem: SortDirection
   *
   * @see {@link SortDirectionEnum }
   */
  private readonly sortDirectionEnum: SortDirectionEnum;

  /**
   * DataRequirement.sort.direction Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** ascending | descending
   * - **Definition:** The direction of the sort, ascending or descending.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link SortDirectionEnum }
   */
  private direction: EnumCodeType | null;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `path` property value as a StringType object if defined; else null
   */
  public getPathElement(): StringType | null {
    return this.path;
  }

  /**
   * Assigns the provided PrimitiveType value to the `path` property.
   *
   * @param element - the `path` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPathElement(element: StringType): this {
    assertIsDefined<StringType>(element, `DataRequirement.sort.path is required`);
    const optErrMsg = `Invalid DataRequirement.sort.path; Provided value is not an instance of StringType.`;
    assertFhirType<StringType>(element, StringType, optErrMsg);
    this.path = element;
    return this;
  }

  /**
   * @returns `true` if the `path` property exists and has a value; `false` otherwise
   */
  public hasPathElement(): boolean {
    return isDefined<StringType>(this.path) && !this.path.isEmpty();
  }

  /**
   * @returns the `path` property value as a fhirString if defined; else null
   */
  public getPath(): fhirString | null {
    if (this.path?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.path.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the `path` property.
   *
   * @param value - the `path` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPath(value: fhirString): this {
    assertIsDefined<fhirString>(value, `DataRequirement.sort.path is required`);
    const optErrMsg = `Invalid DataRequirement.sort.path (${String(value)})`;
    this.path = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    return this;
  }

  /**
   * @returns `true` if the `path` property exists and has a value; `false` otherwise
   */
  public hasPath(): boolean {
    return this.hasPathElement();
  }

  /**
   * @returns the `direction` property value as a EnumCodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link SortDirectionEnum }
   */
  public getDirectionEnumType(): EnumCodeType | null {
    return this.direction;
  }

  /**
   * Assigns the provided EnumCodeType value to the `direction` property.
   *
   * @param enumType - the `direction` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link SortDirectionEnum }
   */
  public setDirectionEnumType(enumType: EnumCodeType): this {
    assertIsDefined<EnumCodeType>(enumType, `DataRequirement.sort.direction is required`);
    const errMsgPrefix = `Invalid DataRequirement.sort.direction`;
    assertEnumCodeType<SortDirectionEnum>(enumType, SortDirectionEnum, errMsgPrefix);
    this.direction = enumType;
    return this;
  }

  /**
   * @returns `true` if the `direction` property exists and has a value; `false` otherwise
   */
  public hasDirectionEnumType(): boolean {
    return isDefined<EnumCodeType>(this.direction) && !this.direction.isEmpty() && this.direction.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the `direction` property value as a CodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link SortDirectionEnum }
   */
  public getDirectionElement(): CodeType | null {
    if (this.direction === null) {
      return null;
    }
    return this.direction as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the `direction` property.
   *
   * @param element - the `direction` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link SortDirectionEnum }
   */
  public setDirectionElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, `DataRequirement.sort.direction is required`);
    const optErrMsg = `Invalid DataRequirement.sort.direction; Provided value is not an instance of CodeType.`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.direction = new EnumCodeType(element, this.sortDirectionEnum);
    return this;
  }

  /**
   * @returns `true` if the `direction` property exists and has a value; `false` otherwise
   */
  public hasDirectionElement(): boolean {
    return this.hasDirectionEnumType();
  }

  /**
   * @returns the `direction` property value as a fhirCode if defined; else null
   *
   * @see CodeSystem Enumeration: {@link SortDirectionEnum }
   */
  public getDirection(): fhirCode | null {
    if (this.direction === null) {
      return null;
    }
    return this.direction.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the `direction` property.
   *
   * @param value - the `direction` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link SortDirectionEnum }
   */
  public setDirection(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, `DataRequirement.sort.direction is required`);
    const optErrMsg = `Invalid DataRequirement.sort.direction (${String(value)})`;
    this.direction = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.sortDirectionEnum);
    return this;
  }

  /**
   * @returns `true` if the `direction` property exists and has a value; `false` otherwise
   */
  public hasDirection(): boolean {
    return this.hasDirectionEnumType();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'DataRequirement.sort';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.path,
      this.direction,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): DataRequirementSortComponent {
    const dest = new DataRequirementSortComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: DataRequirementSortComponent): void {
    super.copyValues(dest);
    dest.path = this.path ? this.path.copy() : null;
    dest.direction = this.direction ? this.direction.copy() : null;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasPathElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirString>(this.getPathElement()!, 'path', jsonObj);
    } else {
      missingReqdProperties.push(`DataRequirement.sort.path`);
    }

    if (this.hasDirectionElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getDirectionElement()!, 'direction', jsonObj);
    } else {
      missingReqdProperties.push(`DataRequirement.sort.direction`);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_DO_NOT_EXIST} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

/**
 * Distance Class
 *
 * @remarks
 * Distance Type: A length - a value with a unit that is a physical distance.
 *
 * **FHIR Specification**
 * - **Short:** A length - a value with a unit that is a physical distance
 * - **Definition:** A length - a value with a unit that is a physical distance.
 * - **Comment:** The context of use may frequently define what kind of quantity this is and therefore what kind of units can be used. The context of use may also restrict the values for the comparator.
 * - **FHIR Version:** 5.0.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR Distance](http://hl7.org/fhir/StructureDefinition/Distance)
 */
export class Distance extends DataType implements IDataType {
  constructor() {
    super();

    this.quantityComparatorEnum = new QuantityComparatorEnum();
  }

  /**
   * Parse the provided `Distance` JSON to instantiate the Distance data model.
   *
   * @param sourceJson - JSON representing FHIR `Distance`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to Distance
   * @returns Distance data model or undefined for `Distance`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Distance | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Distance';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new Distance();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'value';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setValueElement(datatype);
    }

    fieldName = 'comparator';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setComparatorElement(datatype);
    }

    fieldName = 'unit';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setUnitElement(datatype);
    }

    fieldName = 'system';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = fhirParser.parseUriType(dtJson, dtSiblingJson);
      instance.setSystemElement(datatype);
    }

    fieldName = 'code';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setCodeElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Distance.value Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Numerical value (with implicit precision)
   * - **Definition:** The value of the measured amount. The value includes an implicit precision in the presentation of the value.
   * - **Comment:** The implicit precision in the value should always be honored. Monetary values have their own rules for handling precision (refer to standard accounting text books).
   * - **Requirements:** Precision is handled implicitly in almost all cases of measurement.
   * - **FHIR Type:** `decimal`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private value?: DecimalType | undefined;

  /**
   * FHIR CodeSystem: QuantityComparator
   *
   * @see {@link QuantityComparatorEnum }
   */
  private readonly quantityComparatorEnum: QuantityComparatorEnum;

  /**
   * Distance.comparator Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** < | <= | >= | > | ad - how to understand the value
   * - **Definition:** How the value should be understood and represented - whether the actual value is greater or less than the stated value due to measurement issues; e.g. if the comparator is "<" , then the real value is < stated value.
   * - **Requirements:** Need a framework for handling measures where the value is <5ug/L or >400mg/L due to the limitations of measuring methodology.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** true
   * - **isModifierReason:** This is labeled as &quot;Is Modifier&quot; because the comparator modifies the interpretation of the value significantly. If there is no comparator, then there is no modification of the value
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  private comparator?: EnumCodeType | undefined;

  /**
   * Distance.unit Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Unit representation
   * - **Definition:** A human-readable form of the unit.
   * - **Requirements:** There are many representations for units of measure and in many contexts, particular representations are fixed and required. I.e. mcg for micrograms.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private unit?: StringType | undefined;

  /**
   * Distance.system Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** System that defines coded unit form
   * - **Definition:** The identification of the system that provides the coded form of the unit.
   * - **Requirements:** Need to know the system that defines the coded form of the unit.
   * - **FHIR Type:** `uri`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private system?: UriType | undefined;

  /**
   * Distance.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Coded form of the unit
   * - **Definition:** A computer processable form of the unit in some unit representation system.
   * - **Comment:** The preferred system is UCUM, but SNOMED CT can also be used (for customary units) or ISO 4217 for currency.  The context of use may additionally require a code from a particular system.
   * - **Requirements:** Need a computable form of the unit that is fixed across all forms. UCUM provides this for quantities, but SNOMED CT provides many units of interest.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code?: CodeType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `value` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getValueElement(): DecimalType {
    return this.value ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `value` property.
   *
   * @param element - the `value` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValueElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = `Invalid Distance.value; Provided element is not an instance of DecimalType.`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.value = element;
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `value` property exists and has a value; `false` otherwise
   */
  public hasValueElement(): boolean {
    return isDefined<DecimalType>(this.value) && !this.value.isEmpty();
  }

  /**
   * @returns the `value` property value as a fhirDecimal if defined; else undefined
   */
  public getValue(): fhirDecimal | undefined {
    return this.value?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `value` property.
   *
   * @param value - the `value` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValue(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = `Invalid Distance.value (${String(value)})`;
      this.value = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `value` property exists and has a value; `false` otherwise
   */
  public hasValue(): boolean {
    return this.hasValueElement();
  }

  /**
   * @returns the `comparator` property value as a EnumCodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public getComparatorEnumType(): EnumCodeType | undefined {
    return this.comparator;
  }

  /**
   * Assigns the provided EnumCodeType value to the `comparator` property.
   *
   * @param enumType - the `comparator` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code values
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public setComparatorEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid Distance.comparator';
      assertEnumCodeType<QuantityComparatorEnum>(enumType, QuantityComparatorEnum, errMsgPrefix);
      this.comparator = enumType;
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `comparator` property exists and has a value; `false` otherwise
   */
  public hasComparatorEnumType(): boolean {
    return isDefined<EnumCodeType>(this.comparator) && !this.comparator.isEmpty() && this.comparator.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the `comparator` property value as a CodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public getComparatorElement(): CodeType | undefined {
    if (this.comparator === undefined) {
      return undefined;
    }
    return this.comparator as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the `comparator` property.
   *
   * @param element - the `comparator` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public setComparatorElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid Distance.comparator; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.comparator = new EnumCodeType(element, this.quantityComparatorEnum);
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `comparator` property exists and has a value; `false` otherwise
   */
  public hasComparatorElement(): boolean {
    return this.hasComparatorEnumType();
  }

  /**
   * @returns the `comparator` property value as a fhirCode if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public getComparator(): fhirCode | undefined {
    if (this.comparator === undefined) {
      return undefined;
    }
    return this.comparator.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the `comparator` property.
   *
   * @param value - the `comparator` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public setComparator(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid Distance.comparator; Provided value is not an instance of fhirCode.`;
      this.comparator = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.quantityComparatorEnum);
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `comparator` property exists and has a value; `false` otherwise
   */
  public hasComparator(): boolean {
    return this.hasComparatorEnumType();
  }

  /**
   * @returns the `unit` property value as a StringType object if defined; else an empty StringType object
   */
  public getUnitElement(): StringType {
    return this.unit ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `unit` property.
   *
   * @param element - the `unit` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUnitElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid Distance.unit; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.unit = element;
    } else {
      this.unit = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `unit` property exists and has a value; `false` otherwise
   */
  public hasUnitElement(): boolean {
    return isDefined<StringType>(this.unit) && !this.unit.isEmpty();
  }

  /**
   * @returns the `unit` property value as a fhirString if defined; else undefined
   */
  public getUnit(): fhirString | undefined {
    return this.unit?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `unit` property.
   *
   * @param value - the `unit` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUnit(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid Distance.unit (${String(value)})`;
      this.unit = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.unit = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `unit` property exists and has a value; `false` otherwise
   */
  public hasUnit(): boolean {
    return this.hasUnitElement();
  }

  /**
   * @returns the `system` property value as a UriType object if defined; else an empty UriType object
   */
  public getSystemElement(): UriType {
    return this.system ?? new UriType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `system` property.
   *
   * @param element - the `system` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSystemElement(element: UriType | undefined): this {
    if (isDefined<UriType>(element)) {
      const optErrMsg = `Invalid Distance.system; Provided element is not an instance of UriType.`;
      assertFhirType<UriType>(element, UriType, optErrMsg);
      this.system = element;
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `system` property exists and has a value; `false` otherwise
   */
  public hasSystemElement(): boolean {
    return isDefined<UriType>(this.system) && !this.system.isEmpty();
  }

  /**
   * @returns the `system` property value as a fhirUri if defined; else undefined
   */
  public getSystem(): fhirUri | undefined {
    return this.system?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `system` property.
   *
   * @param value - the `system` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSystem(value: fhirUri | undefined): this {
    if (isDefined<fhirUri>(value)) {
      const optErrMsg = `Invalid Distance.system (${String(value)})`;
      this.system = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `system` property exists and has a value; `false` otherwise
   */
  public hasSystem(): boolean {
    return this.hasSystemElement();
  }

  /**
   * @returns the `code` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getCodeElement(): CodeType {
    return this.code ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `code` property.
   *
   * @param element - the `code` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCodeElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid Distance.code; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.code = element;
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `code` property exists and has a value; `false` otherwise
   */
  public hasCodeElement(): boolean {
    return isDefined<CodeType>(this.code) && !this.code.isEmpty();
  }

  /**
   * @returns the `code` property value as a fhirCode if defined; else undefined
   */
  public getCode(): fhirCode | undefined {
    return this.code?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `code` property.
   *
   * @param value - the `code` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCode(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid Distance.code (${String(value)})`;
      this.code = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `code` property exists and has a value; `false` otherwise
   */
  public hasCode(): boolean {
    return this.hasCodeElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Distance';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.value,
      this.comparator,
      this.unit,
      this.system,
      this.code,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Distance {
    const dest = new Distance();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Distance): void {
    super.copyValues(dest);
    dest.value = this.value?.copy();
    dest.comparator = this.comparator?.copy();
    dest.unit = this.unit?.copy();
    dest.system = this.system?.copy();
    dest.code = this.code?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasValueElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getValueElement(), 'value', jsonObj);
    }

    if (this.hasComparatorElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getComparatorElement()!, 'comparator', jsonObj);
    }

    if (this.hasUnitElement()) {
      setFhirPrimitiveJson<fhirString>(this.getUnitElement(), 'unit', jsonObj);
    }

    if (this.hasSystemElement()) {
      setFhirPrimitiveJson<fhirUri>(this.getSystemElement(), 'system', jsonObj);
    }

    if (this.hasCodeElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getCodeElement(), 'code', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * Dosage Class
 *
 * @remarks
 * Dosage Type: Indicates how the medication is/was taken or should be taken by the patient.
 *
 * **FHIR Specification**
 * - **Short:** How the medication is/was taken or should be taken
 * - **Definition:** Indicates how the medication is/was taken or should be taken by the patient.
 * - **FHIR Version:** 5.0.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR Dosage](http://hl7.org/fhir/StructureDefinition/Dosage)
 */
export class Dosage extends BackboneType implements IBackboneType {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided `Dosage` JSON to instantiate the Dosage data model.
   *
   * @param sourceJson - JSON representing FHIR `Dosage`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to Dosage
   * @returns Dosage data model or undefined for `Dosage`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Dosage | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Dosage';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new Dosage();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneTypeJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'sequence';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: IntegerType | undefined = fhirParser.parseIntegerType(dtJson, dtSiblingJson);
      instance.setSequenceElement(datatype);
    }

    fieldName = 'text';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setTextElement(datatype);
    }

    fieldName = 'additionalInstruction';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: CodeableConcept | undefined = CodeableConcept.parse(dataElementJson, `${sourceField}[${String(idx)}]`);
        if (datatype !== undefined) {
          instance.addAdditionalInstruction(datatype);
        }
      });
    }

    fieldName = 'patientInstruction';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setPatientInstructionElement(datatype);
    }

    fieldName = 'timing';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Timing | undefined = Timing.parse(classJsonObj[fieldName]!, sourceField);
      instance.setTiming(datatype);
    }

    fieldName = 'asNeeded';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'boolean';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: BooleanType | undefined = fhirParser.parseBooleanType(dtJson, dtSiblingJson);
      instance.setAsNeededElement(datatype);
    }

    fieldName = 'asNeededFor';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: CodeableConcept | undefined = CodeableConcept.parse(dataElementJson, `${sourceField}[${String(idx)}]`);
        if (datatype !== undefined) {
          instance.addAsNeededFor(datatype);
        }
      });
    }

    fieldName = 'site';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = CodeableConcept.parse(classJsonObj[fieldName]!, sourceField);
      instance.setSite(datatype);
    }

    fieldName = 'route';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = CodeableConcept.parse(classJsonObj[fieldName]!, sourceField);
      instance.setRoute(datatype);
    }

    fieldName = 'method';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = CodeableConcept.parse(classJsonObj[fieldName]!, sourceField);
      instance.setMethod(datatype);
    }

    fieldName = 'doseAndRate';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: DosageDoseAndRateComponent | undefined = DosageDoseAndRateComponent.parse(dataElementJson, `${sourceField}[${String(idx)}]`);
        if (datatype !== undefined) {
          instance.addDoseAndRate(datatype);
        }
      });
    }

    fieldName = 'maxDosePerPeriod';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Ratio | undefined = Ratio.parse(dataElementJson, `${sourceField}[${String(idx)}]`);
        if (datatype !== undefined) {
          instance.addMaxDosePerPeriod(datatype);
        }
      });
    }

    fieldName = 'maxDosePerAdministration';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = Quantity.parse(classJsonObj[fieldName]!, sourceField);
      instance.setMaxDosePerAdministration(datatype);
    }

    fieldName = 'maxDosePerLifetime';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = Quantity.parse(classJsonObj[fieldName]!, sourceField);
      instance.setMaxDosePerLifetime(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Dosage.sequence Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The order of the dosage instructions
   * - **Definition:** Indicates the order in which the dosage instructions should be applied or interpreted.
   * - **Requirements:** If the sequence number of multiple Dosages is the same, then it is implied that the instructions are to be treated as concurrent.  If the sequence number is different, then the Dosages are intended to be sequential.
   * - **FHIR Type:** `integer`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private sequence?: IntegerType | undefined;

  /**
   * Dosage.text Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Free text dosage instructions e.g. SIG
   * - **Definition:** Free text dosage instructions e.g. SIG.
   * - **Requirements:** Free text dosage instructions can be used for cases where the instructions are too complex to code.  The content of this attribute does not include the name or description of the medication. When coded instructions are present, the free text instructions may still be present for display to humans taking or administering the medication. It is expected that the text instructions will always be populated.  If the dosage.timing attribute is also populated, then the dosage.text should reflect the same information as the timing.  Additional information about administration or preparation of the medication should be included as text.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private text?: StringType | undefined;

  /**
   * Dosage.additionalInstruction Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Supplemental instruction or warnings to the patient - e.g. "with meals", "may cause drowsiness"
   * - **Definition:** Supplemental instructions to the patient on how to take the medication  (e.g. "with meals" or"take half to one hour before food") or warnings for the patient about the medication (e.g. "may cause drowsiness" or "avoid exposure of skin to direct sunlight or sunlamps").
   * - **Comment:** Information about administration or preparation of the medication (e.g. "infuse as rapidly as possibly via intraperitoneal port" or take "immediately following drug x") should be populated in dosage.text.
   * - **Requirements:** Additional instruction is intended to be coded, but where no code exists, the element could include text.  For example, "Swallow with plenty of water" which might or might not be coded.
   * - **FHIR Type:** `CodeableConcept`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private additionalInstruction?: CodeableConcept[] | undefined;

  /**
   * Dosage.patientInstruction Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Patient or consumer oriented instructions
   * - **Definition:** Instructions in terms that are understood by the patient or consumer.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private patientInstruction?: StringType | undefined;

  /**
   * Dosage.timing Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** When medication should be administered
   * - **Definition:** When medication should be administered.
   * - **Comment:** This attribute might not always be populated while the Dosage.text is expected to be populated.  If both are populated, then the Dosage.text should reflect the content of the Dosage.timing.
   * - **Requirements:** The timing schedule for giving the medication to the patient. This  data type allows many different expressions. For example: "Every 8 hours"; "Three times a day"; "1/2 an hour before breakfast for 10 days from 23-Dec 2011:"; "15 Oct 2013, 17 Oct 2013 and 1 Nov 2013".  Sometimes, a rate can imply duration when expressed as total volume / duration (e.g.  500mL/2 hours implies a duration of 2 hours).  However, when rate doesn\'t imply duration (e.g. 250mL/hour), then the timing.repeat.duration is needed to convey the infuse over time period.
   * - **FHIR Type:** `Timing`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private timing?: Timing | undefined;

  /**
   * Dosage.asNeeded Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Take "as needed"
   * - **Definition:** Indicates whether the Medication is only taken when needed within a specific dosing schedule (Boolean option).
   * - **Comment:** Can express "as needed" without a reason by setting the Boolean = True.  In this case the CodeableConcept is not populated.
   * - **FHIR Type:** `boolean`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private asNeeded?: BooleanType | undefined;

  /**
   * Dosage.asNeededFor Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Take "as needed" (for x)
   * - **Definition:** Indicates whether the Medication is only taken based on a precondition for taking the Medication (CodeableConcept).
   * - **Comment:** Can express "as needed" with a reason by including the CodeableConcept.  In this case the Boolean is assumed to be False, then the dose is given according to the schedule and is not "prn" or "as needed".
   * - **FHIR Type:** `CodeableConcept`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private asNeededFor?: CodeableConcept[] | undefined;

  /**
   * Dosage.site Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Body site to administer to
   * - **Definition:** Body site to administer to.
   * - **Comment:** If the use case requires attributes from the BodySite resource (e.g. to identify and track separately) then use the standard extension [http://hl7.org/fhir/StructureDefinition/bodySite](http://hl7.org/fhir/extensions/https://hl7.org/fhir/StructureDefinition-bodySite.html).  May be a summary code, or a reference to a very precise definition of the location, or both.
   * - **Requirements:** A coded specification of the anatomic site where the medication first enters the body.
   * - **FHIR Type:** `CodeableConcept`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private site?: CodeableConcept | undefined;

  /**
   * Dosage.route Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** How drug should enter body
   * - **Definition:** How drug should enter body.
   * - **Requirements:** A code specifying the route or physiological path of administration of a therapeutic agent into or onto a patient\'s body.
   * - **FHIR Type:** `CodeableConcept`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private route?: CodeableConcept | undefined;

  /**
   * Dosage.method Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Technique for administering medication
   * - **Definition:** Technique for administering medication.
   * - **Comment:** Terminologies used often pre-coordinate this term with the route and or form of administration.
   * - **Requirements:** A coded value indicating the method by which the medication is introduced into or onto the body. Most commonly used for injections.  For examples, Slow Push; Deep IV.
   * - **FHIR Type:** `CodeableConcept`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private method?: CodeableConcept | undefined;

  /**
   * Dosage.doseAndRate Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Amount of medication administered, to be administered or typical amount to be administered
   * - **Definition:** Depending on the resource,this is the amount of medication administered, to  be administered or typical amount to be administered.
   * - **FHIR Type:** `Element`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private doseAndRate?: DosageDoseAndRateComponent[] | undefined;

  /**
   * Dosage.maxDosePerPeriod Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Upper limit on medication per unit of time
   * - **Definition:** Upper limit on medication per unit of time.
   * - **Comment:** This is intended for use as an adjunct to the dosage when there is an upper cap.  For example "2 tablets every 4 hours to a maximum of 8/day".
   * - **Requirements:** The maximum total quantity of a therapeutic substance that may be administered to a subject over the period of time.  For example, 1000mg in 24 hours.
   * - **FHIR Type:** `Ratio`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private maxDosePerPeriod?: Ratio[] | undefined;

  /**
   * Dosage.maxDosePerAdministration Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Upper limit on medication per administration
   * - **Definition:** Upper limit on medication per administration.
   * - **Comment:** This is intended for use as an adjunct to the dosage when there is an upper cap.  For example, a body surface area related dose with a maximum amount, such as 1.5 mg/m2 (maximum 2 mg) IV over 5 - 10 minutes would have doseQuantity of 1.5 mg/m2 and maxDosePerAdministration of 2 mg.
   * - **Requirements:** The maximum total quantity of a therapeutic substance that may be administered to a subject per administration.
   * - **FHIR Type:** `Quantity`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private maxDosePerAdministration?: Quantity | undefined;

  /**
   * Dosage.maxDosePerLifetime Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Upper limit on medication per lifetime of the patient
   * - **Definition:** Upper limit on medication per lifetime of the patient.
   * - **Requirements:** The maximum total quantity of a therapeutic substance that may be administered per lifetime of the subject.
   * - **FHIR Type:** `Quantity`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private maxDosePerLifetime?: Quantity | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `sequence` property value as a IntegerType object if defined; else an empty IntegerType object
   */
  public getSequenceElement(): IntegerType {
    return this.sequence ?? new IntegerType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `sequence` property.
   *
   * @param element - the `sequence` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSequenceElement(element: IntegerType | undefined): this {
    if (isDefined<IntegerType>(element)) {
      const optErrMsg = `Invalid Dosage.sequence; Provided element is not an instance of IntegerType.`;
      assertFhirType<IntegerType>(element, IntegerType, optErrMsg);
      this.sequence = element;
    } else {
      this.sequence = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `sequence` property exists and has a value; `false` otherwise
   */
  public hasSequenceElement(): boolean {
    return isDefined<IntegerType>(this.sequence) && !this.sequence.isEmpty();
  }

  /**
   * @returns the `sequence` property value as a fhirInteger if defined; else undefined
   */
  public getSequence(): fhirInteger | undefined {
    return this.sequence?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `sequence` property.
   *
   * @param value - the `sequence` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSequence(value: fhirInteger | undefined): this {
    if (isDefined<fhirInteger>(value)) {
      const optErrMsg = `Invalid Dosage.sequence (${String(value)})`;
      this.sequence = new IntegerType(parseFhirPrimitiveData(value, fhirIntegerSchema, optErrMsg));
    } else {
      this.sequence = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `sequence` property exists and has a value; `false` otherwise
   */
  public hasSequence(): boolean {
    return this.hasSequenceElement();
  }

  /**
   * @returns the `text` property value as a StringType object if defined; else an empty StringType object
   */
  public getTextElement(): StringType {
    return this.text ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `text` property.
   *
   * @param element - the `text` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTextElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid Dosage.text; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.text = element;
    } else {
      this.text = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `text` property exists and has a value; `false` otherwise
   */
  public hasTextElement(): boolean {
    return isDefined<StringType>(this.text) && !this.text.isEmpty();
  }

  /**
   * @returns the `text` property value as a fhirString if defined; else undefined
   */
  public getText(): fhirString | undefined {
    return this.text?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `text` property.
   *
   * @param value - the `text` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setText(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid Dosage.text (${String(value)})`;
      this.text = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.text = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `text` property exists and has a value; `false` otherwise
   */
  public hasText(): boolean {
    return this.hasTextElement();
  }

  /**
   * @returns the `additionalInstruction` property value as a CodeableConcept array
   */
  public getAdditionalInstruction(): CodeableConcept[] {
    return this.additionalInstruction ?? ([] as CodeableConcept[]);
  }

  /**
   * Assigns the provided CodeableConcept array value to the `additionalInstruction` property.
   *
   * @param value - the `additionalInstruction` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setAdditionalInstruction(value: CodeableConcept[] | undefined): this {
    if (isDefinedList<CodeableConcept>(value)) {
      const optErrMsg = `Invalid Dosage.additionalInstruction; Provided value array has an element that is not an instance of CodeableConcept.`;
      assertFhirTypeList<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.additionalInstruction = value;
    } else {
      this.additionalInstruction = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeableConcept value to the `additionalInstruction` array property.
   *
   * @param value - the `additionalInstruction` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addAdditionalInstruction(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = `Invalid Dosage.additionalInstruction; Provided element is not an instance of CodeableConcept.`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.initAdditionalInstruction();
      this.additionalInstruction?.push(value);
    }
    return this;
  }

  /**
   * @returns `true` if the `additionalInstruction` property exists and has a value; `false` otherwise
   */
  public hasAdditionalInstruction(): boolean {
    return isDefinedList<CodeableConcept>(this.additionalInstruction) && this.additionalInstruction.some((item: CodeableConcept) => !item.isEmpty());
  }

  /**
   * Initialize the `additionalInstruction` property
   */
  private initAdditionalInstruction(): void {
    if(!this.hasAdditionalInstruction()) {
      this.additionalInstruction = [] as CodeableConcept[];
    }
  }

  /**
   * @returns the `patientInstruction` property value as a StringType object if defined; else an empty StringType object
   */
  public getPatientInstructionElement(): StringType {
    return this.patientInstruction ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `patientInstruction` property.
   *
   * @param element - the `patientInstruction` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPatientInstructionElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid Dosage.patientInstruction; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.patientInstruction = element;
    } else {
      this.patientInstruction = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `patientInstruction` property exists and has a value; `false` otherwise
   */
  public hasPatientInstructionElement(): boolean {
    return isDefined<StringType>(this.patientInstruction) && !this.patientInstruction.isEmpty();
  }

  /**
   * @returns the `patientInstruction` property value as a fhirString if defined; else undefined
   */
  public getPatientInstruction(): fhirString | undefined {
    return this.patientInstruction?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `patientInstruction` property.
   *
   * @param value - the `patientInstruction` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPatientInstruction(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid Dosage.patientInstruction (${String(value)})`;
      this.patientInstruction = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.patientInstruction = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `patientInstruction` property exists and has a value; `false` otherwise
   */
  public hasPatientInstruction(): boolean {
    return this.hasPatientInstructionElement();
  }

  /**
   * @returns the `timing` property value as a Timing object if defined; else an empty Timing object
   */
  public getTiming(): Timing {
    return this.timing ?? new Timing();
  }

  /**
   * Assigns the provided Timing object value to the `timing` property.
   *
   * @param value - the `timing` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setTiming(value: Timing | undefined): this {
    if (isDefined<Timing>(value)) {
      const optErrMsg = `Invalid Dosage.timing; Provided element is not an instance of Timing.`;
      assertFhirType<Timing>(value, Timing, optErrMsg);
      this.timing = value;
    } else {
      this.timing = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `timing` property exists and has a value; `false` otherwise
   */
  public hasTiming(): boolean {
    return isDefined<Timing>(this.timing) && !this.timing.isEmpty();
  }

  /**
   * @returns the `asNeeded` property value as a BooleanType object if defined; else an empty BooleanType object
   */
  public getAsNeededElement(): BooleanType {
    return this.asNeeded ?? new BooleanType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `asNeeded` property.
   *
   * @param element - the `asNeeded` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAsNeededElement(element: BooleanType | undefined): this {
    if (isDefined<BooleanType>(element)) {
      const optErrMsg = `Invalid Dosage.asNeeded; Provided element is not an instance of BooleanType.`;
      assertFhirType<BooleanType>(element, BooleanType, optErrMsg);
      this.asNeeded = element;
    } else {
      this.asNeeded = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `asNeeded` property exists and has a value; `false` otherwise
   */
  public hasAsNeededElement(): boolean {
    return isDefined<BooleanType>(this.asNeeded) && !this.asNeeded.isEmpty();
  }

  /**
   * @returns the `asNeeded` property value as a fhirBoolean if defined; else undefined
   */
  public getAsNeeded(): fhirBoolean | undefined {
    return this.asNeeded?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `asNeeded` property.
   *
   * @param value - the `asNeeded` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAsNeeded(value: fhirBoolean | undefined): this {
    if (isDefined<fhirBoolean>(value)) {
      const optErrMsg = `Invalid Dosage.asNeeded (${String(value)})`;
      this.asNeeded = new BooleanType(parseFhirPrimitiveData(value, fhirBooleanSchema, optErrMsg));
    } else {
      this.asNeeded = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `asNeeded` property exists and has a value; `false` otherwise
   */
  public hasAsNeeded(): boolean {
    return this.hasAsNeededElement();
  }

  /**
   * @returns the `asNeededFor` property value as a CodeableConcept array
   */
  public getAsNeededFor(): CodeableConcept[] {
    return this.asNeededFor ?? ([] as CodeableConcept[]);
  }

  /**
   * Assigns the provided CodeableConcept array value to the `asNeededFor` property.
   *
   * @param value - the `asNeededFor` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setAsNeededFor(value: CodeableConcept[] | undefined): this {
    if (isDefinedList<CodeableConcept>(value)) {
      const optErrMsg = `Invalid Dosage.asNeededFor; Provided value array has an element that is not an instance of CodeableConcept.`;
      assertFhirTypeList<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.asNeededFor = value;
    } else {
      this.asNeededFor = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeableConcept value to the `asNeededFor` array property.
   *
   * @param value - the `asNeededFor` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addAsNeededFor(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = `Invalid Dosage.asNeededFor; Provided element is not an instance of CodeableConcept.`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.initAsNeededFor();
      this.asNeededFor?.push(value);
    }
    return this;
  }

  /**
   * @returns `true` if the `asNeededFor` property exists and has a value; `false` otherwise
   */
  public hasAsNeededFor(): boolean {
    return isDefinedList<CodeableConcept>(this.asNeededFor) && this.asNeededFor.some((item: CodeableConcept) => !item.isEmpty());
  }

  /**
   * Initialize the `asNeededFor` property
   */
  private initAsNeededFor(): void {
    if(!this.hasAsNeededFor()) {
      this.asNeededFor = [] as CodeableConcept[];
    }
  }

  /**
   * @returns the `site` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getSite(): CodeableConcept {
    return this.site ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Site object value to the `site` property.
   *
   * @param value - the `site` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setSite(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = `Invalid Dosage.site; Provided element is not an instance of CodeableConcept.`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.site = value;
    } else {
      this.site = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `site` property exists and has a value; `false` otherwise
   */
  public hasSite(): boolean {
    return isDefined<CodeableConcept>(this.site) && !this.site.isEmpty();
  }

  /**
   * @returns the `route` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getRoute(): CodeableConcept {
    return this.route ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Route object value to the `route` property.
   *
   * @param value - the `route` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setRoute(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = `Invalid Dosage.route; Provided element is not an instance of CodeableConcept.`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.route = value;
    } else {
      this.route = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `route` property exists and has a value; `false` otherwise
   */
  public hasRoute(): boolean {
    return isDefined<CodeableConcept>(this.route) && !this.route.isEmpty();
  }

  /**
   * @returns the `method` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getMethod(): CodeableConcept {
    return this.method ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Method object value to the `method` property.
   *
   * @param value - the `method` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setMethod(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = `Invalid Dosage.method; Provided element is not an instance of CodeableConcept.`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.method = value;
    } else {
      this.method = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `method` property exists and has a value; `false` otherwise
   */
  public hasMethod(): boolean {
    return isDefined<CodeableConcept>(this.method) && !this.method.isEmpty();
  }

  /**
   * @returns the `doseAndRate` property value as a DosageDoseAndRateComponent array
   */
  public getDoseAndRate(): DosageDoseAndRateComponent[] {
    return this.doseAndRate ?? ([] as DosageDoseAndRateComponent[]);
  }

  /**
   * Assigns the provided DosageDoseAndRateComponent array value to the `doseAndRate` property.
   *
   * @param value - the `doseAndRate` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setDoseAndRate(value: DosageDoseAndRateComponent[] | undefined): this {
    if (isDefinedList<DosageDoseAndRateComponent>(value)) {
      const optErrMsg = `Invalid Dosage.doseAndRate; Provided value array has an element that is not an instance of DosageDoseAndRateComponent.`;
      assertFhirTypeList<DosageDoseAndRateComponent>(value, DosageDoseAndRateComponent, optErrMsg);
      this.doseAndRate = value;
    } else {
      this.doseAndRate = undefined;
    }
    return this;
  }

  /**
   * Add the provided DosageDoseAndRateComponent value to the `doseAndRate` array property.
   *
   * @param value - the `doseAndRate` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addDoseAndRate(value: DosageDoseAndRateComponent | undefined): this {
    if (isDefined<DosageDoseAndRateComponent>(value)) {
      const optErrMsg = `Invalid Dosage.doseAndRate; Provided element is not an instance of DosageDoseAndRateComponent.`;
      assertFhirType<DosageDoseAndRateComponent>(value, DosageDoseAndRateComponent, optErrMsg);
      this.initDoseAndRate();
      this.doseAndRate?.push(value);
    }
    return this;
  }

  /**
   * @returns `true` if the `doseAndRate` property exists and has a value; `false` otherwise
   */
  public hasDoseAndRate(): boolean {
    return isDefinedList<DosageDoseAndRateComponent>(this.doseAndRate) && this.doseAndRate.some((item: DosageDoseAndRateComponent) => !item.isEmpty());
  }

  /**
   * Initialize the `doseAndRate` property
   */
  private initDoseAndRate(): void {
    if(!this.hasDoseAndRate()) {
      this.doseAndRate = [] as DosageDoseAndRateComponent[];
    }
  }

  /**
   * @returns the `maxDosePerPeriod` property value as a Ratio array
   */
  public getMaxDosePerPeriod(): Ratio[] {
    return this.maxDosePerPeriod ?? ([] as Ratio[]);
  }

  /**
   * Assigns the provided Ratio array value to the `maxDosePerPeriod` property.
   *
   * @param value - the `maxDosePerPeriod` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setMaxDosePerPeriod(value: Ratio[] | undefined): this {
    if (isDefinedList<Ratio>(value)) {
      const optErrMsg = `Invalid Dosage.maxDosePerPeriod; Provided value array has an element that is not an instance of Ratio.`;
      assertFhirTypeList<Ratio>(value, Ratio, optErrMsg);
      this.maxDosePerPeriod = value;
    } else {
      this.maxDosePerPeriod = undefined;
    }
    return this;
  }

  /**
   * Add the provided Ratio value to the `maxDosePerPeriod` array property.
   *
   * @param value - the `maxDosePerPeriod` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addMaxDosePerPeriod(value: Ratio | undefined): this {
    if (isDefined<Ratio>(value)) {
      const optErrMsg = `Invalid Dosage.maxDosePerPeriod; Provided element is not an instance of Ratio.`;
      assertFhirType<Ratio>(value, Ratio, optErrMsg);
      this.initMaxDosePerPeriod();
      this.maxDosePerPeriod?.push(value);
    }
    return this;
  }

  /**
   * @returns `true` if the `maxDosePerPeriod` property exists and has a value; `false` otherwise
   */
  public hasMaxDosePerPeriod(): boolean {
    return isDefinedList<Ratio>(this.maxDosePerPeriod) && this.maxDosePerPeriod.some((item: Ratio) => !item.isEmpty());
  }

  /**
   * Initialize the `maxDosePerPeriod` property
   */
  private initMaxDosePerPeriod(): void {
    if(!this.hasMaxDosePerPeriod()) {
      this.maxDosePerPeriod = [] as Ratio[];
    }
  }

  /**
   * @returns the `maxDosePerAdministration` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getMaxDosePerAdministration(): Quantity {
    return this.maxDosePerAdministration ?? new Quantity();
  }

  /**
   * Assigns the provided MaxDosePerAdministration object value to the `maxDosePerAdministration` property.
   *
   * @param value - the `maxDosePerAdministration` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setMaxDosePerAdministration(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = `Invalid Dosage.maxDosePerAdministration; Provided element is not an instance of Quantity.`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.maxDosePerAdministration = value;
    } else {
      this.maxDosePerAdministration = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `maxDosePerAdministration` property exists and has a value; `false` otherwise
   */
  public hasMaxDosePerAdministration(): boolean {
    return isDefined<Quantity>(this.maxDosePerAdministration) && !this.maxDosePerAdministration.isEmpty();
  }

  /**
   * @returns the `maxDosePerLifetime` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getMaxDosePerLifetime(): Quantity {
    return this.maxDosePerLifetime ?? new Quantity();
  }

  /**
   * Assigns the provided MaxDosePerLifetime object value to the `maxDosePerLifetime` property.
   *
   * @param value - the `maxDosePerLifetime` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setMaxDosePerLifetime(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = `Invalid Dosage.maxDosePerLifetime; Provided element is not an instance of Quantity.`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.maxDosePerLifetime = value;
    } else {
      this.maxDosePerLifetime = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `maxDosePerLifetime` property exists and has a value; `false` otherwise
   */
  public hasMaxDosePerLifetime(): boolean {
    return isDefined<Quantity>(this.maxDosePerLifetime) && !this.maxDosePerLifetime.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Dosage';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.sequence,
      this.text,
      this.additionalInstruction,
      this.patientInstruction,
      this.timing,
      this.asNeeded,
      this.asNeededFor,
      this.site,
      this.route,
      this.method,
      this.doseAndRate,
      this.maxDosePerPeriod,
      this.maxDosePerAdministration,
      this.maxDosePerLifetime,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Dosage {
    const dest = new Dosage();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Dosage): void {
    super.copyValues(dest);
    dest.sequence = this.sequence?.copy();
    dest.text = this.text?.copy();
    const additionalInstructionList = copyListValues<CodeableConcept>(this.additionalInstruction);
    dest.additionalInstruction = additionalInstructionList.length === 0 ? undefined : additionalInstructionList;
    dest.patientInstruction = this.patientInstruction?.copy();
    dest.timing = this.timing?.copy();
    dest.asNeeded = this.asNeeded?.copy();
    const asNeededForList = copyListValues<CodeableConcept>(this.asNeededFor);
    dest.asNeededFor = asNeededForList.length === 0 ? undefined : asNeededForList;
    dest.site = this.site?.copy();
    dest.route = this.route?.copy();
    dest.method = this.method?.copy();
    const doseAndRateList = copyListValues<DosageDoseAndRateComponent>(this.doseAndRate);
    dest.doseAndRate = doseAndRateList.length === 0 ? undefined : doseAndRateList;
    const maxDosePerPeriodList = copyListValues<Ratio>(this.maxDosePerPeriod);
    dest.maxDosePerPeriod = maxDosePerPeriodList.length === 0 ? undefined : maxDosePerPeriodList;
    dest.maxDosePerAdministration = this.maxDosePerAdministration?.copy();
    dest.maxDosePerLifetime = this.maxDosePerLifetime?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasSequenceElement()) {
      setFhirPrimitiveJson<fhirInteger>(this.getSequenceElement(), 'sequence', jsonObj);
    }

    if (this.hasTextElement()) {
      setFhirPrimitiveJson<fhirString>(this.getTextElement(), 'text', jsonObj);
    }

    if (this.hasAdditionalInstruction()) {
      setFhirComplexListJson(this.getAdditionalInstruction(), 'additionalInstruction', jsonObj);
    }

    if (this.hasPatientInstructionElement()) {
      setFhirPrimitiveJson<fhirString>(this.getPatientInstructionElement(), 'patientInstruction', jsonObj);
    }

    if (this.hasTiming()) {
      setFhirComplexJson(this.getTiming(), 'timing', jsonObj);
    }

    if (this.hasAsNeededElement()) {
      setFhirPrimitiveJson<fhirBoolean>(this.getAsNeededElement(), 'asNeeded', jsonObj);
    }

    if (this.hasAsNeededFor()) {
      setFhirComplexListJson(this.getAsNeededFor(), 'asNeededFor', jsonObj);
    }

    if (this.hasSite()) {
      setFhirComplexJson(this.getSite(), 'site', jsonObj);
    }

    if (this.hasRoute()) {
      setFhirComplexJson(this.getRoute(), 'route', jsonObj);
    }

    if (this.hasMethod()) {
      setFhirComplexJson(this.getMethod(), 'method', jsonObj);
    }

    if (this.hasDoseAndRate()) {
      setFhirComplexListJson(this.getDoseAndRate(), 'doseAndRate', jsonObj);
    }

    if (this.hasMaxDosePerPeriod()) {
      setFhirComplexListJson(this.getMaxDosePerPeriod(), 'maxDosePerPeriod', jsonObj);
    }

    if (this.hasMaxDosePerAdministration()) {
      setFhirComplexJson(this.getMaxDosePerAdministration(), 'maxDosePerAdministration', jsonObj);
    }

    if (this.hasMaxDosePerLifetime()) {
      setFhirComplexJson(this.getMaxDosePerLifetime(), 'maxDosePerLifetime', jsonObj);
    }

    return jsonObj;
  }
}
/**
 * DosageDoseAndRateComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Amount of medication administered, to be administered or typical amount to be administered
 * - **Definition:** Depending on the resource,this is the amount of medication administered, to  be administered or typical amount to be administered.
 *
 * @category Data Models: ComplexType
 * @see [FHIR Dosage](http://hl7.org/fhir/StructureDefinition/Dosage)
 */
export class DosageDoseAndRateComponent extends DataType implements IDataType {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided `DosageDoseAndRateComponent` JSON to instantiate the DosageDoseAndRateComponent data model.
   *
   * @param sourceJson - JSON representing FHIR `DosageDoseAndRateComponent`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to DosageDoseAndRateComponent
   * @returns DosageDoseAndRateComponent data model or undefined for `DosageDoseAndRateComponent`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): DosageDoseAndRateComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'DosageDoseAndRateComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new DosageDoseAndRateComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';

    const classMetadata: DecoratorMetadataObject | null = DosageDoseAndRateComponent[Symbol.metadata];
    const errorMessage = `DecoratorMetadataObject does not exist for DosageDoseAndRateComponent`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    fieldName = 'type';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = CodeableConcept.parse(classJsonObj[fieldName]!, sourceField);
      instance.setType(datatype);
    }

    fieldName = 'dose[x]';
    sourceField = `${optSourceValue}.${fieldName}`;
    const dose: IDataType | undefined = fhirParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setDose(dose);

    fieldName = 'rate[x]';
    sourceField = `${optSourceValue}.${fieldName}`;
    const rate: IDataType | undefined = fhirParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setRate(rate);

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Dosage.doseAndRate.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The kind of dose or rate specified
   * - **Definition:** The kind of dose or rate specified, for example, ordered or calculated.
   * - **Requirements:** If the type is not populated, assume to be "ordered".
   * - **FHIR Type:** `CodeableConcept`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private type_?: CodeableConcept | undefined;

  /**
   * Dosage.doseAndRate.dose[x] Element
   *
   * @decorator `@ChoiceDataTypesMeta('Dosage.doseAndRate.dose[x]', ['Range','Quantity',]`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Amount of medication per dose
   * - **Definition:** Amount of medication per dose.
   * - **Comment:** Note that this specifies the quantity of the specified medication, not the quantity for each active ingredient(s). Each ingredient amount can be communicated in the Medication resource. For example, if one wants to communicate that a tablet was 375 mg, where the dose was one tablet, you can use the Medication resource to document that the tablet was comprised of 375 mg of drug XYZ. Alternatively if the dose was 375 mg, then you may only need to use the Medication resource to indicate this was a tablet. If the example were an IV such as dopamine and you wanted to communicate that 400mg of dopamine was mixed in 500 ml of some IV solution, then this would all be communicated in the Medication resource. If the administration is not intended to be instantaneous (rate is present or timing has a duration), this can be specified to convey the total amount to be administered over the period of time as indicated by the schedule e.g. 500 ml in dose, with timing used to convey that this should be done over 4 hours.
   * - **Requirements:** The amount of therapeutic or other substance given at one administration event.
   * - **FHIR Types:**
   *     'Range',
   *     'Quantity',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('Dosage.doseAndRate.dose[x]',[
    'Range',
    'Quantity',
  ])
  private dose?: IDataType | undefined;

  /**
   * Dosage.doseAndRate.rate[x] Element
   *
   * @decorator `@ChoiceDataTypesMeta('Dosage.doseAndRate.rate[x]', ['Ratio','Range','Quantity',]`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Amount of medication per unit of time
   * - **Definition:** Amount of medication per unit of time.
   * - **Comment:** It is possible to supply both a rate and a doseQuantity to provide full details about how the medication is to be administered and supplied. If the rate is intended to change over time, depending on local rules/regulations, each change should be captured as a new version of the MedicationRequest with an updated rate, or captured with a new MedicationRequest with the new rate. It is possible to specify a rate over time (for example, 100 ml/hour) using either the rateRatio and rateQuantity.  The rateQuantity approach requires systems to have the capability to parse UCUM grammar where ml/hour is included rather than a specific ratio where the time is specified as the denominator.  Where a rate such as 500ml over 2 hours is specified, the use of rateRatio may be more semantically correct than specifying using a rateQuantity of 250 mg/hour.
   * - **Requirements:** Identifies the speed with which the medication was or will be introduced into the patient. Typically the rate for an infusion e.g. 100 ml per 1 hour or 100 ml/hr.  May also be expressed as a rate per unit of time e.g. 500 ml per 2 hours.   Other examples: 200 mcg/min or 200 mcg/1 minute; 1 liter/8 hours.  Sometimes, a rate can imply duration when expressed as total volume / duration (e.g.  500mL/2 hours implies a duration of 2 hours).  However, when rate doesn\'t imply duration (e.g. 250mL/hour), then the timing.repeat.duration is needed to convey the infuse over time period.
   * - **FHIR Types:**
   *     'Ratio',
   *     'Range',
   *     'Quantity',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('Dosage.doseAndRate.rate[x]',[
    'Ratio',
    'Range',
    'Quantity',
  ])
  private rate?: IDataType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `type_` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getType(): CodeableConcept {
    return this.type_ ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Type object value to the `type_` property.
   *
   * @param value - the `type_` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setType(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = `Invalid Dosage.doseAndRate.type; Provided element is not an instance of CodeableConcept.`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.type_ = value;
    } else {
      this.type_ = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasType(): boolean {
    return isDefined<CodeableConcept>(this.type_) && !this.type_.isEmpty();
  }

  /**
   * @returns the `dose` property value as a DataType object if defined; else undefined
   */
  public getDose(): IDataType | undefined {
    return this.dose;
  }

  /**
   * Assigns the provided DataType object value to the `dose` property.
   *
   * @decorator `@ChoiceDataTypes('Dosage.doseAndRate.dose[x]')`
   *
   * @param value - the `dose` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  @ChoiceDataTypes('Dosage.doseAndRate.dose[x]')
  public setDose(value: IDataType | undefined): this {
    if (isDefined<IDataType>(value)) {
      // assertFhirType<IDataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.dose = value;
    } else {
      this.dose = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `dose` property exists and has a value; `false` otherwise
   */
  public hasDose(): boolean {
    return isDefined<IDataType>(this.dose) && !this.dose.isEmpty();
  }

  // *** NOTE ***
  // Following choice datatype-specific "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the `dose` property value as a Range object if defined; else undefined
   */
  public getDoseRange(): Range | undefined {
    if (!isDefined<IDataType | undefined>(this.dose)) {
      return undefined;
    }
    if (!(this.dose instanceof Range)) {
      throw new InvalidTypeError(
        `DataType mismatch for Dosage.doseAndRate.dose[x]: Expected Range but encountered ${this.dose.fhirType()}`,
      );
    }
    return this.dose;
  }

  /**
   * @returns `true` if the `dose` property exists as a Range and has a value; `false` otherwise
   */
  public hasDoseRange(): boolean {
    return this.hasDose() && this.dose instanceof Range;
  }

  /**
   * @returns the `dose` property value as a Quantity object if defined; else undefined
   */
  public getDoseQuantity(): Quantity | undefined {
    if (!isDefined<IDataType | undefined>(this.dose)) {
      return undefined;
    }
    if (!(this.dose instanceof Quantity)) {
      throw new InvalidTypeError(
        `DataType mismatch for Dosage.doseAndRate.dose[x]: Expected Quantity but encountered ${this.dose.fhirType()}`,
      );
    }
    return this.dose;
  }

  /**
   * @returns `true` if the `dose` property exists as a Quantity and has a value; `false` otherwise
   */
  public hasDoseQuantity(): boolean {
    return this.hasDose() && this.dose instanceof Quantity;
  }

  // End of choice datatype-specific "get"/"has" methods

  /**
   * @returns the `rate` property value as a DataType object if defined; else undefined
   */
  public getRate(): IDataType | undefined {
    return this.rate;
  }

  /**
   * Assigns the provided DataType object value to the `rate` property.
   *
   * @decorator `@ChoiceDataTypes('Dosage.doseAndRate.rate[x]')`
   *
   * @param value - the `rate` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  @ChoiceDataTypes('Dosage.doseAndRate.rate[x]')
  public setRate(value: IDataType | undefined): this {
    if (isDefined<IDataType>(value)) {
      // assertFhirType<IDataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.rate = value;
    } else {
      this.rate = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `rate` property exists and has a value; `false` otherwise
   */
  public hasRate(): boolean {
    return isDefined<IDataType>(this.rate) && !this.rate.isEmpty();
  }

  // *** NOTE ***
  // Following choice datatype-specific "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the `rate` property value as a Ratio object if defined; else undefined
   */
  public getRateRatio(): Ratio | undefined {
    if (!isDefined<IDataType | undefined>(this.rate)) {
      return undefined;
    }
    if (!(this.rate instanceof Ratio)) {
      throw new InvalidTypeError(
        `DataType mismatch for Dosage.doseAndRate.rate[x]: Expected Ratio but encountered ${this.rate.fhirType()}`,
      );
    }
    return this.rate;
  }

  /**
   * @returns `true` if the `rate` property exists as a Ratio and has a value; `false` otherwise
   */
  public hasRateRatio(): boolean {
    return this.hasRate() && this.rate instanceof Ratio;
  }

  /**
   * @returns the `rate` property value as a Range object if defined; else undefined
   */
  public getRateRange(): Range | undefined {
    if (!isDefined<IDataType | undefined>(this.rate)) {
      return undefined;
    }
    if (!(this.rate instanceof Range)) {
      throw new InvalidTypeError(
        `DataType mismatch for Dosage.doseAndRate.rate[x]: Expected Range but encountered ${this.rate.fhirType()}`,
      );
    }
    return this.rate;
  }

  /**
   * @returns `true` if the `rate` property exists as a Range and has a value; `false` otherwise
   */
  public hasRateRange(): boolean {
    return this.hasRate() && this.rate instanceof Range;
  }

  /**
   * @returns the `rate` property value as a Quantity object if defined; else undefined
   */
  public getRateQuantity(): Quantity | undefined {
    if (!isDefined<IDataType | undefined>(this.rate)) {
      return undefined;
    }
    if (!(this.rate instanceof Quantity)) {
      throw new InvalidTypeError(
        `DataType mismatch for Dosage.doseAndRate.rate[x]: Expected Quantity but encountered ${this.rate.fhirType()}`,
      );
    }
    return this.rate;
  }

  /**
   * @returns `true` if the `rate` property exists as a Quantity and has a value; `false` otherwise
   */
  public hasRateQuantity(): boolean {
    return this.hasRate() && this.rate instanceof Quantity;
  }

  // End of choice datatype-specific "get"/"has" methods

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Dosage.doseAndRate';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.type_,
      this.dose,
      this.rate,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): DosageDoseAndRateComponent {
    const dest = new DosageDoseAndRateComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: DosageDoseAndRateComponent): void {
    super.copyValues(dest);
    dest.type_ = this.type_?.copy();
    dest.dose = this.dose?.copy() as IDataType;
    dest.rate = this.rate?.copy() as IDataType;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasType()) {
      setFhirComplexJson(this.getType(), 'type', jsonObj);
    }

    if (this.hasDose()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getDose()!, 'dose', jsonObj);
    }

    if (this.hasRate()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getRate()!, 'rate', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * Duration Class
 *
 * @remarks
 * Duration Type: A length of time.
 *
 * **FHIR Specification**
 * - **Short:** A length of time
 * - **Definition:** A length of time.
 * - **Comment:** The context of use may frequently define what kind of quantity this is and therefore what kind of units can be used. The context of use may also restrict the values for the comparator.
 * - **FHIR Version:** 5.0.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR Duration](http://hl7.org/fhir/StructureDefinition/Duration)
 */
export class Duration extends DataType implements IDataType {
  constructor() {
    super();

    this.quantityComparatorEnum = new QuantityComparatorEnum();
  }

  /**
   * Parse the provided `Duration` JSON to instantiate the Duration data model.
   *
   * @param sourceJson - JSON representing FHIR `Duration`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to Duration
   * @returns Duration data model or undefined for `Duration`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Duration | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Duration';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new Duration();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'value';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setValueElement(datatype);
    }

    fieldName = 'comparator';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setComparatorElement(datatype);
    }

    fieldName = 'unit';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setUnitElement(datatype);
    }

    fieldName = 'system';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = fhirParser.parseUriType(dtJson, dtSiblingJson);
      instance.setSystemElement(datatype);
    }

    fieldName = 'code';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setCodeElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Duration.value Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Numerical value (with implicit precision)
   * - **Definition:** The value of the measured amount. The value includes an implicit precision in the presentation of the value.
   * - **Comment:** The implicit precision in the value should always be honored. Monetary values have their own rules for handling precision (refer to standard accounting text books).
   * - **Requirements:** Precision is handled implicitly in almost all cases of measurement.
   * - **FHIR Type:** `decimal`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private value?: DecimalType | undefined;

  /**
   * FHIR CodeSystem: QuantityComparator
   *
   * @see {@link QuantityComparatorEnum }
   */
  private readonly quantityComparatorEnum: QuantityComparatorEnum;

  /**
   * Duration.comparator Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** < | <= | >= | > | ad - how to understand the value
   * - **Definition:** How the value should be understood and represented - whether the actual value is greater or less than the stated value due to measurement issues; e.g. if the comparator is "<" , then the real value is < stated value.
   * - **Requirements:** Need a framework for handling measures where the value is <5ug/L or >400mg/L due to the limitations of measuring methodology.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** true
   * - **isModifierReason:** This is labeled as &quot;Is Modifier&quot; because the comparator modifies the interpretation of the value significantly. If there is no comparator, then there is no modification of the value
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  private comparator?: EnumCodeType | undefined;

  /**
   * Duration.unit Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Unit representation
   * - **Definition:** A human-readable form of the unit.
   * - **Requirements:** There are many representations for units of measure and in many contexts, particular representations are fixed and required. I.e. mcg for micrograms.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private unit?: StringType | undefined;

  /**
   * Duration.system Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** System that defines coded unit form
   * - **Definition:** The identification of the system that provides the coded form of the unit.
   * - **Requirements:** Need to know the system that defines the coded form of the unit.
   * - **FHIR Type:** `uri`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private system?: UriType | undefined;

  /**
   * Duration.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Coded form of the unit
   * - **Definition:** A computer processable form of the unit in some unit representation system.
   * - **Comment:** The preferred system is UCUM, but SNOMED CT can also be used (for customary units) or ISO 4217 for currency.  The context of use may additionally require a code from a particular system.
   * - **Requirements:** Need a computable form of the unit that is fixed across all forms. UCUM provides this for quantities, but SNOMED CT provides many units of interest.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code?: CodeType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `value` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getValueElement(): DecimalType {
    return this.value ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `value` property.
   *
   * @param element - the `value` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValueElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = `Invalid Duration.value; Provided element is not an instance of DecimalType.`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.value = element;
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `value` property exists and has a value; `false` otherwise
   */
  public hasValueElement(): boolean {
    return isDefined<DecimalType>(this.value) && !this.value.isEmpty();
  }

  /**
   * @returns the `value` property value as a fhirDecimal if defined; else undefined
   */
  public getValue(): fhirDecimal | undefined {
    return this.value?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `value` property.
   *
   * @param value - the `value` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValue(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = `Invalid Duration.value (${String(value)})`;
      this.value = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `value` property exists and has a value; `false` otherwise
   */
  public hasValue(): boolean {
    return this.hasValueElement();
  }

  /**
   * @returns the `comparator` property value as a EnumCodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public getComparatorEnumType(): EnumCodeType | undefined {
    return this.comparator;
  }

  /**
   * Assigns the provided EnumCodeType value to the `comparator` property.
   *
   * @param enumType - the `comparator` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code values
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public setComparatorEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid Duration.comparator';
      assertEnumCodeType<QuantityComparatorEnum>(enumType, QuantityComparatorEnum, errMsgPrefix);
      this.comparator = enumType;
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `comparator` property exists and has a value; `false` otherwise
   */
  public hasComparatorEnumType(): boolean {
    return isDefined<EnumCodeType>(this.comparator) && !this.comparator.isEmpty() && this.comparator.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the `comparator` property value as a CodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public getComparatorElement(): CodeType | undefined {
    if (this.comparator === undefined) {
      return undefined;
    }
    return this.comparator as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the `comparator` property.
   *
   * @param element - the `comparator` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public setComparatorElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid Duration.comparator; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.comparator = new EnumCodeType(element, this.quantityComparatorEnum);
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `comparator` property exists and has a value; `false` otherwise
   */
  public hasComparatorElement(): boolean {
    return this.hasComparatorEnumType();
  }

  /**
   * @returns the `comparator` property value as a fhirCode if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public getComparator(): fhirCode | undefined {
    if (this.comparator === undefined) {
      return undefined;
    }
    return this.comparator.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the `comparator` property.
   *
   * @param value - the `comparator` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public setComparator(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid Duration.comparator; Provided value is not an instance of fhirCode.`;
      this.comparator = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.quantityComparatorEnum);
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `comparator` property exists and has a value; `false` otherwise
   */
  public hasComparator(): boolean {
    return this.hasComparatorEnumType();
  }

  /**
   * @returns the `unit` property value as a StringType object if defined; else an empty StringType object
   */
  public getUnitElement(): StringType {
    return this.unit ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `unit` property.
   *
   * @param element - the `unit` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUnitElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid Duration.unit; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.unit = element;
    } else {
      this.unit = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `unit` property exists and has a value; `false` otherwise
   */
  public hasUnitElement(): boolean {
    return isDefined<StringType>(this.unit) && !this.unit.isEmpty();
  }

  /**
   * @returns the `unit` property value as a fhirString if defined; else undefined
   */
  public getUnit(): fhirString | undefined {
    return this.unit?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `unit` property.
   *
   * @param value - the `unit` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUnit(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid Duration.unit (${String(value)})`;
      this.unit = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.unit = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `unit` property exists and has a value; `false` otherwise
   */
  public hasUnit(): boolean {
    return this.hasUnitElement();
  }

  /**
   * @returns the `system` property value as a UriType object if defined; else an empty UriType object
   */
  public getSystemElement(): UriType {
    return this.system ?? new UriType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `system` property.
   *
   * @param element - the `system` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSystemElement(element: UriType | undefined): this {
    if (isDefined<UriType>(element)) {
      const optErrMsg = `Invalid Duration.system; Provided element is not an instance of UriType.`;
      assertFhirType<UriType>(element, UriType, optErrMsg);
      this.system = element;
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `system` property exists and has a value; `false` otherwise
   */
  public hasSystemElement(): boolean {
    return isDefined<UriType>(this.system) && !this.system.isEmpty();
  }

  /**
   * @returns the `system` property value as a fhirUri if defined; else undefined
   */
  public getSystem(): fhirUri | undefined {
    return this.system?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `system` property.
   *
   * @param value - the `system` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSystem(value: fhirUri | undefined): this {
    if (isDefined<fhirUri>(value)) {
      const optErrMsg = `Invalid Duration.system (${String(value)})`;
      this.system = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `system` property exists and has a value; `false` otherwise
   */
  public hasSystem(): boolean {
    return this.hasSystemElement();
  }

  /**
   * @returns the `code` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getCodeElement(): CodeType {
    return this.code ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `code` property.
   *
   * @param element - the `code` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCodeElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid Duration.code; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.code = element;
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `code` property exists and has a value; `false` otherwise
   */
  public hasCodeElement(): boolean {
    return isDefined<CodeType>(this.code) && !this.code.isEmpty();
  }

  /**
   * @returns the `code` property value as a fhirCode if defined; else undefined
   */
  public getCode(): fhirCode | undefined {
    return this.code?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `code` property.
   *
   * @param value - the `code` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCode(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid Duration.code (${String(value)})`;
      this.code = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `code` property exists and has a value; `false` otherwise
   */
  public hasCode(): boolean {
    return this.hasCodeElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Duration';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.value,
      this.comparator,
      this.unit,
      this.system,
      this.code,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Duration {
    const dest = new Duration();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Duration): void {
    super.copyValues(dest);
    dest.value = this.value?.copy();
    dest.comparator = this.comparator?.copy();
    dest.unit = this.unit?.copy();
    dest.system = this.system?.copy();
    dest.code = this.code?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasValueElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getValueElement(), 'value', jsonObj);
    }

    if (this.hasComparatorElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getComparatorElement()!, 'comparator', jsonObj);
    }

    if (this.hasUnitElement()) {
      setFhirPrimitiveJson<fhirString>(this.getUnitElement(), 'unit', jsonObj);
    }

    if (this.hasSystemElement()) {
      setFhirPrimitiveJson<fhirUri>(this.getSystemElement(), 'system', jsonObj);
    }

    if (this.hasCodeElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getCodeElement(), 'code', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * ElementDefinition Class
 *
 * @remarks
 * ElementDefinition Type: Captures constraints on each element within the resource, profile, or extension.
 *
 * **FHIR Specification**
 * - **Short:** Definition of an element in a resource or extension
 * - **Definition:** Captures constraints on each element within the resource, profile, or extension.
 * - **FHIR Version:** 5.0.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR ElementDefinition](http://hl7.org/fhir/StructureDefinition/ElementDefinition)
 */
export class ElementDefinition extends BackboneType implements IBackboneType {
  constructor(path: StringType | fhirString | null = null) {
    super();

    this.propertyRepresentationEnum = new PropertyRepresentationEnum();

    this.path = null;
    if (isDefined<StringType | fhirString>(path)) {
      if (path instanceof PrimitiveType) {
        this.setPathElement(path);
      } else {
        this.setPath(path);
      }
    }
  }

  /**
   * Parse the provided `ElementDefinition` JSON to instantiate the ElementDefinition data model.
   *
   * @param sourceJson - JSON representing FHIR `ElementDefinition`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to ElementDefinition
   * @returns ElementDefinition data model or undefined for `ElementDefinition`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): ElementDefinition | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'ElementDefinition';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new ElementDefinition();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneTypeJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const classMetadata: DecoratorMetadataObject | null = ElementDefinition[Symbol.metadata];
    const errorMessage = `DecoratorMetadataObject does not exist for ElementDefinition`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    const missingReqdProperties: string[] = [];

    fieldName = 'path';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setPathElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'representation';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: CodeType | undefined = fhirParser.parseCodeType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addRepresentationElement(datatype);
        }
      });
    }

    fieldName = 'sliceName';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setSliceNameElement(datatype);
    }

    fieldName = 'sliceIsConstraining';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'boolean';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: BooleanType | undefined = fhirParser.parseBooleanType(dtJson, dtSiblingJson);
      instance.setSliceIsConstrainingElement(datatype);
    }

    fieldName = 'label';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setLabelElement(datatype);
    }

    fieldName = 'code';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Coding | undefined = Coding.parse(dataElementJson, `${sourceField}[${String(idx)}]`);
        if (datatype !== undefined) {
          instance.addCode(datatype);
        }
      });
    }

    fieldName = 'slicing';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: ElementDefinitionSlicingComponent | undefined = ElementDefinitionSlicingComponent.parse(classJsonObj[fieldName]!, sourceField);
      instance.setSlicing(datatype);
    }

    fieldName = 'short';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setShortElement(datatype);
    }

    fieldName = 'definition';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: MarkdownType | undefined = fhirParser.parseMarkdownType(dtJson, dtSiblingJson);
      instance.setDefinitionElement(datatype);
    }

    fieldName = 'comment';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: MarkdownType | undefined = fhirParser.parseMarkdownType(dtJson, dtSiblingJson);
      instance.setCommentElement(datatype);
    }

    fieldName = 'requirements';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: MarkdownType | undefined = fhirParser.parseMarkdownType(dtJson, dtSiblingJson);
      instance.setRequirementsElement(datatype);
    }

    fieldName = 'alias';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: StringType | undefined = fhirParser.parseStringType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addAliasElement(datatype);
        }
      });
    }

    fieldName = 'min';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UnsignedIntType | undefined = fhirParser.parseUnsignedIntType(dtJson, dtSiblingJson);
      instance.setMinElement(datatype);
    }

    fieldName = 'max';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setMaxElement(datatype);
    }

    fieldName = 'base';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: ElementDefinitionBaseComponent | undefined = ElementDefinitionBaseComponent.parse(classJsonObj[fieldName]!, sourceField);
      instance.setBase(datatype);
    }

    fieldName = 'contentReference';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = fhirParser.parseUriType(dtJson, dtSiblingJson);
      instance.setContentReferenceElement(datatype);
    }

    fieldName = 'type';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: ElementDefinitionTypeComponent | undefined = ElementDefinitionTypeComponent.parse(dataElementJson, `${sourceField}[${String(idx)}]`);
        if (datatype !== undefined) {
          instance.addType(datatype);
        }
      });
    }

    fieldName = 'defaultValue[x]';
    sourceField = `${optSourceValue}.${fieldName}`;
    const defaultValue: IDataType | undefined = fhirParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setDefaultValue(defaultValue);

    fieldName = 'meaningWhenMissing';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: MarkdownType | undefined = fhirParser.parseMarkdownType(dtJson, dtSiblingJson);
      instance.setMeaningWhenMissingElement(datatype);
    }

    fieldName = 'orderMeaning';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setOrderMeaningElement(datatype);
    }

    fieldName = 'fixed[x]';
    sourceField = `${optSourceValue}.${fieldName}`;
    const fixed: IDataType | undefined = fhirParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setFixed(fixed);

    fieldName = 'pattern[x]';
    sourceField = `${optSourceValue}.${fieldName}`;
    const pattern: IDataType | undefined = fhirParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setPattern(pattern);

    fieldName = 'example';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: ElementDefinitionExampleComponent | undefined = ElementDefinitionExampleComponent.parse(dataElementJson, `${sourceField}[${String(idx)}]`);
        if (datatype !== undefined) {
          instance.addExample(datatype);
        }
      });
    }

    fieldName = 'minValue[x]';
    sourceField = `${optSourceValue}.${fieldName}`;
    const minValue: IDataType | undefined = fhirParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setMinValue(minValue);

    fieldName = 'maxValue[x]';
    sourceField = `${optSourceValue}.${fieldName}`;
    const maxValue: IDataType | undefined = fhirParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setMaxValue(maxValue);

    fieldName = 'maxLength';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: IntegerType | undefined = fhirParser.parseIntegerType(dtJson, dtSiblingJson);
      instance.setMaxLengthElement(datatype);
    }

    fieldName = 'condition';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: IdType | undefined = fhirParser.parseIdType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addConditionElement(datatype);
        }
      });
    }

    fieldName = 'constraint';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: ElementDefinitionConstraintComponent | undefined = ElementDefinitionConstraintComponent.parse(dataElementJson, `${sourceField}[${String(idx)}]`);
        if (datatype !== undefined) {
          instance.addConstraint(datatype);
        }
      });
    }

    fieldName = 'mustHaveValue';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'boolean';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: BooleanType | undefined = fhirParser.parseBooleanType(dtJson, dtSiblingJson);
      instance.setMustHaveValueElement(datatype);
    }

    fieldName = 'valueAlternatives';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: CanonicalType | undefined = fhirParser.parseCanonicalType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addValueAlternativesElement(datatype);
        }
      });
    }

    fieldName = 'mustSupport';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'boolean';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: BooleanType | undefined = fhirParser.parseBooleanType(dtJson, dtSiblingJson);
      instance.setMustSupportElement(datatype);
    }

    fieldName = 'isModifier';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'boolean';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: BooleanType | undefined = fhirParser.parseBooleanType(dtJson, dtSiblingJson);
      instance.setIsModifierElement(datatype);
    }

    fieldName = 'isModifierReason';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setIsModifierReasonElement(datatype);
    }

    fieldName = 'isSummary';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'boolean';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: BooleanType | undefined = fhirParser.parseBooleanType(dtJson, dtSiblingJson);
      instance.setIsSummaryElement(datatype);
    }

    fieldName = 'binding';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: ElementDefinitionBindingComponent | undefined = ElementDefinitionBindingComponent.parse(classJsonObj[fieldName]!, sourceField);
      instance.setBinding(datatype);
    }

    fieldName = 'mapping';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: ElementDefinitionMappingComponent | undefined = ElementDefinitionMappingComponent.parse(dataElementJson, `${sourceField}[${String(idx)}]`);
        if (datatype !== undefined) {
          instance.addMapping(datatype);
        }
      });
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_REQD_IN_JSON} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * ElementDefinition.path Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Path of the element in the hierarchy of elements
   * - **Definition:** The path identifies the element and is expressed as a "."-separated list of ancestor elements, beginning with the name of the resource or extension.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private path: StringType | null;

  /**
   * FHIR CodeSystem: PropertyRepresentation
   *
   * @see {@link PropertyRepresentationEnum }
   */
  private readonly propertyRepresentationEnum: PropertyRepresentationEnum;

  /**
   * ElementDefinition.representation Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** xmlAttr | xmlText | typeAttr | cdaText | xhtml
   * - **Definition:** Codes that define how this element is represented in instances, when the deviation varies from the normal case. No extensions are allowed on elements with a representation of \'xmlAttr\', no matter what FHIR serialization format is used.
   * - **Comment:** In resources, this is rarely used except for special cases where the representation deviates from the normal, and can only be done in the base standard (and profiles must reproduce what the base standard does). This element is used quite commonly in Logical models when the logical models represent a specific serialization format (e.g. CDA, v2 etc.).
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link PropertyRepresentationEnum }
   */
  private representation?: EnumCodeType[] | undefined;

  /**
   * ElementDefinition.sliceName Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Name for this particular element (in a set of slices)
   * - **Definition:** The name of this element definition slice, when slicing is working. The name must be a token with no dots or spaces. This is a unique name referring to a specific set of constraints applied to this element, used to provide a name to different slices of the same element.
   * - **Comment:** The name SHALL be unique within the structure within the context of the constrained resource element.  (Though to avoid confusion, uniqueness across all elements is recommended.).
   * - **Requirements:** May also be used for code generation purposes.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private sliceName?: StringType | undefined;

  /**
   * ElementDefinition.sliceIsConstraining Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** If this slice definition constrains an inherited slice definition (or not)
   * - **Definition:** If true, indicates that this slice definition is constraining a slice definition with the same name in an inherited profile. If false, the slice is not overriding any slice in an inherited profile. If missing, the slice might or might not be overriding a slice in an inherited profile, depending on the sliceName.
   * - **Comment:** If set to true, an ancestor profile SHALL have a slicing definition with this name.  If set to false, no ancestor profile is permitted to have a slicing definition with this name.
   * - **Requirements:** Allows detection of a situation where an ancestor profile adds or removes slicing with the same name where that might impact the child profile.
   * - **FHIR Type:** `boolean`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private sliceIsConstraining?: BooleanType | undefined;

  /**
   * ElementDefinition.label Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Name for element to display with or prompt for element
   * - **Definition:** A single preferred label which is the text to display beside the element indicating its meaning or to use to prompt for the element in a user display or form.
   * - **Comment:** See also the extension [http://hl7.org/fhir/StructureDefinition/elementdefinition-question](http://hl7.org/fhir/extensions/https://hl7.org/fhir/StructureDefinition-elementdefinition-question.html).
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private label?: StringType | undefined;

  /**
   * ElementDefinition.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Corresponding codes in terminologies
   * - **Definition:** A code that has the same meaning as the element in a particular terminology.
   * - **Comment:** The concept SHALL be properly aligned with the data element definition and other constraints, as defined in the code system, including relationships, of any code listed here.  Where multiple codes exist in a terminology that could correspond to the data element, the most granular code(s) should be selected, so long as they are not more restrictive than the data element itself. The mappings may be used to provide more or less granular or structured equivalences in the code system.
   * - **Requirements:** Links the meaning of an element to an external terminology, and is very useful for searching and indexing.
   * - **FHIR Type:** `Coding`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code?: Coding[] | undefined;

  /**
   * ElementDefinition.slicing Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** This element is sliced - slices follow
   * - **Definition:** Indicates that the element is sliced into a set of alternative definitions (i.e. in a structure definition, there are multiple different constraints on a single element in the base resource). Slicing can be used in any resource that has cardinality ..* on the base resource, or any resource with a choice of types. The set of slices is any elements that come after this in the element sequence that have the same path, until a shorter path occurs (the shorter path terminates the set).
   * - **Comment:** The first element in the sequence, the one that carries the slicing, is the definition that applies to all the slices. This is based on the unconstrained element, but can apply any constraints as appropriate. This may include the common constraints on the children of the element.
   * - **FHIR Type:** `Element`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private slicing?: ElementDefinitionSlicingComponent | undefined;

  /**
   * ElementDefinition.short Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Concise definition for space-constrained presentation
   * - **Definition:** A concise description of what this element means (e.g. for use in autogenerated summaries).
   * - **Comment:** It is easy for a different short definition to change the meaning of an element and this can have nasty downstream consequences. Please be careful when providing short definitions in a profile.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private short?: StringType | undefined;

  /**
   * ElementDefinition.definition Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Full formal definition as narrative text
   * - **Definition:** Provides a complete explanation of the meaning of the data element for human readability.  For the case of elements derived from existing elements (e.g. constraints), the definition SHALL be consistent with the base definition, but convey the meaning of the element in the particular context of use of the resource. (Note: The text you are reading is specified in ElementDefinition.definition).
   * - **Comment:** It is easy for a different definition to change the meaning of an element and this can have nasty downstream consequences. Please be careful when providing definitions in a profile.
   * - **Requirements:** To allow a user to state the usage of an element in a particular context.
   * - **FHIR Type:** `markdown`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private definition?: MarkdownType | undefined;

  /**
   * ElementDefinition.comment Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Comments about the use of this element
   * - **Definition:** Explanatory notes and implementation guidance about the data element, including notes about how to use the data properly, exceptions to proper use, etc. (Note: The text you are reading is specified in ElementDefinition.comment).
   * - **Comment:** If it is possible to capture usage rules using constraints, that mechanism should be used in preference to this element.
   * - **FHIR Type:** `markdown`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private comment?: MarkdownType | undefined;

  /**
   * ElementDefinition.requirements Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Why this resource has been created
   * - **Definition:** This element is for traceability of why the element was created and why the constraints exist as they do. This may be used to point to source materials or specifications that drove the structure of this element.
   * - **Comment:** This element does not describe the usage of the element (that\'s done in comments), rather it\'s for traceability of *why* the element is either needed or why the constraints exist as they do.  This may be used to point to source materials or specifications that drove the structure of this data element.
   * - **FHIR Type:** `markdown`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private requirements?: MarkdownType | undefined;

  /**
   * ElementDefinition.alias Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Other names
   * - **Definition:** Identifies additional names by which this element might also be known.
   * - **Requirements:** Allows for better easier recognition of the element by multiple communities, including international communities.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private alias?: StringType[] | undefined;

  /**
   * ElementDefinition.min Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Minimum Cardinality
   * - **Definition:** The minimum number of times this element SHALL appear in the instance.
   * - **FHIR Type:** `unsignedInt`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private min?: UnsignedIntType | undefined;

  /**
   * ElementDefinition.max Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Maximum Cardinality (a number or *)
   * - **Definition:** The maximum number of times this element is permitted to appear in the instance.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private max?: StringType | undefined;

  /**
   * ElementDefinition.base Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Base definition information for tools
   * - **Definition:** Information about the base definition of the element, provided to make it unnecessary for tools to trace the deviation of the element through the derived and related profiles. When the element definition is not the original definition of an element - e.g. either in a constraint on another type, or for elements from a super type in a snap shot - then the information in provided in the element definition may be different to the base definition. On the original definition of the element, it will be same.
   * - **Comment:** The base information does not carry any information that could not be determined from the path and related profiles, but making this determination requires both that the related profiles are available, and that the algorithm to determine them be available. For tooling simplicity, the base information must always be populated in element definitions in snap shots, even if it is the same.
   * - **FHIR Type:** `Element`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private base?: ElementDefinitionBaseComponent | undefined;

  /**
   * ElementDefinition.contentReference Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Reference to definition of content for the element
   * - **Definition:** Identifies an element defined elsewhere in the definition whose content rules should be applied to the current element. ContentReferences bring across all the rules that are in the ElementDefinition for the element, including definitions, cardinality constraints, bindings, invariants etc.
   * - **Comment:** ContentReferences can only be defined in specializations, not constrained types, and they cannot be changed and always reference the non-constrained definition.
   * - **FHIR Type:** `uri`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private contentReference?: UriType | undefined;

  /**
   * ElementDefinition.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Data type and Profile for this element
   * - **Definition:** The data type or resource that the value of this element is permitted to be.
   * - **Comment:** The Type of the element can be left blank in a differential constraint, in which case the type is inherited from the resource. Abstract types are not permitted to appear as a type when multiple types are listed.  (I.e. Abstract types cannot be part of a choice).
   * - **FHIR Type:** `Element`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private type_?: ElementDefinitionTypeComponent[] | undefined;

  /**
   * ElementDefinition.defaultValue[x] Element
   *
   * @decorator `@ChoiceDataTypesMeta('ElementDefinition.defaultValue[x]', ['base64Binary','boolean','canonical','code','date','dateTime','decimal','id','instant','integer','integer64','markdown','oid','positiveInt','string','time','unsignedInt','uri','url','uuid','Address','Age','Annotation','Attachment','CodeableConcept','CodeableReference','Coding','ContactPoint','Count','Distance','Duration','HumanName','Identifier','Money','Period','Quantity','Range','Ratio','RatioRange','Reference','SampledData','Signature','Timing','ContactDetail','DataRequirement','Expression','ParameterDefinition','RelatedArtifact','TriggerDefinition','UsageContext','Availability','ExtendedContactDetail','Dosage','Meta',]`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Specified value if missing from instance
   * - **Definition:** The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
   * - **Comment:** Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.  No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   * - **FHIR Types:**
   *     'base64Binary',
   *     'boolean',
   *     'canonical',
   *     'code',
   *     'date',
   *     'dateTime',
   *     'decimal',
   *     'id',
   *     'instant',
   *     'integer',
   *     'integer64',
   *     'markdown',
   *     'oid',
   *     'positiveInt',
   *     'string',
   *     'time',
   *     'unsignedInt',
   *     'uri',
   *     'url',
   *     'uuid',
   *     'Address',
   *     'Age',
   *     'Annotation',
   *     'Attachment',
   *     'CodeableConcept',
   *     'CodeableReference',
   *     'Coding',
   *     'ContactPoint',
   *     'Count',
   *     'Distance',
   *     'Duration',
   *     'HumanName',
   *     'Identifier',
   *     'Money',
   *     'Period',
   *     'Quantity',
   *     'Range',
   *     'Ratio',
   *     'RatioRange',
   *     'Reference',
   *     'SampledData',
   *     'Signature',
   *     'Timing',
   *     'ContactDetail',
   *     'DataRequirement',
   *     'Expression',
   *     'ParameterDefinition',
   *     'RelatedArtifact',
   *     'TriggerDefinition',
   *     'UsageContext',
   *     'Availability',
   *     'ExtendedContactDetail',
   *     'Dosage',
   *     'Meta',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('ElementDefinition.defaultValue[x]',[
    'base64Binary',
    'boolean',
    'canonical',
    'code',
    'date',
    'dateTime',
    'decimal',
    'id',
    'instant',
    'integer',
    'integer64',
    'markdown',
    'oid',
    'positiveInt',
    'string',
    'time',
    'unsignedInt',
    'uri',
    'url',
    'uuid',
    'Address',
    'Age',
    'Annotation',
    'Attachment',
    'CodeableConcept',
    'CodeableReference',
    'Coding',
    'ContactPoint',
    'Count',
    'Distance',
    'Duration',
    'HumanName',
    'Identifier',
    'Money',
    'Period',
    'Quantity',
    'Range',
    'Ratio',
    'RatioRange',
    'Reference',
    'SampledData',
    'Signature',
    'Timing',
    'ContactDetail',
    'DataRequirement',
    'Expression',
    'ParameterDefinition',
    'RelatedArtifact',
    'TriggerDefinition',
    'UsageContext',
    'Availability',
    'ExtendedContactDetail',
    'Dosage',
    'Meta',
  ])
  private defaultValue?: IDataType | undefined;

  /**
   * ElementDefinition.meaningWhenMissing Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Implicit meaning when this element is missing
   * - **Definition:** The Implicit meaning that is to be understood when this element is missing (e.g. \'when this element is missing, the period is ongoing\').
   * - **Comment:** Implicit meanings for missing values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. An implicit meaning for a missing value can never be changed, and specifying one has the consequence that constraining its use in profiles eliminates use cases as possibilities, not merely moving them out of scope.
   * - **FHIR Type:** `markdown`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private meaningWhenMissing?: MarkdownType | undefined;

  /**
   * ElementDefinition.orderMeaning Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** What the order of the elements means
   * - **Definition:** If present, indicates that the order of the repeating element has meaning and describes what that meaning is.  If absent, it means that the order of the element has no meaning.
   * - **Comment:** This element can only be asserted on repeating elements and can only be introduced when defining resources or data types.  It can be further refined profiled elements but if absent in the base type, a profile cannot assert meaning.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private orderMeaning?: StringType | undefined;

  /**
   * ElementDefinition.fixed[x] Element
   *
   * @decorator `@ChoiceDataTypesMeta('ElementDefinition.fixed[x]', ['base64Binary','boolean','canonical','code','date','dateTime','decimal','id','instant','integer','integer64','markdown','oid','positiveInt','string','time','unsignedInt','uri','url','uuid','Address','Age','Annotation','Attachment','CodeableConcept','CodeableReference','Coding','ContactPoint','Count','Distance','Duration','HumanName','Identifier','Money','Period','Quantity','Range','Ratio','RatioRange','Reference','SampledData','Signature','Timing','ContactDetail','DataRequirement','Expression','ParameterDefinition','RelatedArtifact','TriggerDefinition','UsageContext','Availability','ExtendedContactDetail','Dosage','Meta',]`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Value must be exactly this
   * - **Definition:** Specifies a value that SHALL be exactly the value  for this element in the instance, if present. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
   * - **Comment:** This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   * - **FHIR Types:**
   *     'base64Binary',
   *     'boolean',
   *     'canonical',
   *     'code',
   *     'date',
   *     'dateTime',
   *     'decimal',
   *     'id',
   *     'instant',
   *     'integer',
   *     'integer64',
   *     'markdown',
   *     'oid',
   *     'positiveInt',
   *     'string',
   *     'time',
   *     'unsignedInt',
   *     'uri',
   *     'url',
   *     'uuid',
   *     'Address',
   *     'Age',
   *     'Annotation',
   *     'Attachment',
   *     'CodeableConcept',
   *     'CodeableReference',
   *     'Coding',
   *     'ContactPoint',
   *     'Count',
   *     'Distance',
   *     'Duration',
   *     'HumanName',
   *     'Identifier',
   *     'Money',
   *     'Period',
   *     'Quantity',
   *     'Range',
   *     'Ratio',
   *     'RatioRange',
   *     'Reference',
   *     'SampledData',
   *     'Signature',
   *     'Timing',
   *     'ContactDetail',
   *     'DataRequirement',
   *     'Expression',
   *     'ParameterDefinition',
   *     'RelatedArtifact',
   *     'TriggerDefinition',
   *     'UsageContext',
   *     'Availability',
   *     'ExtendedContactDetail',
   *     'Dosage',
   *     'Meta',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('ElementDefinition.fixed[x]',[
    'base64Binary',
    'boolean',
    'canonical',
    'code',
    'date',
    'dateTime',
    'decimal',
    'id',
    'instant',
    'integer',
    'integer64',
    'markdown',
    'oid',
    'positiveInt',
    'string',
    'time',
    'unsignedInt',
    'uri',
    'url',
    'uuid',
    'Address',
    'Age',
    'Annotation',
    'Attachment',
    'CodeableConcept',
    'CodeableReference',
    'Coding',
    'ContactPoint',
    'Count',
    'Distance',
    'Duration',
    'HumanName',
    'Identifier',
    'Money',
    'Period',
    'Quantity',
    'Range',
    'Ratio',
    'RatioRange',
    'Reference',
    'SampledData',
    'Signature',
    'Timing',
    'ContactDetail',
    'DataRequirement',
    'Expression',
    'ParameterDefinition',
    'RelatedArtifact',
    'TriggerDefinition',
    'UsageContext',
    'Availability',
    'ExtendedContactDetail',
    'Dosage',
    'Meta',
  ])
  private fixed?: IDataType | undefined;

  /**
   * ElementDefinition.pattern[x] Element
   *
   * @decorator `@ChoiceDataTypesMeta('ElementDefinition.pattern[x]', ['base64Binary','boolean','canonical','code','date','dateTime','decimal','id','instant','integer','integer64','markdown','oid','positiveInt','string','time','unsignedInt','uri','url','uuid','Address','Age','Annotation','Attachment','CodeableConcept','CodeableReference','Coding','ContactPoint','Count','Distance','Duration','HumanName','Identifier','Money','Period','Quantity','Range','Ratio','RatioRange','Reference','SampledData','Signature','Timing','ContactDetail','DataRequirement','Expression','ParameterDefinition','RelatedArtifact','TriggerDefinition','UsageContext','Availability','ExtendedContactDetail','Dosage','Meta',]`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Value must have at least these property values
   * - **Definition:** Specifies a value that each occurrence of the element in the instance SHALL follow - that is, any value in the pattern must be found in the instance, if the element has a value. Other additional values may be found too. This is effectively constraint by example.   When pattern[x] is used to constrain a primitive, it means that the value provided in the pattern[x] must match the instance value exactly. When an element within a pattern[x] is used to constrain an array, it means that each element provided in the pattern[x] must (recursively) match at least one element from the instance array. When pattern[x] is used to constrain a complex object, it means that each property in the pattern must be present in the complex object, and its value must recursively match -- i.e., 1. If primitive: it must match exactly the pattern value 2. If a complex object: it must match (recursively) the pattern value 3. If an array: it must match (recursively) the pattern value If a pattern[x] is declared on a repeating element, the pattern applies to all repetitions.  If the desire is for a pattern to apply to only one element or a subset of elements, slicing must be used. See [Examples of Patterns](https://hl7.org/fhir/elementdefinition-examples.html#pattern-examples) for examples of pattern usage and the effect it will have.
   * - **Comment:** Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   * - **FHIR Types:**
   *     'base64Binary',
   *     'boolean',
   *     'canonical',
   *     'code',
   *     'date',
   *     'dateTime',
   *     'decimal',
   *     'id',
   *     'instant',
   *     'integer',
   *     'integer64',
   *     'markdown',
   *     'oid',
   *     'positiveInt',
   *     'string',
   *     'time',
   *     'unsignedInt',
   *     'uri',
   *     'url',
   *     'uuid',
   *     'Address',
   *     'Age',
   *     'Annotation',
   *     'Attachment',
   *     'CodeableConcept',
   *     'CodeableReference',
   *     'Coding',
   *     'ContactPoint',
   *     'Count',
   *     'Distance',
   *     'Duration',
   *     'HumanName',
   *     'Identifier',
   *     'Money',
   *     'Period',
   *     'Quantity',
   *     'Range',
   *     'Ratio',
   *     'RatioRange',
   *     'Reference',
   *     'SampledData',
   *     'Signature',
   *     'Timing',
   *     'ContactDetail',
   *     'DataRequirement',
   *     'Expression',
   *     'ParameterDefinition',
   *     'RelatedArtifact',
   *     'TriggerDefinition',
   *     'UsageContext',
   *     'Availability',
   *     'ExtendedContactDetail',
   *     'Dosage',
   *     'Meta',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('ElementDefinition.pattern[x]',[
    'base64Binary',
    'boolean',
    'canonical',
    'code',
    'date',
    'dateTime',
    'decimal',
    'id',
    'instant',
    'integer',
    'integer64',
    'markdown',
    'oid',
    'positiveInt',
    'string',
    'time',
    'unsignedInt',
    'uri',
    'url',
    'uuid',
    'Address',
    'Age',
    'Annotation',
    'Attachment',
    'CodeableConcept',
    'CodeableReference',
    'Coding',
    'ContactPoint',
    'Count',
    'Distance',
    'Duration',
    'HumanName',
    'Identifier',
    'Money',
    'Period',
    'Quantity',
    'Range',
    'Ratio',
    'RatioRange',
    'Reference',
    'SampledData',
    'Signature',
    'Timing',
    'ContactDetail',
    'DataRequirement',
    'Expression',
    'ParameterDefinition',
    'RelatedArtifact',
    'TriggerDefinition',
    'UsageContext',
    'Availability',
    'ExtendedContactDetail',
    'Dosage',
    'Meta',
  ])
  private pattern?: IDataType | undefined;

  /**
   * ElementDefinition.example Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Example value (as defined for type)
   * - **Definition:** A sample value for this element demonstrating the type of information that would typically be found in the element.
   * - **Comment:** Examples will most commonly be present for data where it\'s not implicitly obvious from either the data type or value set what the values might be.  (I.e. Example values for dates or quantities would generally be unnecessary.)  If the example value is fully populated, the publication tool can generate an instance automatically.
   * - **FHIR Type:** `Element`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private example?: ElementDefinitionExampleComponent[] | undefined;

  /**
   * ElementDefinition.minValue[x] Element
   *
   * @decorator `@ChoiceDataTypesMeta('ElementDefinition.minValue[x]', ['date','dateTime','instant','time','decimal','integer','integer64','positiveInt','unsignedInt','Quantity',]`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Minimum Allowed Value (for some types)
   * - **Definition:** The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   * - **Comment:** Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a [Duration](https://hl7.org/fhir/datatypes.html#Duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as a canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
   * - **FHIR Types:**
   *     'date',
   *     'dateTime',
   *     'instant',
   *     'time',
   *     'decimal',
   *     'integer',
   *     'integer64',
   *     'positiveInt',
   *     'unsignedInt',
   *     'Quantity',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('ElementDefinition.minValue[x]',[
    'date',
    'dateTime',
    'instant',
    'time',
    'decimal',
    'integer',
    'integer64',
    'positiveInt',
    'unsignedInt',
    'Quantity',
  ])
  private minValue?: IDataType | undefined;

  /**
   * ElementDefinition.maxValue[x] Element
   *
   * @decorator `@ChoiceDataTypesMeta('ElementDefinition.maxValue[x]', ['date','dateTime','instant','time','decimal','integer','integer64','positiveInt','unsignedInt','Quantity',]`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Maximum Allowed Value (for some types)
   * - **Definition:** The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   * - **Comment:** Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a [Duration](https://hl7.org/fhir/datatypes.html#Duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as a canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
   * - **FHIR Types:**
   *     'date',
   *     'dateTime',
   *     'instant',
   *     'time',
   *     'decimal',
   *     'integer',
   *     'integer64',
   *     'positiveInt',
   *     'unsignedInt',
   *     'Quantity',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('ElementDefinition.maxValue[x]',[
    'date',
    'dateTime',
    'instant',
    'time',
    'decimal',
    'integer',
    'integer64',
    'positiveInt',
    'unsignedInt',
    'Quantity',
  ])
  private maxValue?: IDataType | undefined;

  /**
   * ElementDefinition.maxLength Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Max length for string type data
   * - **Definition:** Indicates the maximum length in characters that is permitted to be present in conformant instances and which is expected to be supported by conformant consumers that support the element. ```maxLength``` SHOULD only be used on primitive data types that have a string representation (see [http://hl7.org/fhir/StructureDefinition/structuredefinition-type-characteristics](http://hl7.org/fhir/extensions/https://hl7.org/fhir/StructureDefinition-structuredefinition-type-characteristics.html)).
   * - **Comment:** Receivers are not required to reject instances that exceed the maximum length.  The full length could be stored.  In some cases, data might be truncated, though truncation should be undertaken with care and an understanding of the consequences of doing so. If not specified, there is no conformance expectation for length support.
   * - **FHIR Type:** `integer`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private maxLength?: IntegerType | undefined;

  /**
   * ElementDefinition.condition Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Reference to invariant about presence
   * - **Definition:** A reference to an invariant that may make additional statements about the cardinality or value in the instance.
   * - **FHIR Type:** `id`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private condition?: IdType[] | undefined;

  /**
   * ElementDefinition.constraint Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Condition that must evaluate to true
   * - **Definition:** Formal constraints such as co-occurrence and other constraints that can be computationally evaluated within the context of the instance.
   * - **Comment:** Constraints should be declared on the "context" element - the lowest element in the hierarchy that is common to all nodes referenced by the constraint.
   * - **FHIR Type:** `Element`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private constraint?: ElementDefinitionConstraintComponent[] | undefined;

  /**
   * ElementDefinition.mustHaveValue Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** For primitives, that a value must be present - not replaced by an extension
   * - **Definition:** Specifies for a primitive data type that the value of the data type cannot be replaced by an extension.
   * - **Comment:** Typical extensions that can be provided in place of a the value are [http://hl7.org/fhir/StructureDefinition/data-absent-reason](http://hl7.org/fhir/extensions/https://hl7.org/fhir/StructureDefinition-data-absent-reason.html),  [http://hl7.org/fhir/StructureDefinition/iso21090-nullFlavor](http://hl7.org/fhir/extensions/https://hl7.org/fhir/StructureDefinition-iso21090-nullFlavor.html),  [http://hl7.org/fhir/StructureDefinition/originalText](http://hl7.org/fhir/extensions/https://hl7.org/fhir/StructureDefinition-originalText.html), and [http://hl7.org/fhir/StructureDefinition/cqf-expression](http://hl7.org/fhir/extensions/https://hl7.org/fhir/StructureDefinition-cqf-expression.html). Note that this element has no meaning when a value is provided, and extensions can be provided in addition to a value.
   * - **FHIR Type:** `boolean`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private mustHaveValue?: BooleanType | undefined;

  /**
   * ElementDefinition.valueAlternatives Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Extensions that are allowed to replace a primitive value
   * - **Definition:** Specifies a list of extensions that can appear in place of a primitive value.
   * - **Comment:** if mustHaveValue is true, then this element should not be present, since no extensions are allowed in place of the value. Note that this element has no impact if the value is present.
   * - **FHIR Type:** `canonical`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/StructureDefinition',
   *     ]
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private valueAlternatives?: CanonicalType[] | undefined;

  /**
   * ElementDefinition.mustSupport Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** If the element must be supported (discouraged - see obligations)
   * - **Definition:** If true, implementations that produce or consume resources SHALL provide "support" for the element in some meaningful way. Note that this is being phased out and replaced by obligations (see below).  If false, the element may be ignored and not supported. If false, whether to populate or use the data element in any way is at the discretion of the implementation.
   * - **Comment:** "Something meaningful" is context dependent and impossible to describe in the base FHIR specification. For this reason, the mustSupport flag is never set to true by the FHIR specification itself - it is only set to true in profiles.  A profile on a type can always make mustSupport = true if it is false in the base type but cannot make mustSupport = false if it is true in the base type.   This is done in [Resource Profiles](https://hl7.org/fhir/profiling.html#mustsupport), where the profile labels an element as mustSupport=true. When a profile does this, it SHALL also make clear exactly what kind of "support" is required, as this can mean many things.    Note that an element that has the property IsModifier is not necessarily a "key" element (e.g. one of the important elements to make use of the resource), nor is it automatically mustSupport - however both of these things are more likely to be true for IsModifier elements than for other elements.
   * - **Requirements:** Allows a profile to set expectations for system capabilities beyond merely respecting cardinality constraints.
   * - **FHIR Type:** `boolean`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private mustSupport?: BooleanType | undefined;

  /**
   * ElementDefinition.isModifier Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** If this modifies the meaning of other elements
   * - **Definition:** If true, the value of this element affects the interpretation of the element or resource that contains it, and the value of the element cannot be ignored. Typically, this is used for status, negation and qualification codes. The effect of this is that the element cannot be ignored by systems: they SHALL either recognize the element and process it, and/or a pre-determination has been made that it is not relevant to their particular system. When used on the root element in an extension definition, this indicates whether or not the extension is a modifier extension.
   * - **Comment:** Only the definition of an element can set IsModifier true - either the specification itself or where an extension is originally defined. Once set, it cannot be changed in derived profiles (except in the special case of the defining a new extension). An element/extension that has isModifier=true SHOULD also have a minimum cardinality of 1, so that there is no lack of clarity about what to do if it is missing. If it can be missing, the definition SHALL make the meaning of a missing element clear.
   * - **Requirements:** Allows elements to be introduced into a specification that can\'t safely be ignored by applications that don\'t recognize them.
   * - **FHIR Type:** `boolean`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private isModifier?: BooleanType | undefined;

  /**
   * ElementDefinition.isModifierReason Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Reason that this element is marked as a modifier
   * - **Definition:** Explains how that element affects the interpretation of the resource or element that contains it.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private isModifierReason?: StringType | undefined;

  /**
   * ElementDefinition.isSummary Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Include when _summary = true?
   * - **Definition:** Whether the element should be included if a client requests a search with the parameter _summary=true.
   * - **Comment:** Some resources include a set of simple metadata, and some very large data. This element is used to reduce the quantity of data returned in searches. Note that servers may pre-cache summarized resources for optimal performance. When a request is made with _summary=true, serializers only include elements marked as \'isSummary = true\'. With a few exceptions (listed below), all datatype properties are included in the summary form. In resource and datatype definitions, if an element has a descendant marked as isSummary=true or if it satisfies both of the following conditions, it must be marked as isSummary=true: * is at the root or has a parent that is \'mustSupport\' * has a minimum cardinality of 1 or is a modifier element The following datatype properties are exceptions, and are not marked as isSummary: * Attachment.data * Signature.data, Signature.targetFormat, Signature.sigFormat * Narrative.status, Narrative.div * SampledData.data.
   * - **Requirements:** Allow clients to search through large resources quickly.
   * - **FHIR Type:** `boolean`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private isSummary?: BooleanType | undefined;

  /**
   * ElementDefinition.binding Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** ValueSet details if this is coded
   * - **Definition:** Binds to a value set if this element is coded (code, Coding, CodeableConcept, Quantity), or the data types (string, uri).
   * - **Comment:** For a CodeableConcept, when no codes are allowed - only text, use a binding of strength "required" with a description explaining that no coded values are allowed and what sort of information to put in the "text" element.
   * - **FHIR Type:** `Element`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private binding?: ElementDefinitionBindingComponent | undefined;

  /**
   * ElementDefinition.mapping Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Map element to another set of definitions
   * - **Definition:** Identifies a concept from an external specification that roughly corresponds to this element.
   * - **Comment:** Mappings are not necessarily specific enough for safe translation.
   * - **Requirements:** Provides guidance to implementers familiar with or converting content from other specifications.
   * - **FHIR Type:** `Element`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private mapping?: ElementDefinitionMappingComponent[] | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `path` property value as a StringType object if defined; else null
   */
  public getPathElement(): StringType | null {
    return this.path;
  }

  /**
   * Assigns the provided PrimitiveType value to the `path` property.
   *
   * @param element - the `path` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPathElement(element: StringType): this {
    assertIsDefined<StringType>(element, `ElementDefinition.path is required`);
    const optErrMsg = `Invalid ElementDefinition.path; Provided value is not an instance of StringType.`;
    assertFhirType<StringType>(element, StringType, optErrMsg);
    this.path = element;
    return this;
  }

  /**
   * @returns `true` if the `path` property exists and has a value; `false` otherwise
   */
  public hasPathElement(): boolean {
    return isDefined<StringType>(this.path) && !this.path.isEmpty();
  }

  /**
   * @returns the `path` property value as a fhirString if defined; else null
   */
  public getPath(): fhirString | null {
    if (this.path?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.path.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the `path` property.
   *
   * @param value - the `path` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPath(value: fhirString): this {
    assertIsDefined<fhirString>(value, `ElementDefinition.path is required`);
    const optErrMsg = `Invalid ElementDefinition.path (${String(value)})`;
    this.path = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    return this;
  }

  /**
   * @returns `true` if the `path` property exists and has a value; `false` otherwise
   */
  public hasPath(): boolean {
    return this.hasPathElement();
  }

  /**
   * @returns the `representation` property value as a EnumCodeType array
   *
   * @see CodeSystem Enumeration: {@link PropertyRepresentationEnum }
   */
  public getRepresentationEnumType(): EnumCodeType[] {
    return this.representation ?? ([] as EnumCodeType[]);
  }

  /**
   * Assigns the provided EnumCodeType array value to the `representation` property.
   *
   * @param enumType - the `representation` array value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link PropertyRepresentationEnum }
   */
  public setRepresentationEnumType(enumType: EnumCodeType[] | undefined): this {
    if (isDefinedList<EnumCodeType>(enumType)) {
      const errMsgPrefix = `Invalid ElementDefinition.representation`;
      assertEnumCodeTypeList<PropertyRepresentationEnum>(enumType, PropertyRepresentationEnum, errMsgPrefix);
      this.representation = enumType;
    } else {
      this.representation = undefined;
    }
    return this;
  }

  /**
   * Add the provided EnumCodeType value to the `representation` array property.
   *
   * @param enumType - the `representation` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   *
   * @see CodeSystem Enumeration: {@link PropertyRepresentationEnum }
   */
  public addRepresentationEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = `Invalid ElementDefinition.representation`;
      assertEnumCodeType<PropertyRepresentationEnum>(enumType, PropertyRepresentationEnum, errMsgPrefix);
      this.initRepresentation();
      this.representation?.push(enumType);
    }
    return this;
  }

  /**
   * @returns `true` if the `representation` property exists and has a value; `false` otherwise
   */
  public hasRepresentationEnumType(): boolean {
    return isDefinedList<EnumCodeType>(this.representation) && this.representation.some((item: EnumCodeType) => !item.isEmpty()) && this.representation.every((item: EnumCodeType) => item.fhirCodeEnumeration.length > 0);
  }

  /**
   * @returns the `representation` property value as a CodeType array
   *
   * @see CodeSystem Enumeration: {@link PropertyRepresentationEnum }
   */
  public getRepresentationElement(): CodeType[] {
    if (this.representation === undefined) {
      return [] as CodeType[];
    }
    return this.representation as CodeType[];
  }

  /**
   * Assigns the provided PrimitiveType array value to the `representation` property.
   *
   * @param element - the `representation` array value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link PropertyRepresentationEnum }
   */
  public setRepresentationElement(element: CodeType[] | undefined): this {
    if (isDefinedList<CodeType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.representation; Provided element array has an element that is not an instance of CodeType.`;
      assertFhirTypeList<CodeType>(element, CodeType, optErrMsg);
      const enumCodeTypes = [] as EnumCodeType[];
      element.forEach((type: CodeType) => {
        enumCodeTypes.push(new EnumCodeType(type, this.propertyRepresentationEnum));
      });
      this.representation = enumCodeTypes;
    } else {
      this.representation = undefined;
    }
    return this;
  }

  /**
   * Add the provided PrimitiveType value to the `representation` array property.
   *
   * @param element - the `representation` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link PropertyRepresentationEnum }
   */
  public addRepresentationElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.representation; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.initRepresentation();
      this.representation?.push(new EnumCodeType(element, this.propertyRepresentationEnum));
    }
    return this;
  }

  /**
   * @returns `true` if the `representation` property exists and has a value; `false` otherwise
   */
  public hasRepresentationElement(): boolean {
    return this.hasRepresentationEnumType();
  }

  /**
   * @returns the `representation` property value as a fhirCode array
   *
   * @see CodeSystem Enumeration: {@link PropertyRepresentationEnum }
   */
  public getRepresentation(): fhirCode[] {
    if (this.representation === undefined) {
      return [] as fhirCode[];
    }
    const values = [] as fhirCode[];
    for (const item of this.representation) {
      values.push(item.fhirCode.code);
    }
    return values;
  }

  /**
   * Assigns the provided primitive value array to the `representation` property.
   *
   * @param value - the `representation` value array
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link PropertyRepresentationEnum }
   */
  public setRepresentation(value: fhirCode[] | undefined): this {
    if (isDefinedList<fhirCode>(value)) {
      const enumCodeTypes = [] as EnumCodeType[];
      const optErrMsg = `Invalid ElementDefinition.representation; Provided value is not an instance of fhirCode.`;
      value.forEach((val: fhirCode) => {
        enumCodeTypes.push(new EnumCodeType(parseFhirPrimitiveData(val, fhirCodeSchema, optErrMsg), this.propertyRepresentationEnum));
      });
      this.representation = enumCodeTypes;
    } else {
      this.representation = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the `representation` array property.
   *
   * @param value - the `representation` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link PropertyRepresentationEnum }
   */
  public addRepresentation(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      this.initRepresentation();
      const optErrMsg = `Invalid ElementDefinition.representation; Provided value is not an instance of fhirCode.`;
      this.representation?.push(new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.propertyRepresentationEnum));
    }
    return this;
  }

  /**
   * @returns `true` if the `representation` property exists and has a value; `false` otherwise
   */
  public hasRepresentation(): boolean {
    return this.hasRepresentationEnumType();
  }

  /**
   * Initialize the representation property
   */
  private initRepresentation(): void {
    if(!this.hasRepresentationEnumType()) {
      this.representation = [] as EnumCodeType[];
    }
  }

  /**
   * @returns the `sliceName` property value as a StringType object if defined; else an empty StringType object
   */
  public getSliceNameElement(): StringType {
    return this.sliceName ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `sliceName` property.
   *
   * @param element - the `sliceName` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSliceNameElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.sliceName; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.sliceName = element;
    } else {
      this.sliceName = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `sliceName` property exists and has a value; `false` otherwise
   */
  public hasSliceNameElement(): boolean {
    return isDefined<StringType>(this.sliceName) && !this.sliceName.isEmpty();
  }

  /**
   * @returns the `sliceName` property value as a fhirString if defined; else undefined
   */
  public getSliceName(): fhirString | undefined {
    return this.sliceName?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `sliceName` property.
   *
   * @param value - the `sliceName` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSliceName(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid ElementDefinition.sliceName (${String(value)})`;
      this.sliceName = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.sliceName = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `sliceName` property exists and has a value; `false` otherwise
   */
  public hasSliceName(): boolean {
    return this.hasSliceNameElement();
  }

  /**
   * @returns the `sliceIsConstraining` property value as a BooleanType object if defined; else an empty BooleanType object
   */
  public getSliceIsConstrainingElement(): BooleanType {
    return this.sliceIsConstraining ?? new BooleanType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `sliceIsConstraining` property.
   *
   * @param element - the `sliceIsConstraining` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSliceIsConstrainingElement(element: BooleanType | undefined): this {
    if (isDefined<BooleanType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.sliceIsConstraining; Provided element is not an instance of BooleanType.`;
      assertFhirType<BooleanType>(element, BooleanType, optErrMsg);
      this.sliceIsConstraining = element;
    } else {
      this.sliceIsConstraining = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `sliceIsConstraining` property exists and has a value; `false` otherwise
   */
  public hasSliceIsConstrainingElement(): boolean {
    return isDefined<BooleanType>(this.sliceIsConstraining) && !this.sliceIsConstraining.isEmpty();
  }

  /**
   * @returns the `sliceIsConstraining` property value as a fhirBoolean if defined; else undefined
   */
  public getSliceIsConstraining(): fhirBoolean | undefined {
    return this.sliceIsConstraining?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `sliceIsConstraining` property.
   *
   * @param value - the `sliceIsConstraining` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSliceIsConstraining(value: fhirBoolean | undefined): this {
    if (isDefined<fhirBoolean>(value)) {
      const optErrMsg = `Invalid ElementDefinition.sliceIsConstraining (${String(value)})`;
      this.sliceIsConstraining = new BooleanType(parseFhirPrimitiveData(value, fhirBooleanSchema, optErrMsg));
    } else {
      this.sliceIsConstraining = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `sliceIsConstraining` property exists and has a value; `false` otherwise
   */
  public hasSliceIsConstraining(): boolean {
    return this.hasSliceIsConstrainingElement();
  }

  /**
   * @returns the `label` property value as a StringType object if defined; else an empty StringType object
   */
  public getLabelElement(): StringType {
    return this.label ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `label` property.
   *
   * @param element - the `label` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLabelElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.label; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.label = element;
    } else {
      this.label = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `label` property exists and has a value; `false` otherwise
   */
  public hasLabelElement(): boolean {
    return isDefined<StringType>(this.label) && !this.label.isEmpty();
  }

  /**
   * @returns the `label` property value as a fhirString if defined; else undefined
   */
  public getLabel(): fhirString | undefined {
    return this.label?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `label` property.
   *
   * @param value - the `label` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLabel(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid ElementDefinition.label (${String(value)})`;
      this.label = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.label = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `label` property exists and has a value; `false` otherwise
   */
  public hasLabel(): boolean {
    return this.hasLabelElement();
  }

  /**
   * @returns the `code` property value as a Coding array
   */
  public getCode(): Coding[] {
    return this.code ?? ([] as Coding[]);
  }

  /**
   * Assigns the provided Coding array value to the `code` property.
   *
   * @param value - the `code` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setCode(value: Coding[] | undefined): this {
    if (isDefinedList<Coding>(value)) {
      const optErrMsg = `Invalid ElementDefinition.code; Provided value array has an element that is not an instance of Coding.`;
      assertFhirTypeList<Coding>(value, Coding, optErrMsg);
      this.code = value;
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * Add the provided Coding value to the `code` array property.
   *
   * @param value - the `code` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addCode(value: Coding | undefined): this {
    if (isDefined<Coding>(value)) {
      const optErrMsg = `Invalid ElementDefinition.code; Provided element is not an instance of Coding.`;
      assertFhirType<Coding>(value, Coding, optErrMsg);
      this.initCode();
      this.code?.push(value);
    }
    return this;
  }

  /**
   * @returns `true` if the `code` property exists and has a value; `false` otherwise
   */
  public hasCode(): boolean {
    return isDefinedList<Coding>(this.code) && this.code.some((item: Coding) => !item.isEmpty());
  }

  /**
   * Initialize the `code` property
   */
  private initCode(): void {
    if(!this.hasCode()) {
      this.code = [] as Coding[];
    }
  }

  /**
   * @returns the `slicing` property value as a ElementDefinitionSlicingComponent object if defined; else an empty ElementDefinitionSlicingComponent object
   */
  public getSlicing(): ElementDefinitionSlicingComponent {
    return this.slicing ?? new ElementDefinitionSlicingComponent();
  }

  /**
   * Assigns the provided Slicing object value to the `slicing` property.
   *
   * @param value - the `slicing` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setSlicing(value: ElementDefinitionSlicingComponent | undefined): this {
    if (isDefined<ElementDefinitionSlicingComponent>(value)) {
      const optErrMsg = `Invalid ElementDefinition.slicing; Provided element is not an instance of ElementDefinitionSlicingComponent.`;
      assertFhirType<ElementDefinitionSlicingComponent>(value, ElementDefinitionSlicingComponent, optErrMsg);
      this.slicing = value;
    } else {
      this.slicing = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `slicing` property exists and has a value; `false` otherwise
   */
  public hasSlicing(): boolean {
    return isDefined<ElementDefinitionSlicingComponent>(this.slicing) && !this.slicing.isEmpty();
  }

  /**
   * @returns the `short` property value as a StringType object if defined; else an empty StringType object
   */
  public getShortElement(): StringType {
    return this.short ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `short` property.
   *
   * @param element - the `short` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setShortElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.short; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.short = element;
    } else {
      this.short = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `short` property exists and has a value; `false` otherwise
   */
  public hasShortElement(): boolean {
    return isDefined<StringType>(this.short) && !this.short.isEmpty();
  }

  /**
   * @returns the `short` property value as a fhirString if defined; else undefined
   */
  public getShort(): fhirString | undefined {
    return this.short?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `short` property.
   *
   * @param value - the `short` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setShort(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid ElementDefinition.short (${String(value)})`;
      this.short = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.short = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `short` property exists and has a value; `false` otherwise
   */
  public hasShort(): boolean {
    return this.hasShortElement();
  }

  /**
   * @returns the `definition` property value as a MarkdownType object if defined; else an empty MarkdownType object
   */
  public getDefinitionElement(): MarkdownType {
    return this.definition ?? new MarkdownType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `definition` property.
   *
   * @param element - the `definition` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDefinitionElement(element: MarkdownType | undefined): this {
    if (isDefined<MarkdownType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.definition; Provided element is not an instance of MarkdownType.`;
      assertFhirType<MarkdownType>(element, MarkdownType, optErrMsg);
      this.definition = element;
    } else {
      this.definition = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `definition` property exists and has a value; `false` otherwise
   */
  public hasDefinitionElement(): boolean {
    return isDefined<MarkdownType>(this.definition) && !this.definition.isEmpty();
  }

  /**
   * @returns the `definition` property value as a fhirMarkdown if defined; else undefined
   */
  public getDefinition(): fhirMarkdown | undefined {
    return this.definition?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `definition` property.
   *
   * @param value - the `definition` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDefinition(value: fhirMarkdown | undefined): this {
    if (isDefined<fhirMarkdown>(value)) {
      const optErrMsg = `Invalid ElementDefinition.definition (${String(value)})`;
      this.definition = new MarkdownType(parseFhirPrimitiveData(value, fhirMarkdownSchema, optErrMsg));
    } else {
      this.definition = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `definition` property exists and has a value; `false` otherwise
   */
  public hasDefinition(): boolean {
    return this.hasDefinitionElement();
  }

  /**
   * @returns the `comment` property value as a MarkdownType object if defined; else an empty MarkdownType object
   */
  public getCommentElement(): MarkdownType {
    return this.comment ?? new MarkdownType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `comment` property.
   *
   * @param element - the `comment` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCommentElement(element: MarkdownType | undefined): this {
    if (isDefined<MarkdownType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.comment; Provided element is not an instance of MarkdownType.`;
      assertFhirType<MarkdownType>(element, MarkdownType, optErrMsg);
      this.comment = element;
    } else {
      this.comment = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `comment` property exists and has a value; `false` otherwise
   */
  public hasCommentElement(): boolean {
    return isDefined<MarkdownType>(this.comment) && !this.comment.isEmpty();
  }

  /**
   * @returns the `comment` property value as a fhirMarkdown if defined; else undefined
   */
  public getComment(): fhirMarkdown | undefined {
    return this.comment?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `comment` property.
   *
   * @param value - the `comment` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setComment(value: fhirMarkdown | undefined): this {
    if (isDefined<fhirMarkdown>(value)) {
      const optErrMsg = `Invalid ElementDefinition.comment (${String(value)})`;
      this.comment = new MarkdownType(parseFhirPrimitiveData(value, fhirMarkdownSchema, optErrMsg));
    } else {
      this.comment = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `comment` property exists and has a value; `false` otherwise
   */
  public hasComment(): boolean {
    return this.hasCommentElement();
  }

  /**
   * @returns the `requirements` property value as a MarkdownType object if defined; else an empty MarkdownType object
   */
  public getRequirementsElement(): MarkdownType {
    return this.requirements ?? new MarkdownType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `requirements` property.
   *
   * @param element - the `requirements` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setRequirementsElement(element: MarkdownType | undefined): this {
    if (isDefined<MarkdownType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.requirements; Provided element is not an instance of MarkdownType.`;
      assertFhirType<MarkdownType>(element, MarkdownType, optErrMsg);
      this.requirements = element;
    } else {
      this.requirements = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `requirements` property exists and has a value; `false` otherwise
   */
  public hasRequirementsElement(): boolean {
    return isDefined<MarkdownType>(this.requirements) && !this.requirements.isEmpty();
  }

  /**
   * @returns the `requirements` property value as a fhirMarkdown if defined; else undefined
   */
  public getRequirements(): fhirMarkdown | undefined {
    return this.requirements?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `requirements` property.
   *
   * @param value - the `requirements` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setRequirements(value: fhirMarkdown | undefined): this {
    if (isDefined<fhirMarkdown>(value)) {
      const optErrMsg = `Invalid ElementDefinition.requirements (${String(value)})`;
      this.requirements = new MarkdownType(parseFhirPrimitiveData(value, fhirMarkdownSchema, optErrMsg));
    } else {
      this.requirements = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `requirements` property exists and has a value; `false` otherwise
   */
  public hasRequirements(): boolean {
    return this.hasRequirementsElement();
  }

  /**
   * @returns the `alias` property value as a StringType array
   */
  public getAliasElement(): StringType[] {
    return this.alias ?? ([] as StringType[]);
  }

  /**
   * Assigns the provided StringType array value to the `alias` property.
   *
   * @param element - the `alias` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAliasElement(element: StringType[] | undefined): this {
    if (isDefinedList<StringType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.alias; Provided value array has an element that is not an instance of StringType.`;
      assertFhirTypeList<StringType>(element, StringType, optErrMsg);
      this.alias = element;
    } else {
      this.alias = undefined;
    }
    return this;
  }

  /**
   * Add the provided StringType value to the `alias` array property.
   *
   * @param element - the `alias` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addAliasElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.alias; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.initAlias();
      this.alias?.push(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `alias` property exists and has a value; `false` otherwise
   */
  public hasAliasElement(): boolean {
    return isDefinedList<StringType>(this.alias) && this.alias.some((item: StringType) => !item.isEmpty());
  }

  /**
   * @returns the `alias` property value as a fhirString array
   */
  public getAlias(): fhirString[] {
    this.initAlias();
    const aliasValues = [] as fhirString[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.alias!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        aliasValues.push(value);
      }
    }
    return aliasValues;
  }

  /**
   * Assigns the provided primitive value array to the `alias` property.
   *
   * @param value - the `alias` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAlias(value: fhirString[] | undefined): this {
    if (isDefinedList<fhirString>(value)) {
      const aliasElements = [] as StringType[];
      for (const aliasValue of value) {
        const optErrMsg = `Invalid ElementDefinition.alias array item (${String(aliasValue)})`;
        const element = new StringType(parseFhirPrimitiveData(aliasValue, fhirStringSchema, optErrMsg));
        aliasElements.push(element);
      }
      this.alias = aliasElements;
    } else {
      this.alias = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the `alias` array property.
   *
   * @param value - the `alias` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addAlias(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid ElementDefinition.alias array item (${String(value)})`;
      const element = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
      this.initAlias();
      this.addAliasElement(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `alias` property exists and has a value; `false` otherwise
   */
  public hasAlias(): boolean {
    return this.hasAliasElement();
  }

  /**
   * Initialize the `alias` property
   */
  private initAlias(): void {
    if (!this.hasAlias()) {
      this.alias = [] as StringType[];
    }
  }

  /**
   * @returns the `min` property value as a UnsignedIntType object if defined; else an empty UnsignedIntType object
   */
  public getMinElement(): UnsignedIntType {
    return this.min ?? new UnsignedIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `min` property.
   *
   * @param element - the `min` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMinElement(element: UnsignedIntType | undefined): this {
    if (isDefined<UnsignedIntType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.min; Provided element is not an instance of UnsignedIntType.`;
      assertFhirType<UnsignedIntType>(element, UnsignedIntType, optErrMsg);
      this.min = element;
    } else {
      this.min = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `min` property exists and has a value; `false` otherwise
   */
  public hasMinElement(): boolean {
    return isDefined<UnsignedIntType>(this.min) && !this.min.isEmpty();
  }

  /**
   * @returns the `min` property value as a fhirUnsignedInt if defined; else undefined
   */
  public getMin(): fhirUnsignedInt | undefined {
    return this.min?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `min` property.
   *
   * @param value - the `min` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMin(value: fhirUnsignedInt | undefined): this {
    if (isDefined<fhirUnsignedInt>(value)) {
      const optErrMsg = `Invalid ElementDefinition.min (${String(value)})`;
      this.min = new UnsignedIntType(parseFhirPrimitiveData(value, fhirUnsignedIntSchema, optErrMsg));
    } else {
      this.min = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `min` property exists and has a value; `false` otherwise
   */
  public hasMin(): boolean {
    return this.hasMinElement();
  }

  /**
   * @returns the `max` property value as a StringType object if defined; else an empty StringType object
   */
  public getMaxElement(): StringType {
    return this.max ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `max` property.
   *
   * @param element - the `max` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMaxElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.max; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.max = element;
    } else {
      this.max = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `max` property exists and has a value; `false` otherwise
   */
  public hasMaxElement(): boolean {
    return isDefined<StringType>(this.max) && !this.max.isEmpty();
  }

  /**
   * @returns the `max` property value as a fhirString if defined; else undefined
   */
  public getMax(): fhirString | undefined {
    return this.max?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `max` property.
   *
   * @param value - the `max` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMax(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid ElementDefinition.max (${String(value)})`;
      this.max = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.max = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `max` property exists and has a value; `false` otherwise
   */
  public hasMax(): boolean {
    return this.hasMaxElement();
  }

  /**
   * @returns the `base` property value as a ElementDefinitionBaseComponent object if defined; else an empty ElementDefinitionBaseComponent object
   */
  public getBase(): ElementDefinitionBaseComponent {
    return this.base ?? new ElementDefinitionBaseComponent();
  }

  /**
   * Assigns the provided Base object value to the `base` property.
   *
   * @param value - the `base` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setBase(value: ElementDefinitionBaseComponent | undefined): this {
    if (isDefined<ElementDefinitionBaseComponent>(value)) {
      const optErrMsg = `Invalid ElementDefinition.base; Provided element is not an instance of ElementDefinitionBaseComponent.`;
      assertFhirType<ElementDefinitionBaseComponent>(value, ElementDefinitionBaseComponent, optErrMsg);
      this.base = value;
    } else {
      this.base = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `base` property exists and has a value; `false` otherwise
   */
  public hasBase(): boolean {
    return isDefined<ElementDefinitionBaseComponent>(this.base) && !this.base.isEmpty();
  }

  /**
   * @returns the `contentReference` property value as a UriType object if defined; else an empty UriType object
   */
  public getContentReferenceElement(): UriType {
    return this.contentReference ?? new UriType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `contentReference` property.
   *
   * @param element - the `contentReference` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setContentReferenceElement(element: UriType | undefined): this {
    if (isDefined<UriType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.contentReference; Provided element is not an instance of UriType.`;
      assertFhirType<UriType>(element, UriType, optErrMsg);
      this.contentReference = element;
    } else {
      this.contentReference = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `contentReference` property exists and has a value; `false` otherwise
   */
  public hasContentReferenceElement(): boolean {
    return isDefined<UriType>(this.contentReference) && !this.contentReference.isEmpty();
  }

  /**
   * @returns the `contentReference` property value as a fhirUri if defined; else undefined
   */
  public getContentReference(): fhirUri | undefined {
    return this.contentReference?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `contentReference` property.
   *
   * @param value - the `contentReference` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setContentReference(value: fhirUri | undefined): this {
    if (isDefined<fhirUri>(value)) {
      const optErrMsg = `Invalid ElementDefinition.contentReference (${String(value)})`;
      this.contentReference = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    } else {
      this.contentReference = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `contentReference` property exists and has a value; `false` otherwise
   */
  public hasContentReference(): boolean {
    return this.hasContentReferenceElement();
  }

  /**
   * @returns the `type_` property value as a ElementDefinitionTypeComponent array
   */
  public getType(): ElementDefinitionTypeComponent[] {
    return this.type_ ?? ([] as ElementDefinitionTypeComponent[]);
  }

  /**
   * Assigns the provided ElementDefinitionTypeComponent array value to the `type_` property.
   *
   * @param value - the `type_` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setType(value: ElementDefinitionTypeComponent[] | undefined): this {
    if (isDefinedList<ElementDefinitionTypeComponent>(value)) {
      const optErrMsg = `Invalid ElementDefinition.type; Provided value array has an element that is not an instance of ElementDefinitionTypeComponent.`;
      assertFhirTypeList<ElementDefinitionTypeComponent>(value, ElementDefinitionTypeComponent, optErrMsg);
      this.type_ = value;
    } else {
      this.type_ = undefined;
    }
    return this;
  }

  /**
   * Add the provided ElementDefinitionTypeComponent value to the `type_` array property.
   *
   * @param value - the `type_` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addType(value: ElementDefinitionTypeComponent | undefined): this {
    if (isDefined<ElementDefinitionTypeComponent>(value)) {
      const optErrMsg = `Invalid ElementDefinition.type; Provided element is not an instance of ElementDefinitionTypeComponent.`;
      assertFhirType<ElementDefinitionTypeComponent>(value, ElementDefinitionTypeComponent, optErrMsg);
      this.initType();
      this.type_?.push(value);
    }
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasType(): boolean {
    return isDefinedList<ElementDefinitionTypeComponent>(this.type_) && this.type_.some((item: ElementDefinitionTypeComponent) => !item.isEmpty());
  }

  /**
   * Initialize the `type_` property
   */
  private initType(): void {
    if(!this.hasType()) {
      this.type_ = [] as ElementDefinitionTypeComponent[];
    }
  }

  /**
   * @returns the `defaultValue` property value as a DataType object if defined; else undefined
   */
  public getDefaultValue(): IDataType | undefined {
    return this.defaultValue;
  }

  /**
   * Assigns the provided DataType object value to the `defaultValue` property.
   *
   * @decorator `@ChoiceDataTypes('ElementDefinition.defaultValue[x]')`
   *
   * @param value - the `defaultValue` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  @ChoiceDataTypes('ElementDefinition.defaultValue[x]')
  public setDefaultValue(value: IDataType | undefined): this {
    if (isDefined<IDataType>(value)) {
      // assertFhirType<IDataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.defaultValue = value;
    } else {
      this.defaultValue = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `defaultValue` property exists and has a value; `false` otherwise
   */
  public hasDefaultValue(): boolean {
    return isDefined<IDataType>(this.defaultValue) && !this.defaultValue.isEmpty();
  }

  // *** NOTE ***
  // Following choice datatype-specific "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the `defaultValue` property value as a Base64BinaryType object if defined; else undefined
   */
  public getDefaultValueBase64BinaryType(): Base64BinaryType | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof Base64BinaryType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected Base64BinaryType but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a Base64BinaryType and has a value; `false` otherwise
   */
  public hasDefaultValueBase64BinaryType(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof Base64BinaryType;
  }

  /**
   * @returns the `defaultValue` property value as a BooleanType object if defined; else undefined
   */
  public getDefaultValueBooleanType(): BooleanType | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof BooleanType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected BooleanType but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a BooleanType and has a value; `false` otherwise
   */
  public hasDefaultValueBooleanType(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof BooleanType;
  }

  /**
   * @returns the `defaultValue` property value as a CanonicalType object if defined; else undefined
   */
  public getDefaultValueCanonicalType(): CanonicalType | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof CanonicalType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected CanonicalType but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a CanonicalType and has a value; `false` otherwise
   */
  public hasDefaultValueCanonicalType(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof CanonicalType;
  }

  /**
   * @returns the `defaultValue` property value as a CodeType object if defined; else undefined
   */
  public getDefaultValueCodeType(): CodeType | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof CodeType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected CodeType but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a CodeType and has a value; `false` otherwise
   */
  public hasDefaultValueCodeType(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof CodeType;
  }

  /**
   * @returns the `defaultValue` property value as a DateType object if defined; else undefined
   */
  public getDefaultValueDateType(): DateType | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof DateType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected DateType but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a DateType and has a value; `false` otherwise
   */
  public hasDefaultValueDateType(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof DateType;
  }

  /**
   * @returns the `defaultValue` property value as a DateTimeType object if defined; else undefined
   */
  public getDefaultValueDateTimeType(): DateTimeType | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof DateTimeType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected DateTimeType but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a DateTimeType and has a value; `false` otherwise
   */
  public hasDefaultValueDateTimeType(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof DateTimeType;
  }

  /**
   * @returns the `defaultValue` property value as a DecimalType object if defined; else undefined
   */
  public getDefaultValueDecimalType(): DecimalType | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof DecimalType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected DecimalType but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a DecimalType and has a value; `false` otherwise
   */
  public hasDefaultValueDecimalType(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof DecimalType;
  }

  /**
   * @returns the `defaultValue` property value as a IdType object if defined; else undefined
   */
  public getDefaultValueIdType(): IdType | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof IdType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected IdType but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a IdType and has a value; `false` otherwise
   */
  public hasDefaultValueIdType(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof IdType;
  }

  /**
   * @returns the `defaultValue` property value as a InstantType object if defined; else undefined
   */
  public getDefaultValueInstantType(): InstantType | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof InstantType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected InstantType but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a InstantType and has a value; `false` otherwise
   */
  public hasDefaultValueInstantType(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof InstantType;
  }

  /**
   * @returns the `defaultValue` property value as a IntegerType object if defined; else undefined
   */
  public getDefaultValueIntegerType(): IntegerType | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof IntegerType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected IntegerType but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a IntegerType and has a value; `false` otherwise
   */
  public hasDefaultValueIntegerType(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof IntegerType;
  }

  /**
   * @returns the `defaultValue` property value as a Integer64Type object if defined; else undefined
   */
  public getDefaultValueInteger64Type(): Integer64Type | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof Integer64Type)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected Integer64Type but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a Integer64Type and has a value; `false` otherwise
   */
  public hasDefaultValueInteger64Type(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof Integer64Type;
  }

  /**
   * @returns the `defaultValue` property value as a MarkdownType object if defined; else undefined
   */
  public getDefaultValueMarkdownType(): MarkdownType | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof MarkdownType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected MarkdownType but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a MarkdownType and has a value; `false` otherwise
   */
  public hasDefaultValueMarkdownType(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof MarkdownType;
  }

  /**
   * @returns the `defaultValue` property value as a OidType object if defined; else undefined
   */
  public getDefaultValueOidType(): OidType | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof OidType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected OidType but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a OidType and has a value; `false` otherwise
   */
  public hasDefaultValueOidType(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof OidType;
  }

  /**
   * @returns the `defaultValue` property value as a PositiveIntType object if defined; else undefined
   */
  public getDefaultValuePositiveIntType(): PositiveIntType | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof PositiveIntType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected PositiveIntType but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a PositiveIntType and has a value; `false` otherwise
   */
  public hasDefaultValuePositiveIntType(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof PositiveIntType;
  }

  /**
   * @returns the `defaultValue` property value as a StringType object if defined; else undefined
   */
  public getDefaultValueStringType(): StringType | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof StringType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected StringType but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a StringType and has a value; `false` otherwise
   */
  public hasDefaultValueStringType(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof StringType;
  }

  /**
   * @returns the `defaultValue` property value as a TimeType object if defined; else undefined
   */
  public getDefaultValueTimeType(): TimeType | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof TimeType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected TimeType but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a TimeType and has a value; `false` otherwise
   */
  public hasDefaultValueTimeType(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof TimeType;
  }

  /**
   * @returns the `defaultValue` property value as a UnsignedIntType object if defined; else undefined
   */
  public getDefaultValueUnsignedIntType(): UnsignedIntType | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof UnsignedIntType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected UnsignedIntType but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a UnsignedIntType and has a value; `false` otherwise
   */
  public hasDefaultValueUnsignedIntType(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof UnsignedIntType;
  }

  /**
   * @returns the `defaultValue` property value as a UriType object if defined; else undefined
   */
  public getDefaultValueUriType(): UriType | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof UriType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected UriType but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a UriType and has a value; `false` otherwise
   */
  public hasDefaultValueUriType(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof UriType;
  }

  /**
   * @returns the `defaultValue` property value as a UrlType object if defined; else undefined
   */
  public getDefaultValueUrlType(): UrlType | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof UrlType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected UrlType but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a UrlType and has a value; `false` otherwise
   */
  public hasDefaultValueUrlType(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof UrlType;
  }

  /**
   * @returns the `defaultValue` property value as a UuidType object if defined; else undefined
   */
  public getDefaultValueUuidType(): UuidType | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof UuidType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected UuidType but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a UuidType and has a value; `false` otherwise
   */
  public hasDefaultValueUuidType(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof UuidType;
  }

  /**
   * @returns the `defaultValue` property value as a Address object if defined; else undefined
   */
  public getDefaultValueAddress(): Address | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof Address)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected Address but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a Address and has a value; `false` otherwise
   */
  public hasDefaultValueAddress(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof Address;
  }

  /**
   * @returns the `defaultValue` property value as a Age object if defined; else undefined
   */
  public getDefaultValueAge(): Age | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof Age)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected Age but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a Age and has a value; `false` otherwise
   */
  public hasDefaultValueAge(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof Age;
  }

  /**
   * @returns the `defaultValue` property value as a Annotation object if defined; else undefined
   */
  public getDefaultValueAnnotation(): Annotation | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof Annotation)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected Annotation but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a Annotation and has a value; `false` otherwise
   */
  public hasDefaultValueAnnotation(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof Annotation;
  }

  /**
   * @returns the `defaultValue` property value as a Attachment object if defined; else undefined
   */
  public getDefaultValueAttachment(): Attachment | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof Attachment)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected Attachment but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a Attachment and has a value; `false` otherwise
   */
  public hasDefaultValueAttachment(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof Attachment;
  }

  /**
   * @returns the `defaultValue` property value as a CodeableConcept object if defined; else undefined
   */
  public getDefaultValueCodeableConcept(): CodeableConcept | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof CodeableConcept)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected CodeableConcept but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a CodeableConcept and has a value; `false` otherwise
   */
  public hasDefaultValueCodeableConcept(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof CodeableConcept;
  }

  /**
   * @returns the `defaultValue` property value as a CodeableReference object if defined; else undefined
   */
  public getDefaultValueCodeableReference(): CodeableReference | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof CodeableReference)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected CodeableReference but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a CodeableReference and has a value; `false` otherwise
   */
  public hasDefaultValueCodeableReference(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof CodeableReference;
  }

  /**
   * @returns the `defaultValue` property value as a Coding object if defined; else undefined
   */
  public getDefaultValueCoding(): Coding | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof Coding)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected Coding but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a Coding and has a value; `false` otherwise
   */
  public hasDefaultValueCoding(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof Coding;
  }

  /**
   * @returns the `defaultValue` property value as a ContactPoint object if defined; else undefined
   */
  public getDefaultValueContactPoint(): ContactPoint | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof ContactPoint)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected ContactPoint but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a ContactPoint and has a value; `false` otherwise
   */
  public hasDefaultValueContactPoint(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof ContactPoint;
  }

  /**
   * @returns the `defaultValue` property value as a Count object if defined; else undefined
   */
  public getDefaultValueCount(): Count | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof Count)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected Count but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a Count and has a value; `false` otherwise
   */
  public hasDefaultValueCount(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof Count;
  }

  /**
   * @returns the `defaultValue` property value as a Distance object if defined; else undefined
   */
  public getDefaultValueDistance(): Distance | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof Distance)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected Distance but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a Distance and has a value; `false` otherwise
   */
  public hasDefaultValueDistance(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof Distance;
  }

  /**
   * @returns the `defaultValue` property value as a Duration object if defined; else undefined
   */
  public getDefaultValueDuration(): Duration | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof Duration)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected Duration but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a Duration and has a value; `false` otherwise
   */
  public hasDefaultValueDuration(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof Duration;
  }

  /**
   * @returns the `defaultValue` property value as a HumanName object if defined; else undefined
   */
  public getDefaultValueHumanName(): HumanName | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof HumanName)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected HumanName but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a HumanName and has a value; `false` otherwise
   */
  public hasDefaultValueHumanName(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof HumanName;
  }

  /**
   * @returns the `defaultValue` property value as a Identifier object if defined; else undefined
   */
  public getDefaultValueIdentifier(): Identifier | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof Identifier)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected Identifier but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a Identifier and has a value; `false` otherwise
   */
  public hasDefaultValueIdentifier(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof Identifier;
  }

  /**
   * @returns the `defaultValue` property value as a Money object if defined; else undefined
   */
  public getDefaultValueMoney(): Money | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof Money)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected Money but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a Money and has a value; `false` otherwise
   */
  public hasDefaultValueMoney(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof Money;
  }

  /**
   * @returns the `defaultValue` property value as a Period object if defined; else undefined
   */
  public getDefaultValuePeriod(): Period | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof Period)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected Period but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a Period and has a value; `false` otherwise
   */
  public hasDefaultValuePeriod(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof Period;
  }

  /**
   * @returns the `defaultValue` property value as a Quantity object if defined; else undefined
   */
  public getDefaultValueQuantity(): Quantity | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof Quantity)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected Quantity but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a Quantity and has a value; `false` otherwise
   */
  public hasDefaultValueQuantity(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof Quantity;
  }

  /**
   * @returns the `defaultValue` property value as a Range object if defined; else undefined
   */
  public getDefaultValueRange(): Range | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof Range)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected Range but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a Range and has a value; `false` otherwise
   */
  public hasDefaultValueRange(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof Range;
  }

  /**
   * @returns the `defaultValue` property value as a Ratio object if defined; else undefined
   */
  public getDefaultValueRatio(): Ratio | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof Ratio)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected Ratio but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a Ratio and has a value; `false` otherwise
   */
  public hasDefaultValueRatio(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof Ratio;
  }

  /**
   * @returns the `defaultValue` property value as a RatioRange object if defined; else undefined
   */
  public getDefaultValueRatioRange(): RatioRange | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof RatioRange)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected RatioRange but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a RatioRange and has a value; `false` otherwise
   */
  public hasDefaultValueRatioRange(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof RatioRange;
  }

  /**
   * @returns the `defaultValue` property value as a Reference object if defined; else undefined
   */
  public getDefaultValueReference(): Reference | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof Reference)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected Reference but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a Reference and has a value; `false` otherwise
   */
  public hasDefaultValueReference(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof Reference;
  }

  /**
   * @returns the `defaultValue` property value as a SampledData object if defined; else undefined
   */
  public getDefaultValueSampledData(): SampledData | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof SampledData)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected SampledData but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a SampledData and has a value; `false` otherwise
   */
  public hasDefaultValueSampledData(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof SampledData;
  }

  /**
   * @returns the `defaultValue` property value as a Signature object if defined; else undefined
   */
  public getDefaultValueSignature(): Signature | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof Signature)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected Signature but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a Signature and has a value; `false` otherwise
   */
  public hasDefaultValueSignature(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof Signature;
  }

  /**
   * @returns the `defaultValue` property value as a Timing object if defined; else undefined
   */
  public getDefaultValueTiming(): Timing | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof Timing)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected Timing but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a Timing and has a value; `false` otherwise
   */
  public hasDefaultValueTiming(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof Timing;
  }

  /**
   * @returns the `defaultValue` property value as a ContactDetail object if defined; else undefined
   */
  public getDefaultValueContactDetail(): ContactDetail | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof ContactDetail)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected ContactDetail but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a ContactDetail and has a value; `false` otherwise
   */
  public hasDefaultValueContactDetail(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof ContactDetail;
  }

  /**
   * @returns the `defaultValue` property value as a DataRequirement object if defined; else undefined
   */
  public getDefaultValueDataRequirement(): DataRequirement | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof DataRequirement)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected DataRequirement but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a DataRequirement and has a value; `false` otherwise
   */
  public hasDefaultValueDataRequirement(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof DataRequirement;
  }

  /**
   * @returns the `defaultValue` property value as a Expression object if defined; else undefined
   */
  public getDefaultValueExpression(): Expression | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof Expression)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected Expression but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a Expression and has a value; `false` otherwise
   */
  public hasDefaultValueExpression(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof Expression;
  }

  /**
   * @returns the `defaultValue` property value as a ParameterDefinition object if defined; else undefined
   */
  public getDefaultValueParameterDefinition(): ParameterDefinition | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof ParameterDefinition)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected ParameterDefinition but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a ParameterDefinition and has a value; `false` otherwise
   */
  public hasDefaultValueParameterDefinition(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof ParameterDefinition;
  }

  /**
   * @returns the `defaultValue` property value as a RelatedArtifact object if defined; else undefined
   */
  public getDefaultValueRelatedArtifact(): RelatedArtifact | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof RelatedArtifact)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected RelatedArtifact but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a RelatedArtifact and has a value; `false` otherwise
   */
  public hasDefaultValueRelatedArtifact(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof RelatedArtifact;
  }

  /**
   * @returns the `defaultValue` property value as a TriggerDefinition object if defined; else undefined
   */
  public getDefaultValueTriggerDefinition(): TriggerDefinition | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof TriggerDefinition)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected TriggerDefinition but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a TriggerDefinition and has a value; `false` otherwise
   */
  public hasDefaultValueTriggerDefinition(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof TriggerDefinition;
  }

  /**
   * @returns the `defaultValue` property value as a UsageContext object if defined; else undefined
   */
  public getDefaultValueUsageContext(): UsageContext | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof UsageContext)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected UsageContext but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a UsageContext and has a value; `false` otherwise
   */
  public hasDefaultValueUsageContext(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof UsageContext;
  }

  /**
   * @returns the `defaultValue` property value as a Availability object if defined; else undefined
   */
  public getDefaultValueAvailability(): Availability | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof Availability)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected Availability but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a Availability and has a value; `false` otherwise
   */
  public hasDefaultValueAvailability(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof Availability;
  }

  /**
   * @returns the `defaultValue` property value as a ExtendedContactDetail object if defined; else undefined
   */
  public getDefaultValueExtendedContactDetail(): ExtendedContactDetail | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof ExtendedContactDetail)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected ExtendedContactDetail but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a ExtendedContactDetail and has a value; `false` otherwise
   */
  public hasDefaultValueExtendedContactDetail(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof ExtendedContactDetail;
  }

  /**
   * @returns the `defaultValue` property value as a Dosage object if defined; else undefined
   */
  public getDefaultValueDosage(): Dosage | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof Dosage)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected Dosage but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a Dosage and has a value; `false` otherwise
   */
  public hasDefaultValueDosage(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof Dosage;
  }

  /**
   * @returns the `defaultValue` property value as a Meta object if defined; else undefined
   */
  public getDefaultValueMeta(): Meta | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof Meta)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected Meta but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a Meta and has a value; `false` otherwise
   */
  public hasDefaultValueMeta(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof Meta;
  }

  // End of choice datatype-specific "get"/"has" methods

  /**
   * @returns the `meaningWhenMissing` property value as a MarkdownType object if defined; else an empty MarkdownType object
   */
  public getMeaningWhenMissingElement(): MarkdownType {
    return this.meaningWhenMissing ?? new MarkdownType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `meaningWhenMissing` property.
   *
   * @param element - the `meaningWhenMissing` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMeaningWhenMissingElement(element: MarkdownType | undefined): this {
    if (isDefined<MarkdownType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.meaningWhenMissing; Provided element is not an instance of MarkdownType.`;
      assertFhirType<MarkdownType>(element, MarkdownType, optErrMsg);
      this.meaningWhenMissing = element;
    } else {
      this.meaningWhenMissing = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `meaningWhenMissing` property exists and has a value; `false` otherwise
   */
  public hasMeaningWhenMissingElement(): boolean {
    return isDefined<MarkdownType>(this.meaningWhenMissing) && !this.meaningWhenMissing.isEmpty();
  }

  /**
   * @returns the `meaningWhenMissing` property value as a fhirMarkdown if defined; else undefined
   */
  public getMeaningWhenMissing(): fhirMarkdown | undefined {
    return this.meaningWhenMissing?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `meaningWhenMissing` property.
   *
   * @param value - the `meaningWhenMissing` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMeaningWhenMissing(value: fhirMarkdown | undefined): this {
    if (isDefined<fhirMarkdown>(value)) {
      const optErrMsg = `Invalid ElementDefinition.meaningWhenMissing (${String(value)})`;
      this.meaningWhenMissing = new MarkdownType(parseFhirPrimitiveData(value, fhirMarkdownSchema, optErrMsg));
    } else {
      this.meaningWhenMissing = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `meaningWhenMissing` property exists and has a value; `false` otherwise
   */
  public hasMeaningWhenMissing(): boolean {
    return this.hasMeaningWhenMissingElement();
  }

  /**
   * @returns the `orderMeaning` property value as a StringType object if defined; else an empty StringType object
   */
  public getOrderMeaningElement(): StringType {
    return this.orderMeaning ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `orderMeaning` property.
   *
   * @param element - the `orderMeaning` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setOrderMeaningElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.orderMeaning; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.orderMeaning = element;
    } else {
      this.orderMeaning = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `orderMeaning` property exists and has a value; `false` otherwise
   */
  public hasOrderMeaningElement(): boolean {
    return isDefined<StringType>(this.orderMeaning) && !this.orderMeaning.isEmpty();
  }

  /**
   * @returns the `orderMeaning` property value as a fhirString if defined; else undefined
   */
  public getOrderMeaning(): fhirString | undefined {
    return this.orderMeaning?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `orderMeaning` property.
   *
   * @param value - the `orderMeaning` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setOrderMeaning(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid ElementDefinition.orderMeaning (${String(value)})`;
      this.orderMeaning = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.orderMeaning = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `orderMeaning` property exists and has a value; `false` otherwise
   */
  public hasOrderMeaning(): boolean {
    return this.hasOrderMeaningElement();
  }

  /**
   * @returns the `fixed` property value as a DataType object if defined; else undefined
   */
  public getFixed(): IDataType | undefined {
    return this.fixed;
  }

  /**
   * Assigns the provided DataType object value to the `fixed` property.
   *
   * @decorator `@ChoiceDataTypes('ElementDefinition.fixed[x]')`
   *
   * @param value - the `fixed` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  @ChoiceDataTypes('ElementDefinition.fixed[x]')
  public setFixed(value: IDataType | undefined): this {
    if (isDefined<IDataType>(value)) {
      // assertFhirType<IDataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.fixed = value;
    } else {
      this.fixed = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `fixed` property exists and has a value; `false` otherwise
   */
  public hasFixed(): boolean {
    return isDefined<IDataType>(this.fixed) && !this.fixed.isEmpty();
  }

  // *** NOTE ***
  // Following choice datatype-specific "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the `fixed` property value as a Base64BinaryType object if defined; else undefined
   */
  public getFixedBase64BinaryType(): Base64BinaryType | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof Base64BinaryType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected Base64BinaryType but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a Base64BinaryType and has a value; `false` otherwise
   */
  public hasFixedBase64BinaryType(): boolean {
    return this.hasFixed() && this.fixed instanceof Base64BinaryType;
  }

  /**
   * @returns the `fixed` property value as a BooleanType object if defined; else undefined
   */
  public getFixedBooleanType(): BooleanType | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof BooleanType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected BooleanType but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a BooleanType and has a value; `false` otherwise
   */
  public hasFixedBooleanType(): boolean {
    return this.hasFixed() && this.fixed instanceof BooleanType;
  }

  /**
   * @returns the `fixed` property value as a CanonicalType object if defined; else undefined
   */
  public getFixedCanonicalType(): CanonicalType | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof CanonicalType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected CanonicalType but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a CanonicalType and has a value; `false` otherwise
   */
  public hasFixedCanonicalType(): boolean {
    return this.hasFixed() && this.fixed instanceof CanonicalType;
  }

  /**
   * @returns the `fixed` property value as a CodeType object if defined; else undefined
   */
  public getFixedCodeType(): CodeType | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof CodeType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected CodeType but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a CodeType and has a value; `false` otherwise
   */
  public hasFixedCodeType(): boolean {
    return this.hasFixed() && this.fixed instanceof CodeType;
  }

  /**
   * @returns the `fixed` property value as a DateType object if defined; else undefined
   */
  public getFixedDateType(): DateType | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof DateType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected DateType but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a DateType and has a value; `false` otherwise
   */
  public hasFixedDateType(): boolean {
    return this.hasFixed() && this.fixed instanceof DateType;
  }

  /**
   * @returns the `fixed` property value as a DateTimeType object if defined; else undefined
   */
  public getFixedDateTimeType(): DateTimeType | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof DateTimeType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected DateTimeType but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a DateTimeType and has a value; `false` otherwise
   */
  public hasFixedDateTimeType(): boolean {
    return this.hasFixed() && this.fixed instanceof DateTimeType;
  }

  /**
   * @returns the `fixed` property value as a DecimalType object if defined; else undefined
   */
  public getFixedDecimalType(): DecimalType | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof DecimalType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected DecimalType but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a DecimalType and has a value; `false` otherwise
   */
  public hasFixedDecimalType(): boolean {
    return this.hasFixed() && this.fixed instanceof DecimalType;
  }

  /**
   * @returns the `fixed` property value as a IdType object if defined; else undefined
   */
  public getFixedIdType(): IdType | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof IdType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected IdType but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a IdType and has a value; `false` otherwise
   */
  public hasFixedIdType(): boolean {
    return this.hasFixed() && this.fixed instanceof IdType;
  }

  /**
   * @returns the `fixed` property value as a InstantType object if defined; else undefined
   */
  public getFixedInstantType(): InstantType | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof InstantType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected InstantType but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a InstantType and has a value; `false` otherwise
   */
  public hasFixedInstantType(): boolean {
    return this.hasFixed() && this.fixed instanceof InstantType;
  }

  /**
   * @returns the `fixed` property value as a IntegerType object if defined; else undefined
   */
  public getFixedIntegerType(): IntegerType | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof IntegerType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected IntegerType but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a IntegerType and has a value; `false` otherwise
   */
  public hasFixedIntegerType(): boolean {
    return this.hasFixed() && this.fixed instanceof IntegerType;
  }

  /**
   * @returns the `fixed` property value as a Integer64Type object if defined; else undefined
   */
  public getFixedInteger64Type(): Integer64Type | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof Integer64Type)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected Integer64Type but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a Integer64Type and has a value; `false` otherwise
   */
  public hasFixedInteger64Type(): boolean {
    return this.hasFixed() && this.fixed instanceof Integer64Type;
  }

  /**
   * @returns the `fixed` property value as a MarkdownType object if defined; else undefined
   */
  public getFixedMarkdownType(): MarkdownType | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof MarkdownType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected MarkdownType but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a MarkdownType and has a value; `false` otherwise
   */
  public hasFixedMarkdownType(): boolean {
    return this.hasFixed() && this.fixed instanceof MarkdownType;
  }

  /**
   * @returns the `fixed` property value as a OidType object if defined; else undefined
   */
  public getFixedOidType(): OidType | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof OidType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected OidType but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a OidType and has a value; `false` otherwise
   */
  public hasFixedOidType(): boolean {
    return this.hasFixed() && this.fixed instanceof OidType;
  }

  /**
   * @returns the `fixed` property value as a PositiveIntType object if defined; else undefined
   */
  public getFixedPositiveIntType(): PositiveIntType | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof PositiveIntType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected PositiveIntType but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a PositiveIntType and has a value; `false` otherwise
   */
  public hasFixedPositiveIntType(): boolean {
    return this.hasFixed() && this.fixed instanceof PositiveIntType;
  }

  /**
   * @returns the `fixed` property value as a StringType object if defined; else undefined
   */
  public getFixedStringType(): StringType | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof StringType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected StringType but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a StringType and has a value; `false` otherwise
   */
  public hasFixedStringType(): boolean {
    return this.hasFixed() && this.fixed instanceof StringType;
  }

  /**
   * @returns the `fixed` property value as a TimeType object if defined; else undefined
   */
  public getFixedTimeType(): TimeType | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof TimeType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected TimeType but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a TimeType and has a value; `false` otherwise
   */
  public hasFixedTimeType(): boolean {
    return this.hasFixed() && this.fixed instanceof TimeType;
  }

  /**
   * @returns the `fixed` property value as a UnsignedIntType object if defined; else undefined
   */
  public getFixedUnsignedIntType(): UnsignedIntType | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof UnsignedIntType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected UnsignedIntType but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a UnsignedIntType and has a value; `false` otherwise
   */
  public hasFixedUnsignedIntType(): boolean {
    return this.hasFixed() && this.fixed instanceof UnsignedIntType;
  }

  /**
   * @returns the `fixed` property value as a UriType object if defined; else undefined
   */
  public getFixedUriType(): UriType | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof UriType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected UriType but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a UriType and has a value; `false` otherwise
   */
  public hasFixedUriType(): boolean {
    return this.hasFixed() && this.fixed instanceof UriType;
  }

  /**
   * @returns the `fixed` property value as a UrlType object if defined; else undefined
   */
  public getFixedUrlType(): UrlType | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof UrlType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected UrlType but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a UrlType and has a value; `false` otherwise
   */
  public hasFixedUrlType(): boolean {
    return this.hasFixed() && this.fixed instanceof UrlType;
  }

  /**
   * @returns the `fixed` property value as a UuidType object if defined; else undefined
   */
  public getFixedUuidType(): UuidType | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof UuidType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected UuidType but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a UuidType and has a value; `false` otherwise
   */
  public hasFixedUuidType(): boolean {
    return this.hasFixed() && this.fixed instanceof UuidType;
  }

  /**
   * @returns the `fixed` property value as a Address object if defined; else undefined
   */
  public getFixedAddress(): Address | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof Address)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected Address but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a Address and has a value; `false` otherwise
   */
  public hasFixedAddress(): boolean {
    return this.hasFixed() && this.fixed instanceof Address;
  }

  /**
   * @returns the `fixed` property value as a Age object if defined; else undefined
   */
  public getFixedAge(): Age | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof Age)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected Age but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a Age and has a value; `false` otherwise
   */
  public hasFixedAge(): boolean {
    return this.hasFixed() && this.fixed instanceof Age;
  }

  /**
   * @returns the `fixed` property value as a Annotation object if defined; else undefined
   */
  public getFixedAnnotation(): Annotation | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof Annotation)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected Annotation but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a Annotation and has a value; `false` otherwise
   */
  public hasFixedAnnotation(): boolean {
    return this.hasFixed() && this.fixed instanceof Annotation;
  }

  /**
   * @returns the `fixed` property value as a Attachment object if defined; else undefined
   */
  public getFixedAttachment(): Attachment | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof Attachment)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected Attachment but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a Attachment and has a value; `false` otherwise
   */
  public hasFixedAttachment(): boolean {
    return this.hasFixed() && this.fixed instanceof Attachment;
  }

  /**
   * @returns the `fixed` property value as a CodeableConcept object if defined; else undefined
   */
  public getFixedCodeableConcept(): CodeableConcept | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof CodeableConcept)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected CodeableConcept but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a CodeableConcept and has a value; `false` otherwise
   */
  public hasFixedCodeableConcept(): boolean {
    return this.hasFixed() && this.fixed instanceof CodeableConcept;
  }

  /**
   * @returns the `fixed` property value as a CodeableReference object if defined; else undefined
   */
  public getFixedCodeableReference(): CodeableReference | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof CodeableReference)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected CodeableReference but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a CodeableReference and has a value; `false` otherwise
   */
  public hasFixedCodeableReference(): boolean {
    return this.hasFixed() && this.fixed instanceof CodeableReference;
  }

  /**
   * @returns the `fixed` property value as a Coding object if defined; else undefined
   */
  public getFixedCoding(): Coding | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof Coding)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected Coding but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a Coding and has a value; `false` otherwise
   */
  public hasFixedCoding(): boolean {
    return this.hasFixed() && this.fixed instanceof Coding;
  }

  /**
   * @returns the `fixed` property value as a ContactPoint object if defined; else undefined
   */
  public getFixedContactPoint(): ContactPoint | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof ContactPoint)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected ContactPoint but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a ContactPoint and has a value; `false` otherwise
   */
  public hasFixedContactPoint(): boolean {
    return this.hasFixed() && this.fixed instanceof ContactPoint;
  }

  /**
   * @returns the `fixed` property value as a Count object if defined; else undefined
   */
  public getFixedCount(): Count | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof Count)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected Count but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a Count and has a value; `false` otherwise
   */
  public hasFixedCount(): boolean {
    return this.hasFixed() && this.fixed instanceof Count;
  }

  /**
   * @returns the `fixed` property value as a Distance object if defined; else undefined
   */
  public getFixedDistance(): Distance | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof Distance)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected Distance but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a Distance and has a value; `false` otherwise
   */
  public hasFixedDistance(): boolean {
    return this.hasFixed() && this.fixed instanceof Distance;
  }

  /**
   * @returns the `fixed` property value as a Duration object if defined; else undefined
   */
  public getFixedDuration(): Duration | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof Duration)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected Duration but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a Duration and has a value; `false` otherwise
   */
  public hasFixedDuration(): boolean {
    return this.hasFixed() && this.fixed instanceof Duration;
  }

  /**
   * @returns the `fixed` property value as a HumanName object if defined; else undefined
   */
  public getFixedHumanName(): HumanName | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof HumanName)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected HumanName but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a HumanName and has a value; `false` otherwise
   */
  public hasFixedHumanName(): boolean {
    return this.hasFixed() && this.fixed instanceof HumanName;
  }

  /**
   * @returns the `fixed` property value as a Identifier object if defined; else undefined
   */
  public getFixedIdentifier(): Identifier | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof Identifier)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected Identifier but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a Identifier and has a value; `false` otherwise
   */
  public hasFixedIdentifier(): boolean {
    return this.hasFixed() && this.fixed instanceof Identifier;
  }

  /**
   * @returns the `fixed` property value as a Money object if defined; else undefined
   */
  public getFixedMoney(): Money | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof Money)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected Money but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a Money and has a value; `false` otherwise
   */
  public hasFixedMoney(): boolean {
    return this.hasFixed() && this.fixed instanceof Money;
  }

  /**
   * @returns the `fixed` property value as a Period object if defined; else undefined
   */
  public getFixedPeriod(): Period | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof Period)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected Period but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a Period and has a value; `false` otherwise
   */
  public hasFixedPeriod(): boolean {
    return this.hasFixed() && this.fixed instanceof Period;
  }

  /**
   * @returns the `fixed` property value as a Quantity object if defined; else undefined
   */
  public getFixedQuantity(): Quantity | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof Quantity)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected Quantity but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a Quantity and has a value; `false` otherwise
   */
  public hasFixedQuantity(): boolean {
    return this.hasFixed() && this.fixed instanceof Quantity;
  }

  /**
   * @returns the `fixed` property value as a Range object if defined; else undefined
   */
  public getFixedRange(): Range | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof Range)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected Range but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a Range and has a value; `false` otherwise
   */
  public hasFixedRange(): boolean {
    return this.hasFixed() && this.fixed instanceof Range;
  }

  /**
   * @returns the `fixed` property value as a Ratio object if defined; else undefined
   */
  public getFixedRatio(): Ratio | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof Ratio)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected Ratio but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a Ratio and has a value; `false` otherwise
   */
  public hasFixedRatio(): boolean {
    return this.hasFixed() && this.fixed instanceof Ratio;
  }

  /**
   * @returns the `fixed` property value as a RatioRange object if defined; else undefined
   */
  public getFixedRatioRange(): RatioRange | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof RatioRange)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected RatioRange but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a RatioRange and has a value; `false` otherwise
   */
  public hasFixedRatioRange(): boolean {
    return this.hasFixed() && this.fixed instanceof RatioRange;
  }

  /**
   * @returns the `fixed` property value as a Reference object if defined; else undefined
   */
  public getFixedReference(): Reference | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof Reference)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected Reference but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a Reference and has a value; `false` otherwise
   */
  public hasFixedReference(): boolean {
    return this.hasFixed() && this.fixed instanceof Reference;
  }

  /**
   * @returns the `fixed` property value as a SampledData object if defined; else undefined
   */
  public getFixedSampledData(): SampledData | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof SampledData)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected SampledData but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a SampledData and has a value; `false` otherwise
   */
  public hasFixedSampledData(): boolean {
    return this.hasFixed() && this.fixed instanceof SampledData;
  }

  /**
   * @returns the `fixed` property value as a Signature object if defined; else undefined
   */
  public getFixedSignature(): Signature | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof Signature)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected Signature but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a Signature and has a value; `false` otherwise
   */
  public hasFixedSignature(): boolean {
    return this.hasFixed() && this.fixed instanceof Signature;
  }

  /**
   * @returns the `fixed` property value as a Timing object if defined; else undefined
   */
  public getFixedTiming(): Timing | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof Timing)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected Timing but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a Timing and has a value; `false` otherwise
   */
  public hasFixedTiming(): boolean {
    return this.hasFixed() && this.fixed instanceof Timing;
  }

  /**
   * @returns the `fixed` property value as a ContactDetail object if defined; else undefined
   */
  public getFixedContactDetail(): ContactDetail | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof ContactDetail)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected ContactDetail but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a ContactDetail and has a value; `false` otherwise
   */
  public hasFixedContactDetail(): boolean {
    return this.hasFixed() && this.fixed instanceof ContactDetail;
  }

  /**
   * @returns the `fixed` property value as a DataRequirement object if defined; else undefined
   */
  public getFixedDataRequirement(): DataRequirement | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof DataRequirement)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected DataRequirement but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a DataRequirement and has a value; `false` otherwise
   */
  public hasFixedDataRequirement(): boolean {
    return this.hasFixed() && this.fixed instanceof DataRequirement;
  }

  /**
   * @returns the `fixed` property value as a Expression object if defined; else undefined
   */
  public getFixedExpression(): Expression | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof Expression)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected Expression but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a Expression and has a value; `false` otherwise
   */
  public hasFixedExpression(): boolean {
    return this.hasFixed() && this.fixed instanceof Expression;
  }

  /**
   * @returns the `fixed` property value as a ParameterDefinition object if defined; else undefined
   */
  public getFixedParameterDefinition(): ParameterDefinition | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof ParameterDefinition)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected ParameterDefinition but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a ParameterDefinition and has a value; `false` otherwise
   */
  public hasFixedParameterDefinition(): boolean {
    return this.hasFixed() && this.fixed instanceof ParameterDefinition;
  }

  /**
   * @returns the `fixed` property value as a RelatedArtifact object if defined; else undefined
   */
  public getFixedRelatedArtifact(): RelatedArtifact | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof RelatedArtifact)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected RelatedArtifact but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a RelatedArtifact and has a value; `false` otherwise
   */
  public hasFixedRelatedArtifact(): boolean {
    return this.hasFixed() && this.fixed instanceof RelatedArtifact;
  }

  /**
   * @returns the `fixed` property value as a TriggerDefinition object if defined; else undefined
   */
  public getFixedTriggerDefinition(): TriggerDefinition | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof TriggerDefinition)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected TriggerDefinition but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a TriggerDefinition and has a value; `false` otherwise
   */
  public hasFixedTriggerDefinition(): boolean {
    return this.hasFixed() && this.fixed instanceof TriggerDefinition;
  }

  /**
   * @returns the `fixed` property value as a UsageContext object if defined; else undefined
   */
  public getFixedUsageContext(): UsageContext | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof UsageContext)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected UsageContext but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a UsageContext and has a value; `false` otherwise
   */
  public hasFixedUsageContext(): boolean {
    return this.hasFixed() && this.fixed instanceof UsageContext;
  }

  /**
   * @returns the `fixed` property value as a Availability object if defined; else undefined
   */
  public getFixedAvailability(): Availability | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof Availability)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected Availability but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a Availability and has a value; `false` otherwise
   */
  public hasFixedAvailability(): boolean {
    return this.hasFixed() && this.fixed instanceof Availability;
  }

  /**
   * @returns the `fixed` property value as a ExtendedContactDetail object if defined; else undefined
   */
  public getFixedExtendedContactDetail(): ExtendedContactDetail | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof ExtendedContactDetail)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected ExtendedContactDetail but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a ExtendedContactDetail and has a value; `false` otherwise
   */
  public hasFixedExtendedContactDetail(): boolean {
    return this.hasFixed() && this.fixed instanceof ExtendedContactDetail;
  }

  /**
   * @returns the `fixed` property value as a Dosage object if defined; else undefined
   */
  public getFixedDosage(): Dosage | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof Dosage)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected Dosage but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a Dosage and has a value; `false` otherwise
   */
  public hasFixedDosage(): boolean {
    return this.hasFixed() && this.fixed instanceof Dosage;
  }

  /**
   * @returns the `fixed` property value as a Meta object if defined; else undefined
   */
  public getFixedMeta(): Meta | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof Meta)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected Meta but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a Meta and has a value; `false` otherwise
   */
  public hasFixedMeta(): boolean {
    return this.hasFixed() && this.fixed instanceof Meta;
  }

  // End of choice datatype-specific "get"/"has" methods

  /**
   * @returns the `pattern` property value as a DataType object if defined; else undefined
   */
  public getPattern(): IDataType | undefined {
    return this.pattern;
  }

  /**
   * Assigns the provided DataType object value to the `pattern` property.
   *
   * @decorator `@ChoiceDataTypes('ElementDefinition.pattern[x]')`
   *
   * @param value - the `pattern` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  @ChoiceDataTypes('ElementDefinition.pattern[x]')
  public setPattern(value: IDataType | undefined): this {
    if (isDefined<IDataType>(value)) {
      // assertFhirType<IDataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.pattern = value;
    } else {
      this.pattern = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `pattern` property exists and has a value; `false` otherwise
   */
  public hasPattern(): boolean {
    return isDefined<IDataType>(this.pattern) && !this.pattern.isEmpty();
  }

  // *** NOTE ***
  // Following choice datatype-specific "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the `pattern` property value as a Base64BinaryType object if defined; else undefined
   */
  public getPatternBase64BinaryType(): Base64BinaryType | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof Base64BinaryType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected Base64BinaryType but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a Base64BinaryType and has a value; `false` otherwise
   */
  public hasPatternBase64BinaryType(): boolean {
    return this.hasPattern() && this.pattern instanceof Base64BinaryType;
  }

  /**
   * @returns the `pattern` property value as a BooleanType object if defined; else undefined
   */
  public getPatternBooleanType(): BooleanType | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof BooleanType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected BooleanType but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a BooleanType and has a value; `false` otherwise
   */
  public hasPatternBooleanType(): boolean {
    return this.hasPattern() && this.pattern instanceof BooleanType;
  }

  /**
   * @returns the `pattern` property value as a CanonicalType object if defined; else undefined
   */
  public getPatternCanonicalType(): CanonicalType | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof CanonicalType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected CanonicalType but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a CanonicalType and has a value; `false` otherwise
   */
  public hasPatternCanonicalType(): boolean {
    return this.hasPattern() && this.pattern instanceof CanonicalType;
  }

  /**
   * @returns the `pattern` property value as a CodeType object if defined; else undefined
   */
  public getPatternCodeType(): CodeType | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof CodeType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected CodeType but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a CodeType and has a value; `false` otherwise
   */
  public hasPatternCodeType(): boolean {
    return this.hasPattern() && this.pattern instanceof CodeType;
  }

  /**
   * @returns the `pattern` property value as a DateType object if defined; else undefined
   */
  public getPatternDateType(): DateType | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof DateType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected DateType but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a DateType and has a value; `false` otherwise
   */
  public hasPatternDateType(): boolean {
    return this.hasPattern() && this.pattern instanceof DateType;
  }

  /**
   * @returns the `pattern` property value as a DateTimeType object if defined; else undefined
   */
  public getPatternDateTimeType(): DateTimeType | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof DateTimeType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected DateTimeType but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a DateTimeType and has a value; `false` otherwise
   */
  public hasPatternDateTimeType(): boolean {
    return this.hasPattern() && this.pattern instanceof DateTimeType;
  }

  /**
   * @returns the `pattern` property value as a DecimalType object if defined; else undefined
   */
  public getPatternDecimalType(): DecimalType | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof DecimalType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected DecimalType but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a DecimalType and has a value; `false` otherwise
   */
  public hasPatternDecimalType(): boolean {
    return this.hasPattern() && this.pattern instanceof DecimalType;
  }

  /**
   * @returns the `pattern` property value as a IdType object if defined; else undefined
   */
  public getPatternIdType(): IdType | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof IdType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected IdType but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a IdType and has a value; `false` otherwise
   */
  public hasPatternIdType(): boolean {
    return this.hasPattern() && this.pattern instanceof IdType;
  }

  /**
   * @returns the `pattern` property value as a InstantType object if defined; else undefined
   */
  public getPatternInstantType(): InstantType | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof InstantType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected InstantType but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a InstantType and has a value; `false` otherwise
   */
  public hasPatternInstantType(): boolean {
    return this.hasPattern() && this.pattern instanceof InstantType;
  }

  /**
   * @returns the `pattern` property value as a IntegerType object if defined; else undefined
   */
  public getPatternIntegerType(): IntegerType | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof IntegerType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected IntegerType but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a IntegerType and has a value; `false` otherwise
   */
  public hasPatternIntegerType(): boolean {
    return this.hasPattern() && this.pattern instanceof IntegerType;
  }

  /**
   * @returns the `pattern` property value as a Integer64Type object if defined; else undefined
   */
  public getPatternInteger64Type(): Integer64Type | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof Integer64Type)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected Integer64Type but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a Integer64Type and has a value; `false` otherwise
   */
  public hasPatternInteger64Type(): boolean {
    return this.hasPattern() && this.pattern instanceof Integer64Type;
  }

  /**
   * @returns the `pattern` property value as a MarkdownType object if defined; else undefined
   */
  public getPatternMarkdownType(): MarkdownType | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof MarkdownType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected MarkdownType but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a MarkdownType and has a value; `false` otherwise
   */
  public hasPatternMarkdownType(): boolean {
    return this.hasPattern() && this.pattern instanceof MarkdownType;
  }

  /**
   * @returns the `pattern` property value as a OidType object if defined; else undefined
   */
  public getPatternOidType(): OidType | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof OidType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected OidType but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a OidType and has a value; `false` otherwise
   */
  public hasPatternOidType(): boolean {
    return this.hasPattern() && this.pattern instanceof OidType;
  }

  /**
   * @returns the `pattern` property value as a PositiveIntType object if defined; else undefined
   */
  public getPatternPositiveIntType(): PositiveIntType | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof PositiveIntType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected PositiveIntType but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a PositiveIntType and has a value; `false` otherwise
   */
  public hasPatternPositiveIntType(): boolean {
    return this.hasPattern() && this.pattern instanceof PositiveIntType;
  }

  /**
   * @returns the `pattern` property value as a StringType object if defined; else undefined
   */
  public getPatternStringType(): StringType | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof StringType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected StringType but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a StringType and has a value; `false` otherwise
   */
  public hasPatternStringType(): boolean {
    return this.hasPattern() && this.pattern instanceof StringType;
  }

  /**
   * @returns the `pattern` property value as a TimeType object if defined; else undefined
   */
  public getPatternTimeType(): TimeType | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof TimeType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected TimeType but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a TimeType and has a value; `false` otherwise
   */
  public hasPatternTimeType(): boolean {
    return this.hasPattern() && this.pattern instanceof TimeType;
  }

  /**
   * @returns the `pattern` property value as a UnsignedIntType object if defined; else undefined
   */
  public getPatternUnsignedIntType(): UnsignedIntType | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof UnsignedIntType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected UnsignedIntType but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a UnsignedIntType and has a value; `false` otherwise
   */
  public hasPatternUnsignedIntType(): boolean {
    return this.hasPattern() && this.pattern instanceof UnsignedIntType;
  }

  /**
   * @returns the `pattern` property value as a UriType object if defined; else undefined
   */
  public getPatternUriType(): UriType | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof UriType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected UriType but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a UriType and has a value; `false` otherwise
   */
  public hasPatternUriType(): boolean {
    return this.hasPattern() && this.pattern instanceof UriType;
  }

  /**
   * @returns the `pattern` property value as a UrlType object if defined; else undefined
   */
  public getPatternUrlType(): UrlType | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof UrlType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected UrlType but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a UrlType and has a value; `false` otherwise
   */
  public hasPatternUrlType(): boolean {
    return this.hasPattern() && this.pattern instanceof UrlType;
  }

  /**
   * @returns the `pattern` property value as a UuidType object if defined; else undefined
   */
  public getPatternUuidType(): UuidType | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof UuidType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected UuidType but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a UuidType and has a value; `false` otherwise
   */
  public hasPatternUuidType(): boolean {
    return this.hasPattern() && this.pattern instanceof UuidType;
  }

  /**
   * @returns the `pattern` property value as a Address object if defined; else undefined
   */
  public getPatternAddress(): Address | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof Address)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected Address but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a Address and has a value; `false` otherwise
   */
  public hasPatternAddress(): boolean {
    return this.hasPattern() && this.pattern instanceof Address;
  }

  /**
   * @returns the `pattern` property value as a Age object if defined; else undefined
   */
  public getPatternAge(): Age | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof Age)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected Age but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a Age and has a value; `false` otherwise
   */
  public hasPatternAge(): boolean {
    return this.hasPattern() && this.pattern instanceof Age;
  }

  /**
   * @returns the `pattern` property value as a Annotation object if defined; else undefined
   */
  public getPatternAnnotation(): Annotation | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof Annotation)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected Annotation but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a Annotation and has a value; `false` otherwise
   */
  public hasPatternAnnotation(): boolean {
    return this.hasPattern() && this.pattern instanceof Annotation;
  }

  /**
   * @returns the `pattern` property value as a Attachment object if defined; else undefined
   */
  public getPatternAttachment(): Attachment | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof Attachment)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected Attachment but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a Attachment and has a value; `false` otherwise
   */
  public hasPatternAttachment(): boolean {
    return this.hasPattern() && this.pattern instanceof Attachment;
  }

  /**
   * @returns the `pattern` property value as a CodeableConcept object if defined; else undefined
   */
  public getPatternCodeableConcept(): CodeableConcept | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof CodeableConcept)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected CodeableConcept but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a CodeableConcept and has a value; `false` otherwise
   */
  public hasPatternCodeableConcept(): boolean {
    return this.hasPattern() && this.pattern instanceof CodeableConcept;
  }

  /**
   * @returns the `pattern` property value as a CodeableReference object if defined; else undefined
   */
  public getPatternCodeableReference(): CodeableReference | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof CodeableReference)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected CodeableReference but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a CodeableReference and has a value; `false` otherwise
   */
  public hasPatternCodeableReference(): boolean {
    return this.hasPattern() && this.pattern instanceof CodeableReference;
  }

  /**
   * @returns the `pattern` property value as a Coding object if defined; else undefined
   */
  public getPatternCoding(): Coding | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof Coding)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected Coding but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a Coding and has a value; `false` otherwise
   */
  public hasPatternCoding(): boolean {
    return this.hasPattern() && this.pattern instanceof Coding;
  }

  /**
   * @returns the `pattern` property value as a ContactPoint object if defined; else undefined
   */
  public getPatternContactPoint(): ContactPoint | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof ContactPoint)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected ContactPoint but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a ContactPoint and has a value; `false` otherwise
   */
  public hasPatternContactPoint(): boolean {
    return this.hasPattern() && this.pattern instanceof ContactPoint;
  }

  /**
   * @returns the `pattern` property value as a Count object if defined; else undefined
   */
  public getPatternCount(): Count | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof Count)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected Count but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a Count and has a value; `false` otherwise
   */
  public hasPatternCount(): boolean {
    return this.hasPattern() && this.pattern instanceof Count;
  }

  /**
   * @returns the `pattern` property value as a Distance object if defined; else undefined
   */
  public getPatternDistance(): Distance | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof Distance)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected Distance but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a Distance and has a value; `false` otherwise
   */
  public hasPatternDistance(): boolean {
    return this.hasPattern() && this.pattern instanceof Distance;
  }

  /**
   * @returns the `pattern` property value as a Duration object if defined; else undefined
   */
  public getPatternDuration(): Duration | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof Duration)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected Duration but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a Duration and has a value; `false` otherwise
   */
  public hasPatternDuration(): boolean {
    return this.hasPattern() && this.pattern instanceof Duration;
  }

  /**
   * @returns the `pattern` property value as a HumanName object if defined; else undefined
   */
  public getPatternHumanName(): HumanName | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof HumanName)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected HumanName but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a HumanName and has a value; `false` otherwise
   */
  public hasPatternHumanName(): boolean {
    return this.hasPattern() && this.pattern instanceof HumanName;
  }

  /**
   * @returns the `pattern` property value as a Identifier object if defined; else undefined
   */
  public getPatternIdentifier(): Identifier | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof Identifier)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected Identifier but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a Identifier and has a value; `false` otherwise
   */
  public hasPatternIdentifier(): boolean {
    return this.hasPattern() && this.pattern instanceof Identifier;
  }

  /**
   * @returns the `pattern` property value as a Money object if defined; else undefined
   */
  public getPatternMoney(): Money | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof Money)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected Money but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a Money and has a value; `false` otherwise
   */
  public hasPatternMoney(): boolean {
    return this.hasPattern() && this.pattern instanceof Money;
  }

  /**
   * @returns the `pattern` property value as a Period object if defined; else undefined
   */
  public getPatternPeriod(): Period | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof Period)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected Period but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a Period and has a value; `false` otherwise
   */
  public hasPatternPeriod(): boolean {
    return this.hasPattern() && this.pattern instanceof Period;
  }

  /**
   * @returns the `pattern` property value as a Quantity object if defined; else undefined
   */
  public getPatternQuantity(): Quantity | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof Quantity)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected Quantity but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a Quantity and has a value; `false` otherwise
   */
  public hasPatternQuantity(): boolean {
    return this.hasPattern() && this.pattern instanceof Quantity;
  }

  /**
   * @returns the `pattern` property value as a Range object if defined; else undefined
   */
  public getPatternRange(): Range | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof Range)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected Range but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a Range and has a value; `false` otherwise
   */
  public hasPatternRange(): boolean {
    return this.hasPattern() && this.pattern instanceof Range;
  }

  /**
   * @returns the `pattern` property value as a Ratio object if defined; else undefined
   */
  public getPatternRatio(): Ratio | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof Ratio)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected Ratio but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a Ratio and has a value; `false` otherwise
   */
  public hasPatternRatio(): boolean {
    return this.hasPattern() && this.pattern instanceof Ratio;
  }

  /**
   * @returns the `pattern` property value as a RatioRange object if defined; else undefined
   */
  public getPatternRatioRange(): RatioRange | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof RatioRange)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected RatioRange but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a RatioRange and has a value; `false` otherwise
   */
  public hasPatternRatioRange(): boolean {
    return this.hasPattern() && this.pattern instanceof RatioRange;
  }

  /**
   * @returns the `pattern` property value as a Reference object if defined; else undefined
   */
  public getPatternReference(): Reference | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof Reference)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected Reference but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a Reference and has a value; `false` otherwise
   */
  public hasPatternReference(): boolean {
    return this.hasPattern() && this.pattern instanceof Reference;
  }

  /**
   * @returns the `pattern` property value as a SampledData object if defined; else undefined
   */
  public getPatternSampledData(): SampledData | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof SampledData)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected SampledData but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a SampledData and has a value; `false` otherwise
   */
  public hasPatternSampledData(): boolean {
    return this.hasPattern() && this.pattern instanceof SampledData;
  }

  /**
   * @returns the `pattern` property value as a Signature object if defined; else undefined
   */
  public getPatternSignature(): Signature | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof Signature)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected Signature but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a Signature and has a value; `false` otherwise
   */
  public hasPatternSignature(): boolean {
    return this.hasPattern() && this.pattern instanceof Signature;
  }

  /**
   * @returns the `pattern` property value as a Timing object if defined; else undefined
   */
  public getPatternTiming(): Timing | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof Timing)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected Timing but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a Timing and has a value; `false` otherwise
   */
  public hasPatternTiming(): boolean {
    return this.hasPattern() && this.pattern instanceof Timing;
  }

  /**
   * @returns the `pattern` property value as a ContactDetail object if defined; else undefined
   */
  public getPatternContactDetail(): ContactDetail | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof ContactDetail)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected ContactDetail but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a ContactDetail and has a value; `false` otherwise
   */
  public hasPatternContactDetail(): boolean {
    return this.hasPattern() && this.pattern instanceof ContactDetail;
  }

  /**
   * @returns the `pattern` property value as a DataRequirement object if defined; else undefined
   */
  public getPatternDataRequirement(): DataRequirement | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof DataRequirement)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected DataRequirement but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a DataRequirement and has a value; `false` otherwise
   */
  public hasPatternDataRequirement(): boolean {
    return this.hasPattern() && this.pattern instanceof DataRequirement;
  }

  /**
   * @returns the `pattern` property value as a Expression object if defined; else undefined
   */
  public getPatternExpression(): Expression | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof Expression)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected Expression but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a Expression and has a value; `false` otherwise
   */
  public hasPatternExpression(): boolean {
    return this.hasPattern() && this.pattern instanceof Expression;
  }

  /**
   * @returns the `pattern` property value as a ParameterDefinition object if defined; else undefined
   */
  public getPatternParameterDefinition(): ParameterDefinition | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof ParameterDefinition)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected ParameterDefinition but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a ParameterDefinition and has a value; `false` otherwise
   */
  public hasPatternParameterDefinition(): boolean {
    return this.hasPattern() && this.pattern instanceof ParameterDefinition;
  }

  /**
   * @returns the `pattern` property value as a RelatedArtifact object if defined; else undefined
   */
  public getPatternRelatedArtifact(): RelatedArtifact | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof RelatedArtifact)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected RelatedArtifact but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a RelatedArtifact and has a value; `false` otherwise
   */
  public hasPatternRelatedArtifact(): boolean {
    return this.hasPattern() && this.pattern instanceof RelatedArtifact;
  }

  /**
   * @returns the `pattern` property value as a TriggerDefinition object if defined; else undefined
   */
  public getPatternTriggerDefinition(): TriggerDefinition | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof TriggerDefinition)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected TriggerDefinition but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a TriggerDefinition and has a value; `false` otherwise
   */
  public hasPatternTriggerDefinition(): boolean {
    return this.hasPattern() && this.pattern instanceof TriggerDefinition;
  }

  /**
   * @returns the `pattern` property value as a UsageContext object if defined; else undefined
   */
  public getPatternUsageContext(): UsageContext | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof UsageContext)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected UsageContext but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a UsageContext and has a value; `false` otherwise
   */
  public hasPatternUsageContext(): boolean {
    return this.hasPattern() && this.pattern instanceof UsageContext;
  }

  /**
   * @returns the `pattern` property value as a Availability object if defined; else undefined
   */
  public getPatternAvailability(): Availability | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof Availability)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected Availability but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a Availability and has a value; `false` otherwise
   */
  public hasPatternAvailability(): boolean {
    return this.hasPattern() && this.pattern instanceof Availability;
  }

  /**
   * @returns the `pattern` property value as a ExtendedContactDetail object if defined; else undefined
   */
  public getPatternExtendedContactDetail(): ExtendedContactDetail | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof ExtendedContactDetail)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected ExtendedContactDetail but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a ExtendedContactDetail and has a value; `false` otherwise
   */
  public hasPatternExtendedContactDetail(): boolean {
    return this.hasPattern() && this.pattern instanceof ExtendedContactDetail;
  }

  /**
   * @returns the `pattern` property value as a Dosage object if defined; else undefined
   */
  public getPatternDosage(): Dosage | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof Dosage)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected Dosage but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a Dosage and has a value; `false` otherwise
   */
  public hasPatternDosage(): boolean {
    return this.hasPattern() && this.pattern instanceof Dosage;
  }

  /**
   * @returns the `pattern` property value as a Meta object if defined; else undefined
   */
  public getPatternMeta(): Meta | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof Meta)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected Meta but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a Meta and has a value; `false` otherwise
   */
  public hasPatternMeta(): boolean {
    return this.hasPattern() && this.pattern instanceof Meta;
  }

  // End of choice datatype-specific "get"/"has" methods

  /**
   * @returns the `example` property value as a ElementDefinitionExampleComponent array
   */
  public getExample(): ElementDefinitionExampleComponent[] {
    return this.example ?? ([] as ElementDefinitionExampleComponent[]);
  }

  /**
   * Assigns the provided ElementDefinitionExampleComponent array value to the `example` property.
   *
   * @param value - the `example` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setExample(value: ElementDefinitionExampleComponent[] | undefined): this {
    if (isDefinedList<ElementDefinitionExampleComponent>(value)) {
      const optErrMsg = `Invalid ElementDefinition.example; Provided value array has an element that is not an instance of ElementDefinitionExampleComponent.`;
      assertFhirTypeList<ElementDefinitionExampleComponent>(value, ElementDefinitionExampleComponent, optErrMsg);
      this.example = value;
    } else {
      this.example = undefined;
    }
    return this;
  }

  /**
   * Add the provided ElementDefinitionExampleComponent value to the `example` array property.
   *
   * @param value - the `example` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addExample(value: ElementDefinitionExampleComponent | undefined): this {
    if (isDefined<ElementDefinitionExampleComponent>(value)) {
      const optErrMsg = `Invalid ElementDefinition.example; Provided element is not an instance of ElementDefinitionExampleComponent.`;
      assertFhirType<ElementDefinitionExampleComponent>(value, ElementDefinitionExampleComponent, optErrMsg);
      this.initExample();
      this.example?.push(value);
    }
    return this;
  }

  /**
   * @returns `true` if the `example` property exists and has a value; `false` otherwise
   */
  public hasExample(): boolean {
    return isDefinedList<ElementDefinitionExampleComponent>(this.example) && this.example.some((item: ElementDefinitionExampleComponent) => !item.isEmpty());
  }

  /**
   * Initialize the `example` property
   */
  private initExample(): void {
    if(!this.hasExample()) {
      this.example = [] as ElementDefinitionExampleComponent[];
    }
  }

  /**
   * @returns the `minValue` property value as a DataType object if defined; else undefined
   */
  public getMinValue(): IDataType | undefined {
    return this.minValue;
  }

  /**
   * Assigns the provided DataType object value to the `minValue` property.
   *
   * @decorator `@ChoiceDataTypes('ElementDefinition.minValue[x]')`
   *
   * @param value - the `minValue` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  @ChoiceDataTypes('ElementDefinition.minValue[x]')
  public setMinValue(value: IDataType | undefined): this {
    if (isDefined<IDataType>(value)) {
      // assertFhirType<IDataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.minValue = value;
    } else {
      this.minValue = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `minValue` property exists and has a value; `false` otherwise
   */
  public hasMinValue(): boolean {
    return isDefined<IDataType>(this.minValue) && !this.minValue.isEmpty();
  }

  // *** NOTE ***
  // Following choice datatype-specific "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the `minValue` property value as a DateType object if defined; else undefined
   */
  public getMinValueDateType(): DateType | undefined {
    if (!isDefined<IDataType | undefined>(this.minValue)) {
      return undefined;
    }
    if (!(this.minValue instanceof DateType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.minValue[x]: Expected DateType but encountered ${this.minValue.fhirType()}`,
      );
    }
    return this.minValue;
  }

  /**
   * @returns `true` if the `minValue` property exists as a DateType and has a value; `false` otherwise
   */
  public hasMinValueDateType(): boolean {
    return this.hasMinValue() && this.minValue instanceof DateType;
  }

  /**
   * @returns the `minValue` property value as a DateTimeType object if defined; else undefined
   */
  public getMinValueDateTimeType(): DateTimeType | undefined {
    if (!isDefined<IDataType | undefined>(this.minValue)) {
      return undefined;
    }
    if (!(this.minValue instanceof DateTimeType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.minValue[x]: Expected DateTimeType but encountered ${this.minValue.fhirType()}`,
      );
    }
    return this.minValue;
  }

  /**
   * @returns `true` if the `minValue` property exists as a DateTimeType and has a value; `false` otherwise
   */
  public hasMinValueDateTimeType(): boolean {
    return this.hasMinValue() && this.minValue instanceof DateTimeType;
  }

  /**
   * @returns the `minValue` property value as a InstantType object if defined; else undefined
   */
  public getMinValueInstantType(): InstantType | undefined {
    if (!isDefined<IDataType | undefined>(this.minValue)) {
      return undefined;
    }
    if (!(this.minValue instanceof InstantType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.minValue[x]: Expected InstantType but encountered ${this.minValue.fhirType()}`,
      );
    }
    return this.minValue;
  }

  /**
   * @returns `true` if the `minValue` property exists as a InstantType and has a value; `false` otherwise
   */
  public hasMinValueInstantType(): boolean {
    return this.hasMinValue() && this.minValue instanceof InstantType;
  }

  /**
   * @returns the `minValue` property value as a TimeType object if defined; else undefined
   */
  public getMinValueTimeType(): TimeType | undefined {
    if (!isDefined<IDataType | undefined>(this.minValue)) {
      return undefined;
    }
    if (!(this.minValue instanceof TimeType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.minValue[x]: Expected TimeType but encountered ${this.minValue.fhirType()}`,
      );
    }
    return this.minValue;
  }

  /**
   * @returns `true` if the `minValue` property exists as a TimeType and has a value; `false` otherwise
   */
  public hasMinValueTimeType(): boolean {
    return this.hasMinValue() && this.minValue instanceof TimeType;
  }

  /**
   * @returns the `minValue` property value as a DecimalType object if defined; else undefined
   */
  public getMinValueDecimalType(): DecimalType | undefined {
    if (!isDefined<IDataType | undefined>(this.minValue)) {
      return undefined;
    }
    if (!(this.minValue instanceof DecimalType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.minValue[x]: Expected DecimalType but encountered ${this.minValue.fhirType()}`,
      );
    }
    return this.minValue;
  }

  /**
   * @returns `true` if the `minValue` property exists as a DecimalType and has a value; `false` otherwise
   */
  public hasMinValueDecimalType(): boolean {
    return this.hasMinValue() && this.minValue instanceof DecimalType;
  }

  /**
   * @returns the `minValue` property value as a IntegerType object if defined; else undefined
   */
  public getMinValueIntegerType(): IntegerType | undefined {
    if (!isDefined<IDataType | undefined>(this.minValue)) {
      return undefined;
    }
    if (!(this.minValue instanceof IntegerType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.minValue[x]: Expected IntegerType but encountered ${this.minValue.fhirType()}`,
      );
    }
    return this.minValue;
  }

  /**
   * @returns `true` if the `minValue` property exists as a IntegerType and has a value; `false` otherwise
   */
  public hasMinValueIntegerType(): boolean {
    return this.hasMinValue() && this.minValue instanceof IntegerType;
  }

  /**
   * @returns the `minValue` property value as a Integer64Type object if defined; else undefined
   */
  public getMinValueInteger64Type(): Integer64Type | undefined {
    if (!isDefined<IDataType | undefined>(this.minValue)) {
      return undefined;
    }
    if (!(this.minValue instanceof Integer64Type)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.minValue[x]: Expected Integer64Type but encountered ${this.minValue.fhirType()}`,
      );
    }
    return this.minValue;
  }

  /**
   * @returns `true` if the `minValue` property exists as a Integer64Type and has a value; `false` otherwise
   */
  public hasMinValueInteger64Type(): boolean {
    return this.hasMinValue() && this.minValue instanceof Integer64Type;
  }

  /**
   * @returns the `minValue` property value as a PositiveIntType object if defined; else undefined
   */
  public getMinValuePositiveIntType(): PositiveIntType | undefined {
    if (!isDefined<IDataType | undefined>(this.minValue)) {
      return undefined;
    }
    if (!(this.minValue instanceof PositiveIntType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.minValue[x]: Expected PositiveIntType but encountered ${this.minValue.fhirType()}`,
      );
    }
    return this.minValue;
  }

  /**
   * @returns `true` if the `minValue` property exists as a PositiveIntType and has a value; `false` otherwise
   */
  public hasMinValuePositiveIntType(): boolean {
    return this.hasMinValue() && this.minValue instanceof PositiveIntType;
  }

  /**
   * @returns the `minValue` property value as a UnsignedIntType object if defined; else undefined
   */
  public getMinValueUnsignedIntType(): UnsignedIntType | undefined {
    if (!isDefined<IDataType | undefined>(this.minValue)) {
      return undefined;
    }
    if (!(this.minValue instanceof UnsignedIntType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.minValue[x]: Expected UnsignedIntType but encountered ${this.minValue.fhirType()}`,
      );
    }
    return this.minValue;
  }

  /**
   * @returns `true` if the `minValue` property exists as a UnsignedIntType and has a value; `false` otherwise
   */
  public hasMinValueUnsignedIntType(): boolean {
    return this.hasMinValue() && this.minValue instanceof UnsignedIntType;
  }

  /**
   * @returns the `minValue` property value as a Quantity object if defined; else undefined
   */
  public getMinValueQuantity(): Quantity | undefined {
    if (!isDefined<IDataType | undefined>(this.minValue)) {
      return undefined;
    }
    if (!(this.minValue instanceof Quantity)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.minValue[x]: Expected Quantity but encountered ${this.minValue.fhirType()}`,
      );
    }
    return this.minValue;
  }

  /**
   * @returns `true` if the `minValue` property exists as a Quantity and has a value; `false` otherwise
   */
  public hasMinValueQuantity(): boolean {
    return this.hasMinValue() && this.minValue instanceof Quantity;
  }

  // End of choice datatype-specific "get"/"has" methods

  /**
   * @returns the `maxValue` property value as a DataType object if defined; else undefined
   */
  public getMaxValue(): IDataType | undefined {
    return this.maxValue;
  }

  /**
   * Assigns the provided DataType object value to the `maxValue` property.
   *
   * @decorator `@ChoiceDataTypes('ElementDefinition.maxValue[x]')`
   *
   * @param value - the `maxValue` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  @ChoiceDataTypes('ElementDefinition.maxValue[x]')
  public setMaxValue(value: IDataType | undefined): this {
    if (isDefined<IDataType>(value)) {
      // assertFhirType<IDataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.maxValue = value;
    } else {
      this.maxValue = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `maxValue` property exists and has a value; `false` otherwise
   */
  public hasMaxValue(): boolean {
    return isDefined<IDataType>(this.maxValue) && !this.maxValue.isEmpty();
  }

  // *** NOTE ***
  // Following choice datatype-specific "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the `maxValue` property value as a DateType object if defined; else undefined
   */
  public getMaxValueDateType(): DateType | undefined {
    if (!isDefined<IDataType | undefined>(this.maxValue)) {
      return undefined;
    }
    if (!(this.maxValue instanceof DateType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.maxValue[x]: Expected DateType but encountered ${this.maxValue.fhirType()}`,
      );
    }
    return this.maxValue;
  }

  /**
   * @returns `true` if the `maxValue` property exists as a DateType and has a value; `false` otherwise
   */
  public hasMaxValueDateType(): boolean {
    return this.hasMaxValue() && this.maxValue instanceof DateType;
  }

  /**
   * @returns the `maxValue` property value as a DateTimeType object if defined; else undefined
   */
  public getMaxValueDateTimeType(): DateTimeType | undefined {
    if (!isDefined<IDataType | undefined>(this.maxValue)) {
      return undefined;
    }
    if (!(this.maxValue instanceof DateTimeType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.maxValue[x]: Expected DateTimeType but encountered ${this.maxValue.fhirType()}`,
      );
    }
    return this.maxValue;
  }

  /**
   * @returns `true` if the `maxValue` property exists as a DateTimeType and has a value; `false` otherwise
   */
  public hasMaxValueDateTimeType(): boolean {
    return this.hasMaxValue() && this.maxValue instanceof DateTimeType;
  }

  /**
   * @returns the `maxValue` property value as a InstantType object if defined; else undefined
   */
  public getMaxValueInstantType(): InstantType | undefined {
    if (!isDefined<IDataType | undefined>(this.maxValue)) {
      return undefined;
    }
    if (!(this.maxValue instanceof InstantType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.maxValue[x]: Expected InstantType but encountered ${this.maxValue.fhirType()}`,
      );
    }
    return this.maxValue;
  }

  /**
   * @returns `true` if the `maxValue` property exists as a InstantType and has a value; `false` otherwise
   */
  public hasMaxValueInstantType(): boolean {
    return this.hasMaxValue() && this.maxValue instanceof InstantType;
  }

  /**
   * @returns the `maxValue` property value as a TimeType object if defined; else undefined
   */
  public getMaxValueTimeType(): TimeType | undefined {
    if (!isDefined<IDataType | undefined>(this.maxValue)) {
      return undefined;
    }
    if (!(this.maxValue instanceof TimeType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.maxValue[x]: Expected TimeType but encountered ${this.maxValue.fhirType()}`,
      );
    }
    return this.maxValue;
  }

  /**
   * @returns `true` if the `maxValue` property exists as a TimeType and has a value; `false` otherwise
   */
  public hasMaxValueTimeType(): boolean {
    return this.hasMaxValue() && this.maxValue instanceof TimeType;
  }

  /**
   * @returns the `maxValue` property value as a DecimalType object if defined; else undefined
   */
  public getMaxValueDecimalType(): DecimalType | undefined {
    if (!isDefined<IDataType | undefined>(this.maxValue)) {
      return undefined;
    }
    if (!(this.maxValue instanceof DecimalType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.maxValue[x]: Expected DecimalType but encountered ${this.maxValue.fhirType()}`,
      );
    }
    return this.maxValue;
  }

  /**
   * @returns `true` if the `maxValue` property exists as a DecimalType and has a value; `false` otherwise
   */
  public hasMaxValueDecimalType(): boolean {
    return this.hasMaxValue() && this.maxValue instanceof DecimalType;
  }

  /**
   * @returns the `maxValue` property value as a IntegerType object if defined; else undefined
   */
  public getMaxValueIntegerType(): IntegerType | undefined {
    if (!isDefined<IDataType | undefined>(this.maxValue)) {
      return undefined;
    }
    if (!(this.maxValue instanceof IntegerType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.maxValue[x]: Expected IntegerType but encountered ${this.maxValue.fhirType()}`,
      );
    }
    return this.maxValue;
  }

  /**
   * @returns `true` if the `maxValue` property exists as a IntegerType and has a value; `false` otherwise
   */
  public hasMaxValueIntegerType(): boolean {
    return this.hasMaxValue() && this.maxValue instanceof IntegerType;
  }

  /**
   * @returns the `maxValue` property value as a Integer64Type object if defined; else undefined
   */
  public getMaxValueInteger64Type(): Integer64Type | undefined {
    if (!isDefined<IDataType | undefined>(this.maxValue)) {
      return undefined;
    }
    if (!(this.maxValue instanceof Integer64Type)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.maxValue[x]: Expected Integer64Type but encountered ${this.maxValue.fhirType()}`,
      );
    }
    return this.maxValue;
  }

  /**
   * @returns `true` if the `maxValue` property exists as a Integer64Type and has a value; `false` otherwise
   */
  public hasMaxValueInteger64Type(): boolean {
    return this.hasMaxValue() && this.maxValue instanceof Integer64Type;
  }

  /**
   * @returns the `maxValue` property value as a PositiveIntType object if defined; else undefined
   */
  public getMaxValuePositiveIntType(): PositiveIntType | undefined {
    if (!isDefined<IDataType | undefined>(this.maxValue)) {
      return undefined;
    }
    if (!(this.maxValue instanceof PositiveIntType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.maxValue[x]: Expected PositiveIntType but encountered ${this.maxValue.fhirType()}`,
      );
    }
    return this.maxValue;
  }

  /**
   * @returns `true` if the `maxValue` property exists as a PositiveIntType and has a value; `false` otherwise
   */
  public hasMaxValuePositiveIntType(): boolean {
    return this.hasMaxValue() && this.maxValue instanceof PositiveIntType;
  }

  /**
   * @returns the `maxValue` property value as a UnsignedIntType object if defined; else undefined
   */
  public getMaxValueUnsignedIntType(): UnsignedIntType | undefined {
    if (!isDefined<IDataType | undefined>(this.maxValue)) {
      return undefined;
    }
    if (!(this.maxValue instanceof UnsignedIntType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.maxValue[x]: Expected UnsignedIntType but encountered ${this.maxValue.fhirType()}`,
      );
    }
    return this.maxValue;
  }

  /**
   * @returns `true` if the `maxValue` property exists as a UnsignedIntType and has a value; `false` otherwise
   */
  public hasMaxValueUnsignedIntType(): boolean {
    return this.hasMaxValue() && this.maxValue instanceof UnsignedIntType;
  }

  /**
   * @returns the `maxValue` property value as a Quantity object if defined; else undefined
   */
  public getMaxValueQuantity(): Quantity | undefined {
    if (!isDefined<IDataType | undefined>(this.maxValue)) {
      return undefined;
    }
    if (!(this.maxValue instanceof Quantity)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.maxValue[x]: Expected Quantity but encountered ${this.maxValue.fhirType()}`,
      );
    }
    return this.maxValue;
  }

  /**
   * @returns `true` if the `maxValue` property exists as a Quantity and has a value; `false` otherwise
   */
  public hasMaxValueQuantity(): boolean {
    return this.hasMaxValue() && this.maxValue instanceof Quantity;
  }

  // End of choice datatype-specific "get"/"has" methods

  /**
   * @returns the `maxLength` property value as a IntegerType object if defined; else an empty IntegerType object
   */
  public getMaxLengthElement(): IntegerType {
    return this.maxLength ?? new IntegerType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `maxLength` property.
   *
   * @param element - the `maxLength` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMaxLengthElement(element: IntegerType | undefined): this {
    if (isDefined<IntegerType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.maxLength; Provided element is not an instance of IntegerType.`;
      assertFhirType<IntegerType>(element, IntegerType, optErrMsg);
      this.maxLength = element;
    } else {
      this.maxLength = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `maxLength` property exists and has a value; `false` otherwise
   */
  public hasMaxLengthElement(): boolean {
    return isDefined<IntegerType>(this.maxLength) && !this.maxLength.isEmpty();
  }

  /**
   * @returns the `maxLength` property value as a fhirInteger if defined; else undefined
   */
  public getMaxLength(): fhirInteger | undefined {
    return this.maxLength?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `maxLength` property.
   *
   * @param value - the `maxLength` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMaxLength(value: fhirInteger | undefined): this {
    if (isDefined<fhirInteger>(value)) {
      const optErrMsg = `Invalid ElementDefinition.maxLength (${String(value)})`;
      this.maxLength = new IntegerType(parseFhirPrimitiveData(value, fhirIntegerSchema, optErrMsg));
    } else {
      this.maxLength = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `maxLength` property exists and has a value; `false` otherwise
   */
  public hasMaxLength(): boolean {
    return this.hasMaxLengthElement();
  }

  /**
   * @returns the `condition` property value as a IdType array
   */
  public getConditionElement(): IdType[] {
    return this.condition ?? ([] as IdType[]);
  }

  /**
   * Assigns the provided IdType array value to the `condition` property.
   *
   * @param element - the `condition` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setConditionElement(element: IdType[] | undefined): this {
    if (isDefinedList<IdType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.condition; Provided value array has an element that is not an instance of IdType.`;
      assertFhirTypeList<IdType>(element, IdType, optErrMsg);
      this.condition = element;
    } else {
      this.condition = undefined;
    }
    return this;
  }

  /**
   * Add the provided IdType value to the `condition` array property.
   *
   * @param element - the `condition` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addConditionElement(element: IdType | undefined): this {
    if (isDefined<IdType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.condition; Provided element is not an instance of IdType.`;
      assertFhirType<IdType>(element, IdType, optErrMsg);
      this.initCondition();
      this.condition?.push(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `condition` property exists and has a value; `false` otherwise
   */
  public hasConditionElement(): boolean {
    return isDefinedList<IdType>(this.condition) && this.condition.some((item: IdType) => !item.isEmpty());
  }

  /**
   * @returns the `condition` property value as a fhirId array
   */
  public getCondition(): fhirId[] {
    this.initCondition();
    const conditionValues = [] as fhirId[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.condition!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        conditionValues.push(value);
      }
    }
    return conditionValues;
  }

  /**
   * Assigns the provided primitive value array to the `condition` property.
   *
   * @param value - the `condition` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCondition(value: fhirId[] | undefined): this {
    if (isDefinedList<fhirId>(value)) {
      const conditionElements = [] as IdType[];
      for (const conditionValue of value) {
        const optErrMsg = `Invalid ElementDefinition.condition array item (${String(conditionValue)})`;
        const element = new IdType(parseFhirPrimitiveData(conditionValue, fhirIdSchema, optErrMsg));
        conditionElements.push(element);
      }
      this.condition = conditionElements;
    } else {
      this.condition = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the `condition` array property.
   *
   * @param value - the `condition` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addCondition(value: fhirId | undefined): this {
    if (isDefined<fhirId>(value)) {
      const optErrMsg = `Invalid ElementDefinition.condition array item (${String(value)})`;
      const element = new IdType(parseFhirPrimitiveData(value, fhirIdSchema, optErrMsg));
      this.initCondition();
      this.addConditionElement(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `condition` property exists and has a value; `false` otherwise
   */
  public hasCondition(): boolean {
    return this.hasConditionElement();
  }

  /**
   * Initialize the `condition` property
   */
  private initCondition(): void {
    if (!this.hasCondition()) {
      this.condition = [] as IdType[];
    }
  }

  /**
   * @returns the `constraint` property value as a ElementDefinitionConstraintComponent array
   */
  public getConstraint(): ElementDefinitionConstraintComponent[] {
    return this.constraint ?? ([] as ElementDefinitionConstraintComponent[]);
  }

  /**
   * Assigns the provided ElementDefinitionConstraintComponent array value to the `constraint` property.
   *
   * @param value - the `constraint` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setConstraint(value: ElementDefinitionConstraintComponent[] | undefined): this {
    if (isDefinedList<ElementDefinitionConstraintComponent>(value)) {
      const optErrMsg = `Invalid ElementDefinition.constraint; Provided value array has an element that is not an instance of ElementDefinitionConstraintComponent.`;
      assertFhirTypeList<ElementDefinitionConstraintComponent>(value, ElementDefinitionConstraintComponent, optErrMsg);
      this.constraint = value;
    } else {
      this.constraint = undefined;
    }
    return this;
  }

  /**
   * Add the provided ElementDefinitionConstraintComponent value to the `constraint` array property.
   *
   * @param value - the `constraint` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addConstraint(value: ElementDefinitionConstraintComponent | undefined): this {
    if (isDefined<ElementDefinitionConstraintComponent>(value)) {
      const optErrMsg = `Invalid ElementDefinition.constraint; Provided element is not an instance of ElementDefinitionConstraintComponent.`;
      assertFhirType<ElementDefinitionConstraintComponent>(value, ElementDefinitionConstraintComponent, optErrMsg);
      this.initConstraint();
      this.constraint?.push(value);
    }
    return this;
  }

  /**
   * @returns `true` if the `constraint` property exists and has a value; `false` otherwise
   */
  public hasConstraint(): boolean {
    return isDefinedList<ElementDefinitionConstraintComponent>(this.constraint) && this.constraint.some((item: ElementDefinitionConstraintComponent) => !item.isEmpty());
  }

  /**
   * Initialize the `constraint` property
   */
  private initConstraint(): void {
    if(!this.hasConstraint()) {
      this.constraint = [] as ElementDefinitionConstraintComponent[];
    }
  }

  /**
   * @returns the `mustHaveValue` property value as a BooleanType object if defined; else an empty BooleanType object
   */
  public getMustHaveValueElement(): BooleanType {
    return this.mustHaveValue ?? new BooleanType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `mustHaveValue` property.
   *
   * @param element - the `mustHaveValue` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMustHaveValueElement(element: BooleanType | undefined): this {
    if (isDefined<BooleanType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.mustHaveValue; Provided element is not an instance of BooleanType.`;
      assertFhirType<BooleanType>(element, BooleanType, optErrMsg);
      this.mustHaveValue = element;
    } else {
      this.mustHaveValue = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `mustHaveValue` property exists and has a value; `false` otherwise
   */
  public hasMustHaveValueElement(): boolean {
    return isDefined<BooleanType>(this.mustHaveValue) && !this.mustHaveValue.isEmpty();
  }

  /**
   * @returns the `mustHaveValue` property value as a fhirBoolean if defined; else undefined
   */
  public getMustHaveValue(): fhirBoolean | undefined {
    return this.mustHaveValue?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `mustHaveValue` property.
   *
   * @param value - the `mustHaveValue` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMustHaveValue(value: fhirBoolean | undefined): this {
    if (isDefined<fhirBoolean>(value)) {
      const optErrMsg = `Invalid ElementDefinition.mustHaveValue (${String(value)})`;
      this.mustHaveValue = new BooleanType(parseFhirPrimitiveData(value, fhirBooleanSchema, optErrMsg));
    } else {
      this.mustHaveValue = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `mustHaveValue` property exists and has a value; `false` otherwise
   */
  public hasMustHaveValue(): boolean {
    return this.hasMustHaveValueElement();
  }

  /**
   * @returns the `valueAlternatives` property value as a CanonicalType array
   */
  public getValueAlternativesElement(): CanonicalType[] {
    return this.valueAlternatives ?? ([] as CanonicalType[]);
  }

  /**
   * Assigns the provided CanonicalType array value to the `valueAlternatives` property.
   *
   * @param element - the `valueAlternatives` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValueAlternativesElement(element: CanonicalType[] | undefined): this {
    if (isDefinedList<CanonicalType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.valueAlternatives; Provided value array has an element that is not an instance of CanonicalType.`;
      assertFhirTypeList<CanonicalType>(element, CanonicalType, optErrMsg);
      this.valueAlternatives = element;
    } else {
      this.valueAlternatives = undefined;
    }
    return this;
  }

  /**
   * Add the provided CanonicalType value to the `valueAlternatives` array property.
   *
   * @param element - the `valueAlternatives` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addValueAlternativesElement(element: CanonicalType | undefined): this {
    if (isDefined<CanonicalType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.valueAlternatives; Provided element is not an instance of CanonicalType.`;
      assertFhirType<CanonicalType>(element, CanonicalType, optErrMsg);
      this.initValueAlternatives();
      this.valueAlternatives?.push(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `valueAlternatives` property exists and has a value; `false` otherwise
   */
  public hasValueAlternativesElement(): boolean {
    return isDefinedList<CanonicalType>(this.valueAlternatives) && this.valueAlternatives.some((item: CanonicalType) => !item.isEmpty());
  }

  /**
   * @returns the `valueAlternatives` property value as a fhirCanonical array
   */
  public getValueAlternatives(): fhirCanonical[] {
    this.initValueAlternatives();
    const valueAlternativesValues = [] as fhirCanonical[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.valueAlternatives!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        valueAlternativesValues.push(value);
      }
    }
    return valueAlternativesValues;
  }

  /**
   * Assigns the provided primitive value array to the `valueAlternatives` property.
   *
   * @param value - the `valueAlternatives` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValueAlternatives(value: fhirCanonical[] | undefined): this {
    if (isDefinedList<fhirCanonical>(value)) {
      const valueAlternativesElements = [] as CanonicalType[];
      for (const valueAlternativesValue of value) {
        const optErrMsg = `Invalid ElementDefinition.valueAlternatives array item (${String(valueAlternativesValue)})`;
        const element = new CanonicalType(parseFhirPrimitiveData(valueAlternativesValue, fhirCanonicalSchema, optErrMsg));
        valueAlternativesElements.push(element);
      }
      this.valueAlternatives = valueAlternativesElements;
    } else {
      this.valueAlternatives = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the `valueAlternatives` array property.
   *
   * @param value - the `valueAlternatives` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addValueAlternatives(value: fhirCanonical | undefined): this {
    if (isDefined<fhirCanonical>(value)) {
      const optErrMsg = `Invalid ElementDefinition.valueAlternatives array item (${String(value)})`;
      const element = new CanonicalType(parseFhirPrimitiveData(value, fhirCanonicalSchema, optErrMsg));
      this.initValueAlternatives();
      this.addValueAlternativesElement(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `valueAlternatives` property exists and has a value; `false` otherwise
   */
  public hasValueAlternatives(): boolean {
    return this.hasValueAlternativesElement();
  }

  /**
   * Initialize the `valueAlternatives` property
   */
  private initValueAlternatives(): void {
    if (!this.hasValueAlternatives()) {
      this.valueAlternatives = [] as CanonicalType[];
    }
  }

  /**
   * @returns the `mustSupport` property value as a BooleanType object if defined; else an empty BooleanType object
   */
  public getMustSupportElement(): BooleanType {
    return this.mustSupport ?? new BooleanType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `mustSupport` property.
   *
   * @param element - the `mustSupport` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMustSupportElement(element: BooleanType | undefined): this {
    if (isDefined<BooleanType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.mustSupport; Provided element is not an instance of BooleanType.`;
      assertFhirType<BooleanType>(element, BooleanType, optErrMsg);
      this.mustSupport = element;
    } else {
      this.mustSupport = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `mustSupport` property exists and has a value; `false` otherwise
   */
  public hasMustSupportElement(): boolean {
    return isDefined<BooleanType>(this.mustSupport) && !this.mustSupport.isEmpty();
  }

  /**
   * @returns the `mustSupport` property value as a fhirBoolean if defined; else undefined
   */
  public getMustSupport(): fhirBoolean | undefined {
    return this.mustSupport?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `mustSupport` property.
   *
   * @param value - the `mustSupport` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMustSupport(value: fhirBoolean | undefined): this {
    if (isDefined<fhirBoolean>(value)) {
      const optErrMsg = `Invalid ElementDefinition.mustSupport (${String(value)})`;
      this.mustSupport = new BooleanType(parseFhirPrimitiveData(value, fhirBooleanSchema, optErrMsg));
    } else {
      this.mustSupport = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `mustSupport` property exists and has a value; `false` otherwise
   */
  public hasMustSupport(): boolean {
    return this.hasMustSupportElement();
  }

  /**
   * @returns the `isModifier` property value as a BooleanType object if defined; else an empty BooleanType object
   */
  public getIsModifierElement(): BooleanType {
    return this.isModifier ?? new BooleanType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `isModifier` property.
   *
   * @param element - the `isModifier` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setIsModifierElement(element: BooleanType | undefined): this {
    if (isDefined<BooleanType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.isModifier; Provided element is not an instance of BooleanType.`;
      assertFhirType<BooleanType>(element, BooleanType, optErrMsg);
      this.isModifier = element;
    } else {
      this.isModifier = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `isModifier` property exists and has a value; `false` otherwise
   */
  public hasIsModifierElement(): boolean {
    return isDefined<BooleanType>(this.isModifier) && !this.isModifier.isEmpty();
  }

  /**
   * @returns the `isModifier` property value as a fhirBoolean if defined; else undefined
   */
  public getIsModifier(): fhirBoolean | undefined {
    return this.isModifier?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `isModifier` property.
   *
   * @param value - the `isModifier` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setIsModifier(value: fhirBoolean | undefined): this {
    if (isDefined<fhirBoolean>(value)) {
      const optErrMsg = `Invalid ElementDefinition.isModifier (${String(value)})`;
      this.isModifier = new BooleanType(parseFhirPrimitiveData(value, fhirBooleanSchema, optErrMsg));
    } else {
      this.isModifier = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `isModifier` property exists and has a value; `false` otherwise
   */
  public hasIsModifier(): boolean {
    return this.hasIsModifierElement();
  }

  /**
   * @returns the `isModifierReason` property value as a StringType object if defined; else an empty StringType object
   */
  public getIsModifierReasonElement(): StringType {
    return this.isModifierReason ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `isModifierReason` property.
   *
   * @param element - the `isModifierReason` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setIsModifierReasonElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.isModifierReason; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.isModifierReason = element;
    } else {
      this.isModifierReason = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `isModifierReason` property exists and has a value; `false` otherwise
   */
  public hasIsModifierReasonElement(): boolean {
    return isDefined<StringType>(this.isModifierReason) && !this.isModifierReason.isEmpty();
  }

  /**
   * @returns the `isModifierReason` property value as a fhirString if defined; else undefined
   */
  public getIsModifierReason(): fhirString | undefined {
    return this.isModifierReason?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `isModifierReason` property.
   *
   * @param value - the `isModifierReason` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setIsModifierReason(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid ElementDefinition.isModifierReason (${String(value)})`;
      this.isModifierReason = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.isModifierReason = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `isModifierReason` property exists and has a value; `false` otherwise
   */
  public hasIsModifierReason(): boolean {
    return this.hasIsModifierReasonElement();
  }

  /**
   * @returns the `isSummary` property value as a BooleanType object if defined; else an empty BooleanType object
   */
  public getIsSummaryElement(): BooleanType {
    return this.isSummary ?? new BooleanType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `isSummary` property.
   *
   * @param element - the `isSummary` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setIsSummaryElement(element: BooleanType | undefined): this {
    if (isDefined<BooleanType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.isSummary; Provided element is not an instance of BooleanType.`;
      assertFhirType<BooleanType>(element, BooleanType, optErrMsg);
      this.isSummary = element;
    } else {
      this.isSummary = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `isSummary` property exists and has a value; `false` otherwise
   */
  public hasIsSummaryElement(): boolean {
    return isDefined<BooleanType>(this.isSummary) && !this.isSummary.isEmpty();
  }

  /**
   * @returns the `isSummary` property value as a fhirBoolean if defined; else undefined
   */
  public getIsSummary(): fhirBoolean | undefined {
    return this.isSummary?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `isSummary` property.
   *
   * @param value - the `isSummary` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setIsSummary(value: fhirBoolean | undefined): this {
    if (isDefined<fhirBoolean>(value)) {
      const optErrMsg = `Invalid ElementDefinition.isSummary (${String(value)})`;
      this.isSummary = new BooleanType(parseFhirPrimitiveData(value, fhirBooleanSchema, optErrMsg));
    } else {
      this.isSummary = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `isSummary` property exists and has a value; `false` otherwise
   */
  public hasIsSummary(): boolean {
    return this.hasIsSummaryElement();
  }

  /**
   * @returns the `binding` property value as a ElementDefinitionBindingComponent object if defined; else an empty ElementDefinitionBindingComponent object
   */
  public getBinding(): ElementDefinitionBindingComponent {
    return this.binding ?? new ElementDefinitionBindingComponent();
  }

  /**
   * Assigns the provided Binding object value to the `binding` property.
   *
   * @param value - the `binding` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setBinding(value: ElementDefinitionBindingComponent | undefined): this {
    if (isDefined<ElementDefinitionBindingComponent>(value)) {
      const optErrMsg = `Invalid ElementDefinition.binding; Provided element is not an instance of ElementDefinitionBindingComponent.`;
      assertFhirType<ElementDefinitionBindingComponent>(value, ElementDefinitionBindingComponent, optErrMsg);
      this.binding = value;
    } else {
      this.binding = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `binding` property exists and has a value; `false` otherwise
   */
  public hasBinding(): boolean {
    return isDefined<ElementDefinitionBindingComponent>(this.binding) && !this.binding.isEmpty();
  }

  /**
   * @returns the `mapping` property value as a ElementDefinitionMappingComponent array
   */
  public getMapping(): ElementDefinitionMappingComponent[] {
    return this.mapping ?? ([] as ElementDefinitionMappingComponent[]);
  }

  /**
   * Assigns the provided ElementDefinitionMappingComponent array value to the `mapping` property.
   *
   * @param value - the `mapping` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setMapping(value: ElementDefinitionMappingComponent[] | undefined): this {
    if (isDefinedList<ElementDefinitionMappingComponent>(value)) {
      const optErrMsg = `Invalid ElementDefinition.mapping; Provided value array has an element that is not an instance of ElementDefinitionMappingComponent.`;
      assertFhirTypeList<ElementDefinitionMappingComponent>(value, ElementDefinitionMappingComponent, optErrMsg);
      this.mapping = value;
    } else {
      this.mapping = undefined;
    }
    return this;
  }

  /**
   * Add the provided ElementDefinitionMappingComponent value to the `mapping` array property.
   *
   * @param value - the `mapping` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addMapping(value: ElementDefinitionMappingComponent | undefined): this {
    if (isDefined<ElementDefinitionMappingComponent>(value)) {
      const optErrMsg = `Invalid ElementDefinition.mapping; Provided element is not an instance of ElementDefinitionMappingComponent.`;
      assertFhirType<ElementDefinitionMappingComponent>(value, ElementDefinitionMappingComponent, optErrMsg);
      this.initMapping();
      this.mapping?.push(value);
    }
    return this;
  }

  /**
   * @returns `true` if the `mapping` property exists and has a value; `false` otherwise
   */
  public hasMapping(): boolean {
    return isDefinedList<ElementDefinitionMappingComponent>(this.mapping) && this.mapping.some((item: ElementDefinitionMappingComponent) => !item.isEmpty());
  }

  /**
   * Initialize the `mapping` property
   */
  private initMapping(): void {
    if(!this.hasMapping()) {
      this.mapping = [] as ElementDefinitionMappingComponent[];
    }
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'ElementDefinition';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.path,
      this.representation,
      this.sliceName,
      this.sliceIsConstraining,
      this.label,
      this.code,
      this.slicing,
      this.short,
      this.definition,
      this.comment,
      this.requirements,
      this.alias,
      this.min,
      this.max,
      this.base,
      this.contentReference,
      this.type_,
      this.defaultValue,
      this.meaningWhenMissing,
      this.orderMeaning,
      this.fixed,
      this.pattern,
      this.example,
      this.minValue,
      this.maxValue,
      this.maxLength,
      this.condition,
      this.constraint,
      this.mustHaveValue,
      this.valueAlternatives,
      this.mustSupport,
      this.isModifier,
      this.isModifierReason,
      this.isSummary,
      this.binding,
      this.mapping,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): ElementDefinition {
    const dest = new ElementDefinition();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: ElementDefinition): void {
    super.copyValues(dest);
    dest.path = this.path ? this.path.copy() : null;
    const representationList = copyListValues<EnumCodeType>(this.representation);
    dest.representation = representationList.length === 0 ? undefined : representationList;
    dest.sliceName = this.sliceName?.copy();
    dest.sliceIsConstraining = this.sliceIsConstraining?.copy();
    dest.label = this.label?.copy();
    const codeList = copyListValues<Coding>(this.code);
    dest.code = codeList.length === 0 ? undefined : codeList;
    dest.slicing = this.slicing?.copy();
    dest.short = this.short?.copy();
    dest.definition = this.definition?.copy();
    dest.comment = this.comment?.copy();
    dest.requirements = this.requirements?.copy();
    const aliasList = copyListValues<StringType>(this.alias);
    dest.alias = aliasList.length === 0 ? undefined : aliasList;
    dest.min = this.min?.copy();
    dest.max = this.max?.copy();
    dest.base = this.base?.copy();
    dest.contentReference = this.contentReference?.copy();
    const typeList = copyListValues<ElementDefinitionTypeComponent>(this.type_);
    dest.type_ = typeList.length === 0 ? undefined : typeList;
    dest.defaultValue = this.defaultValue?.copy() as IDataType;
    dest.meaningWhenMissing = this.meaningWhenMissing?.copy();
    dest.orderMeaning = this.orderMeaning?.copy();
    dest.fixed = this.fixed?.copy() as IDataType;
    dest.pattern = this.pattern?.copy() as IDataType;
    const exampleList = copyListValues<ElementDefinitionExampleComponent>(this.example);
    dest.example = exampleList.length === 0 ? undefined : exampleList;
    dest.minValue = this.minValue?.copy() as IDataType;
    dest.maxValue = this.maxValue?.copy() as IDataType;
    dest.maxLength = this.maxLength?.copy();
    const conditionList = copyListValues<IdType>(this.condition);
    dest.condition = conditionList.length === 0 ? undefined : conditionList;
    const constraintList = copyListValues<ElementDefinitionConstraintComponent>(this.constraint);
    dest.constraint = constraintList.length === 0 ? undefined : constraintList;
    dest.mustHaveValue = this.mustHaveValue?.copy();
    const valueAlternativesList = copyListValues<CanonicalType>(this.valueAlternatives);
    dest.valueAlternatives = valueAlternativesList.length === 0 ? undefined : valueAlternativesList;
    dest.mustSupport = this.mustSupport?.copy();
    dest.isModifier = this.isModifier?.copy();
    dest.isModifierReason = this.isModifierReason?.copy();
    dest.isSummary = this.isSummary?.copy();
    dest.binding = this.binding?.copy();
    const mappingList = copyListValues<ElementDefinitionMappingComponent>(this.mapping);
    dest.mapping = mappingList.length === 0 ? undefined : mappingList;
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasPathElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirString>(this.getPathElement()!, 'path', jsonObj);
    } else {
      missingReqdProperties.push(`ElementDefinition.path`);
    }

    if (this.hasRepresentationElement()) {
      setFhirPrimitiveListJson<fhirCode>(this.getRepresentationElement(), 'representation', jsonObj);
    }

    if (this.hasSliceNameElement()) {
      setFhirPrimitiveJson<fhirString>(this.getSliceNameElement(), 'sliceName', jsonObj);
    }

    if (this.hasSliceIsConstrainingElement()) {
      setFhirPrimitiveJson<fhirBoolean>(this.getSliceIsConstrainingElement(), 'sliceIsConstraining', jsonObj);
    }

    if (this.hasLabelElement()) {
      setFhirPrimitiveJson<fhirString>(this.getLabelElement(), 'label', jsonObj);
    }

    if (this.hasCode()) {
      setFhirComplexListJson(this.getCode(), 'code', jsonObj);
    }

    if (this.hasSlicing()) {
      setFhirComplexJson(this.getSlicing(), 'slicing', jsonObj);
    }

    if (this.hasShortElement()) {
      setFhirPrimitiveJson<fhirString>(this.getShortElement(), 'short', jsonObj);
    }

    if (this.hasDefinitionElement()) {
      setFhirPrimitiveJson<fhirMarkdown>(this.getDefinitionElement(), 'definition', jsonObj);
    }

    if (this.hasCommentElement()) {
      setFhirPrimitiveJson<fhirMarkdown>(this.getCommentElement(), 'comment', jsonObj);
    }

    if (this.hasRequirementsElement()) {
      setFhirPrimitiveJson<fhirMarkdown>(this.getRequirementsElement(), 'requirements', jsonObj);
    }

    if (this.hasAlias()) {
      setFhirPrimitiveListJson(this.getAliasElement(), 'alias', jsonObj);
    }

    if (this.hasMinElement()) {
      setFhirPrimitiveJson<fhirUnsignedInt>(this.getMinElement(), 'min', jsonObj);
    }

    if (this.hasMaxElement()) {
      setFhirPrimitiveJson<fhirString>(this.getMaxElement(), 'max', jsonObj);
    }

    if (this.hasBase()) {
      setFhirComplexJson(this.getBase(), 'base', jsonObj);
    }

    if (this.hasContentReferenceElement()) {
      setFhirPrimitiveJson<fhirUri>(this.getContentReferenceElement(), 'contentReference', jsonObj);
    }

    if (this.hasType()) {
      setFhirComplexListJson(this.getType(), 'type', jsonObj);
    }

    if (this.hasDefaultValue()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getDefaultValue()!, 'defaultValue', jsonObj);
    }

    if (this.hasMeaningWhenMissingElement()) {
      setFhirPrimitiveJson<fhirMarkdown>(this.getMeaningWhenMissingElement(), 'meaningWhenMissing', jsonObj);
    }

    if (this.hasOrderMeaningElement()) {
      setFhirPrimitiveJson<fhirString>(this.getOrderMeaningElement(), 'orderMeaning', jsonObj);
    }

    if (this.hasFixed()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getFixed()!, 'fixed', jsonObj);
    }

    if (this.hasPattern()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getPattern()!, 'pattern', jsonObj);
    }

    if (this.hasExample()) {
      setFhirComplexListJson(this.getExample(), 'example', jsonObj);
    }

    if (this.hasMinValue()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getMinValue()!, 'minValue', jsonObj);
    }

    if (this.hasMaxValue()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getMaxValue()!, 'maxValue', jsonObj);
    }

    if (this.hasMaxLengthElement()) {
      setFhirPrimitiveJson<fhirInteger>(this.getMaxLengthElement(), 'maxLength', jsonObj);
    }

    if (this.hasCondition()) {
      setFhirPrimitiveListJson(this.getConditionElement(), 'condition', jsonObj);
    }

    if (this.hasConstraint()) {
      setFhirComplexListJson(this.getConstraint(), 'constraint', jsonObj);
    }

    if (this.hasMustHaveValueElement()) {
      setFhirPrimitiveJson<fhirBoolean>(this.getMustHaveValueElement(), 'mustHaveValue', jsonObj);
    }

    if (this.hasValueAlternatives()) {
      setFhirPrimitiveListJson(this.getValueAlternativesElement(), 'valueAlternatives', jsonObj);
    }

    if (this.hasMustSupportElement()) {
      setFhirPrimitiveJson<fhirBoolean>(this.getMustSupportElement(), 'mustSupport', jsonObj);
    }

    if (this.hasIsModifierElement()) {
      setFhirPrimitiveJson<fhirBoolean>(this.getIsModifierElement(), 'isModifier', jsonObj);
    }

    if (this.hasIsModifierReasonElement()) {
      setFhirPrimitiveJson<fhirString>(this.getIsModifierReasonElement(), 'isModifierReason', jsonObj);
    }

    if (this.hasIsSummaryElement()) {
      setFhirPrimitiveJson<fhirBoolean>(this.getIsSummaryElement(), 'isSummary', jsonObj);
    }

    if (this.hasBinding()) {
      setFhirComplexJson(this.getBinding(), 'binding', jsonObj);
    }

    if (this.hasMapping()) {
      setFhirComplexListJson(this.getMapping(), 'mapping', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_DO_NOT_EXIST} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
/**
 * ElementDefinitionSlicingComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** This element is sliced - slices follow
 * - **Definition:** Indicates that the element is sliced into a set of alternative definitions (i.e. in a structure definition, there are multiple different constraints on a single element in the base resource). Slicing can be used in any resource that has cardinality ..* on the base resource, or any resource with a choice of types. The set of slices is any elements that come after this in the element sequence that have the same path, until a shorter path occurs (the shorter path terminates the set).
 * - **Comment:** The first element in the sequence, the one that carries the slicing, is the definition that applies to all the slices. This is based on the unconstrained element, but can apply any constraints as appropriate. This may include the common constraints on the children of the element.
 *
 * @category Data Models: ComplexType
 * @see [FHIR ElementDefinition](http://hl7.org/fhir/StructureDefinition/ElementDefinition)
 */
export class ElementDefinitionSlicingComponent extends DataType implements IDataType {
  constructor(rules: EnumCodeType | CodeType | fhirCode | null = null) {
    super();

    this.resourceSlicingRulesEnum = new ResourceSlicingRulesEnum();

    this.rules = constructorCodeValueAsEnumCodeType<ResourceSlicingRulesEnum>(
      rules,
      ResourceSlicingRulesEnum,
      this.resourceSlicingRulesEnum,
      'ElementDefinition.slicing.rules',
    );
  }

  /**
   * Parse the provided `ElementDefinitionSlicingComponent` JSON to instantiate the ElementDefinitionSlicingComponent data model.
   *
   * @param sourceJson - JSON representing FHIR `ElementDefinitionSlicingComponent`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to ElementDefinitionSlicingComponent
   * @returns ElementDefinitionSlicingComponent data model or undefined for `ElementDefinitionSlicingComponent`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): ElementDefinitionSlicingComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'ElementDefinitionSlicingComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new ElementDefinitionSlicingComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'discriminator';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: ElementDefinitionSlicingDiscriminatorComponent | undefined = ElementDefinitionSlicingDiscriminatorComponent.parse(dataElementJson, `${sourceField}[${String(idx)}]`);
        if (datatype !== undefined) {
          instance.addDiscriminator(datatype);
        }
      });
    }

    fieldName = 'description';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setDescriptionElement(datatype);
    }

    fieldName = 'ordered';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'boolean';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: BooleanType | undefined = fhirParser.parseBooleanType(dtJson, dtSiblingJson);
      instance.setOrderedElement(datatype);
    }

    fieldName = 'rules';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setRulesElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_REQD_IN_JSON} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * ElementDefinition.slicing.discriminator Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Element values that are used to distinguish the slices
   * - **Definition:** Designates which child elements are used to discriminate between the slices when processing an instance. If one or more discriminators are provided, the value of the child elements in the instance data SHALL completely distinguish which slice the element in the resource matches based on the allowed values for those elements in each of the slices.
   * - **Comment:** If there is no discriminator, the content is hard to process, so this should be avoided.
   * - **FHIR Type:** `Element`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private discriminator?: ElementDefinitionSlicingDiscriminatorComponent[] | undefined;

  /**
   * ElementDefinition.slicing.description Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Text description of how slicing works (or not)
   * - **Definition:** A human-readable text description of how the slicing works. If there is no discriminator, this is required to be present to provide whatever information is possible about how the slices can be differentiated.
   * - **Comment:** If it\'s really not possible to differentiate them, the design should be re-evaluated to make the content usable.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private description?: StringType | undefined;

  /**
   * ElementDefinition.slicing.ordered Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** If elements must be in same order as slices
   * - **Definition:** If the matching elements have to occur in the same order as defined in the profile.
   * - **Comment:** Order should only be required when it is a pressing concern for presentation. Profile authors should consider making the order a feature of the rules about the narrative, not the rules about the data - requiring ordered data makes the profile much less re-usable.
   * - **FHIR Type:** `boolean`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private ordered?: BooleanType | undefined;

  /**
   * FHIR CodeSystem: ResourceSlicingRules
   *
   * @see {@link ResourceSlicingRulesEnum }
   */
  private readonly resourceSlicingRulesEnum: ResourceSlicingRulesEnum;

  /**
   * ElementDefinition.slicing.rules Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** closed | open | openAtEnd
   * - **Definition:** Whether additional slices are allowed or not. When the slices are ordered, profile authors can also say that additional slices are only allowed at the end.
   * - **Comment:** Allowing additional elements makes for a much for flexible template - it\'s open for use in wider contexts, but also means that the content of the resource is not closed, and applications have to decide how to handle content not described by the profile.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link ResourceSlicingRulesEnum }
   */
  private rules: EnumCodeType | null;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `discriminator` property value as a ElementDefinitionSlicingDiscriminatorComponent array
   */
  public getDiscriminator(): ElementDefinitionSlicingDiscriminatorComponent[] {
    return this.discriminator ?? ([] as ElementDefinitionSlicingDiscriminatorComponent[]);
  }

  /**
   * Assigns the provided ElementDefinitionSlicingDiscriminatorComponent array value to the `discriminator` property.
   *
   * @param value - the `discriminator` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setDiscriminator(value: ElementDefinitionSlicingDiscriminatorComponent[] | undefined): this {
    if (isDefinedList<ElementDefinitionSlicingDiscriminatorComponent>(value)) {
      const optErrMsg = `Invalid ElementDefinition.slicing.discriminator; Provided value array has an element that is not an instance of ElementDefinitionSlicingDiscriminatorComponent.`;
      assertFhirTypeList<ElementDefinitionSlicingDiscriminatorComponent>(value, ElementDefinitionSlicingDiscriminatorComponent, optErrMsg);
      this.discriminator = value;
    } else {
      this.discriminator = undefined;
    }
    return this;
  }

  /**
   * Add the provided ElementDefinitionSlicingDiscriminatorComponent value to the `discriminator` array property.
   *
   * @param value - the `discriminator` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addDiscriminator(value: ElementDefinitionSlicingDiscriminatorComponent | undefined): this {
    if (isDefined<ElementDefinitionSlicingDiscriminatorComponent>(value)) {
      const optErrMsg = `Invalid ElementDefinition.slicing.discriminator; Provided element is not an instance of ElementDefinitionSlicingDiscriminatorComponent.`;
      assertFhirType<ElementDefinitionSlicingDiscriminatorComponent>(value, ElementDefinitionSlicingDiscriminatorComponent, optErrMsg);
      this.initDiscriminator();
      this.discriminator?.push(value);
    }
    return this;
  }

  /**
   * @returns `true` if the `discriminator` property exists and has a value; `false` otherwise
   */
  public hasDiscriminator(): boolean {
    return isDefinedList<ElementDefinitionSlicingDiscriminatorComponent>(this.discriminator) && this.discriminator.some((item: ElementDefinitionSlicingDiscriminatorComponent) => !item.isEmpty());
  }

  /**
   * Initialize the `discriminator` property
   */
  private initDiscriminator(): void {
    if(!this.hasDiscriminator()) {
      this.discriminator = [] as ElementDefinitionSlicingDiscriminatorComponent[];
    }
  }

  /**
   * @returns the `description` property value as a StringType object if defined; else an empty StringType object
   */
  public getDescriptionElement(): StringType {
    return this.description ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `description` property.
   *
   * @param element - the `description` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDescriptionElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.slicing.description; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.description = element;
    } else {
      this.description = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `description` property exists and has a value; `false` otherwise
   */
  public hasDescriptionElement(): boolean {
    return isDefined<StringType>(this.description) && !this.description.isEmpty();
  }

  /**
   * @returns the `description` property value as a fhirString if defined; else undefined
   */
  public getDescription(): fhirString | undefined {
    return this.description?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `description` property.
   *
   * @param value - the `description` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDescription(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid ElementDefinition.slicing.description (${String(value)})`;
      this.description = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.description = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `description` property exists and has a value; `false` otherwise
   */
  public hasDescription(): boolean {
    return this.hasDescriptionElement();
  }

  /**
   * @returns the `ordered` property value as a BooleanType object if defined; else an empty BooleanType object
   */
  public getOrderedElement(): BooleanType {
    return this.ordered ?? new BooleanType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `ordered` property.
   *
   * @param element - the `ordered` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setOrderedElement(element: BooleanType | undefined): this {
    if (isDefined<BooleanType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.slicing.ordered; Provided element is not an instance of BooleanType.`;
      assertFhirType<BooleanType>(element, BooleanType, optErrMsg);
      this.ordered = element;
    } else {
      this.ordered = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `ordered` property exists and has a value; `false` otherwise
   */
  public hasOrderedElement(): boolean {
    return isDefined<BooleanType>(this.ordered) && !this.ordered.isEmpty();
  }

  /**
   * @returns the `ordered` property value as a fhirBoolean if defined; else undefined
   */
  public getOrdered(): fhirBoolean | undefined {
    return this.ordered?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `ordered` property.
   *
   * @param value - the `ordered` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setOrdered(value: fhirBoolean | undefined): this {
    if (isDefined<fhirBoolean>(value)) {
      const optErrMsg = `Invalid ElementDefinition.slicing.ordered (${String(value)})`;
      this.ordered = new BooleanType(parseFhirPrimitiveData(value, fhirBooleanSchema, optErrMsg));
    } else {
      this.ordered = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `ordered` property exists and has a value; `false` otherwise
   */
  public hasOrdered(): boolean {
    return this.hasOrderedElement();
  }

  /**
   * @returns the `rules` property value as a EnumCodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link ResourceSlicingRulesEnum }
   */
  public getRulesEnumType(): EnumCodeType | null {
    return this.rules;
  }

  /**
   * Assigns the provided EnumCodeType value to the `rules` property.
   *
   * @param enumType - the `rules` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ResourceSlicingRulesEnum }
   */
  public setRulesEnumType(enumType: EnumCodeType): this {
    assertIsDefined<EnumCodeType>(enumType, `ElementDefinition.slicing.rules is required`);
    const errMsgPrefix = `Invalid ElementDefinition.slicing.rules`;
    assertEnumCodeType<ResourceSlicingRulesEnum>(enumType, ResourceSlicingRulesEnum, errMsgPrefix);
    this.rules = enumType;
    return this;
  }

  /**
   * @returns `true` if the `rules` property exists and has a value; `false` otherwise
   */
  public hasRulesEnumType(): boolean {
    return isDefined<EnumCodeType>(this.rules) && !this.rules.isEmpty() && this.rules.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the `rules` property value as a CodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link ResourceSlicingRulesEnum }
   */
  public getRulesElement(): CodeType | null {
    if (this.rules === null) {
      return null;
    }
    return this.rules as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the `rules` property.
   *
   * @param element - the `rules` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ResourceSlicingRulesEnum }
   */
  public setRulesElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, `ElementDefinition.slicing.rules is required`);
    const optErrMsg = `Invalid ElementDefinition.slicing.rules; Provided value is not an instance of CodeType.`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.rules = new EnumCodeType(element, this.resourceSlicingRulesEnum);
    return this;
  }

  /**
   * @returns `true` if the `rules` property exists and has a value; `false` otherwise
   */
  public hasRulesElement(): boolean {
    return this.hasRulesEnumType();
  }

  /**
   * @returns the `rules` property value as a fhirCode if defined; else null
   *
   * @see CodeSystem Enumeration: {@link ResourceSlicingRulesEnum }
   */
  public getRules(): fhirCode | null {
    if (this.rules === null) {
      return null;
    }
    return this.rules.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the `rules` property.
   *
   * @param value - the `rules` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link ResourceSlicingRulesEnum }
   */
  public setRules(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, `ElementDefinition.slicing.rules is required`);
    const optErrMsg = `Invalid ElementDefinition.slicing.rules (${String(value)})`;
    this.rules = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.resourceSlicingRulesEnum);
    return this;
  }

  /**
   * @returns `true` if the `rules` property exists and has a value; `false` otherwise
   */
  public hasRules(): boolean {
    return this.hasRulesEnumType();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'ElementDefinition.slicing';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.discriminator,
      this.description,
      this.ordered,
      this.rules,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): ElementDefinitionSlicingComponent {
    const dest = new ElementDefinitionSlicingComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: ElementDefinitionSlicingComponent): void {
    super.copyValues(dest);
    const discriminatorList = copyListValues<ElementDefinitionSlicingDiscriminatorComponent>(this.discriminator);
    dest.discriminator = discriminatorList.length === 0 ? undefined : discriminatorList;
    dest.description = this.description?.copy();
    dest.ordered = this.ordered?.copy();
    dest.rules = this.rules ? this.rules.copy() : null;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasDiscriminator()) {
      setFhirComplexListJson(this.getDiscriminator(), 'discriminator', jsonObj);
    }

    if (this.hasDescriptionElement()) {
      setFhirPrimitiveJson<fhirString>(this.getDescriptionElement(), 'description', jsonObj);
    }

    if (this.hasOrderedElement()) {
      setFhirPrimitiveJson<fhirBoolean>(this.getOrderedElement(), 'ordered', jsonObj);
    }

    if (this.hasRulesElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getRulesElement()!, 'rules', jsonObj);
    } else {
      missingReqdProperties.push(`ElementDefinition.slicing.rules`);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_DO_NOT_EXIST} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
/**
 * ElementDefinitionSlicingDiscriminatorComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Element values that are used to distinguish the slices
 * - **Definition:** Designates which child elements are used to discriminate between the slices when processing an instance. If one or more discriminators are provided, the value of the child elements in the instance data SHALL completely distinguish which slice the element in the resource matches based on the allowed values for those elements in each of the slices.
 * - **Comment:** If there is no discriminator, the content is hard to process, so this should be avoided.
 *
 * @category Data Models: ComplexType
 * @see [FHIR ElementDefinition](http://hl7.org/fhir/StructureDefinition/ElementDefinition)
 */
export class ElementDefinitionSlicingDiscriminatorComponent extends DataType implements IDataType {
  constructor(type_: EnumCodeType | CodeType | fhirCode | null = null, path: StringType | fhirString | null = null) {
    super();

    this.discriminatorTypeEnum = new DiscriminatorTypeEnum();

    this.type_ = constructorCodeValueAsEnumCodeType<DiscriminatorTypeEnum>(
      type_,
      DiscriminatorTypeEnum,
      this.discriminatorTypeEnum,
      'ElementDefinition.slicing.discriminator.type',
    );

    this.path = null;
    if (isDefined<StringType | fhirString>(path)) {
      if (path instanceof PrimitiveType) {
        this.setPathElement(path);
      } else {
        this.setPath(path);
      }
    }
  }

  /**
   * Parse the provided `ElementDefinitionSlicingDiscriminatorComponent` JSON to instantiate the ElementDefinitionSlicingDiscriminatorComponent data model.
   *
   * @param sourceJson - JSON representing FHIR `ElementDefinitionSlicingDiscriminatorComponent`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to ElementDefinitionSlicingDiscriminatorComponent
   * @returns ElementDefinitionSlicingDiscriminatorComponent data model or undefined for `ElementDefinitionSlicingDiscriminatorComponent`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): ElementDefinitionSlicingDiscriminatorComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'ElementDefinitionSlicingDiscriminatorComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new ElementDefinitionSlicingDiscriminatorComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'type';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setTypeElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'path';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setPathElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_REQD_IN_JSON} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: DiscriminatorType
   *
   * @see {@link DiscriminatorTypeEnum }
   */
  private readonly discriminatorTypeEnum: DiscriminatorTypeEnum;

  /**
   * ElementDefinition.slicing.discriminator.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** value | exists | type | profile | position
   * - **Definition:** How the element value is interpreted when discrimination is evaluated.
   * - **Comment:** \'pattern\' is deprecated - it works exactly the same as \'value\'.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link DiscriminatorTypeEnum }
   */
  private type_: EnumCodeType | null;

  /**
   * ElementDefinition.slicing.discriminator.path Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Path to element value
   * - **Definition:** A FHIRPath expression, using [the simple subset of FHIRPath](https://hl7.org/fhir/fhirpath.html#simple), that is used to identify the element on which discrimination is based.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private path: StringType | null;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `type_` property value as a EnumCodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link DiscriminatorTypeEnum }
   */
  public getTypeEnumType(): EnumCodeType | null {
    return this.type_;
  }

  /**
   * Assigns the provided EnumCodeType value to the `type_` property.
   *
   * @param enumType - the `type_` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link DiscriminatorTypeEnum }
   */
  public setTypeEnumType(enumType: EnumCodeType): this {
    assertIsDefined<EnumCodeType>(enumType, `ElementDefinition.slicing.discriminator.type is required`);
    const errMsgPrefix = `Invalid ElementDefinition.slicing.discriminator.type`;
    assertEnumCodeType<DiscriminatorTypeEnum>(enumType, DiscriminatorTypeEnum, errMsgPrefix);
    this.type_ = enumType;
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasTypeEnumType(): boolean {
    return isDefined<EnumCodeType>(this.type_) && !this.type_.isEmpty() && this.type_.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the `type_` property value as a CodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link DiscriminatorTypeEnum }
   */
  public getTypeElement(): CodeType | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_ as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the `type_` property.
   *
   * @param element - the `type_` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link DiscriminatorTypeEnum }
   */
  public setTypeElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, `ElementDefinition.slicing.discriminator.type is required`);
    const optErrMsg = `Invalid ElementDefinition.slicing.discriminator.type; Provided value is not an instance of CodeType.`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.type_ = new EnumCodeType(element, this.discriminatorTypeEnum);
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasTypeElement(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the `type_` property value as a fhirCode if defined; else null
   *
   * @see CodeSystem Enumeration: {@link DiscriminatorTypeEnum }
   */
  public getType(): fhirCode | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the `type_` property.
   *
   * @param value - the `type_` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link DiscriminatorTypeEnum }
   */
  public setType(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, `ElementDefinition.slicing.discriminator.type is required`);
    const optErrMsg = `Invalid ElementDefinition.slicing.discriminator.type (${String(value)})`;
    this.type_ = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.discriminatorTypeEnum);
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasType(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the `path` property value as a StringType object if defined; else null
   */
  public getPathElement(): StringType | null {
    return this.path;
  }

  /**
   * Assigns the provided PrimitiveType value to the `path` property.
   *
   * @param element - the `path` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPathElement(element: StringType): this {
    assertIsDefined<StringType>(element, `ElementDefinition.slicing.discriminator.path is required`);
    const optErrMsg = `Invalid ElementDefinition.slicing.discriminator.path; Provided value is not an instance of StringType.`;
    assertFhirType<StringType>(element, StringType, optErrMsg);
    this.path = element;
    return this;
  }

  /**
   * @returns `true` if the `path` property exists and has a value; `false` otherwise
   */
  public hasPathElement(): boolean {
    return isDefined<StringType>(this.path) && !this.path.isEmpty();
  }

  /**
   * @returns the `path` property value as a fhirString if defined; else null
   */
  public getPath(): fhirString | null {
    if (this.path?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.path.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the `path` property.
   *
   * @param value - the `path` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPath(value: fhirString): this {
    assertIsDefined<fhirString>(value, `ElementDefinition.slicing.discriminator.path is required`);
    const optErrMsg = `Invalid ElementDefinition.slicing.discriminator.path (${String(value)})`;
    this.path = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    return this;
  }

  /**
   * @returns `true` if the `path` property exists and has a value; `false` otherwise
   */
  public hasPath(): boolean {
    return this.hasPathElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'ElementDefinition.slicing.discriminator';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.type_,
      this.path,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): ElementDefinitionSlicingDiscriminatorComponent {
    const dest = new ElementDefinitionSlicingDiscriminatorComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: ElementDefinitionSlicingDiscriminatorComponent): void {
    super.copyValues(dest);
    dest.type_ = this.type_ ? this.type_.copy() : null;
    dest.path = this.path ? this.path.copy() : null;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasTypeElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getTypeElement()!, 'type', jsonObj);
    } else {
      missingReqdProperties.push(`ElementDefinition.slicing.discriminator.type`);
    }

    if (this.hasPathElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirString>(this.getPathElement()!, 'path', jsonObj);
    } else {
      missingReqdProperties.push(`ElementDefinition.slicing.discriminator.path`);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_DO_NOT_EXIST} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
/**
 * ElementDefinitionBaseComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Base definition information for tools
 * - **Definition:** Information about the base definition of the element, provided to make it unnecessary for tools to trace the deviation of the element through the derived and related profiles. When the element definition is not the original definition of an element - e.g. either in a constraint on another type, or for elements from a super type in a snap shot - then the information in provided in the element definition may be different to the base definition. On the original definition of the element, it will be same.
 * - **Comment:** The base information does not carry any information that could not be determined from the path and related profiles, but making this determination requires both that the related profiles are available, and that the algorithm to determine them be available. For tooling simplicity, the base information must always be populated in element definitions in snap shots, even if it is the same.
 *
 * @category Data Models: ComplexType
 * @see [FHIR ElementDefinition](http://hl7.org/fhir/StructureDefinition/ElementDefinition)
 */
export class ElementDefinitionBaseComponent extends DataType implements IDataType {
  constructor(path: StringType | fhirString | null = null, min: UnsignedIntType | fhirUnsignedInt | null = null, max: StringType | fhirString | null = null) {
    super();

    this.path = null;
    if (isDefined<StringType | fhirString>(path)) {
      if (path instanceof PrimitiveType) {
        this.setPathElement(path);
      } else {
        this.setPath(path);
      }
    }

    this.min = null;
    if (isDefined<UnsignedIntType | fhirUnsignedInt>(min)) {
      if (min instanceof PrimitiveType) {
        this.setMinElement(min);
      } else {
        this.setMin(min);
      }
    }

    this.max = null;
    if (isDefined<StringType | fhirString>(max)) {
      if (max instanceof PrimitiveType) {
        this.setMaxElement(max);
      } else {
        this.setMax(max);
      }
    }
  }

  /**
   * Parse the provided `ElementDefinitionBaseComponent` JSON to instantiate the ElementDefinitionBaseComponent data model.
   *
   * @param sourceJson - JSON representing FHIR `ElementDefinitionBaseComponent`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to ElementDefinitionBaseComponent
   * @returns ElementDefinitionBaseComponent data model or undefined for `ElementDefinitionBaseComponent`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): ElementDefinitionBaseComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'ElementDefinitionBaseComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new ElementDefinitionBaseComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'path';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setPathElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'min';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UnsignedIntType | undefined = fhirParser.parseUnsignedIntType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setMinElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'max';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setMaxElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_REQD_IN_JSON} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * ElementDefinition.base.path Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Path that identifies the base element
   * - **Definition:** The Path that identifies the base element - this matches the ElementDefinition.path for that element. Across FHIR, there is only one base definition of any element - that is, an element definition on a [StructureDefinition](https://hl7.org/fhir/structuredefinition.html#) without a StructureDefinition.base.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private path: StringType | null;

  /**
   * ElementDefinition.base.min Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Min cardinality of the base element
   * - **Definition:** Minimum cardinality of the base element identified by the path.
   * - **Comment:** This is provided for consistency with max, and may affect code generation of mandatory elements of the base resource are generated differently (some reference implementations have done this).
   * - **FHIR Type:** `unsignedInt`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private min: UnsignedIntType | null;

  /**
   * ElementDefinition.base.max Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Max cardinality of the base element
   * - **Definition:** Maximum cardinality of the base element identified by the path.
   * - **Comment:** This is provided to code generation, since the serialization representation in JSON differs depending on whether the base element has max > 1. Also, some forms of code generation may differ.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private max: StringType | null;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `path` property value as a StringType object if defined; else null
   */
  public getPathElement(): StringType | null {
    return this.path;
  }

  /**
   * Assigns the provided PrimitiveType value to the `path` property.
   *
   * @param element - the `path` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPathElement(element: StringType): this {
    assertIsDefined<StringType>(element, `ElementDefinition.base.path is required`);
    const optErrMsg = `Invalid ElementDefinition.base.path; Provided value is not an instance of StringType.`;
    assertFhirType<StringType>(element, StringType, optErrMsg);
    this.path = element;
    return this;
  }

  /**
   * @returns `true` if the `path` property exists and has a value; `false` otherwise
   */
  public hasPathElement(): boolean {
    return isDefined<StringType>(this.path) && !this.path.isEmpty();
  }

  /**
   * @returns the `path` property value as a fhirString if defined; else null
   */
  public getPath(): fhirString | null {
    if (this.path?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.path.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the `path` property.
   *
   * @param value - the `path` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPath(value: fhirString): this {
    assertIsDefined<fhirString>(value, `ElementDefinition.base.path is required`);
    const optErrMsg = `Invalid ElementDefinition.base.path (${String(value)})`;
    this.path = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    return this;
  }

  /**
   * @returns `true` if the `path` property exists and has a value; `false` otherwise
   */
  public hasPath(): boolean {
    return this.hasPathElement();
  }

  /**
   * @returns the `min` property value as a UnsignedIntType object if defined; else null
   */
  public getMinElement(): UnsignedIntType | null {
    return this.min;
  }

  /**
   * Assigns the provided PrimitiveType value to the `min` property.
   *
   * @param element - the `min` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMinElement(element: UnsignedIntType): this {
    assertIsDefined<UnsignedIntType>(element, `ElementDefinition.base.min is required`);
    const optErrMsg = `Invalid ElementDefinition.base.min; Provided value is not an instance of UnsignedIntType.`;
    assertFhirType<UnsignedIntType>(element, UnsignedIntType, optErrMsg);
    this.min = element;
    return this;
  }

  /**
   * @returns `true` if the `min` property exists and has a value; `false` otherwise
   */
  public hasMinElement(): boolean {
    return isDefined<UnsignedIntType>(this.min) && !this.min.isEmpty();
  }

  /**
   * @returns the `min` property value as a fhirUnsignedInt if defined; else null
   */
  public getMin(): fhirUnsignedInt | null {
    if (this.min?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.min.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the `min` property.
   *
   * @param value - the `min` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMin(value: fhirUnsignedInt): this {
    assertIsDefined<fhirUnsignedInt>(value, `ElementDefinition.base.min is required`);
    const optErrMsg = `Invalid ElementDefinition.base.min (${String(value)})`;
    this.min = new UnsignedIntType(parseFhirPrimitiveData(value, fhirUnsignedIntSchema, optErrMsg));
    return this;
  }

  /**
   * @returns `true` if the `min` property exists and has a value; `false` otherwise
   */
  public hasMin(): boolean {
    return this.hasMinElement();
  }

  /**
   * @returns the `max` property value as a StringType object if defined; else null
   */
  public getMaxElement(): StringType | null {
    return this.max;
  }

  /**
   * Assigns the provided PrimitiveType value to the `max` property.
   *
   * @param element - the `max` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMaxElement(element: StringType): this {
    assertIsDefined<StringType>(element, `ElementDefinition.base.max is required`);
    const optErrMsg = `Invalid ElementDefinition.base.max; Provided value is not an instance of StringType.`;
    assertFhirType<StringType>(element, StringType, optErrMsg);
    this.max = element;
    return this;
  }

  /**
   * @returns `true` if the `max` property exists and has a value; `false` otherwise
   */
  public hasMaxElement(): boolean {
    return isDefined<StringType>(this.max) && !this.max.isEmpty();
  }

  /**
   * @returns the `max` property value as a fhirString if defined; else null
   */
  public getMax(): fhirString | null {
    if (this.max?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.max.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the `max` property.
   *
   * @param value - the `max` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMax(value: fhirString): this {
    assertIsDefined<fhirString>(value, `ElementDefinition.base.max is required`);
    const optErrMsg = `Invalid ElementDefinition.base.max (${String(value)})`;
    this.max = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    return this;
  }

  /**
   * @returns `true` if the `max` property exists and has a value; `false` otherwise
   */
  public hasMax(): boolean {
    return this.hasMaxElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'ElementDefinition.base';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.path,
      this.min,
      this.max,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): ElementDefinitionBaseComponent {
    const dest = new ElementDefinitionBaseComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: ElementDefinitionBaseComponent): void {
    super.copyValues(dest);
    dest.path = this.path ? this.path.copy() : null;
    dest.min = this.min ? this.min.copy() : null;
    dest.max = this.max ? this.max.copy() : null;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasPathElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirString>(this.getPathElement()!, 'path', jsonObj);
    } else {
      missingReqdProperties.push(`ElementDefinition.base.path`);
    }

    if (this.hasMinElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirUnsignedInt>(this.getMinElement()!, 'min', jsonObj);
    } else {
      missingReqdProperties.push(`ElementDefinition.base.min`);
    }

    if (this.hasMaxElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirString>(this.getMaxElement()!, 'max', jsonObj);
    } else {
      missingReqdProperties.push(`ElementDefinition.base.max`);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_DO_NOT_EXIST} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
/**
 * ElementDefinitionTypeComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Data type and Profile for this element
 * - **Definition:** The data type or resource that the value of this element is permitted to be.
 * - **Comment:** The Type of the element can be left blank in a differential constraint, in which case the type is inherited from the resource. Abstract types are not permitted to appear as a type when multiple types are listed.  (I.e. Abstract types cannot be part of a choice).
 *
 * @category Data Models: ComplexType
 * @see [FHIR ElementDefinition](http://hl7.org/fhir/StructureDefinition/ElementDefinition)
 */
export class ElementDefinitionTypeComponent extends DataType implements IDataType {
  constructor(code: UriType | fhirUri | null = null) {
    super();

    this.resourceAggregationModeEnum = new ResourceAggregationModeEnum();
    this.referenceVersionRulesEnum = new ReferenceVersionRulesEnum();

    this.code = null;
    if (isDefined<UriType | fhirUri>(code)) {
      if (code instanceof PrimitiveType) {
        this.setCodeElement(code);
      } else {
        this.setCode(code);
      }
    }
  }

  /**
   * Parse the provided `ElementDefinitionTypeComponent` JSON to instantiate the ElementDefinitionTypeComponent data model.
   *
   * @param sourceJson - JSON representing FHIR `ElementDefinitionTypeComponent`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to ElementDefinitionTypeComponent
   * @returns ElementDefinitionTypeComponent data model or undefined for `ElementDefinitionTypeComponent`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): ElementDefinitionTypeComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'ElementDefinitionTypeComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new ElementDefinitionTypeComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'code';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = fhirParser.parseUriType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setCodeElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'profile';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: CanonicalType | undefined = fhirParser.parseCanonicalType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addProfileElement(datatype);
        }
      });
    }

    fieldName = 'targetProfile';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: CanonicalType | undefined = fhirParser.parseCanonicalType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addTargetProfileElement(datatype);
        }
      });
    }

    fieldName = 'aggregation';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: CodeType | undefined = fhirParser.parseCodeType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addAggregationElement(datatype);
        }
      });
    }

    fieldName = 'versioning';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setVersioningElement(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_REQD_IN_JSON} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * ElementDefinition.type.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Data type or Resource (reference to definition)
   * - **Definition:** URL of Data type or Resource that is a(or the) type used for this element. References are URLs that are relative to http://hl7.org/fhir/StructureDefinition e.g. "string" is a reference to http://hl7.org/fhir/StructureDefinition/string. Absolute URLs are only allowed in logical models.
   * - **Comment:** If the element is a reference to another resource, this element contains "Reference", and the targetProfile element defines what resources can be referenced. The targetProfile may be a reference to the general definition of a resource (e.g. http://hl7.org/fhir/StructureDefinition/Patient).
   * - **FHIR Type:** `uri`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code: UriType | null;

  /**
   * ElementDefinition.type.profile Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Profiles (StructureDefinition or IG) - one must apply
   * - **Definition:** Identifies a profile structure or implementation Guide that applies to the datatype this element refers to. If any profiles are specified, then the content must conform to at least one of them. The URL can be a local reference - to a contained StructureDefinition, or a reference to another StructureDefinition or Implementation Guide by a canonical URL. When an implementation guide is specified, the type SHALL conform to at least one profile defined in the implementation guide.
   * - **Comment:** It is possible to profile  backbone element (e.g. part of a resource), using the [http://hl7.org/fhir/StructureDefinition/elementdefinition-profile-element](http://hl7.org/fhir/extensions/https://hl7.org/fhir/StructureDefinition-elementdefinition-profile-element.html) extension.
   * - **FHIR Type:** `canonical`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/StructureDefinition',
   *       'http://hl7.org/fhir/StructureDefinition/ImplementationGuide',
   *     ]
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private profile?: CanonicalType[] | undefined;

  /**
   * ElementDefinition.type.targetProfile Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Profile (StructureDefinition or IG) on the Reference/canonical target - one must apply
   * - **Definition:** Used when the type is "Reference" or "canonical", and identifies a profile structure or implementation Guide that applies to the target of the reference this element refers to. If any profiles are specified, then the content must conform to at least one of them. The URL can be a local reference - to a contained StructureDefinition, or a reference to another StructureDefinition or Implementation Guide by a canonical URL. When an implementation guide is specified, the target resource SHALL conform to at least one profile defined in the implementation guide.
   * - **FHIR Type:** `canonical`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/StructureDefinition',
   *       'http://hl7.org/fhir/StructureDefinition/ImplementationGuide',
   *     ]
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private targetProfile?: CanonicalType[] | undefined;

  /**
   * FHIR CodeSystem: ResourceAggregationMode
   *
   * @see {@link ResourceAggregationModeEnum }
   */
  private readonly resourceAggregationModeEnum: ResourceAggregationModeEnum;

  /**
   * ElementDefinition.type.aggregation Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** contained | referenced | bundled - how aggregated
   * - **Definition:** If the type is a reference to another resource, how the resource is or can be aggregated - is it a contained resource, or a reference, and if the context is a bundle, is it included in the bundle.
   * - **Comment:** See [Aggregation Rules](https://hl7.org/fhir/elementdefinition.html#aggregation) for further clarification.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link ResourceAggregationModeEnum }
   */
  private aggregation?: EnumCodeType[] | undefined;

  /**
   * FHIR CodeSystem: ReferenceVersionRules
   *
   * @see {@link ReferenceVersionRulesEnum }
   */
  private readonly referenceVersionRulesEnum: ReferenceVersionRulesEnum;

  /**
   * ElementDefinition.type.versioning Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** either | independent | specific
   * - **Definition:** Whether this reference needs to be version specific or version independent, or whether either can be used.
   * - **Comment:** The base specification never makes a rule as to which form is allowed, but implementation guides may do this. See [Aggregation Rules](https://hl7.org/fhir/elementdefinition.html#aggregation) for further clarification.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link ReferenceVersionRulesEnum }
   */
  private versioning?: EnumCodeType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `code` property value as a UriType object if defined; else null
   */
  public getCodeElement(): UriType | null {
    return this.code;
  }

  /**
   * Assigns the provided PrimitiveType value to the `code` property.
   *
   * @param element - the `code` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCodeElement(element: UriType): this {
    assertIsDefined<UriType>(element, `ElementDefinition.type.code is required`);
    const optErrMsg = `Invalid ElementDefinition.type.code; Provided value is not an instance of UriType.`;
    assertFhirType<UriType>(element, UriType, optErrMsg);
    this.code = element;
    return this;
  }

  /**
   * @returns `true` if the `code` property exists and has a value; `false` otherwise
   */
  public hasCodeElement(): boolean {
    return isDefined<UriType>(this.code) && !this.code.isEmpty();
  }

  /**
   * @returns the `code` property value as a fhirUri if defined; else null
   */
  public getCode(): fhirUri | null {
    if (this.code?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.code.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the `code` property.
   *
   * @param value - the `code` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCode(value: fhirUri): this {
    assertIsDefined<fhirUri>(value, `ElementDefinition.type.code is required`);
    const optErrMsg = `Invalid ElementDefinition.type.code (${String(value)})`;
    this.code = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    return this;
  }

  /**
   * @returns `true` if the `code` property exists and has a value; `false` otherwise
   */
  public hasCode(): boolean {
    return this.hasCodeElement();
  }

  /**
   * @returns the `profile` property value as a CanonicalType array
   */
  public getProfileElement(): CanonicalType[] {
    return this.profile ?? ([] as CanonicalType[]);
  }

  /**
   * Assigns the provided CanonicalType array value to the `profile` property.
   *
   * @param element - the `profile` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setProfileElement(element: CanonicalType[] | undefined): this {
    if (isDefinedList<CanonicalType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.type.profile; Provided value array has an element that is not an instance of CanonicalType.`;
      assertFhirTypeList<CanonicalType>(element, CanonicalType, optErrMsg);
      this.profile = element;
    } else {
      this.profile = undefined;
    }
    return this;
  }

  /**
   * Add the provided CanonicalType value to the `profile` array property.
   *
   * @param element - the `profile` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addProfileElement(element: CanonicalType | undefined): this {
    if (isDefined<CanonicalType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.type.profile; Provided element is not an instance of CanonicalType.`;
      assertFhirType<CanonicalType>(element, CanonicalType, optErrMsg);
      this.initProfile();
      this.profile?.push(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `profile` property exists and has a value; `false` otherwise
   */
  public hasProfileElement(): boolean {
    return isDefinedList<CanonicalType>(this.profile) && this.profile.some((item: CanonicalType) => !item.isEmpty());
  }

  /**
   * @returns the `profile` property value as a fhirCanonical array
   */
  public getProfile(): fhirCanonical[] {
    this.initProfile();
    const profileValues = [] as fhirCanonical[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.profile!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        profileValues.push(value);
      }
    }
    return profileValues;
  }

  /**
   * Assigns the provided primitive value array to the `profile` property.
   *
   * @param value - the `profile` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setProfile(value: fhirCanonical[] | undefined): this {
    if (isDefinedList<fhirCanonical>(value)) {
      const profileElements = [] as CanonicalType[];
      for (const profileValue of value) {
        const optErrMsg = `Invalid ElementDefinition.type.profile array item (${String(profileValue)})`;
        const element = new CanonicalType(parseFhirPrimitiveData(profileValue, fhirCanonicalSchema, optErrMsg));
        profileElements.push(element);
      }
      this.profile = profileElements;
    } else {
      this.profile = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the `profile` array property.
   *
   * @param value - the `profile` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addProfile(value: fhirCanonical | undefined): this {
    if (isDefined<fhirCanonical>(value)) {
      const optErrMsg = `Invalid ElementDefinition.type.profile array item (${String(value)})`;
      const element = new CanonicalType(parseFhirPrimitiveData(value, fhirCanonicalSchema, optErrMsg));
      this.initProfile();
      this.addProfileElement(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `profile` property exists and has a value; `false` otherwise
   */
  public hasProfile(): boolean {
    return this.hasProfileElement();
  }

  /**
   * Initialize the `profile` property
   */
  private initProfile(): void {
    if (!this.hasProfile()) {
      this.profile = [] as CanonicalType[];
    }
  }

  /**
   * @returns the `targetProfile` property value as a CanonicalType array
   */
  public getTargetProfileElement(): CanonicalType[] {
    return this.targetProfile ?? ([] as CanonicalType[]);
  }

  /**
   * Assigns the provided CanonicalType array value to the `targetProfile` property.
   *
   * @param element - the `targetProfile` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTargetProfileElement(element: CanonicalType[] | undefined): this {
    if (isDefinedList<CanonicalType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.type.targetProfile; Provided value array has an element that is not an instance of CanonicalType.`;
      assertFhirTypeList<CanonicalType>(element, CanonicalType, optErrMsg);
      this.targetProfile = element;
    } else {
      this.targetProfile = undefined;
    }
    return this;
  }

  /**
   * Add the provided CanonicalType value to the `targetProfile` array property.
   *
   * @param element - the `targetProfile` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addTargetProfileElement(element: CanonicalType | undefined): this {
    if (isDefined<CanonicalType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.type.targetProfile; Provided element is not an instance of CanonicalType.`;
      assertFhirType<CanonicalType>(element, CanonicalType, optErrMsg);
      this.initTargetProfile();
      this.targetProfile?.push(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `targetProfile` property exists and has a value; `false` otherwise
   */
  public hasTargetProfileElement(): boolean {
    return isDefinedList<CanonicalType>(this.targetProfile) && this.targetProfile.some((item: CanonicalType) => !item.isEmpty());
  }

  /**
   * @returns the `targetProfile` property value as a fhirCanonical array
   */
  public getTargetProfile(): fhirCanonical[] {
    this.initTargetProfile();
    const targetProfileValues = [] as fhirCanonical[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.targetProfile!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        targetProfileValues.push(value);
      }
    }
    return targetProfileValues;
  }

  /**
   * Assigns the provided primitive value array to the `targetProfile` property.
   *
   * @param value - the `targetProfile` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTargetProfile(value: fhirCanonical[] | undefined): this {
    if (isDefinedList<fhirCanonical>(value)) {
      const targetProfileElements = [] as CanonicalType[];
      for (const targetProfileValue of value) {
        const optErrMsg = `Invalid ElementDefinition.type.targetProfile array item (${String(targetProfileValue)})`;
        const element = new CanonicalType(parseFhirPrimitiveData(targetProfileValue, fhirCanonicalSchema, optErrMsg));
        targetProfileElements.push(element);
      }
      this.targetProfile = targetProfileElements;
    } else {
      this.targetProfile = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the `targetProfile` array property.
   *
   * @param value - the `targetProfile` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addTargetProfile(value: fhirCanonical | undefined): this {
    if (isDefined<fhirCanonical>(value)) {
      const optErrMsg = `Invalid ElementDefinition.type.targetProfile array item (${String(value)})`;
      const element = new CanonicalType(parseFhirPrimitiveData(value, fhirCanonicalSchema, optErrMsg));
      this.initTargetProfile();
      this.addTargetProfileElement(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `targetProfile` property exists and has a value; `false` otherwise
   */
  public hasTargetProfile(): boolean {
    return this.hasTargetProfileElement();
  }

  /**
   * Initialize the `targetProfile` property
   */
  private initTargetProfile(): void {
    if (!this.hasTargetProfile()) {
      this.targetProfile = [] as CanonicalType[];
    }
  }

  /**
   * @returns the `aggregation` property value as a EnumCodeType array
   *
   * @see CodeSystem Enumeration: {@link ResourceAggregationModeEnum }
   */
  public getAggregationEnumType(): EnumCodeType[] {
    return this.aggregation ?? ([] as EnumCodeType[]);
  }

  /**
   * Assigns the provided EnumCodeType array value to the `aggregation` property.
   *
   * @param enumType - the `aggregation` array value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ResourceAggregationModeEnum }
   */
  public setAggregationEnumType(enumType: EnumCodeType[] | undefined): this {
    if (isDefinedList<EnumCodeType>(enumType)) {
      const errMsgPrefix = `Invalid ElementDefinition.type.aggregation`;
      assertEnumCodeTypeList<ResourceAggregationModeEnum>(enumType, ResourceAggregationModeEnum, errMsgPrefix);
      this.aggregation = enumType;
    } else {
      this.aggregation = undefined;
    }
    return this;
  }

  /**
   * Add the provided EnumCodeType value to the `aggregation` array property.
   *
   * @param enumType - the `aggregation` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   *
   * @see CodeSystem Enumeration: {@link ResourceAggregationModeEnum }
   */
  public addAggregationEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = `Invalid ElementDefinition.type.aggregation`;
      assertEnumCodeType<ResourceAggregationModeEnum>(enumType, ResourceAggregationModeEnum, errMsgPrefix);
      this.initAggregation();
      this.aggregation?.push(enumType);
    }
    return this;
  }

  /**
   * @returns `true` if the `aggregation` property exists and has a value; `false` otherwise
   */
  public hasAggregationEnumType(): boolean {
    return isDefinedList<EnumCodeType>(this.aggregation) && this.aggregation.some((item: EnumCodeType) => !item.isEmpty()) && this.aggregation.every((item: EnumCodeType) => item.fhirCodeEnumeration.length > 0);
  }

  /**
   * @returns the `aggregation` property value as a CodeType array
   *
   * @see CodeSystem Enumeration: {@link ResourceAggregationModeEnum }
   */
  public getAggregationElement(): CodeType[] {
    if (this.aggregation === undefined) {
      return [] as CodeType[];
    }
    return this.aggregation as CodeType[];
  }

  /**
   * Assigns the provided PrimitiveType array value to the `aggregation` property.
   *
   * @param element - the `aggregation` array value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ResourceAggregationModeEnum }
   */
  public setAggregationElement(element: CodeType[] | undefined): this {
    if (isDefinedList<CodeType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.type.aggregation; Provided element array has an element that is not an instance of CodeType.`;
      assertFhirTypeList<CodeType>(element, CodeType, optErrMsg);
      const enumCodeTypes = [] as EnumCodeType[];
      element.forEach((type: CodeType) => {
        enumCodeTypes.push(new EnumCodeType(type, this.resourceAggregationModeEnum));
      });
      this.aggregation = enumCodeTypes;
    } else {
      this.aggregation = undefined;
    }
    return this;
  }

  /**
   * Add the provided PrimitiveType value to the `aggregation` array property.
   *
   * @param element - the `aggregation` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ResourceAggregationModeEnum }
   */
  public addAggregationElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.type.aggregation; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.initAggregation();
      this.aggregation?.push(new EnumCodeType(element, this.resourceAggregationModeEnum));
    }
    return this;
  }

  /**
   * @returns `true` if the `aggregation` property exists and has a value; `false` otherwise
   */
  public hasAggregationElement(): boolean {
    return this.hasAggregationEnumType();
  }

  /**
   * @returns the `aggregation` property value as a fhirCode array
   *
   * @see CodeSystem Enumeration: {@link ResourceAggregationModeEnum }
   */
  public getAggregation(): fhirCode[] {
    if (this.aggregation === undefined) {
      return [] as fhirCode[];
    }
    const values = [] as fhirCode[];
    for (const item of this.aggregation) {
      values.push(item.fhirCode.code);
    }
    return values;
  }

  /**
   * Assigns the provided primitive value array to the `aggregation` property.
   *
   * @param value - the `aggregation` value array
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link ResourceAggregationModeEnum }
   */
  public setAggregation(value: fhirCode[] | undefined): this {
    if (isDefinedList<fhirCode>(value)) {
      const enumCodeTypes = [] as EnumCodeType[];
      const optErrMsg = `Invalid ElementDefinition.type.aggregation; Provided value is not an instance of fhirCode.`;
      value.forEach((val: fhirCode) => {
        enumCodeTypes.push(new EnumCodeType(parseFhirPrimitiveData(val, fhirCodeSchema, optErrMsg), this.resourceAggregationModeEnum));
      });
      this.aggregation = enumCodeTypes;
    } else {
      this.aggregation = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the `aggregation` array property.
   *
   * @param value - the `aggregation` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link ResourceAggregationModeEnum }
   */
  public addAggregation(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      this.initAggregation();
      const optErrMsg = `Invalid ElementDefinition.type.aggregation; Provided value is not an instance of fhirCode.`;
      this.aggregation?.push(new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.resourceAggregationModeEnum));
    }
    return this;
  }

  /**
   * @returns `true` if the `aggregation` property exists and has a value; `false` otherwise
   */
  public hasAggregation(): boolean {
    return this.hasAggregationEnumType();
  }

  /**
   * Initialize the aggregation property
   */
  private initAggregation(): void {
    if(!this.hasAggregationEnumType()) {
      this.aggregation = [] as EnumCodeType[];
    }
  }

  /**
   * @returns the `versioning` property value as a EnumCodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link ReferenceVersionRulesEnum }
   */
  public getVersioningEnumType(): EnumCodeType | undefined {
    return this.versioning;
  }

  /**
   * Assigns the provided EnumCodeType value to the `versioning` property.
   *
   * @param enumType - the `versioning` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code values
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ReferenceVersionRulesEnum }
   */
  public setVersioningEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid ElementDefinition.type.versioning';
      assertEnumCodeType<ReferenceVersionRulesEnum>(enumType, ReferenceVersionRulesEnum, errMsgPrefix);
      this.versioning = enumType;
    } else {
      this.versioning = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `versioning` property exists and has a value; `false` otherwise
   */
  public hasVersioningEnumType(): boolean {
    return isDefined<EnumCodeType>(this.versioning) && !this.versioning.isEmpty() && this.versioning.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the `versioning` property value as a CodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link ReferenceVersionRulesEnum }
   */
  public getVersioningElement(): CodeType | undefined {
    if (this.versioning === undefined) {
      return undefined;
    }
    return this.versioning as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the `versioning` property.
   *
   * @param element - the `versioning` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ReferenceVersionRulesEnum }
   */
  public setVersioningElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.type.versioning; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.versioning = new EnumCodeType(element, this.referenceVersionRulesEnum);
    } else {
      this.versioning = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `versioning` property exists and has a value; `false` otherwise
   */
  public hasVersioningElement(): boolean {
    return this.hasVersioningEnumType();
  }

  /**
   * @returns the `versioning` property value as a fhirCode if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link ReferenceVersionRulesEnum }
   */
  public getVersioning(): fhirCode | undefined {
    if (this.versioning === undefined) {
      return undefined;
    }
    return this.versioning.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the `versioning` property.
   *
   * @param value - the `versioning` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link ReferenceVersionRulesEnum }
   */
  public setVersioning(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid ElementDefinition.type.versioning; Provided value is not an instance of fhirCode.`;
      this.versioning = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.referenceVersionRulesEnum);
    } else {
      this.versioning = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `versioning` property exists and has a value; `false` otherwise
   */
  public hasVersioning(): boolean {
    return this.hasVersioningEnumType();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'ElementDefinition.type';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.code,
      this.profile,
      this.targetProfile,
      this.aggregation,
      this.versioning,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): ElementDefinitionTypeComponent {
    const dest = new ElementDefinitionTypeComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: ElementDefinitionTypeComponent): void {
    super.copyValues(dest);
    dest.code = this.code ? this.code.copy() : null;
    const profileList = copyListValues<CanonicalType>(this.profile);
    dest.profile = profileList.length === 0 ? undefined : profileList;
    const targetProfileList = copyListValues<CanonicalType>(this.targetProfile);
    dest.targetProfile = targetProfileList.length === 0 ? undefined : targetProfileList;
    const aggregationList = copyListValues<EnumCodeType>(this.aggregation);
    dest.aggregation = aggregationList.length === 0 ? undefined : aggregationList;
    dest.versioning = this.versioning?.copy();
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasCodeElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirUri>(this.getCodeElement()!, 'code', jsonObj);
    } else {
      missingReqdProperties.push(`ElementDefinition.type.code`);
    }

    if (this.hasProfile()) {
      setFhirPrimitiveListJson(this.getProfileElement(), 'profile', jsonObj);
    }

    if (this.hasTargetProfile()) {
      setFhirPrimitiveListJson(this.getTargetProfileElement(), 'targetProfile', jsonObj);
    }

    if (this.hasAggregationElement()) {
      setFhirPrimitiveListJson<fhirCode>(this.getAggregationElement(), 'aggregation', jsonObj);
    }

    if (this.hasVersioningElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getVersioningElement()!, 'versioning', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_DO_NOT_EXIST} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
/**
 * ElementDefinitionExampleComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Example value (as defined for type)
 * - **Definition:** A sample value for this element demonstrating the type of information that would typically be found in the element.
 * - **Comment:** Examples will most commonly be present for data where it\'s not implicitly obvious from either the data type or value set what the values might be.  (I.e. Example values for dates or quantities would generally be unnecessary.)  If the example value is fully populated, the publication tool can generate an instance automatically.
 *
 * @category Data Models: ComplexType
 * @see [FHIR ElementDefinition](http://hl7.org/fhir/StructureDefinition/ElementDefinition)
 */
export class ElementDefinitionExampleComponent extends DataType implements IDataType {
  constructor(label: StringType | fhirString | null = null, value: IDataType | null = null) {
    super();

    this.label = null;
    if (isDefined<StringType | fhirString>(label)) {
      if (label instanceof PrimitiveType) {
        this.setLabelElement(label);
      } else {
        this.setLabel(label);
      }
    }

    this.value = null;
    if (isDefined<IDataType>(value)) {
      this.setValue(value);
    }

  }

  /**
   * Parse the provided `ElementDefinitionExampleComponent` JSON to instantiate the ElementDefinitionExampleComponent data model.
   *
   * @param sourceJson - JSON representing FHIR `ElementDefinitionExampleComponent`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to ElementDefinitionExampleComponent
   * @returns ElementDefinitionExampleComponent data model or undefined for `ElementDefinitionExampleComponent`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): ElementDefinitionExampleComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'ElementDefinitionExampleComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new ElementDefinitionExampleComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    

    const classMetadata: DecoratorMetadataObject | null = ElementDefinitionExampleComponent[Symbol.metadata];
    const errorMessage = `DecoratorMetadataObject does not exist for ElementDefinitionExampleComponent`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    const missingReqdProperties: string[] = [];

    fieldName = 'label';
    sourceField = `${optSourceValue}.${fieldName}`;
    const primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setLabelElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'value[x]';
    sourceField = `${optSourceValue}.${fieldName}`;
    const value: IDataType | undefined = fhirParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    if (value === undefined) {
      missingReqdProperties.push(sourceField);
    } else {
      instance.setValue(value);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_REQD_IN_JSON} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * ElementDefinition.example.label Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Describes the purpose of this example
   * - **Definition:** Describes the purpose of this example among the set of examples.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private label: StringType | null;

  /**
   * ElementDefinition.example.value[x] Element
   *
   * @decorator `@ChoiceDataTypesMeta('ElementDefinition.example.value[x]', ['base64Binary','boolean','canonical','code','date','dateTime','decimal','id','instant','integer','integer64','markdown','oid','positiveInt','string','time','unsignedInt','uri','url','uuid','Address','Age','Annotation','Attachment','CodeableConcept','CodeableReference','Coding','ContactPoint','Count','Distance','Duration','HumanName','Identifier','Money','Period','Quantity','Range','Ratio','RatioRange','Reference','SampledData','Signature','Timing','ContactDetail','DataRequirement','Expression','ParameterDefinition','RelatedArtifact','TriggerDefinition','UsageContext','Availability','ExtendedContactDetail','Dosage','Meta',]`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Value of Example (one of allowed types)
   * - **Definition:** The actual value for the element, which must be one of the types allowed for this element.
   * - **FHIR Types:**
   *     'base64Binary',
   *     'boolean',
   *     'canonical',
   *     'code',
   *     'date',
   *     'dateTime',
   *     'decimal',
   *     'id',
   *     'instant',
   *     'integer',
   *     'integer64',
   *     'markdown',
   *     'oid',
   *     'positiveInt',
   *     'string',
   *     'time',
   *     'unsignedInt',
   *     'uri',
   *     'url',
   *     'uuid',
   *     'Address',
   *     'Age',
   *     'Annotation',
   *     'Attachment',
   *     'CodeableConcept',
   *     'CodeableReference',
   *     'Coding',
   *     'ContactPoint',
   *     'Count',
   *     'Distance',
   *     'Duration',
   *     'HumanName',
   *     'Identifier',
   *     'Money',
   *     'Period',
   *     'Quantity',
   *     'Range',
   *     'Ratio',
   *     'RatioRange',
   *     'Reference',
   *     'SampledData',
   *     'Signature',
   *     'Timing',
   *     'ContactDetail',
   *     'DataRequirement',
   *     'Expression',
   *     'ParameterDefinition',
   *     'RelatedArtifact',
   *     'TriggerDefinition',
   *     'UsageContext',
   *     'Availability',
   *     'ExtendedContactDetail',
   *     'Dosage',
   *     'Meta',
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('ElementDefinition.example.value[x]',[
    'base64Binary',
    'boolean',
    'canonical',
    'code',
    'date',
    'dateTime',
    'decimal',
    'id',
    'instant',
    'integer',
    'integer64',
    'markdown',
    'oid',
    'positiveInt',
    'string',
    'time',
    'unsignedInt',
    'uri',
    'url',
    'uuid',
    'Address',
    'Age',
    'Annotation',
    'Attachment',
    'CodeableConcept',
    'CodeableReference',
    'Coding',
    'ContactPoint',
    'Count',
    'Distance',
    'Duration',
    'HumanName',
    'Identifier',
    'Money',
    'Period',
    'Quantity',
    'Range',
    'Ratio',
    'RatioRange',
    'Reference',
    'SampledData',
    'Signature',
    'Timing',
    'ContactDetail',
    'DataRequirement',
    'Expression',
    'ParameterDefinition',
    'RelatedArtifact',
    'TriggerDefinition',
    'UsageContext',
    'Availability',
    'ExtendedContactDetail',
    'Dosage',
    'Meta',
  ])
  private value: IDataType | null;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `label` property value as a StringType object if defined; else null
   */
  public getLabelElement(): StringType | null {
    return this.label;
  }

  /**
   * Assigns the provided PrimitiveType value to the `label` property.
   *
   * @param element - the `label` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLabelElement(element: StringType): this {
    assertIsDefined<StringType>(element, `ElementDefinition.example.label is required`);
    const optErrMsg = `Invalid ElementDefinition.example.label; Provided value is not an instance of StringType.`;
    assertFhirType<StringType>(element, StringType, optErrMsg);
    this.label = element;
    return this;
  }

  /**
   * @returns `true` if the `label` property exists and has a value; `false` otherwise
   */
  public hasLabelElement(): boolean {
    return isDefined<StringType>(this.label) && !this.label.isEmpty();
  }

  /**
   * @returns the `label` property value as a fhirString if defined; else null
   */
  public getLabel(): fhirString | null {
    if (this.label?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.label.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the `label` property.
   *
   * @param value - the `label` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLabel(value: fhirString): this {
    assertIsDefined<fhirString>(value, `ElementDefinition.example.label is required`);
    const optErrMsg = `Invalid ElementDefinition.example.label (${String(value)})`;
    this.label = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    return this;
  }

  /**
   * @returns `true` if the `label` property exists and has a value; `false` otherwise
   */
  public hasLabel(): boolean {
    return this.hasLabelElement();
  }

  /**
   * @returns the `value` property value as a DataType object; else null
   */
  public getValue(): IDataType | null {
    return this.value;
  }

  /**
   * Assigns the provided DataType object value to the `value` property.
   *
   * @decorator `@ChoiceDataTypes('ElementDefinition.example.value[x]')`
   *
   * @param value - the `value` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  @ChoiceDataTypes('ElementDefinition.example.value[x]')
  public setValue(value: IDataType): this {
    assertIsDefined<IDataType>(value, `ElementDefinition.example.value[x] is required`);
    // assertFhirType<IDataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
    this.value = value;
    return this;
  }

  /**
   * @returns `true` if the `value` property exists and has a value; `false` otherwise
   */
  public hasValue(): boolean {
    return isDefined<IDataType>(this.value) && !this.value.isEmpty();
  }

  // *** NOTE ***
  // Following choice datatype-specific "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the `value` property value as a Base64BinaryType object if defined; else null
   */
  public getValueBase64BinaryType(): Base64BinaryType | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Base64BinaryType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected Base64BinaryType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a Base64BinaryType and has a value; `false` otherwise
   */
  public hasValueBase64BinaryType(): boolean {
    return this.hasValue() && this.value instanceof Base64BinaryType;
  }

  /**
   * @returns the `value` property value as a BooleanType object if defined; else null
   */
  public getValueBooleanType(): BooleanType | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof BooleanType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected BooleanType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a BooleanType and has a value; `false` otherwise
   */
  public hasValueBooleanType(): boolean {
    return this.hasValue() && this.value instanceof BooleanType;
  }

  /**
   * @returns the `value` property value as a CanonicalType object if defined; else null
   */
  public getValueCanonicalType(): CanonicalType | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof CanonicalType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected CanonicalType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a CanonicalType and has a value; `false` otherwise
   */
  public hasValueCanonicalType(): boolean {
    return this.hasValue() && this.value instanceof CanonicalType;
  }

  /**
   * @returns the `value` property value as a CodeType object if defined; else null
   */
  public getValueCodeType(): CodeType | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof CodeType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected CodeType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a CodeType and has a value; `false` otherwise
   */
  public hasValueCodeType(): boolean {
    return this.hasValue() && this.value instanceof CodeType;
  }

  /**
   * @returns the `value` property value as a DateType object if defined; else null
   */
  public getValueDateType(): DateType | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof DateType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected DateType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a DateType and has a value; `false` otherwise
   */
  public hasValueDateType(): boolean {
    return this.hasValue() && this.value instanceof DateType;
  }

  /**
   * @returns the `value` property value as a DateTimeType object if defined; else null
   */
  public getValueDateTimeType(): DateTimeType | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof DateTimeType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected DateTimeType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a DateTimeType and has a value; `false` otherwise
   */
  public hasValueDateTimeType(): boolean {
    return this.hasValue() && this.value instanceof DateTimeType;
  }

  /**
   * @returns the `value` property value as a DecimalType object if defined; else null
   */
  public getValueDecimalType(): DecimalType | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof DecimalType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected DecimalType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a DecimalType and has a value; `false` otherwise
   */
  public hasValueDecimalType(): boolean {
    return this.hasValue() && this.value instanceof DecimalType;
  }

  /**
   * @returns the `value` property value as a IdType object if defined; else null
   */
  public getValueIdType(): IdType | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof IdType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected IdType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a IdType and has a value; `false` otherwise
   */
  public hasValueIdType(): boolean {
    return this.hasValue() && this.value instanceof IdType;
  }

  /**
   * @returns the `value` property value as a InstantType object if defined; else null
   */
  public getValueInstantType(): InstantType | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof InstantType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected InstantType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a InstantType and has a value; `false` otherwise
   */
  public hasValueInstantType(): boolean {
    return this.hasValue() && this.value instanceof InstantType;
  }

  /**
   * @returns the `value` property value as a IntegerType object if defined; else null
   */
  public getValueIntegerType(): IntegerType | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof IntegerType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected IntegerType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a IntegerType and has a value; `false` otherwise
   */
  public hasValueIntegerType(): boolean {
    return this.hasValue() && this.value instanceof IntegerType;
  }

  /**
   * @returns the `value` property value as a Integer64Type object if defined; else null
   */
  public getValueInteger64Type(): Integer64Type | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Integer64Type)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected Integer64Type but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a Integer64Type and has a value; `false` otherwise
   */
  public hasValueInteger64Type(): boolean {
    return this.hasValue() && this.value instanceof Integer64Type;
  }

  /**
   * @returns the `value` property value as a MarkdownType object if defined; else null
   */
  public getValueMarkdownType(): MarkdownType | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof MarkdownType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected MarkdownType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a MarkdownType and has a value; `false` otherwise
   */
  public hasValueMarkdownType(): boolean {
    return this.hasValue() && this.value instanceof MarkdownType;
  }

  /**
   * @returns the `value` property value as a OidType object if defined; else null
   */
  public getValueOidType(): OidType | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof OidType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected OidType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a OidType and has a value; `false` otherwise
   */
  public hasValueOidType(): boolean {
    return this.hasValue() && this.value instanceof OidType;
  }

  /**
   * @returns the `value` property value as a PositiveIntType object if defined; else null
   */
  public getValuePositiveIntType(): PositiveIntType | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof PositiveIntType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected PositiveIntType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a PositiveIntType and has a value; `false` otherwise
   */
  public hasValuePositiveIntType(): boolean {
    return this.hasValue() && this.value instanceof PositiveIntType;
  }

  /**
   * @returns the `value` property value as a StringType object if defined; else null
   */
  public getValueStringType(): StringType | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof StringType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected StringType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a StringType and has a value; `false` otherwise
   */
  public hasValueStringType(): boolean {
    return this.hasValue() && this.value instanceof StringType;
  }

  /**
   * @returns the `value` property value as a TimeType object if defined; else null
   */
  public getValueTimeType(): TimeType | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof TimeType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected TimeType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a TimeType and has a value; `false` otherwise
   */
  public hasValueTimeType(): boolean {
    return this.hasValue() && this.value instanceof TimeType;
  }

  /**
   * @returns the `value` property value as a UnsignedIntType object if defined; else null
   */
  public getValueUnsignedIntType(): UnsignedIntType | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof UnsignedIntType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected UnsignedIntType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a UnsignedIntType and has a value; `false` otherwise
   */
  public hasValueUnsignedIntType(): boolean {
    return this.hasValue() && this.value instanceof UnsignedIntType;
  }

  /**
   * @returns the `value` property value as a UriType object if defined; else null
   */
  public getValueUriType(): UriType | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof UriType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected UriType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a UriType and has a value; `false` otherwise
   */
  public hasValueUriType(): boolean {
    return this.hasValue() && this.value instanceof UriType;
  }

  /**
   * @returns the `value` property value as a UrlType object if defined; else null
   */
  public getValueUrlType(): UrlType | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof UrlType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected UrlType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a UrlType and has a value; `false` otherwise
   */
  public hasValueUrlType(): boolean {
    return this.hasValue() && this.value instanceof UrlType;
  }

  /**
   * @returns the `value` property value as a UuidType object if defined; else null
   */
  public getValueUuidType(): UuidType | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof UuidType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected UuidType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a UuidType and has a value; `false` otherwise
   */
  public hasValueUuidType(): boolean {
    return this.hasValue() && this.value instanceof UuidType;
  }

  /**
   * @returns the `value` property value as a Address object if defined; else null
   */
  public getValueAddress(): Address | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Address)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected Address but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a Address and has a value; `false` otherwise
   */
  public hasValueAddress(): boolean {
    return this.hasValue() && this.value instanceof Address;
  }

  /**
   * @returns the `value` property value as a Age object if defined; else null
   */
  public getValueAge(): Age | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Age)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected Age but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a Age and has a value; `false` otherwise
   */
  public hasValueAge(): boolean {
    return this.hasValue() && this.value instanceof Age;
  }

  /**
   * @returns the `value` property value as a Annotation object if defined; else null
   */
  public getValueAnnotation(): Annotation | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Annotation)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected Annotation but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a Annotation and has a value; `false` otherwise
   */
  public hasValueAnnotation(): boolean {
    return this.hasValue() && this.value instanceof Annotation;
  }

  /**
   * @returns the `value` property value as a Attachment object if defined; else null
   */
  public getValueAttachment(): Attachment | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Attachment)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected Attachment but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a Attachment and has a value; `false` otherwise
   */
  public hasValueAttachment(): boolean {
    return this.hasValue() && this.value instanceof Attachment;
  }

  /**
   * @returns the `value` property value as a CodeableConcept object if defined; else null
   */
  public getValueCodeableConcept(): CodeableConcept | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof CodeableConcept)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected CodeableConcept but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a CodeableConcept and has a value; `false` otherwise
   */
  public hasValueCodeableConcept(): boolean {
    return this.hasValue() && this.value instanceof CodeableConcept;
  }

  /**
   * @returns the `value` property value as a CodeableReference object if defined; else null
   */
  public getValueCodeableReference(): CodeableReference | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof CodeableReference)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected CodeableReference but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a CodeableReference and has a value; `false` otherwise
   */
  public hasValueCodeableReference(): boolean {
    return this.hasValue() && this.value instanceof CodeableReference;
  }

  /**
   * @returns the `value` property value as a Coding object if defined; else null
   */
  public getValueCoding(): Coding | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Coding)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected Coding but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a Coding and has a value; `false` otherwise
   */
  public hasValueCoding(): boolean {
    return this.hasValue() && this.value instanceof Coding;
  }

  /**
   * @returns the `value` property value as a ContactPoint object if defined; else null
   */
  public getValueContactPoint(): ContactPoint | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof ContactPoint)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected ContactPoint but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a ContactPoint and has a value; `false` otherwise
   */
  public hasValueContactPoint(): boolean {
    return this.hasValue() && this.value instanceof ContactPoint;
  }

  /**
   * @returns the `value` property value as a Count object if defined; else null
   */
  public getValueCount(): Count | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Count)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected Count but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a Count and has a value; `false` otherwise
   */
  public hasValueCount(): boolean {
    return this.hasValue() && this.value instanceof Count;
  }

  /**
   * @returns the `value` property value as a Distance object if defined; else null
   */
  public getValueDistance(): Distance | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Distance)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected Distance but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a Distance and has a value; `false` otherwise
   */
  public hasValueDistance(): boolean {
    return this.hasValue() && this.value instanceof Distance;
  }

  /**
   * @returns the `value` property value as a Duration object if defined; else null
   */
  public getValueDuration(): Duration | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Duration)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected Duration but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a Duration and has a value; `false` otherwise
   */
  public hasValueDuration(): boolean {
    return this.hasValue() && this.value instanceof Duration;
  }

  /**
   * @returns the `value` property value as a HumanName object if defined; else null
   */
  public getValueHumanName(): HumanName | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof HumanName)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected HumanName but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a HumanName and has a value; `false` otherwise
   */
  public hasValueHumanName(): boolean {
    return this.hasValue() && this.value instanceof HumanName;
  }

  /**
   * @returns the `value` property value as a Identifier object if defined; else null
   */
  public getValueIdentifier(): Identifier | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Identifier)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected Identifier but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a Identifier and has a value; `false` otherwise
   */
  public hasValueIdentifier(): boolean {
    return this.hasValue() && this.value instanceof Identifier;
  }

  /**
   * @returns the `value` property value as a Money object if defined; else null
   */
  public getValueMoney(): Money | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Money)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected Money but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a Money and has a value; `false` otherwise
   */
  public hasValueMoney(): boolean {
    return this.hasValue() && this.value instanceof Money;
  }

  /**
   * @returns the `value` property value as a Period object if defined; else null
   */
  public getValuePeriod(): Period | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Period)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected Period but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a Period and has a value; `false` otherwise
   */
  public hasValuePeriod(): boolean {
    return this.hasValue() && this.value instanceof Period;
  }

  /**
   * @returns the `value` property value as a Quantity object if defined; else null
   */
  public getValueQuantity(): Quantity | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Quantity)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected Quantity but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a Quantity and has a value; `false` otherwise
   */
  public hasValueQuantity(): boolean {
    return this.hasValue() && this.value instanceof Quantity;
  }

  /**
   * @returns the `value` property value as a Range object if defined; else null
   */
  public getValueRange(): Range | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Range)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected Range but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a Range and has a value; `false` otherwise
   */
  public hasValueRange(): boolean {
    return this.hasValue() && this.value instanceof Range;
  }

  /**
   * @returns the `value` property value as a Ratio object if defined; else null
   */
  public getValueRatio(): Ratio | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Ratio)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected Ratio but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a Ratio and has a value; `false` otherwise
   */
  public hasValueRatio(): boolean {
    return this.hasValue() && this.value instanceof Ratio;
  }

  /**
   * @returns the `value` property value as a RatioRange object if defined; else null
   */
  public getValueRatioRange(): RatioRange | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof RatioRange)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected RatioRange but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a RatioRange and has a value; `false` otherwise
   */
  public hasValueRatioRange(): boolean {
    return this.hasValue() && this.value instanceof RatioRange;
  }

  /**
   * @returns the `value` property value as a Reference object if defined; else null
   */
  public getValueReference(): Reference | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Reference)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected Reference but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a Reference and has a value; `false` otherwise
   */
  public hasValueReference(): boolean {
    return this.hasValue() && this.value instanceof Reference;
  }

  /**
   * @returns the `value` property value as a SampledData object if defined; else null
   */
  public getValueSampledData(): SampledData | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof SampledData)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected SampledData but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a SampledData and has a value; `false` otherwise
   */
  public hasValueSampledData(): boolean {
    return this.hasValue() && this.value instanceof SampledData;
  }

  /**
   * @returns the `value` property value as a Signature object if defined; else null
   */
  public getValueSignature(): Signature | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Signature)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected Signature but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a Signature and has a value; `false` otherwise
   */
  public hasValueSignature(): boolean {
    return this.hasValue() && this.value instanceof Signature;
  }

  /**
   * @returns the `value` property value as a Timing object if defined; else null
   */
  public getValueTiming(): Timing | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Timing)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected Timing but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a Timing and has a value; `false` otherwise
   */
  public hasValueTiming(): boolean {
    return this.hasValue() && this.value instanceof Timing;
  }

  /**
   * @returns the `value` property value as a ContactDetail object if defined; else null
   */
  public getValueContactDetail(): ContactDetail | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof ContactDetail)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected ContactDetail but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a ContactDetail and has a value; `false` otherwise
   */
  public hasValueContactDetail(): boolean {
    return this.hasValue() && this.value instanceof ContactDetail;
  }

  /**
   * @returns the `value` property value as a DataRequirement object if defined; else null
   */
  public getValueDataRequirement(): DataRequirement | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof DataRequirement)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected DataRequirement but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a DataRequirement and has a value; `false` otherwise
   */
  public hasValueDataRequirement(): boolean {
    return this.hasValue() && this.value instanceof DataRequirement;
  }

  /**
   * @returns the `value` property value as a Expression object if defined; else null
   */
  public getValueExpression(): Expression | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Expression)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected Expression but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a Expression and has a value; `false` otherwise
   */
  public hasValueExpression(): boolean {
    return this.hasValue() && this.value instanceof Expression;
  }

  /**
   * @returns the `value` property value as a ParameterDefinition object if defined; else null
   */
  public getValueParameterDefinition(): ParameterDefinition | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof ParameterDefinition)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected ParameterDefinition but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a ParameterDefinition and has a value; `false` otherwise
   */
  public hasValueParameterDefinition(): boolean {
    return this.hasValue() && this.value instanceof ParameterDefinition;
  }

  /**
   * @returns the `value` property value as a RelatedArtifact object if defined; else null
   */
  public getValueRelatedArtifact(): RelatedArtifact | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof RelatedArtifact)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected RelatedArtifact but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a RelatedArtifact and has a value; `false` otherwise
   */
  public hasValueRelatedArtifact(): boolean {
    return this.hasValue() && this.value instanceof RelatedArtifact;
  }

  /**
   * @returns the `value` property value as a TriggerDefinition object if defined; else null
   */
  public getValueTriggerDefinition(): TriggerDefinition | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof TriggerDefinition)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected TriggerDefinition but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a TriggerDefinition and has a value; `false` otherwise
   */
  public hasValueTriggerDefinition(): boolean {
    return this.hasValue() && this.value instanceof TriggerDefinition;
  }

  /**
   * @returns the `value` property value as a UsageContext object if defined; else null
   */
  public getValueUsageContext(): UsageContext | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof UsageContext)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected UsageContext but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a UsageContext and has a value; `false` otherwise
   */
  public hasValueUsageContext(): boolean {
    return this.hasValue() && this.value instanceof UsageContext;
  }

  /**
   * @returns the `value` property value as a Availability object if defined; else null
   */
  public getValueAvailability(): Availability | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Availability)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected Availability but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a Availability and has a value; `false` otherwise
   */
  public hasValueAvailability(): boolean {
    return this.hasValue() && this.value instanceof Availability;
  }

  /**
   * @returns the `value` property value as a ExtendedContactDetail object if defined; else null
   */
  public getValueExtendedContactDetail(): ExtendedContactDetail | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof ExtendedContactDetail)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected ExtendedContactDetail but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a ExtendedContactDetail and has a value; `false` otherwise
   */
  public hasValueExtendedContactDetail(): boolean {
    return this.hasValue() && this.value instanceof ExtendedContactDetail;
  }

  /**
   * @returns the `value` property value as a Dosage object if defined; else null
   */
  public getValueDosage(): Dosage | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Dosage)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected Dosage but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a Dosage and has a value; `false` otherwise
   */
  public hasValueDosage(): boolean {
    return this.hasValue() && this.value instanceof Dosage;
  }

  /**
   * @returns the `value` property value as a Meta object if defined; else null
   */
  public getValueMeta(): Meta | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Meta)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected Meta but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a Meta and has a value; `false` otherwise
   */
  public hasValueMeta(): boolean {
    return this.hasValue() && this.value instanceof Meta;
  }

  // End of choice datatype-specific "get"/"has" methods

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'ElementDefinition.example';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.label,
      this.value,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): ElementDefinitionExampleComponent {
    const dest = new ElementDefinitionExampleComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: ElementDefinitionExampleComponent): void {
    super.copyValues(dest);
    dest.label = this.label ? this.label.copy() : null;
    dest.value = this.value ? this.value.copy() as IDataType : null;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasLabelElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirString>(this.getLabelElement()!, 'label', jsonObj);
    } else {
      missingReqdProperties.push(`ElementDefinition.example.label`);
    }

    if (this.hasValue()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getValue()!, 'value', jsonObj);
    } else {
      missingReqdProperties.push(`ElementDefinition.example.value[x]`);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_DO_NOT_EXIST} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
/**
 * ElementDefinitionConstraintComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Condition that must evaluate to true
 * - **Definition:** Formal constraints such as co-occurrence and other constraints that can be computationally evaluated within the context of the instance.
 * - **Comment:** Constraints should be declared on the "context" element - the lowest element in the hierarchy that is common to all nodes referenced by the constraint.
 *
 * @category Data Models: ComplexType
 * @see [FHIR ElementDefinition](http://hl7.org/fhir/StructureDefinition/ElementDefinition)
 */
export class ElementDefinitionConstraintComponent extends DataType implements IDataType {
  constructor(key: IdType | fhirId | null = null, severity: EnumCodeType | CodeType | fhirCode | null = null, human: StringType | fhirString | null = null) {
    super();

    this.constraintSeverityEnum = new ConstraintSeverityEnum();

    this.key = null;
    if (isDefined<IdType | fhirId>(key)) {
      if (key instanceof PrimitiveType) {
        this.setKeyElement(key);
      } else {
        this.setKey(key);
      }
    }

    this.severity = constructorCodeValueAsEnumCodeType<ConstraintSeverityEnum>(
      severity,
      ConstraintSeverityEnum,
      this.constraintSeverityEnum,
      'ElementDefinition.constraint.severity',
    );

    this.human = null;
    if (isDefined<StringType | fhirString>(human)) {
      if (human instanceof PrimitiveType) {
        this.setHumanElement(human);
      } else {
        this.setHuman(human);
      }
    }
  }

  /**
   * Parse the provided `ElementDefinitionConstraintComponent` JSON to instantiate the ElementDefinitionConstraintComponent data model.
   *
   * @param sourceJson - JSON representing FHIR `ElementDefinitionConstraintComponent`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to ElementDefinitionConstraintComponent
   * @returns ElementDefinitionConstraintComponent data model or undefined for `ElementDefinitionConstraintComponent`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): ElementDefinitionConstraintComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'ElementDefinitionConstraintComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new ElementDefinitionConstraintComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'key';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: IdType | undefined = fhirParser.parseIdType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setKeyElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'requirements';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: MarkdownType | undefined = fhirParser.parseMarkdownType(dtJson, dtSiblingJson);
      instance.setRequirementsElement(datatype);
    }

    fieldName = 'severity';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setSeverityElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'suppress';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'boolean';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: BooleanType | undefined = fhirParser.parseBooleanType(dtJson, dtSiblingJson);
      instance.setSuppressElement(datatype);
    }

    fieldName = 'human';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setHumanElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'expression';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setExpressionElement(datatype);
    }

    fieldName = 'source';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CanonicalType | undefined = fhirParser.parseCanonicalType(dtJson, dtSiblingJson);
      instance.setSourceElement(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_REQD_IN_JSON} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * ElementDefinition.constraint.key Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Target of \'condition\' reference above
   * - **Definition:** Allows identification of which elements have their cardinalities impacted by the constraint.  Will not be referenced for constraints that do not affect cardinality.
   * - **FHIR Type:** `id`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private key: IdType | null;

  /**
   * ElementDefinition.constraint.requirements Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Why this constraint is necessary or appropriate
   * - **Definition:** Description of why this constraint is necessary or appropriate.
   * - **Comment:** To be used if the reason for the constraint might not be intuitive to all implementers.
   * - **FHIR Type:** `markdown`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private requirements?: MarkdownType | undefined;

  /**
   * FHIR CodeSystem: ConstraintSeverity
   *
   * @see {@link ConstraintSeverityEnum }
   */
  private readonly constraintSeverityEnum: ConstraintSeverityEnum;

  /**
   * ElementDefinition.constraint.severity Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** error | warning
   * - **Definition:** Identifies the impact constraint violation has on the conformance of the instance.
   * - **Comment:** This allows constraints to be asserted as "shall" (error) and "should" (warning).
   * - **FHIR Type:** `code`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link ConstraintSeverityEnum }
   */
  private severity: EnumCodeType | null;

  /**
   * ElementDefinition.constraint.suppress Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Suppress warning or hint in profile
   * - **Definition:** If true, indicates that the warning or best practice guideline should be suppressed.
   * - **Comment:** This element should only be present in a derived profile where a warning or hint has been determined to be spurious/incorrect. E.g. a warning encouraging the inclusion of an element that the profile explicitly prohibits.
   * - **FHIR Type:** `boolean`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private suppress?: BooleanType | undefined;

  /**
   * ElementDefinition.constraint.human Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Human description of constraint
   * - **Definition:** Text that can be used to describe the constraint in messages identifying that the constraint has been violated.
   * - **Comment:** Should be expressed in business terms as much as possible.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private human: StringType | null;

  /**
   * ElementDefinition.constraint.expression Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** FHIRPath expression of constraint
   * - **Definition:** A [FHIRPath](https://hl7.org/fhir/fhirpath.html) expression of constraint that can be executed to see if this constraint is met.
   * - **Comment:** In the absense of an expression, the expression is likely not enforceable by validators, and might be missed by many systems.
   * - **Requirements:** Used by validation tooling tests of the validity of the resource.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private expression?: StringType | undefined;

  /**
   * ElementDefinition.constraint.source Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Reference to original source of constraint
   * - **Definition:** A reference to the original source of the constraint, for traceability purposes.
   * - **Comment:** This is used when, e.g. rendering, where it is not useful to present inherited constraints when rendering the snapshot.
   * - **FHIR Type:** `canonical`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/StructureDefinition',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private source?: CanonicalType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `key` property value as a IdType object if defined; else null
   */
  public getKeyElement(): IdType | null {
    return this.key;
  }

  /**
   * Assigns the provided PrimitiveType value to the `key` property.
   *
   * @param element - the `key` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setKeyElement(element: IdType): this {
    assertIsDefined<IdType>(element, `ElementDefinition.constraint.key is required`);
    const optErrMsg = `Invalid ElementDefinition.constraint.key; Provided value is not an instance of IdType.`;
    assertFhirType<IdType>(element, IdType, optErrMsg);
    this.key = element;
    return this;
  }

  /**
   * @returns `true` if the `key` property exists and has a value; `false` otherwise
   */
  public hasKeyElement(): boolean {
    return isDefined<IdType>(this.key) && !this.key.isEmpty();
  }

  /**
   * @returns the `key` property value as a fhirId if defined; else null
   */
  public getKey(): fhirId | null {
    if (this.key?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.key.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the `key` property.
   *
   * @param value - the `key` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setKey(value: fhirId): this {
    assertIsDefined<fhirId>(value, `ElementDefinition.constraint.key is required`);
    const optErrMsg = `Invalid ElementDefinition.constraint.key (${String(value)})`;
    this.key = new IdType(parseFhirPrimitiveData(value, fhirIdSchema, optErrMsg));
    return this;
  }

  /**
   * @returns `true` if the `key` property exists and has a value; `false` otherwise
   */
  public hasKey(): boolean {
    return this.hasKeyElement();
  }

  /**
   * @returns the `requirements` property value as a MarkdownType object if defined; else an empty MarkdownType object
   */
  public getRequirementsElement(): MarkdownType {
    return this.requirements ?? new MarkdownType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `requirements` property.
   *
   * @param element - the `requirements` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setRequirementsElement(element: MarkdownType | undefined): this {
    if (isDefined<MarkdownType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.constraint.requirements; Provided element is not an instance of MarkdownType.`;
      assertFhirType<MarkdownType>(element, MarkdownType, optErrMsg);
      this.requirements = element;
    } else {
      this.requirements = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `requirements` property exists and has a value; `false` otherwise
   */
  public hasRequirementsElement(): boolean {
    return isDefined<MarkdownType>(this.requirements) && !this.requirements.isEmpty();
  }

  /**
   * @returns the `requirements` property value as a fhirMarkdown if defined; else undefined
   */
  public getRequirements(): fhirMarkdown | undefined {
    return this.requirements?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `requirements` property.
   *
   * @param value - the `requirements` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setRequirements(value: fhirMarkdown | undefined): this {
    if (isDefined<fhirMarkdown>(value)) {
      const optErrMsg = `Invalid ElementDefinition.constraint.requirements (${String(value)})`;
      this.requirements = new MarkdownType(parseFhirPrimitiveData(value, fhirMarkdownSchema, optErrMsg));
    } else {
      this.requirements = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `requirements` property exists and has a value; `false` otherwise
   */
  public hasRequirements(): boolean {
    return this.hasRequirementsElement();
  }

  /**
   * @returns the `severity` property value as a EnumCodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link ConstraintSeverityEnum }
   */
  public getSeverityEnumType(): EnumCodeType | null {
    return this.severity;
  }

  /**
   * Assigns the provided EnumCodeType value to the `severity` property.
   *
   * @param enumType - the `severity` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ConstraintSeverityEnum }
   */
  public setSeverityEnumType(enumType: EnumCodeType): this {
    assertIsDefined<EnumCodeType>(enumType, `ElementDefinition.constraint.severity is required`);
    const errMsgPrefix = `Invalid ElementDefinition.constraint.severity`;
    assertEnumCodeType<ConstraintSeverityEnum>(enumType, ConstraintSeverityEnum, errMsgPrefix);
    this.severity = enumType;
    return this;
  }

  /**
   * @returns `true` if the `severity` property exists and has a value; `false` otherwise
   */
  public hasSeverityEnumType(): boolean {
    return isDefined<EnumCodeType>(this.severity) && !this.severity.isEmpty() && this.severity.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the `severity` property value as a CodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link ConstraintSeverityEnum }
   */
  public getSeverityElement(): CodeType | null {
    if (this.severity === null) {
      return null;
    }
    return this.severity as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the `severity` property.
   *
   * @param element - the `severity` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ConstraintSeverityEnum }
   */
  public setSeverityElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, `ElementDefinition.constraint.severity is required`);
    const optErrMsg = `Invalid ElementDefinition.constraint.severity; Provided value is not an instance of CodeType.`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.severity = new EnumCodeType(element, this.constraintSeverityEnum);
    return this;
  }

  /**
   * @returns `true` if the `severity` property exists and has a value; `false` otherwise
   */
  public hasSeverityElement(): boolean {
    return this.hasSeverityEnumType();
  }

  /**
   * @returns the `severity` property value as a fhirCode if defined; else null
   *
   * @see CodeSystem Enumeration: {@link ConstraintSeverityEnum }
   */
  public getSeverity(): fhirCode | null {
    if (this.severity === null) {
      return null;
    }
    return this.severity.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the `severity` property.
   *
   * @param value - the `severity` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link ConstraintSeverityEnum }
   */
  public setSeverity(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, `ElementDefinition.constraint.severity is required`);
    const optErrMsg = `Invalid ElementDefinition.constraint.severity (${String(value)})`;
    this.severity = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.constraintSeverityEnum);
    return this;
  }

  /**
   * @returns `true` if the `severity` property exists and has a value; `false` otherwise
   */
  public hasSeverity(): boolean {
    return this.hasSeverityEnumType();
  }

  /**
   * @returns the `suppress` property value as a BooleanType object if defined; else an empty BooleanType object
   */
  public getSuppressElement(): BooleanType {
    return this.suppress ?? new BooleanType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `suppress` property.
   *
   * @param element - the `suppress` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSuppressElement(element: BooleanType | undefined): this {
    if (isDefined<BooleanType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.constraint.suppress; Provided element is not an instance of BooleanType.`;
      assertFhirType<BooleanType>(element, BooleanType, optErrMsg);
      this.suppress = element;
    } else {
      this.suppress = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `suppress` property exists and has a value; `false` otherwise
   */
  public hasSuppressElement(): boolean {
    return isDefined<BooleanType>(this.suppress) && !this.suppress.isEmpty();
  }

  /**
   * @returns the `suppress` property value as a fhirBoolean if defined; else undefined
   */
  public getSuppress(): fhirBoolean | undefined {
    return this.suppress?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `suppress` property.
   *
   * @param value - the `suppress` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSuppress(value: fhirBoolean | undefined): this {
    if (isDefined<fhirBoolean>(value)) {
      const optErrMsg = `Invalid ElementDefinition.constraint.suppress (${String(value)})`;
      this.suppress = new BooleanType(parseFhirPrimitiveData(value, fhirBooleanSchema, optErrMsg));
    } else {
      this.suppress = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `suppress` property exists and has a value; `false` otherwise
   */
  public hasSuppress(): boolean {
    return this.hasSuppressElement();
  }

  /**
   * @returns the `human` property value as a StringType object if defined; else null
   */
  public getHumanElement(): StringType | null {
    return this.human;
  }

  /**
   * Assigns the provided PrimitiveType value to the `human` property.
   *
   * @param element - the `human` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setHumanElement(element: StringType): this {
    assertIsDefined<StringType>(element, `ElementDefinition.constraint.human is required`);
    const optErrMsg = `Invalid ElementDefinition.constraint.human; Provided value is not an instance of StringType.`;
    assertFhirType<StringType>(element, StringType, optErrMsg);
    this.human = element;
    return this;
  }

  /**
   * @returns `true` if the `human` property exists and has a value; `false` otherwise
   */
  public hasHumanElement(): boolean {
    return isDefined<StringType>(this.human) && !this.human.isEmpty();
  }

  /**
   * @returns the `human` property value as a fhirString if defined; else null
   */
  public getHuman(): fhirString | null {
    if (this.human?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.human.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the `human` property.
   *
   * @param value - the `human` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setHuman(value: fhirString): this {
    assertIsDefined<fhirString>(value, `ElementDefinition.constraint.human is required`);
    const optErrMsg = `Invalid ElementDefinition.constraint.human (${String(value)})`;
    this.human = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    return this;
  }

  /**
   * @returns `true` if the `human` property exists and has a value; `false` otherwise
   */
  public hasHuman(): boolean {
    return this.hasHumanElement();
  }

  /**
   * @returns the `expression` property value as a StringType object if defined; else an empty StringType object
   */
  public getExpressionElement(): StringType {
    return this.expression ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `expression` property.
   *
   * @param element - the `expression` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setExpressionElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.constraint.expression; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.expression = element;
    } else {
      this.expression = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `expression` property exists and has a value; `false` otherwise
   */
  public hasExpressionElement(): boolean {
    return isDefined<StringType>(this.expression) && !this.expression.isEmpty();
  }

  /**
   * @returns the `expression` property value as a fhirString if defined; else undefined
   */
  public getExpression(): fhirString | undefined {
    return this.expression?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `expression` property.
   *
   * @param value - the `expression` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setExpression(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid ElementDefinition.constraint.expression (${String(value)})`;
      this.expression = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.expression = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `expression` property exists and has a value; `false` otherwise
   */
  public hasExpression(): boolean {
    return this.hasExpressionElement();
  }

  /**
   * @returns the `source` property value as a CanonicalType object if defined; else an empty CanonicalType object
   */
  public getSourceElement(): CanonicalType {
    return this.source ?? new CanonicalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `source` property.
   *
   * @param element - the `source` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSourceElement(element: CanonicalType | undefined): this {
    if (isDefined<CanonicalType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.constraint.source; Provided element is not an instance of CanonicalType.`;
      assertFhirType<CanonicalType>(element, CanonicalType, optErrMsg);
      this.source = element;
    } else {
      this.source = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `source` property exists and has a value; `false` otherwise
   */
  public hasSourceElement(): boolean {
    return isDefined<CanonicalType>(this.source) && !this.source.isEmpty();
  }

  /**
   * @returns the `source` property value as a fhirCanonical if defined; else undefined
   */
  public getSource(): fhirCanonical | undefined {
    return this.source?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `source` property.
   *
   * @param value - the `source` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSource(value: fhirCanonical | undefined): this {
    if (isDefined<fhirCanonical>(value)) {
      const optErrMsg = `Invalid ElementDefinition.constraint.source (${String(value)})`;
      this.source = new CanonicalType(parseFhirPrimitiveData(value, fhirCanonicalSchema, optErrMsg));
    } else {
      this.source = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `source` property exists and has a value; `false` otherwise
   */
  public hasSource(): boolean {
    return this.hasSourceElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'ElementDefinition.constraint';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.key,
      this.requirements,
      this.severity,
      this.suppress,
      this.human,
      this.expression,
      this.source,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): ElementDefinitionConstraintComponent {
    const dest = new ElementDefinitionConstraintComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: ElementDefinitionConstraintComponent): void {
    super.copyValues(dest);
    dest.key = this.key ? this.key.copy() : null;
    dest.requirements = this.requirements?.copy();
    dest.severity = this.severity ? this.severity.copy() : null;
    dest.suppress = this.suppress?.copy();
    dest.human = this.human ? this.human.copy() : null;
    dest.expression = this.expression?.copy();
    dest.source = this.source?.copy();
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasKeyElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirId>(this.getKeyElement()!, 'key', jsonObj);
    } else {
      missingReqdProperties.push(`ElementDefinition.constraint.key`);
    }

    if (this.hasRequirementsElement()) {
      setFhirPrimitiveJson<fhirMarkdown>(this.getRequirementsElement(), 'requirements', jsonObj);
    }

    if (this.hasSeverityElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getSeverityElement()!, 'severity', jsonObj);
    } else {
      missingReqdProperties.push(`ElementDefinition.constraint.severity`);
    }

    if (this.hasSuppressElement()) {
      setFhirPrimitiveJson<fhirBoolean>(this.getSuppressElement(), 'suppress', jsonObj);
    }

    if (this.hasHumanElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirString>(this.getHumanElement()!, 'human', jsonObj);
    } else {
      missingReqdProperties.push(`ElementDefinition.constraint.human`);
    }

    if (this.hasExpressionElement()) {
      setFhirPrimitiveJson<fhirString>(this.getExpressionElement(), 'expression', jsonObj);
    }

    if (this.hasSourceElement()) {
      setFhirPrimitiveJson<fhirCanonical>(this.getSourceElement(), 'source', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_DO_NOT_EXIST} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
/**
 * ElementDefinitionBindingComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** ValueSet details if this is coded
 * - **Definition:** Binds to a value set if this element is coded (code, Coding, CodeableConcept, Quantity), or the data types (string, uri).
 * - **Comment:** For a CodeableConcept, when no codes are allowed - only text, use a binding of strength "required" with a description explaining that no coded values are allowed and what sort of information to put in the "text" element.
 *
 * @category Data Models: ComplexType
 * @see [FHIR ElementDefinition](http://hl7.org/fhir/StructureDefinition/ElementDefinition)
 */
export class ElementDefinitionBindingComponent extends DataType implements IDataType {
  constructor(strength: EnumCodeType | CodeType | fhirCode | null = null) {
    super();

    this.bindingStrengthEnum = new BindingStrengthEnum();

    this.strength = constructorCodeValueAsEnumCodeType<BindingStrengthEnum>(
      strength,
      BindingStrengthEnum,
      this.bindingStrengthEnum,
      'ElementDefinition.binding.strength',
    );
  }

  /**
   * Parse the provided `ElementDefinitionBindingComponent` JSON to instantiate the ElementDefinitionBindingComponent data model.
   *
   * @param sourceJson - JSON representing FHIR `ElementDefinitionBindingComponent`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to ElementDefinitionBindingComponent
   * @returns ElementDefinitionBindingComponent data model or undefined for `ElementDefinitionBindingComponent`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): ElementDefinitionBindingComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'ElementDefinitionBindingComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new ElementDefinitionBindingComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'strength';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setStrengthElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'description';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: MarkdownType | undefined = fhirParser.parseMarkdownType(dtJson, dtSiblingJson);
      instance.setDescriptionElement(datatype);
    }

    fieldName = 'valueSet';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CanonicalType | undefined = fhirParser.parseCanonicalType(dtJson, dtSiblingJson);
      instance.setValueSetElement(datatype);
    }

    fieldName = 'additional';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: ElementDefinitionBindingAdditionalComponent | undefined = ElementDefinitionBindingAdditionalComponent.parse(dataElementJson, `${sourceField}[${String(idx)}]`);
        if (datatype !== undefined) {
          instance.addAdditional(datatype);
        }
      });
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_REQD_IN_JSON} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: BindingStrength
   *
   * @see {@link BindingStrengthEnum }
   */
  private readonly bindingStrengthEnum: BindingStrengthEnum;

  /**
   * ElementDefinition.binding.strength Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** required | extensible | preferred | example
   * - **Definition:** Indicates the degree of conformance expectations associated with this binding - that is, the degree to which the provided value set must be adhered to in the instances.
   * - **Comment:** For further discussion, see [Using Terminologies](https://hl7.org/fhir/terminologies.html).
   * - **FHIR Type:** `code`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link BindingStrengthEnum }
   */
  private strength: EnumCodeType | null;

  /**
   * ElementDefinition.binding.description Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Intended use of codes in the bound value set
   * - **Definition:** Describes the intended use of this particular set of codes.
   * - **FHIR Type:** `markdown`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private description?: MarkdownType | undefined;

  /**
   * ElementDefinition.binding.valueSet Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Source of value set
   * - **Definition:** Refers to the value set that identifies the set of codes the binding refers to.
   * - **Comment:** The reference may be version-specific or not (e.g. have a |[version] at the end of the canonical URL).
   * - **FHIR Type:** `canonical`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/ValueSet',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private valueSet?: CanonicalType | undefined;

  /**
   * ElementDefinition.binding.additional Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Additional Bindings - more rules about the binding
   * - **Definition:** Additional bindings that help applications implementing this element. Additional bindings do not replace the main binding but provide more information and/or context.
   * - **FHIR Type:** `Element`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private additional?: ElementDefinitionBindingAdditionalComponent[] | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `strength` property value as a EnumCodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link BindingStrengthEnum }
   */
  public getStrengthEnumType(): EnumCodeType | null {
    return this.strength;
  }

  /**
   * Assigns the provided EnumCodeType value to the `strength` property.
   *
   * @param enumType - the `strength` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link BindingStrengthEnum }
   */
  public setStrengthEnumType(enumType: EnumCodeType): this {
    assertIsDefined<EnumCodeType>(enumType, `ElementDefinition.binding.strength is required`);
    const errMsgPrefix = `Invalid ElementDefinition.binding.strength`;
    assertEnumCodeType<BindingStrengthEnum>(enumType, BindingStrengthEnum, errMsgPrefix);
    this.strength = enumType;
    return this;
  }

  /**
   * @returns `true` if the `strength` property exists and has a value; `false` otherwise
   */
  public hasStrengthEnumType(): boolean {
    return isDefined<EnumCodeType>(this.strength) && !this.strength.isEmpty() && this.strength.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the `strength` property value as a CodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link BindingStrengthEnum }
   */
  public getStrengthElement(): CodeType | null {
    if (this.strength === null) {
      return null;
    }
    return this.strength as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the `strength` property.
   *
   * @param element - the `strength` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link BindingStrengthEnum }
   */
  public setStrengthElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, `ElementDefinition.binding.strength is required`);
    const optErrMsg = `Invalid ElementDefinition.binding.strength; Provided value is not an instance of CodeType.`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.strength = new EnumCodeType(element, this.bindingStrengthEnum);
    return this;
  }

  /**
   * @returns `true` if the `strength` property exists and has a value; `false` otherwise
   */
  public hasStrengthElement(): boolean {
    return this.hasStrengthEnumType();
  }

  /**
   * @returns the `strength` property value as a fhirCode if defined; else null
   *
   * @see CodeSystem Enumeration: {@link BindingStrengthEnum }
   */
  public getStrength(): fhirCode | null {
    if (this.strength === null) {
      return null;
    }
    return this.strength.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the `strength` property.
   *
   * @param value - the `strength` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link BindingStrengthEnum }
   */
  public setStrength(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, `ElementDefinition.binding.strength is required`);
    const optErrMsg = `Invalid ElementDefinition.binding.strength (${String(value)})`;
    this.strength = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.bindingStrengthEnum);
    return this;
  }

  /**
   * @returns `true` if the `strength` property exists and has a value; `false` otherwise
   */
  public hasStrength(): boolean {
    return this.hasStrengthEnumType();
  }

  /**
   * @returns the `description` property value as a MarkdownType object if defined; else an empty MarkdownType object
   */
  public getDescriptionElement(): MarkdownType {
    return this.description ?? new MarkdownType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `description` property.
   *
   * @param element - the `description` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDescriptionElement(element: MarkdownType | undefined): this {
    if (isDefined<MarkdownType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.binding.description; Provided element is not an instance of MarkdownType.`;
      assertFhirType<MarkdownType>(element, MarkdownType, optErrMsg);
      this.description = element;
    } else {
      this.description = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `description` property exists and has a value; `false` otherwise
   */
  public hasDescriptionElement(): boolean {
    return isDefined<MarkdownType>(this.description) && !this.description.isEmpty();
  }

  /**
   * @returns the `description` property value as a fhirMarkdown if defined; else undefined
   */
  public getDescription(): fhirMarkdown | undefined {
    return this.description?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `description` property.
   *
   * @param value - the `description` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDescription(value: fhirMarkdown | undefined): this {
    if (isDefined<fhirMarkdown>(value)) {
      const optErrMsg = `Invalid ElementDefinition.binding.description (${String(value)})`;
      this.description = new MarkdownType(parseFhirPrimitiveData(value, fhirMarkdownSchema, optErrMsg));
    } else {
      this.description = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `description` property exists and has a value; `false` otherwise
   */
  public hasDescription(): boolean {
    return this.hasDescriptionElement();
  }

  /**
   * @returns the `valueSet` property value as a CanonicalType object if defined; else an empty CanonicalType object
   */
  public getValueSetElement(): CanonicalType {
    return this.valueSet ?? new CanonicalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `valueSet` property.
   *
   * @param element - the `valueSet` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValueSetElement(element: CanonicalType | undefined): this {
    if (isDefined<CanonicalType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.binding.valueSet; Provided element is not an instance of CanonicalType.`;
      assertFhirType<CanonicalType>(element, CanonicalType, optErrMsg);
      this.valueSet = element;
    } else {
      this.valueSet = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `valueSet` property exists and has a value; `false` otherwise
   */
  public hasValueSetElement(): boolean {
    return isDefined<CanonicalType>(this.valueSet) && !this.valueSet.isEmpty();
  }

  /**
   * @returns the `valueSet` property value as a fhirCanonical if defined; else undefined
   */
  public getValueSet(): fhirCanonical | undefined {
    return this.valueSet?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `valueSet` property.
   *
   * @param value - the `valueSet` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValueSet(value: fhirCanonical | undefined): this {
    if (isDefined<fhirCanonical>(value)) {
      const optErrMsg = `Invalid ElementDefinition.binding.valueSet (${String(value)})`;
      this.valueSet = new CanonicalType(parseFhirPrimitiveData(value, fhirCanonicalSchema, optErrMsg));
    } else {
      this.valueSet = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `valueSet` property exists and has a value; `false` otherwise
   */
  public hasValueSet(): boolean {
    return this.hasValueSetElement();
  }

  /**
   * @returns the `additional` property value as a ElementDefinitionBindingAdditionalComponent array
   */
  public getAdditional(): ElementDefinitionBindingAdditionalComponent[] {
    return this.additional ?? ([] as ElementDefinitionBindingAdditionalComponent[]);
  }

  /**
   * Assigns the provided ElementDefinitionBindingAdditionalComponent array value to the `additional` property.
   *
   * @param value - the `additional` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setAdditional(value: ElementDefinitionBindingAdditionalComponent[] | undefined): this {
    if (isDefinedList<ElementDefinitionBindingAdditionalComponent>(value)) {
      const optErrMsg = `Invalid ElementDefinition.binding.additional; Provided value array has an element that is not an instance of ElementDefinitionBindingAdditionalComponent.`;
      assertFhirTypeList<ElementDefinitionBindingAdditionalComponent>(value, ElementDefinitionBindingAdditionalComponent, optErrMsg);
      this.additional = value;
    } else {
      this.additional = undefined;
    }
    return this;
  }

  /**
   * Add the provided ElementDefinitionBindingAdditionalComponent value to the `additional` array property.
   *
   * @param value - the `additional` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addAdditional(value: ElementDefinitionBindingAdditionalComponent | undefined): this {
    if (isDefined<ElementDefinitionBindingAdditionalComponent>(value)) {
      const optErrMsg = `Invalid ElementDefinition.binding.additional; Provided element is not an instance of ElementDefinitionBindingAdditionalComponent.`;
      assertFhirType<ElementDefinitionBindingAdditionalComponent>(value, ElementDefinitionBindingAdditionalComponent, optErrMsg);
      this.initAdditional();
      this.additional?.push(value);
    }
    return this;
  }

  /**
   * @returns `true` if the `additional` property exists and has a value; `false` otherwise
   */
  public hasAdditional(): boolean {
    return isDefinedList<ElementDefinitionBindingAdditionalComponent>(this.additional) && this.additional.some((item: ElementDefinitionBindingAdditionalComponent) => !item.isEmpty());
  }

  /**
   * Initialize the `additional` property
   */
  private initAdditional(): void {
    if(!this.hasAdditional()) {
      this.additional = [] as ElementDefinitionBindingAdditionalComponent[];
    }
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'ElementDefinition.binding';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.strength,
      this.description,
      this.valueSet,
      this.additional,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): ElementDefinitionBindingComponent {
    const dest = new ElementDefinitionBindingComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: ElementDefinitionBindingComponent): void {
    super.copyValues(dest);
    dest.strength = this.strength ? this.strength.copy() : null;
    dest.description = this.description?.copy();
    dest.valueSet = this.valueSet?.copy();
    const additionalList = copyListValues<ElementDefinitionBindingAdditionalComponent>(this.additional);
    dest.additional = additionalList.length === 0 ? undefined : additionalList;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasStrengthElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getStrengthElement()!, 'strength', jsonObj);
    } else {
      missingReqdProperties.push(`ElementDefinition.binding.strength`);
    }

    if (this.hasDescriptionElement()) {
      setFhirPrimitiveJson<fhirMarkdown>(this.getDescriptionElement(), 'description', jsonObj);
    }

    if (this.hasValueSetElement()) {
      setFhirPrimitiveJson<fhirCanonical>(this.getValueSetElement(), 'valueSet', jsonObj);
    }

    if (this.hasAdditional()) {
      setFhirComplexListJson(this.getAdditional(), 'additional', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_DO_NOT_EXIST} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
/**
 * ElementDefinitionBindingAdditionalComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Additional Bindings - more rules about the binding
 * - **Definition:** Additional bindings that help applications implementing this element. Additional bindings do not replace the main binding but provide more information and/or context.
 *
 * @category Data Models: ComplexType
 * @see [FHIR ElementDefinition](http://hl7.org/fhir/StructureDefinition/ElementDefinition)
 */
export class ElementDefinitionBindingAdditionalComponent extends DataType implements IDataType {
  constructor(purpose: EnumCodeType | CodeType | fhirCode | null = null, valueSet: CanonicalType | fhirCanonical | null = null) {
    super();

    this.additionalBindingPurposeEnum = new AdditionalBindingPurposeEnum();

    this.purpose = constructorCodeValueAsEnumCodeType<AdditionalBindingPurposeEnum>(
      purpose,
      AdditionalBindingPurposeEnum,
      this.additionalBindingPurposeEnum,
      'ElementDefinition.binding.additional.purpose',
    );

    this.valueSet = null;
    if (isDefined<CanonicalType | fhirCanonical>(valueSet)) {
      if (valueSet instanceof PrimitiveType) {
        this.setValueSetElement(valueSet);
      } else {
        this.setValueSet(valueSet);
      }
    }
  }

  /**
   * Parse the provided `ElementDefinitionBindingAdditionalComponent` JSON to instantiate the ElementDefinitionBindingAdditionalComponent data model.
   *
   * @param sourceJson - JSON representing FHIR `ElementDefinitionBindingAdditionalComponent`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to ElementDefinitionBindingAdditionalComponent
   * @returns ElementDefinitionBindingAdditionalComponent data model or undefined for `ElementDefinitionBindingAdditionalComponent`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): ElementDefinitionBindingAdditionalComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'ElementDefinitionBindingAdditionalComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new ElementDefinitionBindingAdditionalComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'purpose';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setPurposeElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'valueSet';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CanonicalType | undefined = fhirParser.parseCanonicalType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setValueSetElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'documentation';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: MarkdownType | undefined = fhirParser.parseMarkdownType(dtJson, dtSiblingJson);
      instance.setDocumentationElement(datatype);
    }

    fieldName = 'shortDoco';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setShortDocoElement(datatype);
    }

    fieldName = 'usage';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: UsageContext | undefined = UsageContext.parse(dataElementJson, `${sourceField}[${String(idx)}]`);
        if (datatype !== undefined) {
          instance.addUsage(datatype);
        }
      });
    }

    fieldName = 'any';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'boolean';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: BooleanType | undefined = fhirParser.parseBooleanType(dtJson, dtSiblingJson);
      instance.setAnyElement(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_REQD_IN_JSON} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: AdditionalBindingPurpose
   *
   * @see {@link AdditionalBindingPurposeEnum }
   */
  private readonly additionalBindingPurposeEnum: AdditionalBindingPurposeEnum;

  /**
   * ElementDefinition.binding.additional.purpose Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** maximum | minimum | required | extensible | candidate | current | preferred | ui | starter | component
   * - **Definition:** The use of this additional binding.
   * - **Comment:** Conformance bindings are in addition to the base binding, not instead of it.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link AdditionalBindingPurposeEnum }
   */
  private purpose: EnumCodeType | null;

  /**
   * ElementDefinition.binding.additional.valueSet Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The value set for the additional binding
   * - **Definition:** The valueSet that is being bound for the purpose.
   * - **FHIR Type:** `canonical`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/ValueSet',
   *     ]
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private valueSet: CanonicalType | null;

  /**
   * ElementDefinition.binding.additional.documentation Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Documentation of the purpose of use of the binding
   * - **Definition:** Documentation of the purpose of use of the bindingproviding additional information about how it is intended to be used.
   * - **FHIR Type:** `markdown`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private documentation?: MarkdownType | undefined;

  /**
   * ElementDefinition.binding.additional.shortDoco Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Concise documentation - for summary tables
   * - **Definition:** Concise documentation - for summary tables.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private shortDoco?: StringType | undefined;

  /**
   * ElementDefinition.binding.additional.usage Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Qualifies the usage - jurisdiction, gender, workflow status etc.
   * - **Definition:** Qualifies the usage of the binding. Typically bindings are qualified by jurisdiction, but they may also be qualified by gender, workflow status, clinical domain etc. The information to decide whether a usege context applies is usually outside the resource, determined by context, and this might present challenges for validation tooling.
   * - **Comment:** This specification does not define exactly how the context is determined for the usage; typically, this will be described in implementation guides.
   * - **FHIR Type:** `UsageContext`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private usage?: UsageContext[] | undefined;

  /**
   * ElementDefinition.binding.additional.any Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Whether binding can applies to all repeats, or just one
   * - **Definition:** Whether the binding applies to all repeats, or just to any one of them. This is only relevant for elements that can repeat.
   * - **Comment:** A common pattern is to make a conformance binding to all repeats, and then make a binding that one of the repeats must conform to.
   * - **FHIR Type:** `boolean`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private any?: BooleanType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `purpose` property value as a EnumCodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link AdditionalBindingPurposeEnum }
   */
  public getPurposeEnumType(): EnumCodeType | null {
    return this.purpose;
  }

  /**
   * Assigns the provided EnumCodeType value to the `purpose` property.
   *
   * @param enumType - the `purpose` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link AdditionalBindingPurposeEnum }
   */
  public setPurposeEnumType(enumType: EnumCodeType): this {
    assertIsDefined<EnumCodeType>(enumType, `ElementDefinition.binding.additional.purpose is required`);
    const errMsgPrefix = `Invalid ElementDefinition.binding.additional.purpose`;
    assertEnumCodeType<AdditionalBindingPurposeEnum>(enumType, AdditionalBindingPurposeEnum, errMsgPrefix);
    this.purpose = enumType;
    return this;
  }

  /**
   * @returns `true` if the `purpose` property exists and has a value; `false` otherwise
   */
  public hasPurposeEnumType(): boolean {
    return isDefined<EnumCodeType>(this.purpose) && !this.purpose.isEmpty() && this.purpose.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the `purpose` property value as a CodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link AdditionalBindingPurposeEnum }
   */
  public getPurposeElement(): CodeType | null {
    if (this.purpose === null) {
      return null;
    }
    return this.purpose as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the `purpose` property.
   *
   * @param element - the `purpose` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link AdditionalBindingPurposeEnum }
   */
  public setPurposeElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, `ElementDefinition.binding.additional.purpose is required`);
    const optErrMsg = `Invalid ElementDefinition.binding.additional.purpose; Provided value is not an instance of CodeType.`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.purpose = new EnumCodeType(element, this.additionalBindingPurposeEnum);
    return this;
  }

  /**
   * @returns `true` if the `purpose` property exists and has a value; `false` otherwise
   */
  public hasPurposeElement(): boolean {
    return this.hasPurposeEnumType();
  }

  /**
   * @returns the `purpose` property value as a fhirCode if defined; else null
   *
   * @see CodeSystem Enumeration: {@link AdditionalBindingPurposeEnum }
   */
  public getPurpose(): fhirCode | null {
    if (this.purpose === null) {
      return null;
    }
    return this.purpose.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the `purpose` property.
   *
   * @param value - the `purpose` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link AdditionalBindingPurposeEnum }
   */
  public setPurpose(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, `ElementDefinition.binding.additional.purpose is required`);
    const optErrMsg = `Invalid ElementDefinition.binding.additional.purpose (${String(value)})`;
    this.purpose = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.additionalBindingPurposeEnum);
    return this;
  }

  /**
   * @returns `true` if the `purpose` property exists and has a value; `false` otherwise
   */
  public hasPurpose(): boolean {
    return this.hasPurposeEnumType();
  }

  /**
   * @returns the `valueSet` property value as a CanonicalType object if defined; else null
   */
  public getValueSetElement(): CanonicalType | null {
    return this.valueSet;
  }

  /**
   * Assigns the provided PrimitiveType value to the `valueSet` property.
   *
   * @param element - the `valueSet` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValueSetElement(element: CanonicalType): this {
    assertIsDefined<CanonicalType>(element, `ElementDefinition.binding.additional.valueSet is required`);
    const optErrMsg = `Invalid ElementDefinition.binding.additional.valueSet; Provided value is not an instance of CanonicalType.`;
    assertFhirType<CanonicalType>(element, CanonicalType, optErrMsg);
    this.valueSet = element;
    return this;
  }

  /**
   * @returns `true` if the `valueSet` property exists and has a value; `false` otherwise
   */
  public hasValueSetElement(): boolean {
    return isDefined<CanonicalType>(this.valueSet) && !this.valueSet.isEmpty();
  }

  /**
   * @returns the `valueSet` property value as a fhirCanonical if defined; else null
   */
  public getValueSet(): fhirCanonical | null {
    if (this.valueSet?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.valueSet.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the `valueSet` property.
   *
   * @param value - the `valueSet` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValueSet(value: fhirCanonical): this {
    assertIsDefined<fhirCanonical>(value, `ElementDefinition.binding.additional.valueSet is required`);
    const optErrMsg = `Invalid ElementDefinition.binding.additional.valueSet (${String(value)})`;
    this.valueSet = new CanonicalType(parseFhirPrimitiveData(value, fhirCanonicalSchema, optErrMsg));
    return this;
  }

  /**
   * @returns `true` if the `valueSet` property exists and has a value; `false` otherwise
   */
  public hasValueSet(): boolean {
    return this.hasValueSetElement();
  }

  /**
   * @returns the `documentation` property value as a MarkdownType object if defined; else an empty MarkdownType object
   */
  public getDocumentationElement(): MarkdownType {
    return this.documentation ?? new MarkdownType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `documentation` property.
   *
   * @param element - the `documentation` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDocumentationElement(element: MarkdownType | undefined): this {
    if (isDefined<MarkdownType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.binding.additional.documentation; Provided element is not an instance of MarkdownType.`;
      assertFhirType<MarkdownType>(element, MarkdownType, optErrMsg);
      this.documentation = element;
    } else {
      this.documentation = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `documentation` property exists and has a value; `false` otherwise
   */
  public hasDocumentationElement(): boolean {
    return isDefined<MarkdownType>(this.documentation) && !this.documentation.isEmpty();
  }

  /**
   * @returns the `documentation` property value as a fhirMarkdown if defined; else undefined
   */
  public getDocumentation(): fhirMarkdown | undefined {
    return this.documentation?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `documentation` property.
   *
   * @param value - the `documentation` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDocumentation(value: fhirMarkdown | undefined): this {
    if (isDefined<fhirMarkdown>(value)) {
      const optErrMsg = `Invalid ElementDefinition.binding.additional.documentation (${String(value)})`;
      this.documentation = new MarkdownType(parseFhirPrimitiveData(value, fhirMarkdownSchema, optErrMsg));
    } else {
      this.documentation = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `documentation` property exists and has a value; `false` otherwise
   */
  public hasDocumentation(): boolean {
    return this.hasDocumentationElement();
  }

  /**
   * @returns the `shortDoco` property value as a StringType object if defined; else an empty StringType object
   */
  public getShortDocoElement(): StringType {
    return this.shortDoco ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `shortDoco` property.
   *
   * @param element - the `shortDoco` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setShortDocoElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.binding.additional.shortDoco; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.shortDoco = element;
    } else {
      this.shortDoco = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `shortDoco` property exists and has a value; `false` otherwise
   */
  public hasShortDocoElement(): boolean {
    return isDefined<StringType>(this.shortDoco) && !this.shortDoco.isEmpty();
  }

  /**
   * @returns the `shortDoco` property value as a fhirString if defined; else undefined
   */
  public getShortDoco(): fhirString | undefined {
    return this.shortDoco?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `shortDoco` property.
   *
   * @param value - the `shortDoco` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setShortDoco(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid ElementDefinition.binding.additional.shortDoco (${String(value)})`;
      this.shortDoco = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.shortDoco = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `shortDoco` property exists and has a value; `false` otherwise
   */
  public hasShortDoco(): boolean {
    return this.hasShortDocoElement();
  }

  /**
   * @returns the `usage` property value as a UsageContext array
   */
  public getUsage(): UsageContext[] {
    return this.usage ?? ([] as UsageContext[]);
  }

  /**
   * Assigns the provided UsageContext array value to the `usage` property.
   *
   * @param value - the `usage` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setUsage(value: UsageContext[] | undefined): this {
    if (isDefinedList<UsageContext>(value)) {
      const optErrMsg = `Invalid ElementDefinition.binding.additional.usage; Provided value array has an element that is not an instance of UsageContext.`;
      assertFhirTypeList<UsageContext>(value, UsageContext, optErrMsg);
      this.usage = value;
    } else {
      this.usage = undefined;
    }
    return this;
  }

  /**
   * Add the provided UsageContext value to the `usage` array property.
   *
   * @param value - the `usage` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addUsage(value: UsageContext | undefined): this {
    if (isDefined<UsageContext>(value)) {
      const optErrMsg = `Invalid ElementDefinition.binding.additional.usage; Provided element is not an instance of UsageContext.`;
      assertFhirType<UsageContext>(value, UsageContext, optErrMsg);
      this.initUsage();
      this.usage?.push(value);
    }
    return this;
  }

  /**
   * @returns `true` if the `usage` property exists and has a value; `false` otherwise
   */
  public hasUsage(): boolean {
    return isDefinedList<UsageContext>(this.usage) && this.usage.some((item: UsageContext) => !item.isEmpty());
  }

  /**
   * Initialize the `usage` property
   */
  private initUsage(): void {
    if(!this.hasUsage()) {
      this.usage = [] as UsageContext[];
    }
  }

  /**
   * @returns the `any` property value as a BooleanType object if defined; else an empty BooleanType object
   */
  public getAnyElement(): BooleanType {
    return this.any ?? new BooleanType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `any` property.
   *
   * @param element - the `any` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAnyElement(element: BooleanType | undefined): this {
    if (isDefined<BooleanType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.binding.additional.any; Provided element is not an instance of BooleanType.`;
      assertFhirType<BooleanType>(element, BooleanType, optErrMsg);
      this.any = element;
    } else {
      this.any = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `any` property exists and has a value; `false` otherwise
   */
  public hasAnyElement(): boolean {
    return isDefined<BooleanType>(this.any) && !this.any.isEmpty();
  }

  /**
   * @returns the `any` property value as a fhirBoolean if defined; else undefined
   */
  public getAny(): fhirBoolean | undefined {
    return this.any?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `any` property.
   *
   * @param value - the `any` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAny(value: fhirBoolean | undefined): this {
    if (isDefined<fhirBoolean>(value)) {
      const optErrMsg = `Invalid ElementDefinition.binding.additional.any (${String(value)})`;
      this.any = new BooleanType(parseFhirPrimitiveData(value, fhirBooleanSchema, optErrMsg));
    } else {
      this.any = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `any` property exists and has a value; `false` otherwise
   */
  public hasAny(): boolean {
    return this.hasAnyElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'ElementDefinition.binding.additional';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.purpose,
      this.valueSet,
      this.documentation,
      this.shortDoco,
      this.usage,
      this.any,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): ElementDefinitionBindingAdditionalComponent {
    const dest = new ElementDefinitionBindingAdditionalComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: ElementDefinitionBindingAdditionalComponent): void {
    super.copyValues(dest);
    dest.purpose = this.purpose ? this.purpose.copy() : null;
    dest.valueSet = this.valueSet ? this.valueSet.copy() : null;
    dest.documentation = this.documentation?.copy();
    dest.shortDoco = this.shortDoco?.copy();
    const usageList = copyListValues<UsageContext>(this.usage);
    dest.usage = usageList.length === 0 ? undefined : usageList;
    dest.any = this.any?.copy();
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasPurposeElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getPurposeElement()!, 'purpose', jsonObj);
    } else {
      missingReqdProperties.push(`ElementDefinition.binding.additional.purpose`);
    }

    if (this.hasValueSetElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCanonical>(this.getValueSetElement()!, 'valueSet', jsonObj);
    } else {
      missingReqdProperties.push(`ElementDefinition.binding.additional.valueSet`);
    }

    if (this.hasDocumentationElement()) {
      setFhirPrimitiveJson<fhirMarkdown>(this.getDocumentationElement(), 'documentation', jsonObj);
    }

    if (this.hasShortDocoElement()) {
      setFhirPrimitiveJson<fhirString>(this.getShortDocoElement(), 'shortDoco', jsonObj);
    }

    if (this.hasUsage()) {
      setFhirComplexListJson(this.getUsage(), 'usage', jsonObj);
    }

    if (this.hasAnyElement()) {
      setFhirPrimitiveJson<fhirBoolean>(this.getAnyElement(), 'any', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_DO_NOT_EXIST} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
/**
 * ElementDefinitionMappingComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Map element to another set of definitions
 * - **Definition:** Identifies a concept from an external specification that roughly corresponds to this element.
 * - **Comment:** Mappings are not necessarily specific enough for safe translation.
 * - **Requirements:** Provides guidance to implementers familiar with or converting content from other specifications.
 *
 * @category Data Models: ComplexType
 * @see [FHIR ElementDefinition](http://hl7.org/fhir/StructureDefinition/ElementDefinition)
 */
export class ElementDefinitionMappingComponent extends DataType implements IDataType {
  constructor(identity: IdType | fhirId | null = null, map: StringType | fhirString | null = null) {
    super();

    this.identity = null;
    if (isDefined<IdType | fhirId>(identity)) {
      if (identity instanceof PrimitiveType) {
        this.setIdentityElement(identity);
      } else {
        this.setIdentity(identity);
      }
    }

    this.map = null;
    if (isDefined<StringType | fhirString>(map)) {
      if (map instanceof PrimitiveType) {
        this.setMapElement(map);
      } else {
        this.setMap(map);
      }
    }
  }

  /**
   * Parse the provided `ElementDefinitionMappingComponent` JSON to instantiate the ElementDefinitionMappingComponent data model.
   *
   * @param sourceJson - JSON representing FHIR `ElementDefinitionMappingComponent`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to ElementDefinitionMappingComponent
   * @returns ElementDefinitionMappingComponent data model or undefined for `ElementDefinitionMappingComponent`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): ElementDefinitionMappingComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'ElementDefinitionMappingComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new ElementDefinitionMappingComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'identity';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: IdType | undefined = fhirParser.parseIdType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setIdentityElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'language';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setLanguageElement(datatype);
    }

    fieldName = 'map';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setMapElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'comment';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: MarkdownType | undefined = fhirParser.parseMarkdownType(dtJson, dtSiblingJson);
      instance.setCommentElement(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_REQD_IN_JSON} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * ElementDefinition.mapping.identity Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Reference to mapping declaration
   * - **Definition:** An internal reference to the definition of a mapping.
   * - **FHIR Type:** `id`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private identity: IdType | null;

  /**
   * ElementDefinition.mapping.language Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Computable language of mapping
   * - **Definition:** Identifies the computable language in which mapping.map is expressed.
   * - **Comment:** If omitted, then there can be no expectation of computational interpretation of the mapping.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private language?: CodeType | undefined;

  /**
   * ElementDefinition.mapping.map Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Details of the mapping
   * - **Definition:** Expresses what part of the target specification corresponds to this element.
   * - **Comment:** For most mappings, the syntax is undefined.  Syntax will be provided for mappings to the RIM.  Multiple mappings may be possible and may include constraints on other resource elements that identify when a particular mapping applies.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private map: StringType | null;

  /**
   * ElementDefinition.mapping.comment Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Comments about the mapping or its use
   * - **Definition:** Comments that provide information about the mapping or its use.
   * - **FHIR Type:** `markdown`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private comment?: MarkdownType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `identity` property value as a IdType object if defined; else null
   */
  public getIdentityElement(): IdType | null {
    return this.identity;
  }

  /**
   * Assigns the provided PrimitiveType value to the `identity` property.
   *
   * @param element - the `identity` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setIdentityElement(element: IdType): this {
    assertIsDefined<IdType>(element, `ElementDefinition.mapping.identity is required`);
    const optErrMsg = `Invalid ElementDefinition.mapping.identity; Provided value is not an instance of IdType.`;
    assertFhirType<IdType>(element, IdType, optErrMsg);
    this.identity = element;
    return this;
  }

  /**
   * @returns `true` if the `identity` property exists and has a value; `false` otherwise
   */
  public hasIdentityElement(): boolean {
    return isDefined<IdType>(this.identity) && !this.identity.isEmpty();
  }

  /**
   * @returns the `identity` property value as a fhirId if defined; else null
   */
  public getIdentity(): fhirId | null {
    if (this.identity?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.identity.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the `identity` property.
   *
   * @param value - the `identity` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setIdentity(value: fhirId): this {
    assertIsDefined<fhirId>(value, `ElementDefinition.mapping.identity is required`);
    const optErrMsg = `Invalid ElementDefinition.mapping.identity (${String(value)})`;
    this.identity = new IdType(parseFhirPrimitiveData(value, fhirIdSchema, optErrMsg));
    return this;
  }

  /**
   * @returns `true` if the `identity` property exists and has a value; `false` otherwise
   */
  public hasIdentity(): boolean {
    return this.hasIdentityElement();
  }

  /**
   * @returns the `language` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getLanguageElement(): CodeType {
    return this.language ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `language` property.
   *
   * @param element - the `language` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLanguageElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.mapping.language; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.language = element;
    } else {
      this.language = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `language` property exists and has a value; `false` otherwise
   */
  public hasLanguageElement(): boolean {
    return isDefined<CodeType>(this.language) && !this.language.isEmpty();
  }

  /**
   * @returns the `language` property value as a fhirCode if defined; else undefined
   */
  public getLanguage(): fhirCode | undefined {
    return this.language?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `language` property.
   *
   * @param value - the `language` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLanguage(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid ElementDefinition.mapping.language (${String(value)})`;
      this.language = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.language = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `language` property exists and has a value; `false` otherwise
   */
  public hasLanguage(): boolean {
    return this.hasLanguageElement();
  }

  /**
   * @returns the `map` property value as a StringType object if defined; else null
   */
  public getMapElement(): StringType | null {
    return this.map;
  }

  /**
   * Assigns the provided PrimitiveType value to the `map` property.
   *
   * @param element - the `map` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMapElement(element: StringType): this {
    assertIsDefined<StringType>(element, `ElementDefinition.mapping.map is required`);
    const optErrMsg = `Invalid ElementDefinition.mapping.map; Provided value is not an instance of StringType.`;
    assertFhirType<StringType>(element, StringType, optErrMsg);
    this.map = element;
    return this;
  }

  /**
   * @returns `true` if the `map` property exists and has a value; `false` otherwise
   */
  public hasMapElement(): boolean {
    return isDefined<StringType>(this.map) && !this.map.isEmpty();
  }

  /**
   * @returns the `map` property value as a fhirString if defined; else null
   */
  public getMap(): fhirString | null {
    if (this.map?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.map.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the `map` property.
   *
   * @param value - the `map` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMap(value: fhirString): this {
    assertIsDefined<fhirString>(value, `ElementDefinition.mapping.map is required`);
    const optErrMsg = `Invalid ElementDefinition.mapping.map (${String(value)})`;
    this.map = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    return this;
  }

  /**
   * @returns `true` if the `map` property exists and has a value; `false` otherwise
   */
  public hasMap(): boolean {
    return this.hasMapElement();
  }

  /**
   * @returns the `comment` property value as a MarkdownType object if defined; else an empty MarkdownType object
   */
  public getCommentElement(): MarkdownType {
    return this.comment ?? new MarkdownType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `comment` property.
   *
   * @param element - the `comment` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCommentElement(element: MarkdownType | undefined): this {
    if (isDefined<MarkdownType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.mapping.comment; Provided element is not an instance of MarkdownType.`;
      assertFhirType<MarkdownType>(element, MarkdownType, optErrMsg);
      this.comment = element;
    } else {
      this.comment = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `comment` property exists and has a value; `false` otherwise
   */
  public hasCommentElement(): boolean {
    return isDefined<MarkdownType>(this.comment) && !this.comment.isEmpty();
  }

  /**
   * @returns the `comment` property value as a fhirMarkdown if defined; else undefined
   */
  public getComment(): fhirMarkdown | undefined {
    return this.comment?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `comment` property.
   *
   * @param value - the `comment` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setComment(value: fhirMarkdown | undefined): this {
    if (isDefined<fhirMarkdown>(value)) {
      const optErrMsg = `Invalid ElementDefinition.mapping.comment (${String(value)})`;
      this.comment = new MarkdownType(parseFhirPrimitiveData(value, fhirMarkdownSchema, optErrMsg));
    } else {
      this.comment = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `comment` property exists and has a value; `false` otherwise
   */
  public hasComment(): boolean {
    return this.hasCommentElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'ElementDefinition.mapping';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.identity,
      this.language,
      this.map,
      this.comment,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): ElementDefinitionMappingComponent {
    const dest = new ElementDefinitionMappingComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: ElementDefinitionMappingComponent): void {
    super.copyValues(dest);
    dest.identity = this.identity ? this.identity.copy() : null;
    dest.language = this.language?.copy();
    dest.map = this.map ? this.map.copy() : null;
    dest.comment = this.comment?.copy();
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasIdentityElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirId>(this.getIdentityElement()!, 'identity', jsonObj);
    } else {
      missingReqdProperties.push(`ElementDefinition.mapping.identity`);
    }

    if (this.hasLanguageElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getLanguageElement(), 'language', jsonObj);
    }

    if (this.hasMapElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirString>(this.getMapElement()!, 'map', jsonObj);
    } else {
      missingReqdProperties.push(`ElementDefinition.mapping.map`);
    }

    if (this.hasCommentElement()) {
      setFhirPrimitiveJson<fhirMarkdown>(this.getCommentElement(), 'comment', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_DO_NOT_EXIST} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

/**
 * Expression Class
 *
 * @remarks
 * Expression Type: A expression that is evaluated in a specified context and returns a value. The context of use of the expression must specify the context in which the expression is evaluated, and how the result of the expression is used.
 *
 * **FHIR Specification**
 * - **Short:** An expression that can be used to generate a value
 * - **Definition:** A expression that is evaluated in a specified context and returns a value. The context of use of the expression must specify the context in which the expression is evaluated, and how the result of the expression is used.
 * - **FHIR Version:** 5.0.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR Expression](http://hl7.org/fhir/StructureDefinition/Expression)
 */
export class Expression extends DataType implements IDataType {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided `Expression` JSON to instantiate the Expression data model.
   *
   * @param sourceJson - JSON representing FHIR `Expression`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to Expression
   * @returns Expression data model or undefined for `Expression`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Expression | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Expression';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new Expression();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'description';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setDescriptionElement(datatype);
    }

    fieldName = 'name';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setNameElement(datatype);
    }

    fieldName = 'language';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setLanguageElement(datatype);
    }

    fieldName = 'expression';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setExpressionElement(datatype);
    }

    fieldName = 'reference';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = fhirParser.parseUriType(dtJson, dtSiblingJson);
      instance.setReferenceElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Expression.description Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Natural language description of the condition
   * - **Definition:** A brief, natural language description of the condition that effectively communicates the intended semantics.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private description?: StringType | undefined;

  /**
   * Expression.name Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Short name assigned to expression for reuse
   * - **Definition:** A short name assigned to the expression to allow for multiple reuse of the expression in the context where it is defined.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private name?: CodeType | undefined;

  /**
   * Expression.language Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** text/cql | text/fhirpath | application/x-fhir-query | etc.
   * - **Definition:** The media type of the language for the expression.
   * - **Requirements:** The cardinality of this element is optional to allow text only as part of the authoring process.  However, in order to be executable, the expression element must be specified.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private language?: CodeType | undefined;

  /**
   * Expression.expression Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Expression in specified language
   * - **Definition:** An expression in the specified language that returns a value.
   * - **Comment:** If Expression.expression and Expression.reference are both present, the Expression.expression might just be a name pointing something within the referenced content.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private expression?: StringType | undefined;

  /**
   * Expression.reference Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Where the expression is found
   * - **Definition:** A URI that defines where the expression is found.
   * - **Comment:** If both a reference and an expression is found, the reference SHALL point to the same expression.
   * - **FHIR Type:** `uri`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private reference?: UriType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `description` property value as a StringType object if defined; else an empty StringType object
   */
  public getDescriptionElement(): StringType {
    return this.description ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `description` property.
   *
   * @param element - the `description` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDescriptionElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid Expression.description; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.description = element;
    } else {
      this.description = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `description` property exists and has a value; `false` otherwise
   */
  public hasDescriptionElement(): boolean {
    return isDefined<StringType>(this.description) && !this.description.isEmpty();
  }

  /**
   * @returns the `description` property value as a fhirString if defined; else undefined
   */
  public getDescription(): fhirString | undefined {
    return this.description?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `description` property.
   *
   * @param value - the `description` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDescription(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid Expression.description (${String(value)})`;
      this.description = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.description = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `description` property exists and has a value; `false` otherwise
   */
  public hasDescription(): boolean {
    return this.hasDescriptionElement();
  }

  /**
   * @returns the `name` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getNameElement(): CodeType {
    return this.name ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `name` property.
   *
   * @param element - the `name` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setNameElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid Expression.name; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.name = element;
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `name` property exists and has a value; `false` otherwise
   */
  public hasNameElement(): boolean {
    return isDefined<CodeType>(this.name) && !this.name.isEmpty();
  }

  /**
   * @returns the `name` property value as a fhirCode if defined; else undefined
   */
  public getName(): fhirCode | undefined {
    return this.name?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `name` property.
   *
   * @param value - the `name` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setName(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid Expression.name (${String(value)})`;
      this.name = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `name` property exists and has a value; `false` otherwise
   */
  public hasName(): boolean {
    return this.hasNameElement();
  }

  /**
   * @returns the `language` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getLanguageElement(): CodeType {
    return this.language ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `language` property.
   *
   * @param element - the `language` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLanguageElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid Expression.language; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.language = element;
    } else {
      this.language = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `language` property exists and has a value; `false` otherwise
   */
  public hasLanguageElement(): boolean {
    return isDefined<CodeType>(this.language) && !this.language.isEmpty();
  }

  /**
   * @returns the `language` property value as a fhirCode if defined; else undefined
   */
  public getLanguage(): fhirCode | undefined {
    return this.language?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `language` property.
   *
   * @param value - the `language` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLanguage(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid Expression.language (${String(value)})`;
      this.language = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.language = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `language` property exists and has a value; `false` otherwise
   */
  public hasLanguage(): boolean {
    return this.hasLanguageElement();
  }

  /**
   * @returns the `expression` property value as a StringType object if defined; else an empty StringType object
   */
  public getExpressionElement(): StringType {
    return this.expression ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `expression` property.
   *
   * @param element - the `expression` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setExpressionElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid Expression.expression; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.expression = element;
    } else {
      this.expression = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `expression` property exists and has a value; `false` otherwise
   */
  public hasExpressionElement(): boolean {
    return isDefined<StringType>(this.expression) && !this.expression.isEmpty();
  }

  /**
   * @returns the `expression` property value as a fhirString if defined; else undefined
   */
  public getExpression(): fhirString | undefined {
    return this.expression?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `expression` property.
   *
   * @param value - the `expression` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setExpression(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid Expression.expression (${String(value)})`;
      this.expression = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.expression = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `expression` property exists and has a value; `false` otherwise
   */
  public hasExpression(): boolean {
    return this.hasExpressionElement();
  }

  /**
   * @returns the `reference` property value as a UriType object if defined; else an empty UriType object
   */
  public getReferenceElement(): UriType {
    return this.reference ?? new UriType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `reference` property.
   *
   * @param element - the `reference` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setReferenceElement(element: UriType | undefined): this {
    if (isDefined<UriType>(element)) {
      const optErrMsg = `Invalid Expression.reference; Provided element is not an instance of UriType.`;
      assertFhirType<UriType>(element, UriType, optErrMsg);
      this.reference = element;
    } else {
      this.reference = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `reference` property exists and has a value; `false` otherwise
   */
  public hasReferenceElement(): boolean {
    return isDefined<UriType>(this.reference) && !this.reference.isEmpty();
  }

  /**
   * @returns the `reference` property value as a fhirUri if defined; else undefined
   */
  public getReference(): fhirUri | undefined {
    return this.reference?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `reference` property.
   *
   * @param value - the `reference` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setReference(value: fhirUri | undefined): this {
    if (isDefined<fhirUri>(value)) {
      const optErrMsg = `Invalid Expression.reference (${String(value)})`;
      this.reference = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    } else {
      this.reference = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `reference` property exists and has a value; `false` otherwise
   */
  public hasReference(): boolean {
    return this.hasReferenceElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Expression';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.description,
      this.name,
      this.language,
      this.expression,
      this.reference,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Expression {
    const dest = new Expression();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Expression): void {
    super.copyValues(dest);
    dest.description = this.description?.copy();
    dest.name = this.name?.copy();
    dest.language = this.language?.copy();
    dest.expression = this.expression?.copy();
    dest.reference = this.reference?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasDescriptionElement()) {
      setFhirPrimitiveJson<fhirString>(this.getDescriptionElement(), 'description', jsonObj);
    }

    if (this.hasNameElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getNameElement(), 'name', jsonObj);
    }

    if (this.hasLanguageElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getLanguageElement(), 'language', jsonObj);
    }

    if (this.hasExpressionElement()) {
      setFhirPrimitiveJson<fhirString>(this.getExpressionElement(), 'expression', jsonObj);
    }

    if (this.hasReferenceElement()) {
      setFhirPrimitiveJson<fhirUri>(this.getReferenceElement(), 'reference', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * ExtendedContactDetail Class
 *
 * @remarks
 * ExtendedContactDetail Type: Specifies contact information for a specific purpose over a period of time, might be handled/monitored by a specific named person or organization.
 *
 * Need to track contact and address information in the same way across multiple resources.
 *
 * **FHIR Specification**
 * - **Short:** Contact information
 * - **Definition:** Specifies contact information for a specific purpose over a period of time, might be handled/monitored by a specific named person or organization.
 * - **Comment:** This datatype may be sparsely populated, i.e. only contain a purpose and phone number or address, but other cases could be completed filled out.
 * - **FHIR Version:** 5.0.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR ExtendedContactDetail](http://hl7.org/fhir/StructureDefinition/ExtendedContactDetail)
 */
export class ExtendedContactDetail extends DataType implements IDataType {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided `ExtendedContactDetail` JSON to instantiate the ExtendedContactDetail data model.
   *
   * @param sourceJson - JSON representing FHIR `ExtendedContactDetail`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to ExtendedContactDetail
   * @returns ExtendedContactDetail data model or undefined for `ExtendedContactDetail`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): ExtendedContactDetail | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'ExtendedContactDetail';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new ExtendedContactDetail();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';

    fieldName = 'purpose';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = CodeableConcept.parse(classJsonObj[fieldName]!, sourceField);
      instance.setPurpose(datatype);
    }

    fieldName = 'name';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: HumanName | undefined = HumanName.parse(dataElementJson, `${sourceField}[${String(idx)}]`);
        if (datatype !== undefined) {
          instance.addName(datatype);
        }
      });
    }

    fieldName = 'telecom';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: ContactPoint | undefined = ContactPoint.parse(dataElementJson, `${sourceField}[${String(idx)}]`);
        if (datatype !== undefined) {
          instance.addTelecom(datatype);
        }
      });
    }

    fieldName = 'address';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Address | undefined = Address.parse(classJsonObj[fieldName]!, sourceField);
      instance.setAddress(datatype);
    }

    fieldName = 'organization';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = Reference.parse(classJsonObj[fieldName]!, sourceField);
      instance.setOrganization(datatype);
    }

    fieldName = 'period';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Period | undefined = Period.parse(classJsonObj[fieldName]!, sourceField);
      instance.setPeriod(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * ExtendedContactDetail.purpose Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The type of contact
   * - **Definition:** The purpose/type of contact.
   * - **Comment:** If no purpose is defined, then these contact details may be used for any purpose.
   * - **FHIR Type:** `CodeableConcept`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private purpose?: CodeableConcept | undefined;

  /**
   * ExtendedContactDetail.name Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Name of an individual to contact
   * - **Definition:** The name of an individual to contact, some types of contact detail are usually blank.
   * - **Comment:** If there is no named individual, the telecom/address information is not generally monitored by a specific individual.
   * - **FHIR Type:** `HumanName`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private name?: HumanName[] | undefined;

  /**
   * ExtendedContactDetail.telecom Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Contact details (e.g.phone/fax/url)
   * - **Definition:** The contact details application for the purpose defined.
   * - **FHIR Type:** `ContactPoint`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private telecom?: ContactPoint[] | undefined;

  /**
   * ExtendedContactDetail.address Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Address for the contact
   * - **Definition:** Address for the contact.
   * - **Comment:** More than 1 address would be for different purposes, and thus should be entered as a different entry,.
   * - **FHIR Type:** `Address`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private address?: Address | undefined;

  /**
   * ExtendedContactDetail.organization Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** This contact detail is handled/monitored by a specific organization
   * - **Definition:** This contact detail is handled/monitored by a specific organization. If the name is provided in the contact, then it is referring to the named individual within this organization.
   * - **Requirements:** Some specific types of contact information can be an handled by an organization (eg legal council is via a specific firm).
   * - **FHIR Type:** `Reference`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Organization',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private organization?: Reference | undefined;

  /**
   * ExtendedContactDetail.period Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Period that this contact was valid for usage
   * - **Definition:** Period that this contact was valid for usage.
   * - **Comment:** If the details have multiple periods, then enter in a new ExtendedContact with the new period.
   * - **FHIR Type:** `Period`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private period?: Period | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `purpose` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getPurpose(): CodeableConcept {
    return this.purpose ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Purpose object value to the `purpose` property.
   *
   * @param value - the `purpose` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setPurpose(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = `Invalid ExtendedContactDetail.purpose; Provided element is not an instance of CodeableConcept.`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.purpose = value;
    } else {
      this.purpose = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `purpose` property exists and has a value; `false` otherwise
   */
  public hasPurpose(): boolean {
    return isDefined<CodeableConcept>(this.purpose) && !this.purpose.isEmpty();
  }

  /**
   * @returns the `name` property value as a HumanName array
   */
  public getName(): HumanName[] {
    return this.name ?? ([] as HumanName[]);
  }

  /**
   * Assigns the provided HumanName array value to the `name` property.
   *
   * @param value - the `name` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setName(value: HumanName[] | undefined): this {
    if (isDefinedList<HumanName>(value)) {
      const optErrMsg = `Invalid ExtendedContactDetail.name; Provided value array has an element that is not an instance of HumanName.`;
      assertFhirTypeList<HumanName>(value, HumanName, optErrMsg);
      this.name = value;
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * Add the provided HumanName value to the `name` array property.
   *
   * @param value - the `name` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addName(value: HumanName | undefined): this {
    if (isDefined<HumanName>(value)) {
      const optErrMsg = `Invalid ExtendedContactDetail.name; Provided element is not an instance of HumanName.`;
      assertFhirType<HumanName>(value, HumanName, optErrMsg);
      this.initName();
      this.name?.push(value);
    }
    return this;
  }

  /**
   * @returns `true` if the `name` property exists and has a value; `false` otherwise
   */
  public hasName(): boolean {
    return isDefinedList<HumanName>(this.name) && this.name.some((item: HumanName) => !item.isEmpty());
  }

  /**
   * Initialize the `name` property
   */
  private initName(): void {
    if(!this.hasName()) {
      this.name = [] as HumanName[];
    }
  }

  /**
   * @returns the `telecom` property value as a ContactPoint array
   */
  public getTelecom(): ContactPoint[] {
    return this.telecom ?? ([] as ContactPoint[]);
  }

  /**
   * Assigns the provided ContactPoint array value to the `telecom` property.
   *
   * @param value - the `telecom` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setTelecom(value: ContactPoint[] | undefined): this {
    if (isDefinedList<ContactPoint>(value)) {
      const optErrMsg = `Invalid ExtendedContactDetail.telecom; Provided value array has an element that is not an instance of ContactPoint.`;
      assertFhirTypeList<ContactPoint>(value, ContactPoint, optErrMsg);
      this.telecom = value;
    } else {
      this.telecom = undefined;
    }
    return this;
  }

  /**
   * Add the provided ContactPoint value to the `telecom` array property.
   *
   * @param value - the `telecom` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addTelecom(value: ContactPoint | undefined): this {
    if (isDefined<ContactPoint>(value)) {
      const optErrMsg = `Invalid ExtendedContactDetail.telecom; Provided element is not an instance of ContactPoint.`;
      assertFhirType<ContactPoint>(value, ContactPoint, optErrMsg);
      this.initTelecom();
      this.telecom?.push(value);
    }
    return this;
  }

  /**
   * @returns `true` if the `telecom` property exists and has a value; `false` otherwise
   */
  public hasTelecom(): boolean {
    return isDefinedList<ContactPoint>(this.telecom) && this.telecom.some((item: ContactPoint) => !item.isEmpty());
  }

  /**
   * Initialize the `telecom` property
   */
  private initTelecom(): void {
    if(!this.hasTelecom()) {
      this.telecom = [] as ContactPoint[];
    }
  }

  /**
   * @returns the `address` property value as a Address object if defined; else an empty Address object
   */
  public getAddress(): Address {
    return this.address ?? new Address();
  }

  /**
   * Assigns the provided Address object value to the `address` property.
   *
   * @param value - the `address` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setAddress(value: Address | undefined): this {
    if (isDefined<Address>(value)) {
      const optErrMsg = `Invalid ExtendedContactDetail.address; Provided element is not an instance of Address.`;
      assertFhirType<Address>(value, Address, optErrMsg);
      this.address = value;
    } else {
      this.address = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `address` property exists and has a value; `false` otherwise
   */
  public hasAddress(): boolean {
    return isDefined<Address>(this.address) && !this.address.isEmpty();
  }

  /**
   * @returns the `organization` property value as a Reference object; else an empty Reference object
   */
  public getOrganization(): Reference {
    return this.organization ?? new Reference();
  }

  /**
   * Assigns the provided Organization object value to the `organization` property.
   *
   * @decorator `@ReferenceTargets('ExtendedContactDetail.organization', ['Organization',])`
   *
   * @param value - the `organization` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('ExtendedContactDetail.organization', [
    'Organization',
  ])
  public setOrganization(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.organization = value;
    } else {
      this.organization = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `organization` property exists and has a value; `false` otherwise
   */
  public hasOrganization(): boolean {
    return isDefined<Reference>(this.organization) && !this.organization.isEmpty();
  }

  /**
   * @returns the `period` property value as a Period object if defined; else an empty Period object
   */
  public getPeriod(): Period {
    return this.period ?? new Period();
  }

  /**
   * Assigns the provided Period object value to the `period` property.
   *
   * @param value - the `period` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setPeriod(value: Period | undefined): this {
    if (isDefined<Period>(value)) {
      const optErrMsg = `Invalid ExtendedContactDetail.period; Provided element is not an instance of Period.`;
      assertFhirType<Period>(value, Period, optErrMsg);
      this.period = value;
    } else {
      this.period = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `period` property exists and has a value; `false` otherwise
   */
  public hasPeriod(): boolean {
    return isDefined<Period>(this.period) && !this.period.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'ExtendedContactDetail';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.purpose,
      this.name,
      this.telecom,
      this.address,
      this.organization,
      this.period,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): ExtendedContactDetail {
    const dest = new ExtendedContactDetail();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: ExtendedContactDetail): void {
    super.copyValues(dest);
    dest.purpose = this.purpose?.copy();
    const nameList = copyListValues<HumanName>(this.name);
    dest.name = nameList.length === 0 ? undefined : nameList;
    const telecomList = copyListValues<ContactPoint>(this.telecom);
    dest.telecom = telecomList.length === 0 ? undefined : telecomList;
    dest.address = this.address?.copy();
    dest.organization = this.organization?.copy();
    dest.period = this.period?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasPurpose()) {
      setFhirComplexJson(this.getPurpose(), 'purpose', jsonObj);
    }

    if (this.hasName()) {
      setFhirComplexListJson(this.getName(), 'name', jsonObj);
    }

    if (this.hasTelecom()) {
      setFhirComplexListJson(this.getTelecom(), 'telecom', jsonObj);
    }

    if (this.hasAddress()) {
      setFhirComplexJson(this.getAddress(), 'address', jsonObj);
    }

    if (this.hasOrganization()) {
      setFhirComplexJson(this.getOrganization(), 'organization', jsonObj);
    }

    if (this.hasPeriod()) {
      setFhirComplexJson(this.getPeriod(), 'period', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * HumanName Class
 *
 * @remarks
 * HumanName Type: A name, normally of a human, that can be used for other living entities (e.g. animals but not organizations) that have been assigned names by a human and may need the use of name parts or the need for usage information.
 *
 * Need to be able to record names, along with notes about their use.
 *
 * **FHIR Specification**
 * - **Short:** Name of a human or other living entity - parts and usage
 * - **Definition:** A name, normally of a human, that can be used for other living entities (e.g. animals but not organizations) that have been assigned names by a human and may need the use of name parts or the need for usage information.
 * - **Comment:** Names may be changed, or repudiated, or people may have different names in different contexts. Names may be divided into parts of different type that have variable significance depending on context, though the division into parts does not always matter. With personal names, the different parts might or might not be imbued with some implicit meaning; various cultures associate different importance with the name parts and the degree to which systems must care about name parts around the world varies widely.
 * - **FHIR Version:** 5.0.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR HumanName](http://hl7.org/fhir/StructureDefinition/HumanName)
 */
export class HumanName extends DataType implements IDataType {
  constructor() {
    super();

    this.nameUseEnum = new NameUseEnum();
  }

  /**
   * Parse the provided `HumanName` JSON to instantiate the HumanName data model.
   *
   * @param sourceJson - JSON representing FHIR `HumanName`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to HumanName
   * @returns HumanName data model or undefined for `HumanName`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): HumanName | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'HumanName';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new HumanName();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'use';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setUseElement(datatype);
    }

    fieldName = 'text';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setTextElement(datatype);
    }

    fieldName = 'family';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setFamilyElement(datatype);
    }

    fieldName = 'given';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: StringType | undefined = fhirParser.parseStringType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addGivenElement(datatype);
        }
      });
    }

    fieldName = 'prefix';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: StringType | undefined = fhirParser.parseStringType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addPrefixElement(datatype);
        }
      });
    }

    fieldName = 'suffix';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: StringType | undefined = fhirParser.parseStringType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addSuffixElement(datatype);
        }
      });
    }

    fieldName = 'period';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Period | undefined = Period.parse(classJsonObj[fieldName]!, sourceField);
      instance.setPeriod(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: NameUse
   *
   * @see {@link NameUseEnum }
   */
  private readonly nameUseEnum: NameUseEnum;

  /**
   * HumanName.use Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** usual | official | temp | nickname | anonymous | old | maiden
   * - **Definition:** Identifies the purpose for this name.
   * - **Comment:** Applications can assume that a name is current unless it explicitly says that it is temporary or old.
   * - **Requirements:** Allows the appropriate name for a particular context of use to be selected from among a set of names.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** true
   * - **isModifierReason:** This is labeled as &quot;Is Modifier&quot; because applications should not mistake a temporary or old name etc.for a current/permanent one
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link NameUseEnum }
   */
  private use?: EnumCodeType | undefined;

  /**
   * HumanName.text Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Text representation of the full name
   * - **Definition:** Specifies the entire name as it should be displayed e.g. on an application UI. This may be provided instead of or as well as the specific parts.
   * - **Comment:** Can provide both a text representation and parts. Applications updating a name SHALL ensure that when both text and parts are present,  no content is included in the text that isn\'t found in a part.
   * - **Requirements:** A renderable, unencoded form.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private text?: StringType | undefined;

  /**
   * HumanName.family Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Family name (often called \'Surname\')
   * - **Definition:** The part of a name that links to the genealogy. In some cultures (e.g. Eritrea) the family name of a son is the first name of his father.
   * - **Comment:** Family Name may be decomposed into specific parts using extensions (de, nl, es related cultures).
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private family?: StringType | undefined;

  /**
   * HumanName.given Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Given names (not always \'first\'). Includes middle names
   * - **Definition:** Given name.
   * - **Comment:** If only initials are recorded, they may be used in place of the full name parts. Initials may be separated into multiple given names but often aren\'t due to paractical limitations.  This element is not called "first name" since given names do not always come first.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private given?: StringType[] | undefined;

  /**
   * HumanName.prefix Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Parts that come before the name
   * - **Definition:** Part of the name that is acquired as a title due to academic, legal, employment or nobility status, etc. and that appears at the start of the name.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private prefix?: StringType[] | undefined;

  /**
   * HumanName.suffix Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Parts that come after the name
   * - **Definition:** Part of the name that is acquired as a title due to academic, legal, employment or nobility status, etc. and that appears at the end of the name.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private suffix?: StringType[] | undefined;

  /**
   * HumanName.period Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Time period when name was/is in use
   * - **Definition:** Indicates the period of time when this name was valid for the named person.
   * - **Requirements:** Allows names to be placed in historical context.
   * - **FHIR Type:** `Period`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private period?: Period | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `use` property value as a EnumCodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link NameUseEnum }
   */
  public getUseEnumType(): EnumCodeType | undefined {
    return this.use;
  }

  /**
   * Assigns the provided EnumCodeType value to the `use` property.
   *
   * @param enumType - the `use` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code values
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link NameUseEnum }
   */
  public setUseEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid HumanName.use';
      assertEnumCodeType<NameUseEnum>(enumType, NameUseEnum, errMsgPrefix);
      this.use = enumType;
    } else {
      this.use = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `use` property exists and has a value; `false` otherwise
   */
  public hasUseEnumType(): boolean {
    return isDefined<EnumCodeType>(this.use) && !this.use.isEmpty() && this.use.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the `use` property value as a CodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link NameUseEnum }
   */
  public getUseElement(): CodeType | undefined {
    if (this.use === undefined) {
      return undefined;
    }
    return this.use as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the `use` property.
   *
   * @param element - the `use` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link NameUseEnum }
   */
  public setUseElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid HumanName.use; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.use = new EnumCodeType(element, this.nameUseEnum);
    } else {
      this.use = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `use` property exists and has a value; `false` otherwise
   */
  public hasUseElement(): boolean {
    return this.hasUseEnumType();
  }

  /**
   * @returns the `use` property value as a fhirCode if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link NameUseEnum }
   */
  public getUse(): fhirCode | undefined {
    if (this.use === undefined) {
      return undefined;
    }
    return this.use.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the `use` property.
   *
   * @param value - the `use` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link NameUseEnum }
   */
  public setUse(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid HumanName.use; Provided value is not an instance of fhirCode.`;
      this.use = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.nameUseEnum);
    } else {
      this.use = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `use` property exists and has a value; `false` otherwise
   */
  public hasUse(): boolean {
    return this.hasUseEnumType();
  }

  /**
   * @returns the `text` property value as a StringType object if defined; else an empty StringType object
   */
  public getTextElement(): StringType {
    return this.text ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `text` property.
   *
   * @param element - the `text` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTextElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid HumanName.text; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.text = element;
    } else {
      this.text = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `text` property exists and has a value; `false` otherwise
   */
  public hasTextElement(): boolean {
    return isDefined<StringType>(this.text) && !this.text.isEmpty();
  }

  /**
   * @returns the `text` property value as a fhirString if defined; else undefined
   */
  public getText(): fhirString | undefined {
    return this.text?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `text` property.
   *
   * @param value - the `text` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setText(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid HumanName.text (${String(value)})`;
      this.text = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.text = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `text` property exists and has a value; `false` otherwise
   */
  public hasText(): boolean {
    return this.hasTextElement();
  }

  /**
   * @returns the `family` property value as a StringType object if defined; else an empty StringType object
   */
  public getFamilyElement(): StringType {
    return this.family ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `family` property.
   *
   * @param element - the `family` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setFamilyElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid HumanName.family; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.family = element;
    } else {
      this.family = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `family` property exists and has a value; `false` otherwise
   */
  public hasFamilyElement(): boolean {
    return isDefined<StringType>(this.family) && !this.family.isEmpty();
  }

  /**
   * @returns the `family` property value as a fhirString if defined; else undefined
   */
  public getFamily(): fhirString | undefined {
    return this.family?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `family` property.
   *
   * @param value - the `family` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setFamily(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid HumanName.family (${String(value)})`;
      this.family = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.family = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `family` property exists and has a value; `false` otherwise
   */
  public hasFamily(): boolean {
    return this.hasFamilyElement();
  }

  /**
   * @returns the `given` property value as a StringType array
   */
  public getGivenElement(): StringType[] {
    return this.given ?? ([] as StringType[]);
  }

  /**
   * Assigns the provided StringType array value to the `given` property.
   *
   * @param element - the `given` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setGivenElement(element: StringType[] | undefined): this {
    if (isDefinedList<StringType>(element)) {
      const optErrMsg = `Invalid HumanName.given; Provided value array has an element that is not an instance of StringType.`;
      assertFhirTypeList<StringType>(element, StringType, optErrMsg);
      this.given = element;
    } else {
      this.given = undefined;
    }
    return this;
  }

  /**
   * Add the provided StringType value to the `given` array property.
   *
   * @param element - the `given` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addGivenElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid HumanName.given; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.initGiven();
      this.given?.push(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `given` property exists and has a value; `false` otherwise
   */
  public hasGivenElement(): boolean {
    return isDefinedList<StringType>(this.given) && this.given.some((item: StringType) => !item.isEmpty());
  }

  /**
   * @returns the `given` property value as a fhirString array
   */
  public getGiven(): fhirString[] {
    this.initGiven();
    const givenValues = [] as fhirString[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.given!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        givenValues.push(value);
      }
    }
    return givenValues;
  }

  /**
   * Assigns the provided primitive value array to the `given` property.
   *
   * @param value - the `given` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setGiven(value: fhirString[] | undefined): this {
    if (isDefinedList<fhirString>(value)) {
      const givenElements = [] as StringType[];
      for (const givenValue of value) {
        const optErrMsg = `Invalid HumanName.given array item (${String(givenValue)})`;
        const element = new StringType(parseFhirPrimitiveData(givenValue, fhirStringSchema, optErrMsg));
        givenElements.push(element);
      }
      this.given = givenElements;
    } else {
      this.given = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the `given` array property.
   *
   * @param value - the `given` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addGiven(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid HumanName.given array item (${String(value)})`;
      const element = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
      this.initGiven();
      this.addGivenElement(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `given` property exists and has a value; `false` otherwise
   */
  public hasGiven(): boolean {
    return this.hasGivenElement();
  }

  /**
   * Initialize the `given` property
   */
  private initGiven(): void {
    if (!this.hasGiven()) {
      this.given = [] as StringType[];
    }
  }

  /**
   * @returns the `prefix` property value as a StringType array
   */
  public getPrefixElement(): StringType[] {
    return this.prefix ?? ([] as StringType[]);
  }

  /**
   * Assigns the provided StringType array value to the `prefix` property.
   *
   * @param element - the `prefix` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPrefixElement(element: StringType[] | undefined): this {
    if (isDefinedList<StringType>(element)) {
      const optErrMsg = `Invalid HumanName.prefix; Provided value array has an element that is not an instance of StringType.`;
      assertFhirTypeList<StringType>(element, StringType, optErrMsg);
      this.prefix = element;
    } else {
      this.prefix = undefined;
    }
    return this;
  }

  /**
   * Add the provided StringType value to the `prefix` array property.
   *
   * @param element - the `prefix` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addPrefixElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid HumanName.prefix; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.initPrefix();
      this.prefix?.push(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `prefix` property exists and has a value; `false` otherwise
   */
  public hasPrefixElement(): boolean {
    return isDefinedList<StringType>(this.prefix) && this.prefix.some((item: StringType) => !item.isEmpty());
  }

  /**
   * @returns the `prefix` property value as a fhirString array
   */
  public getPrefix(): fhirString[] {
    this.initPrefix();
    const prefixValues = [] as fhirString[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.prefix!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        prefixValues.push(value);
      }
    }
    return prefixValues;
  }

  /**
   * Assigns the provided primitive value array to the `prefix` property.
   *
   * @param value - the `prefix` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPrefix(value: fhirString[] | undefined): this {
    if (isDefinedList<fhirString>(value)) {
      const prefixElements = [] as StringType[];
      for (const prefixValue of value) {
        const optErrMsg = `Invalid HumanName.prefix array item (${String(prefixValue)})`;
        const element = new StringType(parseFhirPrimitiveData(prefixValue, fhirStringSchema, optErrMsg));
        prefixElements.push(element);
      }
      this.prefix = prefixElements;
    } else {
      this.prefix = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the `prefix` array property.
   *
   * @param value - the `prefix` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addPrefix(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid HumanName.prefix array item (${String(value)})`;
      const element = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
      this.initPrefix();
      this.addPrefixElement(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `prefix` property exists and has a value; `false` otherwise
   */
  public hasPrefix(): boolean {
    return this.hasPrefixElement();
  }

  /**
   * Initialize the `prefix` property
   */
  private initPrefix(): void {
    if (!this.hasPrefix()) {
      this.prefix = [] as StringType[];
    }
  }

  /**
   * @returns the `suffix` property value as a StringType array
   */
  public getSuffixElement(): StringType[] {
    return this.suffix ?? ([] as StringType[]);
  }

  /**
   * Assigns the provided StringType array value to the `suffix` property.
   *
   * @param element - the `suffix` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSuffixElement(element: StringType[] | undefined): this {
    if (isDefinedList<StringType>(element)) {
      const optErrMsg = `Invalid HumanName.suffix; Provided value array has an element that is not an instance of StringType.`;
      assertFhirTypeList<StringType>(element, StringType, optErrMsg);
      this.suffix = element;
    } else {
      this.suffix = undefined;
    }
    return this;
  }

  /**
   * Add the provided StringType value to the `suffix` array property.
   *
   * @param element - the `suffix` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addSuffixElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid HumanName.suffix; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.initSuffix();
      this.suffix?.push(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `suffix` property exists and has a value; `false` otherwise
   */
  public hasSuffixElement(): boolean {
    return isDefinedList<StringType>(this.suffix) && this.suffix.some((item: StringType) => !item.isEmpty());
  }

  /**
   * @returns the `suffix` property value as a fhirString array
   */
  public getSuffix(): fhirString[] {
    this.initSuffix();
    const suffixValues = [] as fhirString[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.suffix!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        suffixValues.push(value);
      }
    }
    return suffixValues;
  }

  /**
   * Assigns the provided primitive value array to the `suffix` property.
   *
   * @param value - the `suffix` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSuffix(value: fhirString[] | undefined): this {
    if (isDefinedList<fhirString>(value)) {
      const suffixElements = [] as StringType[];
      for (const suffixValue of value) {
        const optErrMsg = `Invalid HumanName.suffix array item (${String(suffixValue)})`;
        const element = new StringType(parseFhirPrimitiveData(suffixValue, fhirStringSchema, optErrMsg));
        suffixElements.push(element);
      }
      this.suffix = suffixElements;
    } else {
      this.suffix = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the `suffix` array property.
   *
   * @param value - the `suffix` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addSuffix(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid HumanName.suffix array item (${String(value)})`;
      const element = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
      this.initSuffix();
      this.addSuffixElement(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `suffix` property exists and has a value; `false` otherwise
   */
  public hasSuffix(): boolean {
    return this.hasSuffixElement();
  }

  /**
   * Initialize the `suffix` property
   */
  private initSuffix(): void {
    if (!this.hasSuffix()) {
      this.suffix = [] as StringType[];
    }
  }

  /**
   * @returns the `period` property value as a Period object if defined; else an empty Period object
   */
  public getPeriod(): Period {
    return this.period ?? new Period();
  }

  /**
   * Assigns the provided Period object value to the `period` property.
   *
   * @param value - the `period` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setPeriod(value: Period | undefined): this {
    if (isDefined<Period>(value)) {
      const optErrMsg = `Invalid HumanName.period; Provided element is not an instance of Period.`;
      assertFhirType<Period>(value, Period, optErrMsg);
      this.period = value;
    } else {
      this.period = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `period` property exists and has a value; `false` otherwise
   */
  public hasPeriod(): boolean {
    return isDefined<Period>(this.period) && !this.period.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'HumanName';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.use,
      this.text,
      this.family,
      this.given,
      this.prefix,
      this.suffix,
      this.period,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): HumanName {
    const dest = new HumanName();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: HumanName): void {
    super.copyValues(dest);
    dest.use = this.use?.copy();
    dest.text = this.text?.copy();
    dest.family = this.family?.copy();
    const givenList = copyListValues<StringType>(this.given);
    dest.given = givenList.length === 0 ? undefined : givenList;
    const prefixList = copyListValues<StringType>(this.prefix);
    dest.prefix = prefixList.length === 0 ? undefined : prefixList;
    const suffixList = copyListValues<StringType>(this.suffix);
    dest.suffix = suffixList.length === 0 ? undefined : suffixList;
    dest.period = this.period?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasUseElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getUseElement()!, 'use', jsonObj);
    }

    if (this.hasTextElement()) {
      setFhirPrimitiveJson<fhirString>(this.getTextElement(), 'text', jsonObj);
    }

    if (this.hasFamilyElement()) {
      setFhirPrimitiveJson<fhirString>(this.getFamilyElement(), 'family', jsonObj);
    }

    if (this.hasGiven()) {
      setFhirPrimitiveListJson(this.getGivenElement(), 'given', jsonObj);
    }

    if (this.hasPrefix()) {
      setFhirPrimitiveListJson(this.getPrefixElement(), 'prefix', jsonObj);
    }

    if (this.hasSuffix()) {
      setFhirPrimitiveListJson(this.getSuffixElement(), 'suffix', jsonObj);
    }

    if (this.hasPeriod()) {
      setFhirComplexJson(this.getPeriod(), 'period', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * MarketingStatus Class
 *
 * @remarks
 * MarketingStatus Type: The marketing status describes the date when a medicinal product is actually put on the market or the date as of which it is no longer available.
 *
 * **FHIR Specification**
 * - **Short:** The marketing status describes the date when a medicinal product is actually put on the market or the date as of which it is no longer available
 * - **Definition:** The marketing status describes the date when a medicinal product is actually put on the market or the date as of which it is no longer available.
 * - **FHIR Version:** 5.0.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR MarketingStatus](http://hl7.org/fhir/StructureDefinition/MarketingStatus)
 */
export class MarketingStatus extends BackboneType implements IBackboneType {
  constructor(status: CodeableConcept | null = null) {
    super();

    this.status = null;
    if (isDefined<CodeableConcept>(status)) {
      this.setStatus(status);
    }
  }

  /**
   * Parse the provided `MarketingStatus` JSON to instantiate the MarketingStatus data model.
   *
   * @param sourceJson - JSON representing FHIR `MarketingStatus`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to MarketingStatus
   * @returns MarketingStatus data model or undefined for `MarketingStatus`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): MarketingStatus | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'MarketingStatus';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new MarketingStatus();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneTypeJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    

    const missingReqdProperties: string[] = [];

    fieldName = 'country';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = CodeableConcept.parse(classJsonObj[fieldName]!, sourceField);
      instance.setCountry(datatype);
    }

    fieldName = 'jurisdiction';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = CodeableConcept.parse(classJsonObj[fieldName]!, sourceField);
      instance.setJurisdiction(datatype);
    }

    fieldName = 'status';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = CodeableConcept.parse(classJsonObj[fieldName]!, sourceField);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setStatus(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'dateRange';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Period | undefined = Period.parse(classJsonObj[fieldName]!, sourceField);
      instance.setDateRange(datatype);
    }

    fieldName = 'restoreDate';
    sourceField = `${optSourceValue}.${fieldName}`;
    const primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DateTimeType | undefined = fhirParser.parseDateTimeType(dtJson, dtSiblingJson);
      instance.setRestoreDateElement(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_REQD_IN_JSON} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * MarketingStatus.country Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The country in which the marketing authorization has been granted shall be specified It should be specified using the ISO 3166 - 1 alpha-2 code elements
   * - **Definition:** The country in which the marketing authorization has been granted shall be specified It should be specified using the ISO 3166 - 1 alpha-2 code elements.
   * - **FHIR Type:** `CodeableConcept`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private country?: CodeableConcept | undefined;

  /**
   * MarketingStatus.jurisdiction Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Where a Medicines Regulatory Agency has granted a marketing authorization for which specific provisions within a jurisdiction apply, the jurisdiction can be specified using an appropriate controlled terminology The controlled term and the controlled term identifier shall be specified
   * - **Definition:** Where a Medicines Regulatory Agency has granted a marketing authorization for which specific provisions within a jurisdiction apply, the jurisdiction can be specified using an appropriate controlled terminology The controlled term and the controlled term identifier shall be specified.
   * - **FHIR Type:** `CodeableConcept`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private jurisdiction?: CodeableConcept | undefined;

  /**
   * MarketingStatus.status Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** This attribute provides information on the status of the marketing of the medicinal product See ISO/TS 20443 for more information and examples
   * - **Definition:** This attribute provides information on the status of the marketing of the medicinal product See ISO/TS 20443 for more information and examples.
   * - **FHIR Type:** `CodeableConcept`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private status: CodeableConcept | null;

  /**
   * MarketingStatus.dateRange Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The date when the Medicinal Product is placed on the market by the Marketing Authorization Holder (or where applicable, the manufacturer/distributor) in a country and/or jurisdiction shall be provided A complete date consisting of day, month and year shall be specified using the ISO 8601 date format NOTE "Placed on the market" refers to the release of the Medicinal Product into the distribution chain
   * - **Definition:** The date when the Medicinal Product is placed on the market by the Marketing Authorization Holder (or where applicable, the manufacturer/distributor) in a country and/or jurisdiction shall be provided A complete date consisting of day, month and year shall be specified using the ISO 8601 date format NOTE "Placed on the market" refers to the release of the Medicinal Product into the distribution chain.
   * - **FHIR Type:** `Period`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private dateRange?: Period | undefined;

  /**
   * MarketingStatus.restoreDate Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The date when the Medicinal Product is placed on the market by the Marketing Authorization Holder (or where applicable, the manufacturer/distributor) in a country and/or jurisdiction shall be provided A complete date consisting of day, month and year shall be specified using the ISO 8601 date format NOTE "Placed on the market" refers to the release of the Medicinal Product into the distribution chain
   * - **Definition:** The date when the Medicinal Product is placed on the market by the Marketing Authorization Holder (or where applicable, the manufacturer/distributor) in a country and/or jurisdiction shall be provided A complete date consisting of day, month and year shall be specified using the ISO 8601 date format NOTE "Placed on the market" refers to the release of the Medicinal Product into the distribution chain.
   * - **FHIR Type:** `dateTime`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private restoreDate?: DateTimeType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `country` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getCountry(): CodeableConcept {
    return this.country ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Country object value to the `country` property.
   *
   * @param value - the `country` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setCountry(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = `Invalid MarketingStatus.country; Provided element is not an instance of CodeableConcept.`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.country = value;
    } else {
      this.country = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `country` property exists and has a value; `false` otherwise
   */
  public hasCountry(): boolean {
    return isDefined<CodeableConcept>(this.country) && !this.country.isEmpty();
  }

  /**
   * @returns the `jurisdiction` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getJurisdiction(): CodeableConcept {
    return this.jurisdiction ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Jurisdiction object value to the `jurisdiction` property.
   *
   * @param value - the `jurisdiction` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setJurisdiction(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = `Invalid MarketingStatus.jurisdiction; Provided element is not an instance of CodeableConcept.`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.jurisdiction = value;
    } else {
      this.jurisdiction = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `jurisdiction` property exists and has a value; `false` otherwise
   */
  public hasJurisdiction(): boolean {
    return isDefined<CodeableConcept>(this.jurisdiction) && !this.jurisdiction.isEmpty();
  }

  /**
   * @returns the `status` property value as a CodeableConcept object if defined; else null
   */
  public getStatus(): CodeableConcept | null {
    return this.status;
  }

  /**
   * Assigns the provided CodeableConcept object value to the `status` property.
   *
   * @param value - the `status` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setStatus(value: CodeableConcept): this {
    assertIsDefined<CodeableConcept>(value, `MarketingStatus.status is required`);
    const optErrMsg = `Invalid MarketingStatus.status; Provided element is not an instance of CodeableConcept.`;
    assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
    this.status = value;
    return this;
  }

  /**
   * @returns `true` if the `status` property exists and has a value; `false` otherwise
   */
  public hasStatus(): boolean {
    return isDefined<CodeableConcept>(this.status) && !this.status.isEmpty();
  }

  /**
   * @returns the `dateRange` property value as a Period object if defined; else an empty Period object
   */
  public getDateRange(): Period {
    return this.dateRange ?? new Period();
  }

  /**
   * Assigns the provided DateRange object value to the `dateRange` property.
   *
   * @param value - the `dateRange` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setDateRange(value: Period | undefined): this {
    if (isDefined<Period>(value)) {
      const optErrMsg = `Invalid MarketingStatus.dateRange; Provided element is not an instance of Period.`;
      assertFhirType<Period>(value, Period, optErrMsg);
      this.dateRange = value;
    } else {
      this.dateRange = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `dateRange` property exists and has a value; `false` otherwise
   */
  public hasDateRange(): boolean {
    return isDefined<Period>(this.dateRange) && !this.dateRange.isEmpty();
  }

  /**
   * @returns the `restoreDate` property value as a DateTimeType object if defined; else an empty DateTimeType object
   */
  public getRestoreDateElement(): DateTimeType {
    return this.restoreDate ?? new DateTimeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `restoreDate` property.
   *
   * @param element - the `restoreDate` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setRestoreDateElement(element: DateTimeType | undefined): this {
    if (isDefined<DateTimeType>(element)) {
      const optErrMsg = `Invalid MarketingStatus.restoreDate; Provided element is not an instance of DateTimeType.`;
      assertFhirType<DateTimeType>(element, DateTimeType, optErrMsg);
      this.restoreDate = element;
    } else {
      this.restoreDate = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `restoreDate` property exists and has a value; `false` otherwise
   */
  public hasRestoreDateElement(): boolean {
    return isDefined<DateTimeType>(this.restoreDate) && !this.restoreDate.isEmpty();
  }

  /**
   * @returns the `restoreDate` property value as a fhirDateTime if defined; else undefined
   */
  public getRestoreDate(): fhirDateTime | undefined {
    return this.restoreDate?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `restoreDate` property.
   *
   * @param value - the `restoreDate` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setRestoreDate(value: fhirDateTime | undefined): this {
    if (isDefined<fhirDateTime>(value)) {
      const optErrMsg = `Invalid MarketingStatus.restoreDate (${String(value)})`;
      this.restoreDate = new DateTimeType(parseFhirPrimitiveData(value, fhirDateTimeSchema, optErrMsg));
    } else {
      this.restoreDate = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `restoreDate` property exists and has a value; `false` otherwise
   */
  public hasRestoreDate(): boolean {
    return this.hasRestoreDateElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'MarketingStatus';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.country,
      this.jurisdiction,
      this.status,
      this.dateRange,
      this.restoreDate,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): MarketingStatus {
    const dest = new MarketingStatus();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: MarketingStatus): void {
    super.copyValues(dest);
    dest.country = this.country?.copy();
    dest.jurisdiction = this.jurisdiction?.copy();
    dest.status = this.status ? this.status.copy() : null;
    dest.dateRange = this.dateRange?.copy();
    dest.restoreDate = this.restoreDate?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasCountry()) {
      setFhirComplexJson(this.getCountry(), 'country', jsonObj);
    }

    if (this.hasJurisdiction()) {
      setFhirComplexJson(this.getJurisdiction(), 'jurisdiction', jsonObj);
    }

    if (this.hasStatus()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirComplexJson(this.getStatus()!, 'status', jsonObj);
    } else {
      missingReqdProperties.push(`MarketingStatus.status`);
    }

    if (this.hasDateRange()) {
      setFhirComplexJson(this.getDateRange(), 'dateRange', jsonObj);
    }

    if (this.hasRestoreDateElement()) {
      setFhirPrimitiveJson<fhirDateTime>(this.getRestoreDateElement(), 'restoreDate', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_DO_NOT_EXIST} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

/**
 * MonetaryComponent Class
 *
 * @remarks
 * MonetaryComponent Type: Availability data for an {item}.
 *
 * **FHIR Specification**
 * - **Short:** Availability data for an {item}
 * - **Definition:** Availability data for an {item}.
 * - **FHIR Version:** 5.0.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR MonetaryComponent](http://hl7.org/fhir/StructureDefinition/MonetaryComponent)
 */
export class MonetaryComponent extends DataType implements IDataType {
  constructor(type_: EnumCodeType | CodeType | fhirCode | null = null) {
    super();

    this.priceComponentTypeEnum = new PriceComponentTypeEnum();

    this.type_ = constructorCodeValueAsEnumCodeType<PriceComponentTypeEnum>(
      type_,
      PriceComponentTypeEnum,
      this.priceComponentTypeEnum,
      'MonetaryComponent.type',
    );
  }

  /**
   * Parse the provided `MonetaryComponent` JSON to instantiate the MonetaryComponent data model.
   *
   * @param sourceJson - JSON representing FHIR `MonetaryComponent`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to MonetaryComponent
   * @returns MonetaryComponent data model or undefined for `MonetaryComponent`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): MonetaryComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'MonetaryComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new MonetaryComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'type';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setTypeElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'code';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = CodeableConcept.parse(classJsonObj[fieldName]!, sourceField);
      instance.setCode(datatype);
    }

    fieldName = 'factor';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setFactorElement(datatype);
    }

    fieldName = 'amount';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Money | undefined = Money.parse(classJsonObj[fieldName]!, sourceField);
      instance.setAmount(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_REQD_IN_JSON} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: PriceComponentType
   *
   * @see {@link PriceComponentTypeEnum }
   */
  private readonly priceComponentTypeEnum: PriceComponentTypeEnum;

  /**
   * MonetaryComponent.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** base | surcharge | deduction | discount | tax | informational
   * - **Definition:** base | surcharge | deduction | discount | tax | informational.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link PriceComponentTypeEnum }
   */
  private type_: EnumCodeType | null;

  /**
   * MonetaryComponent.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Codes may be used to differentiate between kinds of taxes, surcharges, discounts etc.
   * - **Definition:** Codes may be used to differentiate between kinds of taxes, surcharges, discounts etc.
   * - **FHIR Type:** `CodeableConcept`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code?: CodeableConcept | undefined;

  /**
   * MonetaryComponent.factor Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Factor used for calculating this component
   * - **Definition:** Factor used for calculating this component.
   * - **FHIR Type:** `decimal`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private factor?: DecimalType | undefined;

  /**
   * MonetaryComponent.amount Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Explicit value amount to be used
   * - **Definition:** Explicit value amount to be used.
   * - **FHIR Type:** `Money`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private amount?: Money | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `type_` property value as a EnumCodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link PriceComponentTypeEnum }
   */
  public getTypeEnumType(): EnumCodeType | null {
    return this.type_;
  }

  /**
   * Assigns the provided EnumCodeType value to the `type_` property.
   *
   * @param enumType - the `type_` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link PriceComponentTypeEnum }
   */
  public setTypeEnumType(enumType: EnumCodeType): this {
    assertIsDefined<EnumCodeType>(enumType, `MonetaryComponent.type is required`);
    const errMsgPrefix = `Invalid MonetaryComponent.type`;
    assertEnumCodeType<PriceComponentTypeEnum>(enumType, PriceComponentTypeEnum, errMsgPrefix);
    this.type_ = enumType;
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasTypeEnumType(): boolean {
    return isDefined<EnumCodeType>(this.type_) && !this.type_.isEmpty() && this.type_.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the `type_` property value as a CodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link PriceComponentTypeEnum }
   */
  public getTypeElement(): CodeType | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_ as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the `type_` property.
   *
   * @param element - the `type_` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link PriceComponentTypeEnum }
   */
  public setTypeElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, `MonetaryComponent.type is required`);
    const optErrMsg = `Invalid MonetaryComponent.type; Provided value is not an instance of CodeType.`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.type_ = new EnumCodeType(element, this.priceComponentTypeEnum);
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasTypeElement(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the `type_` property value as a fhirCode if defined; else null
   *
   * @see CodeSystem Enumeration: {@link PriceComponentTypeEnum }
   */
  public getType(): fhirCode | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the `type_` property.
   *
   * @param value - the `type_` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link PriceComponentTypeEnum }
   */
  public setType(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, `MonetaryComponent.type is required`);
    const optErrMsg = `Invalid MonetaryComponent.type (${String(value)})`;
    this.type_ = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.priceComponentTypeEnum);
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasType(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the `code` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getCode(): CodeableConcept {
    return this.code ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Code object value to the `code` property.
   *
   * @param value - the `code` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setCode(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = `Invalid MonetaryComponent.code; Provided element is not an instance of CodeableConcept.`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.code = value;
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `code` property exists and has a value; `false` otherwise
   */
  public hasCode(): boolean {
    return isDefined<CodeableConcept>(this.code) && !this.code.isEmpty();
  }

  /**
   * @returns the `factor` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getFactorElement(): DecimalType {
    return this.factor ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `factor` property.
   *
   * @param element - the `factor` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setFactorElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = `Invalid MonetaryComponent.factor; Provided element is not an instance of DecimalType.`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.factor = element;
    } else {
      this.factor = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `factor` property exists and has a value; `false` otherwise
   */
  public hasFactorElement(): boolean {
    return isDefined<DecimalType>(this.factor) && !this.factor.isEmpty();
  }

  /**
   * @returns the `factor` property value as a fhirDecimal if defined; else undefined
   */
  public getFactor(): fhirDecimal | undefined {
    return this.factor?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `factor` property.
   *
   * @param value - the `factor` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setFactor(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = `Invalid MonetaryComponent.factor (${String(value)})`;
      this.factor = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.factor = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `factor` property exists and has a value; `false` otherwise
   */
  public hasFactor(): boolean {
    return this.hasFactorElement();
  }

  /**
   * @returns the `amount` property value as a Money object if defined; else an empty Money object
   */
  public getAmount(): Money {
    return this.amount ?? new Money();
  }

  /**
   * Assigns the provided Amount object value to the `amount` property.
   *
   * @param value - the `amount` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setAmount(value: Money | undefined): this {
    if (isDefined<Money>(value)) {
      const optErrMsg = `Invalid MonetaryComponent.amount; Provided element is not an instance of Money.`;
      assertFhirType<Money>(value, Money, optErrMsg);
      this.amount = value;
    } else {
      this.amount = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `amount` property exists and has a value; `false` otherwise
   */
  public hasAmount(): boolean {
    return isDefined<Money>(this.amount) && !this.amount.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'MonetaryComponent';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.type_,
      this.code,
      this.factor,
      this.amount,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): MonetaryComponent {
    const dest = new MonetaryComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: MonetaryComponent): void {
    super.copyValues(dest);
    dest.type_ = this.type_ ? this.type_.copy() : null;
    dest.code = this.code?.copy();
    dest.factor = this.factor?.copy();
    dest.amount = this.amount?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasTypeElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getTypeElement()!, 'type', jsonObj);
    } else {
      missingReqdProperties.push(`MonetaryComponent.type`);
    }

    if (this.hasCode()) {
      setFhirComplexJson(this.getCode(), 'code', jsonObj);
    }

    if (this.hasFactorElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getFactorElement(), 'factor', jsonObj);
    }

    if (this.hasAmount()) {
      setFhirComplexJson(this.getAmount(), 'amount', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_DO_NOT_EXIST} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

/**
 * Money Class
 *
 * @remarks
 * Money Type: An amount of economic utility in some recognized currency.
 *
 * **FHIR Specification**
 * - **Short:** An amount of economic utility in some recognized currency
 * - **Definition:** An amount of economic utility in some recognized currency.
 * - **FHIR Version:** 5.0.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR Money](http://hl7.org/fhir/StructureDefinition/Money)
 */
export class Money extends DataType implements IDataType {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided `Money` JSON to instantiate the Money data model.
   *
   * @param sourceJson - JSON representing FHIR `Money`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to Money
   * @returns Money data model or undefined for `Money`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Money | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Money';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new Money();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'value';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setValueElement(datatype);
    }

    fieldName = 'currency';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setCurrencyElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Money.value Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Numerical value (with implicit precision)
   * - **Definition:** Numerical value (with implicit precision).
   * - **Comment:** Monetary values have their own rules for handling precision (refer to standard accounting text books).
   * - **Requirements:** The amount of the currency. The value includes an implicit precision in the presentation of the value.
   * - **FHIR Type:** `decimal`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private value?: DecimalType | undefined;

  /**
   * Money.currency Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** ISO 4217 Currency Code
   * - **Definition:** ISO 4217 Currency Code.
   * - **Requirements:** A code indicating the currency, taken from ISO 4217.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private currency?: CodeType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `value` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getValueElement(): DecimalType {
    return this.value ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `value` property.
   *
   * @param element - the `value` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValueElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = `Invalid Money.value; Provided element is not an instance of DecimalType.`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.value = element;
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `value` property exists and has a value; `false` otherwise
   */
  public hasValueElement(): boolean {
    return isDefined<DecimalType>(this.value) && !this.value.isEmpty();
  }

  /**
   * @returns the `value` property value as a fhirDecimal if defined; else undefined
   */
  public getValue(): fhirDecimal | undefined {
    return this.value?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `value` property.
   *
   * @param value - the `value` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValue(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = `Invalid Money.value (${String(value)})`;
      this.value = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `value` property exists and has a value; `false` otherwise
   */
  public hasValue(): boolean {
    return this.hasValueElement();
  }

  /**
   * @returns the `currency` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getCurrencyElement(): CodeType {
    return this.currency ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `currency` property.
   *
   * @param element - the `currency` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCurrencyElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid Money.currency; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.currency = element;
    } else {
      this.currency = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `currency` property exists and has a value; `false` otherwise
   */
  public hasCurrencyElement(): boolean {
    return isDefined<CodeType>(this.currency) && !this.currency.isEmpty();
  }

  /**
   * @returns the `currency` property value as a fhirCode if defined; else undefined
   */
  public getCurrency(): fhirCode | undefined {
    return this.currency?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `currency` property.
   *
   * @param value - the `currency` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCurrency(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid Money.currency (${String(value)})`;
      this.currency = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.currency = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `currency` property exists and has a value; `false` otherwise
   */
  public hasCurrency(): boolean {
    return this.hasCurrencyElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Money';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.value,
      this.currency,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Money {
    const dest = new Money();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Money): void {
    super.copyValues(dest);
    dest.value = this.value?.copy();
    dest.currency = this.currency?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasValueElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getValueElement(), 'value', jsonObj);
    }

    if (this.hasCurrencyElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getCurrencyElement(), 'currency', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * ParameterDefinition Class
 *
 * @remarks
 * ParameterDefinition Type: The parameters to the module. This collection specifies both the input and output parameters. Input parameters are provided by the caller as part of the $evaluate operation. Output parameters are included in the GuidanceResponse.
 *
 * **FHIR Specification**
 * - **Short:** Definition of a parameter to a module
 * - **Definition:** The parameters to the module. This collection specifies both the input and output parameters. Input parameters are provided by the caller as part of the $evaluate operation. Output parameters are included in the GuidanceResponse.
 * - **FHIR Version:** 5.0.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR ParameterDefinition](http://hl7.org/fhir/StructureDefinition/ParameterDefinition)
 */
export class ParameterDefinition extends DataType implements IDataType {
  constructor(use: EnumCodeType | CodeType | fhirCode | null = null, type_: EnumCodeType | CodeType | fhirCode | null = null) {
    super();

    this.operationParameterUseEnum = new OperationParameterUseEnum();
    this.fhirTypesEnum = new FhirTypesEnum();

    this.use = constructorCodeValueAsEnumCodeType<OperationParameterUseEnum>(
      use,
      OperationParameterUseEnum,
      this.operationParameterUseEnum,
      'ParameterDefinition.use',
    );

    this.type_ = constructorCodeValueAsEnumCodeType<FhirTypesEnum>(
      type_,
      FhirTypesEnum,
      this.fhirTypesEnum,
      'ParameterDefinition.type',
    );
  }

  /**
   * Parse the provided `ParameterDefinition` JSON to instantiate the ParameterDefinition data model.
   *
   * @param sourceJson - JSON representing FHIR `ParameterDefinition`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to ParameterDefinition
   * @returns ParameterDefinition data model or undefined for `ParameterDefinition`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): ParameterDefinition | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'ParameterDefinition';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new ParameterDefinition();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'name';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setNameElement(datatype);
    }

    fieldName = 'use';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setUseElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'min';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: IntegerType | undefined = fhirParser.parseIntegerType(dtJson, dtSiblingJson);
      instance.setMinElement(datatype);
    }

    fieldName = 'max';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setMaxElement(datatype);
    }

    fieldName = 'documentation';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setDocumentationElement(datatype);
    }

    fieldName = 'type';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setTypeElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'profile';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CanonicalType | undefined = fhirParser.parseCanonicalType(dtJson, dtSiblingJson);
      instance.setProfileElement(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_REQD_IN_JSON} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * ParameterDefinition.name Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Name used to access the parameter value
   * - **Definition:** The name of the parameter used to allow access to the value of the parameter in evaluation contexts.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private name?: CodeType | undefined;

  /**
   * FHIR CodeSystem: OperationParameterUse
   *
   * @see {@link OperationParameterUseEnum }
   */
  private readonly operationParameterUseEnum: OperationParameterUseEnum;

  /**
   * ParameterDefinition.use Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** in | out
   * - **Definition:** Whether the parameter is input or output for the module.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link OperationParameterUseEnum }
   */
  private use: EnumCodeType | null;

  /**
   * ParameterDefinition.min Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Minimum cardinality
   * - **Definition:** The minimum number of times this parameter SHALL appear in the request or response.
   * - **FHIR Type:** `integer`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private min?: IntegerType | undefined;

  /**
   * ParameterDefinition.max Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Maximum cardinality (a number of *)
   * - **Definition:** The maximum number of times this element is permitted to appear in the request or response.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private max?: StringType | undefined;

  /**
   * ParameterDefinition.documentation Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A brief description of the parameter
   * - **Definition:** A brief discussion of what the parameter is for and how it is used by the module.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private documentation?: StringType | undefined;

  /**
   * FHIR CodeSystem: FhirTypes
   *
   * @see {@link FhirTypesEnum }
   */
  private readonly fhirTypesEnum: FhirTypesEnum;

  /**
   * ParameterDefinition.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** What type of value
   * - **Definition:** The type of the parameter.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link FhirTypesEnum }
   */
  private type_: EnumCodeType | null;

  /**
   * ParameterDefinition.profile Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** What profile the value is expected to be
   * - **Definition:** If specified, this indicates a profile that the input data must conform to, or that the output data will conform to.
   * - **FHIR Type:** `canonical`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/StructureDefinition',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private profile?: CanonicalType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `name` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getNameElement(): CodeType {
    return this.name ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `name` property.
   *
   * @param element - the `name` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setNameElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid ParameterDefinition.name; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.name = element;
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `name` property exists and has a value; `false` otherwise
   */
  public hasNameElement(): boolean {
    return isDefined<CodeType>(this.name) && !this.name.isEmpty();
  }

  /**
   * @returns the `name` property value as a fhirCode if defined; else undefined
   */
  public getName(): fhirCode | undefined {
    return this.name?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `name` property.
   *
   * @param value - the `name` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setName(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid ParameterDefinition.name (${String(value)})`;
      this.name = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `name` property exists and has a value; `false` otherwise
   */
  public hasName(): boolean {
    return this.hasNameElement();
  }

  /**
   * @returns the `use` property value as a EnumCodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link OperationParameterUseEnum }
   */
  public getUseEnumType(): EnumCodeType | null {
    return this.use;
  }

  /**
   * Assigns the provided EnumCodeType value to the `use` property.
   *
   * @param enumType - the `use` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link OperationParameterUseEnum }
   */
  public setUseEnumType(enumType: EnumCodeType): this {
    assertIsDefined<EnumCodeType>(enumType, `ParameterDefinition.use is required`);
    const errMsgPrefix = `Invalid ParameterDefinition.use`;
    assertEnumCodeType<OperationParameterUseEnum>(enumType, OperationParameterUseEnum, errMsgPrefix);
    this.use = enumType;
    return this;
  }

  /**
   * @returns `true` if the `use` property exists and has a value; `false` otherwise
   */
  public hasUseEnumType(): boolean {
    return isDefined<EnumCodeType>(this.use) && !this.use.isEmpty() && this.use.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the `use` property value as a CodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link OperationParameterUseEnum }
   */
  public getUseElement(): CodeType | null {
    if (this.use === null) {
      return null;
    }
    return this.use as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the `use` property.
   *
   * @param element - the `use` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link OperationParameterUseEnum }
   */
  public setUseElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, `ParameterDefinition.use is required`);
    const optErrMsg = `Invalid ParameterDefinition.use; Provided value is not an instance of CodeType.`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.use = new EnumCodeType(element, this.operationParameterUseEnum);
    return this;
  }

  /**
   * @returns `true` if the `use` property exists and has a value; `false` otherwise
   */
  public hasUseElement(): boolean {
    return this.hasUseEnumType();
  }

  /**
   * @returns the `use` property value as a fhirCode if defined; else null
   *
   * @see CodeSystem Enumeration: {@link OperationParameterUseEnum }
   */
  public getUse(): fhirCode | null {
    if (this.use === null) {
      return null;
    }
    return this.use.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the `use` property.
   *
   * @param value - the `use` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link OperationParameterUseEnum }
   */
  public setUse(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, `ParameterDefinition.use is required`);
    const optErrMsg = `Invalid ParameterDefinition.use (${String(value)})`;
    this.use = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.operationParameterUseEnum);
    return this;
  }

  /**
   * @returns `true` if the `use` property exists and has a value; `false` otherwise
   */
  public hasUse(): boolean {
    return this.hasUseEnumType();
  }

  /**
   * @returns the `min` property value as a IntegerType object if defined; else an empty IntegerType object
   */
  public getMinElement(): IntegerType {
    return this.min ?? new IntegerType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `min` property.
   *
   * @param element - the `min` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMinElement(element: IntegerType | undefined): this {
    if (isDefined<IntegerType>(element)) {
      const optErrMsg = `Invalid ParameterDefinition.min; Provided element is not an instance of IntegerType.`;
      assertFhirType<IntegerType>(element, IntegerType, optErrMsg);
      this.min = element;
    } else {
      this.min = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `min` property exists and has a value; `false` otherwise
   */
  public hasMinElement(): boolean {
    return isDefined<IntegerType>(this.min) && !this.min.isEmpty();
  }

  /**
   * @returns the `min` property value as a fhirInteger if defined; else undefined
   */
  public getMin(): fhirInteger | undefined {
    return this.min?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `min` property.
   *
   * @param value - the `min` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMin(value: fhirInteger | undefined): this {
    if (isDefined<fhirInteger>(value)) {
      const optErrMsg = `Invalid ParameterDefinition.min (${String(value)})`;
      this.min = new IntegerType(parseFhirPrimitiveData(value, fhirIntegerSchema, optErrMsg));
    } else {
      this.min = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `min` property exists and has a value; `false` otherwise
   */
  public hasMin(): boolean {
    return this.hasMinElement();
  }

  /**
   * @returns the `max` property value as a StringType object if defined; else an empty StringType object
   */
  public getMaxElement(): StringType {
    return this.max ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `max` property.
   *
   * @param element - the `max` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMaxElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid ParameterDefinition.max; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.max = element;
    } else {
      this.max = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `max` property exists and has a value; `false` otherwise
   */
  public hasMaxElement(): boolean {
    return isDefined<StringType>(this.max) && !this.max.isEmpty();
  }

  /**
   * @returns the `max` property value as a fhirString if defined; else undefined
   */
  public getMax(): fhirString | undefined {
    return this.max?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `max` property.
   *
   * @param value - the `max` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMax(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid ParameterDefinition.max (${String(value)})`;
      this.max = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.max = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `max` property exists and has a value; `false` otherwise
   */
  public hasMax(): boolean {
    return this.hasMaxElement();
  }

  /**
   * @returns the `documentation` property value as a StringType object if defined; else an empty StringType object
   */
  public getDocumentationElement(): StringType {
    return this.documentation ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `documentation` property.
   *
   * @param element - the `documentation` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDocumentationElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid ParameterDefinition.documentation; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.documentation = element;
    } else {
      this.documentation = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `documentation` property exists and has a value; `false` otherwise
   */
  public hasDocumentationElement(): boolean {
    return isDefined<StringType>(this.documentation) && !this.documentation.isEmpty();
  }

  /**
   * @returns the `documentation` property value as a fhirString if defined; else undefined
   */
  public getDocumentation(): fhirString | undefined {
    return this.documentation?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `documentation` property.
   *
   * @param value - the `documentation` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDocumentation(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid ParameterDefinition.documentation (${String(value)})`;
      this.documentation = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.documentation = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `documentation` property exists and has a value; `false` otherwise
   */
  public hasDocumentation(): boolean {
    return this.hasDocumentationElement();
  }

  /**
   * @returns the `type_` property value as a EnumCodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link FhirTypesEnum }
   */
  public getTypeEnumType(): EnumCodeType | null {
    return this.type_;
  }

  /**
   * Assigns the provided EnumCodeType value to the `type_` property.
   *
   * @param enumType - the `type_` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link FhirTypesEnum }
   */
  public setTypeEnumType(enumType: EnumCodeType): this {
    assertIsDefined<EnumCodeType>(enumType, `ParameterDefinition.type is required`);
    const errMsgPrefix = `Invalid ParameterDefinition.type`;
    assertEnumCodeType<FhirTypesEnum>(enumType, FhirTypesEnum, errMsgPrefix);
    this.type_ = enumType;
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasTypeEnumType(): boolean {
    return isDefined<EnumCodeType>(this.type_) && !this.type_.isEmpty() && this.type_.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the `type_` property value as a CodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link FhirTypesEnum }
   */
  public getTypeElement(): CodeType | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_ as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the `type_` property.
   *
   * @param element - the `type_` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link FhirTypesEnum }
   */
  public setTypeElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, `ParameterDefinition.type is required`);
    const optErrMsg = `Invalid ParameterDefinition.type; Provided value is not an instance of CodeType.`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.type_ = new EnumCodeType(element, this.fhirTypesEnum);
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasTypeElement(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the `type_` property value as a fhirCode if defined; else null
   *
   * @see CodeSystem Enumeration: {@link FhirTypesEnum }
   */
  public getType(): fhirCode | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the `type_` property.
   *
   * @param value - the `type_` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link FhirTypesEnum }
   */
  public setType(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, `ParameterDefinition.type is required`);
    const optErrMsg = `Invalid ParameterDefinition.type (${String(value)})`;
    this.type_ = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.fhirTypesEnum);
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasType(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the `profile` property value as a CanonicalType object if defined; else an empty CanonicalType object
   */
  public getProfileElement(): CanonicalType {
    return this.profile ?? new CanonicalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `profile` property.
   *
   * @param element - the `profile` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setProfileElement(element: CanonicalType | undefined): this {
    if (isDefined<CanonicalType>(element)) {
      const optErrMsg = `Invalid ParameterDefinition.profile; Provided element is not an instance of CanonicalType.`;
      assertFhirType<CanonicalType>(element, CanonicalType, optErrMsg);
      this.profile = element;
    } else {
      this.profile = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `profile` property exists and has a value; `false` otherwise
   */
  public hasProfileElement(): boolean {
    return isDefined<CanonicalType>(this.profile) && !this.profile.isEmpty();
  }

  /**
   * @returns the `profile` property value as a fhirCanonical if defined; else undefined
   */
  public getProfile(): fhirCanonical | undefined {
    return this.profile?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `profile` property.
   *
   * @param value - the `profile` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setProfile(value: fhirCanonical | undefined): this {
    if (isDefined<fhirCanonical>(value)) {
      const optErrMsg = `Invalid ParameterDefinition.profile (${String(value)})`;
      this.profile = new CanonicalType(parseFhirPrimitiveData(value, fhirCanonicalSchema, optErrMsg));
    } else {
      this.profile = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `profile` property exists and has a value; `false` otherwise
   */
  public hasProfile(): boolean {
    return this.hasProfileElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'ParameterDefinition';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.name,
      this.use,
      this.min,
      this.max,
      this.documentation,
      this.type_,
      this.profile,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): ParameterDefinition {
    const dest = new ParameterDefinition();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: ParameterDefinition): void {
    super.copyValues(dest);
    dest.name = this.name?.copy();
    dest.use = this.use ? this.use.copy() : null;
    dest.min = this.min?.copy();
    dest.max = this.max?.copy();
    dest.documentation = this.documentation?.copy();
    dest.type_ = this.type_ ? this.type_.copy() : null;
    dest.profile = this.profile?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasNameElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getNameElement(), 'name', jsonObj);
    }

    if (this.hasUseElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getUseElement()!, 'use', jsonObj);
    } else {
      missingReqdProperties.push(`ParameterDefinition.use`);
    }

    if (this.hasMinElement()) {
      setFhirPrimitiveJson<fhirInteger>(this.getMinElement(), 'min', jsonObj);
    }

    if (this.hasMaxElement()) {
      setFhirPrimitiveJson<fhirString>(this.getMaxElement(), 'max', jsonObj);
    }

    if (this.hasDocumentationElement()) {
      setFhirPrimitiveJson<fhirString>(this.getDocumentationElement(), 'documentation', jsonObj);
    }

    if (this.hasTypeElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getTypeElement()!, 'type', jsonObj);
    } else {
      missingReqdProperties.push(`ParameterDefinition.type`);
    }

    if (this.hasProfileElement()) {
      setFhirPrimitiveJson<fhirCanonical>(this.getProfileElement(), 'profile', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_DO_NOT_EXIST} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

/**
 * ProductShelfLife Class
 *
 * @remarks
 * ProductShelfLife Type: The shelf-life and storage information for a medicinal product item or container can be described using this class.
 *
 * **FHIR Specification**
 * - **Short:** The shelf-life and storage information for a medicinal product item or container can be described using this class
 * - **Definition:** The shelf-life and storage information for a medicinal product item or container can be described using this class.
 * - **FHIR Version:** 5.0.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR ProductShelfLife](http://hl7.org/fhir/StructureDefinition/ProductShelfLife)
 */
export class ProductShelfLife extends BackboneType implements IBackboneType {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided `ProductShelfLife` JSON to instantiate the ProductShelfLife data model.
   *
   * @param sourceJson - JSON representing FHIR `ProductShelfLife`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to ProductShelfLife
   * @returns ProductShelfLife data model or undefined for `ProductShelfLife`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): ProductShelfLife | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'ProductShelfLife';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new ProductShelfLife();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneTypeJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';

    const classMetadata: DecoratorMetadataObject | null = ProductShelfLife[Symbol.metadata];
    const errorMessage = `DecoratorMetadataObject does not exist for ProductShelfLife`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    fieldName = 'type';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = CodeableConcept.parse(classJsonObj[fieldName]!, sourceField);
      instance.setType(datatype);
    }

    fieldName = 'period[x]';
    sourceField = `${optSourceValue}.${fieldName}`;
    const period: IDataType | undefined = fhirParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setPeriod(period);

    fieldName = 'specialPrecautionsForStorage';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: CodeableConcept | undefined = CodeableConcept.parse(dataElementJson, `${sourceField}[${String(idx)}]`);
        if (datatype !== undefined) {
          instance.addSpecialPrecautionsForStorage(datatype);
        }
      });
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * ProductShelfLife.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** This describes the shelf life, taking into account various scenarios such as shelf life of the packaged Medicinal Product itself, shelf life after transformation where necessary and shelf life after the first opening of a bottle, etc. The shelf life type shall be specified using an appropriate controlled vocabulary The controlled term and the controlled term identifier shall be specified
   * - **Definition:** This describes the shelf life, taking into account various scenarios such as shelf life of the packaged Medicinal Product itself, shelf life after transformation where necessary and shelf life after the first opening of a bottle, etc. The shelf life type shall be specified using an appropriate controlled vocabulary The controlled term and the controlled term identifier shall be specified.
   * - **FHIR Type:** `CodeableConcept`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private type_?: CodeableConcept | undefined;

  /**
   * ProductShelfLife.period[x] Element
   *
   * @decorator `@ChoiceDataTypesMeta('ProductShelfLife.period[x]', ['Duration','string',]`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The shelf life time period can be specified using a numerical value for the period of time and its unit of time measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used
   * - **Definition:** The shelf life time period can be specified using a numerical value for the period of time and its unit of time measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used.
   * - **FHIR Types:**
   *     'Duration',
   *     'string',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('ProductShelfLife.period[x]',[
    'Duration',
    'string',
  ])
  private period?: IDataType | undefined;

  /**
   * ProductShelfLife.specialPrecautionsForStorage Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Special precautions for storage, if any, can be specified using an appropriate controlled vocabulary The controlled term and the controlled term identifier shall be specified
   * - **Definition:** Special precautions for storage, if any, can be specified using an appropriate controlled vocabulary The controlled term and the controlled term identifier shall be specified.
   * - **FHIR Type:** `CodeableConcept`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private specialPrecautionsForStorage?: CodeableConcept[] | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `type_` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getType(): CodeableConcept {
    return this.type_ ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Type object value to the `type_` property.
   *
   * @param value - the `type_` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setType(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = `Invalid ProductShelfLife.type; Provided element is not an instance of CodeableConcept.`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.type_ = value;
    } else {
      this.type_ = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasType(): boolean {
    return isDefined<CodeableConcept>(this.type_) && !this.type_.isEmpty();
  }

  /**
   * @returns the `period` property value as a DataType object if defined; else undefined
   */
  public getPeriod(): IDataType | undefined {
    return this.period;
  }

  /**
   * Assigns the provided DataType object value to the `period` property.
   *
   * @decorator `@ChoiceDataTypes('ProductShelfLife.period[x]')`
   *
   * @param value - the `period` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  @ChoiceDataTypes('ProductShelfLife.period[x]')
  public setPeriod(value: IDataType | undefined): this {
    if (isDefined<IDataType>(value)) {
      // assertFhirType<IDataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.period = value;
    } else {
      this.period = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `period` property exists and has a value; `false` otherwise
   */
  public hasPeriod(): boolean {
    return isDefined<IDataType>(this.period) && !this.period.isEmpty();
  }

  // *** NOTE ***
  // Following choice datatype-specific "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the `period` property value as a Duration object if defined; else undefined
   */
  public getPeriodDuration(): Duration | undefined {
    if (!isDefined<IDataType | undefined>(this.period)) {
      return undefined;
    }
    if (!(this.period instanceof Duration)) {
      throw new InvalidTypeError(
        `DataType mismatch for ProductShelfLife.period[x]: Expected Duration but encountered ${this.period.fhirType()}`,
      );
    }
    return this.period;
  }

  /**
   * @returns `true` if the `period` property exists as a Duration and has a value; `false` otherwise
   */
  public hasPeriodDuration(): boolean {
    return this.hasPeriod() && this.period instanceof Duration;
  }

  /**
   * @returns the `period` property value as a StringType object if defined; else undefined
   */
  public getPeriodStringType(): StringType | undefined {
    if (!isDefined<IDataType | undefined>(this.period)) {
      return undefined;
    }
    if (!(this.period instanceof StringType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ProductShelfLife.period[x]: Expected StringType but encountered ${this.period.fhirType()}`,
      );
    }
    return this.period;
  }

  /**
   * @returns `true` if the `period` property exists as a StringType and has a value; `false` otherwise
   */
  public hasPeriodStringType(): boolean {
    return this.hasPeriod() && this.period instanceof StringType;
  }

  // End of choice datatype-specific "get"/"has" methods

  /**
   * @returns the `specialPrecautionsForStorage` property value as a CodeableConcept array
   */
  public getSpecialPrecautionsForStorage(): CodeableConcept[] {
    return this.specialPrecautionsForStorage ?? ([] as CodeableConcept[]);
  }

  /**
   * Assigns the provided CodeableConcept array value to the `specialPrecautionsForStorage` property.
   *
   * @param value - the `specialPrecautionsForStorage` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setSpecialPrecautionsForStorage(value: CodeableConcept[] | undefined): this {
    if (isDefinedList<CodeableConcept>(value)) {
      const optErrMsg = `Invalid ProductShelfLife.specialPrecautionsForStorage; Provided value array has an element that is not an instance of CodeableConcept.`;
      assertFhirTypeList<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.specialPrecautionsForStorage = value;
    } else {
      this.specialPrecautionsForStorage = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeableConcept value to the `specialPrecautionsForStorage` array property.
   *
   * @param value - the `specialPrecautionsForStorage` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addSpecialPrecautionsForStorage(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = `Invalid ProductShelfLife.specialPrecautionsForStorage; Provided element is not an instance of CodeableConcept.`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.initSpecialPrecautionsForStorage();
      this.specialPrecautionsForStorage?.push(value);
    }
    return this;
  }

  /**
   * @returns `true` if the `specialPrecautionsForStorage` property exists and has a value; `false` otherwise
   */
  public hasSpecialPrecautionsForStorage(): boolean {
    return isDefinedList<CodeableConcept>(this.specialPrecautionsForStorage) && this.specialPrecautionsForStorage.some((item: CodeableConcept) => !item.isEmpty());
  }

  /**
   * Initialize the `specialPrecautionsForStorage` property
   */
  private initSpecialPrecautionsForStorage(): void {
    if(!this.hasSpecialPrecautionsForStorage()) {
      this.specialPrecautionsForStorage = [] as CodeableConcept[];
    }
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'ProductShelfLife';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.type_,
      this.period,
      this.specialPrecautionsForStorage,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): ProductShelfLife {
    const dest = new ProductShelfLife();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: ProductShelfLife): void {
    super.copyValues(dest);
    dest.type_ = this.type_?.copy();
    dest.period = this.period?.copy() as IDataType;
    const specialPrecautionsForStorageList = copyListValues<CodeableConcept>(this.specialPrecautionsForStorage);
    dest.specialPrecautionsForStorage = specialPrecautionsForStorageList.length === 0 ? undefined : specialPrecautionsForStorageList;
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasType()) {
      setFhirComplexJson(this.getType(), 'type', jsonObj);
    }

    if (this.hasPeriod()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getPeriod()!, 'period', jsonObj);
    }

    if (this.hasSpecialPrecautionsForStorage()) {
      setFhirComplexListJson(this.getSpecialPrecautionsForStorage(), 'specialPrecautionsForStorage', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * Quantity Class
 *
 * @remarks
 * Quantity Type: A measured amount (or an amount that can potentially be measured). Note that measured amounts include amounts that are not precisely quantified, including amounts involving arbitrary units and floating currencies.
 *
 * Need to able to capture all sorts of measured values, even if the measured value are not precisely quantified. Values include exact measures such as 3.51g, customary units such as 3 tablets, and currencies such as $100.32USD.
 *
 * **FHIR Specification**
 * - **Short:** A measured or measurable amount
 * - **Definition:** A measured amount (or an amount that can potentially be measured). Note that measured amounts include amounts that are not precisely quantified, including amounts involving arbitrary units and floating currencies.
 * - **Comment:** The context of use may frequently define what kind of quantity this is and therefore what kind of units can be used. The context of use may also restrict the values for the comparator.
 * - **FHIR Version:** 5.0.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR Quantity](http://hl7.org/fhir/StructureDefinition/Quantity)
 */
export class Quantity extends DataType implements IDataType {
  constructor() {
    super();

    this.quantityComparatorEnum = new QuantityComparatorEnum();
  }

  /**
   * Parse the provided `Quantity` JSON to instantiate the Quantity data model.
   *
   * @param sourceJson - JSON representing FHIR `Quantity`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to Quantity
   * @returns Quantity data model or undefined for `Quantity`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Quantity | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Quantity';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new Quantity();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'value';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setValueElement(datatype);
    }

    fieldName = 'comparator';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setComparatorElement(datatype);
    }

    fieldName = 'unit';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setUnitElement(datatype);
    }

    fieldName = 'system';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = fhirParser.parseUriType(dtJson, dtSiblingJson);
      instance.setSystemElement(datatype);
    }

    fieldName = 'code';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setCodeElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Quantity.value Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Numerical value (with implicit precision)
   * - **Definition:** The value of the measured amount. The value includes an implicit precision in the presentation of the value.
   * - **Comment:** The implicit precision in the value should always be honored. Monetary values have their own rules for handling precision (refer to standard accounting text books).
   * - **Requirements:** Precision is handled implicitly in almost all cases of measurement.
   * - **FHIR Type:** `decimal`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private value?: DecimalType | undefined;

  /**
   * FHIR CodeSystem: QuantityComparator
   *
   * @see {@link QuantityComparatorEnum }
   */
  private readonly quantityComparatorEnum: QuantityComparatorEnum;

  /**
   * Quantity.comparator Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** < | <= | >= | > | ad - how to understand the value
   * - **Definition:** How the value should be understood and represented - whether the actual value is greater or less than the stated value due to measurement issues; e.g. if the comparator is "<" , then the real value is < stated value.
   * - **Requirements:** Need a framework for handling measures where the value is <5ug/L or >400mg/L due to the limitations of measuring methodology.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** true
   * - **isModifierReason:** This is labeled as &quot;Is Modifier&quot; because the comparator modifies the interpretation of the value significantly. If there is no comparator, then there is no modification of the value
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  private comparator?: EnumCodeType | undefined;

  /**
   * Quantity.unit Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Unit representation
   * - **Definition:** A human-readable form of the unit.
   * - **Requirements:** There are many representations for units of measure and in many contexts, particular representations are fixed and required. I.e. mcg for micrograms.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private unit?: StringType | undefined;

  /**
   * Quantity.system Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** System that defines coded unit form
   * - **Definition:** The identification of the system that provides the coded form of the unit.
   * - **Requirements:** Need to know the system that defines the coded form of the unit.
   * - **FHIR Type:** `uri`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private system?: UriType | undefined;

  /**
   * Quantity.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Coded form of the unit
   * - **Definition:** A computer processable form of the unit in some unit representation system.
   * - **Comment:** The preferred system is UCUM, but SNOMED CT can also be used (for customary units) or ISO 4217 for currency.  The context of use may additionally require a code from a particular system.
   * - **Requirements:** Need a computable form of the unit that is fixed across all forms. UCUM provides this for quantities, but SNOMED CT provides many units of interest.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code?: CodeType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `value` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getValueElement(): DecimalType {
    return this.value ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `value` property.
   *
   * @param element - the `value` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValueElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = `Invalid Quantity.value; Provided element is not an instance of DecimalType.`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.value = element;
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `value` property exists and has a value; `false` otherwise
   */
  public hasValueElement(): boolean {
    return isDefined<DecimalType>(this.value) && !this.value.isEmpty();
  }

  /**
   * @returns the `value` property value as a fhirDecimal if defined; else undefined
   */
  public getValue(): fhirDecimal | undefined {
    return this.value?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `value` property.
   *
   * @param value - the `value` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValue(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = `Invalid Quantity.value (${String(value)})`;
      this.value = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `value` property exists and has a value; `false` otherwise
   */
  public hasValue(): boolean {
    return this.hasValueElement();
  }

  /**
   * @returns the `comparator` property value as a EnumCodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public getComparatorEnumType(): EnumCodeType | undefined {
    return this.comparator;
  }

  /**
   * Assigns the provided EnumCodeType value to the `comparator` property.
   *
   * @param enumType - the `comparator` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code values
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public setComparatorEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid Quantity.comparator';
      assertEnumCodeType<QuantityComparatorEnum>(enumType, QuantityComparatorEnum, errMsgPrefix);
      this.comparator = enumType;
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `comparator` property exists and has a value; `false` otherwise
   */
  public hasComparatorEnumType(): boolean {
    return isDefined<EnumCodeType>(this.comparator) && !this.comparator.isEmpty() && this.comparator.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the `comparator` property value as a CodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public getComparatorElement(): CodeType | undefined {
    if (this.comparator === undefined) {
      return undefined;
    }
    return this.comparator as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the `comparator` property.
   *
   * @param element - the `comparator` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public setComparatorElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid Quantity.comparator; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.comparator = new EnumCodeType(element, this.quantityComparatorEnum);
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `comparator` property exists and has a value; `false` otherwise
   */
  public hasComparatorElement(): boolean {
    return this.hasComparatorEnumType();
  }

  /**
   * @returns the `comparator` property value as a fhirCode if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public getComparator(): fhirCode | undefined {
    if (this.comparator === undefined) {
      return undefined;
    }
    return this.comparator.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the `comparator` property.
   *
   * @param value - the `comparator` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public setComparator(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid Quantity.comparator; Provided value is not an instance of fhirCode.`;
      this.comparator = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.quantityComparatorEnum);
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `comparator` property exists and has a value; `false` otherwise
   */
  public hasComparator(): boolean {
    return this.hasComparatorEnumType();
  }

  /**
   * @returns the `unit` property value as a StringType object if defined; else an empty StringType object
   */
  public getUnitElement(): StringType {
    return this.unit ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `unit` property.
   *
   * @param element - the `unit` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUnitElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid Quantity.unit; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.unit = element;
    } else {
      this.unit = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `unit` property exists and has a value; `false` otherwise
   */
  public hasUnitElement(): boolean {
    return isDefined<StringType>(this.unit) && !this.unit.isEmpty();
  }

  /**
   * @returns the `unit` property value as a fhirString if defined; else undefined
   */
  public getUnit(): fhirString | undefined {
    return this.unit?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `unit` property.
   *
   * @param value - the `unit` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUnit(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid Quantity.unit (${String(value)})`;
      this.unit = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.unit = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `unit` property exists and has a value; `false` otherwise
   */
  public hasUnit(): boolean {
    return this.hasUnitElement();
  }

  /**
   * @returns the `system` property value as a UriType object if defined; else an empty UriType object
   */
  public getSystemElement(): UriType {
    return this.system ?? new UriType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `system` property.
   *
   * @param element - the `system` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSystemElement(element: UriType | undefined): this {
    if (isDefined<UriType>(element)) {
      const optErrMsg = `Invalid Quantity.system; Provided element is not an instance of UriType.`;
      assertFhirType<UriType>(element, UriType, optErrMsg);
      this.system = element;
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `system` property exists and has a value; `false` otherwise
   */
  public hasSystemElement(): boolean {
    return isDefined<UriType>(this.system) && !this.system.isEmpty();
  }

  /**
   * @returns the `system` property value as a fhirUri if defined; else undefined
   */
  public getSystem(): fhirUri | undefined {
    return this.system?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `system` property.
   *
   * @param value - the `system` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSystem(value: fhirUri | undefined): this {
    if (isDefined<fhirUri>(value)) {
      const optErrMsg = `Invalid Quantity.system (${String(value)})`;
      this.system = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `system` property exists and has a value; `false` otherwise
   */
  public hasSystem(): boolean {
    return this.hasSystemElement();
  }

  /**
   * @returns the `code` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getCodeElement(): CodeType {
    return this.code ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `code` property.
   *
   * @param element - the `code` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCodeElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid Quantity.code; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.code = element;
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `code` property exists and has a value; `false` otherwise
   */
  public hasCodeElement(): boolean {
    return isDefined<CodeType>(this.code) && !this.code.isEmpty();
  }

  /**
   * @returns the `code` property value as a fhirCode if defined; else undefined
   */
  public getCode(): fhirCode | undefined {
    return this.code?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `code` property.
   *
   * @param value - the `code` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCode(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid Quantity.code (${String(value)})`;
      this.code = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `code` property exists and has a value; `false` otherwise
   */
  public hasCode(): boolean {
    return this.hasCodeElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Quantity';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.value,
      this.comparator,
      this.unit,
      this.system,
      this.code,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Quantity {
    const dest = new Quantity();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Quantity): void {
    super.copyValues(dest);
    dest.value = this.value?.copy();
    dest.comparator = this.comparator?.copy();
    dest.unit = this.unit?.copy();
    dest.system = this.system?.copy();
    dest.code = this.code?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasValueElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getValueElement(), 'value', jsonObj);
    }

    if (this.hasComparatorElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getComparatorElement()!, 'comparator', jsonObj);
    }

    if (this.hasUnitElement()) {
      setFhirPrimitiveJson<fhirString>(this.getUnitElement(), 'unit', jsonObj);
    }

    if (this.hasSystemElement()) {
      setFhirPrimitiveJson<fhirUri>(this.getSystemElement(), 'system', jsonObj);
    }

    if (this.hasCodeElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getCodeElement(), 'code', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * Range Class
 *
 * @remarks
 * Range Type: A set of ordered Quantities defined by a low and high limit.
 *
 * Need to be able to specify ranges of values.
 *
 * **FHIR Specification**
 * - **Short:** Set of values bounded by low and high
 * - **Definition:** A set of ordered Quantities defined by a low and high limit.
 * - **Comment:** The stated low and high value are assumed to have arbitrarily high precision when it comes to determining which values are in the range. I.e. 1.99 is not in the range 2 -> 3.
 * - **FHIR Version:** 5.0.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR Range](http://hl7.org/fhir/StructureDefinition/Range)
 */
export class Range extends DataType implements IDataType {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided `Range` JSON to instantiate the Range data model.
   *
   * @param sourceJson - JSON representing FHIR `Range`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to Range
   * @returns Range data model or undefined for `Range`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Range | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Range';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new Range();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';

    fieldName = 'low';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = Quantity.parse(classJsonObj[fieldName]!, sourceField);
      instance.setLow(datatype);
    }

    fieldName = 'high';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = Quantity.parse(classJsonObj[fieldName]!, sourceField);
      instance.setHigh(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Range.low Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Low limit
   * - **Definition:** The low limit. The boundary is inclusive.
   * - **Comment:** If the low element is missing, the low boundary is not known.
   * - **FHIR Type:** `Quantity`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private low?: Quantity | undefined;

  /**
   * Range.high Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** High limit
   * - **Definition:** The high limit. The boundary is inclusive.
   * - **Comment:** If the high element is missing, the high boundary is not known.
   * - **FHIR Type:** `Quantity`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private high?: Quantity | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `low` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getLow(): Quantity {
    return this.low ?? new Quantity();
  }

  /**
   * Assigns the provided Low object value to the `low` property.
   *
   * @param value - the `low` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setLow(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = `Invalid Range.low; Provided element is not an instance of Quantity.`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.low = value;
    } else {
      this.low = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `low` property exists and has a value; `false` otherwise
   */
  public hasLow(): boolean {
    return isDefined<Quantity>(this.low) && !this.low.isEmpty();
  }

  /**
   * @returns the `high` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getHigh(): Quantity {
    return this.high ?? new Quantity();
  }

  /**
   * Assigns the provided High object value to the `high` property.
   *
   * @param value - the `high` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setHigh(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = `Invalid Range.high; Provided element is not an instance of Quantity.`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.high = value;
    } else {
      this.high = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `high` property exists and has a value; `false` otherwise
   */
  public hasHigh(): boolean {
    return isDefined<Quantity>(this.high) && !this.high.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Range';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.low,
      this.high,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Range {
    const dest = new Range();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Range): void {
    super.copyValues(dest);
    dest.low = this.low?.copy();
    dest.high = this.high?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasLow()) {
      setFhirComplexJson(this.getLow(), 'low', jsonObj);
    }

    if (this.hasHigh()) {
      setFhirComplexJson(this.getHigh(), 'high', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * Ratio Class
 *
 * @remarks
 * Ratio Type: A relationship of two Quantity values - expressed as a numerator and a denominator.
 *
 * Need to able to capture ratios for some measurements (titers) and some rates (costs).
 *
 * **FHIR Specification**
 * - **Short:** A ratio of two Quantity values - a numerator and a denominator
 * - **Definition:** A relationship of two Quantity values - expressed as a numerator and a denominator.
 * - **Comment:** The Ratio datatype should only be used to express a relationship of two numbers if the relationship cannot be suitably expressed using a Quantity and a common unit.  Where the denominator value is known to be fixed to "1", Quantity should be used instead of Ratio.
 * - **FHIR Version:** 5.0.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR Ratio](http://hl7.org/fhir/StructureDefinition/Ratio)
 */
export class Ratio extends DataType implements IDataType {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided `Ratio` JSON to instantiate the Ratio data model.
   *
   * @param sourceJson - JSON representing FHIR `Ratio`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to Ratio
   * @returns Ratio data model or undefined for `Ratio`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Ratio | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Ratio';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new Ratio();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';

    fieldName = 'numerator';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = Quantity.parse(classJsonObj[fieldName]!, sourceField);
      instance.setNumerator(datatype);
    }

    fieldName = 'denominator';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = Quantity.parse(classJsonObj[fieldName]!, sourceField);
      instance.setDenominator(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Ratio.numerator Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Numerator value
   * - **Definition:** The value of the numerator.
   * - **FHIR Type:** `Quantity`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private numerator?: Quantity | undefined;

  /**
   * Ratio.denominator Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Denominator value
   * - **Definition:** The value of the denominator.
   * - **FHIR Type:** `Quantity`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private denominator?: Quantity | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `numerator` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getNumerator(): Quantity {
    return this.numerator ?? new Quantity();
  }

  /**
   * Assigns the provided Numerator object value to the `numerator` property.
   *
   * @param value - the `numerator` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setNumerator(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = `Invalid Ratio.numerator; Provided element is not an instance of Quantity.`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.numerator = value;
    } else {
      this.numerator = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `numerator` property exists and has a value; `false` otherwise
   */
  public hasNumerator(): boolean {
    return isDefined<Quantity>(this.numerator) && !this.numerator.isEmpty();
  }

  /**
   * @returns the `denominator` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getDenominator(): Quantity {
    return this.denominator ?? new Quantity();
  }

  /**
   * Assigns the provided Denominator object value to the `denominator` property.
   *
   * @param value - the `denominator` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setDenominator(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = `Invalid Ratio.denominator; Provided element is not an instance of Quantity.`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.denominator = value;
    } else {
      this.denominator = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `denominator` property exists and has a value; `false` otherwise
   */
  public hasDenominator(): boolean {
    return isDefined<Quantity>(this.denominator) && !this.denominator.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Ratio';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.numerator,
      this.denominator,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Ratio {
    const dest = new Ratio();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Ratio): void {
    super.copyValues(dest);
    dest.numerator = this.numerator?.copy();
    dest.denominator = this.denominator?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasNumerator()) {
      setFhirComplexJson(this.getNumerator(), 'numerator', jsonObj);
    }

    if (this.hasDenominator()) {
      setFhirComplexJson(this.getDenominator(), 'denominator', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * RatioRange Class
 *
 * @remarks
 * RatioRange Type: A range of ratios expressed as a low and high numerator and a denominator.
 *
 * Need to be able to specify ranges of ratios.
 *
 * **FHIR Specification**
 * - **Short:** Range of ratio values
 * - **Definition:** A range of ratios expressed as a low and high numerator and a denominator.
 * - **Comment:** The stated low and high value are assumed to have arbitrarily high precision when it comes to determining which values are in the range. I.e. 1.99 is not in the range 2 -> 3.
 * - **FHIR Version:** 5.0.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR RatioRange](http://hl7.org/fhir/StructureDefinition/RatioRange)
 */
export class RatioRange extends DataType implements IDataType {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided `RatioRange` JSON to instantiate the RatioRange data model.
   *
   * @param sourceJson - JSON representing FHIR `RatioRange`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to RatioRange
   * @returns RatioRange data model or undefined for `RatioRange`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): RatioRange | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'RatioRange';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new RatioRange();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';

    fieldName = 'lowNumerator';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = Quantity.parse(classJsonObj[fieldName]!, sourceField);
      instance.setLowNumerator(datatype);
    }

    fieldName = 'highNumerator';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = Quantity.parse(classJsonObj[fieldName]!, sourceField);
      instance.setHighNumerator(datatype);
    }

    fieldName = 'denominator';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = Quantity.parse(classJsonObj[fieldName]!, sourceField);
      instance.setDenominator(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * RatioRange.lowNumerator Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Low Numerator limit
   * - **Definition:** The value of the low limit numerator.
   * - **Comment:** If the low element is missing, the low boundary is not known.
   * - **FHIR Type:** `Quantity`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private lowNumerator?: Quantity | undefined;

  /**
   * RatioRange.highNumerator Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** High Numerator limit
   * - **Definition:** The value of the high limit numerator.
   * - **Comment:** If the high element is missing, the high boundary is not known.
   * - **FHIR Type:** `Quantity`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private highNumerator?: Quantity | undefined;

  /**
   * RatioRange.denominator Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Denominator value
   * - **Definition:** The value of the denominator.
   * - **FHIR Type:** `Quantity`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private denominator?: Quantity | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `lowNumerator` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getLowNumerator(): Quantity {
    return this.lowNumerator ?? new Quantity();
  }

  /**
   * Assigns the provided LowNumerator object value to the `lowNumerator` property.
   *
   * @param value - the `lowNumerator` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setLowNumerator(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = `Invalid RatioRange.lowNumerator; Provided element is not an instance of Quantity.`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.lowNumerator = value;
    } else {
      this.lowNumerator = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `lowNumerator` property exists and has a value; `false` otherwise
   */
  public hasLowNumerator(): boolean {
    return isDefined<Quantity>(this.lowNumerator) && !this.lowNumerator.isEmpty();
  }

  /**
   * @returns the `highNumerator` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getHighNumerator(): Quantity {
    return this.highNumerator ?? new Quantity();
  }

  /**
   * Assigns the provided HighNumerator object value to the `highNumerator` property.
   *
   * @param value - the `highNumerator` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setHighNumerator(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = `Invalid RatioRange.highNumerator; Provided element is not an instance of Quantity.`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.highNumerator = value;
    } else {
      this.highNumerator = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `highNumerator` property exists and has a value; `false` otherwise
   */
  public hasHighNumerator(): boolean {
    return isDefined<Quantity>(this.highNumerator) && !this.highNumerator.isEmpty();
  }

  /**
   * @returns the `denominator` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getDenominator(): Quantity {
    return this.denominator ?? new Quantity();
  }

  /**
   * Assigns the provided Denominator object value to the `denominator` property.
   *
   * @param value - the `denominator` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setDenominator(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = `Invalid RatioRange.denominator; Provided element is not an instance of Quantity.`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.denominator = value;
    } else {
      this.denominator = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `denominator` property exists and has a value; `false` otherwise
   */
  public hasDenominator(): boolean {
    return isDefined<Quantity>(this.denominator) && !this.denominator.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'RatioRange';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.lowNumerator,
      this.highNumerator,
      this.denominator,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): RatioRange {
    const dest = new RatioRange();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: RatioRange): void {
    super.copyValues(dest);
    dest.lowNumerator = this.lowNumerator?.copy();
    dest.highNumerator = this.highNumerator?.copy();
    dest.denominator = this.denominator?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasLowNumerator()) {
      setFhirComplexJson(this.getLowNumerator(), 'lowNumerator', jsonObj);
    }

    if (this.hasHighNumerator()) {
      setFhirComplexJson(this.getHighNumerator(), 'highNumerator', jsonObj);
    }

    if (this.hasDenominator()) {
      setFhirComplexJson(this.getDenominator(), 'denominator', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * RelatedArtifact Class
 *
 * @remarks
 * RelatedArtifact Type: Related artifacts such as additional documentation, justification, or bibliographic references.
 *
 * Knowledge resources must be able to provide enough information for consumers of the content (and/or interventions or results produced by the content) to be able to determine and understand the justification for and evidence in support of the content.
 *
 * **FHIR Specification**
 * - **Short:** Related artifacts for a knowledge resource
 * - **Definition:** Related artifacts such as additional documentation, justification, or bibliographic references.
 * - **Comment:** Each related artifact is either an attachment, or a reference to another knowledge resource, but not both.
 * - **FHIR Version:** 5.0.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR RelatedArtifact](http://hl7.org/fhir/StructureDefinition/RelatedArtifact)
 */
export class RelatedArtifact extends DataType implements IDataType {
  constructor(type_: EnumCodeType | CodeType | fhirCode | null = null) {
    super();

    this.relatedArtifactTypeEnum = new RelatedArtifactTypeEnum();
    this.publicationStatusEnum = new PublicationStatusEnum();

    this.type_ = constructorCodeValueAsEnumCodeType<RelatedArtifactTypeEnum>(
      type_,
      RelatedArtifactTypeEnum,
      this.relatedArtifactTypeEnum,
      'RelatedArtifact.type',
    );
  }

  /**
   * Parse the provided `RelatedArtifact` JSON to instantiate the RelatedArtifact data model.
   *
   * @param sourceJson - JSON representing FHIR `RelatedArtifact`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to RelatedArtifact
   * @returns RelatedArtifact data model or undefined for `RelatedArtifact`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): RelatedArtifact | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'RelatedArtifact';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new RelatedArtifact();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'type';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setTypeElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'classifier';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: CodeableConcept | undefined = CodeableConcept.parse(dataElementJson, `${sourceField}[${String(idx)}]`);
        if (datatype !== undefined) {
          instance.addClassifier(datatype);
        }
      });
    }

    fieldName = 'label';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setLabelElement(datatype);
    }

    fieldName = 'display';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setDisplayElement(datatype);
    }

    fieldName = 'citation';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: MarkdownType | undefined = fhirParser.parseMarkdownType(dtJson, dtSiblingJson);
      instance.setCitationElement(datatype);
    }

    fieldName = 'document';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Attachment | undefined = Attachment.parse(classJsonObj[fieldName]!, sourceField);
      instance.setDocument(datatype);
    }

    fieldName = 'resource';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CanonicalType | undefined = fhirParser.parseCanonicalType(dtJson, dtSiblingJson);
      instance.setResourceElement(datatype);
    }

    fieldName = 'resourceReference';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = Reference.parse(classJsonObj[fieldName]!, sourceField);
      instance.setResourceReference(datatype);
    }

    fieldName = 'publicationStatus';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setPublicationStatusElement(datatype);
    }

    fieldName = 'publicationDate';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DateType | undefined = fhirParser.parseDateType(dtJson, dtSiblingJson);
      instance.setPublicationDateElement(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_REQD_IN_JSON} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: RelatedArtifactType
   *
   * @see {@link RelatedArtifactTypeEnum }
   */
  private readonly relatedArtifactTypeEnum: RelatedArtifactTypeEnum;

  /**
   * RelatedArtifact.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** documentation | justification | citation | predecessor | successor | derived-from | depends-on | composed-of | part-of | amends | amended-with | appends | appended-with | cites | cited-by | comments-on | comment-in | contains | contained-in | corrects | correction-in | replaces | replaced-with | retracts | retracted-by | signs | similar-to | supports | supported-with | transforms | transformed-into | transformed-with | documents | specification-of | created-with | cite-as
   * - **Definition:** The type of relationship to the related artifact.
   * - **Comment:** The presence of both sides of a relationship type (e.g. successor and predecessor) is required to support use cases where one side of a relationship is not represented in FHIR. However, this feature SHALL NOT be used to create bi-directional resource links in FHIR instances. Specifically, following the methodology of "new points to old" and "many points to one", when using related artifact elements to describe and reference FHIR resources, the type element SHALL be drawn from the fhir-related-artifact-type ValueSet.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link RelatedArtifactTypeEnum }
   */
  private type_: EnumCodeType | null;

  /**
   * RelatedArtifact.classifier Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Additional classifiers
   * - **Definition:** Provides additional classifiers of the related artifact.
   * - **FHIR Type:** `CodeableConcept`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private classifier?: CodeableConcept[] | undefined;

  /**
   * RelatedArtifact.label Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Short label
   * - **Definition:** A short label that can be used to reference the citation from elsewhere in the containing artifact, such as a footnote index.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private label?: StringType | undefined;

  /**
   * RelatedArtifact.display Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Brief description of the related artifact
   * - **Definition:** A brief description of the document or knowledge resource being referenced, suitable for display to a consumer.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private display?: StringType | undefined;

  /**
   * RelatedArtifact.citation Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Bibliographic citation for the artifact
   * - **Definition:** A bibliographic citation for the related artifact. This text SHOULD be formatted according to an accepted citation format.
   * - **Comment:** Additional structured information about citations should be captured as extensions.
   * - **FHIR Type:** `markdown`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private citation?: MarkdownType | undefined;

  /**
   * RelatedArtifact.document Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** What document is being referenced
   * - **Definition:** The document being referenced, represented as an attachment. This is exclusive with the resource element.
   * - **FHIR Type:** `Attachment`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private document?: Attachment | undefined;

  /**
   * RelatedArtifact.resource Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** What artifact is being referenced
   * - **Definition:** The related artifact, such as a library, value set, profile, or other knowledge resource.
   * - **Comment:** If the type is predecessor, this is a reference to the succeeding knowledge resource. If the type is successor, this is a reference to the prior knowledge resource.
   * - **FHIR Type:** `canonical`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Resource',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private resource?: CanonicalType | undefined;

  /**
   * RelatedArtifact.resourceReference Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** What artifact, if not a conformance resource
   * - **Definition:** The related artifact, if the artifact is not a canonical resource, or a resource reference to a canonical resource.
   * - **Comment:** If both resource and resourceReference are present, they SHOULD be consistent and reference the same resource. Although relatedArtifact is intended to support references to definitional resources, there are cases where non-definitional resources can be definitional (such as Location where the kind is mode). Related artifacts SHOULD be used to reference definitional resources, and profiles SHOULD be used to make that explicit for particular use cases.
   * - **FHIR Type:** `Reference`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Resource',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private resourceReference?: Reference | undefined;

  /**
   * FHIR CodeSystem: PublicationStatus
   *
   * @see {@link PublicationStatusEnum }
   */
  private readonly publicationStatusEnum: PublicationStatusEnum;

  /**
   * RelatedArtifact.publicationStatus Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** draft | active | retired | unknown
   * - **Definition:** The publication status of the artifact being referred to.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link PublicationStatusEnum }
   */
  private publicationStatus?: EnumCodeType | undefined;

  /**
   * RelatedArtifact.publicationDate Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Date of publication of the artifact being referred to
   * - **Definition:** The date of publication of the artifact being referred to.
   * - **FHIR Type:** `date`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private publicationDate?: DateType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `type_` property value as a EnumCodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link RelatedArtifactTypeEnum }
   */
  public getTypeEnumType(): EnumCodeType | null {
    return this.type_;
  }

  /**
   * Assigns the provided EnumCodeType value to the `type_` property.
   *
   * @param enumType - the `type_` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link RelatedArtifactTypeEnum }
   */
  public setTypeEnumType(enumType: EnumCodeType): this {
    assertIsDefined<EnumCodeType>(enumType, `RelatedArtifact.type is required`);
    const errMsgPrefix = `Invalid RelatedArtifact.type`;
    assertEnumCodeType<RelatedArtifactTypeEnum>(enumType, RelatedArtifactTypeEnum, errMsgPrefix);
    this.type_ = enumType;
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasTypeEnumType(): boolean {
    return isDefined<EnumCodeType>(this.type_) && !this.type_.isEmpty() && this.type_.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the `type_` property value as a CodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link RelatedArtifactTypeEnum }
   */
  public getTypeElement(): CodeType | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_ as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the `type_` property.
   *
   * @param element - the `type_` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link RelatedArtifactTypeEnum }
   */
  public setTypeElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, `RelatedArtifact.type is required`);
    const optErrMsg = `Invalid RelatedArtifact.type; Provided value is not an instance of CodeType.`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.type_ = new EnumCodeType(element, this.relatedArtifactTypeEnum);
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasTypeElement(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the `type_` property value as a fhirCode if defined; else null
   *
   * @see CodeSystem Enumeration: {@link RelatedArtifactTypeEnum }
   */
  public getType(): fhirCode | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the `type_` property.
   *
   * @param value - the `type_` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link RelatedArtifactTypeEnum }
   */
  public setType(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, `RelatedArtifact.type is required`);
    const optErrMsg = `Invalid RelatedArtifact.type (${String(value)})`;
    this.type_ = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.relatedArtifactTypeEnum);
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasType(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the `classifier` property value as a CodeableConcept array
   */
  public getClassifier(): CodeableConcept[] {
    return this.classifier ?? ([] as CodeableConcept[]);
  }

  /**
   * Assigns the provided CodeableConcept array value to the `classifier` property.
   *
   * @param value - the `classifier` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setClassifier(value: CodeableConcept[] | undefined): this {
    if (isDefinedList<CodeableConcept>(value)) {
      const optErrMsg = `Invalid RelatedArtifact.classifier; Provided value array has an element that is not an instance of CodeableConcept.`;
      assertFhirTypeList<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.classifier = value;
    } else {
      this.classifier = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeableConcept value to the `classifier` array property.
   *
   * @param value - the `classifier` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addClassifier(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = `Invalid RelatedArtifact.classifier; Provided element is not an instance of CodeableConcept.`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.initClassifier();
      this.classifier?.push(value);
    }
    return this;
  }

  /**
   * @returns `true` if the `classifier` property exists and has a value; `false` otherwise
   */
  public hasClassifier(): boolean {
    return isDefinedList<CodeableConcept>(this.classifier) && this.classifier.some((item: CodeableConcept) => !item.isEmpty());
  }

  /**
   * Initialize the `classifier` property
   */
  private initClassifier(): void {
    if(!this.hasClassifier()) {
      this.classifier = [] as CodeableConcept[];
    }
  }

  /**
   * @returns the `label` property value as a StringType object if defined; else an empty StringType object
   */
  public getLabelElement(): StringType {
    return this.label ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `label` property.
   *
   * @param element - the `label` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLabelElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid RelatedArtifact.label; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.label = element;
    } else {
      this.label = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `label` property exists and has a value; `false` otherwise
   */
  public hasLabelElement(): boolean {
    return isDefined<StringType>(this.label) && !this.label.isEmpty();
  }

  /**
   * @returns the `label` property value as a fhirString if defined; else undefined
   */
  public getLabel(): fhirString | undefined {
    return this.label?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `label` property.
   *
   * @param value - the `label` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLabel(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid RelatedArtifact.label (${String(value)})`;
      this.label = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.label = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `label` property exists and has a value; `false` otherwise
   */
  public hasLabel(): boolean {
    return this.hasLabelElement();
  }

  /**
   * @returns the `display` property value as a StringType object if defined; else an empty StringType object
   */
  public getDisplayElement(): StringType {
    return this.display ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `display` property.
   *
   * @param element - the `display` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDisplayElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid RelatedArtifact.display; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.display = element;
    } else {
      this.display = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `display` property exists and has a value; `false` otherwise
   */
  public hasDisplayElement(): boolean {
    return isDefined<StringType>(this.display) && !this.display.isEmpty();
  }

  /**
   * @returns the `display` property value as a fhirString if defined; else undefined
   */
  public getDisplay(): fhirString | undefined {
    return this.display?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `display` property.
   *
   * @param value - the `display` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDisplay(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid RelatedArtifact.display (${String(value)})`;
      this.display = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.display = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `display` property exists and has a value; `false` otherwise
   */
  public hasDisplay(): boolean {
    return this.hasDisplayElement();
  }

  /**
   * @returns the `citation` property value as a MarkdownType object if defined; else an empty MarkdownType object
   */
  public getCitationElement(): MarkdownType {
    return this.citation ?? new MarkdownType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `citation` property.
   *
   * @param element - the `citation` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCitationElement(element: MarkdownType | undefined): this {
    if (isDefined<MarkdownType>(element)) {
      const optErrMsg = `Invalid RelatedArtifact.citation; Provided element is not an instance of MarkdownType.`;
      assertFhirType<MarkdownType>(element, MarkdownType, optErrMsg);
      this.citation = element;
    } else {
      this.citation = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `citation` property exists and has a value; `false` otherwise
   */
  public hasCitationElement(): boolean {
    return isDefined<MarkdownType>(this.citation) && !this.citation.isEmpty();
  }

  /**
   * @returns the `citation` property value as a fhirMarkdown if defined; else undefined
   */
  public getCitation(): fhirMarkdown | undefined {
    return this.citation?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `citation` property.
   *
   * @param value - the `citation` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCitation(value: fhirMarkdown | undefined): this {
    if (isDefined<fhirMarkdown>(value)) {
      const optErrMsg = `Invalid RelatedArtifact.citation (${String(value)})`;
      this.citation = new MarkdownType(parseFhirPrimitiveData(value, fhirMarkdownSchema, optErrMsg));
    } else {
      this.citation = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `citation` property exists and has a value; `false` otherwise
   */
  public hasCitation(): boolean {
    return this.hasCitationElement();
  }

  /**
   * @returns the `document` property value as a Attachment object if defined; else an empty Attachment object
   */
  public getDocument(): Attachment {
    return this.document ?? new Attachment();
  }

  /**
   * Assigns the provided Document object value to the `document` property.
   *
   * @param value - the `document` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setDocument(value: Attachment | undefined): this {
    if (isDefined<Attachment>(value)) {
      const optErrMsg = `Invalid RelatedArtifact.document; Provided element is not an instance of Attachment.`;
      assertFhirType<Attachment>(value, Attachment, optErrMsg);
      this.document = value;
    } else {
      this.document = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `document` property exists and has a value; `false` otherwise
   */
  public hasDocument(): boolean {
    return isDefined<Attachment>(this.document) && !this.document.isEmpty();
  }

  /**
   * @returns the `resource` property value as a CanonicalType object if defined; else an empty CanonicalType object
   */
  public getResourceElement(): CanonicalType {
    return this.resource ?? new CanonicalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `resource` property.
   *
   * @param element - the `resource` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setResourceElement(element: CanonicalType | undefined): this {
    if (isDefined<CanonicalType>(element)) {
      const optErrMsg = `Invalid RelatedArtifact.resource; Provided element is not an instance of CanonicalType.`;
      assertFhirType<CanonicalType>(element, CanonicalType, optErrMsg);
      this.resource = element;
    } else {
      this.resource = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `resource` property exists and has a value; `false` otherwise
   */
  public hasResourceElement(): boolean {
    return isDefined<CanonicalType>(this.resource) && !this.resource.isEmpty();
  }

  /**
   * @returns the `resource` property value as a fhirCanonical if defined; else undefined
   */
  public getResource(): fhirCanonical | undefined {
    return this.resource?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `resource` property.
   *
   * @param value - the `resource` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setResource(value: fhirCanonical | undefined): this {
    if (isDefined<fhirCanonical>(value)) {
      const optErrMsg = `Invalid RelatedArtifact.resource (${String(value)})`;
      this.resource = new CanonicalType(parseFhirPrimitiveData(value, fhirCanonicalSchema, optErrMsg));
    } else {
      this.resource = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `resource` property exists and has a value; `false` otherwise
   */
  public hasResource(): boolean {
    return this.hasResourceElement();
  }

  /**
   * @returns the `resourceReference` property value as a Reference object; else an empty Reference object
   */
  public getResourceReference(): Reference {
    return this.resourceReference ?? new Reference();
  }

  /**
   * Assigns the provided ResourceReference object value to the `resourceReference` property.
   *
   * @decorator `@ReferenceTargets('RelatedArtifact.resourceReference', ['Resource',])`
   *
   * @param value - the `resourceReference` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('RelatedArtifact.resourceReference', [
    'Resource',
  ])
  public setResourceReference(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.resourceReference = value;
    } else {
      this.resourceReference = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `resourceReference` property exists and has a value; `false` otherwise
   */
  public hasResourceReference(): boolean {
    return isDefined<Reference>(this.resourceReference) && !this.resourceReference.isEmpty();
  }

  /**
   * @returns the `publicationStatus` property value as a EnumCodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link PublicationStatusEnum }
   */
  public getPublicationStatusEnumType(): EnumCodeType | undefined {
    return this.publicationStatus;
  }

  /**
   * Assigns the provided EnumCodeType value to the `publicationStatus` property.
   *
   * @param enumType - the `publicationStatus` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code values
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link PublicationStatusEnum }
   */
  public setPublicationStatusEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid RelatedArtifact.publicationStatus';
      assertEnumCodeType<PublicationStatusEnum>(enumType, PublicationStatusEnum, errMsgPrefix);
      this.publicationStatus = enumType;
    } else {
      this.publicationStatus = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `publicationStatus` property exists and has a value; `false` otherwise
   */
  public hasPublicationStatusEnumType(): boolean {
    return isDefined<EnumCodeType>(this.publicationStatus) && !this.publicationStatus.isEmpty() && this.publicationStatus.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the `publicationStatus` property value as a CodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link PublicationStatusEnum }
   */
  public getPublicationStatusElement(): CodeType | undefined {
    if (this.publicationStatus === undefined) {
      return undefined;
    }
    return this.publicationStatus as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the `publicationStatus` property.
   *
   * @param element - the `publicationStatus` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link PublicationStatusEnum }
   */
  public setPublicationStatusElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid RelatedArtifact.publicationStatus; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.publicationStatus = new EnumCodeType(element, this.publicationStatusEnum);
    } else {
      this.publicationStatus = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `publicationStatus` property exists and has a value; `false` otherwise
   */
  public hasPublicationStatusElement(): boolean {
    return this.hasPublicationStatusEnumType();
  }

  /**
   * @returns the `publicationStatus` property value as a fhirCode if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link PublicationStatusEnum }
   */
  public getPublicationStatus(): fhirCode | undefined {
    if (this.publicationStatus === undefined) {
      return undefined;
    }
    return this.publicationStatus.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the `publicationStatus` property.
   *
   * @param value - the `publicationStatus` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link PublicationStatusEnum }
   */
  public setPublicationStatus(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid RelatedArtifact.publicationStatus; Provided value is not an instance of fhirCode.`;
      this.publicationStatus = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.publicationStatusEnum);
    } else {
      this.publicationStatus = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `publicationStatus` property exists and has a value; `false` otherwise
   */
  public hasPublicationStatus(): boolean {
    return this.hasPublicationStatusEnumType();
  }

  /**
   * @returns the `publicationDate` property value as a DateType object if defined; else an empty DateType object
   */
  public getPublicationDateElement(): DateType {
    return this.publicationDate ?? new DateType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `publicationDate` property.
   *
   * @param element - the `publicationDate` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPublicationDateElement(element: DateType | undefined): this {
    if (isDefined<DateType>(element)) {
      const optErrMsg = `Invalid RelatedArtifact.publicationDate; Provided element is not an instance of DateType.`;
      assertFhirType<DateType>(element, DateType, optErrMsg);
      this.publicationDate = element;
    } else {
      this.publicationDate = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `publicationDate` property exists and has a value; `false` otherwise
   */
  public hasPublicationDateElement(): boolean {
    return isDefined<DateType>(this.publicationDate) && !this.publicationDate.isEmpty();
  }

  /**
   * @returns the `publicationDate` property value as a fhirDate if defined; else undefined
   */
  public getPublicationDate(): fhirDate | undefined {
    return this.publicationDate?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `publicationDate` property.
   *
   * @param value - the `publicationDate` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPublicationDate(value: fhirDate | undefined): this {
    if (isDefined<fhirDate>(value)) {
      const optErrMsg = `Invalid RelatedArtifact.publicationDate (${String(value)})`;
      this.publicationDate = new DateType(parseFhirPrimitiveData(value, fhirDateSchema, optErrMsg));
    } else {
      this.publicationDate = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `publicationDate` property exists and has a value; `false` otherwise
   */
  public hasPublicationDate(): boolean {
    return this.hasPublicationDateElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'RelatedArtifact';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.type_,
      this.classifier,
      this.label,
      this.display,
      this.citation,
      this.document,
      this.resource,
      this.resourceReference,
      this.publicationStatus,
      this.publicationDate,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): RelatedArtifact {
    const dest = new RelatedArtifact();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: RelatedArtifact): void {
    super.copyValues(dest);
    dest.type_ = this.type_ ? this.type_.copy() : null;
    const classifierList = copyListValues<CodeableConcept>(this.classifier);
    dest.classifier = classifierList.length === 0 ? undefined : classifierList;
    dest.label = this.label?.copy();
    dest.display = this.display?.copy();
    dest.citation = this.citation?.copy();
    dest.document = this.document?.copy();
    dest.resource = this.resource?.copy();
    dest.resourceReference = this.resourceReference?.copy();
    dest.publicationStatus = this.publicationStatus?.copy();
    dest.publicationDate = this.publicationDate?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasTypeElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getTypeElement()!, 'type', jsonObj);
    } else {
      missingReqdProperties.push(`RelatedArtifact.type`);
    }

    if (this.hasClassifier()) {
      setFhirComplexListJson(this.getClassifier(), 'classifier', jsonObj);
    }

    if (this.hasLabelElement()) {
      setFhirPrimitiveJson<fhirString>(this.getLabelElement(), 'label', jsonObj);
    }

    if (this.hasDisplayElement()) {
      setFhirPrimitiveJson<fhirString>(this.getDisplayElement(), 'display', jsonObj);
    }

    if (this.hasCitationElement()) {
      setFhirPrimitiveJson<fhirMarkdown>(this.getCitationElement(), 'citation', jsonObj);
    }

    if (this.hasDocument()) {
      setFhirComplexJson(this.getDocument(), 'document', jsonObj);
    }

    if (this.hasResourceElement()) {
      setFhirPrimitiveJson<fhirCanonical>(this.getResourceElement(), 'resource', jsonObj);
    }

    if (this.hasResourceReference()) {
      setFhirComplexJson(this.getResourceReference(), 'resourceReference', jsonObj);
    }

    if (this.hasPublicationStatusElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getPublicationStatusElement()!, 'publicationStatus', jsonObj);
    }

    if (this.hasPublicationDateElement()) {
      setFhirPrimitiveJson<fhirDate>(this.getPublicationDateElement(), 'publicationDate', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_DO_NOT_EXIST} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

/**
 * SampledData Class
 *
 * @remarks
 * SampledData Type: A series of measurements taken by a device, with upper and lower limits. There may be more than one dimension in the data.
 *
 * There is a need for a concise way to handle the data produced by devices that sample a physical state at a high frequency.
 *
 * **FHIR Specification**
 * - **Short:** A series of measurements taken by a device
 * - **Definition:** A series of measurements taken by a device, with upper and lower limits. There may be more than one dimension in the data.
 * - **Comment:** The data is not interpretable without at least origin, period, and dimensions, but these are optional to allow a separation between the template of measurement and the actual measurement, such as between DeviceCapabilities and DeviceLog.  When providing a summary view (for example with Observation.value[x]) SampledData should be represented with a brief display text such as "Sampled Data".
 * - **FHIR Version:** 5.0.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR SampledData](http://hl7.org/fhir/StructureDefinition/SampledData)
 */
export class SampledData extends DataType implements IDataType {
  constructor(origin: Quantity | null = null, intervalUnit: CodeType | fhirCode | null = null, dimensions: PositiveIntType | fhirPositiveInt | null = null) {
    super();

    this.origin = null;
    if (isDefined<Quantity>(origin)) {
      this.setOrigin(origin);
    }

    this.intervalUnit = null;
    if (isDefined<CodeType | fhirCode>(intervalUnit)) {
      if (intervalUnit instanceof PrimitiveType) {
        this.setIntervalUnitElement(intervalUnit);
      } else {
        this.setIntervalUnit(intervalUnit);
      }
    }

    this.dimensions = null;
    if (isDefined<PositiveIntType | fhirPositiveInt>(dimensions)) {
      if (dimensions instanceof PrimitiveType) {
        this.setDimensionsElement(dimensions);
      } else {
        this.setDimensions(dimensions);
      }
    }
  }

  /**
   * Parse the provided `SampledData` JSON to instantiate the SampledData data model.
   *
   * @param sourceJson - JSON representing FHIR `SampledData`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to SampledData
   * @returns SampledData data model or undefined for `SampledData`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): SampledData | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'SampledData';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new SampledData();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'origin';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = Quantity.parse(classJsonObj[fieldName]!, sourceField);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setOrigin(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'interval';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setIntervalElement(datatype);
    }

    fieldName = 'intervalUnit';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setIntervalUnitElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'factor';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setFactorElement(datatype);
    }

    fieldName = 'lowerLimit';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setLowerLimitElement(datatype);
    }

    fieldName = 'upperLimit';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setUpperLimitElement(datatype);
    }

    fieldName = 'dimensions';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = fhirParser.parsePositiveIntType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setDimensionsElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'codeMap';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CanonicalType | undefined = fhirParser.parseCanonicalType(dtJson, dtSiblingJson);
      instance.setCodeMapElement(datatype);
    }

    fieldName = 'offsets';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setOffsetsElement(datatype);
    }

    fieldName = 'data';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setDataElement(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_REQD_IN_JSON} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * SampledData.origin Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Zero value and units
   * - **Definition:** The base quantity that a measured value of zero represents. In addition, this provides the units of the entire measurement series.
   * - **FHIR Type:** `Quantity`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private origin: Quantity | null;

  /**
   * SampledData.interval Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Number of intervalUnits between samples
   * - **Definition:** Amount of intervalUnits between samples, e.g. milliseconds for time-based sampling.
   * - **Comment:** This is usually a whole number.
   * - **FHIR Type:** `decimal`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private interval?: DecimalType | undefined;

  /**
   * SampledData.intervalUnit Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The measurement unit of the interval between samples
   * - **Definition:** The measurement unit in which the sample interval is expressed.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private intervalUnit: CodeType | null;

  /**
   * SampledData.factor Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Multiply data by this before adding to origin
   * - **Definition:** A correction factor that is applied to the sampled data points before they are added to the origin.
   * - **FHIR Type:** `decimal`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private factor?: DecimalType | undefined;

  /**
   * SampledData.lowerLimit Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Lower limit of detection
   * - **Definition:** The lower limit of detection of the measured points. This is needed if any of the data points have the value "L" (lower than detection limit).
   * - **FHIR Type:** `decimal`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private lowerLimit?: DecimalType | undefined;

  /**
   * SampledData.upperLimit Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Upper limit of detection
   * - **Definition:** The upper limit of detection of the measured points. This is needed if any of the data points have the value "U" (higher than detection limit).
   * - **FHIR Type:** `decimal`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private upperLimit?: DecimalType | undefined;

  /**
   * SampledData.dimensions Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Number of sample points at each time point
   * - **Definition:** The number of sample points at each time point. If this value is greater than one, then the dimensions will be interlaced - all the sample points for a point in time will be recorded at once.
   * - **Comment:** If there is more than one dimension, the code for the type of data will define the meaning of the dimensions (typically ECG data).
   * - **FHIR Type:** `positiveInt`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private dimensions: PositiveIntType | null;

  /**
   * SampledData.codeMap Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Defines the codes used in the data
   * - **Definition:** Reference to ConceptMap that defines the codes used in the data.
   * - **Comment:** The ConceptMap cannot define meanings for the codes \'E\', \'U\', or \'L\' (nor \'e\', \'u\', or \'l\').
   * - **FHIR Type:** `canonical`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/ConceptMap',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private codeMap?: CanonicalType | undefined;

  /**
   * SampledData.offsets Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Offsets, typically in time, at which data values were taken
   * - **Definition:** A series of data points which are decimal values separated by a single space (character u20).  The units in which the offsets are expressed are found in intervalUnit.  The absolute point at which the measurements begin SHALL be conveyed outside the scope of this datatype, e.g. Observation.effectiveDateTime for a timing offset.
   * - **Comment:** If offsets is present, the number of data points must be equal to the number of offsets mlutipled by the dimensions.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private offsets?: StringType | undefined;

  /**
   * SampledData.data Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Decimal values with spaces, or "E" | "U" | "L", or another code
   * - **Definition:** A series of data points which are decimal values or codes separated by a single space (character u20). The special codes "E" (error), "L" (below detection limit) and "U" (above detection limit) are also defined for used in place of decimal values.
   * - **Comment:** The data may be missing if it is omitted for summarization purposes. In general, data is required for any actual use of a SampledData.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private data?: StringType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `origin` property value as a Quantity object if defined; else null
   */
  public getOrigin(): Quantity | null {
    return this.origin;
  }

  /**
   * Assigns the provided Quantity object value to the `origin` property.
   *
   * @param value - the `origin` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setOrigin(value: Quantity): this {
    assertIsDefined<Quantity>(value, `SampledData.origin is required`);
    const optErrMsg = `Invalid SampledData.origin; Provided element is not an instance of Quantity.`;
    assertFhirType<Quantity>(value, Quantity, optErrMsg);
    this.origin = value;
    return this;
  }

  /**
   * @returns `true` if the `origin` property exists and has a value; `false` otherwise
   */
  public hasOrigin(): boolean {
    return isDefined<Quantity>(this.origin) && !this.origin.isEmpty();
  }

  /**
   * @returns the `interval` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getIntervalElement(): DecimalType {
    return this.interval ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `interval` property.
   *
   * @param element - the `interval` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setIntervalElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = `Invalid SampledData.interval; Provided element is not an instance of DecimalType.`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.interval = element;
    } else {
      this.interval = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `interval` property exists and has a value; `false` otherwise
   */
  public hasIntervalElement(): boolean {
    return isDefined<DecimalType>(this.interval) && !this.interval.isEmpty();
  }

  /**
   * @returns the `interval` property value as a fhirDecimal if defined; else undefined
   */
  public getInterval(): fhirDecimal | undefined {
    return this.interval?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `interval` property.
   *
   * @param value - the `interval` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setInterval(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = `Invalid SampledData.interval (${String(value)})`;
      this.interval = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.interval = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `interval` property exists and has a value; `false` otherwise
   */
  public hasInterval(): boolean {
    return this.hasIntervalElement();
  }

  /**
   * @returns the `intervalUnit` property value as a CodeType object if defined; else null
   */
  public getIntervalUnitElement(): CodeType | null {
    return this.intervalUnit;
  }

  /**
   * Assigns the provided PrimitiveType value to the `intervalUnit` property.
   *
   * @param element - the `intervalUnit` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setIntervalUnitElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, `SampledData.intervalUnit is required`);
    const optErrMsg = `Invalid SampledData.intervalUnit; Provided value is not an instance of CodeType.`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.intervalUnit = element;
    return this;
  }

  /**
   * @returns `true` if the `intervalUnit` property exists and has a value; `false` otherwise
   */
  public hasIntervalUnitElement(): boolean {
    return isDefined<CodeType>(this.intervalUnit) && !this.intervalUnit.isEmpty();
  }

  /**
   * @returns the `intervalUnit` property value as a fhirCode if defined; else null
   */
  public getIntervalUnit(): fhirCode | null {
    if (this.intervalUnit?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.intervalUnit.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the `intervalUnit` property.
   *
   * @param value - the `intervalUnit` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setIntervalUnit(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, `SampledData.intervalUnit is required`);
    const optErrMsg = `Invalid SampledData.intervalUnit (${String(value)})`;
    this.intervalUnit = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    return this;
  }

  /**
   * @returns `true` if the `intervalUnit` property exists and has a value; `false` otherwise
   */
  public hasIntervalUnit(): boolean {
    return this.hasIntervalUnitElement();
  }

  /**
   * @returns the `factor` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getFactorElement(): DecimalType {
    return this.factor ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `factor` property.
   *
   * @param element - the `factor` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setFactorElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = `Invalid SampledData.factor; Provided element is not an instance of DecimalType.`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.factor = element;
    } else {
      this.factor = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `factor` property exists and has a value; `false` otherwise
   */
  public hasFactorElement(): boolean {
    return isDefined<DecimalType>(this.factor) && !this.factor.isEmpty();
  }

  /**
   * @returns the `factor` property value as a fhirDecimal if defined; else undefined
   */
  public getFactor(): fhirDecimal | undefined {
    return this.factor?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `factor` property.
   *
   * @param value - the `factor` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setFactor(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = `Invalid SampledData.factor (${String(value)})`;
      this.factor = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.factor = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `factor` property exists and has a value; `false` otherwise
   */
  public hasFactor(): boolean {
    return this.hasFactorElement();
  }

  /**
   * @returns the `lowerLimit` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getLowerLimitElement(): DecimalType {
    return this.lowerLimit ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `lowerLimit` property.
   *
   * @param element - the `lowerLimit` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLowerLimitElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = `Invalid SampledData.lowerLimit; Provided element is not an instance of DecimalType.`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.lowerLimit = element;
    } else {
      this.lowerLimit = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `lowerLimit` property exists and has a value; `false` otherwise
   */
  public hasLowerLimitElement(): boolean {
    return isDefined<DecimalType>(this.lowerLimit) && !this.lowerLimit.isEmpty();
  }

  /**
   * @returns the `lowerLimit` property value as a fhirDecimal if defined; else undefined
   */
  public getLowerLimit(): fhirDecimal | undefined {
    return this.lowerLimit?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `lowerLimit` property.
   *
   * @param value - the `lowerLimit` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLowerLimit(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = `Invalid SampledData.lowerLimit (${String(value)})`;
      this.lowerLimit = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.lowerLimit = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `lowerLimit` property exists and has a value; `false` otherwise
   */
  public hasLowerLimit(): boolean {
    return this.hasLowerLimitElement();
  }

  /**
   * @returns the `upperLimit` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getUpperLimitElement(): DecimalType {
    return this.upperLimit ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `upperLimit` property.
   *
   * @param element - the `upperLimit` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUpperLimitElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = `Invalid SampledData.upperLimit; Provided element is not an instance of DecimalType.`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.upperLimit = element;
    } else {
      this.upperLimit = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `upperLimit` property exists and has a value; `false` otherwise
   */
  public hasUpperLimitElement(): boolean {
    return isDefined<DecimalType>(this.upperLimit) && !this.upperLimit.isEmpty();
  }

  /**
   * @returns the `upperLimit` property value as a fhirDecimal if defined; else undefined
   */
  public getUpperLimit(): fhirDecimal | undefined {
    return this.upperLimit?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `upperLimit` property.
   *
   * @param value - the `upperLimit` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUpperLimit(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = `Invalid SampledData.upperLimit (${String(value)})`;
      this.upperLimit = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.upperLimit = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `upperLimit` property exists and has a value; `false` otherwise
   */
  public hasUpperLimit(): boolean {
    return this.hasUpperLimitElement();
  }

  /**
   * @returns the `dimensions` property value as a PositiveIntType object if defined; else null
   */
  public getDimensionsElement(): PositiveIntType | null {
    return this.dimensions;
  }

  /**
   * Assigns the provided PrimitiveType value to the `dimensions` property.
   *
   * @param element - the `dimensions` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDimensionsElement(element: PositiveIntType): this {
    assertIsDefined<PositiveIntType>(element, `SampledData.dimensions is required`);
    const optErrMsg = `Invalid SampledData.dimensions; Provided value is not an instance of PositiveIntType.`;
    assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
    this.dimensions = element;
    return this;
  }

  /**
   * @returns `true` if the `dimensions` property exists and has a value; `false` otherwise
   */
  public hasDimensionsElement(): boolean {
    return isDefined<PositiveIntType>(this.dimensions) && !this.dimensions.isEmpty();
  }

  /**
   * @returns the `dimensions` property value as a fhirPositiveInt if defined; else null
   */
  public getDimensions(): fhirPositiveInt | null {
    if (this.dimensions?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.dimensions.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the `dimensions` property.
   *
   * @param value - the `dimensions` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDimensions(value: fhirPositiveInt): this {
    assertIsDefined<fhirPositiveInt>(value, `SampledData.dimensions is required`);
    const optErrMsg = `Invalid SampledData.dimensions (${String(value)})`;
    this.dimensions = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    return this;
  }

  /**
   * @returns `true` if the `dimensions` property exists and has a value; `false` otherwise
   */
  public hasDimensions(): boolean {
    return this.hasDimensionsElement();
  }

  /**
   * @returns the `codeMap` property value as a CanonicalType object if defined; else an empty CanonicalType object
   */
  public getCodeMapElement(): CanonicalType {
    return this.codeMap ?? new CanonicalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `codeMap` property.
   *
   * @param element - the `codeMap` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCodeMapElement(element: CanonicalType | undefined): this {
    if (isDefined<CanonicalType>(element)) {
      const optErrMsg = `Invalid SampledData.codeMap; Provided element is not an instance of CanonicalType.`;
      assertFhirType<CanonicalType>(element, CanonicalType, optErrMsg);
      this.codeMap = element;
    } else {
      this.codeMap = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `codeMap` property exists and has a value; `false` otherwise
   */
  public hasCodeMapElement(): boolean {
    return isDefined<CanonicalType>(this.codeMap) && !this.codeMap.isEmpty();
  }

  /**
   * @returns the `codeMap` property value as a fhirCanonical if defined; else undefined
   */
  public getCodeMap(): fhirCanonical | undefined {
    return this.codeMap?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `codeMap` property.
   *
   * @param value - the `codeMap` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCodeMap(value: fhirCanonical | undefined): this {
    if (isDefined<fhirCanonical>(value)) {
      const optErrMsg = `Invalid SampledData.codeMap (${String(value)})`;
      this.codeMap = new CanonicalType(parseFhirPrimitiveData(value, fhirCanonicalSchema, optErrMsg));
    } else {
      this.codeMap = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `codeMap` property exists and has a value; `false` otherwise
   */
  public hasCodeMap(): boolean {
    return this.hasCodeMapElement();
  }

  /**
   * @returns the `offsets` property value as a StringType object if defined; else an empty StringType object
   */
  public getOffsetsElement(): StringType {
    return this.offsets ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `offsets` property.
   *
   * @param element - the `offsets` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setOffsetsElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid SampledData.offsets; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.offsets = element;
    } else {
      this.offsets = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `offsets` property exists and has a value; `false` otherwise
   */
  public hasOffsetsElement(): boolean {
    return isDefined<StringType>(this.offsets) && !this.offsets.isEmpty();
  }

  /**
   * @returns the `offsets` property value as a fhirString if defined; else undefined
   */
  public getOffsets(): fhirString | undefined {
    return this.offsets?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `offsets` property.
   *
   * @param value - the `offsets` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setOffsets(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid SampledData.offsets (${String(value)})`;
      this.offsets = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.offsets = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `offsets` property exists and has a value; `false` otherwise
   */
  public hasOffsets(): boolean {
    return this.hasOffsetsElement();
  }

  /**
   * @returns the `data` property value as a StringType object if defined; else an empty StringType object
   */
  public getDataElement(): StringType {
    return this.data ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `data` property.
   *
   * @param element - the `data` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDataElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid SampledData.data; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.data = element;
    } else {
      this.data = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `data` property exists and has a value; `false` otherwise
   */
  public hasDataElement(): boolean {
    return isDefined<StringType>(this.data) && !this.data.isEmpty();
  }

  /**
   * @returns the `data` property value as a fhirString if defined; else undefined
   */
  public getData(): fhirString | undefined {
    return this.data?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `data` property.
   *
   * @param value - the `data` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setData(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid SampledData.data (${String(value)})`;
      this.data = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.data = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `data` property exists and has a value; `false` otherwise
   */
  public hasData(): boolean {
    return this.hasDataElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'SampledData';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.origin,
      this.interval,
      this.intervalUnit,
      this.factor,
      this.lowerLimit,
      this.upperLimit,
      this.dimensions,
      this.codeMap,
      this.offsets,
      this.data,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): SampledData {
    const dest = new SampledData();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: SampledData): void {
    super.copyValues(dest);
    dest.origin = this.origin ? this.origin.copy() : null;
    dest.interval = this.interval?.copy();
    dest.intervalUnit = this.intervalUnit ? this.intervalUnit.copy() : null;
    dest.factor = this.factor?.copy();
    dest.lowerLimit = this.lowerLimit?.copy();
    dest.upperLimit = this.upperLimit?.copy();
    dest.dimensions = this.dimensions ? this.dimensions.copy() : null;
    dest.codeMap = this.codeMap?.copy();
    dest.offsets = this.offsets?.copy();
    dest.data = this.data?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasOrigin()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirComplexJson(this.getOrigin()!, 'origin', jsonObj);
    } else {
      missingReqdProperties.push(`SampledData.origin`);
    }

    if (this.hasIntervalElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getIntervalElement(), 'interval', jsonObj);
    }

    if (this.hasIntervalUnitElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getIntervalUnitElement()!, 'intervalUnit', jsonObj);
    } else {
      missingReqdProperties.push(`SampledData.intervalUnit`);
    }

    if (this.hasFactorElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getFactorElement(), 'factor', jsonObj);
    }

    if (this.hasLowerLimitElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getLowerLimitElement(), 'lowerLimit', jsonObj);
    }

    if (this.hasUpperLimitElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getUpperLimitElement(), 'upperLimit', jsonObj);
    }

    if (this.hasDimensionsElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirPositiveInt>(this.getDimensionsElement()!, 'dimensions', jsonObj);
    } else {
      missingReqdProperties.push(`SampledData.dimensions`);
    }

    if (this.hasCodeMapElement()) {
      setFhirPrimitiveJson<fhirCanonical>(this.getCodeMapElement(), 'codeMap', jsonObj);
    }

    if (this.hasOffsetsElement()) {
      setFhirPrimitiveJson<fhirString>(this.getOffsetsElement(), 'offsets', jsonObj);
    }

    if (this.hasDataElement()) {
      setFhirPrimitiveJson<fhirString>(this.getDataElement(), 'data', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_DO_NOT_EXIST} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

/**
 * Signature Class
 *
 * @remarks
 * Signature Type: A signature along with supporting context. The signature may be a digital signature that is cryptographic in nature, or some other signature acceptable to the domain. This other signature may be as simple as a graphical image representing a hand-written signature, or a signature ceremony Different signature approaches have different utilities.
 *
 * There are a number of places where content must be signed in healthcare.
 *
 * **FHIR Specification**
 * - **Short:** A Signature - XML DigSig, JWS, Graphical image of signature, etc.
 * - **Definition:** A signature along with supporting context. The signature may be a digital signature that is cryptographic in nature, or some other signature acceptable to the domain. This other signature may be as simple as a graphical image representing a hand-written signature, or a signature ceremony Different signature approaches have different utilities.
 * - **Comment:** The elements of the Signature Resource are for ease of access of these elements. For digital signatures (Xml DigSig, JWS), the non-repudiation proof comes from the Signature  validation, which includes validation of the referenced objects (e.g. Resources) (a.k.a., Content) in the XML-Signature Detached form.
 * - **FHIR Version:** 5.0.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR Signature](http://hl7.org/fhir/StructureDefinition/Signature)
 */
export class Signature extends DataType implements IDataType {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided `Signature` JSON to instantiate the Signature data model.
   *
   * @param sourceJson - JSON representing FHIR `Signature`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to Signature
   * @returns Signature data model or undefined for `Signature`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Signature | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Signature';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new Signature();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'type';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Coding | undefined = Coding.parse(dataElementJson, `${sourceField}[${String(idx)}]`);
        if (datatype !== undefined) {
          instance.addType(datatype);
        }
      });
    }

    fieldName = 'when';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: InstantType | undefined = fhirParser.parseInstantType(dtJson, dtSiblingJson);
      instance.setWhenElement(datatype);
    }

    fieldName = 'who';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = Reference.parse(classJsonObj[fieldName]!, sourceField);
      instance.setWho(datatype);
    }

    fieldName = 'onBehalfOf';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = Reference.parse(classJsonObj[fieldName]!, sourceField);
      instance.setOnBehalfOf(datatype);
    }

    fieldName = 'targetFormat';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setTargetFormatElement(datatype);
    }

    fieldName = 'sigFormat';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setSigFormatElement(datatype);
    }

    fieldName = 'data';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: Base64BinaryType | undefined = fhirParser.parseBase64BinaryType(dtJson, dtSiblingJson);
      instance.setDataElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Signature.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Indication of the reason the entity signed the object(s)
   * - **Definition:** An indication of the reason that the entity signed this document. This may be explicitly included as part of the signature information and can be used when determining accountability for various actions concerning the document.
   * - **Comment:** Examples include attesting to: authorship, correct transcription, and witness of specific event. Also known as a &quot;Commitment Type Indication&quot;.
   * - **FHIR Type:** `Coding`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private type_?: Coding[] | undefined;

  /**
   * Signature.when Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** When the signature was created
   * - **Definition:** When the digital signature was signed.
   * - **Comment:** This should agree with the information in the signature.
   * - **FHIR Type:** `instant`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private when?: InstantType | undefined;

  /**
   * Signature.who Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Who signed
   * - **Definition:** A reference to an application-usable description of the identity that signed  (e.g. the signature used their private key).
   * - **Comment:** This should agree with the information in the signature.
   * - **FHIR Type:** `Reference`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Practitioner',
   *       'http://hl7.org/fhir/StructureDefinition/PractitionerRole',
   *       'http://hl7.org/fhir/StructureDefinition/RelatedPerson',
   *       'http://hl7.org/fhir/StructureDefinition/Patient',
   *       'http://hl7.org/fhir/StructureDefinition/Device',
   *       'http://hl7.org/fhir/StructureDefinition/Organization',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private who?: Reference | undefined;

  /**
   * Signature.onBehalfOf Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The party represented
   * - **Definition:** A reference to an application-usable description of the identity that is represented by the signature.
   * - **Comment:** The party that can\'t sign. For example a child.
   * - **Requirements:** used when the signature is on behalf of a non-signer.
   * - **FHIR Type:** `Reference`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Practitioner',
   *       'http://hl7.org/fhir/StructureDefinition/PractitionerRole',
   *       'http://hl7.org/fhir/StructureDefinition/RelatedPerson',
   *       'http://hl7.org/fhir/StructureDefinition/Patient',
   *       'http://hl7.org/fhir/StructureDefinition/Device',
   *       'http://hl7.org/fhir/StructureDefinition/Organization',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private onBehalfOf?: Reference | undefined;

  /**
   * Signature.targetFormat Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The technical format of the signed resources
   * - **Definition:** A mime type that indicates the technical format of the target resources signed by the signature.
   * - **Comment:** "xml", "json" and "ttl" are allowed, which describe the simple encodings described in the specification (and imply appropriate bundle support). Otherwise, mime types are legal here.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private targetFormat?: CodeType | undefined;

  /**
   * Signature.sigFormat Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The technical format of the signature
   * - **Definition:** A mime type that indicates the technical format of the signature. Important mime types are application/signature+xml for X ML DigSig, application/jose for JWS, and image/* for a graphical image of a signature, etc.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private sigFormat?: CodeType | undefined;

  /**
   * Signature.data Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The actual signature content (XML DigSig. JWS, picture, etc.)
   * - **Definition:** The base64 encoding of the Signature content. When signature is not recorded electronically this element would be empty.
   * - **Comment:** Where the signature type is an XML DigSig, the signed content is a FHIR Resource(s), the signature is of the XML form of the Resource(s) using  XML-Signature (XMLDIG) "Detached Signature" form.
   * - **FHIR Type:** `base64Binary`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private data?: Base64BinaryType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `type_` property value as a Coding array
   */
  public getType(): Coding[] {
    return this.type_ ?? ([] as Coding[]);
  }

  /**
   * Assigns the provided Coding array value to the `type_` property.
   *
   * @param value - the `type_` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setType(value: Coding[] | undefined): this {
    if (isDefinedList<Coding>(value)) {
      const optErrMsg = `Invalid Signature.type; Provided value array has an element that is not an instance of Coding.`;
      assertFhirTypeList<Coding>(value, Coding, optErrMsg);
      this.type_ = value;
    } else {
      this.type_ = undefined;
    }
    return this;
  }

  /**
   * Add the provided Coding value to the `type_` array property.
   *
   * @param value - the `type_` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addType(value: Coding | undefined): this {
    if (isDefined<Coding>(value)) {
      const optErrMsg = `Invalid Signature.type; Provided element is not an instance of Coding.`;
      assertFhirType<Coding>(value, Coding, optErrMsg);
      this.initType();
      this.type_?.push(value);
    }
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasType(): boolean {
    return isDefinedList<Coding>(this.type_) && this.type_.some((item: Coding) => !item.isEmpty());
  }

  /**
   * Initialize the `type_` property
   */
  private initType(): void {
    if(!this.hasType()) {
      this.type_ = [] as Coding[];
    }
  }

  /**
   * @returns the `when` property value as a InstantType object if defined; else an empty InstantType object
   */
  public getWhenElement(): InstantType {
    return this.when ?? new InstantType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `when` property.
   *
   * @param element - the `when` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setWhenElement(element: InstantType | undefined): this {
    if (isDefined<InstantType>(element)) {
      const optErrMsg = `Invalid Signature.when; Provided element is not an instance of InstantType.`;
      assertFhirType<InstantType>(element, InstantType, optErrMsg);
      this.when = element;
    } else {
      this.when = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `when` property exists and has a value; `false` otherwise
   */
  public hasWhenElement(): boolean {
    return isDefined<InstantType>(this.when) && !this.when.isEmpty();
  }

  /**
   * @returns the `when` property value as a fhirInstant if defined; else undefined
   */
  public getWhen(): fhirInstant | undefined {
    return this.when?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `when` property.
   *
   * @param value - the `when` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setWhen(value: fhirInstant | undefined): this {
    if (isDefined<fhirInstant>(value)) {
      const optErrMsg = `Invalid Signature.when (${String(value)})`;
      this.when = new InstantType(parseFhirPrimitiveData(value, fhirInstantSchema, optErrMsg));
    } else {
      this.when = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `when` property exists and has a value; `false` otherwise
   */
  public hasWhen(): boolean {
    return this.hasWhenElement();
  }

  /**
   * @returns the `who` property value as a Reference object; else an empty Reference object
   */
  public getWho(): Reference {
    return this.who ?? new Reference();
  }

  /**
   * Assigns the provided Who object value to the `who` property.
   *
   * @decorator `@ReferenceTargets('Signature.who', ['Practitioner','PractitionerRole','RelatedPerson','Patient','Device','Organization',])`
   *
   * @param value - the `who` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('Signature.who', [
    'Practitioner',
  
    'PractitionerRole',
  
    'RelatedPerson',
  
    'Patient',
  
    'Device',
  
    'Organization',
  ])
  public setWho(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.who = value;
    } else {
      this.who = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `who` property exists and has a value; `false` otherwise
   */
  public hasWho(): boolean {
    return isDefined<Reference>(this.who) && !this.who.isEmpty();
  }

  /**
   * @returns the `onBehalfOf` property value as a Reference object; else an empty Reference object
   */
  public getOnBehalfOf(): Reference {
    return this.onBehalfOf ?? new Reference();
  }

  /**
   * Assigns the provided OnBehalfOf object value to the `onBehalfOf` property.
   *
   * @decorator `@ReferenceTargets('Signature.onBehalfOf', ['Practitioner','PractitionerRole','RelatedPerson','Patient','Device','Organization',])`
   *
   * @param value - the `onBehalfOf` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('Signature.onBehalfOf', [
    'Practitioner',
  
    'PractitionerRole',
  
    'RelatedPerson',
  
    'Patient',
  
    'Device',
  
    'Organization',
  ])
  public setOnBehalfOf(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.onBehalfOf = value;
    } else {
      this.onBehalfOf = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `onBehalfOf` property exists and has a value; `false` otherwise
   */
  public hasOnBehalfOf(): boolean {
    return isDefined<Reference>(this.onBehalfOf) && !this.onBehalfOf.isEmpty();
  }

  /**
   * @returns the `targetFormat` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getTargetFormatElement(): CodeType {
    return this.targetFormat ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `targetFormat` property.
   *
   * @param element - the `targetFormat` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTargetFormatElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid Signature.targetFormat; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.targetFormat = element;
    } else {
      this.targetFormat = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `targetFormat` property exists and has a value; `false` otherwise
   */
  public hasTargetFormatElement(): boolean {
    return isDefined<CodeType>(this.targetFormat) && !this.targetFormat.isEmpty();
  }

  /**
   * @returns the `targetFormat` property value as a fhirCode if defined; else undefined
   */
  public getTargetFormat(): fhirCode | undefined {
    return this.targetFormat?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `targetFormat` property.
   *
   * @param value - the `targetFormat` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTargetFormat(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid Signature.targetFormat (${String(value)})`;
      this.targetFormat = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.targetFormat = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `targetFormat` property exists and has a value; `false` otherwise
   */
  public hasTargetFormat(): boolean {
    return this.hasTargetFormatElement();
  }

  /**
   * @returns the `sigFormat` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getSigFormatElement(): CodeType {
    return this.sigFormat ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `sigFormat` property.
   *
   * @param element - the `sigFormat` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSigFormatElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid Signature.sigFormat; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.sigFormat = element;
    } else {
      this.sigFormat = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `sigFormat` property exists and has a value; `false` otherwise
   */
  public hasSigFormatElement(): boolean {
    return isDefined<CodeType>(this.sigFormat) && !this.sigFormat.isEmpty();
  }

  /**
   * @returns the `sigFormat` property value as a fhirCode if defined; else undefined
   */
  public getSigFormat(): fhirCode | undefined {
    return this.sigFormat?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `sigFormat` property.
   *
   * @param value - the `sigFormat` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSigFormat(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid Signature.sigFormat (${String(value)})`;
      this.sigFormat = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.sigFormat = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `sigFormat` property exists and has a value; `false` otherwise
   */
  public hasSigFormat(): boolean {
    return this.hasSigFormatElement();
  }

  /**
   * @returns the `data` property value as a Base64BinaryType object if defined; else an empty Base64BinaryType object
   */
  public getDataElement(): Base64BinaryType {
    return this.data ?? new Base64BinaryType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `data` property.
   *
   * @param element - the `data` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDataElement(element: Base64BinaryType | undefined): this {
    if (isDefined<Base64BinaryType>(element)) {
      const optErrMsg = `Invalid Signature.data; Provided element is not an instance of Base64BinaryType.`;
      assertFhirType<Base64BinaryType>(element, Base64BinaryType, optErrMsg);
      this.data = element;
    } else {
      this.data = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `data` property exists and has a value; `false` otherwise
   */
  public hasDataElement(): boolean {
    return isDefined<Base64BinaryType>(this.data) && !this.data.isEmpty();
  }

  /**
   * @returns the `data` property value as a fhirBase64Binary if defined; else undefined
   */
  public getData(): fhirBase64Binary | undefined {
    return this.data?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `data` property.
   *
   * @param value - the `data` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setData(value: fhirBase64Binary | undefined): this {
    if (isDefined<fhirBase64Binary>(value)) {
      const optErrMsg = `Invalid Signature.data (${String(value)})`;
      this.data = new Base64BinaryType(parseFhirPrimitiveData(value, fhirBase64BinarySchema, optErrMsg));
    } else {
      this.data = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `data` property exists and has a value; `false` otherwise
   */
  public hasData(): boolean {
    return this.hasDataElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Signature';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.type_,
      this.when,
      this.who,
      this.onBehalfOf,
      this.targetFormat,
      this.sigFormat,
      this.data,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Signature {
    const dest = new Signature();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Signature): void {
    super.copyValues(dest);
    const typeList = copyListValues<Coding>(this.type_);
    dest.type_ = typeList.length === 0 ? undefined : typeList;
    dest.when = this.when?.copy();
    dest.who = this.who?.copy();
    dest.onBehalfOf = this.onBehalfOf?.copy();
    dest.targetFormat = this.targetFormat?.copy();
    dest.sigFormat = this.sigFormat?.copy();
    dest.data = this.data?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasType()) {
      setFhirComplexListJson(this.getType(), 'type', jsonObj);
    }

    if (this.hasWhenElement()) {
      setFhirPrimitiveJson<fhirInstant>(this.getWhenElement(), 'when', jsonObj);
    }

    if (this.hasWho()) {
      setFhirComplexJson(this.getWho(), 'who', jsonObj);
    }

    if (this.hasOnBehalfOf()) {
      setFhirComplexJson(this.getOnBehalfOf(), 'onBehalfOf', jsonObj);
    }

    if (this.hasTargetFormatElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getTargetFormatElement(), 'targetFormat', jsonObj);
    }

    if (this.hasSigFormatElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getSigFormatElement(), 'sigFormat', jsonObj);
    }

    if (this.hasDataElement()) {
      setFhirPrimitiveJson<fhirBase64Binary>(this.getDataElement(), 'data', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * Timing Class
 *
 * @remarks
 * Timing Type: Specifies an event that may occur multiple times. Timing schedules are used to record when things are planned, expected or requested to occur. The most common usage is in dosage instructions for medications. They are also used when planning care of various kinds, and may be used for reporting the schedule to which past regular activities were carried out.
 *
 * Need to able to track proposed timing schedules. There are several different ways to do this: one or more specified times, a simple rules like three times a day, or  before/after meals.
 *
 * **FHIR Specification**
 * - **Short:** A timing schedule that specifies an event that may occur multiple times
 * - **Definition:** Specifies an event that may occur multiple times. Timing schedules are used to record when things are planned, expected or requested to occur. The most common usage is in dosage instructions for medications. They are also used when planning care of various kinds, and may be used for reporting the schedule to which past regular activities were carried out.
 * - **Comment:** Describes the occurrence of an event that may occur multiple times. Timing schedules are used for specifying when events are expected or requested to occur, and may also be used to represent the summary of a past or ongoing event.  For simplicity, the definitions of Timing components are expressed as \'future\' events, but such components can also be used to describe historic or ongoing events. A Timing schedule can be a list of events and/or criteria for when the event happens, which can be expressed in a structured form and/or as a code. When both event and a repeating specification are provided, the list of events should be understood as an interpretation of the information in the repeat structure.
 * - **FHIR Version:** 5.0.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR Timing](http://hl7.org/fhir/StructureDefinition/Timing)
 */
export class Timing extends BackboneType implements IBackboneType {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided `Timing` JSON to instantiate the Timing data model.
   *
   * @param sourceJson - JSON representing FHIR `Timing`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to Timing
   * @returns Timing data model or undefined for `Timing`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Timing | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Timing';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new Timing();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneTypeJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    

    fieldName = 'event';
    sourceField = `${optSourceValue}.${fieldName}`;
    const primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: DateTimeType | undefined = fhirParser.parseDateTimeType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addEventElement(datatype);
        }
      });
    }

    fieldName = 'repeat';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: TimingRepeatComponent | undefined = TimingRepeatComponent.parse(classJsonObj[fieldName]!, sourceField);
      instance.setRepeat(datatype);
    }

    fieldName = 'code';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = CodeableConcept.parse(classJsonObj[fieldName]!, sourceField);
      instance.setCode(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Timing.event Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** When the event occurs
   * - **Definition:** Identifies specific times when the event occurs.
   * - **Requirements:** In a Medication Administration Record, for instance, you need to take a general specification, and turn it into a precise specification.
   * - **FHIR Type:** `dateTime`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private event?: DateTimeType[] | undefined;

  /**
   * Timing.repeat Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** When the event is to occur
   * - **Definition:** A set of rules that describe when the event is scheduled.
   * - **Requirements:** Many timing schedules are determined by regular repetitions.
   * - **FHIR Type:** `Element`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private repeat?: TimingRepeatComponent | undefined;

  /**
   * Timing.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** C | BID | TID | QID | AM | PM | QD | QOD | +
   * - **Definition:** A code for the timing schedule (or just text in code.text). Some codes such as BID are ubiquitous, but many institutions define their own additional codes. If a code is provided, the code is understood to be a complete statement of whatever is specified in the structured timing data, and either the code or the data may be used to interpret the Timing, with the exception that .repeat.bounds still applies over the code (and is not contained in the code).
   * - **Comment:** BID etc. are defined as \'at institutionally specified times\'. For example, an institution may choose that BID is "always at 7am and 6pm".  If it is inappropriate for this choice to be made, the code BID should not be used. Instead, a distinct organization-specific code should be used in place of the HL7-defined BID code and/or a structured representation should be used (in this case, specifying the two event times).
   * - **FHIR Type:** `CodeableConcept`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code?: CodeableConcept | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `event` property value as a DateTimeType array
   */
  public getEventElement(): DateTimeType[] {
    return this.event ?? ([] as DateTimeType[]);
  }

  /**
   * Assigns the provided DateTimeType array value to the `event` property.
   *
   * @param element - the `event` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setEventElement(element: DateTimeType[] | undefined): this {
    if (isDefinedList<DateTimeType>(element)) {
      const optErrMsg = `Invalid Timing.event; Provided value array has an element that is not an instance of DateTimeType.`;
      assertFhirTypeList<DateTimeType>(element, DateTimeType, optErrMsg);
      this.event = element;
    } else {
      this.event = undefined;
    }
    return this;
  }

  /**
   * Add the provided DateTimeType value to the `event` array property.
   *
   * @param element - the `event` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addEventElement(element: DateTimeType | undefined): this {
    if (isDefined<DateTimeType>(element)) {
      const optErrMsg = `Invalid Timing.event; Provided element is not an instance of DateTimeType.`;
      assertFhirType<DateTimeType>(element, DateTimeType, optErrMsg);
      this.initEvent();
      this.event?.push(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `event` property exists and has a value; `false` otherwise
   */
  public hasEventElement(): boolean {
    return isDefinedList<DateTimeType>(this.event) && this.event.some((item: DateTimeType) => !item.isEmpty());
  }

  /**
   * @returns the `event` property value as a fhirDateTime array
   */
  public getEvent(): fhirDateTime[] {
    this.initEvent();
    const eventValues = [] as fhirDateTime[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.event!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        eventValues.push(value);
      }
    }
    return eventValues;
  }

  /**
   * Assigns the provided primitive value array to the `event` property.
   *
   * @param value - the `event` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setEvent(value: fhirDateTime[] | undefined): this {
    if (isDefinedList<fhirDateTime>(value)) {
      const eventElements = [] as DateTimeType[];
      for (const eventValue of value) {
        const optErrMsg = `Invalid Timing.event array item (${String(eventValue)})`;
        const element = new DateTimeType(parseFhirPrimitiveData(eventValue, fhirDateTimeSchema, optErrMsg));
        eventElements.push(element);
      }
      this.event = eventElements;
    } else {
      this.event = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the `event` array property.
   *
   * @param value - the `event` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addEvent(value: fhirDateTime | undefined): this {
    if (isDefined<fhirDateTime>(value)) {
      const optErrMsg = `Invalid Timing.event array item (${String(value)})`;
      const element = new DateTimeType(parseFhirPrimitiveData(value, fhirDateTimeSchema, optErrMsg));
      this.initEvent();
      this.addEventElement(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `event` property exists and has a value; `false` otherwise
   */
  public hasEvent(): boolean {
    return this.hasEventElement();
  }

  /**
   * Initialize the `event` property
   */
  private initEvent(): void {
    if (!this.hasEvent()) {
      this.event = [] as DateTimeType[];
    }
  }

  /**
   * @returns the `repeat` property value as a TimingRepeatComponent object if defined; else an empty TimingRepeatComponent object
   */
  public getRepeat(): TimingRepeatComponent {
    return this.repeat ?? new TimingRepeatComponent();
  }

  /**
   * Assigns the provided Repeat object value to the `repeat` property.
   *
   * @param value - the `repeat` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setRepeat(value: TimingRepeatComponent | undefined): this {
    if (isDefined<TimingRepeatComponent>(value)) {
      const optErrMsg = `Invalid Timing.repeat; Provided element is not an instance of TimingRepeatComponent.`;
      assertFhirType<TimingRepeatComponent>(value, TimingRepeatComponent, optErrMsg);
      this.repeat = value;
    } else {
      this.repeat = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `repeat` property exists and has a value; `false` otherwise
   */
  public hasRepeat(): boolean {
    return isDefined<TimingRepeatComponent>(this.repeat) && !this.repeat.isEmpty();
  }

  /**
   * @returns the `code` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getCode(): CodeableConcept {
    return this.code ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Code object value to the `code` property.
   *
   * @param value - the `code` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setCode(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = `Invalid Timing.code; Provided element is not an instance of CodeableConcept.`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.code = value;
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `code` property exists and has a value; `false` otherwise
   */
  public hasCode(): boolean {
    return isDefined<CodeableConcept>(this.code) && !this.code.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Timing';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.event,
      this.repeat,
      this.code,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Timing {
    const dest = new Timing();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Timing): void {
    super.copyValues(dest);
    const eventList = copyListValues<DateTimeType>(this.event);
    dest.event = eventList.length === 0 ? undefined : eventList;
    dest.repeat = this.repeat?.copy();
    dest.code = this.code?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasEvent()) {
      setFhirPrimitiveListJson(this.getEventElement(), 'event', jsonObj);
    }

    if (this.hasRepeat()) {
      setFhirComplexJson(this.getRepeat(), 'repeat', jsonObj);
    }

    if (this.hasCode()) {
      setFhirComplexJson(this.getCode(), 'code', jsonObj);
    }

    return jsonObj;
  }
}
/**
 * TimingRepeatComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** When the event is to occur
 * - **Definition:** A set of rules that describe when the event is scheduled.
 * - **Requirements:** Many timing schedules are determined by regular repetitions.
 *
 * @category Data Models: ComplexType
 * @see [FHIR Timing](http://hl7.org/fhir/StructureDefinition/Timing)
 */
export class TimingRepeatComponent extends DataType implements IDataType {
  constructor() {
    super();

    this.daysOfWeekEnum = new DaysOfWeekEnum();
  }

  /**
   * Parse the provided `TimingRepeatComponent` JSON to instantiate the TimingRepeatComponent data model.
   *
   * @param sourceJson - JSON representing FHIR `TimingRepeatComponent`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to TimingRepeatComponent
   * @returns TimingRepeatComponent data model or undefined for `TimingRepeatComponent`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): TimingRepeatComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'TimingRepeatComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new TimingRepeatComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const classMetadata: DecoratorMetadataObject | null = TimingRepeatComponent[Symbol.metadata];
    const errorMessage = `DecoratorMetadataObject does not exist for TimingRepeatComponent`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    fieldName = 'bounds[x]';
    sourceField = `${optSourceValue}.${fieldName}`;
    const bounds: IDataType | undefined = fhirParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setBounds(bounds);

    fieldName = 'count';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = fhirParser.parsePositiveIntType(dtJson, dtSiblingJson);
      instance.setCountElement(datatype);
    }

    fieldName = 'countMax';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = fhirParser.parsePositiveIntType(dtJson, dtSiblingJson);
      instance.setCountMaxElement(datatype);
    }

    fieldName = 'duration';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setDurationElement(datatype);
    }

    fieldName = 'durationMax';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setDurationMaxElement(datatype);
    }

    fieldName = 'durationUnit';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setDurationUnitElement(datatype);
    }

    fieldName = 'frequency';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = fhirParser.parsePositiveIntType(dtJson, dtSiblingJson);
      instance.setFrequencyElement(datatype);
    }

    fieldName = 'frequencyMax';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = fhirParser.parsePositiveIntType(dtJson, dtSiblingJson);
      instance.setFrequencyMaxElement(datatype);
    }

    fieldName = 'period';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setPeriodElement(datatype);
    }

    fieldName = 'periodMax';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setPeriodMaxElement(datatype);
    }

    fieldName = 'periodUnit';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setPeriodUnitElement(datatype);
    }

    fieldName = 'dayOfWeek';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: CodeType | undefined = fhirParser.parseCodeType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addDayOfWeekElement(datatype);
        }
      });
    }

    fieldName = 'timeOfDay';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: TimeType | undefined = fhirParser.parseTimeType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addTimeOfDayElement(datatype);
        }
      });
    }

    fieldName = 'when';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: CodeType | undefined = fhirParser.parseCodeType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addWhenElement(datatype);
        }
      });
    }

    fieldName = 'offset';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UnsignedIntType | undefined = fhirParser.parseUnsignedIntType(dtJson, dtSiblingJson);
      instance.setOffsetElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Timing.repeat.bounds[x] Element
   *
   * @decorator `@ChoiceDataTypesMeta('Timing.repeat.bounds[x]', ['Duration','Range','Period',]`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Length/Range of lengths, or (Start and/or end) limits
   * - **Definition:** Either a duration for the length of the timing schedule, a range of possible length, or outer bounds for start and/or end limits of the timing schedule.
   * - **FHIR Types:**
   *     'Duration',
   *     'Range',
   *     'Period',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('Timing.repeat.bounds[x]',[
    'Duration',
    'Range',
    'Period',
  ])
  private bounds?: IDataType | undefined;

  /**
   * Timing.repeat.count Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Number of times to repeat
   * - **Definition:** A total count of the desired number of repetitions across the duration of the entire timing specification. If countMax is present, this element indicates the lower bound of the allowed range of count values.
   * - **Comment:** If you have both bounds and count, then this should be understood as within the bounds period, until count times happens.
   * - **Requirements:** Repetitions may be limited by end time or total occurrences.
   * - **FHIR Type:** `positiveInt`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private count?: PositiveIntType | undefined;

  /**
   * Timing.repeat.countMax Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Maximum number of times to repeat
   * - **Definition:** If present, indicates that the count is a range - so to perform the action between [count] and [countMax] times.
   * - **FHIR Type:** `positiveInt`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private countMax?: PositiveIntType | undefined;

  /**
   * Timing.repeat.duration Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** How long when it happens
   * - **Definition:** How long this thing happens for when it happens. If durationMax is present, this element indicates the lower bound of the allowed range of the duration.
   * - **Comment:** For some events the duration is part of the definition of the event (e.g. IV infusions, where the duration is implicit in the specified quantity and rate). For others, it\'s part of the timing specification (e.g. exercise).
   * - **Requirements:** Some activities are not instantaneous and need to be maintained for a period of time.
   * - **FHIR Type:** `decimal`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private duration?: DecimalType | undefined;

  /**
   * Timing.repeat.durationMax Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** How long when it happens (Max)
   * - **Definition:** If present, indicates that the duration is a range - so to perform the action between [duration] and [durationMax] time length.
   * - **Comment:** For some events the duration is part of the definition of the event (e.g. IV infusions, where the duration is implicit in the specified quantity and rate). For others, it\'s part of the timing specification (e.g. exercise).
   * - **Requirements:** Some activities are not instantaneous and need to be maintained for a period of time.
   * - **FHIR Type:** `decimal`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private durationMax?: DecimalType | undefined;

  /**
   * Timing.repeat.durationUnit Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** s | min | h | d | wk | mo | a - unit of time (UCUM)
   * - **Definition:** The units of time for the duration, in UCUM units Normal practice is to use the \'mo\' code as a calendar month when calculating the next occurrence.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private durationUnit?: CodeType | undefined;

  /**
   * Timing.repeat.frequency Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Indicates the number of repetitions that should occur within a period. I.e. Event occurs frequency times per period
   * - **Definition:** The number of times to repeat the action within the specified period. If frequencyMax is present, this element indicates the lower bound of the allowed range of the frequency.
   * - **FHIR Type:** `positiveInt`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private frequency?: PositiveIntType | undefined;

  /**
   * Timing.repeat.frequencyMax Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Event occurs up to frequencyMax times per period
   * - **Definition:** If present, indicates that the frequency is a range - so to repeat between [frequency] and [frequencyMax] times within the period or period range.
   * - **FHIR Type:** `positiveInt`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private frequencyMax?: PositiveIntType | undefined;

  /**
   * Timing.repeat.period Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The duration to which the frequency applies. I.e. Event occurs frequency times per period
   * - **Definition:** Indicates the duration of time over which repetitions are to occur; e.g. to express "3 times per day", 3 would be the frequency and "1 day" would be the period. If periodMax is present, this element indicates the lower bound of the allowed range of the period length.
   * - **FHIR Type:** `decimal`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private period?: DecimalType | undefined;

  /**
   * Timing.repeat.periodMax Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Upper limit of period (3-4 hours)
   * - **Definition:** If present, indicates that the period is a range from [period] to [periodMax], allowing expressing concepts such as "do this once every 3-5 days.
   * - **FHIR Type:** `decimal`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private periodMax?: DecimalType | undefined;

  /**
   * Timing.repeat.periodUnit Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** s | min | h | d | wk | mo | a - unit of time (UCUM)
   * - **Definition:** The units of time for the period in UCUM units Normal practice is to use the \'mo\' code as a calendar month when calculating the next occurrence.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private periodUnit?: CodeType | undefined;

  /**
   * FHIR CodeSystem: DaysOfWeek
   *
   * @see {@link DaysOfWeekEnum }
   */
  private readonly daysOfWeekEnum: DaysOfWeekEnum;

  /**
   * Timing.repeat.dayOfWeek Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** mon | tue | wed | thu | fri | sat | sun
   * - **Definition:** If one or more days of week is provided, then the action happens only on the specified day(s).
   * - **Comment:** If no days are specified, the action is assumed to happen every day as otherwise specified.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  private dayOfWeek?: EnumCodeType[] | undefined;

  /**
   * Timing.repeat.timeOfDay Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Time of day for action
   * - **Definition:** Specified time of day for action to take place.
   * - **Comment:** When time of day is specified, it is inferred that the action happens every day (as filtered by dayofWeek) on the specified times. If there\'s a timeOfDay, there cannot be a when, or vice versa.
   * - **FHIR Type:** `time`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private timeOfDay?: TimeType[] | undefined;

  /**
   * Timing.repeat.when Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Code for time period of occurrence
   * - **Definition:** An approximate time period during the day, potentially linked to an event of daily living that indicates when the action should occur.
   * - **Comment:** When more than one event is listed, the event is tied to the union of the specified events.
   * - **Requirements:** Timings are frequently determined by occurrences such as waking, eating and sleep.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private when?: CodeType[] | undefined;

  /**
   * Timing.repeat.offset Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Minutes from event (before or after)
   * - **Definition:** The number of minutes from the event. If the event code does not indicate whether the minutes is before or after the event, then the offset is assumed to be after the event.
   * - **FHIR Type:** `unsignedInt`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private offset?: UnsignedIntType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `bounds` property value as a DataType object if defined; else undefined
   */
  public getBounds(): IDataType | undefined {
    return this.bounds;
  }

  /**
   * Assigns the provided DataType object value to the `bounds` property.
   *
   * @decorator `@ChoiceDataTypes('Timing.repeat.bounds[x]')`
   *
   * @param value - the `bounds` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  @ChoiceDataTypes('Timing.repeat.bounds[x]')
  public setBounds(value: IDataType | undefined): this {
    if (isDefined<IDataType>(value)) {
      // assertFhirType<IDataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.bounds = value;
    } else {
      this.bounds = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `bounds` property exists and has a value; `false` otherwise
   */
  public hasBounds(): boolean {
    return isDefined<IDataType>(this.bounds) && !this.bounds.isEmpty();
  }

  // *** NOTE ***
  // Following choice datatype-specific "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the `bounds` property value as a Duration object if defined; else undefined
   */
  public getBoundsDuration(): Duration | undefined {
    if (!isDefined<IDataType | undefined>(this.bounds)) {
      return undefined;
    }
    if (!(this.bounds instanceof Duration)) {
      throw new InvalidTypeError(
        `DataType mismatch for Timing.repeat.bounds[x]: Expected Duration but encountered ${this.bounds.fhirType()}`,
      );
    }
    return this.bounds;
  }

  /**
   * @returns `true` if the `bounds` property exists as a Duration and has a value; `false` otherwise
   */
  public hasBoundsDuration(): boolean {
    return this.hasBounds() && this.bounds instanceof Duration;
  }

  /**
   * @returns the `bounds` property value as a Range object if defined; else undefined
   */
  public getBoundsRange(): Range | undefined {
    if (!isDefined<IDataType | undefined>(this.bounds)) {
      return undefined;
    }
    if (!(this.bounds instanceof Range)) {
      throw new InvalidTypeError(
        `DataType mismatch for Timing.repeat.bounds[x]: Expected Range but encountered ${this.bounds.fhirType()}`,
      );
    }
    return this.bounds;
  }

  /**
   * @returns `true` if the `bounds` property exists as a Range and has a value; `false` otherwise
   */
  public hasBoundsRange(): boolean {
    return this.hasBounds() && this.bounds instanceof Range;
  }

  /**
   * @returns the `bounds` property value as a Period object if defined; else undefined
   */
  public getBoundsPeriod(): Period | undefined {
    if (!isDefined<IDataType | undefined>(this.bounds)) {
      return undefined;
    }
    if (!(this.bounds instanceof Period)) {
      throw new InvalidTypeError(
        `DataType mismatch for Timing.repeat.bounds[x]: Expected Period but encountered ${this.bounds.fhirType()}`,
      );
    }
    return this.bounds;
  }

  /**
   * @returns `true` if the `bounds` property exists as a Period and has a value; `false` otherwise
   */
  public hasBoundsPeriod(): boolean {
    return this.hasBounds() && this.bounds instanceof Period;
  }

  // End of choice datatype-specific "get"/"has" methods

  /**
   * @returns the `count` property value as a PositiveIntType object if defined; else an empty PositiveIntType object
   */
  public getCountElement(): PositiveIntType {
    return this.count ?? new PositiveIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `count` property.
   *
   * @param element - the `count` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCountElement(element: PositiveIntType | undefined): this {
    if (isDefined<PositiveIntType>(element)) {
      const optErrMsg = `Invalid Timing.repeat.count; Provided element is not an instance of PositiveIntType.`;
      assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
      this.count = element;
    } else {
      this.count = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `count` property exists and has a value; `false` otherwise
   */
  public hasCountElement(): boolean {
    return isDefined<PositiveIntType>(this.count) && !this.count.isEmpty();
  }

  /**
   * @returns the `count` property value as a fhirPositiveInt if defined; else undefined
   */
  public getCount(): fhirPositiveInt | undefined {
    return this.count?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `count` property.
   *
   * @param value - the `count` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCount(value: fhirPositiveInt | undefined): this {
    if (isDefined<fhirPositiveInt>(value)) {
      const optErrMsg = `Invalid Timing.repeat.count (${String(value)})`;
      this.count = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    } else {
      this.count = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `count` property exists and has a value; `false` otherwise
   */
  public hasCount(): boolean {
    return this.hasCountElement();
  }

  /**
   * @returns the `countMax` property value as a PositiveIntType object if defined; else an empty PositiveIntType object
   */
  public getCountMaxElement(): PositiveIntType {
    return this.countMax ?? new PositiveIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `countMax` property.
   *
   * @param element - the `countMax` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCountMaxElement(element: PositiveIntType | undefined): this {
    if (isDefined<PositiveIntType>(element)) {
      const optErrMsg = `Invalid Timing.repeat.countMax; Provided element is not an instance of PositiveIntType.`;
      assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
      this.countMax = element;
    } else {
      this.countMax = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `countMax` property exists and has a value; `false` otherwise
   */
  public hasCountMaxElement(): boolean {
    return isDefined<PositiveIntType>(this.countMax) && !this.countMax.isEmpty();
  }

  /**
   * @returns the `countMax` property value as a fhirPositiveInt if defined; else undefined
   */
  public getCountMax(): fhirPositiveInt | undefined {
    return this.countMax?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `countMax` property.
   *
   * @param value - the `countMax` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCountMax(value: fhirPositiveInt | undefined): this {
    if (isDefined<fhirPositiveInt>(value)) {
      const optErrMsg = `Invalid Timing.repeat.countMax (${String(value)})`;
      this.countMax = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    } else {
      this.countMax = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `countMax` property exists and has a value; `false` otherwise
   */
  public hasCountMax(): boolean {
    return this.hasCountMaxElement();
  }

  /**
   * @returns the `duration` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getDurationElement(): DecimalType {
    return this.duration ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `duration` property.
   *
   * @param element - the `duration` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDurationElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = `Invalid Timing.repeat.duration; Provided element is not an instance of DecimalType.`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.duration = element;
    } else {
      this.duration = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `duration` property exists and has a value; `false` otherwise
   */
  public hasDurationElement(): boolean {
    return isDefined<DecimalType>(this.duration) && !this.duration.isEmpty();
  }

  /**
   * @returns the `duration` property value as a fhirDecimal if defined; else undefined
   */
  public getDuration(): fhirDecimal | undefined {
    return this.duration?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `duration` property.
   *
   * @param value - the `duration` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDuration(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = `Invalid Timing.repeat.duration (${String(value)})`;
      this.duration = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.duration = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `duration` property exists and has a value; `false` otherwise
   */
  public hasDuration(): boolean {
    return this.hasDurationElement();
  }

  /**
   * @returns the `durationMax` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getDurationMaxElement(): DecimalType {
    return this.durationMax ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `durationMax` property.
   *
   * @param element - the `durationMax` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDurationMaxElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = `Invalid Timing.repeat.durationMax; Provided element is not an instance of DecimalType.`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.durationMax = element;
    } else {
      this.durationMax = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `durationMax` property exists and has a value; `false` otherwise
   */
  public hasDurationMaxElement(): boolean {
    return isDefined<DecimalType>(this.durationMax) && !this.durationMax.isEmpty();
  }

  /**
   * @returns the `durationMax` property value as a fhirDecimal if defined; else undefined
   */
  public getDurationMax(): fhirDecimal | undefined {
    return this.durationMax?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `durationMax` property.
   *
   * @param value - the `durationMax` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDurationMax(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = `Invalid Timing.repeat.durationMax (${String(value)})`;
      this.durationMax = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.durationMax = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `durationMax` property exists and has a value; `false` otherwise
   */
  public hasDurationMax(): boolean {
    return this.hasDurationMaxElement();
  }

  /**
   * @returns the `durationUnit` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getDurationUnitElement(): CodeType {
    return this.durationUnit ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `durationUnit` property.
   *
   * @param element - the `durationUnit` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDurationUnitElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid Timing.repeat.durationUnit; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.durationUnit = element;
    } else {
      this.durationUnit = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `durationUnit` property exists and has a value; `false` otherwise
   */
  public hasDurationUnitElement(): boolean {
    return isDefined<CodeType>(this.durationUnit) && !this.durationUnit.isEmpty();
  }

  /**
   * @returns the `durationUnit` property value as a fhirCode if defined; else undefined
   */
  public getDurationUnit(): fhirCode | undefined {
    return this.durationUnit?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `durationUnit` property.
   *
   * @param value - the `durationUnit` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDurationUnit(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid Timing.repeat.durationUnit (${String(value)})`;
      this.durationUnit = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.durationUnit = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `durationUnit` property exists and has a value; `false` otherwise
   */
  public hasDurationUnit(): boolean {
    return this.hasDurationUnitElement();
  }

  /**
   * @returns the `frequency` property value as a PositiveIntType object if defined; else an empty PositiveIntType object
   */
  public getFrequencyElement(): PositiveIntType {
    return this.frequency ?? new PositiveIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `frequency` property.
   *
   * @param element - the `frequency` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setFrequencyElement(element: PositiveIntType | undefined): this {
    if (isDefined<PositiveIntType>(element)) {
      const optErrMsg = `Invalid Timing.repeat.frequency; Provided element is not an instance of PositiveIntType.`;
      assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
      this.frequency = element;
    } else {
      this.frequency = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `frequency` property exists and has a value; `false` otherwise
   */
  public hasFrequencyElement(): boolean {
    return isDefined<PositiveIntType>(this.frequency) && !this.frequency.isEmpty();
  }

  /**
   * @returns the `frequency` property value as a fhirPositiveInt if defined; else undefined
   */
  public getFrequency(): fhirPositiveInt | undefined {
    return this.frequency?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `frequency` property.
   *
   * @param value - the `frequency` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setFrequency(value: fhirPositiveInt | undefined): this {
    if (isDefined<fhirPositiveInt>(value)) {
      const optErrMsg = `Invalid Timing.repeat.frequency (${String(value)})`;
      this.frequency = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    } else {
      this.frequency = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `frequency` property exists and has a value; `false` otherwise
   */
  public hasFrequency(): boolean {
    return this.hasFrequencyElement();
  }

  /**
   * @returns the `frequencyMax` property value as a PositiveIntType object if defined; else an empty PositiveIntType object
   */
  public getFrequencyMaxElement(): PositiveIntType {
    return this.frequencyMax ?? new PositiveIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `frequencyMax` property.
   *
   * @param element - the `frequencyMax` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setFrequencyMaxElement(element: PositiveIntType | undefined): this {
    if (isDefined<PositiveIntType>(element)) {
      const optErrMsg = `Invalid Timing.repeat.frequencyMax; Provided element is not an instance of PositiveIntType.`;
      assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
      this.frequencyMax = element;
    } else {
      this.frequencyMax = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `frequencyMax` property exists and has a value; `false` otherwise
   */
  public hasFrequencyMaxElement(): boolean {
    return isDefined<PositiveIntType>(this.frequencyMax) && !this.frequencyMax.isEmpty();
  }

  /**
   * @returns the `frequencyMax` property value as a fhirPositiveInt if defined; else undefined
   */
  public getFrequencyMax(): fhirPositiveInt | undefined {
    return this.frequencyMax?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `frequencyMax` property.
   *
   * @param value - the `frequencyMax` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setFrequencyMax(value: fhirPositiveInt | undefined): this {
    if (isDefined<fhirPositiveInt>(value)) {
      const optErrMsg = `Invalid Timing.repeat.frequencyMax (${String(value)})`;
      this.frequencyMax = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    } else {
      this.frequencyMax = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `frequencyMax` property exists and has a value; `false` otherwise
   */
  public hasFrequencyMax(): boolean {
    return this.hasFrequencyMaxElement();
  }

  /**
   * @returns the `period` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getPeriodElement(): DecimalType {
    return this.period ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `period` property.
   *
   * @param element - the `period` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPeriodElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = `Invalid Timing.repeat.period; Provided element is not an instance of DecimalType.`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.period = element;
    } else {
      this.period = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `period` property exists and has a value; `false` otherwise
   */
  public hasPeriodElement(): boolean {
    return isDefined<DecimalType>(this.period) && !this.period.isEmpty();
  }

  /**
   * @returns the `period` property value as a fhirDecimal if defined; else undefined
   */
  public getPeriod(): fhirDecimal | undefined {
    return this.period?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `period` property.
   *
   * @param value - the `period` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPeriod(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = `Invalid Timing.repeat.period (${String(value)})`;
      this.period = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.period = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `period` property exists and has a value; `false` otherwise
   */
  public hasPeriod(): boolean {
    return this.hasPeriodElement();
  }

  /**
   * @returns the `periodMax` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getPeriodMaxElement(): DecimalType {
    return this.periodMax ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `periodMax` property.
   *
   * @param element - the `periodMax` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPeriodMaxElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = `Invalid Timing.repeat.periodMax; Provided element is not an instance of DecimalType.`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.periodMax = element;
    } else {
      this.periodMax = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `periodMax` property exists and has a value; `false` otherwise
   */
  public hasPeriodMaxElement(): boolean {
    return isDefined<DecimalType>(this.periodMax) && !this.periodMax.isEmpty();
  }

  /**
   * @returns the `periodMax` property value as a fhirDecimal if defined; else undefined
   */
  public getPeriodMax(): fhirDecimal | undefined {
    return this.periodMax?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `periodMax` property.
   *
   * @param value - the `periodMax` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPeriodMax(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = `Invalid Timing.repeat.periodMax (${String(value)})`;
      this.periodMax = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.periodMax = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `periodMax` property exists and has a value; `false` otherwise
   */
  public hasPeriodMax(): boolean {
    return this.hasPeriodMaxElement();
  }

  /**
   * @returns the `periodUnit` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getPeriodUnitElement(): CodeType {
    return this.periodUnit ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `periodUnit` property.
   *
   * @param element - the `periodUnit` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPeriodUnitElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid Timing.repeat.periodUnit; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.periodUnit = element;
    } else {
      this.periodUnit = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `periodUnit` property exists and has a value; `false` otherwise
   */
  public hasPeriodUnitElement(): boolean {
    return isDefined<CodeType>(this.periodUnit) && !this.periodUnit.isEmpty();
  }

  /**
   * @returns the `periodUnit` property value as a fhirCode if defined; else undefined
   */
  public getPeriodUnit(): fhirCode | undefined {
    return this.periodUnit?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `periodUnit` property.
   *
   * @param value - the `periodUnit` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPeriodUnit(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid Timing.repeat.periodUnit (${String(value)})`;
      this.periodUnit = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.periodUnit = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `periodUnit` property exists and has a value; `false` otherwise
   */
  public hasPeriodUnit(): boolean {
    return this.hasPeriodUnitElement();
  }

  /**
   * @returns the `dayOfWeek` property value as a EnumCodeType array
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public getDayOfWeekEnumType(): EnumCodeType[] {
    return this.dayOfWeek ?? ([] as EnumCodeType[]);
  }

  /**
   * Assigns the provided EnumCodeType array value to the `dayOfWeek` property.
   *
   * @param enumType - the `dayOfWeek` array value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public setDayOfWeekEnumType(enumType: EnumCodeType[] | undefined): this {
    if (isDefinedList<EnumCodeType>(enumType)) {
      const errMsgPrefix = `Invalid Timing.repeat.dayOfWeek`;
      assertEnumCodeTypeList<DaysOfWeekEnum>(enumType, DaysOfWeekEnum, errMsgPrefix);
      this.dayOfWeek = enumType;
    } else {
      this.dayOfWeek = undefined;
    }
    return this;
  }

  /**
   * Add the provided EnumCodeType value to the `dayOfWeek` array property.
   *
   * @param enumType - the `dayOfWeek` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public addDayOfWeekEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = `Invalid Timing.repeat.dayOfWeek`;
      assertEnumCodeType<DaysOfWeekEnum>(enumType, DaysOfWeekEnum, errMsgPrefix);
      this.initDayOfWeek();
      this.dayOfWeek?.push(enumType);
    }
    return this;
  }

  /**
   * @returns `true` if the `dayOfWeek` property exists and has a value; `false` otherwise
   */
  public hasDayOfWeekEnumType(): boolean {
    return isDefinedList<EnumCodeType>(this.dayOfWeek) && this.dayOfWeek.some((item: EnumCodeType) => !item.isEmpty()) && this.dayOfWeek.every((item: EnumCodeType) => item.fhirCodeEnumeration.length > 0);
  }

  /**
   * @returns the `dayOfWeek` property value as a CodeType array
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public getDayOfWeekElement(): CodeType[] {
    if (this.dayOfWeek === undefined) {
      return [] as CodeType[];
    }
    return this.dayOfWeek as CodeType[];
  }

  /**
   * Assigns the provided PrimitiveType array value to the `dayOfWeek` property.
   *
   * @param element - the `dayOfWeek` array value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public setDayOfWeekElement(element: CodeType[] | undefined): this {
    if (isDefinedList<CodeType>(element)) {
      const optErrMsg = `Invalid Timing.repeat.dayOfWeek; Provided element array has an element that is not an instance of CodeType.`;
      assertFhirTypeList<CodeType>(element, CodeType, optErrMsg);
      const enumCodeTypes = [] as EnumCodeType[];
      element.forEach((type: CodeType) => {
        enumCodeTypes.push(new EnumCodeType(type, this.daysOfWeekEnum));
      });
      this.dayOfWeek = enumCodeTypes;
    } else {
      this.dayOfWeek = undefined;
    }
    return this;
  }

  /**
   * Add the provided PrimitiveType value to the `dayOfWeek` array property.
   *
   * @param element - the `dayOfWeek` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public addDayOfWeekElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid Timing.repeat.dayOfWeek; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.initDayOfWeek();
      this.dayOfWeek?.push(new EnumCodeType(element, this.daysOfWeekEnum));
    }
    return this;
  }

  /**
   * @returns `true` if the `dayOfWeek` property exists and has a value; `false` otherwise
   */
  public hasDayOfWeekElement(): boolean {
    return this.hasDayOfWeekEnumType();
  }

  /**
   * @returns the `dayOfWeek` property value as a fhirCode array
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public getDayOfWeek(): fhirCode[] {
    if (this.dayOfWeek === undefined) {
      return [] as fhirCode[];
    }
    const values = [] as fhirCode[];
    for (const item of this.dayOfWeek) {
      values.push(item.fhirCode.code);
    }
    return values;
  }

  /**
   * Assigns the provided primitive value array to the `dayOfWeek` property.
   *
   * @param value - the `dayOfWeek` value array
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public setDayOfWeek(value: fhirCode[] | undefined): this {
    if (isDefinedList<fhirCode>(value)) {
      const enumCodeTypes = [] as EnumCodeType[];
      const optErrMsg = `Invalid Timing.repeat.dayOfWeek; Provided value is not an instance of fhirCode.`;
      value.forEach((val: fhirCode) => {
        enumCodeTypes.push(new EnumCodeType(parseFhirPrimitiveData(val, fhirCodeSchema, optErrMsg), this.daysOfWeekEnum));
      });
      this.dayOfWeek = enumCodeTypes;
    } else {
      this.dayOfWeek = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the `dayOfWeek` array property.
   *
   * @param value - the `dayOfWeek` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public addDayOfWeek(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      this.initDayOfWeek();
      const optErrMsg = `Invalid Timing.repeat.dayOfWeek; Provided value is not an instance of fhirCode.`;
      this.dayOfWeek?.push(new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.daysOfWeekEnum));
    }
    return this;
  }

  /**
   * @returns `true` if the `dayOfWeek` property exists and has a value; `false` otherwise
   */
  public hasDayOfWeek(): boolean {
    return this.hasDayOfWeekEnumType();
  }

  /**
   * Initialize the dayOfWeek property
   */
  private initDayOfWeek(): void {
    if(!this.hasDayOfWeekEnumType()) {
      this.dayOfWeek = [] as EnumCodeType[];
    }
  }

  /**
   * @returns the `timeOfDay` property value as a TimeType array
   */
  public getTimeOfDayElement(): TimeType[] {
    return this.timeOfDay ?? ([] as TimeType[]);
  }

  /**
   * Assigns the provided TimeType array value to the `timeOfDay` property.
   *
   * @param element - the `timeOfDay` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTimeOfDayElement(element: TimeType[] | undefined): this {
    if (isDefinedList<TimeType>(element)) {
      const optErrMsg = `Invalid Timing.repeat.timeOfDay; Provided value array has an element that is not an instance of TimeType.`;
      assertFhirTypeList<TimeType>(element, TimeType, optErrMsg);
      this.timeOfDay = element;
    } else {
      this.timeOfDay = undefined;
    }
    return this;
  }

  /**
   * Add the provided TimeType value to the `timeOfDay` array property.
   *
   * @param element - the `timeOfDay` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addTimeOfDayElement(element: TimeType | undefined): this {
    if (isDefined<TimeType>(element)) {
      const optErrMsg = `Invalid Timing.repeat.timeOfDay; Provided element is not an instance of TimeType.`;
      assertFhirType<TimeType>(element, TimeType, optErrMsg);
      this.initTimeOfDay();
      this.timeOfDay?.push(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `timeOfDay` property exists and has a value; `false` otherwise
   */
  public hasTimeOfDayElement(): boolean {
    return isDefinedList<TimeType>(this.timeOfDay) && this.timeOfDay.some((item: TimeType) => !item.isEmpty());
  }

  /**
   * @returns the `timeOfDay` property value as a fhirTime array
   */
  public getTimeOfDay(): fhirTime[] {
    this.initTimeOfDay();
    const timeOfDayValues = [] as fhirTime[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.timeOfDay!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        timeOfDayValues.push(value);
      }
    }
    return timeOfDayValues;
  }

  /**
   * Assigns the provided primitive value array to the `timeOfDay` property.
   *
   * @param value - the `timeOfDay` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTimeOfDay(value: fhirTime[] | undefined): this {
    if (isDefinedList<fhirTime>(value)) {
      const timeOfDayElements = [] as TimeType[];
      for (const timeOfDayValue of value) {
        const optErrMsg = `Invalid Timing.repeat.timeOfDay array item (${String(timeOfDayValue)})`;
        const element = new TimeType(parseFhirPrimitiveData(timeOfDayValue, fhirTimeSchema, optErrMsg));
        timeOfDayElements.push(element);
      }
      this.timeOfDay = timeOfDayElements;
    } else {
      this.timeOfDay = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the `timeOfDay` array property.
   *
   * @param value - the `timeOfDay` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addTimeOfDay(value: fhirTime | undefined): this {
    if (isDefined<fhirTime>(value)) {
      const optErrMsg = `Invalid Timing.repeat.timeOfDay array item (${String(value)})`;
      const element = new TimeType(parseFhirPrimitiveData(value, fhirTimeSchema, optErrMsg));
      this.initTimeOfDay();
      this.addTimeOfDayElement(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `timeOfDay` property exists and has a value; `false` otherwise
   */
  public hasTimeOfDay(): boolean {
    return this.hasTimeOfDayElement();
  }

  /**
   * Initialize the `timeOfDay` property
   */
  private initTimeOfDay(): void {
    if (!this.hasTimeOfDay()) {
      this.timeOfDay = [] as TimeType[];
    }
  }

  /**
   * @returns the `when` property value as a CodeType array
   */
  public getWhenElement(): CodeType[] {
    return this.when ?? ([] as CodeType[]);
  }

  /**
   * Assigns the provided CodeType array value to the `when` property.
   *
   * @param element - the `when` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setWhenElement(element: CodeType[] | undefined): this {
    if (isDefinedList<CodeType>(element)) {
      const optErrMsg = `Invalid Timing.repeat.when; Provided value array has an element that is not an instance of CodeType.`;
      assertFhirTypeList<CodeType>(element, CodeType, optErrMsg);
      this.when = element;
    } else {
      this.when = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeType value to the `when` array property.
   *
   * @param element - the `when` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addWhenElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid Timing.repeat.when; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.initWhen();
      this.when?.push(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `when` property exists and has a value; `false` otherwise
   */
  public hasWhenElement(): boolean {
    return isDefinedList<CodeType>(this.when) && this.when.some((item: CodeType) => !item.isEmpty());
  }

  /**
   * @returns the `when` property value as a fhirCode array
   */
  public getWhen(): fhirCode[] {
    this.initWhen();
    const whenValues = [] as fhirCode[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.when!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        whenValues.push(value);
      }
    }
    return whenValues;
  }

  /**
   * Assigns the provided primitive value array to the `when` property.
   *
   * @param value - the `when` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setWhen(value: fhirCode[] | undefined): this {
    if (isDefinedList<fhirCode>(value)) {
      const whenElements = [] as CodeType[];
      for (const whenValue of value) {
        const optErrMsg = `Invalid Timing.repeat.when array item (${String(whenValue)})`;
        const element = new CodeType(parseFhirPrimitiveData(whenValue, fhirCodeSchema, optErrMsg));
        whenElements.push(element);
      }
      this.when = whenElements;
    } else {
      this.when = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the `when` array property.
   *
   * @param value - the `when` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addWhen(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid Timing.repeat.when array item (${String(value)})`;
      const element = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
      this.initWhen();
      this.addWhenElement(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `when` property exists and has a value; `false` otherwise
   */
  public hasWhen(): boolean {
    return this.hasWhenElement();
  }

  /**
   * Initialize the `when` property
   */
  private initWhen(): void {
    if (!this.hasWhen()) {
      this.when = [] as CodeType[];
    }
  }

  /**
   * @returns the `offset` property value as a UnsignedIntType object if defined; else an empty UnsignedIntType object
   */
  public getOffsetElement(): UnsignedIntType {
    return this.offset ?? new UnsignedIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `offset` property.
   *
   * @param element - the `offset` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setOffsetElement(element: UnsignedIntType | undefined): this {
    if (isDefined<UnsignedIntType>(element)) {
      const optErrMsg = `Invalid Timing.repeat.offset; Provided element is not an instance of UnsignedIntType.`;
      assertFhirType<UnsignedIntType>(element, UnsignedIntType, optErrMsg);
      this.offset = element;
    } else {
      this.offset = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `offset` property exists and has a value; `false` otherwise
   */
  public hasOffsetElement(): boolean {
    return isDefined<UnsignedIntType>(this.offset) && !this.offset.isEmpty();
  }

  /**
   * @returns the `offset` property value as a fhirUnsignedInt if defined; else undefined
   */
  public getOffset(): fhirUnsignedInt | undefined {
    return this.offset?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `offset` property.
   *
   * @param value - the `offset` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setOffset(value: fhirUnsignedInt | undefined): this {
    if (isDefined<fhirUnsignedInt>(value)) {
      const optErrMsg = `Invalid Timing.repeat.offset (${String(value)})`;
      this.offset = new UnsignedIntType(parseFhirPrimitiveData(value, fhirUnsignedIntSchema, optErrMsg));
    } else {
      this.offset = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `offset` property exists and has a value; `false` otherwise
   */
  public hasOffset(): boolean {
    return this.hasOffsetElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Timing.repeat';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.bounds,
      this.count,
      this.countMax,
      this.duration,
      this.durationMax,
      this.durationUnit,
      this.frequency,
      this.frequencyMax,
      this.period,
      this.periodMax,
      this.periodUnit,
      this.dayOfWeek,
      this.timeOfDay,
      this.when,
      this.offset,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): TimingRepeatComponent {
    const dest = new TimingRepeatComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: TimingRepeatComponent): void {
    super.copyValues(dest);
    dest.bounds = this.bounds?.copy() as IDataType;
    dest.count = this.count?.copy();
    dest.countMax = this.countMax?.copy();
    dest.duration = this.duration?.copy();
    dest.durationMax = this.durationMax?.copy();
    dest.durationUnit = this.durationUnit?.copy();
    dest.frequency = this.frequency?.copy();
    dest.frequencyMax = this.frequencyMax?.copy();
    dest.period = this.period?.copy();
    dest.periodMax = this.periodMax?.copy();
    dest.periodUnit = this.periodUnit?.copy();
    const dayOfWeekList = copyListValues<EnumCodeType>(this.dayOfWeek);
    dest.dayOfWeek = dayOfWeekList.length === 0 ? undefined : dayOfWeekList;
    const timeOfDayList = copyListValues<TimeType>(this.timeOfDay);
    dest.timeOfDay = timeOfDayList.length === 0 ? undefined : timeOfDayList;
    const whenList = copyListValues<CodeType>(this.when);
    dest.when = whenList.length === 0 ? undefined : whenList;
    dest.offset = this.offset?.copy();
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasBounds()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getBounds()!, 'bounds', jsonObj);
    }

    if (this.hasCountElement()) {
      setFhirPrimitiveJson<fhirPositiveInt>(this.getCountElement(), 'count', jsonObj);
    }

    if (this.hasCountMaxElement()) {
      setFhirPrimitiveJson<fhirPositiveInt>(this.getCountMaxElement(), 'countMax', jsonObj);
    }

    if (this.hasDurationElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getDurationElement(), 'duration', jsonObj);
    }

    if (this.hasDurationMaxElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getDurationMaxElement(), 'durationMax', jsonObj);
    }

    if (this.hasDurationUnitElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getDurationUnitElement(), 'durationUnit', jsonObj);
    }

    if (this.hasFrequencyElement()) {
      setFhirPrimitiveJson<fhirPositiveInt>(this.getFrequencyElement(), 'frequency', jsonObj);
    }

    if (this.hasFrequencyMaxElement()) {
      setFhirPrimitiveJson<fhirPositiveInt>(this.getFrequencyMaxElement(), 'frequencyMax', jsonObj);
    }

    if (this.hasPeriodElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getPeriodElement(), 'period', jsonObj);
    }

    if (this.hasPeriodMaxElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getPeriodMaxElement(), 'periodMax', jsonObj);
    }

    if (this.hasPeriodUnitElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getPeriodUnitElement(), 'periodUnit', jsonObj);
    }

    if (this.hasDayOfWeekElement()) {
      setFhirPrimitiveListJson<fhirCode>(this.getDayOfWeekElement(), 'dayOfWeek', jsonObj);
    }

    if (this.hasTimeOfDay()) {
      setFhirPrimitiveListJson(this.getTimeOfDayElement(), 'timeOfDay', jsonObj);
    }

    if (this.hasWhen()) {
      setFhirPrimitiveListJson(this.getWhenElement(), 'when', jsonObj);
    }

    if (this.hasOffsetElement()) {
      setFhirPrimitiveJson<fhirUnsignedInt>(this.getOffsetElement(), 'offset', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * TriggerDefinition Class
 *
 * @remarks
 * TriggerDefinition Type: A description of a triggering event. Triggering events can be named events, data events, or periodic, as determined by the type element.
 *
 * **FHIR Specification**
 * - **Short:** Defines an expected trigger for a module
 * - **Definition:** A description of a triggering event. Triggering events can be named events, data events, or periodic, as determined by the type element.
 * - **Comment:** If an event is a named-event, it means the event is completely pre-coordinated, and no other information can be specified for the event. If the event is one of the data- events, the data and condition elements specify the triggering criteria. The data element specifies the structured component, and the condition element provides additional optional refinement of that structured component. If the event is periodic, the timing element defines when the event is triggered. For both data- and periodic events, a name can be provided as a shorthand for the formal semantics provided by the other elements.
 * - **FHIR Version:** 5.0.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR TriggerDefinition](http://hl7.org/fhir/StructureDefinition/TriggerDefinition)
 */
export class TriggerDefinition extends DataType implements IDataType {
  constructor(type_: EnumCodeType | CodeType | fhirCode | null = null) {
    super();

    this.triggerTypeEnum = new TriggerTypeEnum();

    this.type_ = constructorCodeValueAsEnumCodeType<TriggerTypeEnum>(
      type_,
      TriggerTypeEnum,
      this.triggerTypeEnum,
      'TriggerDefinition.type',
    );
  }

  /**
   * Parse the provided `TriggerDefinition` JSON to instantiate the TriggerDefinition data model.
   *
   * @param sourceJson - JSON representing FHIR `TriggerDefinition`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to TriggerDefinition
   * @returns TriggerDefinition data model or undefined for `TriggerDefinition`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): TriggerDefinition | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'TriggerDefinition';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new TriggerDefinition();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const classMetadata: DecoratorMetadataObject | null = TriggerDefinition[Symbol.metadata];
    const errorMessage = `DecoratorMetadataObject does not exist for TriggerDefinition`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    const missingReqdProperties: string[] = [];

    fieldName = 'type';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setTypeElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'name';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setNameElement(datatype);
    }

    fieldName = 'code';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = CodeableConcept.parse(classJsonObj[fieldName]!, sourceField);
      instance.setCode(datatype);
    }

    fieldName = 'subscriptionTopic';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CanonicalType | undefined = fhirParser.parseCanonicalType(dtJson, dtSiblingJson);
      instance.setSubscriptionTopicElement(datatype);
    }

    fieldName = 'timing[x]';
    sourceField = `${optSourceValue}.${fieldName}`;
    const timing: IDataType | undefined = fhirParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setTiming(timing);

    fieldName = 'data';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: DataRequirement | undefined = DataRequirement.parse(dataElementJson, `${sourceField}[${String(idx)}]`);
        if (datatype !== undefined) {
          instance.addData(datatype);
        }
      });
    }

    fieldName = 'condition';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Expression | undefined = Expression.parse(classJsonObj[fieldName]!, sourceField);
      instance.setCondition(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_REQD_IN_JSON} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: TriggerType
   *
   * @see {@link TriggerTypeEnum }
   */
  private readonly triggerTypeEnum: TriggerTypeEnum;

  /**
   * TriggerDefinition.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** named-event | periodic | data-changed | data-added | data-modified | data-removed | data-accessed | data-access-ended
   * - **Definition:** The type of triggering event.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link TriggerTypeEnum }
   */
  private type_: EnumCodeType | null;

  /**
   * TriggerDefinition.name Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Name or URI that identifies the event
   * - **Definition:** A formal name for the event. This may be an absolute URI that identifies the event formally (e.g. from a trigger registry), or a simple relative URI that identifies the event in a local context.
   * - **Comment:** An event name can be provided for all event types, but is required for named events. If a name is provided for a type other than named events, it is considered to be a shorthand for the semantics described by the formal description of the event.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private name?: StringType | undefined;

  /**
   * TriggerDefinition.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Coded definition of the event
   * - **Definition:** A code that identifies the event.
   * - **FHIR Type:** `CodeableConcept`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code?: CodeableConcept | undefined;

  /**
   * TriggerDefinition.subscriptionTopic Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** What event
   * - **Definition:** A reference to a SubscriptionTopic resource that defines the event. If this element is provided, no other information about the trigger definition may be supplied.
   * - **FHIR Type:** `canonical`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/SubscriptionTopic',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private subscriptionTopic?: CanonicalType | undefined;

  /**
   * TriggerDefinition.timing[x] Element
   *
   * @decorator `@ChoiceDataTypesMeta('TriggerDefinition.timing[x]', ['Timing','Reference','date','dateTime',]`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Timing of the event
   * - **Definition:** The timing of the event (if this is a periodic trigger).
   * - **FHIR Types:**
   *     'Timing',
   *     'Reference',
   *     'date',
   *     'dateTime',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('TriggerDefinition.timing[x]',[
    'Timing',
    'Reference',
    'date',
    'dateTime',
  ])
  private timing?: IDataType | undefined;

  /**
   * TriggerDefinition.data Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Triggering data of the event (multiple = \'and\')
   * - **Definition:** The triggering data of the event (if this is a data trigger). If more than one data is requirement is specified, then all the data requirements must be true.
   * - **Comment:** This element shall be present for any data type trigger.
   * - **FHIR Type:** `DataRequirement`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private data?: DataRequirement[] | undefined;

  /**
   * TriggerDefinition.condition Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Whether the event triggers (boolean expression)
   * - **Definition:** A boolean-valued expression that is evaluated in the context of the container of the trigger definition and returns whether or not the trigger fires.
   * - **Comment:** This element can be only be specified for data type triggers and provides additional semantics for the trigger. The context available within the condition is based on the type of data event. For all events, the current resource will be available as context. In addition, for modification events, the previous resource will also be available. The expression may be inlined, or may be a simple absolute URI, which is a reference to a named expression within a logic library referenced by a library element or extension within the containing resource. If the expression is a FHIR Path expression, it evaluates in the context of a resource of one of the type identified in the data requirement, and may also refer to the variable %previous for delta comparisons on events of type data-changed, data-modified, and data-deleted which will always have the same type.
   * - **Requirements:** Need to be able to formally describe the triggering criteria.
   * - **FHIR Type:** `Expression`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private condition?: Expression | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `type_` property value as a EnumCodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link TriggerTypeEnum }
   */
  public getTypeEnumType(): EnumCodeType | null {
    return this.type_;
  }

  /**
   * Assigns the provided EnumCodeType value to the `type_` property.
   *
   * @param enumType - the `type_` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link TriggerTypeEnum }
   */
  public setTypeEnumType(enumType: EnumCodeType): this {
    assertIsDefined<EnumCodeType>(enumType, `TriggerDefinition.type is required`);
    const errMsgPrefix = `Invalid TriggerDefinition.type`;
    assertEnumCodeType<TriggerTypeEnum>(enumType, TriggerTypeEnum, errMsgPrefix);
    this.type_ = enumType;
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasTypeEnumType(): boolean {
    return isDefined<EnumCodeType>(this.type_) && !this.type_.isEmpty() && this.type_.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the `type_` property value as a CodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link TriggerTypeEnum }
   */
  public getTypeElement(): CodeType | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_ as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the `type_` property.
   *
   * @param element - the `type_` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link TriggerTypeEnum }
   */
  public setTypeElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, `TriggerDefinition.type is required`);
    const optErrMsg = `Invalid TriggerDefinition.type; Provided value is not an instance of CodeType.`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.type_ = new EnumCodeType(element, this.triggerTypeEnum);
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasTypeElement(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the `type_` property value as a fhirCode if defined; else null
   *
   * @see CodeSystem Enumeration: {@link TriggerTypeEnum }
   */
  public getType(): fhirCode | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the `type_` property.
   *
   * @param value - the `type_` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link TriggerTypeEnum }
   */
  public setType(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, `TriggerDefinition.type is required`);
    const optErrMsg = `Invalid TriggerDefinition.type (${String(value)})`;
    this.type_ = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.triggerTypeEnum);
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasType(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the `name` property value as a StringType object if defined; else an empty StringType object
   */
  public getNameElement(): StringType {
    return this.name ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `name` property.
   *
   * @param element - the `name` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setNameElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid TriggerDefinition.name; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.name = element;
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `name` property exists and has a value; `false` otherwise
   */
  public hasNameElement(): boolean {
    return isDefined<StringType>(this.name) && !this.name.isEmpty();
  }

  /**
   * @returns the `name` property value as a fhirString if defined; else undefined
   */
  public getName(): fhirString | undefined {
    return this.name?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `name` property.
   *
   * @param value - the `name` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setName(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid TriggerDefinition.name (${String(value)})`;
      this.name = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `name` property exists and has a value; `false` otherwise
   */
  public hasName(): boolean {
    return this.hasNameElement();
  }

  /**
   * @returns the `code` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getCode(): CodeableConcept {
    return this.code ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Code object value to the `code` property.
   *
   * @param value - the `code` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setCode(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = `Invalid TriggerDefinition.code; Provided element is not an instance of CodeableConcept.`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.code = value;
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `code` property exists and has a value; `false` otherwise
   */
  public hasCode(): boolean {
    return isDefined<CodeableConcept>(this.code) && !this.code.isEmpty();
  }

  /**
   * @returns the `subscriptionTopic` property value as a CanonicalType object if defined; else an empty CanonicalType object
   */
  public getSubscriptionTopicElement(): CanonicalType {
    return this.subscriptionTopic ?? new CanonicalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `subscriptionTopic` property.
   *
   * @param element - the `subscriptionTopic` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSubscriptionTopicElement(element: CanonicalType | undefined): this {
    if (isDefined<CanonicalType>(element)) {
      const optErrMsg = `Invalid TriggerDefinition.subscriptionTopic; Provided element is not an instance of CanonicalType.`;
      assertFhirType<CanonicalType>(element, CanonicalType, optErrMsg);
      this.subscriptionTopic = element;
    } else {
      this.subscriptionTopic = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `subscriptionTopic` property exists and has a value; `false` otherwise
   */
  public hasSubscriptionTopicElement(): boolean {
    return isDefined<CanonicalType>(this.subscriptionTopic) && !this.subscriptionTopic.isEmpty();
  }

  /**
   * @returns the `subscriptionTopic` property value as a fhirCanonical if defined; else undefined
   */
  public getSubscriptionTopic(): fhirCanonical | undefined {
    return this.subscriptionTopic?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `subscriptionTopic` property.
   *
   * @param value - the `subscriptionTopic` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSubscriptionTopic(value: fhirCanonical | undefined): this {
    if (isDefined<fhirCanonical>(value)) {
      const optErrMsg = `Invalid TriggerDefinition.subscriptionTopic (${String(value)})`;
      this.subscriptionTopic = new CanonicalType(parseFhirPrimitiveData(value, fhirCanonicalSchema, optErrMsg));
    } else {
      this.subscriptionTopic = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `subscriptionTopic` property exists and has a value; `false` otherwise
   */
  public hasSubscriptionTopic(): boolean {
    return this.hasSubscriptionTopicElement();
  }

  /**
   * @returns the `timing` property value as a DataType object if defined; else undefined
   */
  public getTiming(): IDataType | undefined {
    return this.timing;
  }

  /**
   * Assigns the provided DataType object value to the `timing` property.
   *
   * @decorator `@ChoiceDataTypes('TriggerDefinition.timing[x]')`
   *
   * @param value - the `timing` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  @ChoiceDataTypes('TriggerDefinition.timing[x]')
  public setTiming(value: IDataType | undefined): this {
    if (isDefined<IDataType>(value)) {
      // assertFhirType<IDataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.timing = value;
    } else {
      this.timing = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `timing` property exists and has a value; `false` otherwise
   */
  public hasTiming(): boolean {
    return isDefined<IDataType>(this.timing) && !this.timing.isEmpty();
  }

  // *** NOTE ***
  // Following choice datatype-specific "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the `timing` property value as a Timing object if defined; else undefined
   */
  public getTimingTiming(): Timing | undefined {
    if (!isDefined<IDataType | undefined>(this.timing)) {
      return undefined;
    }
    if (!(this.timing instanceof Timing)) {
      throw new InvalidTypeError(
        `DataType mismatch for TriggerDefinition.timing[x]: Expected Timing but encountered ${this.timing.fhirType()}`,
      );
    }
    return this.timing;
  }

  /**
   * @returns `true` if the `timing` property exists as a Timing and has a value; `false` otherwise
   */
  public hasTimingTiming(): boolean {
    return this.hasTiming() && this.timing instanceof Timing;
  }

  /**
   * @returns the `timing` property value as a Reference object if defined; else undefined
   */
  public getTimingReference(): Reference | undefined {
    if (!isDefined<IDataType | undefined>(this.timing)) {
      return undefined;
    }
    if (!(this.timing instanceof Reference)) {
      throw new InvalidTypeError(
        `DataType mismatch for TriggerDefinition.timing[x]: Expected Reference but encountered ${this.timing.fhirType()}`,
      );
    }
    return this.timing;
  }

  /**
   * @returns `true` if the `timing` property exists as a Reference and has a value; `false` otherwise
   */
  public hasTimingReference(): boolean {
    return this.hasTiming() && this.timing instanceof Reference;
  }

  /**
   * @returns the `timing` property value as a DateType object if defined; else undefined
   */
  public getTimingDateType(): DateType | undefined {
    if (!isDefined<IDataType | undefined>(this.timing)) {
      return undefined;
    }
    if (!(this.timing instanceof DateType)) {
      throw new InvalidTypeError(
        `DataType mismatch for TriggerDefinition.timing[x]: Expected DateType but encountered ${this.timing.fhirType()}`,
      );
    }
    return this.timing;
  }

  /**
   * @returns `true` if the `timing` property exists as a DateType and has a value; `false` otherwise
   */
  public hasTimingDateType(): boolean {
    return this.hasTiming() && this.timing instanceof DateType;
  }

  /**
   * @returns the `timing` property value as a DateTimeType object if defined; else undefined
   */
  public getTimingDateTimeType(): DateTimeType | undefined {
    if (!isDefined<IDataType | undefined>(this.timing)) {
      return undefined;
    }
    if (!(this.timing instanceof DateTimeType)) {
      throw new InvalidTypeError(
        `DataType mismatch for TriggerDefinition.timing[x]: Expected DateTimeType but encountered ${this.timing.fhirType()}`,
      );
    }
    return this.timing;
  }

  /**
   * @returns `true` if the `timing` property exists as a DateTimeType and has a value; `false` otherwise
   */
  public hasTimingDateTimeType(): boolean {
    return this.hasTiming() && this.timing instanceof DateTimeType;
  }

  // End of choice datatype-specific "get"/"has" methods

  /**
   * @returns the `data` property value as a DataRequirement array
   */
  public getData(): DataRequirement[] {
    return this.data ?? ([] as DataRequirement[]);
  }

  /**
   * Assigns the provided DataRequirement array value to the `data` property.
   *
   * @param value - the `data` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setData(value: DataRequirement[] | undefined): this {
    if (isDefinedList<DataRequirement>(value)) {
      const optErrMsg = `Invalid TriggerDefinition.data; Provided value array has an element that is not an instance of DataRequirement.`;
      assertFhirTypeList<DataRequirement>(value, DataRequirement, optErrMsg);
      this.data = value;
    } else {
      this.data = undefined;
    }
    return this;
  }

  /**
   * Add the provided DataRequirement value to the `data` array property.
   *
   * @param value - the `data` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addData(value: DataRequirement | undefined): this {
    if (isDefined<DataRequirement>(value)) {
      const optErrMsg = `Invalid TriggerDefinition.data; Provided element is not an instance of DataRequirement.`;
      assertFhirType<DataRequirement>(value, DataRequirement, optErrMsg);
      this.initData();
      this.data?.push(value);
    }
    return this;
  }

  /**
   * @returns `true` if the `data` property exists and has a value; `false` otherwise
   */
  public hasData(): boolean {
    return isDefinedList<DataRequirement>(this.data) && this.data.some((item: DataRequirement) => !item.isEmpty());
  }

  /**
   * Initialize the `data` property
   */
  private initData(): void {
    if(!this.hasData()) {
      this.data = [] as DataRequirement[];
    }
  }

  /**
   * @returns the `condition` property value as a Expression object if defined; else an empty Expression object
   */
  public getCondition(): Expression {
    return this.condition ?? new Expression();
  }

  /**
   * Assigns the provided Condition object value to the `condition` property.
   *
   * @param value - the `condition` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setCondition(value: Expression | undefined): this {
    if (isDefined<Expression>(value)) {
      const optErrMsg = `Invalid TriggerDefinition.condition; Provided element is not an instance of Expression.`;
      assertFhirType<Expression>(value, Expression, optErrMsg);
      this.condition = value;
    } else {
      this.condition = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `condition` property exists and has a value; `false` otherwise
   */
  public hasCondition(): boolean {
    return isDefined<Expression>(this.condition) && !this.condition.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'TriggerDefinition';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.type_,
      this.name,
      this.code,
      this.subscriptionTopic,
      this.timing,
      this.data,
      this.condition,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): TriggerDefinition {
    const dest = new TriggerDefinition();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: TriggerDefinition): void {
    super.copyValues(dest);
    dest.type_ = this.type_ ? this.type_.copy() : null;
    dest.name = this.name?.copy();
    dest.code = this.code?.copy();
    dest.subscriptionTopic = this.subscriptionTopic?.copy();
    dest.timing = this.timing?.copy() as IDataType;
    const dataList = copyListValues<DataRequirement>(this.data);
    dest.data = dataList.length === 0 ? undefined : dataList;
    dest.condition = this.condition?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasTypeElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getTypeElement()!, 'type', jsonObj);
    } else {
      missingReqdProperties.push(`TriggerDefinition.type`);
    }

    if (this.hasNameElement()) {
      setFhirPrimitiveJson<fhirString>(this.getNameElement(), 'name', jsonObj);
    }

    if (this.hasCode()) {
      setFhirComplexJson(this.getCode(), 'code', jsonObj);
    }

    if (this.hasSubscriptionTopicElement()) {
      setFhirPrimitiveJson<fhirCanonical>(this.getSubscriptionTopicElement(), 'subscriptionTopic', jsonObj);
    }

    if (this.hasTiming()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getTiming()!, 'timing', jsonObj);
    }

    if (this.hasData()) {
      setFhirComplexListJson(this.getData(), 'data', jsonObj);
    }

    if (this.hasCondition()) {
      setFhirComplexJson(this.getCondition(), 'condition', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_DO_NOT_EXIST} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

/**
 * UsageContext Class
 *
 * @remarks
 * UsageContext Type: Specifies clinical/business/etc. metadata that can be used to retrieve, index and/or categorize an artifact. This metadata can either be specific to the applicable population (e.g., age category, DRG) or the specific context of care (e.g., venue, care setting, provider of care).
 *
 * Consumers of the resource must be able to determine the intended applicability for the resource. Ideally, this information would be used programmatically to determine when and how it should be incorporated or exposed.
 *
 * **FHIR Specification**
 * - **Short:** Describes the context of use for a conformance or knowledge resource
 * - **Definition:** Specifies clinical/business/etc. metadata that can be used to retrieve, index and/or categorize an artifact. This metadata can either be specific to the applicable population (e.g., age category, DRG) or the specific context of care (e.g., venue, care setting, provider of care).
 * - **FHIR Version:** 5.0.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR UsageContext](http://hl7.org/fhir/StructureDefinition/UsageContext)
 */
export class UsageContext extends DataType implements IDataType {
  constructor(code: Coding | null = null, value: IDataType | null = null) {
    super();

    this.code = null;
    if (isDefined<Coding>(code)) {
      this.setCode(code);
    }

    this.value = null;
    if (isDefined<IDataType>(value)) {
      this.setValue(value);
    }

  }

  /**
   * Parse the provided `UsageContext` JSON to instantiate the UsageContext data model.
   *
   * @param sourceJson - JSON representing FHIR `UsageContext`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to UsageContext
   * @returns UsageContext data model or undefined for `UsageContext`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): UsageContext | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'UsageContext';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new UsageContext();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';

    const classMetadata: DecoratorMetadataObject | null = UsageContext[Symbol.metadata];
    const errorMessage = `DecoratorMetadataObject does not exist for UsageContext`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    const missingReqdProperties: string[] = [];

    fieldName = 'code';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Coding | undefined = Coding.parse(classJsonObj[fieldName]!, sourceField);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setCode(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'value[x]';
    sourceField = `${optSourceValue}.${fieldName}`;
    const value: IDataType | undefined = fhirParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    if (value === undefined) {
      missingReqdProperties.push(sourceField);
    } else {
      instance.setValue(value);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_REQD_IN_JSON} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * UsageContext.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Type of context being specified
   * - **Definition:** A code that identifies the type of context being specified by this usage context.
   * - **FHIR Type:** `Coding`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code: Coding | null;

  /**
   * UsageContext.value[x] Element
   *
   * @decorator `@ChoiceDataTypesMeta('UsageContext.value[x]', ['CodeableConcept','Quantity','Range','Reference',]`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Value that defines the context
   * - **Definition:** A value that defines the context specified in this context of use. The interpretation of the value is defined by the code.
   * - **FHIR Types:**
   *     'CodeableConcept',
   *     'Quantity',
   *     'Range',
   *     'Reference',
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('UsageContext.value[x]',[
    'CodeableConcept',
    'Quantity',
    'Range',
    'Reference',
  ])
  private value: IDataType | null;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `code` property value as a Coding object if defined; else null
   */
  public getCode(): Coding | null {
    return this.code;
  }

  /**
   * Assigns the provided Coding object value to the `code` property.
   *
   * @param value - the `code` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setCode(value: Coding): this {
    assertIsDefined<Coding>(value, `UsageContext.code is required`);
    const optErrMsg = `Invalid UsageContext.code; Provided element is not an instance of Coding.`;
    assertFhirType<Coding>(value, Coding, optErrMsg);
    this.code = value;
    return this;
  }

  /**
   * @returns `true` if the `code` property exists and has a value; `false` otherwise
   */
  public hasCode(): boolean {
    return isDefined<Coding>(this.code) && !this.code.isEmpty();
  }

  /**
   * @returns the `value` property value as a DataType object; else null
   */
  public getValue(): IDataType | null {
    return this.value;
  }

  /**
   * Assigns the provided DataType object value to the `value` property.
   *
   * @decorator `@ChoiceDataTypes('UsageContext.value[x]')`
   *
   * @param value - the `value` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  @ChoiceDataTypes('UsageContext.value[x]')
  public setValue(value: IDataType): this {
    assertIsDefined<IDataType>(value, `UsageContext.value[x] is required`);
    // assertFhirType<IDataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
    this.value = value;
    return this;
  }

  /**
   * @returns `true` if the `value` property exists and has a value; `false` otherwise
   */
  public hasValue(): boolean {
    return isDefined<IDataType>(this.value) && !this.value.isEmpty();
  }

  // *** NOTE ***
  // Following choice datatype-specific "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the `value` property value as a CodeableConcept object if defined; else null
   */
  public getValueCodeableConcept(): CodeableConcept | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof CodeableConcept)) {
      throw new InvalidTypeError(
        `DataType mismatch for UsageContext.value[x]: Expected CodeableConcept but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a CodeableConcept and has a value; `false` otherwise
   */
  public hasValueCodeableConcept(): boolean {
    return this.hasValue() && this.value instanceof CodeableConcept;
  }

  /**
   * @returns the `value` property value as a Quantity object if defined; else null
   */
  public getValueQuantity(): Quantity | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Quantity)) {
      throw new InvalidTypeError(
        `DataType mismatch for UsageContext.value[x]: Expected Quantity but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a Quantity and has a value; `false` otherwise
   */
  public hasValueQuantity(): boolean {
    return this.hasValue() && this.value instanceof Quantity;
  }

  /**
   * @returns the `value` property value as a Range object if defined; else null
   */
  public getValueRange(): Range | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Range)) {
      throw new InvalidTypeError(
        `DataType mismatch for UsageContext.value[x]: Expected Range but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a Range and has a value; `false` otherwise
   */
  public hasValueRange(): boolean {
    return this.hasValue() && this.value instanceof Range;
  }

  /**
   * @returns the `value` property value as a Reference object if defined; else null
   */
  public getValueReference(): Reference | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Reference)) {
      throw new InvalidTypeError(
        `DataType mismatch for UsageContext.value[x]: Expected Reference but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a Reference and has a value; `false` otherwise
   */
  public hasValueReference(): boolean {
    return this.hasValue() && this.value instanceof Reference;
  }

  // End of choice datatype-specific "get"/"has" methods

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'UsageContext';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.code,
      this.value,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): UsageContext {
    const dest = new UsageContext();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: UsageContext): void {
    super.copyValues(dest);
    dest.code = this.code ? this.code.copy() : null;
    dest.value = this.value ? this.value.copy() as IDataType : null;
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasCode()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirComplexJson(this.getCode()!, 'code', jsonObj);
    } else {
      missingReqdProperties.push(`UsageContext.code`);
    }

    if (this.hasValue()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getValue()!, 'value', jsonObj);
    } else {
      missingReqdProperties.push(`UsageContext.value[x]`);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_DO_NOT_EXIST} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

/**
 * VirtualServiceDetail Class
 *
 * @remarks
 * VirtualServiceDetail Type: Virtual Service Contact Details.
 *
 * **FHIR Specification**
 * - **Short:** Virtual Service Contact Details
 * - **Definition:** Virtual Service Contact Details.
 * - **FHIR Version:** 5.0.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR VirtualServiceDetail](http://hl7.org/fhir/StructureDefinition/VirtualServiceDetail)
 */
export class VirtualServiceDetail extends DataType implements IDataType {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided `VirtualServiceDetail` JSON to instantiate the VirtualServiceDetail data model.
   *
   * @param sourceJson - JSON representing FHIR `VirtualServiceDetail`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to VirtualServiceDetail
   * @returns VirtualServiceDetail data model or undefined for `VirtualServiceDetail`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): VirtualServiceDetail | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'VirtualServiceDetail';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new VirtualServiceDetail();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const classMetadata: DecoratorMetadataObject | null = VirtualServiceDetail[Symbol.metadata];
    const errorMessage = `DecoratorMetadataObject does not exist for VirtualServiceDetail`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    fieldName = 'channelType';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Coding | undefined = Coding.parse(classJsonObj[fieldName]!, sourceField);
      instance.setChannelType(datatype);
    }

    fieldName = 'address[x]';
    sourceField = `${optSourceValue}.${fieldName}`;
    const address: IDataType | undefined = fhirParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setAddress(address);

    fieldName = 'additionalInfo';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: UrlType | undefined = fhirParser.parseUrlType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addAdditionalInfoElement(datatype);
        }
      });
    }

    fieldName = 'maxParticipants';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = fhirParser.parsePositiveIntType(dtJson, dtSiblingJson);
      instance.setMaxParticipantsElement(datatype);
    }

    fieldName = 'sessionKey';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setSessionKeyElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * VirtualServiceDetail.channelType Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Channel Type
   * - **Definition:** The type of virtual service to connect to (i.e. Teams, Zoom, Specific VMR technology, WhatsApp).
   * - **Comment:** As this type defines what the virtual service is, it then defines what address and additional information might be relevant. Some profiles could be used for specific types to define what the other values could/should be.
   * - **FHIR Type:** `Coding`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private channelType?: Coding | undefined;

  /**
   * VirtualServiceDetail.address[x] Element
   *
   * @decorator `@ChoiceDataTypesMeta('VirtualServiceDetail.address[x]', ['url','string','ContactPoint','ExtendedContactDetail',]`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Contact address/number
   * - **Definition:** What address or number needs to be used for a user to connect to the virtual service to join. The channelType informs as to which datatype is appropriate to use (requires knowledge of the specific type).
   * - **FHIR Types:**
   *     'url',
   *     'string',
   *     'ContactPoint',
   *     'ExtendedContactDetail',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('VirtualServiceDetail.address[x]',[
    'url',
    'string',
    'ContactPoint',
    'ExtendedContactDetail',
  ])
  private address?: IDataType | undefined;

  /**
   * VirtualServiceDetail.additionalInfo Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Address to see alternative connection details
   * - **Definition:** Address to see alternative connection details.
   * - **Comment:** This web address can be used to provide additional details on the call, such as alternative/regional call in numbers, or other associated services.
   * - **FHIR Type:** `url`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private additionalInfo?: UrlType[] | undefined;

  /**
   * VirtualServiceDetail.maxParticipants Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Maximum number of participants supported by the virtual service
   * - **Definition:** Maximum number of participants supported by the virtual service.
   * - **Comment:** Some services have only a limitted number of participants permitted to connect at a time, this is typically used in "shared" virtual services that you might find on location resources. Typically on-demand services might not have these restrictions.
   * - **FHIR Type:** `positiveInt`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private maxParticipants?: PositiveIntType | undefined;

  /**
   * VirtualServiceDetail.sessionKey Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Session Key required by the virtual service
   * - **Definition:** Session Key required by the virtual service.
   * - **Comment:** Some services require a session key to be able to access the service once connected. This could be in cases where a shared number is used, and a session key is added to put into a private line, or to identify the participant in a call.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private sessionKey?: StringType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `channelType` property value as a Coding object if defined; else an empty Coding object
   */
  public getChannelType(): Coding {
    return this.channelType ?? new Coding();
  }

  /**
   * Assigns the provided ChannelType object value to the `channelType` property.
   *
   * @param value - the `channelType` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setChannelType(value: Coding | undefined): this {
    if (isDefined<Coding>(value)) {
      const optErrMsg = `Invalid VirtualServiceDetail.channelType; Provided element is not an instance of Coding.`;
      assertFhirType<Coding>(value, Coding, optErrMsg);
      this.channelType = value;
    } else {
      this.channelType = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `channelType` property exists and has a value; `false` otherwise
   */
  public hasChannelType(): boolean {
    return isDefined<Coding>(this.channelType) && !this.channelType.isEmpty();
  }

  /**
   * @returns the `address` property value as a DataType object if defined; else undefined
   */
  public getAddress(): IDataType | undefined {
    return this.address;
  }

  /**
   * Assigns the provided DataType object value to the `address` property.
   *
   * @decorator `@ChoiceDataTypes('VirtualServiceDetail.address[x]')`
   *
   * @param value - the `address` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  @ChoiceDataTypes('VirtualServiceDetail.address[x]')
  public setAddress(value: IDataType | undefined): this {
    if (isDefined<IDataType>(value)) {
      // assertFhirType<IDataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.address = value;
    } else {
      this.address = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `address` property exists and has a value; `false` otherwise
   */
  public hasAddress(): boolean {
    return isDefined<IDataType>(this.address) && !this.address.isEmpty();
  }

  // *** NOTE ***
  // Following choice datatype-specific "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the `address` property value as a UrlType object if defined; else undefined
   */
  public getAddressUrlType(): UrlType | undefined {
    if (!isDefined<IDataType | undefined>(this.address)) {
      return undefined;
    }
    if (!(this.address instanceof UrlType)) {
      throw new InvalidTypeError(
        `DataType mismatch for VirtualServiceDetail.address[x]: Expected UrlType but encountered ${this.address.fhirType()}`,
      );
    }
    return this.address;
  }

  /**
   * @returns `true` if the `address` property exists as a UrlType and has a value; `false` otherwise
   */
  public hasAddressUrlType(): boolean {
    return this.hasAddress() && this.address instanceof UrlType;
  }

  /**
   * @returns the `address` property value as a StringType object if defined; else undefined
   */
  public getAddressStringType(): StringType | undefined {
    if (!isDefined<IDataType | undefined>(this.address)) {
      return undefined;
    }
    if (!(this.address instanceof StringType)) {
      throw new InvalidTypeError(
        `DataType mismatch for VirtualServiceDetail.address[x]: Expected StringType but encountered ${this.address.fhirType()}`,
      );
    }
    return this.address;
  }

  /**
   * @returns `true` if the `address` property exists as a StringType and has a value; `false` otherwise
   */
  public hasAddressStringType(): boolean {
    return this.hasAddress() && this.address instanceof StringType;
  }

  /**
   * @returns the `address` property value as a ContactPoint object if defined; else undefined
   */
  public getAddressContactPoint(): ContactPoint | undefined {
    if (!isDefined<IDataType | undefined>(this.address)) {
      return undefined;
    }
    if (!(this.address instanceof ContactPoint)) {
      throw new InvalidTypeError(
        `DataType mismatch for VirtualServiceDetail.address[x]: Expected ContactPoint but encountered ${this.address.fhirType()}`,
      );
    }
    return this.address;
  }

  /**
   * @returns `true` if the `address` property exists as a ContactPoint and has a value; `false` otherwise
   */
  public hasAddressContactPoint(): boolean {
    return this.hasAddress() && this.address instanceof ContactPoint;
  }

  /**
   * @returns the `address` property value as a ExtendedContactDetail object if defined; else undefined
   */
  public getAddressExtendedContactDetail(): ExtendedContactDetail | undefined {
    if (!isDefined<IDataType | undefined>(this.address)) {
      return undefined;
    }
    if (!(this.address instanceof ExtendedContactDetail)) {
      throw new InvalidTypeError(
        `DataType mismatch for VirtualServiceDetail.address[x]: Expected ExtendedContactDetail but encountered ${this.address.fhirType()}`,
      );
    }
    return this.address;
  }

  /**
   * @returns `true` if the `address` property exists as a ExtendedContactDetail and has a value; `false` otherwise
   */
  public hasAddressExtendedContactDetail(): boolean {
    return this.hasAddress() && this.address instanceof ExtendedContactDetail;
  }

  // End of choice datatype-specific "get"/"has" methods

  /**
   * @returns the `additionalInfo` property value as a UrlType array
   */
  public getAdditionalInfoElement(): UrlType[] {
    return this.additionalInfo ?? ([] as UrlType[]);
  }

  /**
   * Assigns the provided UrlType array value to the `additionalInfo` property.
   *
   * @param element - the `additionalInfo` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAdditionalInfoElement(element: UrlType[] | undefined): this {
    if (isDefinedList<UrlType>(element)) {
      const optErrMsg = `Invalid VirtualServiceDetail.additionalInfo; Provided value array has an element that is not an instance of UrlType.`;
      assertFhirTypeList<UrlType>(element, UrlType, optErrMsg);
      this.additionalInfo = element;
    } else {
      this.additionalInfo = undefined;
    }
    return this;
  }

  /**
   * Add the provided UrlType value to the `additionalInfo` array property.
   *
   * @param element - the `additionalInfo` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addAdditionalInfoElement(element: UrlType | undefined): this {
    if (isDefined<UrlType>(element)) {
      const optErrMsg = `Invalid VirtualServiceDetail.additionalInfo; Provided element is not an instance of UrlType.`;
      assertFhirType<UrlType>(element, UrlType, optErrMsg);
      this.initAdditionalInfo();
      this.additionalInfo?.push(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `additionalInfo` property exists and has a value; `false` otherwise
   */
  public hasAdditionalInfoElement(): boolean {
    return isDefinedList<UrlType>(this.additionalInfo) && this.additionalInfo.some((item: UrlType) => !item.isEmpty());
  }

  /**
   * @returns the `additionalInfo` property value as a fhirUrl array
   */
  public getAdditionalInfo(): fhirUrl[] {
    this.initAdditionalInfo();
    const additionalInfoValues = [] as fhirUrl[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.additionalInfo!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        additionalInfoValues.push(value);
      }
    }
    return additionalInfoValues;
  }

  /**
   * Assigns the provided primitive value array to the `additionalInfo` property.
   *
   * @param value - the `additionalInfo` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAdditionalInfo(value: fhirUrl[] | undefined): this {
    if (isDefinedList<fhirUrl>(value)) {
      const additionalInfoElements = [] as UrlType[];
      for (const additionalInfoValue of value) {
        const optErrMsg = `Invalid VirtualServiceDetail.additionalInfo array item (${String(additionalInfoValue)})`;
        const element = new UrlType(parseFhirPrimitiveData(additionalInfoValue, fhirUrlSchema, optErrMsg));
        additionalInfoElements.push(element);
      }
      this.additionalInfo = additionalInfoElements;
    } else {
      this.additionalInfo = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the `additionalInfo` array property.
   *
   * @param value - the `additionalInfo` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addAdditionalInfo(value: fhirUrl | undefined): this {
    if (isDefined<fhirUrl>(value)) {
      const optErrMsg = `Invalid VirtualServiceDetail.additionalInfo array item (${String(value)})`;
      const element = new UrlType(parseFhirPrimitiveData(value, fhirUrlSchema, optErrMsg));
      this.initAdditionalInfo();
      this.addAdditionalInfoElement(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `additionalInfo` property exists and has a value; `false` otherwise
   */
  public hasAdditionalInfo(): boolean {
    return this.hasAdditionalInfoElement();
  }

  /**
   * Initialize the `additionalInfo` property
   */
  private initAdditionalInfo(): void {
    if (!this.hasAdditionalInfo()) {
      this.additionalInfo = [] as UrlType[];
    }
  }

  /**
   * @returns the `maxParticipants` property value as a PositiveIntType object if defined; else an empty PositiveIntType object
   */
  public getMaxParticipantsElement(): PositiveIntType {
    return this.maxParticipants ?? new PositiveIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `maxParticipants` property.
   *
   * @param element - the `maxParticipants` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMaxParticipantsElement(element: PositiveIntType | undefined): this {
    if (isDefined<PositiveIntType>(element)) {
      const optErrMsg = `Invalid VirtualServiceDetail.maxParticipants; Provided element is not an instance of PositiveIntType.`;
      assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
      this.maxParticipants = element;
    } else {
      this.maxParticipants = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `maxParticipants` property exists and has a value; `false` otherwise
   */
  public hasMaxParticipantsElement(): boolean {
    return isDefined<PositiveIntType>(this.maxParticipants) && !this.maxParticipants.isEmpty();
  }

  /**
   * @returns the `maxParticipants` property value as a fhirPositiveInt if defined; else undefined
   */
  public getMaxParticipants(): fhirPositiveInt | undefined {
    return this.maxParticipants?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `maxParticipants` property.
   *
   * @param value - the `maxParticipants` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMaxParticipants(value: fhirPositiveInt | undefined): this {
    if (isDefined<fhirPositiveInt>(value)) {
      const optErrMsg = `Invalid VirtualServiceDetail.maxParticipants (${String(value)})`;
      this.maxParticipants = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    } else {
      this.maxParticipants = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `maxParticipants` property exists and has a value; `false` otherwise
   */
  public hasMaxParticipants(): boolean {
    return this.hasMaxParticipantsElement();
  }

  /**
   * @returns the `sessionKey` property value as a StringType object if defined; else an empty StringType object
   */
  public getSessionKeyElement(): StringType {
    return this.sessionKey ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `sessionKey` property.
   *
   * @param element - the `sessionKey` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSessionKeyElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid VirtualServiceDetail.sessionKey; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.sessionKey = element;
    } else {
      this.sessionKey = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `sessionKey` property exists and has a value; `false` otherwise
   */
  public hasSessionKeyElement(): boolean {
    return isDefined<StringType>(this.sessionKey) && !this.sessionKey.isEmpty();
  }

  /**
   * @returns the `sessionKey` property value as a fhirString if defined; else undefined
   */
  public getSessionKey(): fhirString | undefined {
    return this.sessionKey?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `sessionKey` property.
   *
   * @param value - the `sessionKey` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSessionKey(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid VirtualServiceDetail.sessionKey (${String(value)})`;
      this.sessionKey = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.sessionKey = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `sessionKey` property exists and has a value; `false` otherwise
   */
  public hasSessionKey(): boolean {
    return this.hasSessionKeyElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'VirtualServiceDetail';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.channelType,
      this.address,
      this.additionalInfo,
      this.maxParticipants,
      this.sessionKey,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): VirtualServiceDetail {
    const dest = new VirtualServiceDetail();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: VirtualServiceDetail): void {
    super.copyValues(dest);
    dest.channelType = this.channelType?.copy();
    dest.address = this.address?.copy() as IDataType;
    const additionalInfoList = copyListValues<UrlType>(this.additionalInfo);
    dest.additionalInfo = additionalInfoList.length === 0 ? undefined : additionalInfoList;
    dest.maxParticipants = this.maxParticipants?.copy();
    dest.sessionKey = this.sessionKey?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasChannelType()) {
      setFhirComplexJson(this.getChannelType(), 'channelType', jsonObj);
    }

    if (this.hasAddress()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getAddress()!, 'address', jsonObj);
    }

    if (this.hasAdditionalInfo()) {
      setFhirPrimitiveListJson(this.getAdditionalInfoElement(), 'additionalInfo', jsonObj);
    }

    if (this.hasMaxParticipantsElement()) {
      setFhirPrimitiveJson<fhirPositiveInt>(this.getMaxParticipantsElement(), 'maxParticipants', jsonObj);
    }

    if (this.hasSessionKeyElement()) {
      setFhirPrimitiveJson<fhirString>(this.getSessionKeyElement(), 'sessionKey', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * PARSABLE_DATATYPE_MAP
 *
 * @remarks
 * Map of all parsable DataTypes where the key is the name of the DataType and the value is its ParsableDataType<DataType> class.
 *
 * @internal
 */
export const PARSABLE_DATATYPE_MAP = new Map<string, ParsableDataType<DataType>>();
PARSABLE_DATATYPE_MAP.set('Address', Address);
PARSABLE_DATATYPE_MAP.set('Age', Age);
PARSABLE_DATATYPE_MAP.set('Annotation', Annotation);
PARSABLE_DATATYPE_MAP.set('Attachment', Attachment);
PARSABLE_DATATYPE_MAP.set('Availability', Availability);
PARSABLE_DATATYPE_MAP.set('CodeableConcept', CodeableConcept);
PARSABLE_DATATYPE_MAP.set('CodeableReference', CodeableReference);
PARSABLE_DATATYPE_MAP.set('Coding', Coding);
PARSABLE_DATATYPE_MAP.set('ContactDetail', ContactDetail);
PARSABLE_DATATYPE_MAP.set('ContactPoint', ContactPoint);
PARSABLE_DATATYPE_MAP.set('Contributor', Contributor);
PARSABLE_DATATYPE_MAP.set('Count', Count);
PARSABLE_DATATYPE_MAP.set('DataRequirement', DataRequirement);
PARSABLE_DATATYPE_MAP.set('Distance', Distance);
PARSABLE_DATATYPE_MAP.set('Dosage', Dosage);
PARSABLE_DATATYPE_MAP.set('Duration', Duration);
PARSABLE_DATATYPE_MAP.set('ElementDefinition', ElementDefinition);
PARSABLE_DATATYPE_MAP.set('Expression', Expression);
PARSABLE_DATATYPE_MAP.set('ExtendedContactDetail', ExtendedContactDetail);
PARSABLE_DATATYPE_MAP.set('HumanName', HumanName);
PARSABLE_DATATYPE_MAP.set('Identifier', Identifier);
PARSABLE_DATATYPE_MAP.set('MarketingStatus', MarketingStatus);
PARSABLE_DATATYPE_MAP.set('Meta', Meta);
PARSABLE_DATATYPE_MAP.set('MonetaryComponent', MonetaryComponent);
PARSABLE_DATATYPE_MAP.set('Money', Money);
PARSABLE_DATATYPE_MAP.set('Narrative', Narrative);
PARSABLE_DATATYPE_MAP.set('ParameterDefinition', ParameterDefinition);
PARSABLE_DATATYPE_MAP.set('Period', Period);
PARSABLE_DATATYPE_MAP.set('ProductShelfLife', ProductShelfLife);
PARSABLE_DATATYPE_MAP.set('Quantity', Quantity);
PARSABLE_DATATYPE_MAP.set('Range', Range);
PARSABLE_DATATYPE_MAP.set('Ratio', Ratio);
PARSABLE_DATATYPE_MAP.set('RatioRange', RatioRange);
PARSABLE_DATATYPE_MAP.set('Reference', Reference);
PARSABLE_DATATYPE_MAP.set('RelatedArtifact', RelatedArtifact);
PARSABLE_DATATYPE_MAP.set('SampledData', SampledData);
PARSABLE_DATATYPE_MAP.set('Signature', Signature);
PARSABLE_DATATYPE_MAP.set('Timing', Timing);
PARSABLE_DATATYPE_MAP.set('TriggerDefinition', TriggerDefinition);
PARSABLE_DATATYPE_MAP.set('UsageContext', UsageContext);
PARSABLE_DATATYPE_MAP.set('VirtualServiceDetail', VirtualServiceDetail);
