/*
 * Copyright (c) 2025. Joe Paquette
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/**
 * This file is generated from a FHIR StructureDefinitions for FHIR complex datatypes.
 * DO NOT make any modifications!
 *
 * Combined FHIR Complex Datatypes Module
 *
 * For questions, suggestions, or bugs, please open an issue at [GitHub ts-fhir-datamodels/issues](https://github.com/Paqrat76/ts-fhir-datamodels/issues).
 *
 * @packageDocumentation
 */

import { strict as assert } from 'node:assert';
import {
  BackboneType,
  Base64BinaryType,
  BooleanType,
  CanonicalType,
  ChoiceDataTypes,
  ChoiceDataTypesMeta,
  CodeType,
  CodeableConcept,
  Coding,
  DataType,
  DateTimeType,
  DateType,
  DecimalType,
  EnumCodeType,
  Extension as CoreExtension,
  FhirError,
  FhirParser,
  IBackboneType,
  IDataType,
  INSTANCE_EMPTY_ERROR_MSG,
  IdType,
  Identifier,
  InstantType,
  IntegerType,
  InvalidTypeError,
  JSON,
  MarkdownType,
  Meta,
  Narrative,
  OidType,
  ParsableDataType,
  Period,
  PositiveIntType,
  PrimitiveType,
  PrimitiveTypeJson,
  REQUIRED_PROPERTIES_DO_NOT_EXIST,
  REQUIRED_PROPERTIES_REQD_IN_JSON,
  Reference,
  ReferenceTargets,
  StringType,
  TimeType,
  UnsignedIntType,
  UriType,
  UrlType,
  UuidType,
  assertEnumCodeType,
  assertEnumCodeTypeList,
  assertFhirType,
  assertFhirTypeList,
  assertIsDefined,
  assertIsDefinedList,
  constructorCodeValueAsEnumCodeType,
  copyListValues,
  fhirBase64Binary,
  fhirBase64BinarySchema,
  fhirBoolean,
  fhirBooleanSchema,
  fhirCanonical,
  fhirCanonicalSchema,
  fhirCode,
  fhirCodeSchema,
  fhirDateTime,
  fhirDateTimeSchema,
  fhirDecimal,
  fhirDecimalSchema,
  fhirId,
  fhirIdSchema,
  fhirInstant,
  fhirInstantSchema,
  fhirInteger,
  fhirIntegerSchema,
  fhirMarkdown,
  fhirMarkdownSchema,
  fhirPositiveInt,
  fhirPositiveIntSchema,
  fhirString,
  fhirStringSchema,
  fhirTime,
  fhirTimeSchema,
  fhirUnsignedInt,
  fhirUnsignedIntSchema,
  fhirUri,
  fhirUriSchema,
  fhirUrl,
  fhirUrlSchema,
  getPrimitiveTypeJson,
  getPrimitiveTypeListJson,
  isDefined,
  isDefinedList,
  isElementEmpty,
  isEmpty,
  parseFhirPrimitiveData,
  setFhirComplexJson,
  setFhirComplexListJson,
  setFhirPrimitiveJson,
  setFhirPrimitiveListJson,
  setPolymorphicValueJson,
} from '@paq-ts-fhir/fhir-core';
import { AddressTypeEnum } from '../code-systems/AddressTypeEnum';
import { AddressUseEnum } from '../code-systems/AddressUseEnum';
import { BindingStrengthEnum } from '../code-systems/BindingStrengthEnum';
import { ConstraintSeverityEnum } from '../code-systems/ConstraintSeverityEnum';
import { ContactPointSystemEnum } from '../code-systems/ContactPointSystemEnum';
import { ContactPointUseEnum } from '../code-systems/ContactPointUseEnum';
import { ContributorTypeEnum } from '../code-systems/ContributorTypeEnum';
import { DaysOfWeekEnum } from '../code-systems/DaysOfWeekEnum';
import { DiscriminatorTypeEnum } from '../code-systems/DiscriminatorTypeEnum';
import { NameUseEnum } from '../code-systems/NameUseEnum';
import { OperationParameterUseEnum } from '../code-systems/OperationParameterUseEnum';
import { PARSABLE_RESOURCE_MAP } from '../resources/parsable-resource-map';
import { PropertyRepresentationEnum } from '../code-systems/PropertyRepresentationEnum';
import { QuantityComparatorEnum } from '../code-systems/QuantityComparatorEnum';
import { ReferenceVersionRulesEnum } from '../code-systems/ReferenceVersionRulesEnum';
import { RelatedArtifactTypeEnum } from '../code-systems/RelatedArtifactTypeEnum';
import { ResourceAggregationModeEnum } from '../code-systems/ResourceAggregationModeEnum';
import { ResourceSlicingRulesEnum } from '../code-systems/ResourceSlicingRulesEnum';
import { SortDirectionEnum } from '../code-systems/SortDirectionEnum';
import { TriggerTypeEnum } from '../code-systems/TriggerTypeEnum';

// eslint-disable-next-line @typescript-eslint/no-explicit-any -- Symbol.metadata polyfill secret sauce for decorator metadata
(Symbol.metadata as any) ??= Symbol('Symbol.metadata');

// The fhir-core complex types must be exported from @paq-ts-fhir/fhir-core rather than using the generated complex types.
export { CodeableConcept, Coding, Identifier, Meta, Narrative, Period, Reference } from '@paq-ts-fhir/fhir-core';


/**
 * Address Class
 *
 * @remarks
 * Base StructureDefinition for Address Type: An address expressed using postal conventions (as opposed to GPS or other location definition formats).  This data type may be used to convey addresses for use in delivering mail as well as for visiting locations which might not be valid for mail delivery.  There are a variety of postal address formats defined around the world.
 *
 * Need to be able to record postal addresses, along with notes about their use.
 *
 * **FHIR Specification**
 * - **Short:** An address expressed using postal conventions (as opposed to GPS or other location definition formats)
 * - **Definition:** An address expressed using postal conventions (as opposed to GPS or other location definition formats).  This data type may be used to convey addresses for use in delivering mail as well as for visiting locations which might not be valid for mail delivery.  There are a variety of postal address formats defined around the world.
 * - **Comment:** Note: address is intended to describe postal addresses for administrative purposes, not to describe absolute geographical coordinates.  Postal addresses are often used as proxies for physical locations (also see the [Location](https://hl7.org/fhir/location.html#) resource).
 * - **FHIR Version:** 4.3.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR Address](http://hl7.org/fhir/StructureDefinition/Address)
 */
export class Address extends DataType implements IDataType {
  constructor() {
    super();

    this.addressUseEnum = new AddressUseEnum();
    this.addressTypeEnum = new AddressTypeEnum();
  }

  /**
   * Parse the provided `Address` JSON to instantiate the Address data model.
   *
   * @param sourceJson - JSON representing FHIR `Address`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to Address
   * @returns Address data model or undefined for `Address`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Address | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Address';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new Address();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'use';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setUseElement(datatype);
    }

    fieldName = 'type';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setTypeElement(datatype);
    }

    fieldName = 'text';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setTextElement(datatype);
    }

    fieldName = 'line';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: StringType | undefined = fhirParser.parseStringType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addLineElement(datatype);
        }
      });
    }

    fieldName = 'city';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setCityElement(datatype);
    }

    fieldName = 'district';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setDistrictElement(datatype);
    }

    fieldName = 'state';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setStateElement(datatype);
    }

    fieldName = 'postalCode';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setPostalCodeElement(datatype);
    }

    fieldName = 'country';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setCountryElement(datatype);
    }

    fieldName = 'period';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Period | undefined = Period.parse(classJsonObj[fieldName]!, sourceField);
      instance.setPeriod(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: AddressUse
   *
   * @see {@link AddressUseEnum }
   */
  private readonly addressUseEnum: AddressUseEnum;

  /**
   * Address.use Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** home | work | temp | old | billing - purpose of this address
   * - **Definition:** The purpose of this address.
   * - **Comment:** Applications can assume that an address is current unless it explicitly says that it is temporary or old.
   * - **Requirements:** Allows an appropriate address to be chosen from a list of many.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** true
   * - **isModifierReason:** This is labeled as &quot;Is Modifier&quot; because applications should not mistake a temporary or old address etc.for a current/permanent one
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link AddressUseEnum }
   */
  private use?: EnumCodeType | undefined;

  /**
   * FHIR CodeSystem: AddressType
   *
   * @see {@link AddressTypeEnum }
   */
  private readonly addressTypeEnum: AddressTypeEnum;

  /**
   * Address.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** postal | physical | both
   * - **Definition:** Distinguishes between physical addresses (those you can visit) and mailing addresses (e.g. PO Boxes and care-of addresses). Most addresses are both.
   * - **Comment:** The definition of Address states that "address is intended to describe postal addresses, not physical locations". However, many applications track whether an address has a dual purpose of being a location that can be visited as well as being a valid delivery destination, and Postal addresses are often used as proxies for physical locations (also see the [Location](https://hl7.org/fhir/location.html#) resource).
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link AddressTypeEnum }
   */
  private type_?: EnumCodeType | undefined;

  /**
   * Address.text Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Text representation of the address
   * - **Definition:** Specifies the entire address as it should be displayed e.g. on a postal label. This may be provided instead of or as well as the specific parts.
   * - **Comment:** Can provide both a text representation and parts. Applications updating an address SHALL ensure that  when both text and parts are present,  no content is included in the text that isn\'t found in a part.
   * - **Requirements:** A renderable, unencoded form.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private text?: StringType | undefined;

  /**
   * Address.line Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Street name, number, direction & P.O. Box etc.
   * - **Definition:** This component contains the house number, apartment number, street name, street direction,  P.O. Box number, delivery hints, and similar address information.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private line?: StringType[] | undefined;

  /**
   * Address.city Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Name of city, town etc.
   * - **Definition:** The name of the city, town, suburb, village or other community or delivery center.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private city?: StringType | undefined;

  /**
   * Address.district Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** District name (aka county)
   * - **Definition:** The name of the administrative area (county).
   * - **Comment:** District is sometimes known as county, but in some regions \'county\' is used in place of city (municipality), so county name should be conveyed in city instead.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private district?: StringType | undefined;

  /**
   * Address.state Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Sub-unit of country (abbreviations ok)
   * - **Definition:** Sub-unit of a country with limited sovereignty in a federally organized country. A code may be used if codes are in common use (e.g. US 2 letter state codes).
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private state?: StringType | undefined;

  /**
   * Address.postalCode Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Postal code for area
   * - **Definition:** A postal code designating a region defined by the postal service.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private postalCode?: StringType | undefined;

  /**
   * Address.country Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Country (e.g. can be ISO 3166 2 or 3 letter code)
   * - **Definition:** Country - a nation as commonly understood or generally accepted.
   * - **Comment:** ISO 3166 3 letter codes can be used in place of a human readable country name.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private country?: StringType | undefined;

  /**
   * Address.period Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Time period when address was/is in use
   * - **Definition:** Time period when address was/is in use.
   * - **Requirements:** Allows addresses to be placed in historical context.
   * - **FHIR Type:** `Period`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private period?: Period | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `use` property value as a EnumCodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link AddressUseEnum }
   */
  public getUseEnumType(): EnumCodeType | undefined {
    return this.use;
  }

  /**
   * Assigns the provided EnumCodeType value to the `use` property.
   *
   * @param enumType - the `use` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code values
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link AddressUseEnum }
   */
  public setUseEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid Address.use';
      assertEnumCodeType<AddressUseEnum>(enumType, AddressUseEnum, errMsgPrefix);
      this.use = enumType;
    } else {
      this.use = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `use` property exists and has a value; `false` otherwise
   */
  public hasUseEnumType(): boolean {
    return isDefined<EnumCodeType>(this.use) && !this.use.isEmpty() && this.use.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the `use` property value as a CodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link AddressUseEnum }
   */
  public getUseElement(): CodeType | undefined {
    if (this.use === undefined) {
      return undefined;
    }
    return this.use as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the `use` property.
   *
   * @param element - the `use` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link AddressUseEnum }
   */
  public setUseElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid Address.use; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.use = new EnumCodeType(element, this.addressUseEnum);
    } else {
      this.use = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `use` property exists and has a value; `false` otherwise
   */
  public hasUseElement(): boolean {
    return this.hasUseEnumType();
  }

  /**
   * @returns the `use` property value as a fhirCode if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link AddressUseEnum }
   */
  public getUse(): fhirCode | undefined {
    if (this.use === undefined) {
      return undefined;
    }
    return this.use.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the `use` property.
   *
   * @param value - the `use` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link AddressUseEnum }
   */
  public setUse(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid Address.use; Provided value is not an instance of fhirCode.`;
      this.use = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.addressUseEnum);
    } else {
      this.use = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `use` property exists and has a value; `false` otherwise
   */
  public hasUse(): boolean {
    return this.hasUseEnumType();
  }

  /**
   * @returns the `type_` property value as a EnumCodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link AddressTypeEnum }
   */
  public getTypeEnumType(): EnumCodeType | undefined {
    return this.type_;
  }

  /**
   * Assigns the provided EnumCodeType value to the `type_` property.
   *
   * @param enumType - the `type_` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code values
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link AddressTypeEnum }
   */
  public setTypeEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid Address.type';
      assertEnumCodeType<AddressTypeEnum>(enumType, AddressTypeEnum, errMsgPrefix);
      this.type_ = enumType;
    } else {
      this.type_ = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasTypeEnumType(): boolean {
    return isDefined<EnumCodeType>(this.type_) && !this.type_.isEmpty() && this.type_.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the `type_` property value as a CodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link AddressTypeEnum }
   */
  public getTypeElement(): CodeType | undefined {
    if (this.type_ === undefined) {
      return undefined;
    }
    return this.type_ as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the `type_` property.
   *
   * @param element - the `type_` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link AddressTypeEnum }
   */
  public setTypeElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid Address.type; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.type_ = new EnumCodeType(element, this.addressTypeEnum);
    } else {
      this.type_ = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasTypeElement(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the `type_` property value as a fhirCode if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link AddressTypeEnum }
   */
  public getType(): fhirCode | undefined {
    if (this.type_ === undefined) {
      return undefined;
    }
    return this.type_.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the `type_` property.
   *
   * @param value - the `type_` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link AddressTypeEnum }
   */
  public setType(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid Address.type; Provided value is not an instance of fhirCode.`;
      this.type_ = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.addressTypeEnum);
    } else {
      this.type_ = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasType(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the `text` property value as a StringType object if defined; else an empty StringType object
   */
  public getTextElement(): StringType {
    return this.text ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `text` property.
   *
   * @param element - the `text` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTextElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid Address.text; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.text = element;
    } else {
      this.text = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `text` property exists and has a value; `false` otherwise
   */
  public hasTextElement(): boolean {
    return isDefined<StringType>(this.text) && !this.text.isEmpty();
  }

  /**
   * @returns the `text` property value as a fhirString if defined; else undefined
   */
  public getText(): fhirString | undefined {
    return this.text?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `text` property.
   *
   * @param value - the `text` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setText(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid Address.text (${String(value)})`;
      this.text = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.text = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `text` property exists and has a value; `false` otherwise
   */
  public hasText(): boolean {
    return this.hasTextElement();
  }

  /**
   * @returns the `line` property value as a StringType array
   */
  public getLineElement(): StringType[] {
    return this.line ?? ([] as StringType[]);
  }

  /**
   * Assigns the provided StringType array value to the `line` property.
   *
   * @param element - the `line` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLineElement(element: StringType[] | undefined): this {
    if (isDefinedList<StringType>(element)) {
      const optErrMsg = `Invalid Address.line; Provided value array has an element that is not an instance of StringType.`;
      assertFhirTypeList<StringType>(element, StringType, optErrMsg);
      this.line = element;
    } else {
      this.line = undefined;
    }
    return this;
  }

  /**
   * Add the provided StringType value to the `line` array property.
   *
   * @param element - the `line` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addLineElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid Address.line; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.initLine();
      this.line?.push(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `line` property exists and has a value; `false` otherwise
   */
  public hasLineElement(): boolean {
    return isDefinedList<StringType>(this.line) && this.line.some((item: StringType) => !item.isEmpty());
  }

  /**
   * @returns the `line` property value as a fhirString array
   */
  public getLine(): fhirString[] {
    this.initLine();
    const lineValues = [] as fhirString[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.line!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        lineValues.push(value);
      }
    }
    return lineValues;
  }

  /**
   * Assigns the provided primitive value array to the `line` property.
   *
   * @param value - the `line` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLine(value: fhirString[] | undefined): this {
    if (isDefinedList<fhirString>(value)) {
      const lineElements = [] as StringType[];
      for (const lineValue of value) {
        const optErrMsg = `Invalid Address.line array item (${String(lineValue)})`;
        const element = new StringType(parseFhirPrimitiveData(lineValue, fhirStringSchema, optErrMsg));
        lineElements.push(element);
      }
      this.line = lineElements;
    } else {
      this.line = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the `line` array property.
   *
   * @param value - the `line` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addLine(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid Address.line array item (${String(value)})`;
      const element = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
      this.initLine();
      this.addLineElement(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `line` property exists and has a value; `false` otherwise
   */
  public hasLine(): boolean {
    return this.hasLineElement();
  }

  /**
   * Initialize the `line` property
   */
  private initLine(): void {
    if (!this.hasLine()) {
      this.line = [] as StringType[];
    }
  }

  /**
   * @returns the `city` property value as a StringType object if defined; else an empty StringType object
   */
  public getCityElement(): StringType {
    return this.city ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `city` property.
   *
   * @param element - the `city` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCityElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid Address.city; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.city = element;
    } else {
      this.city = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `city` property exists and has a value; `false` otherwise
   */
  public hasCityElement(): boolean {
    return isDefined<StringType>(this.city) && !this.city.isEmpty();
  }

  /**
   * @returns the `city` property value as a fhirString if defined; else undefined
   */
  public getCity(): fhirString | undefined {
    return this.city?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `city` property.
   *
   * @param value - the `city` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCity(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid Address.city (${String(value)})`;
      this.city = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.city = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `city` property exists and has a value; `false` otherwise
   */
  public hasCity(): boolean {
    return this.hasCityElement();
  }

  /**
   * @returns the `district` property value as a StringType object if defined; else an empty StringType object
   */
  public getDistrictElement(): StringType {
    return this.district ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `district` property.
   *
   * @param element - the `district` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDistrictElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid Address.district; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.district = element;
    } else {
      this.district = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `district` property exists and has a value; `false` otherwise
   */
  public hasDistrictElement(): boolean {
    return isDefined<StringType>(this.district) && !this.district.isEmpty();
  }

  /**
   * @returns the `district` property value as a fhirString if defined; else undefined
   */
  public getDistrict(): fhirString | undefined {
    return this.district?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `district` property.
   *
   * @param value - the `district` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDistrict(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid Address.district (${String(value)})`;
      this.district = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.district = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `district` property exists and has a value; `false` otherwise
   */
  public hasDistrict(): boolean {
    return this.hasDistrictElement();
  }

  /**
   * @returns the `state` property value as a StringType object if defined; else an empty StringType object
   */
  public getStateElement(): StringType {
    return this.state ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `state` property.
   *
   * @param element - the `state` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setStateElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid Address.state; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.state = element;
    } else {
      this.state = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `state` property exists and has a value; `false` otherwise
   */
  public hasStateElement(): boolean {
    return isDefined<StringType>(this.state) && !this.state.isEmpty();
  }

  /**
   * @returns the `state` property value as a fhirString if defined; else undefined
   */
  public getState(): fhirString | undefined {
    return this.state?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `state` property.
   *
   * @param value - the `state` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setState(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid Address.state (${String(value)})`;
      this.state = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.state = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `state` property exists and has a value; `false` otherwise
   */
  public hasState(): boolean {
    return this.hasStateElement();
  }

  /**
   * @returns the `postalCode` property value as a StringType object if defined; else an empty StringType object
   */
  public getPostalCodeElement(): StringType {
    return this.postalCode ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `postalCode` property.
   *
   * @param element - the `postalCode` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPostalCodeElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid Address.postalCode; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.postalCode = element;
    } else {
      this.postalCode = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `postalCode` property exists and has a value; `false` otherwise
   */
  public hasPostalCodeElement(): boolean {
    return isDefined<StringType>(this.postalCode) && !this.postalCode.isEmpty();
  }

  /**
   * @returns the `postalCode` property value as a fhirString if defined; else undefined
   */
  public getPostalCode(): fhirString | undefined {
    return this.postalCode?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `postalCode` property.
   *
   * @param value - the `postalCode` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPostalCode(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid Address.postalCode (${String(value)})`;
      this.postalCode = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.postalCode = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `postalCode` property exists and has a value; `false` otherwise
   */
  public hasPostalCode(): boolean {
    return this.hasPostalCodeElement();
  }

  /**
   * @returns the `country` property value as a StringType object if defined; else an empty StringType object
   */
  public getCountryElement(): StringType {
    return this.country ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `country` property.
   *
   * @param element - the `country` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCountryElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid Address.country; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.country = element;
    } else {
      this.country = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `country` property exists and has a value; `false` otherwise
   */
  public hasCountryElement(): boolean {
    return isDefined<StringType>(this.country) && !this.country.isEmpty();
  }

  /**
   * @returns the `country` property value as a fhirString if defined; else undefined
   */
  public getCountry(): fhirString | undefined {
    return this.country?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `country` property.
   *
   * @param value - the `country` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCountry(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid Address.country (${String(value)})`;
      this.country = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.country = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `country` property exists and has a value; `false` otherwise
   */
  public hasCountry(): boolean {
    return this.hasCountryElement();
  }

  /**
   * @returns the `period` property value as a Period object if defined; else an empty Period object
   */
  public getPeriod(): Period {
    return this.period ?? new Period();
  }

  /**
   * Assigns the provided Period object value to the `period` property.
   *
   * @param value - the `period` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setPeriod(value: Period | undefined): this {
    if (isDefined<Period>(value)) {
      const optErrMsg = `Invalid Address.period; Provided element is not an instance of Period.`;
      assertFhirType<Period>(value, Period, optErrMsg);
      this.period = value;
    } else {
      this.period = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `period` property exists and has a value; `false` otherwise
   */
  public hasPeriod(): boolean {
    return isDefined<Period>(this.period) && !this.period.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Address';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.use,
      this.type_,
      this.text,
      this.line,
      this.city,
      this.district,
      this.state,
      this.postalCode,
      this.country,
      this.period,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Address {
    const dest = new Address();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Address): void {
    super.copyValues(dest);
    dest.use = this.use?.copy();
    dest.type_ = this.type_?.copy();
    dest.text = this.text?.copy();
    const lineList = copyListValues<StringType>(this.line);
    dest.line = lineList.length === 0 ? undefined : lineList;
    dest.city = this.city?.copy();
    dest.district = this.district?.copy();
    dest.state = this.state?.copy();
    dest.postalCode = this.postalCode?.copy();
    dest.country = this.country?.copy();
    dest.period = this.period?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasUseElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getUseElement()!, 'use', jsonObj);
    }

    if (this.hasTypeElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getTypeElement()!, 'type', jsonObj);
    }

    if (this.hasTextElement()) {
      setFhirPrimitiveJson<fhirString>(this.getTextElement(), 'text', jsonObj);
    }

    if (this.hasLine()) {
      setFhirPrimitiveListJson(this.getLineElement(), 'line', jsonObj);
    }

    if (this.hasCityElement()) {
      setFhirPrimitiveJson<fhirString>(this.getCityElement(), 'city', jsonObj);
    }

    if (this.hasDistrictElement()) {
      setFhirPrimitiveJson<fhirString>(this.getDistrictElement(), 'district', jsonObj);
    }

    if (this.hasStateElement()) {
      setFhirPrimitiveJson<fhirString>(this.getStateElement(), 'state', jsonObj);
    }

    if (this.hasPostalCodeElement()) {
      setFhirPrimitiveJson<fhirString>(this.getPostalCodeElement(), 'postalCode', jsonObj);
    }

    if (this.hasCountryElement()) {
      setFhirPrimitiveJson<fhirString>(this.getCountryElement(), 'country', jsonObj);
    }

    if (this.hasPeriod()) {
      setFhirComplexJson(this.getPeriod(), 'period', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * Age Class
 *
 * @remarks
 * Base StructureDefinition for Age Type: A duration of time during which an organism (or a process) has existed.
 *
 * **FHIR Specification**
 * - **Short:** A duration of time during which an organism (or a process) has existed
 * - **Definition:** A duration of time during which an organism (or a process) has existed.
 * - **Comment:** The context of use may frequently define what kind of quantity this is and therefore what kind of units can be used. The context of use may also restrict the values for the comparator.
 * - **FHIR Version:** 4.3.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR Age](http://hl7.org/fhir/StructureDefinition/Age)
 */
export class Age extends DataType implements IDataType {
  constructor() {
    super();

    this.quantityComparatorEnum = new QuantityComparatorEnum();
  }

  /**
   * Parse the provided `Age` JSON to instantiate the Age data model.
   *
   * @param sourceJson - JSON representing FHIR `Age`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to Age
   * @returns Age data model or undefined for `Age`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Age | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Age';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new Age();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'value';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setValueElement(datatype);
    }

    fieldName = 'comparator';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setComparatorElement(datatype);
    }

    fieldName = 'unit';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setUnitElement(datatype);
    }

    fieldName = 'system';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = fhirParser.parseUriType(dtJson, dtSiblingJson);
      instance.setSystemElement(datatype);
    }

    fieldName = 'code';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setCodeElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Age.value Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Numerical value (with implicit precision)
   * - **Definition:** The value of the measured amount. The value includes an implicit precision in the presentation of the value.
   * - **Comment:** The implicit precision in the value should always be honored. Monetary values have their own rules for handling precision (refer to standard accounting text books).
   * - **Requirements:** Precision is handled implicitly in almost all cases of measurement.
   * - **FHIR Type:** `decimal`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private value?: DecimalType | undefined;

  /**
   * FHIR CodeSystem: QuantityComparator
   *
   * @see {@link QuantityComparatorEnum }
   */
  private readonly quantityComparatorEnum: QuantityComparatorEnum;

  /**
   * Age.comparator Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** < | <= | >= | > - how to understand the value
   * - **Definition:** How the value should be understood and represented - whether the actual value is greater or less than the stated value due to measurement issues; e.g. if the comparator is "<" , then the real value is < stated value.
   * - **Requirements:** Need a framework for handling measures where the value is <5ug/L or >400mg/L due to the limitations of measuring methodology.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** true
   * - **isModifierReason:** This is labeled as &quot;Is Modifier&quot; because the comparator modifies the interpretation of the value significantly. If there is no comparator, then there is no modification of the value
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  private comparator?: EnumCodeType | undefined;

  /**
   * Age.unit Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Unit representation
   * - **Definition:** A human-readable form of the unit.
   * - **Requirements:** There are many representations for units of measure and in many contexts, particular representations are fixed and required. I.e. mcg for micrograms.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private unit?: StringType | undefined;

  /**
   * Age.system Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** System that defines coded unit form
   * - **Definition:** The identification of the system that provides the coded form of the unit.
   * - **Requirements:** Need to know the system that defines the coded form of the unit.
   * - **FHIR Type:** `uri`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private system?: UriType | undefined;

  /**
   * Age.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Coded form of the unit
   * - **Definition:** A computer processable form of the unit in some unit representation system.
   * - **Comment:** The preferred system is UCUM, but SNOMED CT can also be used (for customary units) or ISO 4217 for currency.  The context of use may additionally require a code from a particular system.
   * - **Requirements:** Need a computable form of the unit that is fixed across all forms. UCUM provides this for quantities, but SNOMED CT provides many units of interest.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code?: CodeType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `value` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getValueElement(): DecimalType {
    return this.value ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `value` property.
   *
   * @param element - the `value` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValueElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = `Invalid Age.value; Provided element is not an instance of DecimalType.`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.value = element;
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `value` property exists and has a value; `false` otherwise
   */
  public hasValueElement(): boolean {
    return isDefined<DecimalType>(this.value) && !this.value.isEmpty();
  }

  /**
   * @returns the `value` property value as a fhirDecimal if defined; else undefined
   */
  public getValue(): fhirDecimal | undefined {
    return this.value?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `value` property.
   *
   * @param value - the `value` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValue(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = `Invalid Age.value (${String(value)})`;
      this.value = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `value` property exists and has a value; `false` otherwise
   */
  public hasValue(): boolean {
    return this.hasValueElement();
  }

  /**
   * @returns the `comparator` property value as a EnumCodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public getComparatorEnumType(): EnumCodeType | undefined {
    return this.comparator;
  }

  /**
   * Assigns the provided EnumCodeType value to the `comparator` property.
   *
   * @param enumType - the `comparator` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code values
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public setComparatorEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid Age.comparator';
      assertEnumCodeType<QuantityComparatorEnum>(enumType, QuantityComparatorEnum, errMsgPrefix);
      this.comparator = enumType;
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `comparator` property exists and has a value; `false` otherwise
   */
  public hasComparatorEnumType(): boolean {
    return isDefined<EnumCodeType>(this.comparator) && !this.comparator.isEmpty() && this.comparator.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the `comparator` property value as a CodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public getComparatorElement(): CodeType | undefined {
    if (this.comparator === undefined) {
      return undefined;
    }
    return this.comparator as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the `comparator` property.
   *
   * @param element - the `comparator` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public setComparatorElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid Age.comparator; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.comparator = new EnumCodeType(element, this.quantityComparatorEnum);
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `comparator` property exists and has a value; `false` otherwise
   */
  public hasComparatorElement(): boolean {
    return this.hasComparatorEnumType();
  }

  /**
   * @returns the `comparator` property value as a fhirCode if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public getComparator(): fhirCode | undefined {
    if (this.comparator === undefined) {
      return undefined;
    }
    return this.comparator.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the `comparator` property.
   *
   * @param value - the `comparator` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public setComparator(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid Age.comparator; Provided value is not an instance of fhirCode.`;
      this.comparator = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.quantityComparatorEnum);
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `comparator` property exists and has a value; `false` otherwise
   */
  public hasComparator(): boolean {
    return this.hasComparatorEnumType();
  }

  /**
   * @returns the `unit` property value as a StringType object if defined; else an empty StringType object
   */
  public getUnitElement(): StringType {
    return this.unit ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `unit` property.
   *
   * @param element - the `unit` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUnitElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid Age.unit; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.unit = element;
    } else {
      this.unit = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `unit` property exists and has a value; `false` otherwise
   */
  public hasUnitElement(): boolean {
    return isDefined<StringType>(this.unit) && !this.unit.isEmpty();
  }

  /**
   * @returns the `unit` property value as a fhirString if defined; else undefined
   */
  public getUnit(): fhirString | undefined {
    return this.unit?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `unit` property.
   *
   * @param value - the `unit` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUnit(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid Age.unit (${String(value)})`;
      this.unit = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.unit = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `unit` property exists and has a value; `false` otherwise
   */
  public hasUnit(): boolean {
    return this.hasUnitElement();
  }

  /**
   * @returns the `system` property value as a UriType object if defined; else an empty UriType object
   */
  public getSystemElement(): UriType {
    return this.system ?? new UriType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `system` property.
   *
   * @param element - the `system` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSystemElement(element: UriType | undefined): this {
    if (isDefined<UriType>(element)) {
      const optErrMsg = `Invalid Age.system; Provided element is not an instance of UriType.`;
      assertFhirType<UriType>(element, UriType, optErrMsg);
      this.system = element;
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `system` property exists and has a value; `false` otherwise
   */
  public hasSystemElement(): boolean {
    return isDefined<UriType>(this.system) && !this.system.isEmpty();
  }

  /**
   * @returns the `system` property value as a fhirUri if defined; else undefined
   */
  public getSystem(): fhirUri | undefined {
    return this.system?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `system` property.
   *
   * @param value - the `system` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSystem(value: fhirUri | undefined): this {
    if (isDefined<fhirUri>(value)) {
      const optErrMsg = `Invalid Age.system (${String(value)})`;
      this.system = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `system` property exists and has a value; `false` otherwise
   */
  public hasSystem(): boolean {
    return this.hasSystemElement();
  }

  /**
   * @returns the `code` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getCodeElement(): CodeType {
    return this.code ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `code` property.
   *
   * @param element - the `code` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCodeElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid Age.code; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.code = element;
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `code` property exists and has a value; `false` otherwise
   */
  public hasCodeElement(): boolean {
    return isDefined<CodeType>(this.code) && !this.code.isEmpty();
  }

  /**
   * @returns the `code` property value as a fhirCode if defined; else undefined
   */
  public getCode(): fhirCode | undefined {
    return this.code?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `code` property.
   *
   * @param value - the `code` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCode(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid Age.code (${String(value)})`;
      this.code = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `code` property exists and has a value; `false` otherwise
   */
  public hasCode(): boolean {
    return this.hasCodeElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Age';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.value,
      this.comparator,
      this.unit,
      this.system,
      this.code,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Age {
    const dest = new Age();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Age): void {
    super.copyValues(dest);
    dest.value = this.value?.copy();
    dest.comparator = this.comparator?.copy();
    dest.unit = this.unit?.copy();
    dest.system = this.system?.copy();
    dest.code = this.code?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasValueElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getValueElement(), 'value', jsonObj);
    }

    if (this.hasComparatorElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getComparatorElement()!, 'comparator', jsonObj);
    }

    if (this.hasUnitElement()) {
      setFhirPrimitiveJson<fhirString>(this.getUnitElement(), 'unit', jsonObj);
    }

    if (this.hasSystemElement()) {
      setFhirPrimitiveJson<fhirUri>(this.getSystemElement(), 'system', jsonObj);
    }

    if (this.hasCodeElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getCodeElement(), 'code', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * Annotation Class
 *
 * @remarks
 * Base StructureDefinition for Annotation Type: A  text note which also  contains information about who made the statement and when.
 *
 * **FHIR Specification**
 * - **Short:** Text node with attribution
 * - **Definition:** A  text note which also  contains information about who made the statement and when.
 * - **Comment:** For systems that do not have structured annotations, they can simply communicate a single annotation with no author or time.  This element may need to be included in narrative because of the potential for modifying information.  *Annotations SHOULD NOT* be used to communicate "modifying" information that could be computable. (This is a SHOULD because enforcing user behavior is nearly impossible).
 * - **FHIR Version:** 4.3.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR Annotation](http://hl7.org/fhir/StructureDefinition/Annotation)
 */
export class Annotation extends DataType implements IDataType {
  constructor(text: MarkdownType | fhirMarkdown | null = null) {
    super();

    this.text = null;
    if (isDefined<MarkdownType | fhirMarkdown>(text)) {
      if (text instanceof PrimitiveType) {
        this.setTextElement(text);
      } else {
        this.setText(text);
      }
    }
  }

  /**
   * Parse the provided `Annotation` JSON to instantiate the Annotation data model.
   *
   * @param sourceJson - JSON representing FHIR `Annotation`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to Annotation
   * @returns Annotation data model or undefined for `Annotation`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Annotation | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Annotation';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new Annotation();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const classMetadata: DecoratorMetadataObject | null = Annotation[Symbol.metadata];
    const errorMessage = `DecoratorMetadataObject does not exist for Annotation`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    const missingReqdProperties: string[] = [];

    fieldName = 'author[x]';
    sourceField = `${optSourceValue}.${fieldName}`;
    const author: IDataType | undefined = fhirParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setAuthor(author);

    fieldName = 'time';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DateTimeType | undefined = fhirParser.parseDateTimeType(dtJson, dtSiblingJson);
      instance.setTimeElement(datatype);
    }

    fieldName = 'text';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: MarkdownType | undefined = fhirParser.parseMarkdownType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setTextElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_REQD_IN_JSON} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Annotation.author[x] Element
   *
   * @decorator `@ChoiceDataTypesMeta('Annotation.author[x]', ['Reference','string',]`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Individual responsible for the annotation
   * - **Definition:** The individual responsible for making the annotation.
   * - **Comment:** Organization is used when there\'s no need for specific attribution as to who made the comment.
   * - **FHIR Types:**
   *     'Reference',
   *     'string',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('Annotation.author[x]',[
    'Reference',
    'string',
  ])
  private author?: IDataType | undefined;

  /**
   * Annotation.time Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** When the annotation was made
   * - **Definition:** Indicates when this particular annotation was made.
   * - **FHIR Type:** `dateTime`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private time?: DateTimeType | undefined;

  /**
   * Annotation.text Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The annotation  - text content (as markdown)
   * - **Definition:** The text of the annotation in markdown format.
   * - **FHIR Type:** `markdown`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private text: MarkdownType | null;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `author` property value as a DataType object if defined; else undefined
   */
  public getAuthor(): IDataType | undefined {
    return this.author;
  }

  /**
   * Assigns the provided DataType object value to the `author` property.
   *
   * @decorator `@ChoiceDataTypes('Annotation.author[x]')`
   *
   * @param value - the `author` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  @ChoiceDataTypes('Annotation.author[x]')
  public setAuthor(value: IDataType | undefined): this {
    if (isDefined<IDataType>(value)) {
      // assertFhirType<IDataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.author = value;
    } else {
      this.author = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `author` property exists and has a value; `false` otherwise
   */
  public hasAuthor(): boolean {
    return isDefined<IDataType>(this.author) && !this.author.isEmpty();
  }

  // *** NOTE ***
  // Following choice datatype-specific "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the `author` property value as a Reference object if defined; else undefined
   */
  public getAuthorReference(): Reference | undefined {
    if (!isDefined<IDataType | undefined>(this.author)) {
      return undefined;
    }
    if (!(this.author instanceof Reference)) {
      throw new InvalidTypeError(
        `DataType mismatch for Annotation.author[x]: Expected Reference but encountered ${this.author.fhirType()}`,
      );
    }
    return this.author;
  }

  /**
   * @returns `true` if the `author` property exists as a Reference and has a value; `false` otherwise
   */
  public hasAuthorReference(): boolean {
    return this.hasAuthor() && this.author instanceof Reference;
  }

  /**
   * @returns the `author` property value as a StringType object if defined; else undefined
   */
  public getAuthorStringType(): StringType | undefined {
    if (!isDefined<IDataType | undefined>(this.author)) {
      return undefined;
    }
    if (!(this.author instanceof StringType)) {
      throw new InvalidTypeError(
        `DataType mismatch for Annotation.author[x]: Expected StringType but encountered ${this.author.fhirType()}`,
      );
    }
    return this.author;
  }

  /**
   * @returns `true` if the `author` property exists as a StringType and has a value; `false` otherwise
   */
  public hasAuthorStringType(): boolean {
    return this.hasAuthor() && this.author instanceof StringType;
  }

  // End of choice datatype-specific "get"/"has" methods

  /**
   * @returns the `time` property value as a DateTimeType object if defined; else an empty DateTimeType object
   */
  public getTimeElement(): DateTimeType {
    return this.time ?? new DateTimeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `time` property.
   *
   * @param element - the `time` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTimeElement(element: DateTimeType | undefined): this {
    if (isDefined<DateTimeType>(element)) {
      const optErrMsg = `Invalid Annotation.time; Provided element is not an instance of DateTimeType.`;
      assertFhirType<DateTimeType>(element, DateTimeType, optErrMsg);
      this.time = element;
    } else {
      this.time = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `time` property exists and has a value; `false` otherwise
   */
  public hasTimeElement(): boolean {
    return isDefined<DateTimeType>(this.time) && !this.time.isEmpty();
  }

  /**
   * @returns the `time` property value as a fhirDateTime if defined; else undefined
   */
  public getTime(): fhirDateTime | undefined {
    return this.time?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `time` property.
   *
   * @param value - the `time` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTime(value: fhirDateTime | undefined): this {
    if (isDefined<fhirDateTime>(value)) {
      const optErrMsg = `Invalid Annotation.time (${String(value)})`;
      this.time = new DateTimeType(parseFhirPrimitiveData(value, fhirDateTimeSchema, optErrMsg));
    } else {
      this.time = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `time` property exists and has a value; `false` otherwise
   */
  public hasTime(): boolean {
    return this.hasTimeElement();
  }

  /**
   * @returns the `text` property value as a MarkdownType object if defined; else null
   */
  public getTextElement(): MarkdownType | null {
    return this.text;
  }

  /**
   * Assigns the provided PrimitiveType value to the `text` property.
   *
   * @param element - the `text` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTextElement(element: MarkdownType): this {
    assertIsDefined<MarkdownType>(element, `Annotation.text is required`);
    const optErrMsg = `Invalid Annotation.text; Provided value is not an instance of MarkdownType.`;
    assertFhirType<MarkdownType>(element, MarkdownType, optErrMsg);
    this.text = element;
    return this;
  }

  /**
   * @returns `true` if the `text` property exists and has a value; `false` otherwise
   */
  public hasTextElement(): boolean {
    return isDefined<MarkdownType>(this.text) && !this.text.isEmpty();
  }

  /**
   * @returns the `text` property value as a fhirMarkdown if defined; else null
   */
  public getText(): fhirMarkdown | null {
    if (this.text?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.text.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the `text` property.
   *
   * @param value - the `text` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setText(value: fhirMarkdown): this {
    assertIsDefined<fhirMarkdown>(value, `Annotation.text is required`);
    const optErrMsg = `Invalid Annotation.text (${String(value)})`;
    this.text = new MarkdownType(parseFhirPrimitiveData(value, fhirMarkdownSchema, optErrMsg));
    return this;
  }

  /**
   * @returns `true` if the `text` property exists and has a value; `false` otherwise
   */
  public hasText(): boolean {
    return this.hasTextElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Annotation';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.author,
      this.time,
      this.text,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Annotation {
    const dest = new Annotation();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Annotation): void {
    super.copyValues(dest);
    dest.author = this.author?.copy() as IDataType;
    dest.time = this.time?.copy();
    dest.text = this.text ? this.text.copy() : null;
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasAuthor()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getAuthor()!, 'author', jsonObj);
    }

    if (this.hasTimeElement()) {
      setFhirPrimitiveJson<fhirDateTime>(this.getTimeElement(), 'time', jsonObj);
    }

    if (this.hasTextElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirMarkdown>(this.getTextElement()!, 'text', jsonObj);
    } else {
      missingReqdProperties.push(`Annotation.text`);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_DO_NOT_EXIST} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

/**
 * Attachment Class
 *
 * @remarks
 * Base StructureDefinition for Attachment Type: For referring to data content defined in other formats.
 *
 * Many models need to include data defined in other specifications that is complex and opaque to the healthcare model. This includes documents, media recordings, structured data, etc.
 *
 * **FHIR Specification**
 * - **Short:** Content in a format defined elsewhere
 * - **Definition:** For referring to data content defined in other formats.
 * - **Comment:** When providing a summary view (for example with Observation.value[x]) Attachment should be represented with a brief display text such as "Signed Procedure Consent".
 * - **FHIR Version:** 4.3.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR Attachment](http://hl7.org/fhir/StructureDefinition/Attachment)
 */
export class Attachment extends DataType implements IDataType {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided `Attachment` JSON to instantiate the Attachment data model.
   *
   * @param sourceJson - JSON representing FHIR `Attachment`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to Attachment
   * @returns Attachment data model or undefined for `Attachment`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Attachment | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Attachment';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new Attachment();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'contentType';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setContentTypeElement(datatype);
    }

    fieldName = 'language';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setLanguageElement(datatype);
    }

    fieldName = 'data';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: Base64BinaryType | undefined = fhirParser.parseBase64BinaryType(dtJson, dtSiblingJson);
      instance.setDataElement(datatype);
    }

    fieldName = 'url';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UrlType | undefined = fhirParser.parseUrlType(dtJson, dtSiblingJson);
      instance.setUrlElement(datatype);
    }

    fieldName = 'size';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UnsignedIntType | undefined = fhirParser.parseUnsignedIntType(dtJson, dtSiblingJson);
      instance.setSizeElement(datatype);
    }

    fieldName = 'hash';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: Base64BinaryType | undefined = fhirParser.parseBase64BinaryType(dtJson, dtSiblingJson);
      instance.setHashElement(datatype);
    }

    fieldName = 'title';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setTitleElement(datatype);
    }

    fieldName = 'creation';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DateTimeType | undefined = fhirParser.parseDateTimeType(dtJson, dtSiblingJson);
      instance.setCreationElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Attachment.contentType Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Mime type of the content, with charset etc.
   * - **Definition:** Identifies the type of the data in the attachment and allows a method to be chosen to interpret or render the data. Includes mime type parameters such as charset where appropriate.
   * - **Requirements:** Processors of the data need to be able to know how to interpret the data.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private contentType?: CodeType | undefined;

  /**
   * Attachment.language Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Human language of the content (BCP-47)
   * - **Definition:** The human language of the content. The value can be any valid value according to BCP 47.
   * - **Requirements:** Users need to be able to choose between the languages in a set of attachments.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private language?: CodeType | undefined;

  /**
   * Attachment.data Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Data inline, base64ed
   * - **Definition:** The actual data of the attachment - a sequence of bytes, base64 encoded.
   * - **Comment:** The base64-encoded data SHALL be expressed in the same character set as the base resource XML or JSON.
   * - **Requirements:** The data needs to able to be transmitted inline.
   * - **FHIR Type:** `base64Binary`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private data?: Base64BinaryType | undefined;

  /**
   * Attachment.url Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Uri where the data can be found
   * - **Definition:** A location where the data can be accessed.
   * - **Comment:** If both data and url are provided, the url SHALL point to the same content as the data contains. Urls may be relative references or may reference transient locations such as a wrapping envelope using cid: though this has ramifications for using signatures. Relative URLs are interpreted relative to the service url, like a resource reference, rather than relative to the resource itself. If a URL is provided, it SHALL resolve to actual data.
   * - **Requirements:** The data needs to be transmitted by reference.
   * - **FHIR Type:** `url`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private url?: UrlType | undefined;

  /**
   * Attachment.size Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Number of bytes of content (if url provided)
   * - **Definition:** The number of bytes of data that make up this attachment (before base64 encoding, if that is done).
   * - **Comment:** The number of bytes is redundant if the data is provided as a base64binary, but is useful if the data is provided as a url reference.
   * - **Requirements:** Representing the size allows applications to determine whether they should fetch the content automatically in advance, or refuse to fetch it at all.
   * - **FHIR Type:** `unsignedInt`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private size?: UnsignedIntType | undefined;

  /**
   * Attachment.hash Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Hash of the data (sha-1, base64ed)
   * - **Definition:** The calculated hash of the data using SHA-1. Represented using base64.
   * - **Comment:** The hash is calculated on the data prior to base64 encoding, if the data is based64 encoded. The hash is not intended to support digital signatures. Where protection against malicious threats a digital signature should be considered, see [Provenance.signature](https://hl7.org/fhir/provenance-definitions.html#Provenance.signature) for mechanism to protect a resource with a digital signature.
   * - **Requirements:** Included so that applications can verify that the contents of a location have not changed due to technical failures (e.g., storage rot, transport glitch, incorrect version).
   * - **FHIR Type:** `base64Binary`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private hash?: Base64BinaryType | undefined;

  /**
   * Attachment.title Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Label to display in place of the data
   * - **Definition:** A label or set of text to display in place of the data.
   * - **Requirements:** Applications need a label to display to a human user in place of the actual data if the data cannot be rendered or perceived by the viewer.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private title?: StringType | undefined;

  /**
   * Attachment.creation Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Date attachment was first created
   * - **Definition:** The date that the attachment was first created.
   * - **Requirements:** This is often tracked as an integrity issue for use of the attachment.
   * - **FHIR Type:** `dateTime`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private creation?: DateTimeType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `contentType` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getContentTypeElement(): CodeType {
    return this.contentType ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `contentType` property.
   *
   * @param element - the `contentType` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setContentTypeElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid Attachment.contentType; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.contentType = element;
    } else {
      this.contentType = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `contentType` property exists and has a value; `false` otherwise
   */
  public hasContentTypeElement(): boolean {
    return isDefined<CodeType>(this.contentType) && !this.contentType.isEmpty();
  }

  /**
   * @returns the `contentType` property value as a fhirCode if defined; else undefined
   */
  public getContentType(): fhirCode | undefined {
    return this.contentType?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `contentType` property.
   *
   * @param value - the `contentType` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setContentType(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid Attachment.contentType (${String(value)})`;
      this.contentType = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.contentType = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `contentType` property exists and has a value; `false` otherwise
   */
  public hasContentType(): boolean {
    return this.hasContentTypeElement();
  }

  /**
   * @returns the `language` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getLanguageElement(): CodeType {
    return this.language ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `language` property.
   *
   * @param element - the `language` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLanguageElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid Attachment.language; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.language = element;
    } else {
      this.language = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `language` property exists and has a value; `false` otherwise
   */
  public hasLanguageElement(): boolean {
    return isDefined<CodeType>(this.language) && !this.language.isEmpty();
  }

  /**
   * @returns the `language` property value as a fhirCode if defined; else undefined
   */
  public getLanguage(): fhirCode | undefined {
    return this.language?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `language` property.
   *
   * @param value - the `language` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLanguage(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid Attachment.language (${String(value)})`;
      this.language = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.language = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `language` property exists and has a value; `false` otherwise
   */
  public hasLanguage(): boolean {
    return this.hasLanguageElement();
  }

  /**
   * @returns the `data` property value as a Base64BinaryType object if defined; else an empty Base64BinaryType object
   */
  public getDataElement(): Base64BinaryType {
    return this.data ?? new Base64BinaryType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `data` property.
   *
   * @param element - the `data` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDataElement(element: Base64BinaryType | undefined): this {
    if (isDefined<Base64BinaryType>(element)) {
      const optErrMsg = `Invalid Attachment.data; Provided element is not an instance of Base64BinaryType.`;
      assertFhirType<Base64BinaryType>(element, Base64BinaryType, optErrMsg);
      this.data = element;
    } else {
      this.data = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `data` property exists and has a value; `false` otherwise
   */
  public hasDataElement(): boolean {
    return isDefined<Base64BinaryType>(this.data) && !this.data.isEmpty();
  }

  /**
   * @returns the `data` property value as a fhirBase64Binary if defined; else undefined
   */
  public getData(): fhirBase64Binary | undefined {
    return this.data?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `data` property.
   *
   * @param value - the `data` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setData(value: fhirBase64Binary | undefined): this {
    if (isDefined<fhirBase64Binary>(value)) {
      const optErrMsg = `Invalid Attachment.data (${String(value)})`;
      this.data = new Base64BinaryType(parseFhirPrimitiveData(value, fhirBase64BinarySchema, optErrMsg));
    } else {
      this.data = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `data` property exists and has a value; `false` otherwise
   */
  public hasData(): boolean {
    return this.hasDataElement();
  }

  /**
   * @returns the `url` property value as a UrlType object if defined; else an empty UrlType object
   */
  public getUrlElement(): UrlType {
    return this.url ?? new UrlType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `url` property.
   *
   * @param element - the `url` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUrlElement(element: UrlType | undefined): this {
    if (isDefined<UrlType>(element)) {
      const optErrMsg = `Invalid Attachment.url; Provided element is not an instance of UrlType.`;
      assertFhirType<UrlType>(element, UrlType, optErrMsg);
      this.url = element;
    } else {
      this.url = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `url` property exists and has a value; `false` otherwise
   */
  public hasUrlElement(): boolean {
    return isDefined<UrlType>(this.url) && !this.url.isEmpty();
  }

  /**
   * @returns the `url` property value as a fhirUrl if defined; else undefined
   */
  public getUrl(): fhirUrl | undefined {
    return this.url?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `url` property.
   *
   * @param value - the `url` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUrl(value: fhirUrl | undefined): this {
    if (isDefined<fhirUrl>(value)) {
      const optErrMsg = `Invalid Attachment.url (${String(value)})`;
      this.url = new UrlType(parseFhirPrimitiveData(value, fhirUrlSchema, optErrMsg));
    } else {
      this.url = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `url` property exists and has a value; `false` otherwise
   */
  public hasUrl(): boolean {
    return this.hasUrlElement();
  }

  /**
   * @returns the `size` property value as a UnsignedIntType object if defined; else an empty UnsignedIntType object
   */
  public getSizeElement(): UnsignedIntType {
    return this.size ?? new UnsignedIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `size` property.
   *
   * @param element - the `size` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSizeElement(element: UnsignedIntType | undefined): this {
    if (isDefined<UnsignedIntType>(element)) {
      const optErrMsg = `Invalid Attachment.size; Provided element is not an instance of UnsignedIntType.`;
      assertFhirType<UnsignedIntType>(element, UnsignedIntType, optErrMsg);
      this.size = element;
    } else {
      this.size = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `size` property exists and has a value; `false` otherwise
   */
  public hasSizeElement(): boolean {
    return isDefined<UnsignedIntType>(this.size) && !this.size.isEmpty();
  }

  /**
   * @returns the `size` property value as a fhirUnsignedInt if defined; else undefined
   */
  public getSize(): fhirUnsignedInt | undefined {
    return this.size?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `size` property.
   *
   * @param value - the `size` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSize(value: fhirUnsignedInt | undefined): this {
    if (isDefined<fhirUnsignedInt>(value)) {
      const optErrMsg = `Invalid Attachment.size (${String(value)})`;
      this.size = new UnsignedIntType(parseFhirPrimitiveData(value, fhirUnsignedIntSchema, optErrMsg));
    } else {
      this.size = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `size` property exists and has a value; `false` otherwise
   */
  public hasSize(): boolean {
    return this.hasSizeElement();
  }

  /**
   * @returns the `hash` property value as a Base64BinaryType object if defined; else an empty Base64BinaryType object
   */
  public getHashElement(): Base64BinaryType {
    return this.hash ?? new Base64BinaryType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `hash` property.
   *
   * @param element - the `hash` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setHashElement(element: Base64BinaryType | undefined): this {
    if (isDefined<Base64BinaryType>(element)) {
      const optErrMsg = `Invalid Attachment.hash; Provided element is not an instance of Base64BinaryType.`;
      assertFhirType<Base64BinaryType>(element, Base64BinaryType, optErrMsg);
      this.hash = element;
    } else {
      this.hash = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `hash` property exists and has a value; `false` otherwise
   */
  public hasHashElement(): boolean {
    return isDefined<Base64BinaryType>(this.hash) && !this.hash.isEmpty();
  }

  /**
   * @returns the `hash` property value as a fhirBase64Binary if defined; else undefined
   */
  public getHash(): fhirBase64Binary | undefined {
    return this.hash?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `hash` property.
   *
   * @param value - the `hash` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setHash(value: fhirBase64Binary | undefined): this {
    if (isDefined<fhirBase64Binary>(value)) {
      const optErrMsg = `Invalid Attachment.hash (${String(value)})`;
      this.hash = new Base64BinaryType(parseFhirPrimitiveData(value, fhirBase64BinarySchema, optErrMsg));
    } else {
      this.hash = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `hash` property exists and has a value; `false` otherwise
   */
  public hasHash(): boolean {
    return this.hasHashElement();
  }

  /**
   * @returns the `title` property value as a StringType object if defined; else an empty StringType object
   */
  public getTitleElement(): StringType {
    return this.title ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `title` property.
   *
   * @param element - the `title` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTitleElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid Attachment.title; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.title = element;
    } else {
      this.title = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `title` property exists and has a value; `false` otherwise
   */
  public hasTitleElement(): boolean {
    return isDefined<StringType>(this.title) && !this.title.isEmpty();
  }

  /**
   * @returns the `title` property value as a fhirString if defined; else undefined
   */
  public getTitle(): fhirString | undefined {
    return this.title?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `title` property.
   *
   * @param value - the `title` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTitle(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid Attachment.title (${String(value)})`;
      this.title = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.title = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `title` property exists and has a value; `false` otherwise
   */
  public hasTitle(): boolean {
    return this.hasTitleElement();
  }

  /**
   * @returns the `creation` property value as a DateTimeType object if defined; else an empty DateTimeType object
   */
  public getCreationElement(): DateTimeType {
    return this.creation ?? new DateTimeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `creation` property.
   *
   * @param element - the `creation` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCreationElement(element: DateTimeType | undefined): this {
    if (isDefined<DateTimeType>(element)) {
      const optErrMsg = `Invalid Attachment.creation; Provided element is not an instance of DateTimeType.`;
      assertFhirType<DateTimeType>(element, DateTimeType, optErrMsg);
      this.creation = element;
    } else {
      this.creation = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `creation` property exists and has a value; `false` otherwise
   */
  public hasCreationElement(): boolean {
    return isDefined<DateTimeType>(this.creation) && !this.creation.isEmpty();
  }

  /**
   * @returns the `creation` property value as a fhirDateTime if defined; else undefined
   */
  public getCreation(): fhirDateTime | undefined {
    return this.creation?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `creation` property.
   *
   * @param value - the `creation` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCreation(value: fhirDateTime | undefined): this {
    if (isDefined<fhirDateTime>(value)) {
      const optErrMsg = `Invalid Attachment.creation (${String(value)})`;
      this.creation = new DateTimeType(parseFhirPrimitiveData(value, fhirDateTimeSchema, optErrMsg));
    } else {
      this.creation = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `creation` property exists and has a value; `false` otherwise
   */
  public hasCreation(): boolean {
    return this.hasCreationElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Attachment';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.contentType,
      this.language,
      this.data,
      this.url,
      this.size,
      this.hash,
      this.title,
      this.creation,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Attachment {
    const dest = new Attachment();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Attachment): void {
    super.copyValues(dest);
    dest.contentType = this.contentType?.copy();
    dest.language = this.language?.copy();
    dest.data = this.data?.copy();
    dest.url = this.url?.copy();
    dest.size = this.size?.copy();
    dest.hash = this.hash?.copy();
    dest.title = this.title?.copy();
    dest.creation = this.creation?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasContentTypeElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getContentTypeElement(), 'contentType', jsonObj);
    }

    if (this.hasLanguageElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getLanguageElement(), 'language', jsonObj);
    }

    if (this.hasDataElement()) {
      setFhirPrimitiveJson<fhirBase64Binary>(this.getDataElement(), 'data', jsonObj);
    }

    if (this.hasUrlElement()) {
      setFhirPrimitiveJson<fhirUrl>(this.getUrlElement(), 'url', jsonObj);
    }

    if (this.hasSizeElement()) {
      setFhirPrimitiveJson<fhirUnsignedInt>(this.getSizeElement(), 'size', jsonObj);
    }

    if (this.hasHashElement()) {
      setFhirPrimitiveJson<fhirBase64Binary>(this.getHashElement(), 'hash', jsonObj);
    }

    if (this.hasTitleElement()) {
      setFhirPrimitiveJson<fhirString>(this.getTitleElement(), 'title', jsonObj);
    }

    if (this.hasCreationElement()) {
      setFhirPrimitiveJson<fhirDateTime>(this.getCreationElement(), 'creation', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * CodeableReference Class
 *
 * @remarks
 * Base StructureDefinition for CodeableReference Type: A reference to a resource (by instance), or instead, a reference to a concept defined in a terminology or ontology (by class).
 *
 * This is a common pattern in record keeping - a reference may be made to a specific condition, observation, plan, or definition, or a reference may be made to a general concept defined in a knowledge base somewhere.
 *
 * **FHIR Specification**
 * - **Short:** Reference to a resource or a concept
 * - **Definition:** A reference to a resource (by instance), or instead, a reference to a concept defined in a terminology or ontology (by class).
 * - **FHIR Version:** 4.3.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR CodeableReference](http://hl7.org/fhir/StructureDefinition/CodeableReference)
 */
export class CodeableReference extends DataType implements IDataType {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided `CodeableReference` JSON to instantiate the CodeableReference data model.
   *
   * @param sourceJson - JSON representing FHIR `CodeableReference`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to CodeableReference
   * @returns CodeableReference data model or undefined for `CodeableReference`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): CodeableReference | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'CodeableReference';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new CodeableReference();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';

    fieldName = 'concept';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = CodeableConcept.parse(classJsonObj[fieldName]!, sourceField);
      instance.setConcept(datatype);
    }

    fieldName = 'reference';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = Reference.parse(classJsonObj[fieldName]!, sourceField);
      instance.setReference(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * CodeableReference.concept Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Reference to a concept (by class)
   * - **Definition:** A reference to a concept - e.g. the information is identified by its general class to the degree of precision found in the terminology.
   * - **FHIR Type:** `CodeableConcept`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private concept?: CodeableConcept | undefined;

  /**
   * CodeableReference.reference Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Reference to a resource (by instance)
   * - **Definition:** A reference to a resource the provides exact details about the information being referenced.
   * - **FHIR Type:** `Reference`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private reference?: Reference | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `concept` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getConcept(): CodeableConcept {
    return this.concept ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Concept object value to the `concept` property.
   *
   * @param value - the `concept` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setConcept(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = `Invalid CodeableReference.concept; Provided element is not an instance of CodeableConcept.`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.concept = value;
    } else {
      this.concept = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `concept` property exists and has a value; `false` otherwise
   */
  public hasConcept(): boolean {
    return isDefined<CodeableConcept>(this.concept) && !this.concept.isEmpty();
  }

  /**
   * @returns the `reference` property value as a Reference object; else an empty Reference object
   */
  public getReference(): Reference {
    return this.reference ?? new Reference();
  }

  /**
   * Assigns the provided Reference object value to the `reference` property.
   *
   * @decorator `@ReferenceTargets('CodeableReference.reference', [])`
   *
   * @param value - the `reference` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('CodeableReference.reference', [])
  public setReference(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.reference = value;
    } else {
      this.reference = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `reference` property exists and has a value; `false` otherwise
   */
  public hasReference(): boolean {
    return isDefined<Reference>(this.reference) && !this.reference.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'CodeableReference';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.concept,
      this.reference,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): CodeableReference {
    const dest = new CodeableReference();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: CodeableReference): void {
    super.copyValues(dest);
    dest.concept = this.concept?.copy();
    dest.reference = this.reference?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasConcept()) {
      setFhirComplexJson(this.getConcept(), 'concept', jsonObj);
    }

    if (this.hasReference()) {
      setFhirComplexJson(this.getReference(), 'reference', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * ContactDetail Class
 *
 * @remarks
 * Base StructureDefinition for ContactDetail Type: Specifies contact information for a person or organization.
 *
 * Need to track contact information in the same way across multiple resources.
 *
 * **FHIR Specification**
 * - **Short:** Contact information
 * - **Definition:** Specifies contact information for a person or organization.
 * - **FHIR Version:** 4.3.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR ContactDetail](http://hl7.org/fhir/StructureDefinition/ContactDetail)
 */
export class ContactDetail extends DataType implements IDataType {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided `ContactDetail` JSON to instantiate the ContactDetail data model.
   *
   * @param sourceJson - JSON representing FHIR `ContactDetail`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to ContactDetail
   * @returns ContactDetail data model or undefined for `ContactDetail`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): ContactDetail | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'ContactDetail';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new ContactDetail();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    

    fieldName = 'name';
    sourceField = `${optSourceValue}.${fieldName}`;
    const primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setNameElement(datatype);
    }

    fieldName = 'telecom';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: ContactPoint | undefined = ContactPoint.parse(dataElementJson, `${sourceField}[${String(idx)}]`);
        if (datatype !== undefined) {
          instance.addTelecom(datatype);
        }
      });
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * ContactDetail.name Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Name of an individual to contact
   * - **Definition:** The name of an individual to contact.
   * - **Comment:** If there is no named individual, the telecom information is for the organization as a whole.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private name?: StringType | undefined;

  /**
   * ContactDetail.telecom Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Contact details for individual or organization
   * - **Definition:** The contact details for the individual (if a name was provided) or the organization.
   * - **FHIR Type:** `ContactPoint`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private telecom?: ContactPoint[] | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `name` property value as a StringType object if defined; else an empty StringType object
   */
  public getNameElement(): StringType {
    return this.name ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `name` property.
   *
   * @param element - the `name` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setNameElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid ContactDetail.name; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.name = element;
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `name` property exists and has a value; `false` otherwise
   */
  public hasNameElement(): boolean {
    return isDefined<StringType>(this.name) && !this.name.isEmpty();
  }

  /**
   * @returns the `name` property value as a fhirString if defined; else undefined
   */
  public getName(): fhirString | undefined {
    return this.name?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `name` property.
   *
   * @param value - the `name` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setName(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid ContactDetail.name (${String(value)})`;
      this.name = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `name` property exists and has a value; `false` otherwise
   */
  public hasName(): boolean {
    return this.hasNameElement();
  }

  /**
   * @returns the `telecom` property value as a ContactPoint array
   */
  public getTelecom(): ContactPoint[] {
    return this.telecom ?? ([] as ContactPoint[]);
  }

  /**
   * Assigns the provided ContactPoint array value to the `telecom` property.
   *
   * @param value - the `telecom` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setTelecom(value: ContactPoint[] | undefined): this {
    if (isDefinedList<ContactPoint>(value)) {
      const optErrMsg = `Invalid ContactDetail.telecom; Provided value array has an element that is not an instance of ContactPoint.`;
      assertFhirTypeList<ContactPoint>(value, ContactPoint, optErrMsg);
      this.telecom = value;
    } else {
      this.telecom = undefined;
    }
    return this;
  }

  /**
   * Add the provided ContactPoint value to the `telecom` array property.
   *
   * @param value - the `telecom` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addTelecom(value: ContactPoint | undefined): this {
    if (isDefined<ContactPoint>(value)) {
      const optErrMsg = `Invalid ContactDetail.telecom; Provided element is not an instance of ContactPoint.`;
      assertFhirType<ContactPoint>(value, ContactPoint, optErrMsg);
      this.initTelecom();
      this.telecom?.push(value);
    }
    return this;
  }

  /**
   * @returns `true` if the `telecom` property exists and has a value; `false` otherwise
   */
  public hasTelecom(): boolean {
    return isDefinedList<ContactPoint>(this.telecom) && this.telecom.some((item: ContactPoint) => !item.isEmpty());
  }

  /**
   * Initialize the `telecom` property
   */
  private initTelecom(): void {
    if(!this.hasTelecom()) {
      this.telecom = [] as ContactPoint[];
    }
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'ContactDetail';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.name,
      this.telecom,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): ContactDetail {
    const dest = new ContactDetail();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: ContactDetail): void {
    super.copyValues(dest);
    dest.name = this.name?.copy();
    const telecomList = copyListValues<ContactPoint>(this.telecom);
    dest.telecom = telecomList.length === 0 ? undefined : telecomList;
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasNameElement()) {
      setFhirPrimitiveJson<fhirString>(this.getNameElement(), 'name', jsonObj);
    }

    if (this.hasTelecom()) {
      setFhirComplexListJson(this.getTelecom(), 'telecom', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * ContactPoint Class
 *
 * @remarks
 * Base StructureDefinition for ContactPoint Type: Details for all kinds of technology mediated contact points for a person or organization, including telephone, email, etc.
 *
 * Need to track phone, fax, mobile, sms numbers, email addresses, twitter tags, etc.
 *
 * **FHIR Specification**
 * - **Short:** Details of a Technology mediated contact point (phone, fax, email, etc.)
 * - **Definition:** Details for all kinds of technology mediated contact points for a person or organization, including telephone, email, etc.
 * - **FHIR Version:** 4.3.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR ContactPoint](http://hl7.org/fhir/StructureDefinition/ContactPoint)
 */
export class ContactPoint extends DataType implements IDataType {
  constructor() {
    super();

    this.contactPointSystemEnum = new ContactPointSystemEnum();
    this.contactPointUseEnum = new ContactPointUseEnum();
  }

  /**
   * Parse the provided `ContactPoint` JSON to instantiate the ContactPoint data model.
   *
   * @param sourceJson - JSON representing FHIR `ContactPoint`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to ContactPoint
   * @returns ContactPoint data model or undefined for `ContactPoint`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): ContactPoint | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'ContactPoint';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new ContactPoint();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'system';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setSystemElement(datatype);
    }

    fieldName = 'value';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setValueElement(datatype);
    }

    fieldName = 'use';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setUseElement(datatype);
    }

    fieldName = 'rank';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = fhirParser.parsePositiveIntType(dtJson, dtSiblingJson);
      instance.setRankElement(datatype);
    }

    fieldName = 'period';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Period | undefined = Period.parse(classJsonObj[fieldName]!, sourceField);
      instance.setPeriod(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: ContactPointSystem
   *
   * @see {@link ContactPointSystemEnum }
   */
  private readonly contactPointSystemEnum: ContactPointSystemEnum;

  /**
   * ContactPoint.system Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** phone | fax | email | pager | url | sms | other
   * - **Definition:** Telecommunications form for contact point - what communications system is required to make use of the contact.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link ContactPointSystemEnum }
   */
  private system?: EnumCodeType | undefined;

  /**
   * ContactPoint.value Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The actual contact point details
   * - **Definition:** The actual contact point details, in a form that is meaningful to the designated communication system (i.e. phone number or email address).
   * - **Comment:** Additional text data such as phone extension numbers, or notes about use of the contact are sometimes included in the value.
   * - **Requirements:** Need to support legacy numbers that are not in a tightly controlled format.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private value?: StringType | undefined;

  /**
   * FHIR CodeSystem: ContactPointUse
   *
   * @see {@link ContactPointUseEnum }
   */
  private readonly contactPointUseEnum: ContactPointUseEnum;

  /**
   * ContactPoint.use Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** home | work | temp | old | mobile - purpose of this contact point
   * - **Definition:** Identifies the purpose for the contact point.
   * - **Comment:** Applications can assume that a contact is current unless it explicitly says that it is temporary or old.
   * - **Requirements:** Need to track the way a person uses this contact, so a user can choose which is appropriate for their purpose.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** true
   * - **isModifierReason:** This is labeled as &quot;Is Modifier&quot; because applications should not mistake a temporary or old contact etc.for a current/permanent one
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link ContactPointUseEnum }
   */
  private use?: EnumCodeType | undefined;

  /**
   * ContactPoint.rank Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Specify preferred order of use (1 = highest)
   * - **Definition:** Specifies a preferred order in which to use a set of contacts. ContactPoints with lower rank values are more preferred than those with higher rank values.
   * - **Comment:** Note that rank does not necessarily follow the order in which the contacts are represented in the instance.
   * - **FHIR Type:** `positiveInt`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private rank?: PositiveIntType | undefined;

  /**
   * ContactPoint.period Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Time period when the contact point was/is in use
   * - **Definition:** Time period when the contact point was/is in use.
   * - **FHIR Type:** `Period`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private period?: Period | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `system` property value as a EnumCodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link ContactPointSystemEnum }
   */
  public getSystemEnumType(): EnumCodeType | undefined {
    return this.system;
  }

  /**
   * Assigns the provided EnumCodeType value to the `system` property.
   *
   * @param enumType - the `system` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code values
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ContactPointSystemEnum }
   */
  public setSystemEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid ContactPoint.system';
      assertEnumCodeType<ContactPointSystemEnum>(enumType, ContactPointSystemEnum, errMsgPrefix);
      this.system = enumType;
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `system` property exists and has a value; `false` otherwise
   */
  public hasSystemEnumType(): boolean {
    return isDefined<EnumCodeType>(this.system) && !this.system.isEmpty() && this.system.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the `system` property value as a CodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link ContactPointSystemEnum }
   */
  public getSystemElement(): CodeType | undefined {
    if (this.system === undefined) {
      return undefined;
    }
    return this.system as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the `system` property.
   *
   * @param element - the `system` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ContactPointSystemEnum }
   */
  public setSystemElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid ContactPoint.system; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.system = new EnumCodeType(element, this.contactPointSystemEnum);
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `system` property exists and has a value; `false` otherwise
   */
  public hasSystemElement(): boolean {
    return this.hasSystemEnumType();
  }

  /**
   * @returns the `system` property value as a fhirCode if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link ContactPointSystemEnum }
   */
  public getSystem(): fhirCode | undefined {
    if (this.system === undefined) {
      return undefined;
    }
    return this.system.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the `system` property.
   *
   * @param value - the `system` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link ContactPointSystemEnum }
   */
  public setSystem(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid ContactPoint.system; Provided value is not an instance of fhirCode.`;
      this.system = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.contactPointSystemEnum);
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `system` property exists and has a value; `false` otherwise
   */
  public hasSystem(): boolean {
    return this.hasSystemEnumType();
  }

  /**
   * @returns the `value` property value as a StringType object if defined; else an empty StringType object
   */
  public getValueElement(): StringType {
    return this.value ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `value` property.
   *
   * @param element - the `value` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValueElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid ContactPoint.value; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.value = element;
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `value` property exists and has a value; `false` otherwise
   */
  public hasValueElement(): boolean {
    return isDefined<StringType>(this.value) && !this.value.isEmpty();
  }

  /**
   * @returns the `value` property value as a fhirString if defined; else undefined
   */
  public getValue(): fhirString | undefined {
    return this.value?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `value` property.
   *
   * @param value - the `value` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValue(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid ContactPoint.value (${String(value)})`;
      this.value = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `value` property exists and has a value; `false` otherwise
   */
  public hasValue(): boolean {
    return this.hasValueElement();
  }

  /**
   * @returns the `use` property value as a EnumCodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link ContactPointUseEnum }
   */
  public getUseEnumType(): EnumCodeType | undefined {
    return this.use;
  }

  /**
   * Assigns the provided EnumCodeType value to the `use` property.
   *
   * @param enumType - the `use` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code values
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ContactPointUseEnum }
   */
  public setUseEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid ContactPoint.use';
      assertEnumCodeType<ContactPointUseEnum>(enumType, ContactPointUseEnum, errMsgPrefix);
      this.use = enumType;
    } else {
      this.use = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `use` property exists and has a value; `false` otherwise
   */
  public hasUseEnumType(): boolean {
    return isDefined<EnumCodeType>(this.use) && !this.use.isEmpty() && this.use.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the `use` property value as a CodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link ContactPointUseEnum }
   */
  public getUseElement(): CodeType | undefined {
    if (this.use === undefined) {
      return undefined;
    }
    return this.use as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the `use` property.
   *
   * @param element - the `use` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ContactPointUseEnum }
   */
  public setUseElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid ContactPoint.use; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.use = new EnumCodeType(element, this.contactPointUseEnum);
    } else {
      this.use = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `use` property exists and has a value; `false` otherwise
   */
  public hasUseElement(): boolean {
    return this.hasUseEnumType();
  }

  /**
   * @returns the `use` property value as a fhirCode if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link ContactPointUseEnum }
   */
  public getUse(): fhirCode | undefined {
    if (this.use === undefined) {
      return undefined;
    }
    return this.use.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the `use` property.
   *
   * @param value - the `use` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link ContactPointUseEnum }
   */
  public setUse(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid ContactPoint.use; Provided value is not an instance of fhirCode.`;
      this.use = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.contactPointUseEnum);
    } else {
      this.use = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `use` property exists and has a value; `false` otherwise
   */
  public hasUse(): boolean {
    return this.hasUseEnumType();
  }

  /**
   * @returns the `rank` property value as a PositiveIntType object if defined; else an empty PositiveIntType object
   */
  public getRankElement(): PositiveIntType {
    return this.rank ?? new PositiveIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `rank` property.
   *
   * @param element - the `rank` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setRankElement(element: PositiveIntType | undefined): this {
    if (isDefined<PositiveIntType>(element)) {
      const optErrMsg = `Invalid ContactPoint.rank; Provided element is not an instance of PositiveIntType.`;
      assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
      this.rank = element;
    } else {
      this.rank = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `rank` property exists and has a value; `false` otherwise
   */
  public hasRankElement(): boolean {
    return isDefined<PositiveIntType>(this.rank) && !this.rank.isEmpty();
  }

  /**
   * @returns the `rank` property value as a fhirPositiveInt if defined; else undefined
   */
  public getRank(): fhirPositiveInt | undefined {
    return this.rank?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `rank` property.
   *
   * @param value - the `rank` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setRank(value: fhirPositiveInt | undefined): this {
    if (isDefined<fhirPositiveInt>(value)) {
      const optErrMsg = `Invalid ContactPoint.rank (${String(value)})`;
      this.rank = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    } else {
      this.rank = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `rank` property exists and has a value; `false` otherwise
   */
  public hasRank(): boolean {
    return this.hasRankElement();
  }

  /**
   * @returns the `period` property value as a Period object if defined; else an empty Period object
   */
  public getPeriod(): Period {
    return this.period ?? new Period();
  }

  /**
   * Assigns the provided Period object value to the `period` property.
   *
   * @param value - the `period` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setPeriod(value: Period | undefined): this {
    if (isDefined<Period>(value)) {
      const optErrMsg = `Invalid ContactPoint.period; Provided element is not an instance of Period.`;
      assertFhirType<Period>(value, Period, optErrMsg);
      this.period = value;
    } else {
      this.period = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `period` property exists and has a value; `false` otherwise
   */
  public hasPeriod(): boolean {
    return isDefined<Period>(this.period) && !this.period.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'ContactPoint';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.system,
      this.value,
      this.use,
      this.rank,
      this.period,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): ContactPoint {
    const dest = new ContactPoint();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: ContactPoint): void {
    super.copyValues(dest);
    dest.system = this.system?.copy();
    dest.value = this.value?.copy();
    dest.use = this.use?.copy();
    dest.rank = this.rank?.copy();
    dest.period = this.period?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasSystemElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getSystemElement()!, 'system', jsonObj);
    }

    if (this.hasValueElement()) {
      setFhirPrimitiveJson<fhirString>(this.getValueElement(), 'value', jsonObj);
    }

    if (this.hasUseElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getUseElement()!, 'use', jsonObj);
    }

    if (this.hasRankElement()) {
      setFhirPrimitiveJson<fhirPositiveInt>(this.getRankElement(), 'rank', jsonObj);
    }

    if (this.hasPeriod()) {
      setFhirComplexJson(this.getPeriod(), 'period', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * Contributor Class
 *
 * @remarks
 * Base StructureDefinition for Contributor Type: A contributor to the content of a knowledge asset, including authors, editors, reviewers, and endorsers.
 *
 * Need to track contributor information in the same way across multiple resources.
 *
 * **FHIR Specification**
 * - **Short:** Contributor information
 * - **Definition:** A contributor to the content of a knowledge asset, including authors, editors, reviewers, and endorsers.
 * - **FHIR Version:** 4.3.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR Contributor](http://hl7.org/fhir/StructureDefinition/Contributor)
 */
export class Contributor extends DataType implements IDataType {
  constructor(type_: EnumCodeType | CodeType | fhirCode | null = null, name: StringType | fhirString | null = null) {
    super();

    this.contributorTypeEnum = new ContributorTypeEnum();

    this.type_ = constructorCodeValueAsEnumCodeType<ContributorTypeEnum>(
      type_,
      ContributorTypeEnum,
      this.contributorTypeEnum,
      'Contributor.type',
    );

    this.name = null;
    if (isDefined<StringType | fhirString>(name)) {
      if (name instanceof PrimitiveType) {
        this.setNameElement(name);
      } else {
        this.setName(name);
      }
    }
  }

  /**
   * Parse the provided `Contributor` JSON to instantiate the Contributor data model.
   *
   * @param sourceJson - JSON representing FHIR `Contributor`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to Contributor
   * @returns Contributor data model or undefined for `Contributor`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Contributor | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Contributor';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new Contributor();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'type';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setTypeElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'name';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setNameElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'contact';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: ContactDetail | undefined = ContactDetail.parse(dataElementJson, `${sourceField}[${String(idx)}]`);
        if (datatype !== undefined) {
          instance.addContact(datatype);
        }
      });
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_REQD_IN_JSON} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: ContributorType
   *
   * @see {@link ContributorTypeEnum }
   */
  private readonly contributorTypeEnum: ContributorTypeEnum;

  /**
   * Contributor.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** author | editor | reviewer | endorser
   * - **Definition:** The type of contributor.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link ContributorTypeEnum }
   */
  private type_: EnumCodeType | null;

  /**
   * Contributor.name Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Who contributed the content
   * - **Definition:** The name of the individual or organization responsible for the contribution.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private name: StringType | null;

  /**
   * Contributor.contact Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Contact details of the contributor
   * - **Definition:** Contact details to assist a user in finding and communicating with the contributor.
   * - **FHIR Type:** `ContactDetail`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private contact?: ContactDetail[] | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `type_` property value as a EnumCodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link ContributorTypeEnum }
   */
  public getTypeEnumType(): EnumCodeType | null {
    return this.type_;
  }

  /**
   * Assigns the provided EnumCodeType value to the `type_` property.
   *
   * @param enumType - the `type_` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ContributorTypeEnum }
   */
  public setTypeEnumType(enumType: EnumCodeType): this {
    assertIsDefined<EnumCodeType>(enumType, `Contributor.type is required`);
    const errMsgPrefix = `Invalid Contributor.type`;
    assertEnumCodeType<ContributorTypeEnum>(enumType, ContributorTypeEnum, errMsgPrefix);
    this.type_ = enumType;
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasTypeEnumType(): boolean {
    return isDefined<EnumCodeType>(this.type_) && !this.type_.isEmpty() && this.type_.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the `type_` property value as a CodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link ContributorTypeEnum }
   */
  public getTypeElement(): CodeType | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_ as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the `type_` property.
   *
   * @param element - the `type_` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ContributorTypeEnum }
   */
  public setTypeElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, `Contributor.type is required`);
    const optErrMsg = `Invalid Contributor.type; Provided value is not an instance of CodeType.`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.type_ = new EnumCodeType(element, this.contributorTypeEnum);
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasTypeElement(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the `type_` property value as a fhirCode if defined; else null
   *
   * @see CodeSystem Enumeration: {@link ContributorTypeEnum }
   */
  public getType(): fhirCode | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the `type_` property.
   *
   * @param value - the `type_` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link ContributorTypeEnum }
   */
  public setType(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, `Contributor.type is required`);
    const optErrMsg = `Invalid Contributor.type (${String(value)})`;
    this.type_ = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.contributorTypeEnum);
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasType(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the `name` property value as a StringType object if defined; else null
   */
  public getNameElement(): StringType | null {
    return this.name;
  }

  /**
   * Assigns the provided PrimitiveType value to the `name` property.
   *
   * @param element - the `name` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setNameElement(element: StringType): this {
    assertIsDefined<StringType>(element, `Contributor.name is required`);
    const optErrMsg = `Invalid Contributor.name; Provided value is not an instance of StringType.`;
    assertFhirType<StringType>(element, StringType, optErrMsg);
    this.name = element;
    return this;
  }

  /**
   * @returns `true` if the `name` property exists and has a value; `false` otherwise
   */
  public hasNameElement(): boolean {
    return isDefined<StringType>(this.name) && !this.name.isEmpty();
  }

  /**
   * @returns the `name` property value as a fhirString if defined; else null
   */
  public getName(): fhirString | null {
    if (this.name?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.name.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the `name` property.
   *
   * @param value - the `name` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setName(value: fhirString): this {
    assertIsDefined<fhirString>(value, `Contributor.name is required`);
    const optErrMsg = `Invalid Contributor.name (${String(value)})`;
    this.name = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    return this;
  }

  /**
   * @returns `true` if the `name` property exists and has a value; `false` otherwise
   */
  public hasName(): boolean {
    return this.hasNameElement();
  }

  /**
   * @returns the `contact` property value as a ContactDetail array
   */
  public getContact(): ContactDetail[] {
    return this.contact ?? ([] as ContactDetail[]);
  }

  /**
   * Assigns the provided ContactDetail array value to the `contact` property.
   *
   * @param value - the `contact` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setContact(value: ContactDetail[] | undefined): this {
    if (isDefinedList<ContactDetail>(value)) {
      const optErrMsg = `Invalid Contributor.contact; Provided value array has an element that is not an instance of ContactDetail.`;
      assertFhirTypeList<ContactDetail>(value, ContactDetail, optErrMsg);
      this.contact = value;
    } else {
      this.contact = undefined;
    }
    return this;
  }

  /**
   * Add the provided ContactDetail value to the `contact` array property.
   *
   * @param value - the `contact` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addContact(value: ContactDetail | undefined): this {
    if (isDefined<ContactDetail>(value)) {
      const optErrMsg = `Invalid Contributor.contact; Provided element is not an instance of ContactDetail.`;
      assertFhirType<ContactDetail>(value, ContactDetail, optErrMsg);
      this.initContact();
      this.contact?.push(value);
    }
    return this;
  }

  /**
   * @returns `true` if the `contact` property exists and has a value; `false` otherwise
   */
  public hasContact(): boolean {
    return isDefinedList<ContactDetail>(this.contact) && this.contact.some((item: ContactDetail) => !item.isEmpty());
  }

  /**
   * Initialize the `contact` property
   */
  private initContact(): void {
    if(!this.hasContact()) {
      this.contact = [] as ContactDetail[];
    }
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Contributor';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.type_,
      this.name,
      this.contact,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Contributor {
    const dest = new Contributor();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Contributor): void {
    super.copyValues(dest);
    dest.type_ = this.type_ ? this.type_.copy() : null;
    dest.name = this.name ? this.name.copy() : null;
    const contactList = copyListValues<ContactDetail>(this.contact);
    dest.contact = contactList.length === 0 ? undefined : contactList;
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasTypeElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getTypeElement()!, 'type', jsonObj);
    } else {
      missingReqdProperties.push(`Contributor.type`);
    }

    if (this.hasNameElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirString>(this.getNameElement()!, 'name', jsonObj);
    } else {
      missingReqdProperties.push(`Contributor.name`);
    }

    if (this.hasContact()) {
      setFhirComplexListJson(this.getContact(), 'contact', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_DO_NOT_EXIST} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

/**
 * Count Class
 *
 * @remarks
 * Base StructureDefinition for Count Type: A measured amount (or an amount that can potentially be measured). Note that measured amounts include amounts that are not precisely quantified, including amounts involving arbitrary units and floating currencies.
 *
 * Need to able to capture all sorts of measured values, even if the measured value are not precisely quantified. Values include exact measures such as 3.51g, customary units such as 3 tablets, and currencies such as $100.32USD.
 *
 * **FHIR Specification**
 * - **Short:** A measured or measurable amount
 * - **Definition:** A measured amount (or an amount that can potentially be measured). Note that measured amounts include amounts that are not precisely quantified, including amounts involving arbitrary units and floating currencies.
 * - **Comment:** The context of use may frequently define what kind of quantity this is and therefore what kind of units can be used. The context of use may also restrict the values for the comparator.
 * - **FHIR Version:** 4.3.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR Count](http://hl7.org/fhir/StructureDefinition/Count)
 */
export class Count extends DataType implements IDataType {
  constructor() {
    super();

    this.quantityComparatorEnum = new QuantityComparatorEnum();
  }

  /**
   * Parse the provided `Count` JSON to instantiate the Count data model.
   *
   * @param sourceJson - JSON representing FHIR `Count`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to Count
   * @returns Count data model or undefined for `Count`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Count | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Count';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new Count();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'value';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setValueElement(datatype);
    }

    fieldName = 'comparator';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setComparatorElement(datatype);
    }

    fieldName = 'unit';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setUnitElement(datatype);
    }

    fieldName = 'system';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = fhirParser.parseUriType(dtJson, dtSiblingJson);
      instance.setSystemElement(datatype);
    }

    fieldName = 'code';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setCodeElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Count.value Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Numerical value (with implicit precision)
   * - **Definition:** The value of the measured amount. The value includes an implicit precision in the presentation of the value.
   * - **Comment:** The implicit precision in the value should always be honored. Monetary values have their own rules for handling precision (refer to standard accounting text books).
   * - **Requirements:** Precision is handled implicitly in almost all cases of measurement.
   * - **FHIR Type:** `decimal`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private value?: DecimalType | undefined;

  /**
   * FHIR CodeSystem: QuantityComparator
   *
   * @see {@link QuantityComparatorEnum }
   */
  private readonly quantityComparatorEnum: QuantityComparatorEnum;

  /**
   * Count.comparator Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** < | <= | >= | > - how to understand the value
   * - **Definition:** How the value should be understood and represented - whether the actual value is greater or less than the stated value due to measurement issues; e.g. if the comparator is "<" , then the real value is < stated value.
   * - **Requirements:** Need a framework for handling measures where the value is <5ug/L or >400mg/L due to the limitations of measuring methodology.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** true
   * - **isModifierReason:** This is labeled as &quot;Is Modifier&quot; because the comparator modifies the interpretation of the value significantly. If there is no comparator, then there is no modification of the value
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  private comparator?: EnumCodeType | undefined;

  /**
   * Count.unit Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Unit representation
   * - **Definition:** A human-readable form of the unit.
   * - **Requirements:** There are many representations for units of measure and in many contexts, particular representations are fixed and required. I.e. mcg for micrograms.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private unit?: StringType | undefined;

  /**
   * Count.system Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** System that defines coded unit form
   * - **Definition:** The identification of the system that provides the coded form of the unit.
   * - **Requirements:** Need to know the system that defines the coded form of the unit.
   * - **FHIR Type:** `uri`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private system?: UriType | undefined;

  /**
   * Count.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Coded form of the unit
   * - **Definition:** A computer processable form of the unit in some unit representation system.
   * - **Comment:** The preferred system is UCUM, but SNOMED CT can also be used (for customary units) or ISO 4217 for currency.  The context of use may additionally require a code from a particular system.
   * - **Requirements:** Need a computable form of the unit that is fixed across all forms. UCUM provides this for quantities, but SNOMED CT provides many units of interest.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code?: CodeType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `value` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getValueElement(): DecimalType {
    return this.value ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `value` property.
   *
   * @param element - the `value` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValueElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = `Invalid Count.value; Provided element is not an instance of DecimalType.`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.value = element;
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `value` property exists and has a value; `false` otherwise
   */
  public hasValueElement(): boolean {
    return isDefined<DecimalType>(this.value) && !this.value.isEmpty();
  }

  /**
   * @returns the `value` property value as a fhirDecimal if defined; else undefined
   */
  public getValue(): fhirDecimal | undefined {
    return this.value?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `value` property.
   *
   * @param value - the `value` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValue(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = `Invalid Count.value (${String(value)})`;
      this.value = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `value` property exists and has a value; `false` otherwise
   */
  public hasValue(): boolean {
    return this.hasValueElement();
  }

  /**
   * @returns the `comparator` property value as a EnumCodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public getComparatorEnumType(): EnumCodeType | undefined {
    return this.comparator;
  }

  /**
   * Assigns the provided EnumCodeType value to the `comparator` property.
   *
   * @param enumType - the `comparator` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code values
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public setComparatorEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid Count.comparator';
      assertEnumCodeType<QuantityComparatorEnum>(enumType, QuantityComparatorEnum, errMsgPrefix);
      this.comparator = enumType;
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `comparator` property exists and has a value; `false` otherwise
   */
  public hasComparatorEnumType(): boolean {
    return isDefined<EnumCodeType>(this.comparator) && !this.comparator.isEmpty() && this.comparator.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the `comparator` property value as a CodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public getComparatorElement(): CodeType | undefined {
    if (this.comparator === undefined) {
      return undefined;
    }
    return this.comparator as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the `comparator` property.
   *
   * @param element - the `comparator` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public setComparatorElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid Count.comparator; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.comparator = new EnumCodeType(element, this.quantityComparatorEnum);
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `comparator` property exists and has a value; `false` otherwise
   */
  public hasComparatorElement(): boolean {
    return this.hasComparatorEnumType();
  }

  /**
   * @returns the `comparator` property value as a fhirCode if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public getComparator(): fhirCode | undefined {
    if (this.comparator === undefined) {
      return undefined;
    }
    return this.comparator.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the `comparator` property.
   *
   * @param value - the `comparator` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public setComparator(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid Count.comparator; Provided value is not an instance of fhirCode.`;
      this.comparator = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.quantityComparatorEnum);
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `comparator` property exists and has a value; `false` otherwise
   */
  public hasComparator(): boolean {
    return this.hasComparatorEnumType();
  }

  /**
   * @returns the `unit` property value as a StringType object if defined; else an empty StringType object
   */
  public getUnitElement(): StringType {
    return this.unit ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `unit` property.
   *
   * @param element - the `unit` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUnitElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid Count.unit; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.unit = element;
    } else {
      this.unit = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `unit` property exists and has a value; `false` otherwise
   */
  public hasUnitElement(): boolean {
    return isDefined<StringType>(this.unit) && !this.unit.isEmpty();
  }

  /**
   * @returns the `unit` property value as a fhirString if defined; else undefined
   */
  public getUnit(): fhirString | undefined {
    return this.unit?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `unit` property.
   *
   * @param value - the `unit` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUnit(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid Count.unit (${String(value)})`;
      this.unit = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.unit = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `unit` property exists and has a value; `false` otherwise
   */
  public hasUnit(): boolean {
    return this.hasUnitElement();
  }

  /**
   * @returns the `system` property value as a UriType object if defined; else an empty UriType object
   */
  public getSystemElement(): UriType {
    return this.system ?? new UriType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `system` property.
   *
   * @param element - the `system` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSystemElement(element: UriType | undefined): this {
    if (isDefined<UriType>(element)) {
      const optErrMsg = `Invalid Count.system; Provided element is not an instance of UriType.`;
      assertFhirType<UriType>(element, UriType, optErrMsg);
      this.system = element;
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `system` property exists and has a value; `false` otherwise
   */
  public hasSystemElement(): boolean {
    return isDefined<UriType>(this.system) && !this.system.isEmpty();
  }

  /**
   * @returns the `system` property value as a fhirUri if defined; else undefined
   */
  public getSystem(): fhirUri | undefined {
    return this.system?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `system` property.
   *
   * @param value - the `system` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSystem(value: fhirUri | undefined): this {
    if (isDefined<fhirUri>(value)) {
      const optErrMsg = `Invalid Count.system (${String(value)})`;
      this.system = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `system` property exists and has a value; `false` otherwise
   */
  public hasSystem(): boolean {
    return this.hasSystemElement();
  }

  /**
   * @returns the `code` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getCodeElement(): CodeType {
    return this.code ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `code` property.
   *
   * @param element - the `code` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCodeElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid Count.code; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.code = element;
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `code` property exists and has a value; `false` otherwise
   */
  public hasCodeElement(): boolean {
    return isDefined<CodeType>(this.code) && !this.code.isEmpty();
  }

  /**
   * @returns the `code` property value as a fhirCode if defined; else undefined
   */
  public getCode(): fhirCode | undefined {
    return this.code?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `code` property.
   *
   * @param value - the `code` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCode(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid Count.code (${String(value)})`;
      this.code = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `code` property exists and has a value; `false` otherwise
   */
  public hasCode(): boolean {
    return this.hasCodeElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Count';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.value,
      this.comparator,
      this.unit,
      this.system,
      this.code,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Count {
    const dest = new Count();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Count): void {
    super.copyValues(dest);
    dest.value = this.value?.copy();
    dest.comparator = this.comparator?.copy();
    dest.unit = this.unit?.copy();
    dest.system = this.system?.copy();
    dest.code = this.code?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasValueElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getValueElement(), 'value', jsonObj);
    }

    if (this.hasComparatorElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getComparatorElement()!, 'comparator', jsonObj);
    }

    if (this.hasUnitElement()) {
      setFhirPrimitiveJson<fhirString>(this.getUnitElement(), 'unit', jsonObj);
    }

    if (this.hasSystemElement()) {
      setFhirPrimitiveJson<fhirUri>(this.getSystemElement(), 'system', jsonObj);
    }

    if (this.hasCodeElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getCodeElement(), 'code', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * DataRequirement Class
 *
 * @remarks
 * Base StructureDefinition for DataRequirement Type: Describes a required data item for evaluation in terms of the type of data, and optional code or date-based filters of the data.
 *
 * **FHIR Specification**
 * - **Short:** Describes a required data item
 * - **Definition:** Describes a required data item for evaluation in terms of the type of data, and optional code or date-based filters of the data.
 * - **FHIR Version:** 4.3.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR DataRequirement](http://hl7.org/fhir/StructureDefinition/DataRequirement)
 */
export class DataRequirement extends DataType implements IDataType {
  constructor(type_: CodeType | fhirCode | null = null) {
    super();

    this.type_ = null;
    if (isDefined<CodeType | fhirCode>(type_)) {
      if (type_ instanceof PrimitiveType) {
        this.setTypeElement(type_);
      } else {
        this.setType(type_);
      }
    }
  }

  /**
   * Parse the provided `DataRequirement` JSON to instantiate the DataRequirement data model.
   *
   * @param sourceJson - JSON representing FHIR `DataRequirement`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to DataRequirement
   * @returns DataRequirement data model or undefined for `DataRequirement`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): DataRequirement | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'DataRequirement';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new DataRequirement();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const classMetadata: DecoratorMetadataObject | null = DataRequirement[Symbol.metadata];
    const errorMessage = `DecoratorMetadataObject does not exist for DataRequirement`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    const missingReqdProperties: string[] = [];

    fieldName = 'type';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setTypeElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'profile';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: CanonicalType | undefined = fhirParser.parseCanonicalType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addProfileElement(datatype);
        }
      });
    }

    fieldName = 'subject[x]';
    sourceField = `${optSourceValue}.${fieldName}`;
    const subject: IDataType | undefined = fhirParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setSubject(subject);

    fieldName = 'mustSupport';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: StringType | undefined = fhirParser.parseStringType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addMustSupportElement(datatype);
        }
      });
    }

    fieldName = 'codeFilter';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: DataRequirementCodeFilterComponent | undefined = DataRequirementCodeFilterComponent.parse(dataElementJson, `${sourceField}[${String(idx)}]`);
        if (datatype !== undefined) {
          instance.addCodeFilter(datatype);
        }
      });
    }

    fieldName = 'dateFilter';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: DataRequirementDateFilterComponent | undefined = DataRequirementDateFilterComponent.parse(dataElementJson, `${sourceField}[${String(idx)}]`);
        if (datatype !== undefined) {
          instance.addDateFilter(datatype);
        }
      });
    }

    fieldName = 'limit';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = fhirParser.parsePositiveIntType(dtJson, dtSiblingJson);
      instance.setLimitElement(datatype);
    }

    fieldName = 'sort';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: DataRequirementSortComponent | undefined = DataRequirementSortComponent.parse(dataElementJson, `${sourceField}[${String(idx)}]`);
        if (datatype !== undefined) {
          instance.addSort(datatype);
        }
      });
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_REQD_IN_JSON} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * DataRequirement.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The type of the required data
   * - **Definition:** The type of the required data, specified as the type name of a resource. For profiles, this value is set to the type of the base resource of the profile.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private type_: CodeType | null;

  /**
   * DataRequirement.profile Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The profile of the required data
   * - **Definition:** The profile of the required data, specified as the uri of the profile definition.
   * - **FHIR Type:** `canonical`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/StructureDefinition',
   *     ]
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private profile?: CanonicalType[] | undefined;

  /**
   * DataRequirement.subject[x] Element
   *
   * @decorator `@ChoiceDataTypesMeta('DataRequirement.subject[x]', ['CodeableConcept','Reference',]`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** E.g. Patient, Practitioner, RelatedPerson, Organization, Location, Device
   * - **Definition:** The intended subjects of the data requirement. If this element is not provided, a Patient subject is assumed.
   * - **Comment:** The subject of a data requirement is critical, as the data being specified is determined with respect to a particular subject. This corresponds roughly to the notion of a Compartment in that it limits what data is available based on its relationship to the subject. In CQL, this corresponds to the context declaration.
   * - **FHIR Types:**
   *     'CodeableConcept',
   *     'Reference',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('DataRequirement.subject[x]',[
    'CodeableConcept',
    'Reference',
  ])
  private subject?: IDataType | undefined;

  /**
   * DataRequirement.mustSupport Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Indicates specific structure elements that are referenced by the knowledge module
   * - **Definition:** Indicates that specific elements of the type are referenced by the knowledge module and must be supported by the consumer in order to obtain an effective evaluation. This does not mean that a value is required for this element, only that the consuming system must understand the element and be able to provide values for it if they are available.  The value of mustSupport SHALL be a FHIRPath resolveable on the type of the DataRequirement. The path SHALL consist only of identifiers, constant indexers, and .resolve() (see the [Simple FHIRPath Profile](https://hl7.org/fhir/fhirpath.html#simple) for full details).
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private mustSupport?: StringType[] | undefined;

  /**
   * DataRequirement.codeFilter Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** What codes are expected
   * - **Definition:** Code filters specify additional constraints on the data, specifying the value set of interest for a particular element of the data. Each code filter defines an additional constraint on the data, i.e. code filters are AND\'ed, not OR\'ed.
   * - **FHIR Type:** `Element`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private codeFilter?: DataRequirementCodeFilterComponent[] | undefined;

  /**
   * DataRequirement.dateFilter Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** What dates/date ranges are expected
   * - **Definition:** Date filters specify additional constraints on the data in terms of the applicable date range for specific elements. Each date filter specifies an additional constraint on the data, i.e. date filters are AND\'ed, not OR\'ed.
   * - **FHIR Type:** `Element`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private dateFilter?: DataRequirementDateFilterComponent[] | undefined;

  /**
   * DataRequirement.limit Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Number of results
   * - **Definition:** Specifies a maximum number of results that are required (uses the _count search parameter).
   * - **Comment:** This element can be used in combination with the sort element to specify quota requirements such as "the most recent 5" or "the highest 5".
   * - **Requirements:** Enables the requirement "most recent 5 results" to be expressed.
   * - **FHIR Type:** `positiveInt`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private limit?: PositiveIntType | undefined;

  /**
   * DataRequirement.sort Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Order of the results
   * - **Definition:** Specifies the order of the results to be returned.
   * - **Comment:** This element can be used in combination with the sort element to specify quota requirements such as "the most recent 5" or "the highest 5". When multiple sorts are specified, they are applied in the order they appear in the resource.
   * - **Requirements:** Enables the requirement "most recent 5 results" to be expressed.
   * - **FHIR Type:** `Element`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private sort?: DataRequirementSortComponent[] | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `type_` property value as a CodeType object if defined; else null
   */
  public getTypeElement(): CodeType | null {
    return this.type_;
  }

  /**
   * Assigns the provided PrimitiveType value to the `type_` property.
   *
   * @param element - the `type_` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTypeElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, `DataRequirement.type is required`);
    const optErrMsg = `Invalid DataRequirement.type; Provided value is not an instance of CodeType.`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.type_ = element;
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasTypeElement(): boolean {
    return isDefined<CodeType>(this.type_) && !this.type_.isEmpty();
  }

  /**
   * @returns the `type_` property value as a fhirCode if defined; else null
   */
  public getType(): fhirCode | null {
    if (this.type_?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.type_.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the `type_` property.
   *
   * @param value - the `type_` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setType(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, `DataRequirement.type is required`);
    const optErrMsg = `Invalid DataRequirement.type (${String(value)})`;
    this.type_ = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasType(): boolean {
    return this.hasTypeElement();
  }

  /**
   * @returns the `profile` property value as a CanonicalType array
   */
  public getProfileElement(): CanonicalType[] {
    return this.profile ?? ([] as CanonicalType[]);
  }

  /**
   * Assigns the provided CanonicalType array value to the `profile` property.
   *
   * @param element - the `profile` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setProfileElement(element: CanonicalType[] | undefined): this {
    if (isDefinedList<CanonicalType>(element)) {
      const optErrMsg = `Invalid DataRequirement.profile; Provided value array has an element that is not an instance of CanonicalType.`;
      assertFhirTypeList<CanonicalType>(element, CanonicalType, optErrMsg);
      this.profile = element;
    } else {
      this.profile = undefined;
    }
    return this;
  }

  /**
   * Add the provided CanonicalType value to the `profile` array property.
   *
   * @param element - the `profile` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addProfileElement(element: CanonicalType | undefined): this {
    if (isDefined<CanonicalType>(element)) {
      const optErrMsg = `Invalid DataRequirement.profile; Provided element is not an instance of CanonicalType.`;
      assertFhirType<CanonicalType>(element, CanonicalType, optErrMsg);
      this.initProfile();
      this.profile?.push(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `profile` property exists and has a value; `false` otherwise
   */
  public hasProfileElement(): boolean {
    return isDefinedList<CanonicalType>(this.profile) && this.profile.some((item: CanonicalType) => !item.isEmpty());
  }

  /**
   * @returns the `profile` property value as a fhirCanonical array
   */
  public getProfile(): fhirCanonical[] {
    this.initProfile();
    const profileValues = [] as fhirCanonical[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.profile!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        profileValues.push(value);
      }
    }
    return profileValues;
  }

  /**
   * Assigns the provided primitive value array to the `profile` property.
   *
   * @param value - the `profile` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setProfile(value: fhirCanonical[] | undefined): this {
    if (isDefinedList<fhirCanonical>(value)) {
      const profileElements = [] as CanonicalType[];
      for (const profileValue of value) {
        const optErrMsg = `Invalid DataRequirement.profile array item (${String(profileValue)})`;
        const element = new CanonicalType(parseFhirPrimitiveData(profileValue, fhirCanonicalSchema, optErrMsg));
        profileElements.push(element);
      }
      this.profile = profileElements;
    } else {
      this.profile = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the `profile` array property.
   *
   * @param value - the `profile` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addProfile(value: fhirCanonical | undefined): this {
    if (isDefined<fhirCanonical>(value)) {
      const optErrMsg = `Invalid DataRequirement.profile array item (${String(value)})`;
      const element = new CanonicalType(parseFhirPrimitiveData(value, fhirCanonicalSchema, optErrMsg));
      this.initProfile();
      this.addProfileElement(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `profile` property exists and has a value; `false` otherwise
   */
  public hasProfile(): boolean {
    return this.hasProfileElement();
  }

  /**
   * Initialize the `profile` property
   */
  private initProfile(): void {
    if (!this.hasProfile()) {
      this.profile = [] as CanonicalType[];
    }
  }

  /**
   * @returns the `subject` property value as a DataType object if defined; else undefined
   */
  public getSubject(): IDataType | undefined {
    return this.subject;
  }

  /**
   * Assigns the provided DataType object value to the `subject` property.
   *
   * @decorator `@ChoiceDataTypes('DataRequirement.subject[x]')`
   *
   * @param value - the `subject` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  @ChoiceDataTypes('DataRequirement.subject[x]')
  public setSubject(value: IDataType | undefined): this {
    if (isDefined<IDataType>(value)) {
      // assertFhirType<IDataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.subject = value;
    } else {
      this.subject = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `subject` property exists and has a value; `false` otherwise
   */
  public hasSubject(): boolean {
    return isDefined<IDataType>(this.subject) && !this.subject.isEmpty();
  }

  // *** NOTE ***
  // Following choice datatype-specific "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the `subject` property value as a CodeableConcept object if defined; else undefined
   */
  public getSubjectCodeableConcept(): CodeableConcept | undefined {
    if (!isDefined<IDataType | undefined>(this.subject)) {
      return undefined;
    }
    if (!(this.subject instanceof CodeableConcept)) {
      throw new InvalidTypeError(
        `DataType mismatch for DataRequirement.subject[x]: Expected CodeableConcept but encountered ${this.subject.fhirType()}`,
      );
    }
    return this.subject;
  }

  /**
   * @returns `true` if the `subject` property exists as a CodeableConcept and has a value; `false` otherwise
   */
  public hasSubjectCodeableConcept(): boolean {
    return this.hasSubject() && this.subject instanceof CodeableConcept;
  }

  /**
   * @returns the `subject` property value as a Reference object if defined; else undefined
   */
  public getSubjectReference(): Reference | undefined {
    if (!isDefined<IDataType | undefined>(this.subject)) {
      return undefined;
    }
    if (!(this.subject instanceof Reference)) {
      throw new InvalidTypeError(
        `DataType mismatch for DataRequirement.subject[x]: Expected Reference but encountered ${this.subject.fhirType()}`,
      );
    }
    return this.subject;
  }

  /**
   * @returns `true` if the `subject` property exists as a Reference and has a value; `false` otherwise
   */
  public hasSubjectReference(): boolean {
    return this.hasSubject() && this.subject instanceof Reference;
  }

  // End of choice datatype-specific "get"/"has" methods

  /**
   * @returns the `mustSupport` property value as a StringType array
   */
  public getMustSupportElement(): StringType[] {
    return this.mustSupport ?? ([] as StringType[]);
  }

  /**
   * Assigns the provided StringType array value to the `mustSupport` property.
   *
   * @param element - the `mustSupport` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMustSupportElement(element: StringType[] | undefined): this {
    if (isDefinedList<StringType>(element)) {
      const optErrMsg = `Invalid DataRequirement.mustSupport; Provided value array has an element that is not an instance of StringType.`;
      assertFhirTypeList<StringType>(element, StringType, optErrMsg);
      this.mustSupport = element;
    } else {
      this.mustSupport = undefined;
    }
    return this;
  }

  /**
   * Add the provided StringType value to the `mustSupport` array property.
   *
   * @param element - the `mustSupport` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addMustSupportElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid DataRequirement.mustSupport; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.initMustSupport();
      this.mustSupport?.push(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `mustSupport` property exists and has a value; `false` otherwise
   */
  public hasMustSupportElement(): boolean {
    return isDefinedList<StringType>(this.mustSupport) && this.mustSupport.some((item: StringType) => !item.isEmpty());
  }

  /**
   * @returns the `mustSupport` property value as a fhirString array
   */
  public getMustSupport(): fhirString[] {
    this.initMustSupport();
    const mustSupportValues = [] as fhirString[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.mustSupport!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        mustSupportValues.push(value);
      }
    }
    return mustSupportValues;
  }

  /**
   * Assigns the provided primitive value array to the `mustSupport` property.
   *
   * @param value - the `mustSupport` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMustSupport(value: fhirString[] | undefined): this {
    if (isDefinedList<fhirString>(value)) {
      const mustSupportElements = [] as StringType[];
      for (const mustSupportValue of value) {
        const optErrMsg = `Invalid DataRequirement.mustSupport array item (${String(mustSupportValue)})`;
        const element = new StringType(parseFhirPrimitiveData(mustSupportValue, fhirStringSchema, optErrMsg));
        mustSupportElements.push(element);
      }
      this.mustSupport = mustSupportElements;
    } else {
      this.mustSupport = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the `mustSupport` array property.
   *
   * @param value - the `mustSupport` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addMustSupport(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid DataRequirement.mustSupport array item (${String(value)})`;
      const element = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
      this.initMustSupport();
      this.addMustSupportElement(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `mustSupport` property exists and has a value; `false` otherwise
   */
  public hasMustSupport(): boolean {
    return this.hasMustSupportElement();
  }

  /**
   * Initialize the `mustSupport` property
   */
  private initMustSupport(): void {
    if (!this.hasMustSupport()) {
      this.mustSupport = [] as StringType[];
    }
  }

  /**
   * @returns the `codeFilter` property value as a DataRequirementCodeFilterComponent array
   */
  public getCodeFilter(): DataRequirementCodeFilterComponent[] {
    return this.codeFilter ?? ([] as DataRequirementCodeFilterComponent[]);
  }

  /**
   * Assigns the provided DataRequirementCodeFilterComponent array value to the `codeFilter` property.
   *
   * @param value - the `codeFilter` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setCodeFilter(value: DataRequirementCodeFilterComponent[] | undefined): this {
    if (isDefinedList<DataRequirementCodeFilterComponent>(value)) {
      const optErrMsg = `Invalid DataRequirement.codeFilter; Provided value array has an element that is not an instance of DataRequirementCodeFilterComponent.`;
      assertFhirTypeList<DataRequirementCodeFilterComponent>(value, DataRequirementCodeFilterComponent, optErrMsg);
      this.codeFilter = value;
    } else {
      this.codeFilter = undefined;
    }
    return this;
  }

  /**
   * Add the provided DataRequirementCodeFilterComponent value to the `codeFilter` array property.
   *
   * @param value - the `codeFilter` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addCodeFilter(value: DataRequirementCodeFilterComponent | undefined): this {
    if (isDefined<DataRequirementCodeFilterComponent>(value)) {
      const optErrMsg = `Invalid DataRequirement.codeFilter; Provided element is not an instance of DataRequirementCodeFilterComponent.`;
      assertFhirType<DataRequirementCodeFilterComponent>(value, DataRequirementCodeFilterComponent, optErrMsg);
      this.initCodeFilter();
      this.codeFilter?.push(value);
    }
    return this;
  }

  /**
   * @returns `true` if the `codeFilter` property exists and has a value; `false` otherwise
   */
  public hasCodeFilter(): boolean {
    return isDefinedList<DataRequirementCodeFilterComponent>(this.codeFilter) && this.codeFilter.some((item: DataRequirementCodeFilterComponent) => !item.isEmpty());
  }

  /**
   * Initialize the `codeFilter` property
   */
  private initCodeFilter(): void {
    if(!this.hasCodeFilter()) {
      this.codeFilter = [] as DataRequirementCodeFilterComponent[];
    }
  }

  /**
   * @returns the `dateFilter` property value as a DataRequirementDateFilterComponent array
   */
  public getDateFilter(): DataRequirementDateFilterComponent[] {
    return this.dateFilter ?? ([] as DataRequirementDateFilterComponent[]);
  }

  /**
   * Assigns the provided DataRequirementDateFilterComponent array value to the `dateFilter` property.
   *
   * @param value - the `dateFilter` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setDateFilter(value: DataRequirementDateFilterComponent[] | undefined): this {
    if (isDefinedList<DataRequirementDateFilterComponent>(value)) {
      const optErrMsg = `Invalid DataRequirement.dateFilter; Provided value array has an element that is not an instance of DataRequirementDateFilterComponent.`;
      assertFhirTypeList<DataRequirementDateFilterComponent>(value, DataRequirementDateFilterComponent, optErrMsg);
      this.dateFilter = value;
    } else {
      this.dateFilter = undefined;
    }
    return this;
  }

  /**
   * Add the provided DataRequirementDateFilterComponent value to the `dateFilter` array property.
   *
   * @param value - the `dateFilter` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addDateFilter(value: DataRequirementDateFilterComponent | undefined): this {
    if (isDefined<DataRequirementDateFilterComponent>(value)) {
      const optErrMsg = `Invalid DataRequirement.dateFilter; Provided element is not an instance of DataRequirementDateFilterComponent.`;
      assertFhirType<DataRequirementDateFilterComponent>(value, DataRequirementDateFilterComponent, optErrMsg);
      this.initDateFilter();
      this.dateFilter?.push(value);
    }
    return this;
  }

  /**
   * @returns `true` if the `dateFilter` property exists and has a value; `false` otherwise
   */
  public hasDateFilter(): boolean {
    return isDefinedList<DataRequirementDateFilterComponent>(this.dateFilter) && this.dateFilter.some((item: DataRequirementDateFilterComponent) => !item.isEmpty());
  }

  /**
   * Initialize the `dateFilter` property
   */
  private initDateFilter(): void {
    if(!this.hasDateFilter()) {
      this.dateFilter = [] as DataRequirementDateFilterComponent[];
    }
  }

  /**
   * @returns the `limit` property value as a PositiveIntType object if defined; else an empty PositiveIntType object
   */
  public getLimitElement(): PositiveIntType {
    return this.limit ?? new PositiveIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `limit` property.
   *
   * @param element - the `limit` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLimitElement(element: PositiveIntType | undefined): this {
    if (isDefined<PositiveIntType>(element)) {
      const optErrMsg = `Invalid DataRequirement.limit; Provided element is not an instance of PositiveIntType.`;
      assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
      this.limit = element;
    } else {
      this.limit = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `limit` property exists and has a value; `false` otherwise
   */
  public hasLimitElement(): boolean {
    return isDefined<PositiveIntType>(this.limit) && !this.limit.isEmpty();
  }

  /**
   * @returns the `limit` property value as a fhirPositiveInt if defined; else undefined
   */
  public getLimit(): fhirPositiveInt | undefined {
    return this.limit?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `limit` property.
   *
   * @param value - the `limit` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLimit(value: fhirPositiveInt | undefined): this {
    if (isDefined<fhirPositiveInt>(value)) {
      const optErrMsg = `Invalid DataRequirement.limit (${String(value)})`;
      this.limit = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    } else {
      this.limit = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `limit` property exists and has a value; `false` otherwise
   */
  public hasLimit(): boolean {
    return this.hasLimitElement();
  }

  /**
   * @returns the `sort` property value as a DataRequirementSortComponent array
   */
  public getSort(): DataRequirementSortComponent[] {
    return this.sort ?? ([] as DataRequirementSortComponent[]);
  }

  /**
   * Assigns the provided DataRequirementSortComponent array value to the `sort` property.
   *
   * @param value - the `sort` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setSort(value: DataRequirementSortComponent[] | undefined): this {
    if (isDefinedList<DataRequirementSortComponent>(value)) {
      const optErrMsg = `Invalid DataRequirement.sort; Provided value array has an element that is not an instance of DataRequirementSortComponent.`;
      assertFhirTypeList<DataRequirementSortComponent>(value, DataRequirementSortComponent, optErrMsg);
      this.sort = value;
    } else {
      this.sort = undefined;
    }
    return this;
  }

  /**
   * Add the provided DataRequirementSortComponent value to the `sort` array property.
   *
   * @param value - the `sort` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addSort(value: DataRequirementSortComponent | undefined): this {
    if (isDefined<DataRequirementSortComponent>(value)) {
      const optErrMsg = `Invalid DataRequirement.sort; Provided element is not an instance of DataRequirementSortComponent.`;
      assertFhirType<DataRequirementSortComponent>(value, DataRequirementSortComponent, optErrMsg);
      this.initSort();
      this.sort?.push(value);
    }
    return this;
  }

  /**
   * @returns `true` if the `sort` property exists and has a value; `false` otherwise
   */
  public hasSort(): boolean {
    return isDefinedList<DataRequirementSortComponent>(this.sort) && this.sort.some((item: DataRequirementSortComponent) => !item.isEmpty());
  }

  /**
   * Initialize the `sort` property
   */
  private initSort(): void {
    if(!this.hasSort()) {
      this.sort = [] as DataRequirementSortComponent[];
    }
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'DataRequirement';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.type_,
      this.profile,
      this.subject,
      this.mustSupport,
      this.codeFilter,
      this.dateFilter,
      this.limit,
      this.sort,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): DataRequirement {
    const dest = new DataRequirement();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: DataRequirement): void {
    super.copyValues(dest);
    dest.type_ = this.type_ ? this.type_.copy() : null;
    const profileList = copyListValues<CanonicalType>(this.profile);
    dest.profile = profileList.length === 0 ? undefined : profileList;
    dest.subject = this.subject?.copy() as IDataType;
    const mustSupportList = copyListValues<StringType>(this.mustSupport);
    dest.mustSupport = mustSupportList.length === 0 ? undefined : mustSupportList;
    const codeFilterList = copyListValues<DataRequirementCodeFilterComponent>(this.codeFilter);
    dest.codeFilter = codeFilterList.length === 0 ? undefined : codeFilterList;
    const dateFilterList = copyListValues<DataRequirementDateFilterComponent>(this.dateFilter);
    dest.dateFilter = dateFilterList.length === 0 ? undefined : dateFilterList;
    dest.limit = this.limit?.copy();
    const sortList = copyListValues<DataRequirementSortComponent>(this.sort);
    dest.sort = sortList.length === 0 ? undefined : sortList;
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasTypeElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getTypeElement()!, 'type', jsonObj);
    } else {
      missingReqdProperties.push(`DataRequirement.type`);
    }

    if (this.hasProfile()) {
      setFhirPrimitiveListJson(this.getProfileElement(), 'profile', jsonObj);
    }

    if (this.hasSubject()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getSubject()!, 'subject', jsonObj);
    }

    if (this.hasMustSupport()) {
      setFhirPrimitiveListJson(this.getMustSupportElement(), 'mustSupport', jsonObj);
    }

    if (this.hasCodeFilter()) {
      setFhirComplexListJson(this.getCodeFilter(), 'codeFilter', jsonObj);
    }

    if (this.hasDateFilter()) {
      setFhirComplexListJson(this.getDateFilter(), 'dateFilter', jsonObj);
    }

    if (this.hasLimitElement()) {
      setFhirPrimitiveJson<fhirPositiveInt>(this.getLimitElement(), 'limit', jsonObj);
    }

    if (this.hasSort()) {
      setFhirComplexListJson(this.getSort(), 'sort', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_DO_NOT_EXIST} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
/**
 * DataRequirementCodeFilterComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** What codes are expected
 * - **Definition:** Code filters specify additional constraints on the data, specifying the value set of interest for a particular element of the data. Each code filter defines an additional constraint on the data, i.e. code filters are AND\'ed, not OR\'ed.
 *
 * @category Data Models: ComplexType
 * @see [FHIR DataRequirement](http://hl7.org/fhir/StructureDefinition/DataRequirement)
 */
export class DataRequirementCodeFilterComponent extends DataType implements IDataType {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided `DataRequirementCodeFilterComponent` JSON to instantiate the DataRequirementCodeFilterComponent data model.
   *
   * @param sourceJson - JSON representing FHIR `DataRequirementCodeFilterComponent`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to DataRequirementCodeFilterComponent
   * @returns DataRequirementCodeFilterComponent data model or undefined for `DataRequirementCodeFilterComponent`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): DataRequirementCodeFilterComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'DataRequirementCodeFilterComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new DataRequirementCodeFilterComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'path';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setPathElement(datatype);
    }

    fieldName = 'searchParam';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setSearchParamElement(datatype);
    }

    fieldName = 'valueSet';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CanonicalType | undefined = fhirParser.parseCanonicalType(dtJson, dtSiblingJson);
      instance.setValueSetElement(datatype);
    }

    fieldName = 'code';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Coding | undefined = Coding.parse(dataElementJson, `${sourceField}[${String(idx)}]`);
        if (datatype !== undefined) {
          instance.addCode(datatype);
        }
      });
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * DataRequirement.codeFilter.path Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A code-valued attribute to filter on
   * - **Definition:** The code-valued attribute of the filter. The specified path SHALL be a FHIRPath resolveable on the specified type of the DataRequirement, and SHALL consist only of identifiers, constant indexers, and .resolve(). The path is allowed to contain qualifiers (.) to traverse sub-elements, as well as indexers ([x]) to traverse multiple-cardinality sub-elements (see the [Simple FHIRPath Profile](https://hl7.org/fhir/fhirpath.html#simple) for full details). Note that the index must be an integer constant. The path must resolve to an element of type code, Coding, or CodeableConcept.
   * - **Comment:** The path attribute contains a [Simple FHIRPath Subset](https://hl7.org/fhir/fhirpath.html#simple) that allows path traversal, but not calculation.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private path?: StringType | undefined;

  /**
   * DataRequirement.codeFilter.searchParam Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A coded (token) parameter to search on
   * - **Definition:** A token parameter that refers to a search parameter defined on the specified type of the DataRequirement, and which searches on elements of type code, Coding, or CodeableConcept.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private searchParam?: StringType | undefined;

  /**
   * DataRequirement.codeFilter.valueSet Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Valueset for the filter
   * - **Definition:** The valueset for the code filter. The valueSet and code elements are additive. If valueSet is specified, the filter will return only those data items for which the value of the code-valued element specified in the path is a member of the specified valueset.
   * - **FHIR Type:** `canonical`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/ValueSet',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private valueSet?: CanonicalType | undefined;

  /**
   * DataRequirement.codeFilter.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** What code is expected
   * - **Definition:** The codes for the code filter. If values are given, the filter will return only those data items for which the code-valued attribute specified by the path has a value that is one of the specified codes. If codes are specified in addition to a value set, the filter returns items matching a code in the value set or one of the specified codes.
   * - **FHIR Type:** `Coding`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code?: Coding[] | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `path` property value as a StringType object if defined; else an empty StringType object
   */
  public getPathElement(): StringType {
    return this.path ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `path` property.
   *
   * @param element - the `path` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPathElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid DataRequirement.codeFilter.path; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.path = element;
    } else {
      this.path = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `path` property exists and has a value; `false` otherwise
   */
  public hasPathElement(): boolean {
    return isDefined<StringType>(this.path) && !this.path.isEmpty();
  }

  /**
   * @returns the `path` property value as a fhirString if defined; else undefined
   */
  public getPath(): fhirString | undefined {
    return this.path?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `path` property.
   *
   * @param value - the `path` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPath(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid DataRequirement.codeFilter.path (${String(value)})`;
      this.path = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.path = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `path` property exists and has a value; `false` otherwise
   */
  public hasPath(): boolean {
    return this.hasPathElement();
  }

  /**
   * @returns the `searchParam` property value as a StringType object if defined; else an empty StringType object
   */
  public getSearchParamElement(): StringType {
    return this.searchParam ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `searchParam` property.
   *
   * @param element - the `searchParam` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSearchParamElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid DataRequirement.codeFilter.searchParam; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.searchParam = element;
    } else {
      this.searchParam = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `searchParam` property exists and has a value; `false` otherwise
   */
  public hasSearchParamElement(): boolean {
    return isDefined<StringType>(this.searchParam) && !this.searchParam.isEmpty();
  }

  /**
   * @returns the `searchParam` property value as a fhirString if defined; else undefined
   */
  public getSearchParam(): fhirString | undefined {
    return this.searchParam?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `searchParam` property.
   *
   * @param value - the `searchParam` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSearchParam(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid DataRequirement.codeFilter.searchParam (${String(value)})`;
      this.searchParam = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.searchParam = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `searchParam` property exists and has a value; `false` otherwise
   */
  public hasSearchParam(): boolean {
    return this.hasSearchParamElement();
  }

  /**
   * @returns the `valueSet` property value as a CanonicalType object if defined; else an empty CanonicalType object
   */
  public getValueSetElement(): CanonicalType {
    return this.valueSet ?? new CanonicalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `valueSet` property.
   *
   * @param element - the `valueSet` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValueSetElement(element: CanonicalType | undefined): this {
    if (isDefined<CanonicalType>(element)) {
      const optErrMsg = `Invalid DataRequirement.codeFilter.valueSet; Provided element is not an instance of CanonicalType.`;
      assertFhirType<CanonicalType>(element, CanonicalType, optErrMsg);
      this.valueSet = element;
    } else {
      this.valueSet = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `valueSet` property exists and has a value; `false` otherwise
   */
  public hasValueSetElement(): boolean {
    return isDefined<CanonicalType>(this.valueSet) && !this.valueSet.isEmpty();
  }

  /**
   * @returns the `valueSet` property value as a fhirCanonical if defined; else undefined
   */
  public getValueSet(): fhirCanonical | undefined {
    return this.valueSet?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `valueSet` property.
   *
   * @param value - the `valueSet` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValueSet(value: fhirCanonical | undefined): this {
    if (isDefined<fhirCanonical>(value)) {
      const optErrMsg = `Invalid DataRequirement.codeFilter.valueSet (${String(value)})`;
      this.valueSet = new CanonicalType(parseFhirPrimitiveData(value, fhirCanonicalSchema, optErrMsg));
    } else {
      this.valueSet = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `valueSet` property exists and has a value; `false` otherwise
   */
  public hasValueSet(): boolean {
    return this.hasValueSetElement();
  }

  /**
   * @returns the `code` property value as a Coding array
   */
  public getCode(): Coding[] {
    return this.code ?? ([] as Coding[]);
  }

  /**
   * Assigns the provided Coding array value to the `code` property.
   *
   * @param value - the `code` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setCode(value: Coding[] | undefined): this {
    if (isDefinedList<Coding>(value)) {
      const optErrMsg = `Invalid DataRequirement.codeFilter.code; Provided value array has an element that is not an instance of Coding.`;
      assertFhirTypeList<Coding>(value, Coding, optErrMsg);
      this.code = value;
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * Add the provided Coding value to the `code` array property.
   *
   * @param value - the `code` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addCode(value: Coding | undefined): this {
    if (isDefined<Coding>(value)) {
      const optErrMsg = `Invalid DataRequirement.codeFilter.code; Provided element is not an instance of Coding.`;
      assertFhirType<Coding>(value, Coding, optErrMsg);
      this.initCode();
      this.code?.push(value);
    }
    return this;
  }

  /**
   * @returns `true` if the `code` property exists and has a value; `false` otherwise
   */
  public hasCode(): boolean {
    return isDefinedList<Coding>(this.code) && this.code.some((item: Coding) => !item.isEmpty());
  }

  /**
   * Initialize the `code` property
   */
  private initCode(): void {
    if(!this.hasCode()) {
      this.code = [] as Coding[];
    }
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'DataRequirement.codeFilter';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.path,
      this.searchParam,
      this.valueSet,
      this.code,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): DataRequirementCodeFilterComponent {
    const dest = new DataRequirementCodeFilterComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: DataRequirementCodeFilterComponent): void {
    super.copyValues(dest);
    dest.path = this.path?.copy();
    dest.searchParam = this.searchParam?.copy();
    dest.valueSet = this.valueSet?.copy();
    const codeList = copyListValues<Coding>(this.code);
    dest.code = codeList.length === 0 ? undefined : codeList;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasPathElement()) {
      setFhirPrimitiveJson<fhirString>(this.getPathElement(), 'path', jsonObj);
    }

    if (this.hasSearchParamElement()) {
      setFhirPrimitiveJson<fhirString>(this.getSearchParamElement(), 'searchParam', jsonObj);
    }

    if (this.hasValueSetElement()) {
      setFhirPrimitiveJson<fhirCanonical>(this.getValueSetElement(), 'valueSet', jsonObj);
    }

    if (this.hasCode()) {
      setFhirComplexListJson(this.getCode(), 'code', jsonObj);
    }

    return jsonObj;
  }
}
/**
 * DataRequirementDateFilterComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** What dates/date ranges are expected
 * - **Definition:** Date filters specify additional constraints on the data in terms of the applicable date range for specific elements. Each date filter specifies an additional constraint on the data, i.e. date filters are AND\'ed, not OR\'ed.
 *
 * @category Data Models: ComplexType
 * @see [FHIR DataRequirement](http://hl7.org/fhir/StructureDefinition/DataRequirement)
 */
export class DataRequirementDateFilterComponent extends DataType implements IDataType {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided `DataRequirementDateFilterComponent` JSON to instantiate the DataRequirementDateFilterComponent data model.
   *
   * @param sourceJson - JSON representing FHIR `DataRequirementDateFilterComponent`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to DataRequirementDateFilterComponent
   * @returns DataRequirementDateFilterComponent data model or undefined for `DataRequirementDateFilterComponent`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): DataRequirementDateFilterComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'DataRequirementDateFilterComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new DataRequirementDateFilterComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const classMetadata: DecoratorMetadataObject | null = DataRequirementDateFilterComponent[Symbol.metadata];
    const errorMessage = `DecoratorMetadataObject does not exist for DataRequirementDateFilterComponent`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    fieldName = 'path';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setPathElement(datatype);
    }

    fieldName = 'searchParam';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setSearchParamElement(datatype);
    }

    fieldName = 'value[x]';
    sourceField = `${optSourceValue}.${fieldName}`;
    const value: IDataType | undefined = fhirParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setValue(value);

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * DataRequirement.dateFilter.path Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A date-valued attribute to filter on
   * - **Definition:** The date-valued attribute of the filter. The specified path SHALL be a FHIRPath resolveable on the specified type of the DataRequirement, and SHALL consist only of identifiers, constant indexers, and .resolve(). The path is allowed to contain qualifiers (.) to traverse sub-elements, as well as indexers ([x]) to traverse multiple-cardinality sub-elements (see the [Simple FHIRPath Profile](https://hl7.org/fhir/fhirpath.html#simple) for full details). Note that the index must be an integer constant. The path must resolve to an element of type date, dateTime, Period, Schedule, or Timing.
   * - **Comment:** The path attribute contains a [Simple FHIR Subset](https://hl7.org/fhir/fhirpath.html#simple) that allows path traversal, but not calculation.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private path?: StringType | undefined;

  /**
   * DataRequirement.dateFilter.searchParam Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A date valued parameter to search on
   * - **Definition:** A date parameter that refers to a search parameter defined on the specified type of the DataRequirement, and which searches on elements of type date, dateTime, Period, Schedule, or Timing.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private searchParam?: StringType | undefined;

  /**
   * DataRequirement.dateFilter.value[x] Element
   *
   * @decorator `@ChoiceDataTypesMeta('DataRequirement.dateFilter.value[x]', ['dateTime','Period','Duration',]`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The value of the filter, as a Period, DateTime, or Duration value
   * - **Definition:** The value of the filter. If period is specified, the filter will return only those data items that fall within the bounds determined by the Period, inclusive of the period boundaries. If dateTime is specified, the filter will return only those data items that are equal to the specified dateTime. If a Duration is specified, the filter will return only those data items that fall within Duration before now.
   * - **FHIR Types:**
   *     'dateTime',
   *     'Period',
   *     'Duration',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('DataRequirement.dateFilter.value[x]',[
    'dateTime',
    'Period',
    'Duration',
  ])
  private value?: IDataType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `path` property value as a StringType object if defined; else an empty StringType object
   */
  public getPathElement(): StringType {
    return this.path ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `path` property.
   *
   * @param element - the `path` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPathElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid DataRequirement.dateFilter.path; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.path = element;
    } else {
      this.path = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `path` property exists and has a value; `false` otherwise
   */
  public hasPathElement(): boolean {
    return isDefined<StringType>(this.path) && !this.path.isEmpty();
  }

  /**
   * @returns the `path` property value as a fhirString if defined; else undefined
   */
  public getPath(): fhirString | undefined {
    return this.path?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `path` property.
   *
   * @param value - the `path` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPath(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid DataRequirement.dateFilter.path (${String(value)})`;
      this.path = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.path = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `path` property exists and has a value; `false` otherwise
   */
  public hasPath(): boolean {
    return this.hasPathElement();
  }

  /**
   * @returns the `searchParam` property value as a StringType object if defined; else an empty StringType object
   */
  public getSearchParamElement(): StringType {
    return this.searchParam ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `searchParam` property.
   *
   * @param element - the `searchParam` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSearchParamElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid DataRequirement.dateFilter.searchParam; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.searchParam = element;
    } else {
      this.searchParam = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `searchParam` property exists and has a value; `false` otherwise
   */
  public hasSearchParamElement(): boolean {
    return isDefined<StringType>(this.searchParam) && !this.searchParam.isEmpty();
  }

  /**
   * @returns the `searchParam` property value as a fhirString if defined; else undefined
   */
  public getSearchParam(): fhirString | undefined {
    return this.searchParam?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `searchParam` property.
   *
   * @param value - the `searchParam` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSearchParam(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid DataRequirement.dateFilter.searchParam (${String(value)})`;
      this.searchParam = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.searchParam = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `searchParam` property exists and has a value; `false` otherwise
   */
  public hasSearchParam(): boolean {
    return this.hasSearchParamElement();
  }

  /**
   * @returns the `value` property value as a DataType object if defined; else undefined
   */
  public getValue(): IDataType | undefined {
    return this.value;
  }

  /**
   * Assigns the provided DataType object value to the `value` property.
   *
   * @decorator `@ChoiceDataTypes('DataRequirement.dateFilter.value[x]')`
   *
   * @param value - the `value` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  @ChoiceDataTypes('DataRequirement.dateFilter.value[x]')
  public setValue(value: IDataType | undefined): this {
    if (isDefined<IDataType>(value)) {
      // assertFhirType<IDataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.value = value;
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `value` property exists and has a value; `false` otherwise
   */
  public hasValue(): boolean {
    return isDefined<IDataType>(this.value) && !this.value.isEmpty();
  }

  // *** NOTE ***
  // Following choice datatype-specific "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the `value` property value as a DateTimeType object if defined; else undefined
   */
  public getValueDateTimeType(): DateTimeType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof DateTimeType)) {
      throw new InvalidTypeError(
        `DataType mismatch for DataRequirement.dateFilter.value[x]: Expected DateTimeType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a DateTimeType and has a value; `false` otherwise
   */
  public hasValueDateTimeType(): boolean {
    return this.hasValue() && this.value instanceof DateTimeType;
  }

  /**
   * @returns the `value` property value as a Period object if defined; else undefined
   */
  public getValuePeriod(): Period | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Period)) {
      throw new InvalidTypeError(
        `DataType mismatch for DataRequirement.dateFilter.value[x]: Expected Period but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a Period and has a value; `false` otherwise
   */
  public hasValuePeriod(): boolean {
    return this.hasValue() && this.value instanceof Period;
  }

  /**
   * @returns the `value` property value as a Duration object if defined; else undefined
   */
  public getValueDuration(): Duration | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Duration)) {
      throw new InvalidTypeError(
        `DataType mismatch for DataRequirement.dateFilter.value[x]: Expected Duration but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a Duration and has a value; `false` otherwise
   */
  public hasValueDuration(): boolean {
    return this.hasValue() && this.value instanceof Duration;
  }

  // End of choice datatype-specific "get"/"has" methods

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'DataRequirement.dateFilter';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.path,
      this.searchParam,
      this.value,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): DataRequirementDateFilterComponent {
    const dest = new DataRequirementDateFilterComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: DataRequirementDateFilterComponent): void {
    super.copyValues(dest);
    dest.path = this.path?.copy();
    dest.searchParam = this.searchParam?.copy();
    dest.value = this.value?.copy() as IDataType;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasPathElement()) {
      setFhirPrimitiveJson<fhirString>(this.getPathElement(), 'path', jsonObj);
    }

    if (this.hasSearchParamElement()) {
      setFhirPrimitiveJson<fhirString>(this.getSearchParamElement(), 'searchParam', jsonObj);
    }

    if (this.hasValue()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getValue()!, 'value', jsonObj);
    }

    return jsonObj;
  }
}
/**
 * DataRequirementSortComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Order of the results
 * - **Definition:** Specifies the order of the results to be returned.
 * - **Comment:** This element can be used in combination with the sort element to specify quota requirements such as "the most recent 5" or "the highest 5". When multiple sorts are specified, they are applied in the order they appear in the resource.
 * - **Requirements:** Enables the requirement "most recent 5 results" to be expressed.
 *
 * @category Data Models: ComplexType
 * @see [FHIR DataRequirement](http://hl7.org/fhir/StructureDefinition/DataRequirement)
 */
export class DataRequirementSortComponent extends DataType implements IDataType {
  constructor(path: StringType | fhirString | null = null, direction: EnumCodeType | CodeType | fhirCode | null = null) {
    super();

    this.sortDirectionEnum = new SortDirectionEnum();

    this.path = null;
    if (isDefined<StringType | fhirString>(path)) {
      if (path instanceof PrimitiveType) {
        this.setPathElement(path);
      } else {
        this.setPath(path);
      }
    }

    this.direction = constructorCodeValueAsEnumCodeType<SortDirectionEnum>(
      direction,
      SortDirectionEnum,
      this.sortDirectionEnum,
      'DataRequirement.sort.direction',
    );
  }

  /**
   * Parse the provided `DataRequirementSortComponent` JSON to instantiate the DataRequirementSortComponent data model.
   *
   * @param sourceJson - JSON representing FHIR `DataRequirementSortComponent`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to DataRequirementSortComponent
   * @returns DataRequirementSortComponent data model or undefined for `DataRequirementSortComponent`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): DataRequirementSortComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'DataRequirementSortComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new DataRequirementSortComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'path';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setPathElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'direction';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setDirectionElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_REQD_IN_JSON} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * DataRequirement.sort.path Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The name of the attribute to perform the sort
   * - **Definition:** The attribute of the sort. The specified path must be resolvable from the type of the required data. The path is allowed to contain qualifiers (.) to traverse sub-elements, as well as indexers ([x]) to traverse multiple-cardinality sub-elements. Note that the index must be an integer constant.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private path: StringType | null;

  /**
   * FHIR CodeSystem: SortDirection
   *
   * @see {@link SortDirectionEnum }
   */
  private readonly sortDirectionEnum: SortDirectionEnum;

  /**
   * DataRequirement.sort.direction Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** ascending | descending
   * - **Definition:** The direction of the sort, ascending or descending.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link SortDirectionEnum }
   */
  private direction: EnumCodeType | null;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `path` property value as a StringType object if defined; else null
   */
  public getPathElement(): StringType | null {
    return this.path;
  }

  /**
   * Assigns the provided PrimitiveType value to the `path` property.
   *
   * @param element - the `path` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPathElement(element: StringType): this {
    assertIsDefined<StringType>(element, `DataRequirement.sort.path is required`);
    const optErrMsg = `Invalid DataRequirement.sort.path; Provided value is not an instance of StringType.`;
    assertFhirType<StringType>(element, StringType, optErrMsg);
    this.path = element;
    return this;
  }

  /**
   * @returns `true` if the `path` property exists and has a value; `false` otherwise
   */
  public hasPathElement(): boolean {
    return isDefined<StringType>(this.path) && !this.path.isEmpty();
  }

  /**
   * @returns the `path` property value as a fhirString if defined; else null
   */
  public getPath(): fhirString | null {
    if (this.path?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.path.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the `path` property.
   *
   * @param value - the `path` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPath(value: fhirString): this {
    assertIsDefined<fhirString>(value, `DataRequirement.sort.path is required`);
    const optErrMsg = `Invalid DataRequirement.sort.path (${String(value)})`;
    this.path = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    return this;
  }

  /**
   * @returns `true` if the `path` property exists and has a value; `false` otherwise
   */
  public hasPath(): boolean {
    return this.hasPathElement();
  }

  /**
   * @returns the `direction` property value as a EnumCodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link SortDirectionEnum }
   */
  public getDirectionEnumType(): EnumCodeType | null {
    return this.direction;
  }

  /**
   * Assigns the provided EnumCodeType value to the `direction` property.
   *
   * @param enumType - the `direction` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link SortDirectionEnum }
   */
  public setDirectionEnumType(enumType: EnumCodeType): this {
    assertIsDefined<EnumCodeType>(enumType, `DataRequirement.sort.direction is required`);
    const errMsgPrefix = `Invalid DataRequirement.sort.direction`;
    assertEnumCodeType<SortDirectionEnum>(enumType, SortDirectionEnum, errMsgPrefix);
    this.direction = enumType;
    return this;
  }

  /**
   * @returns `true` if the `direction` property exists and has a value; `false` otherwise
   */
  public hasDirectionEnumType(): boolean {
    return isDefined<EnumCodeType>(this.direction) && !this.direction.isEmpty() && this.direction.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the `direction` property value as a CodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link SortDirectionEnum }
   */
  public getDirectionElement(): CodeType | null {
    if (this.direction === null) {
      return null;
    }
    return this.direction as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the `direction` property.
   *
   * @param element - the `direction` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link SortDirectionEnum }
   */
  public setDirectionElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, `DataRequirement.sort.direction is required`);
    const optErrMsg = `Invalid DataRequirement.sort.direction; Provided value is not an instance of CodeType.`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.direction = new EnumCodeType(element, this.sortDirectionEnum);
    return this;
  }

  /**
   * @returns `true` if the `direction` property exists and has a value; `false` otherwise
   */
  public hasDirectionElement(): boolean {
    return this.hasDirectionEnumType();
  }

  /**
   * @returns the `direction` property value as a fhirCode if defined; else null
   *
   * @see CodeSystem Enumeration: {@link SortDirectionEnum }
   */
  public getDirection(): fhirCode | null {
    if (this.direction === null) {
      return null;
    }
    return this.direction.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the `direction` property.
   *
   * @param value - the `direction` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link SortDirectionEnum }
   */
  public setDirection(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, `DataRequirement.sort.direction is required`);
    const optErrMsg = `Invalid DataRequirement.sort.direction (${String(value)})`;
    this.direction = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.sortDirectionEnum);
    return this;
  }

  /**
   * @returns `true` if the `direction` property exists and has a value; `false` otherwise
   */
  public hasDirection(): boolean {
    return this.hasDirectionEnumType();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'DataRequirement.sort';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.path,
      this.direction,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): DataRequirementSortComponent {
    const dest = new DataRequirementSortComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: DataRequirementSortComponent): void {
    super.copyValues(dest);
    dest.path = this.path ? this.path.copy() : null;
    dest.direction = this.direction ? this.direction.copy() : null;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasPathElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirString>(this.getPathElement()!, 'path', jsonObj);
    } else {
      missingReqdProperties.push(`DataRequirement.sort.path`);
    }

    if (this.hasDirectionElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getDirectionElement()!, 'direction', jsonObj);
    } else {
      missingReqdProperties.push(`DataRequirement.sort.direction`);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_DO_NOT_EXIST} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

/**
 * Distance Class
 *
 * @remarks
 * Base StructureDefinition for Distance Type: A length - a value with a unit that is a physical distance.
 *
 * **FHIR Specification**
 * - **Short:** A length - a value with a unit that is a physical distance
 * - **Definition:** A length - a value with a unit that is a physical distance.
 * - **Comment:** The context of use may frequently define what kind of quantity this is and therefore what kind of units can be used. The context of use may also restrict the values for the comparator.
 * - **FHIR Version:** 4.3.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR Distance](http://hl7.org/fhir/StructureDefinition/Distance)
 */
export class Distance extends DataType implements IDataType {
  constructor() {
    super();

    this.quantityComparatorEnum = new QuantityComparatorEnum();
  }

  /**
   * Parse the provided `Distance` JSON to instantiate the Distance data model.
   *
   * @param sourceJson - JSON representing FHIR `Distance`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to Distance
   * @returns Distance data model or undefined for `Distance`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Distance | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Distance';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new Distance();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'value';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setValueElement(datatype);
    }

    fieldName = 'comparator';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setComparatorElement(datatype);
    }

    fieldName = 'unit';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setUnitElement(datatype);
    }

    fieldName = 'system';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = fhirParser.parseUriType(dtJson, dtSiblingJson);
      instance.setSystemElement(datatype);
    }

    fieldName = 'code';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setCodeElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Distance.value Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Numerical value (with implicit precision)
   * - **Definition:** The value of the measured amount. The value includes an implicit precision in the presentation of the value.
   * - **Comment:** The implicit precision in the value should always be honored. Monetary values have their own rules for handling precision (refer to standard accounting text books).
   * - **Requirements:** Precision is handled implicitly in almost all cases of measurement.
   * - **FHIR Type:** `decimal`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private value?: DecimalType | undefined;

  /**
   * FHIR CodeSystem: QuantityComparator
   *
   * @see {@link QuantityComparatorEnum }
   */
  private readonly quantityComparatorEnum: QuantityComparatorEnum;

  /**
   * Distance.comparator Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** < | <= | >= | > - how to understand the value
   * - **Definition:** How the value should be understood and represented - whether the actual value is greater or less than the stated value due to measurement issues; e.g. if the comparator is "<" , then the real value is < stated value.
   * - **Requirements:** Need a framework for handling measures where the value is <5ug/L or >400mg/L due to the limitations of measuring methodology.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** true
   * - **isModifierReason:** This is labeled as &quot;Is Modifier&quot; because the comparator modifies the interpretation of the value significantly. If there is no comparator, then there is no modification of the value
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  private comparator?: EnumCodeType | undefined;

  /**
   * Distance.unit Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Unit representation
   * - **Definition:** A human-readable form of the unit.
   * - **Requirements:** There are many representations for units of measure and in many contexts, particular representations are fixed and required. I.e. mcg for micrograms.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private unit?: StringType | undefined;

  /**
   * Distance.system Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** System that defines coded unit form
   * - **Definition:** The identification of the system that provides the coded form of the unit.
   * - **Requirements:** Need to know the system that defines the coded form of the unit.
   * - **FHIR Type:** `uri`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private system?: UriType | undefined;

  /**
   * Distance.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Coded form of the unit
   * - **Definition:** A computer processable form of the unit in some unit representation system.
   * - **Comment:** The preferred system is UCUM, but SNOMED CT can also be used (for customary units) or ISO 4217 for currency.  The context of use may additionally require a code from a particular system.
   * - **Requirements:** Need a computable form of the unit that is fixed across all forms. UCUM provides this for quantities, but SNOMED CT provides many units of interest.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code?: CodeType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `value` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getValueElement(): DecimalType {
    return this.value ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `value` property.
   *
   * @param element - the `value` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValueElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = `Invalid Distance.value; Provided element is not an instance of DecimalType.`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.value = element;
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `value` property exists and has a value; `false` otherwise
   */
  public hasValueElement(): boolean {
    return isDefined<DecimalType>(this.value) && !this.value.isEmpty();
  }

  /**
   * @returns the `value` property value as a fhirDecimal if defined; else undefined
   */
  public getValue(): fhirDecimal | undefined {
    return this.value?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `value` property.
   *
   * @param value - the `value` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValue(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = `Invalid Distance.value (${String(value)})`;
      this.value = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `value` property exists and has a value; `false` otherwise
   */
  public hasValue(): boolean {
    return this.hasValueElement();
  }

  /**
   * @returns the `comparator` property value as a EnumCodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public getComparatorEnumType(): EnumCodeType | undefined {
    return this.comparator;
  }

  /**
   * Assigns the provided EnumCodeType value to the `comparator` property.
   *
   * @param enumType - the `comparator` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code values
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public setComparatorEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid Distance.comparator';
      assertEnumCodeType<QuantityComparatorEnum>(enumType, QuantityComparatorEnum, errMsgPrefix);
      this.comparator = enumType;
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `comparator` property exists and has a value; `false` otherwise
   */
  public hasComparatorEnumType(): boolean {
    return isDefined<EnumCodeType>(this.comparator) && !this.comparator.isEmpty() && this.comparator.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the `comparator` property value as a CodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public getComparatorElement(): CodeType | undefined {
    if (this.comparator === undefined) {
      return undefined;
    }
    return this.comparator as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the `comparator` property.
   *
   * @param element - the `comparator` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public setComparatorElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid Distance.comparator; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.comparator = new EnumCodeType(element, this.quantityComparatorEnum);
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `comparator` property exists and has a value; `false` otherwise
   */
  public hasComparatorElement(): boolean {
    return this.hasComparatorEnumType();
  }

  /**
   * @returns the `comparator` property value as a fhirCode if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public getComparator(): fhirCode | undefined {
    if (this.comparator === undefined) {
      return undefined;
    }
    return this.comparator.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the `comparator` property.
   *
   * @param value - the `comparator` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public setComparator(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid Distance.comparator; Provided value is not an instance of fhirCode.`;
      this.comparator = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.quantityComparatorEnum);
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `comparator` property exists and has a value; `false` otherwise
   */
  public hasComparator(): boolean {
    return this.hasComparatorEnumType();
  }

  /**
   * @returns the `unit` property value as a StringType object if defined; else an empty StringType object
   */
  public getUnitElement(): StringType {
    return this.unit ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `unit` property.
   *
   * @param element - the `unit` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUnitElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid Distance.unit; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.unit = element;
    } else {
      this.unit = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `unit` property exists and has a value; `false` otherwise
   */
  public hasUnitElement(): boolean {
    return isDefined<StringType>(this.unit) && !this.unit.isEmpty();
  }

  /**
   * @returns the `unit` property value as a fhirString if defined; else undefined
   */
  public getUnit(): fhirString | undefined {
    return this.unit?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `unit` property.
   *
   * @param value - the `unit` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUnit(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid Distance.unit (${String(value)})`;
      this.unit = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.unit = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `unit` property exists and has a value; `false` otherwise
   */
  public hasUnit(): boolean {
    return this.hasUnitElement();
  }

  /**
   * @returns the `system` property value as a UriType object if defined; else an empty UriType object
   */
  public getSystemElement(): UriType {
    return this.system ?? new UriType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `system` property.
   *
   * @param element - the `system` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSystemElement(element: UriType | undefined): this {
    if (isDefined<UriType>(element)) {
      const optErrMsg = `Invalid Distance.system; Provided element is not an instance of UriType.`;
      assertFhirType<UriType>(element, UriType, optErrMsg);
      this.system = element;
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `system` property exists and has a value; `false` otherwise
   */
  public hasSystemElement(): boolean {
    return isDefined<UriType>(this.system) && !this.system.isEmpty();
  }

  /**
   * @returns the `system` property value as a fhirUri if defined; else undefined
   */
  public getSystem(): fhirUri | undefined {
    return this.system?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `system` property.
   *
   * @param value - the `system` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSystem(value: fhirUri | undefined): this {
    if (isDefined<fhirUri>(value)) {
      const optErrMsg = `Invalid Distance.system (${String(value)})`;
      this.system = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `system` property exists and has a value; `false` otherwise
   */
  public hasSystem(): boolean {
    return this.hasSystemElement();
  }

  /**
   * @returns the `code` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getCodeElement(): CodeType {
    return this.code ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `code` property.
   *
   * @param element - the `code` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCodeElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid Distance.code; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.code = element;
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `code` property exists and has a value; `false` otherwise
   */
  public hasCodeElement(): boolean {
    return isDefined<CodeType>(this.code) && !this.code.isEmpty();
  }

  /**
   * @returns the `code` property value as a fhirCode if defined; else undefined
   */
  public getCode(): fhirCode | undefined {
    return this.code?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `code` property.
   *
   * @param value - the `code` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCode(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid Distance.code (${String(value)})`;
      this.code = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `code` property exists and has a value; `false` otherwise
   */
  public hasCode(): boolean {
    return this.hasCodeElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Distance';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.value,
      this.comparator,
      this.unit,
      this.system,
      this.code,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Distance {
    const dest = new Distance();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Distance): void {
    super.copyValues(dest);
    dest.value = this.value?.copy();
    dest.comparator = this.comparator?.copy();
    dest.unit = this.unit?.copy();
    dest.system = this.system?.copy();
    dest.code = this.code?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasValueElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getValueElement(), 'value', jsonObj);
    }

    if (this.hasComparatorElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getComparatorElement()!, 'comparator', jsonObj);
    }

    if (this.hasUnitElement()) {
      setFhirPrimitiveJson<fhirString>(this.getUnitElement(), 'unit', jsonObj);
    }

    if (this.hasSystemElement()) {
      setFhirPrimitiveJson<fhirUri>(this.getSystemElement(), 'system', jsonObj);
    }

    if (this.hasCodeElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getCodeElement(), 'code', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * Dosage Class
 *
 * @remarks
 * Base StructureDefinition for Dosage Type: Indicates how the medication is/was taken or should be taken by the patient.
 *
 * **FHIR Specification**
 * - **Short:** How the medication is/was taken or should be taken
 * - **Definition:** Indicates how the medication is/was taken or should be taken by the patient.
 * - **FHIR Version:** 4.3.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR Dosage](http://hl7.org/fhir/StructureDefinition/Dosage)
 */
export class Dosage extends BackboneType implements IBackboneType {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided `Dosage` JSON to instantiate the Dosage data model.
   *
   * @param sourceJson - JSON representing FHIR `Dosage`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to Dosage
   * @returns Dosage data model or undefined for `Dosage`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Dosage | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Dosage';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new Dosage();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneTypeJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const classMetadata: DecoratorMetadataObject | null = Dosage[Symbol.metadata];
    const errorMessage = `DecoratorMetadataObject does not exist for Dosage`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    fieldName = 'sequence';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: IntegerType | undefined = fhirParser.parseIntegerType(dtJson, dtSiblingJson);
      instance.setSequenceElement(datatype);
    }

    fieldName = 'text';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setTextElement(datatype);
    }

    fieldName = 'additionalInstruction';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: CodeableConcept | undefined = CodeableConcept.parse(dataElementJson, `${sourceField}[${String(idx)}]`);
        if (datatype !== undefined) {
          instance.addAdditionalInstruction(datatype);
        }
      });
    }

    fieldName = 'patientInstruction';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setPatientInstructionElement(datatype);
    }

    fieldName = 'timing';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Timing | undefined = Timing.parse(classJsonObj[fieldName]!, sourceField);
      instance.setTiming(datatype);
    }

    fieldName = 'asNeeded[x]';
    sourceField = `${optSourceValue}.${fieldName}`;
    const asNeeded: IDataType | undefined = fhirParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setAsNeeded(asNeeded);

    fieldName = 'site';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = CodeableConcept.parse(classJsonObj[fieldName]!, sourceField);
      instance.setSite(datatype);
    }

    fieldName = 'route';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = CodeableConcept.parse(classJsonObj[fieldName]!, sourceField);
      instance.setRoute(datatype);
    }

    fieldName = 'method';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = CodeableConcept.parse(classJsonObj[fieldName]!, sourceField);
      instance.setMethod(datatype);
    }

    fieldName = 'doseAndRate';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: DosageDoseAndRateComponent | undefined = DosageDoseAndRateComponent.parse(dataElementJson, `${sourceField}[${String(idx)}]`);
        if (datatype !== undefined) {
          instance.addDoseAndRate(datatype);
        }
      });
    }

    fieldName = 'maxDosePerPeriod';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Ratio | undefined = Ratio.parse(classJsonObj[fieldName]!, sourceField);
      instance.setMaxDosePerPeriod(datatype);
    }

    fieldName = 'maxDosePerAdministration';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = Quantity.parse(classJsonObj[fieldName]!, sourceField);
      instance.setMaxDosePerAdministration(datatype);
    }

    fieldName = 'maxDosePerLifetime';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = Quantity.parse(classJsonObj[fieldName]!, sourceField);
      instance.setMaxDosePerLifetime(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Dosage.sequence Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The order of the dosage instructions
   * - **Definition:** Indicates the order in which the dosage instructions should be applied or interpreted.
   * - **Requirements:** If the sequence number of multiple Dosages is the same, then it is implied that the instructions are to be treated as concurrent.  If the sequence number is different, then the Dosages are intended to be sequential.
   * - **FHIR Type:** `integer`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private sequence?: IntegerType | undefined;

  /**
   * Dosage.text Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Free text dosage instructions e.g. SIG
   * - **Definition:** Free text dosage instructions e.g. SIG.
   * - **Requirements:** Free text dosage instructions can be used for cases where the instructions are too complex to code.  The content of this attribute does not include the name or description of the medication. When coded instructions are present, the free text instructions may still be present for display to humans taking or administering the medication. It is expected that the text instructions will always be populated.  If the dosage.timing attribute is also populated, then the dosage.text should reflect the same information as the timing.  Additional information about administration or preparation of the medication should be included as text.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private text?: StringType | undefined;

  /**
   * Dosage.additionalInstruction Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Supplemental instruction or warnings to the patient - e.g. "with meals", "may cause drowsiness"
   * - **Definition:** Supplemental instructions to the patient on how to take the medication  (e.g. "with meals" or"take half to one hour before food") or warnings for the patient about the medication (e.g. "may cause drowsiness" or "avoid exposure of skin to direct sunlight or sunlamps").
   * - **Comment:** Information about administration or preparation of the medication (e.g. "infuse as rapidly as possibly via intraperitoneal port" or "immediately following drug x") should be populated in dosage.text.
   * - **Requirements:** Additional instruction is intended to be coded, but where no code exists, the element could include text.  For example, "Swallow with plenty of water" which might or might not be coded.
   * - **FHIR Type:** `CodeableConcept`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private additionalInstruction?: CodeableConcept[] | undefined;

  /**
   * Dosage.patientInstruction Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Patient or consumer oriented instructions
   * - **Definition:** Instructions in terms that are understood by the patient or consumer.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private patientInstruction?: StringType | undefined;

  /**
   * Dosage.timing Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** When medication should be administered
   * - **Definition:** When medication should be administered.
   * - **Comment:** This attribute might not always be populated while the Dosage.text is expected to be populated.  If both are populated, then the Dosage.text should reflect the content of the Dosage.timing.
   * - **Requirements:** The timing schedule for giving the medication to the patient. This  data type allows many different expressions. For example: "Every 8 hours"; "Three times a day"; "1/2 an hour before breakfast for 10 days from 23-Dec 2011:"; "15 Oct 2013, 17 Oct 2013 and 1 Nov 2013".  Sometimes, a rate can imply duration when expressed as total volume / duration (e.g.  500mL/2 hours implies a duration of 2 hours).  However, when rate doesn\'t imply duration (e.g. 250mL/hour), then the timing.repeat.duration is needed to convey the infuse over time period.
   * - **FHIR Type:** `Timing`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private timing?: Timing | undefined;

  /**
   * Dosage.asNeeded[x] Element
   *
   * @decorator `@ChoiceDataTypesMeta('Dosage.asNeeded[x]', ['boolean','CodeableConcept',]`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Take "as needed" (for x)
   * - **Definition:** Indicates whether the Medication is only taken when needed within a specific dosing schedule (Boolean option), or it indicates the precondition for taking the Medication (CodeableConcept).
   * - **Comment:** Can express "as needed" without a reason by setting the Boolean = True.  In this case the CodeableConcept is not populated.  Or you can express "as needed" with a reason by including the CodeableConcept.  In this case the Boolean is assumed to be True.  If you set the Boolean to False, then the dose is given according to the schedule and is not "prn" or "as needed".
   * - **FHIR Types:**
   *     'boolean',
   *     'CodeableConcept',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('Dosage.asNeeded[x]',[
    'boolean',
    'CodeableConcept',
  ])
  private asNeeded?: IDataType | undefined;

  /**
   * Dosage.site Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Body site to administer to
   * - **Definition:** Body site to administer to.
   * - **Comment:** If the use case requires attributes from the BodySite resource (e.g. to identify and track separately) then use the standard extension [bodySite](https://hl7.org/fhir/extension-bodysite.html).  May be a summary code, or a reference to a very precise definition of the location, or both.
   * - **Requirements:** A coded specification of the anatomic site where the medication first enters the body.
   * - **FHIR Type:** `CodeableConcept`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private site?: CodeableConcept | undefined;

  /**
   * Dosage.route Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** How drug should enter body
   * - **Definition:** How drug should enter body.
   * - **Requirements:** A code specifying the route or physiological path of administration of a therapeutic agent into or onto a patient\'s body.
   * - **FHIR Type:** `CodeableConcept`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private route?: CodeableConcept | undefined;

  /**
   * Dosage.method Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Technique for administering medication
   * - **Definition:** Technique for administering medication.
   * - **Comment:** Terminologies used often pre-coordinate this term with the route and or form of administration.
   * - **Requirements:** A coded value indicating the method by which the medication is introduced into or onto the body. Most commonly used for injections.  For examples, Slow Push; Deep IV.
   * - **FHIR Type:** `CodeableConcept`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private method?: CodeableConcept | undefined;

  /**
   * Dosage.doseAndRate Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Amount of medication administered
   * - **Definition:** The amount of medication administered.
   * - **FHIR Type:** `Element`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private doseAndRate?: DosageDoseAndRateComponent[] | undefined;

  /**
   * Dosage.maxDosePerPeriod Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Upper limit on medication per unit of time
   * - **Definition:** Upper limit on medication per unit of time.
   * - **Comment:** This is intended for use as an adjunct to the dosage when there is an upper cap.  For example "2 tablets every 4 hours to a maximum of 8/day".
   * - **Requirements:** The maximum total quantity of a therapeutic substance that may be administered to a subject over the period of time.  For example, 1000mg in 24 hours.
   * - **FHIR Type:** `Ratio`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private maxDosePerPeriod?: Ratio | undefined;

  /**
   * Dosage.maxDosePerAdministration Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Upper limit on medication per administration
   * - **Definition:** Upper limit on medication per administration.
   * - **Comment:** This is intended for use as an adjunct to the dosage when there is an upper cap.  For example, a body surface area related dose with a maximum amount, such as 1.5 mg/m2 (maximum 2 mg) IV over 5 - 10 minutes would have doseQuantity of 1.5 mg/m2 and maxDosePerAdministration of 2 mg.
   * - **Requirements:** The maximum total quantity of a therapeutic substance that may be administered to a subject per administration.
   * - **FHIR Type:** `Quantity`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private maxDosePerAdministration?: Quantity | undefined;

  /**
   * Dosage.maxDosePerLifetime Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Upper limit on medication per lifetime of the patient
   * - **Definition:** Upper limit on medication per lifetime of the patient.
   * - **Requirements:** The maximum total quantity of a therapeutic substance that may be administered per lifetime of the subject.
   * - **FHIR Type:** `Quantity`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private maxDosePerLifetime?: Quantity | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `sequence` property value as a IntegerType object if defined; else an empty IntegerType object
   */
  public getSequenceElement(): IntegerType {
    return this.sequence ?? new IntegerType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `sequence` property.
   *
   * @param element - the `sequence` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSequenceElement(element: IntegerType | undefined): this {
    if (isDefined<IntegerType>(element)) {
      const optErrMsg = `Invalid Dosage.sequence; Provided element is not an instance of IntegerType.`;
      assertFhirType<IntegerType>(element, IntegerType, optErrMsg);
      this.sequence = element;
    } else {
      this.sequence = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `sequence` property exists and has a value; `false` otherwise
   */
  public hasSequenceElement(): boolean {
    return isDefined<IntegerType>(this.sequence) && !this.sequence.isEmpty();
  }

  /**
   * @returns the `sequence` property value as a fhirInteger if defined; else undefined
   */
  public getSequence(): fhirInteger | undefined {
    return this.sequence?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `sequence` property.
   *
   * @param value - the `sequence` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSequence(value: fhirInteger | undefined): this {
    if (isDefined<fhirInteger>(value)) {
      const optErrMsg = `Invalid Dosage.sequence (${String(value)})`;
      this.sequence = new IntegerType(parseFhirPrimitiveData(value, fhirIntegerSchema, optErrMsg));
    } else {
      this.sequence = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `sequence` property exists and has a value; `false` otherwise
   */
  public hasSequence(): boolean {
    return this.hasSequenceElement();
  }

  /**
   * @returns the `text` property value as a StringType object if defined; else an empty StringType object
   */
  public getTextElement(): StringType {
    return this.text ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `text` property.
   *
   * @param element - the `text` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTextElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid Dosage.text; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.text = element;
    } else {
      this.text = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `text` property exists and has a value; `false` otherwise
   */
  public hasTextElement(): boolean {
    return isDefined<StringType>(this.text) && !this.text.isEmpty();
  }

  /**
   * @returns the `text` property value as a fhirString if defined; else undefined
   */
  public getText(): fhirString | undefined {
    return this.text?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `text` property.
   *
   * @param value - the `text` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setText(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid Dosage.text (${String(value)})`;
      this.text = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.text = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `text` property exists and has a value; `false` otherwise
   */
  public hasText(): boolean {
    return this.hasTextElement();
  }

  /**
   * @returns the `additionalInstruction` property value as a CodeableConcept array
   */
  public getAdditionalInstruction(): CodeableConcept[] {
    return this.additionalInstruction ?? ([] as CodeableConcept[]);
  }

  /**
   * Assigns the provided CodeableConcept array value to the `additionalInstruction` property.
   *
   * @param value - the `additionalInstruction` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setAdditionalInstruction(value: CodeableConcept[] | undefined): this {
    if (isDefinedList<CodeableConcept>(value)) {
      const optErrMsg = `Invalid Dosage.additionalInstruction; Provided value array has an element that is not an instance of CodeableConcept.`;
      assertFhirTypeList<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.additionalInstruction = value;
    } else {
      this.additionalInstruction = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeableConcept value to the `additionalInstruction` array property.
   *
   * @param value - the `additionalInstruction` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addAdditionalInstruction(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = `Invalid Dosage.additionalInstruction; Provided element is not an instance of CodeableConcept.`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.initAdditionalInstruction();
      this.additionalInstruction?.push(value);
    }
    return this;
  }

  /**
   * @returns `true` if the `additionalInstruction` property exists and has a value; `false` otherwise
   */
  public hasAdditionalInstruction(): boolean {
    return isDefinedList<CodeableConcept>(this.additionalInstruction) && this.additionalInstruction.some((item: CodeableConcept) => !item.isEmpty());
  }

  /**
   * Initialize the `additionalInstruction` property
   */
  private initAdditionalInstruction(): void {
    if(!this.hasAdditionalInstruction()) {
      this.additionalInstruction = [] as CodeableConcept[];
    }
  }

  /**
   * @returns the `patientInstruction` property value as a StringType object if defined; else an empty StringType object
   */
  public getPatientInstructionElement(): StringType {
    return this.patientInstruction ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `patientInstruction` property.
   *
   * @param element - the `patientInstruction` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPatientInstructionElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid Dosage.patientInstruction; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.patientInstruction = element;
    } else {
      this.patientInstruction = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `patientInstruction` property exists and has a value; `false` otherwise
   */
  public hasPatientInstructionElement(): boolean {
    return isDefined<StringType>(this.patientInstruction) && !this.patientInstruction.isEmpty();
  }

  /**
   * @returns the `patientInstruction` property value as a fhirString if defined; else undefined
   */
  public getPatientInstruction(): fhirString | undefined {
    return this.patientInstruction?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `patientInstruction` property.
   *
   * @param value - the `patientInstruction` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPatientInstruction(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid Dosage.patientInstruction (${String(value)})`;
      this.patientInstruction = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.patientInstruction = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `patientInstruction` property exists and has a value; `false` otherwise
   */
  public hasPatientInstruction(): boolean {
    return this.hasPatientInstructionElement();
  }

  /**
   * @returns the `timing` property value as a Timing object if defined; else an empty Timing object
   */
  public getTiming(): Timing {
    return this.timing ?? new Timing();
  }

  /**
   * Assigns the provided Timing object value to the `timing` property.
   *
   * @param value - the `timing` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setTiming(value: Timing | undefined): this {
    if (isDefined<Timing>(value)) {
      const optErrMsg = `Invalid Dosage.timing; Provided element is not an instance of Timing.`;
      assertFhirType<Timing>(value, Timing, optErrMsg);
      this.timing = value;
    } else {
      this.timing = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `timing` property exists and has a value; `false` otherwise
   */
  public hasTiming(): boolean {
    return isDefined<Timing>(this.timing) && !this.timing.isEmpty();
  }

  /**
   * @returns the `asNeeded` property value as a DataType object if defined; else undefined
   */
  public getAsNeeded(): IDataType | undefined {
    return this.asNeeded;
  }

  /**
   * Assigns the provided DataType object value to the `asNeeded` property.
   *
   * @decorator `@ChoiceDataTypes('Dosage.asNeeded[x]')`
   *
   * @param value - the `asNeeded` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  @ChoiceDataTypes('Dosage.asNeeded[x]')
  public setAsNeeded(value: IDataType | undefined): this {
    if (isDefined<IDataType>(value)) {
      // assertFhirType<IDataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.asNeeded = value;
    } else {
      this.asNeeded = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `asNeeded` property exists and has a value; `false` otherwise
   */
  public hasAsNeeded(): boolean {
    return isDefined<IDataType>(this.asNeeded) && !this.asNeeded.isEmpty();
  }

  // *** NOTE ***
  // Following choice datatype-specific "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the `asNeeded` property value as a BooleanType object if defined; else undefined
   */
  public getAsNeededBooleanType(): BooleanType | undefined {
    if (!isDefined<IDataType | undefined>(this.asNeeded)) {
      return undefined;
    }
    if (!(this.asNeeded instanceof BooleanType)) {
      throw new InvalidTypeError(
        `DataType mismatch for Dosage.asNeeded[x]: Expected BooleanType but encountered ${this.asNeeded.fhirType()}`,
      );
    }
    return this.asNeeded;
  }

  /**
   * @returns `true` if the `asNeeded` property exists as a BooleanType and has a value; `false` otherwise
   */
  public hasAsNeededBooleanType(): boolean {
    return this.hasAsNeeded() && this.asNeeded instanceof BooleanType;
  }

  /**
   * @returns the `asNeeded` property value as a CodeableConcept object if defined; else undefined
   */
  public getAsNeededCodeableConcept(): CodeableConcept | undefined {
    if (!isDefined<IDataType | undefined>(this.asNeeded)) {
      return undefined;
    }
    if (!(this.asNeeded instanceof CodeableConcept)) {
      throw new InvalidTypeError(
        `DataType mismatch for Dosage.asNeeded[x]: Expected CodeableConcept but encountered ${this.asNeeded.fhirType()}`,
      );
    }
    return this.asNeeded;
  }

  /**
   * @returns `true` if the `asNeeded` property exists as a CodeableConcept and has a value; `false` otherwise
   */
  public hasAsNeededCodeableConcept(): boolean {
    return this.hasAsNeeded() && this.asNeeded instanceof CodeableConcept;
  }

  // End of choice datatype-specific "get"/"has" methods

  /**
   * @returns the `site` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getSite(): CodeableConcept {
    return this.site ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Site object value to the `site` property.
   *
   * @param value - the `site` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setSite(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = `Invalid Dosage.site; Provided element is not an instance of CodeableConcept.`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.site = value;
    } else {
      this.site = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `site` property exists and has a value; `false` otherwise
   */
  public hasSite(): boolean {
    return isDefined<CodeableConcept>(this.site) && !this.site.isEmpty();
  }

  /**
   * @returns the `route` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getRoute(): CodeableConcept {
    return this.route ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Route object value to the `route` property.
   *
   * @param value - the `route` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setRoute(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = `Invalid Dosage.route; Provided element is not an instance of CodeableConcept.`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.route = value;
    } else {
      this.route = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `route` property exists and has a value; `false` otherwise
   */
  public hasRoute(): boolean {
    return isDefined<CodeableConcept>(this.route) && !this.route.isEmpty();
  }

  /**
   * @returns the `method` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getMethod(): CodeableConcept {
    return this.method ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Method object value to the `method` property.
   *
   * @param value - the `method` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setMethod(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = `Invalid Dosage.method; Provided element is not an instance of CodeableConcept.`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.method = value;
    } else {
      this.method = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `method` property exists and has a value; `false` otherwise
   */
  public hasMethod(): boolean {
    return isDefined<CodeableConcept>(this.method) && !this.method.isEmpty();
  }

  /**
   * @returns the `doseAndRate` property value as a DosageDoseAndRateComponent array
   */
  public getDoseAndRate(): DosageDoseAndRateComponent[] {
    return this.doseAndRate ?? ([] as DosageDoseAndRateComponent[]);
  }

  /**
   * Assigns the provided DosageDoseAndRateComponent array value to the `doseAndRate` property.
   *
   * @param value - the `doseAndRate` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setDoseAndRate(value: DosageDoseAndRateComponent[] | undefined): this {
    if (isDefinedList<DosageDoseAndRateComponent>(value)) {
      const optErrMsg = `Invalid Dosage.doseAndRate; Provided value array has an element that is not an instance of DosageDoseAndRateComponent.`;
      assertFhirTypeList<DosageDoseAndRateComponent>(value, DosageDoseAndRateComponent, optErrMsg);
      this.doseAndRate = value;
    } else {
      this.doseAndRate = undefined;
    }
    return this;
  }

  /**
   * Add the provided DosageDoseAndRateComponent value to the `doseAndRate` array property.
   *
   * @param value - the `doseAndRate` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addDoseAndRate(value: DosageDoseAndRateComponent | undefined): this {
    if (isDefined<DosageDoseAndRateComponent>(value)) {
      const optErrMsg = `Invalid Dosage.doseAndRate; Provided element is not an instance of DosageDoseAndRateComponent.`;
      assertFhirType<DosageDoseAndRateComponent>(value, DosageDoseAndRateComponent, optErrMsg);
      this.initDoseAndRate();
      this.doseAndRate?.push(value);
    }
    return this;
  }

  /**
   * @returns `true` if the `doseAndRate` property exists and has a value; `false` otherwise
   */
  public hasDoseAndRate(): boolean {
    return isDefinedList<DosageDoseAndRateComponent>(this.doseAndRate) && this.doseAndRate.some((item: DosageDoseAndRateComponent) => !item.isEmpty());
  }

  /**
   * Initialize the `doseAndRate` property
   */
  private initDoseAndRate(): void {
    if(!this.hasDoseAndRate()) {
      this.doseAndRate = [] as DosageDoseAndRateComponent[];
    }
  }

  /**
   * @returns the `maxDosePerPeriod` property value as a Ratio object if defined; else an empty Ratio object
   */
  public getMaxDosePerPeriod(): Ratio {
    return this.maxDosePerPeriod ?? new Ratio();
  }

  /**
   * Assigns the provided MaxDosePerPeriod object value to the `maxDosePerPeriod` property.
   *
   * @param value - the `maxDosePerPeriod` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setMaxDosePerPeriod(value: Ratio | undefined): this {
    if (isDefined<Ratio>(value)) {
      const optErrMsg = `Invalid Dosage.maxDosePerPeriod; Provided element is not an instance of Ratio.`;
      assertFhirType<Ratio>(value, Ratio, optErrMsg);
      this.maxDosePerPeriod = value;
    } else {
      this.maxDosePerPeriod = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `maxDosePerPeriod` property exists and has a value; `false` otherwise
   */
  public hasMaxDosePerPeriod(): boolean {
    return isDefined<Ratio>(this.maxDosePerPeriod) && !this.maxDosePerPeriod.isEmpty();
  }

  /**
   * @returns the `maxDosePerAdministration` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getMaxDosePerAdministration(): Quantity {
    return this.maxDosePerAdministration ?? new Quantity();
  }

  /**
   * Assigns the provided MaxDosePerAdministration object value to the `maxDosePerAdministration` property.
   *
   * @param value - the `maxDosePerAdministration` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setMaxDosePerAdministration(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = `Invalid Dosage.maxDosePerAdministration; Provided element is not an instance of Quantity.`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.maxDosePerAdministration = value;
    } else {
      this.maxDosePerAdministration = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `maxDosePerAdministration` property exists and has a value; `false` otherwise
   */
  public hasMaxDosePerAdministration(): boolean {
    return isDefined<Quantity>(this.maxDosePerAdministration) && !this.maxDosePerAdministration.isEmpty();
  }

  /**
   * @returns the `maxDosePerLifetime` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getMaxDosePerLifetime(): Quantity {
    return this.maxDosePerLifetime ?? new Quantity();
  }

  /**
   * Assigns the provided MaxDosePerLifetime object value to the `maxDosePerLifetime` property.
   *
   * @param value - the `maxDosePerLifetime` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setMaxDosePerLifetime(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = `Invalid Dosage.maxDosePerLifetime; Provided element is not an instance of Quantity.`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.maxDosePerLifetime = value;
    } else {
      this.maxDosePerLifetime = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `maxDosePerLifetime` property exists and has a value; `false` otherwise
   */
  public hasMaxDosePerLifetime(): boolean {
    return isDefined<Quantity>(this.maxDosePerLifetime) && !this.maxDosePerLifetime.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Dosage';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.sequence,
      this.text,
      this.additionalInstruction,
      this.patientInstruction,
      this.timing,
      this.asNeeded,
      this.site,
      this.route,
      this.method,
      this.doseAndRate,
      this.maxDosePerPeriod,
      this.maxDosePerAdministration,
      this.maxDosePerLifetime,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Dosage {
    const dest = new Dosage();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Dosage): void {
    super.copyValues(dest);
    dest.sequence = this.sequence?.copy();
    dest.text = this.text?.copy();
    const additionalInstructionList = copyListValues<CodeableConcept>(this.additionalInstruction);
    dest.additionalInstruction = additionalInstructionList.length === 0 ? undefined : additionalInstructionList;
    dest.patientInstruction = this.patientInstruction?.copy();
    dest.timing = this.timing?.copy();
    dest.asNeeded = this.asNeeded?.copy() as IDataType;
    dest.site = this.site?.copy();
    dest.route = this.route?.copy();
    dest.method = this.method?.copy();
    const doseAndRateList = copyListValues<DosageDoseAndRateComponent>(this.doseAndRate);
    dest.doseAndRate = doseAndRateList.length === 0 ? undefined : doseAndRateList;
    dest.maxDosePerPeriod = this.maxDosePerPeriod?.copy();
    dest.maxDosePerAdministration = this.maxDosePerAdministration?.copy();
    dest.maxDosePerLifetime = this.maxDosePerLifetime?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasSequenceElement()) {
      setFhirPrimitiveJson<fhirInteger>(this.getSequenceElement(), 'sequence', jsonObj);
    }

    if (this.hasTextElement()) {
      setFhirPrimitiveJson<fhirString>(this.getTextElement(), 'text', jsonObj);
    }

    if (this.hasAdditionalInstruction()) {
      setFhirComplexListJson(this.getAdditionalInstruction(), 'additionalInstruction', jsonObj);
    }

    if (this.hasPatientInstructionElement()) {
      setFhirPrimitiveJson<fhirString>(this.getPatientInstructionElement(), 'patientInstruction', jsonObj);
    }

    if (this.hasTiming()) {
      setFhirComplexJson(this.getTiming(), 'timing', jsonObj);
    }

    if (this.hasAsNeeded()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getAsNeeded()!, 'asNeeded', jsonObj);
    }

    if (this.hasSite()) {
      setFhirComplexJson(this.getSite(), 'site', jsonObj);
    }

    if (this.hasRoute()) {
      setFhirComplexJson(this.getRoute(), 'route', jsonObj);
    }

    if (this.hasMethod()) {
      setFhirComplexJson(this.getMethod(), 'method', jsonObj);
    }

    if (this.hasDoseAndRate()) {
      setFhirComplexListJson(this.getDoseAndRate(), 'doseAndRate', jsonObj);
    }

    if (this.hasMaxDosePerPeriod()) {
      setFhirComplexJson(this.getMaxDosePerPeriod(), 'maxDosePerPeriod', jsonObj);
    }

    if (this.hasMaxDosePerAdministration()) {
      setFhirComplexJson(this.getMaxDosePerAdministration(), 'maxDosePerAdministration', jsonObj);
    }

    if (this.hasMaxDosePerLifetime()) {
      setFhirComplexJson(this.getMaxDosePerLifetime(), 'maxDosePerLifetime', jsonObj);
    }

    return jsonObj;
  }
}
/**
 * DosageDoseAndRateComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Amount of medication administered
 * - **Definition:** The amount of medication administered.
 *
 * @category Data Models: ComplexType
 * @see [FHIR Dosage](http://hl7.org/fhir/StructureDefinition/Dosage)
 */
export class DosageDoseAndRateComponent extends DataType implements IDataType {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided `DosageDoseAndRateComponent` JSON to instantiate the DosageDoseAndRateComponent data model.
   *
   * @param sourceJson - JSON representing FHIR `DosageDoseAndRateComponent`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to DosageDoseAndRateComponent
   * @returns DosageDoseAndRateComponent data model or undefined for `DosageDoseAndRateComponent`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): DosageDoseAndRateComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'DosageDoseAndRateComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new DosageDoseAndRateComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';

    const classMetadata: DecoratorMetadataObject | null = DosageDoseAndRateComponent[Symbol.metadata];
    const errorMessage = `DecoratorMetadataObject does not exist for DosageDoseAndRateComponent`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    fieldName = 'type';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = CodeableConcept.parse(classJsonObj[fieldName]!, sourceField);
      instance.setType(datatype);
    }

    fieldName = 'dose[x]';
    sourceField = `${optSourceValue}.${fieldName}`;
    const dose: IDataType | undefined = fhirParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setDose(dose);

    fieldName = 'rate[x]';
    sourceField = `${optSourceValue}.${fieldName}`;
    const rate: IDataType | undefined = fhirParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setRate(rate);

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Dosage.doseAndRate.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The kind of dose or rate specified
   * - **Definition:** The kind of dose or rate specified, for example, ordered or calculated.
   * - **Requirements:** If the type is not populated, assume to be "ordered".
   * - **FHIR Type:** `CodeableConcept`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private type_?: CodeableConcept | undefined;

  /**
   * Dosage.doseAndRate.dose[x] Element
   *
   * @decorator `@ChoiceDataTypesMeta('Dosage.doseAndRate.dose[x]', ['Range','Quantity',]`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Amount of medication per dose
   * - **Definition:** Amount of medication per dose.
   * - **Comment:** Note that this specifies the quantity of the specified medication, not the quantity for each active ingredient(s). Each ingredient amount can be communicated in the Medication resource. For example, if one wants to communicate that a tablet was 375 mg, where the dose was one tablet, you can use the Medication resource to document that the tablet was comprised of 375 mg of drug XYZ. Alternatively if the dose was 375 mg, then you may only need to use the Medication resource to indicate this was a tablet. If the example were an IV such as dopamine and you wanted to communicate that 400mg of dopamine was mixed in 500 ml of some IV solution, then this would all be communicated in the Medication resource. If the administration is not intended to be instantaneous (rate is present or timing has a duration), this can be specified to convey the total amount to be administered over the period of time as indicated by the schedule e.g. 500 ml in dose, with timing used to convey that this should be done over 4 hours.
   * - **Requirements:** The amount of therapeutic or other substance given at one administration event.
   * - **FHIR Types:**
   *     'Range',
   *     'Quantity',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('Dosage.doseAndRate.dose[x]',[
    'Range',
    'Quantity',
  ])
  private dose?: IDataType | undefined;

  /**
   * Dosage.doseAndRate.rate[x] Element
   *
   * @decorator `@ChoiceDataTypesMeta('Dosage.doseAndRate.rate[x]', ['Ratio','Range','Quantity',]`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Amount of medication per unit of time
   * - **Definition:** Amount of medication per unit of time.
   * - **Comment:** It is possible to supply both a rate and a doseQuantity to provide full details about how the medication is to be administered and supplied. If the rate is intended to change over time, depending on local rules/regulations, each change should be captured as a new version of the MedicationRequest with an updated rate, or captured with a new MedicationRequest with the new rate. It is possible to specify a rate over time (for example, 100 ml/hour) using either the rateRatio and rateQuantity.  The rateQuantity approach requires systems to have the capability to parse UCUM grammer where ml/hour is included rather than a specific ratio where the time is specified as the denominator.  Where a rate such as 500ml over 2 hours is specified, the use of rateRatio may be more semantically correct than specifying using a rateQuantity of 250 mg/hour.
   * - **Requirements:** Identifies the speed with which the medication was or will be introduced into the patient. Typically the rate for an infusion e.g. 100 ml per 1 hour or 100 ml/hr.  May also be expressed as a rate per unit of time e.g. 500 ml per 2 hours.   Other examples: 200 mcg/min or 200 mcg/1 minute; 1 liter/8 hours.  Sometimes, a rate can imply duration when expressed as total volume / duration (e.g.  500mL/2 hours implies a duration of 2 hours).  However, when rate doesn\'t imply duration (e.g. 250mL/hour), then the timing.repeat.duration is needed to convey the infuse over time period.
   * - **FHIR Types:**
   *     'Ratio',
   *     'Range',
   *     'Quantity',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('Dosage.doseAndRate.rate[x]',[
    'Ratio',
    'Range',
    'Quantity',
  ])
  private rate?: IDataType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `type_` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getType(): CodeableConcept {
    return this.type_ ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Type object value to the `type_` property.
   *
   * @param value - the `type_` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setType(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = `Invalid Dosage.doseAndRate.type; Provided element is not an instance of CodeableConcept.`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.type_ = value;
    } else {
      this.type_ = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasType(): boolean {
    return isDefined<CodeableConcept>(this.type_) && !this.type_.isEmpty();
  }

  /**
   * @returns the `dose` property value as a DataType object if defined; else undefined
   */
  public getDose(): IDataType | undefined {
    return this.dose;
  }

  /**
   * Assigns the provided DataType object value to the `dose` property.
   *
   * @decorator `@ChoiceDataTypes('Dosage.doseAndRate.dose[x]')`
   *
   * @param value - the `dose` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  @ChoiceDataTypes('Dosage.doseAndRate.dose[x]')
  public setDose(value: IDataType | undefined): this {
    if (isDefined<IDataType>(value)) {
      // assertFhirType<IDataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.dose = value;
    } else {
      this.dose = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `dose` property exists and has a value; `false` otherwise
   */
  public hasDose(): boolean {
    return isDefined<IDataType>(this.dose) && !this.dose.isEmpty();
  }

  // *** NOTE ***
  // Following choice datatype-specific "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the `dose` property value as a Range object if defined; else undefined
   */
  public getDoseRange(): Range | undefined {
    if (!isDefined<IDataType | undefined>(this.dose)) {
      return undefined;
    }
    if (!(this.dose instanceof Range)) {
      throw new InvalidTypeError(
        `DataType mismatch for Dosage.doseAndRate.dose[x]: Expected Range but encountered ${this.dose.fhirType()}`,
      );
    }
    return this.dose;
  }

  /**
   * @returns `true` if the `dose` property exists as a Range and has a value; `false` otherwise
   */
  public hasDoseRange(): boolean {
    return this.hasDose() && this.dose instanceof Range;
  }

  /**
   * @returns the `dose` property value as a Quantity object if defined; else undefined
   */
  public getDoseQuantity(): Quantity | undefined {
    if (!isDefined<IDataType | undefined>(this.dose)) {
      return undefined;
    }
    if (!(this.dose instanceof Quantity)) {
      throw new InvalidTypeError(
        `DataType mismatch for Dosage.doseAndRate.dose[x]: Expected Quantity but encountered ${this.dose.fhirType()}`,
      );
    }
    return this.dose;
  }

  /**
   * @returns `true` if the `dose` property exists as a Quantity and has a value; `false` otherwise
   */
  public hasDoseQuantity(): boolean {
    return this.hasDose() && this.dose instanceof Quantity;
  }

  // End of choice datatype-specific "get"/"has" methods

  /**
   * @returns the `rate` property value as a DataType object if defined; else undefined
   */
  public getRate(): IDataType | undefined {
    return this.rate;
  }

  /**
   * Assigns the provided DataType object value to the `rate` property.
   *
   * @decorator `@ChoiceDataTypes('Dosage.doseAndRate.rate[x]')`
   *
   * @param value - the `rate` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  @ChoiceDataTypes('Dosage.doseAndRate.rate[x]')
  public setRate(value: IDataType | undefined): this {
    if (isDefined<IDataType>(value)) {
      // assertFhirType<IDataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.rate = value;
    } else {
      this.rate = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `rate` property exists and has a value; `false` otherwise
   */
  public hasRate(): boolean {
    return isDefined<IDataType>(this.rate) && !this.rate.isEmpty();
  }

  // *** NOTE ***
  // Following choice datatype-specific "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the `rate` property value as a Ratio object if defined; else undefined
   */
  public getRateRatio(): Ratio | undefined {
    if (!isDefined<IDataType | undefined>(this.rate)) {
      return undefined;
    }
    if (!(this.rate instanceof Ratio)) {
      throw new InvalidTypeError(
        `DataType mismatch for Dosage.doseAndRate.rate[x]: Expected Ratio but encountered ${this.rate.fhirType()}`,
      );
    }
    return this.rate;
  }

  /**
   * @returns `true` if the `rate` property exists as a Ratio and has a value; `false` otherwise
   */
  public hasRateRatio(): boolean {
    return this.hasRate() && this.rate instanceof Ratio;
  }

  /**
   * @returns the `rate` property value as a Range object if defined; else undefined
   */
  public getRateRange(): Range | undefined {
    if (!isDefined<IDataType | undefined>(this.rate)) {
      return undefined;
    }
    if (!(this.rate instanceof Range)) {
      throw new InvalidTypeError(
        `DataType mismatch for Dosage.doseAndRate.rate[x]: Expected Range but encountered ${this.rate.fhirType()}`,
      );
    }
    return this.rate;
  }

  /**
   * @returns `true` if the `rate` property exists as a Range and has a value; `false` otherwise
   */
  public hasRateRange(): boolean {
    return this.hasRate() && this.rate instanceof Range;
  }

  /**
   * @returns the `rate` property value as a Quantity object if defined; else undefined
   */
  public getRateQuantity(): Quantity | undefined {
    if (!isDefined<IDataType | undefined>(this.rate)) {
      return undefined;
    }
    if (!(this.rate instanceof Quantity)) {
      throw new InvalidTypeError(
        `DataType mismatch for Dosage.doseAndRate.rate[x]: Expected Quantity but encountered ${this.rate.fhirType()}`,
      );
    }
    return this.rate;
  }

  /**
   * @returns `true` if the `rate` property exists as a Quantity and has a value; `false` otherwise
   */
  public hasRateQuantity(): boolean {
    return this.hasRate() && this.rate instanceof Quantity;
  }

  // End of choice datatype-specific "get"/"has" methods

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Dosage.doseAndRate';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.type_,
      this.dose,
      this.rate,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): DosageDoseAndRateComponent {
    const dest = new DosageDoseAndRateComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: DosageDoseAndRateComponent): void {
    super.copyValues(dest);
    dest.type_ = this.type_?.copy();
    dest.dose = this.dose?.copy() as IDataType;
    dest.rate = this.rate?.copy() as IDataType;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasType()) {
      setFhirComplexJson(this.getType(), 'type', jsonObj);
    }

    if (this.hasDose()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getDose()!, 'dose', jsonObj);
    }

    if (this.hasRate()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getRate()!, 'rate', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * Duration Class
 *
 * @remarks
 * Base StructureDefinition for Duration Type: A length of time.
 *
 * **FHIR Specification**
 * - **Short:** A length of time
 * - **Definition:** A length of time.
 * - **Comment:** The context of use may frequently define what kind of quantity this is and therefore what kind of units can be used. The context of use may also restrict the values for the comparator.
 * - **FHIR Version:** 4.3.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR Duration](http://hl7.org/fhir/StructureDefinition/Duration)
 */
export class Duration extends DataType implements IDataType {
  constructor() {
    super();

    this.quantityComparatorEnum = new QuantityComparatorEnum();
  }

  /**
   * Parse the provided `Duration` JSON to instantiate the Duration data model.
   *
   * @param sourceJson - JSON representing FHIR `Duration`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to Duration
   * @returns Duration data model or undefined for `Duration`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Duration | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Duration';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new Duration();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'value';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setValueElement(datatype);
    }

    fieldName = 'comparator';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setComparatorElement(datatype);
    }

    fieldName = 'unit';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setUnitElement(datatype);
    }

    fieldName = 'system';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = fhirParser.parseUriType(dtJson, dtSiblingJson);
      instance.setSystemElement(datatype);
    }

    fieldName = 'code';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setCodeElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Duration.value Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Numerical value (with implicit precision)
   * - **Definition:** The value of the measured amount. The value includes an implicit precision in the presentation of the value.
   * - **Comment:** The implicit precision in the value should always be honored. Monetary values have their own rules for handling precision (refer to standard accounting text books).
   * - **Requirements:** Precision is handled implicitly in almost all cases of measurement.
   * - **FHIR Type:** `decimal`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private value?: DecimalType | undefined;

  /**
   * FHIR CodeSystem: QuantityComparator
   *
   * @see {@link QuantityComparatorEnum }
   */
  private readonly quantityComparatorEnum: QuantityComparatorEnum;

  /**
   * Duration.comparator Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** < | <= | >= | > - how to understand the value
   * - **Definition:** How the value should be understood and represented - whether the actual value is greater or less than the stated value due to measurement issues; e.g. if the comparator is "<" , then the real value is < stated value.
   * - **Requirements:** Need a framework for handling measures where the value is <5ug/L or >400mg/L due to the limitations of measuring methodology.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** true
   * - **isModifierReason:** This is labeled as &quot;Is Modifier&quot; because the comparator modifies the interpretation of the value significantly. If there is no comparator, then there is no modification of the value
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  private comparator?: EnumCodeType | undefined;

  /**
   * Duration.unit Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Unit representation
   * - **Definition:** A human-readable form of the unit.
   * - **Requirements:** There are many representations for units of measure and in many contexts, particular representations are fixed and required. I.e. mcg for micrograms.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private unit?: StringType | undefined;

  /**
   * Duration.system Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** System that defines coded unit form
   * - **Definition:** The identification of the system that provides the coded form of the unit.
   * - **Requirements:** Need to know the system that defines the coded form of the unit.
   * - **FHIR Type:** `uri`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private system?: UriType | undefined;

  /**
   * Duration.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Coded form of the unit
   * - **Definition:** A computer processable form of the unit in some unit representation system.
   * - **Comment:** The preferred system is UCUM, but SNOMED CT can also be used (for customary units) or ISO 4217 for currency.  The context of use may additionally require a code from a particular system.
   * - **Requirements:** Need a computable form of the unit that is fixed across all forms. UCUM provides this for quantities, but SNOMED CT provides many units of interest.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code?: CodeType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `value` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getValueElement(): DecimalType {
    return this.value ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `value` property.
   *
   * @param element - the `value` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValueElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = `Invalid Duration.value; Provided element is not an instance of DecimalType.`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.value = element;
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `value` property exists and has a value; `false` otherwise
   */
  public hasValueElement(): boolean {
    return isDefined<DecimalType>(this.value) && !this.value.isEmpty();
  }

  /**
   * @returns the `value` property value as a fhirDecimal if defined; else undefined
   */
  public getValue(): fhirDecimal | undefined {
    return this.value?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `value` property.
   *
   * @param value - the `value` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValue(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = `Invalid Duration.value (${String(value)})`;
      this.value = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `value` property exists and has a value; `false` otherwise
   */
  public hasValue(): boolean {
    return this.hasValueElement();
  }

  /**
   * @returns the `comparator` property value as a EnumCodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public getComparatorEnumType(): EnumCodeType | undefined {
    return this.comparator;
  }

  /**
   * Assigns the provided EnumCodeType value to the `comparator` property.
   *
   * @param enumType - the `comparator` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code values
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public setComparatorEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid Duration.comparator';
      assertEnumCodeType<QuantityComparatorEnum>(enumType, QuantityComparatorEnum, errMsgPrefix);
      this.comparator = enumType;
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `comparator` property exists and has a value; `false` otherwise
   */
  public hasComparatorEnumType(): boolean {
    return isDefined<EnumCodeType>(this.comparator) && !this.comparator.isEmpty() && this.comparator.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the `comparator` property value as a CodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public getComparatorElement(): CodeType | undefined {
    if (this.comparator === undefined) {
      return undefined;
    }
    return this.comparator as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the `comparator` property.
   *
   * @param element - the `comparator` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public setComparatorElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid Duration.comparator; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.comparator = new EnumCodeType(element, this.quantityComparatorEnum);
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `comparator` property exists and has a value; `false` otherwise
   */
  public hasComparatorElement(): boolean {
    return this.hasComparatorEnumType();
  }

  /**
   * @returns the `comparator` property value as a fhirCode if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public getComparator(): fhirCode | undefined {
    if (this.comparator === undefined) {
      return undefined;
    }
    return this.comparator.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the `comparator` property.
   *
   * @param value - the `comparator` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public setComparator(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid Duration.comparator; Provided value is not an instance of fhirCode.`;
      this.comparator = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.quantityComparatorEnum);
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `comparator` property exists and has a value; `false` otherwise
   */
  public hasComparator(): boolean {
    return this.hasComparatorEnumType();
  }

  /**
   * @returns the `unit` property value as a StringType object if defined; else an empty StringType object
   */
  public getUnitElement(): StringType {
    return this.unit ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `unit` property.
   *
   * @param element - the `unit` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUnitElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid Duration.unit; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.unit = element;
    } else {
      this.unit = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `unit` property exists and has a value; `false` otherwise
   */
  public hasUnitElement(): boolean {
    return isDefined<StringType>(this.unit) && !this.unit.isEmpty();
  }

  /**
   * @returns the `unit` property value as a fhirString if defined; else undefined
   */
  public getUnit(): fhirString | undefined {
    return this.unit?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `unit` property.
   *
   * @param value - the `unit` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUnit(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid Duration.unit (${String(value)})`;
      this.unit = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.unit = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `unit` property exists and has a value; `false` otherwise
   */
  public hasUnit(): boolean {
    return this.hasUnitElement();
  }

  /**
   * @returns the `system` property value as a UriType object if defined; else an empty UriType object
   */
  public getSystemElement(): UriType {
    return this.system ?? new UriType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `system` property.
   *
   * @param element - the `system` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSystemElement(element: UriType | undefined): this {
    if (isDefined<UriType>(element)) {
      const optErrMsg = `Invalid Duration.system; Provided element is not an instance of UriType.`;
      assertFhirType<UriType>(element, UriType, optErrMsg);
      this.system = element;
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `system` property exists and has a value; `false` otherwise
   */
  public hasSystemElement(): boolean {
    return isDefined<UriType>(this.system) && !this.system.isEmpty();
  }

  /**
   * @returns the `system` property value as a fhirUri if defined; else undefined
   */
  public getSystem(): fhirUri | undefined {
    return this.system?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `system` property.
   *
   * @param value - the `system` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSystem(value: fhirUri | undefined): this {
    if (isDefined<fhirUri>(value)) {
      const optErrMsg = `Invalid Duration.system (${String(value)})`;
      this.system = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `system` property exists and has a value; `false` otherwise
   */
  public hasSystem(): boolean {
    return this.hasSystemElement();
  }

  /**
   * @returns the `code` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getCodeElement(): CodeType {
    return this.code ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `code` property.
   *
   * @param element - the `code` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCodeElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid Duration.code; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.code = element;
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `code` property exists and has a value; `false` otherwise
   */
  public hasCodeElement(): boolean {
    return isDefined<CodeType>(this.code) && !this.code.isEmpty();
  }

  /**
   * @returns the `code` property value as a fhirCode if defined; else undefined
   */
  public getCode(): fhirCode | undefined {
    return this.code?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `code` property.
   *
   * @param value - the `code` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCode(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid Duration.code (${String(value)})`;
      this.code = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `code` property exists and has a value; `false` otherwise
   */
  public hasCode(): boolean {
    return this.hasCodeElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Duration';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.value,
      this.comparator,
      this.unit,
      this.system,
      this.code,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Duration {
    const dest = new Duration();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Duration): void {
    super.copyValues(dest);
    dest.value = this.value?.copy();
    dest.comparator = this.comparator?.copy();
    dest.unit = this.unit?.copy();
    dest.system = this.system?.copy();
    dest.code = this.code?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasValueElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getValueElement(), 'value', jsonObj);
    }

    if (this.hasComparatorElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getComparatorElement()!, 'comparator', jsonObj);
    }

    if (this.hasUnitElement()) {
      setFhirPrimitiveJson<fhirString>(this.getUnitElement(), 'unit', jsonObj);
    }

    if (this.hasSystemElement()) {
      setFhirPrimitiveJson<fhirUri>(this.getSystemElement(), 'system', jsonObj);
    }

    if (this.hasCodeElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getCodeElement(), 'code', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * ElementDefinition Class
 *
 * @remarks
 * Base StructureDefinition for ElementDefinition Type: Captures constraints on each element within the resource, profile, or extension.
 *
 * **FHIR Specification**
 * - **Short:** Definition of an element in a resource or extension
 * - **Definition:** Captures constraints on each element within the resource, profile, or extension.
 * - **FHIR Version:** 4.3.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR ElementDefinition](http://hl7.org/fhir/StructureDefinition/ElementDefinition)
 */
export class ElementDefinition extends BackboneType implements IBackboneType {
  constructor(path: StringType | fhirString | null = null) {
    super();

    this.propertyRepresentationEnum = new PropertyRepresentationEnum();

    this.path = null;
    if (isDefined<StringType | fhirString>(path)) {
      if (path instanceof PrimitiveType) {
        this.setPathElement(path);
      } else {
        this.setPath(path);
      }
    }
  }

  /**
   * Parse the provided `ElementDefinition` JSON to instantiate the ElementDefinition data model.
   *
   * @param sourceJson - JSON representing FHIR `ElementDefinition`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to ElementDefinition
   * @returns ElementDefinition data model or undefined for `ElementDefinition`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): ElementDefinition | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'ElementDefinition';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new ElementDefinition();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneTypeJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const classMetadata: DecoratorMetadataObject | null = ElementDefinition[Symbol.metadata];
    const errorMessage = `DecoratorMetadataObject does not exist for ElementDefinition`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    const missingReqdProperties: string[] = [];

    fieldName = 'path';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setPathElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'representation';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: CodeType | undefined = fhirParser.parseCodeType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addRepresentationElement(datatype);
        }
      });
    }

    fieldName = 'sliceName';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setSliceNameElement(datatype);
    }

    fieldName = 'sliceIsConstraining';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'boolean';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: BooleanType | undefined = fhirParser.parseBooleanType(dtJson, dtSiblingJson);
      instance.setSliceIsConstrainingElement(datatype);
    }

    fieldName = 'label';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setLabelElement(datatype);
    }

    fieldName = 'code';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Coding | undefined = Coding.parse(dataElementJson, `${sourceField}[${String(idx)}]`);
        if (datatype !== undefined) {
          instance.addCode(datatype);
        }
      });
    }

    fieldName = 'slicing';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: ElementDefinitionSlicingComponent | undefined = ElementDefinitionSlicingComponent.parse(classJsonObj[fieldName]!, sourceField);
      instance.setSlicing(datatype);
    }

    fieldName = 'short';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setShortElement(datatype);
    }

    fieldName = 'definition';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: MarkdownType | undefined = fhirParser.parseMarkdownType(dtJson, dtSiblingJson);
      instance.setDefinitionElement(datatype);
    }

    fieldName = 'comment';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: MarkdownType | undefined = fhirParser.parseMarkdownType(dtJson, dtSiblingJson);
      instance.setCommentElement(datatype);
    }

    fieldName = 'requirements';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: MarkdownType | undefined = fhirParser.parseMarkdownType(dtJson, dtSiblingJson);
      instance.setRequirementsElement(datatype);
    }

    fieldName = 'alias';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: StringType | undefined = fhirParser.parseStringType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addAliasElement(datatype);
        }
      });
    }

    fieldName = 'min';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UnsignedIntType | undefined = fhirParser.parseUnsignedIntType(dtJson, dtSiblingJson);
      instance.setMinElement(datatype);
    }

    fieldName = 'max';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setMaxElement(datatype);
    }

    fieldName = 'base';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: ElementDefinitionBaseComponent | undefined = ElementDefinitionBaseComponent.parse(classJsonObj[fieldName]!, sourceField);
      instance.setBase(datatype);
    }

    fieldName = 'contentReference';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = fhirParser.parseUriType(dtJson, dtSiblingJson);
      instance.setContentReferenceElement(datatype);
    }

    fieldName = 'type';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: ElementDefinitionTypeComponent | undefined = ElementDefinitionTypeComponent.parse(dataElementJson, `${sourceField}[${String(idx)}]`);
        if (datatype !== undefined) {
          instance.addType(datatype);
        }
      });
    }

    fieldName = 'defaultValue[x]';
    sourceField = `${optSourceValue}.${fieldName}`;
    const defaultValue: IDataType | undefined = fhirParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setDefaultValue(defaultValue);

    fieldName = 'meaningWhenMissing';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: MarkdownType | undefined = fhirParser.parseMarkdownType(dtJson, dtSiblingJson);
      instance.setMeaningWhenMissingElement(datatype);
    }

    fieldName = 'orderMeaning';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setOrderMeaningElement(datatype);
    }

    fieldName = 'fixed[x]';
    sourceField = `${optSourceValue}.${fieldName}`;
    const fixed: IDataType | undefined = fhirParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setFixed(fixed);

    fieldName = 'pattern[x]';
    sourceField = `${optSourceValue}.${fieldName}`;
    const pattern: IDataType | undefined = fhirParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setPattern(pattern);

    fieldName = 'example';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: ElementDefinitionExampleComponent | undefined = ElementDefinitionExampleComponent.parse(dataElementJson, `${sourceField}[${String(idx)}]`);
        if (datatype !== undefined) {
          instance.addExample(datatype);
        }
      });
    }

    fieldName = 'minValue[x]';
    sourceField = `${optSourceValue}.${fieldName}`;
    const minValue: IDataType | undefined = fhirParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setMinValue(minValue);

    fieldName = 'maxValue[x]';
    sourceField = `${optSourceValue}.${fieldName}`;
    const maxValue: IDataType | undefined = fhirParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setMaxValue(maxValue);

    fieldName = 'maxLength';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: IntegerType | undefined = fhirParser.parseIntegerType(dtJson, dtSiblingJson);
      instance.setMaxLengthElement(datatype);
    }

    fieldName = 'condition';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: IdType | undefined = fhirParser.parseIdType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addConditionElement(datatype);
        }
      });
    }

    fieldName = 'constraint';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: ElementDefinitionConstraintComponent | undefined = ElementDefinitionConstraintComponent.parse(dataElementJson, `${sourceField}[${String(idx)}]`);
        if (datatype !== undefined) {
          instance.addConstraint(datatype);
        }
      });
    }

    fieldName = 'mustSupport';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'boolean';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: BooleanType | undefined = fhirParser.parseBooleanType(dtJson, dtSiblingJson);
      instance.setMustSupportElement(datatype);
    }

    fieldName = 'isModifier';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'boolean';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: BooleanType | undefined = fhirParser.parseBooleanType(dtJson, dtSiblingJson);
      instance.setIsModifierElement(datatype);
    }

    fieldName = 'isModifierReason';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setIsModifierReasonElement(datatype);
    }

    fieldName = 'isSummary';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'boolean';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: BooleanType | undefined = fhirParser.parseBooleanType(dtJson, dtSiblingJson);
      instance.setIsSummaryElement(datatype);
    }

    fieldName = 'binding';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: ElementDefinitionBindingComponent | undefined = ElementDefinitionBindingComponent.parse(classJsonObj[fieldName]!, sourceField);
      instance.setBinding(datatype);
    }

    fieldName = 'mapping';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: ElementDefinitionMappingComponent | undefined = ElementDefinitionMappingComponent.parse(dataElementJson, `${sourceField}[${String(idx)}]`);
        if (datatype !== undefined) {
          instance.addMapping(datatype);
        }
      });
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_REQD_IN_JSON} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * ElementDefinition.path Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Path of the element in the hierarchy of elements
   * - **Definition:** The path identifies the element and is expressed as a "."-separated list of ancestor elements, beginning with the name of the resource or extension.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private path: StringType | null;

  /**
   * FHIR CodeSystem: PropertyRepresentation
   *
   * @see {@link PropertyRepresentationEnum }
   */
  private readonly propertyRepresentationEnum: PropertyRepresentationEnum;

  /**
   * ElementDefinition.representation Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** xmlAttr | xmlText | typeAttr | cdaText | xhtml
   * - **Definition:** Codes that define how this element is represented in instances, when the deviation varies from the normal case.
   * - **Comment:** In resources, this is rarely used except for special cases where the representation deviates from the normal, and can only be done in the base standard (and profiles must reproduce what the base standard does). This element is used quite commonly in Logical models when the logical models represent a specific serialization format (e.g. CDA, v2 etc.).
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link PropertyRepresentationEnum }
   */
  private representation?: EnumCodeType[] | undefined;

  /**
   * ElementDefinition.sliceName Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Name for this particular element (in a set of slices)
   * - **Definition:** The name of this element definition slice, when slicing is working. The name must be a token with no dots or spaces. This is a unique name referring to a specific set of constraints applied to this element, used to provide a name to different slices of the same element.
   * - **Comment:** The name SHALL be unique within the structure within the context of the constrained resource element.  (Though to avoid confusion, uniqueness across all elements is recommended.).
   * - **Requirements:** May also be used for code generation purposes.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private sliceName?: StringType | undefined;

  /**
   * ElementDefinition.sliceIsConstraining Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** If this slice definition constrains an inherited slice definition (or not)
   * - **Definition:** If true, indicates that this slice definition is constraining a slice definition with the same name in an inherited profile. If false, the slice is not overriding any slice in an inherited profile. If missing, the slice might or might not be overriding a slice in an inherited profile, depending on the sliceName.
   * - **Comment:** If set to true, an ancestor profile SHALL have a slicing definition with this name.  If set to false, no ancestor profile is permitted to have a slicing definition with this name.
   * - **Requirements:** Allows detection of a situation where an ancestor profile adds or removes slicing with the same name where that might impact the child profile.
   * - **FHIR Type:** `boolean`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private sliceIsConstraining?: BooleanType | undefined;

  /**
   * ElementDefinition.label Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Name for element to display with or prompt for element
   * - **Definition:** A single preferred label which is the text to display beside the element indicating its meaning or to use to prompt for the element in a user display or form.
   * - **Comment:** See also the extension (http://hl7.org/fhir/StructureDefinition/elementdefinition-question)[extension-elementdefinition-question.html].
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private label?: StringType | undefined;

  /**
   * ElementDefinition.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Corresponding codes in terminologies
   * - **Definition:** A code that has the same meaning as the element in a particular terminology.
   * - **Comment:** The concept SHALL be properly aligned with the data element definition and other constraints, as defined in the code system, including relationships, of any code listed here.  Where multiple codes exist in a terminology that could correspond to the data element, the most granular code(s) should be selected, so long as they are not more restrictive than the data element itself. The mappings may be used to provide more or less granular or structured equivalences in the code system.
   * - **Requirements:** Links the meaning of an element to an external terminology, and is very useful for searching and indexing.
   * - **FHIR Type:** `Coding`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code?: Coding[] | undefined;

  /**
   * ElementDefinition.slicing Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** This element is sliced - slices follow
   * - **Definition:** Indicates that the element is sliced into a set of alternative definitions (i.e. in a structure definition, there are multiple different constraints on a single element in the base resource). Slicing can be used in any resource that has cardinality ..* on the base resource, or any resource with a choice of types. The set of slices is any elements that come after this in the element sequence that have the same path, until a shorter path occurs (the shorter path terminates the set).
   * - **Comment:** The first element in the sequence, the one that carries the slicing, is the definition that applies to all the slices. This is based on the unconstrained element, but can apply any constraints as appropriate. This may include the common constraints on the children of the element.
   * - **FHIR Type:** `Element`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private slicing?: ElementDefinitionSlicingComponent | undefined;

  /**
   * ElementDefinition.short Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Concise definition for space-constrained presentation
   * - **Definition:** A concise description of what this element means (e.g. for use in autogenerated summaries).
   * - **Comment:** It is easy for a different short definition to change the meaning of an element and this can have nasty downstream consequences. Please be careful when providing short definitions in a profile.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private short?: StringType | undefined;

  /**
   * ElementDefinition.definition Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Full formal definition as narrative text
   * - **Definition:** Provides a complete explanation of the meaning of the data element for human readability.  For the case of elements derived from existing elements (e.g. constraints), the definition SHALL be consistent with the base definition, but convey the meaning of the element in the particular context of use of the resource. (Note: The text you are reading is specified in ElementDefinition.definition).
   * - **Comment:** It is easy for a different definition to change the meaning of an element and this can have nasty downstream consequences. Please be careful when providing definitions in a profile.
   * - **Requirements:** To allow a user to state the usage of an element in a particular context.
   * - **FHIR Type:** `markdown`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private definition?: MarkdownType | undefined;

  /**
   * ElementDefinition.comment Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Comments about the use of this element
   * - **Definition:** Explanatory notes and implementation guidance about the data element, including notes about how to use the data properly, exceptions to proper use, etc. (Note: The text you are reading is specified in ElementDefinition.comment).
   * - **Comment:** If it is possible to capture usage rules using constraints, that mechanism should be used in preference to this element.
   * - **FHIR Type:** `markdown`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private comment?: MarkdownType | undefined;

  /**
   * ElementDefinition.requirements Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Why this resource has been created
   * - **Definition:** This element is for traceability of why the element was created and why the constraints exist as they do. This may be used to point to source materials or specifications that drove the structure of this element.
   * - **Comment:** This element does not describe the usage of the element (that\'s done in comments), rather it\'s for traceability of *why* the element is either needed or why the constraints exist as they do.  This may be used to point to source materials or specifications that drove the structure of this data element.
   * - **FHIR Type:** `markdown`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private requirements?: MarkdownType | undefined;

  /**
   * ElementDefinition.alias Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Other names
   * - **Definition:** Identifies additional names by which this element might also be known.
   * - **Requirements:** Allows for better easier recognition of the element by multiple communities, including international communities.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private alias?: StringType[] | undefined;

  /**
   * ElementDefinition.min Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Minimum Cardinality
   * - **Definition:** The minimum number of times this element SHALL appear in the instance.
   * - **FHIR Type:** `unsignedInt`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private min?: UnsignedIntType | undefined;

  /**
   * ElementDefinition.max Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Maximum Cardinality (a number or *)
   * - **Definition:** The maximum number of times this element is permitted to appear in the instance.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private max?: StringType | undefined;

  /**
   * ElementDefinition.base Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Base definition information for tools
   * - **Definition:** Information about the base definition of the element, provided to make it unnecessary for tools to trace the deviation of the element through the derived and related profiles. When the element definition is not the original definition of an element - i.g. either in a constraint on another type, or for elements from a super type in a snap shot - then the information in provided in the element definition may be different to the base definition. On the original definition of the element, it will be same.
   * - **Comment:** The base information does not carry any information that could not be determined from the path and related profiles, but making this determination requires both that the related profiles are available, and that the algorithm to determine them be available. For tooling simplicity, the base information must always be populated in element definitions in snap shots, even if it is the same.
   * - **FHIR Type:** `Element`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private base?: ElementDefinitionBaseComponent | undefined;

  /**
   * ElementDefinition.contentReference Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Reference to definition of content for the element
   * - **Definition:** Identifies an element defined elsewhere in the definition whose content rules should be applied to the current element. ContentReferences bring across all the rules that are in the ElementDefinition for the element, including definitions, cardinality constraints, bindings, invariants etc.
   * - **Comment:** ContentReferences can only be defined in specializations, not constrained types, and they cannot be changed and always reference the non-constrained definition.
   * - **FHIR Type:** `uri`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private contentReference?: UriType | undefined;

  /**
   * ElementDefinition.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Data type and Profile for this element
   * - **Definition:** The data type or resource that the value of this element is permitted to be.
   * - **Comment:** The Type of the element can be left blank in a differential constraint, in which case the type is inherited from the resource. Abstract types are not permitted to appear as a type when multiple types are listed.  (I.e. Abstract types cannot be part of a choice).
   * - **FHIR Type:** `Element`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private type_?: ElementDefinitionTypeComponent[] | undefined;

  /**
   * ElementDefinition.defaultValue[x] Element
   *
   * @decorator `@ChoiceDataTypesMeta('ElementDefinition.defaultValue[x]', ['base64Binary','boolean','canonical','code','date','dateTime','decimal','id','instant','integer','markdown','oid','positiveInt','string','time','unsignedInt','uri','url','uuid','Address','Age','Annotation','Attachment','CodeableConcept','CodeableReference','Coding','ContactPoint','Count','Distance','Duration','HumanName','Identifier','Money','Period','Quantity','Range','Ratio','RatioRange','Reference','SampledData','Signature','Timing','ContactDetail','Contributor','DataRequirement','Expression','ParameterDefinition','RelatedArtifact','TriggerDefinition','UsageContext','Dosage',]`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Specified value if missing from instance
   * - **Definition:** The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
   * - **Comment:** Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly.  No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
   * - **FHIR Types:**
   *     'base64Binary',
   *     'boolean',
   *     'canonical',
   *     'code',
   *     'date',
   *     'dateTime',
   *     'decimal',
   *     'id',
   *     'instant',
   *     'integer',
   *     'markdown',
   *     'oid',
   *     'positiveInt',
   *     'string',
   *     'time',
   *     'unsignedInt',
   *     'uri',
   *     'url',
   *     'uuid',
   *     'Address',
   *     'Age',
   *     'Annotation',
   *     'Attachment',
   *     'CodeableConcept',
   *     'CodeableReference',
   *     'Coding',
   *     'ContactPoint',
   *     'Count',
   *     'Distance',
   *     'Duration',
   *     'HumanName',
   *     'Identifier',
   *     'Money',
   *     'Period',
   *     'Quantity',
   *     'Range',
   *     'Ratio',
   *     'RatioRange',
   *     'Reference',
   *     'SampledData',
   *     'Signature',
   *     'Timing',
   *     'ContactDetail',
   *     'Contributor',
   *     'DataRequirement',
   *     'Expression',
   *     'ParameterDefinition',
   *     'RelatedArtifact',
   *     'TriggerDefinition',
   *     'UsageContext',
   *     'Dosage',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('ElementDefinition.defaultValue[x]',[
    'base64Binary',
    'boolean',
    'canonical',
    'code',
    'date',
    'dateTime',
    'decimal',
    'id',
    'instant',
    'integer',
    'markdown',
    'oid',
    'positiveInt',
    'string',
    'time',
    'unsignedInt',
    'uri',
    'url',
    'uuid',
    'Address',
    'Age',
    'Annotation',
    'Attachment',
    'CodeableConcept',
    'CodeableReference',
    'Coding',
    'ContactPoint',
    'Count',
    'Distance',
    'Duration',
    'HumanName',
    'Identifier',
    'Money',
    'Period',
    'Quantity',
    'Range',
    'Ratio',
    'RatioRange',
    'Reference',
    'SampledData',
    'Signature',
    'Timing',
    'ContactDetail',
    'Contributor',
    'DataRequirement',
    'Expression',
    'ParameterDefinition',
    'RelatedArtifact',
    'TriggerDefinition',
    'UsageContext',
    'Dosage',
  ])
  private defaultValue?: IDataType | undefined;

  /**
   * ElementDefinition.meaningWhenMissing Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Implicit meaning when this element is missing
   * - **Definition:** The Implicit meaning that is to be understood when this element is missing (e.g. \'when this element is missing, the period is ongoing\').
   * - **Comment:** Implicit meanings for missing values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. An implicit meaning for a missing value can never be changed, and specifying one has the consequence that constraining its use in profiles eliminates use cases as possibilities, not merely moving them out of scope.
   * - **FHIR Type:** `markdown`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private meaningWhenMissing?: MarkdownType | undefined;

  /**
   * ElementDefinition.orderMeaning Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** What the order of the elements means
   * - **Definition:** If present, indicates that the order of the repeating element has meaning and describes what that meaning is.  If absent, it means that the order of the element has no meaning.
   * - **Comment:** This element can only be asserted on repeating elements and can only be introduced when defining resources or data types.  It can be further refined profiled elements but if absent in the base type, a profile cannot assert meaning.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private orderMeaning?: StringType | undefined;

  /**
   * ElementDefinition.fixed[x] Element
   *
   * @decorator `@ChoiceDataTypesMeta('ElementDefinition.fixed[x]', ['base64Binary','boolean','canonical','code','date','dateTime','decimal','id','instant','integer','markdown','oid','positiveInt','string','time','unsignedInt','uri','url','uuid','Address','Age','Annotation','Attachment','CodeableConcept','CodeableReference','Coding','ContactPoint','Count','Distance','Duration','HumanName','Identifier','Money','Period','Quantity','Range','Ratio','RatioRange','Reference','SampledData','Signature','Timing','ContactDetail','Contributor','DataRequirement','Expression','ParameterDefinition','RelatedArtifact','TriggerDefinition','UsageContext','Dosage',]`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Value must be exactly this
   * - **Definition:** Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
   * - **Comment:** This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
   * - **FHIR Types:**
   *     'base64Binary',
   *     'boolean',
   *     'canonical',
   *     'code',
   *     'date',
   *     'dateTime',
   *     'decimal',
   *     'id',
   *     'instant',
   *     'integer',
   *     'markdown',
   *     'oid',
   *     'positiveInt',
   *     'string',
   *     'time',
   *     'unsignedInt',
   *     'uri',
   *     'url',
   *     'uuid',
   *     'Address',
   *     'Age',
   *     'Annotation',
   *     'Attachment',
   *     'CodeableConcept',
   *     'CodeableReference',
   *     'Coding',
   *     'ContactPoint',
   *     'Count',
   *     'Distance',
   *     'Duration',
   *     'HumanName',
   *     'Identifier',
   *     'Money',
   *     'Period',
   *     'Quantity',
   *     'Range',
   *     'Ratio',
   *     'RatioRange',
   *     'Reference',
   *     'SampledData',
   *     'Signature',
   *     'Timing',
   *     'ContactDetail',
   *     'Contributor',
   *     'DataRequirement',
   *     'Expression',
   *     'ParameterDefinition',
   *     'RelatedArtifact',
   *     'TriggerDefinition',
   *     'UsageContext',
   *     'Dosage',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('ElementDefinition.fixed[x]',[
    'base64Binary',
    'boolean',
    'canonical',
    'code',
    'date',
    'dateTime',
    'decimal',
    'id',
    'instant',
    'integer',
    'markdown',
    'oid',
    'positiveInt',
    'string',
    'time',
    'unsignedInt',
    'uri',
    'url',
    'uuid',
    'Address',
    'Age',
    'Annotation',
    'Attachment',
    'CodeableConcept',
    'CodeableReference',
    'Coding',
    'ContactPoint',
    'Count',
    'Distance',
    'Duration',
    'HumanName',
    'Identifier',
    'Money',
    'Period',
    'Quantity',
    'Range',
    'Ratio',
    'RatioRange',
    'Reference',
    'SampledData',
    'Signature',
    'Timing',
    'ContactDetail',
    'Contributor',
    'DataRequirement',
    'Expression',
    'ParameterDefinition',
    'RelatedArtifact',
    'TriggerDefinition',
    'UsageContext',
    'Dosage',
  ])
  private fixed?: IDataType | undefined;

  /**
   * ElementDefinition.pattern[x] Element
   *
   * @decorator `@ChoiceDataTypesMeta('ElementDefinition.pattern[x]', ['base64Binary','boolean','canonical','code','date','dateTime','decimal','id','instant','integer','markdown','oid','positiveInt','string','time','unsignedInt','uri','url','uuid','Address','Age','Annotation','Attachment','CodeableConcept','CodeableReference','Coding','ContactPoint','Count','Distance','Duration','HumanName','Identifier','Money','Period','Quantity','Range','Ratio','RatioRange','Reference','SampledData','Signature','Timing','ContactDetail','Contributor','DataRequirement','Expression','ParameterDefinition','RelatedArtifact','TriggerDefinition','UsageContext','Dosage',]`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Value must have at least these property values
   * - **Definition:** Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.   When pattern[x] is used to constrain a primitive, it means that the value provided in the pattern[x] must match the instance value exactly. When pattern[x] is used to constrain an array, it means that each element provided in the pattern[x] array must (recursively) match at least one element from the instance array. When pattern[x] is used to constrain a complex object, it means that each property in the pattern must be present in the complex object, and its value must recursively match -- i.e., 1. If primitive: it must match exactly the pattern value 2. If a complex object: it must match (recursively) the pattern value 3. If an array: it must match (recursively) the pattern value.
   * - **Comment:** Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
   * - **FHIR Types:**
   *     'base64Binary',
   *     'boolean',
   *     'canonical',
   *     'code',
   *     'date',
   *     'dateTime',
   *     'decimal',
   *     'id',
   *     'instant',
   *     'integer',
   *     'markdown',
   *     'oid',
   *     'positiveInt',
   *     'string',
   *     'time',
   *     'unsignedInt',
   *     'uri',
   *     'url',
   *     'uuid',
   *     'Address',
   *     'Age',
   *     'Annotation',
   *     'Attachment',
   *     'CodeableConcept',
   *     'CodeableReference',
   *     'Coding',
   *     'ContactPoint',
   *     'Count',
   *     'Distance',
   *     'Duration',
   *     'HumanName',
   *     'Identifier',
   *     'Money',
   *     'Period',
   *     'Quantity',
   *     'Range',
   *     'Ratio',
   *     'RatioRange',
   *     'Reference',
   *     'SampledData',
   *     'Signature',
   *     'Timing',
   *     'ContactDetail',
   *     'Contributor',
   *     'DataRequirement',
   *     'Expression',
   *     'ParameterDefinition',
   *     'RelatedArtifact',
   *     'TriggerDefinition',
   *     'UsageContext',
   *     'Dosage',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('ElementDefinition.pattern[x]',[
    'base64Binary',
    'boolean',
    'canonical',
    'code',
    'date',
    'dateTime',
    'decimal',
    'id',
    'instant',
    'integer',
    'markdown',
    'oid',
    'positiveInt',
    'string',
    'time',
    'unsignedInt',
    'uri',
    'url',
    'uuid',
    'Address',
    'Age',
    'Annotation',
    'Attachment',
    'CodeableConcept',
    'CodeableReference',
    'Coding',
    'ContactPoint',
    'Count',
    'Distance',
    'Duration',
    'HumanName',
    'Identifier',
    'Money',
    'Period',
    'Quantity',
    'Range',
    'Ratio',
    'RatioRange',
    'Reference',
    'SampledData',
    'Signature',
    'Timing',
    'ContactDetail',
    'Contributor',
    'DataRequirement',
    'Expression',
    'ParameterDefinition',
    'RelatedArtifact',
    'TriggerDefinition',
    'UsageContext',
    'Dosage',
  ])
  private pattern?: IDataType | undefined;

  /**
   * ElementDefinition.example Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Example value (as defined for type)
   * - **Definition:** A sample value for this element demonstrating the type of information that would typically be found in the element.
   * - **Comment:** Examples will most commonly be present for data where it\'s not implicitly obvious from either the data type or value set what the values might be.  (I.e. Example values for dates or quantities would generally be unnecessary.)  If the example value is fully populated, the publication tool can generate an instance automatically.
   * - **FHIR Type:** `Element`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private example?: ElementDefinitionExampleComponent[] | undefined;

  /**
   * ElementDefinition.minValue[x] Element
   *
   * @decorator `@ChoiceDataTypesMeta('ElementDefinition.minValue[x]', ['date','dateTime','instant','time','decimal','integer','positiveInt','unsignedInt','Quantity',]`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Minimum Allowed Value (for some types)
   * - **Definition:** The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   * - **Comment:** Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a [Duration](https://hl7.org/fhir/datatypes.html#Duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
   * - **FHIR Types:**
   *     'date',
   *     'dateTime',
   *     'instant',
   *     'time',
   *     'decimal',
   *     'integer',
   *     'positiveInt',
   *     'unsignedInt',
   *     'Quantity',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('ElementDefinition.minValue[x]',[
    'date',
    'dateTime',
    'instant',
    'time',
    'decimal',
    'integer',
    'positiveInt',
    'unsignedInt',
    'Quantity',
  ])
  private minValue?: IDataType | undefined;

  /**
   * ElementDefinition.maxValue[x] Element
   *
   * @decorator `@ChoiceDataTypesMeta('ElementDefinition.maxValue[x]', ['date','dateTime','instant','time','decimal','integer','positiveInt','unsignedInt','Quantity',]`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Maximum Allowed Value (for some types)
   * - **Definition:** The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
   * - **Comment:** Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a [Duration](https://hl7.org/fhir/datatypes.html#Duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
   * - **FHIR Types:**
   *     'date',
   *     'dateTime',
   *     'instant',
   *     'time',
   *     'decimal',
   *     'integer',
   *     'positiveInt',
   *     'unsignedInt',
   *     'Quantity',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('ElementDefinition.maxValue[x]',[
    'date',
    'dateTime',
    'instant',
    'time',
    'decimal',
    'integer',
    'positiveInt',
    'unsignedInt',
    'Quantity',
  ])
  private maxValue?: IDataType | undefined;

  /**
   * ElementDefinition.maxLength Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Max length for strings
   * - **Definition:** Indicates the maximum length in characters that is permitted to be present in conformant instances and which is expected to be supported by conformant consumers that support the element.
   * - **Comment:** Receivers are not required to reject instances that exceed the maximum length.  The full length could be stored.  In some cases, data might be truncated, though truncation should be undertaken with care and an understanding of the consequences of doing so. If not specified, there is no conformance expectation for length support.
   * - **FHIR Type:** `integer`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private maxLength?: IntegerType | undefined;

  /**
   * ElementDefinition.condition Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Reference to invariant about presence
   * - **Definition:** A reference to an invariant that may make additional statements about the cardinality or value in the instance.
   * - **FHIR Type:** `id`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private condition?: IdType[] | undefined;

  /**
   * ElementDefinition.constraint Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Condition that must evaluate to true
   * - **Definition:** Formal constraints such as co-occurrence and other constraints that can be computationally evaluated within the context of the instance.
   * - **Comment:** Constraints should be declared on the "context" element - the lowest element in the hierarchy that is common to all nodes referenced by the constraint.
   * - **FHIR Type:** `Element`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private constraint?: ElementDefinitionConstraintComponent[] | undefined;

  /**
   * ElementDefinition.mustSupport Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** If the element must be supported
   * - **Definition:** If true, implementations that produce or consume resources SHALL provide "support" for the element in some meaningful way.  If false, the element may be ignored and not supported. If false, whether to populate or use the data element in any way is at the discretion of the implementation.
   * - **Comment:** "Something useful" is context dependent and impossible to describe in the base FHIR specification. For this reason, tue mustSupport flag is never set to true by the FHIR specification itself - it is only set to true in profiles.  A profile on a type can always make musSupport = true if it is false in the base type but cannot make mustSupport = false if it is true in the base type.   This is done in [Resource Profiles](https://hl7.org/fhir/profiling.html#mustsupport), where the profile labels an element as mustSupport=true. When a profile does this, it SHALL also make clear exactly what kind of "support" is required, as this can mean many things.    Note that an element that has the property IsModifier is not necessarily a "key" element (e.g. one of the important elements to make use of the resource), nor is it automatically mustSupport - however both of these things are more likely to be true for IsModifier elements than for other elements.
   * - **Requirements:** Allows a profile to set expectations for system capabilities beyond merely respecting cardinality constraints.
   * - **FHIR Type:** `boolean`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private mustSupport?: BooleanType | undefined;

  /**
   * ElementDefinition.isModifier Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** If this modifies the meaning of other elements
   * - **Definition:** If true, the value of this element affects the interpretation of the element or resource that contains it, and the value of the element cannot be ignored. Typically, this is used for status, negation and qualification codes. The effect of this is that the element cannot be ignored by systems: they SHALL either recognize the element and process it, and/or a pre-determination has been made that it is not relevant to their particular system.
   * - **Comment:** Only the definition of an element can set IsModifier true - either the specification itself or where an extension is originally defined. Once set, it cannot be changed in derived profiles. An element/extension that has isModifier=true SHOULD also have a minimum cardinality of 1, so that there is no lack of clarity about what to do if it is missing. If it can be missing, the definition SHALL make the meaning of a missing element clear.
   * - **Requirements:** Allows elements to be introduced into a specification that can\'t safely be ignored by applications that don\'t recognize them.
   * - **FHIR Type:** `boolean`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private isModifier?: BooleanType | undefined;

  /**
   * ElementDefinition.isModifierReason Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Reason that this element is marked as a modifier
   * - **Definition:** Explains how that element affects the interpretation of the resource or element that contains it.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private isModifierReason?: StringType | undefined;

  /**
   * ElementDefinition.isSummary Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Include when _summary = true?
   * - **Definition:** Whether the element should be included if a client requests a search with the parameter _summary=true.
   * - **Comment:** Some resources include a set of simple metadata, and some very large data. This element is used to reduce the quantity of data returned in searches. Note that servers may pre-cache summarized resources for optimal performance, so servers might not support per-profile use of the isSummary flag. When a request is made with _summary=true, serailisers only include elements marked as \'isSummary = true\'. Other than Attachment.data, all data type properties are included in the summary form. In resource and data type definitions, if an element is at the root or has a parent that is \'mustSupport\' and the minimum cardinality is 1 or the element is a modifier, it must be marked as isSummary=true.
   * - **Requirements:** Allow clients to search through large resources quickly.
   * - **FHIR Type:** `boolean`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private isSummary?: BooleanType | undefined;

  /**
   * ElementDefinition.binding Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** ValueSet details if this is coded
   * - **Definition:** Binds to a value set if this element is coded (code, Coding, CodeableConcept, Quantity), or the data types (string, uri).
   * - **Comment:** For a CodeableConcept, when no codes are allowed - only text, use a binding of strength "required" with a description explaining that no coded values are allowed and what sort of information to put in the "text" element.
   * - **FHIR Type:** `Element`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private binding?: ElementDefinitionBindingComponent | undefined;

  /**
   * ElementDefinition.mapping Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Map element to another set of definitions
   * - **Definition:** Identifies a concept from an external specification that roughly corresponds to this element.
   * - **Comment:** Mappings are not necessarily specific enough for safe translation.
   * - **Requirements:** Provides guidance to implementers familiar with or converting content from other specifications.
   * - **FHIR Type:** `Element`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private mapping?: ElementDefinitionMappingComponent[] | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `path` property value as a StringType object if defined; else null
   */
  public getPathElement(): StringType | null {
    return this.path;
  }

  /**
   * Assigns the provided PrimitiveType value to the `path` property.
   *
   * @param element - the `path` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPathElement(element: StringType): this {
    assertIsDefined<StringType>(element, `ElementDefinition.path is required`);
    const optErrMsg = `Invalid ElementDefinition.path; Provided value is not an instance of StringType.`;
    assertFhirType<StringType>(element, StringType, optErrMsg);
    this.path = element;
    return this;
  }

  /**
   * @returns `true` if the `path` property exists and has a value; `false` otherwise
   */
  public hasPathElement(): boolean {
    return isDefined<StringType>(this.path) && !this.path.isEmpty();
  }

  /**
   * @returns the `path` property value as a fhirString if defined; else null
   */
  public getPath(): fhirString | null {
    if (this.path?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.path.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the `path` property.
   *
   * @param value - the `path` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPath(value: fhirString): this {
    assertIsDefined<fhirString>(value, `ElementDefinition.path is required`);
    const optErrMsg = `Invalid ElementDefinition.path (${String(value)})`;
    this.path = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    return this;
  }

  /**
   * @returns `true` if the `path` property exists and has a value; `false` otherwise
   */
  public hasPath(): boolean {
    return this.hasPathElement();
  }

  /**
   * @returns the `representation` property value as a EnumCodeType array
   *
   * @see CodeSystem Enumeration: {@link PropertyRepresentationEnum }
   */
  public getRepresentationEnumType(): EnumCodeType[] {
    return this.representation ?? ([] as EnumCodeType[]);
  }

  /**
   * Assigns the provided EnumCodeType array value to the `representation` property.
   *
   * @param enumType - the `representation` array value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link PropertyRepresentationEnum }
   */
  public setRepresentationEnumType(enumType: EnumCodeType[] | undefined): this {
    if (isDefinedList<EnumCodeType>(enumType)) {
      const errMsgPrefix = `Invalid ElementDefinition.representation`;
      assertEnumCodeTypeList<PropertyRepresentationEnum>(enumType, PropertyRepresentationEnum, errMsgPrefix);
      this.representation = enumType;
    } else {
      this.representation = undefined;
    }
    return this;
  }

  /**
   * Add the provided EnumCodeType value to the `representation` array property.
   *
   * @param enumType - the `representation` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   *
   * @see CodeSystem Enumeration: {@link PropertyRepresentationEnum }
   */
  public addRepresentationEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = `Invalid ElementDefinition.representation`;
      assertEnumCodeType<PropertyRepresentationEnum>(enumType, PropertyRepresentationEnum, errMsgPrefix);
      this.initRepresentation();
      this.representation?.push(enumType);
    }
    return this;
  }

  /**
   * @returns `true` if the `representation` property exists and has a value; `false` otherwise
   */
  public hasRepresentationEnumType(): boolean {
    return isDefinedList<EnumCodeType>(this.representation) && this.representation.some((item: EnumCodeType) => !item.isEmpty()) && this.representation.every((item: EnumCodeType) => item.fhirCodeEnumeration.length > 0);
  }

  /**
   * @returns the `representation` property value as a CodeType array
   *
   * @see CodeSystem Enumeration: {@link PropertyRepresentationEnum }
   */
  public getRepresentationElement(): CodeType[] {
    if (this.representation === undefined) {
      return [] as CodeType[];
    }
    return this.representation as CodeType[];
  }

  /**
   * Assigns the provided PrimitiveType array value to the `representation` property.
   *
   * @param element - the `representation` array value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link PropertyRepresentationEnum }
   */
  public setRepresentationElement(element: CodeType[] | undefined): this {
    if (isDefinedList<CodeType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.representation; Provided element array has an element that is not an instance of CodeType.`;
      assertFhirTypeList<CodeType>(element, CodeType, optErrMsg);
      const enumCodeTypes = [] as EnumCodeType[];
      element.forEach((type: CodeType) => {
        enumCodeTypes.push(new EnumCodeType(type, this.propertyRepresentationEnum));
      });
      this.representation = enumCodeTypes;
    } else {
      this.representation = undefined;
    }
    return this;
  }

  /**
   * Add the provided PrimitiveType value to the `representation` array property.
   *
   * @param element - the `representation` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link PropertyRepresentationEnum }
   */
  public addRepresentationElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.representation; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.initRepresentation();
      this.representation?.push(new EnumCodeType(element, this.propertyRepresentationEnum));
    }
    return this;
  }

  /**
   * @returns `true` if the `representation` property exists and has a value; `false` otherwise
   */
  public hasRepresentationElement(): boolean {
    return this.hasRepresentationEnumType();
  }

  /**
   * @returns the `representation` property value as a fhirCode array
   *
   * @see CodeSystem Enumeration: {@link PropertyRepresentationEnum }
   */
  public getRepresentation(): fhirCode[] {
    if (this.representation === undefined) {
      return [] as fhirCode[];
    }
    const values = [] as fhirCode[];
    for (const item of this.representation) {
      values.push(item.fhirCode.code);
    }
    return values;
  }

  /**
   * Assigns the provided primitive value array to the `representation` property.
   *
   * @param value - the `representation` value array
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link PropertyRepresentationEnum }
   */
  public setRepresentation(value: fhirCode[] | undefined): this {
    if (isDefinedList<fhirCode>(value)) {
      const enumCodeTypes = [] as EnumCodeType[];
      const optErrMsg = `Invalid ElementDefinition.representation; Provided value is not an instance of fhirCode.`;
      value.forEach((val: fhirCode) => {
        enumCodeTypes.push(new EnumCodeType(parseFhirPrimitiveData(val, fhirCodeSchema, optErrMsg), this.propertyRepresentationEnum));
      });
      this.representation = enumCodeTypes;
    } else {
      this.representation = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the `representation` array property.
   *
   * @param value - the `representation` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link PropertyRepresentationEnum }
   */
  public addRepresentation(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      this.initRepresentation();
      const optErrMsg = `Invalid ElementDefinition.representation; Provided value is not an instance of fhirCode.`;
      this.representation?.push(new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.propertyRepresentationEnum));
    }
    return this;
  }

  /**
   * @returns `true` if the `representation` property exists and has a value; `false` otherwise
   */
  public hasRepresentation(): boolean {
    return this.hasRepresentationEnumType();
  }

  /**
   * Initialize the representation property
   */
  private initRepresentation(): void {
    if(!this.hasRepresentationEnumType()) {
      this.representation = [] as EnumCodeType[];
    }
  }

  /**
   * @returns the `sliceName` property value as a StringType object if defined; else an empty StringType object
   */
  public getSliceNameElement(): StringType {
    return this.sliceName ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `sliceName` property.
   *
   * @param element - the `sliceName` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSliceNameElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.sliceName; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.sliceName = element;
    } else {
      this.sliceName = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `sliceName` property exists and has a value; `false` otherwise
   */
  public hasSliceNameElement(): boolean {
    return isDefined<StringType>(this.sliceName) && !this.sliceName.isEmpty();
  }

  /**
   * @returns the `sliceName` property value as a fhirString if defined; else undefined
   */
  public getSliceName(): fhirString | undefined {
    return this.sliceName?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `sliceName` property.
   *
   * @param value - the `sliceName` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSliceName(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid ElementDefinition.sliceName (${String(value)})`;
      this.sliceName = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.sliceName = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `sliceName` property exists and has a value; `false` otherwise
   */
  public hasSliceName(): boolean {
    return this.hasSliceNameElement();
  }

  /**
   * @returns the `sliceIsConstraining` property value as a BooleanType object if defined; else an empty BooleanType object
   */
  public getSliceIsConstrainingElement(): BooleanType {
    return this.sliceIsConstraining ?? new BooleanType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `sliceIsConstraining` property.
   *
   * @param element - the `sliceIsConstraining` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSliceIsConstrainingElement(element: BooleanType | undefined): this {
    if (isDefined<BooleanType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.sliceIsConstraining; Provided element is not an instance of BooleanType.`;
      assertFhirType<BooleanType>(element, BooleanType, optErrMsg);
      this.sliceIsConstraining = element;
    } else {
      this.sliceIsConstraining = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `sliceIsConstraining` property exists and has a value; `false` otherwise
   */
  public hasSliceIsConstrainingElement(): boolean {
    return isDefined<BooleanType>(this.sliceIsConstraining) && !this.sliceIsConstraining.isEmpty();
  }

  /**
   * @returns the `sliceIsConstraining` property value as a fhirBoolean if defined; else undefined
   */
  public getSliceIsConstraining(): fhirBoolean | undefined {
    return this.sliceIsConstraining?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `sliceIsConstraining` property.
   *
   * @param value - the `sliceIsConstraining` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSliceIsConstraining(value: fhirBoolean | undefined): this {
    if (isDefined<fhirBoolean>(value)) {
      const optErrMsg = `Invalid ElementDefinition.sliceIsConstraining (${String(value)})`;
      this.sliceIsConstraining = new BooleanType(parseFhirPrimitiveData(value, fhirBooleanSchema, optErrMsg));
    } else {
      this.sliceIsConstraining = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `sliceIsConstraining` property exists and has a value; `false` otherwise
   */
  public hasSliceIsConstraining(): boolean {
    return this.hasSliceIsConstrainingElement();
  }

  /**
   * @returns the `label` property value as a StringType object if defined; else an empty StringType object
   */
  public getLabelElement(): StringType {
    return this.label ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `label` property.
   *
   * @param element - the `label` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLabelElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.label; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.label = element;
    } else {
      this.label = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `label` property exists and has a value; `false` otherwise
   */
  public hasLabelElement(): boolean {
    return isDefined<StringType>(this.label) && !this.label.isEmpty();
  }

  /**
   * @returns the `label` property value as a fhirString if defined; else undefined
   */
  public getLabel(): fhirString | undefined {
    return this.label?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `label` property.
   *
   * @param value - the `label` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLabel(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid ElementDefinition.label (${String(value)})`;
      this.label = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.label = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `label` property exists and has a value; `false` otherwise
   */
  public hasLabel(): boolean {
    return this.hasLabelElement();
  }

  /**
   * @returns the `code` property value as a Coding array
   */
  public getCode(): Coding[] {
    return this.code ?? ([] as Coding[]);
  }

  /**
   * Assigns the provided Coding array value to the `code` property.
   *
   * @param value - the `code` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setCode(value: Coding[] | undefined): this {
    if (isDefinedList<Coding>(value)) {
      const optErrMsg = `Invalid ElementDefinition.code; Provided value array has an element that is not an instance of Coding.`;
      assertFhirTypeList<Coding>(value, Coding, optErrMsg);
      this.code = value;
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * Add the provided Coding value to the `code` array property.
   *
   * @param value - the `code` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addCode(value: Coding | undefined): this {
    if (isDefined<Coding>(value)) {
      const optErrMsg = `Invalid ElementDefinition.code; Provided element is not an instance of Coding.`;
      assertFhirType<Coding>(value, Coding, optErrMsg);
      this.initCode();
      this.code?.push(value);
    }
    return this;
  }

  /**
   * @returns `true` if the `code` property exists and has a value; `false` otherwise
   */
  public hasCode(): boolean {
    return isDefinedList<Coding>(this.code) && this.code.some((item: Coding) => !item.isEmpty());
  }

  /**
   * Initialize the `code` property
   */
  private initCode(): void {
    if(!this.hasCode()) {
      this.code = [] as Coding[];
    }
  }

  /**
   * @returns the `slicing` property value as a ElementDefinitionSlicingComponent object if defined; else an empty ElementDefinitionSlicingComponent object
   */
  public getSlicing(): ElementDefinitionSlicingComponent {
    return this.slicing ?? new ElementDefinitionSlicingComponent();
  }

  /**
   * Assigns the provided Slicing object value to the `slicing` property.
   *
   * @param value - the `slicing` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setSlicing(value: ElementDefinitionSlicingComponent | undefined): this {
    if (isDefined<ElementDefinitionSlicingComponent>(value)) {
      const optErrMsg = `Invalid ElementDefinition.slicing; Provided element is not an instance of ElementDefinitionSlicingComponent.`;
      assertFhirType<ElementDefinitionSlicingComponent>(value, ElementDefinitionSlicingComponent, optErrMsg);
      this.slicing = value;
    } else {
      this.slicing = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `slicing` property exists and has a value; `false` otherwise
   */
  public hasSlicing(): boolean {
    return isDefined<ElementDefinitionSlicingComponent>(this.slicing) && !this.slicing.isEmpty();
  }

  /**
   * @returns the `short` property value as a StringType object if defined; else an empty StringType object
   */
  public getShortElement(): StringType {
    return this.short ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `short` property.
   *
   * @param element - the `short` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setShortElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.short; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.short = element;
    } else {
      this.short = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `short` property exists and has a value; `false` otherwise
   */
  public hasShortElement(): boolean {
    return isDefined<StringType>(this.short) && !this.short.isEmpty();
  }

  /**
   * @returns the `short` property value as a fhirString if defined; else undefined
   */
  public getShort(): fhirString | undefined {
    return this.short?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `short` property.
   *
   * @param value - the `short` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setShort(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid ElementDefinition.short (${String(value)})`;
      this.short = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.short = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `short` property exists and has a value; `false` otherwise
   */
  public hasShort(): boolean {
    return this.hasShortElement();
  }

  /**
   * @returns the `definition` property value as a MarkdownType object if defined; else an empty MarkdownType object
   */
  public getDefinitionElement(): MarkdownType {
    return this.definition ?? new MarkdownType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `definition` property.
   *
   * @param element - the `definition` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDefinitionElement(element: MarkdownType | undefined): this {
    if (isDefined<MarkdownType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.definition; Provided element is not an instance of MarkdownType.`;
      assertFhirType<MarkdownType>(element, MarkdownType, optErrMsg);
      this.definition = element;
    } else {
      this.definition = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `definition` property exists and has a value; `false` otherwise
   */
  public hasDefinitionElement(): boolean {
    return isDefined<MarkdownType>(this.definition) && !this.definition.isEmpty();
  }

  /**
   * @returns the `definition` property value as a fhirMarkdown if defined; else undefined
   */
  public getDefinition(): fhirMarkdown | undefined {
    return this.definition?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `definition` property.
   *
   * @param value - the `definition` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDefinition(value: fhirMarkdown | undefined): this {
    if (isDefined<fhirMarkdown>(value)) {
      const optErrMsg = `Invalid ElementDefinition.definition (${String(value)})`;
      this.definition = new MarkdownType(parseFhirPrimitiveData(value, fhirMarkdownSchema, optErrMsg));
    } else {
      this.definition = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `definition` property exists and has a value; `false` otherwise
   */
  public hasDefinition(): boolean {
    return this.hasDefinitionElement();
  }

  /**
   * @returns the `comment` property value as a MarkdownType object if defined; else an empty MarkdownType object
   */
  public getCommentElement(): MarkdownType {
    return this.comment ?? new MarkdownType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `comment` property.
   *
   * @param element - the `comment` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCommentElement(element: MarkdownType | undefined): this {
    if (isDefined<MarkdownType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.comment; Provided element is not an instance of MarkdownType.`;
      assertFhirType<MarkdownType>(element, MarkdownType, optErrMsg);
      this.comment = element;
    } else {
      this.comment = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `comment` property exists and has a value; `false` otherwise
   */
  public hasCommentElement(): boolean {
    return isDefined<MarkdownType>(this.comment) && !this.comment.isEmpty();
  }

  /**
   * @returns the `comment` property value as a fhirMarkdown if defined; else undefined
   */
  public getComment(): fhirMarkdown | undefined {
    return this.comment?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `comment` property.
   *
   * @param value - the `comment` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setComment(value: fhirMarkdown | undefined): this {
    if (isDefined<fhirMarkdown>(value)) {
      const optErrMsg = `Invalid ElementDefinition.comment (${String(value)})`;
      this.comment = new MarkdownType(parseFhirPrimitiveData(value, fhirMarkdownSchema, optErrMsg));
    } else {
      this.comment = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `comment` property exists and has a value; `false` otherwise
   */
  public hasComment(): boolean {
    return this.hasCommentElement();
  }

  /**
   * @returns the `requirements` property value as a MarkdownType object if defined; else an empty MarkdownType object
   */
  public getRequirementsElement(): MarkdownType {
    return this.requirements ?? new MarkdownType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `requirements` property.
   *
   * @param element - the `requirements` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setRequirementsElement(element: MarkdownType | undefined): this {
    if (isDefined<MarkdownType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.requirements; Provided element is not an instance of MarkdownType.`;
      assertFhirType<MarkdownType>(element, MarkdownType, optErrMsg);
      this.requirements = element;
    } else {
      this.requirements = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `requirements` property exists and has a value; `false` otherwise
   */
  public hasRequirementsElement(): boolean {
    return isDefined<MarkdownType>(this.requirements) && !this.requirements.isEmpty();
  }

  /**
   * @returns the `requirements` property value as a fhirMarkdown if defined; else undefined
   */
  public getRequirements(): fhirMarkdown | undefined {
    return this.requirements?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `requirements` property.
   *
   * @param value - the `requirements` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setRequirements(value: fhirMarkdown | undefined): this {
    if (isDefined<fhirMarkdown>(value)) {
      const optErrMsg = `Invalid ElementDefinition.requirements (${String(value)})`;
      this.requirements = new MarkdownType(parseFhirPrimitiveData(value, fhirMarkdownSchema, optErrMsg));
    } else {
      this.requirements = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `requirements` property exists and has a value; `false` otherwise
   */
  public hasRequirements(): boolean {
    return this.hasRequirementsElement();
  }

  /**
   * @returns the `alias` property value as a StringType array
   */
  public getAliasElement(): StringType[] {
    return this.alias ?? ([] as StringType[]);
  }

  /**
   * Assigns the provided StringType array value to the `alias` property.
   *
   * @param element - the `alias` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAliasElement(element: StringType[] | undefined): this {
    if (isDefinedList<StringType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.alias; Provided value array has an element that is not an instance of StringType.`;
      assertFhirTypeList<StringType>(element, StringType, optErrMsg);
      this.alias = element;
    } else {
      this.alias = undefined;
    }
    return this;
  }

  /**
   * Add the provided StringType value to the `alias` array property.
   *
   * @param element - the `alias` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addAliasElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.alias; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.initAlias();
      this.alias?.push(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `alias` property exists and has a value; `false` otherwise
   */
  public hasAliasElement(): boolean {
    return isDefinedList<StringType>(this.alias) && this.alias.some((item: StringType) => !item.isEmpty());
  }

  /**
   * @returns the `alias` property value as a fhirString array
   */
  public getAlias(): fhirString[] {
    this.initAlias();
    const aliasValues = [] as fhirString[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.alias!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        aliasValues.push(value);
      }
    }
    return aliasValues;
  }

  /**
   * Assigns the provided primitive value array to the `alias` property.
   *
   * @param value - the `alias` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setAlias(value: fhirString[] | undefined): this {
    if (isDefinedList<fhirString>(value)) {
      const aliasElements = [] as StringType[];
      for (const aliasValue of value) {
        const optErrMsg = `Invalid ElementDefinition.alias array item (${String(aliasValue)})`;
        const element = new StringType(parseFhirPrimitiveData(aliasValue, fhirStringSchema, optErrMsg));
        aliasElements.push(element);
      }
      this.alias = aliasElements;
    } else {
      this.alias = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the `alias` array property.
   *
   * @param value - the `alias` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addAlias(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid ElementDefinition.alias array item (${String(value)})`;
      const element = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
      this.initAlias();
      this.addAliasElement(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `alias` property exists and has a value; `false` otherwise
   */
  public hasAlias(): boolean {
    return this.hasAliasElement();
  }

  /**
   * Initialize the `alias` property
   */
  private initAlias(): void {
    if (!this.hasAlias()) {
      this.alias = [] as StringType[];
    }
  }

  /**
   * @returns the `min` property value as a UnsignedIntType object if defined; else an empty UnsignedIntType object
   */
  public getMinElement(): UnsignedIntType {
    return this.min ?? new UnsignedIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `min` property.
   *
   * @param element - the `min` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMinElement(element: UnsignedIntType | undefined): this {
    if (isDefined<UnsignedIntType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.min; Provided element is not an instance of UnsignedIntType.`;
      assertFhirType<UnsignedIntType>(element, UnsignedIntType, optErrMsg);
      this.min = element;
    } else {
      this.min = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `min` property exists and has a value; `false` otherwise
   */
  public hasMinElement(): boolean {
    return isDefined<UnsignedIntType>(this.min) && !this.min.isEmpty();
  }

  /**
   * @returns the `min` property value as a fhirUnsignedInt if defined; else undefined
   */
  public getMin(): fhirUnsignedInt | undefined {
    return this.min?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `min` property.
   *
   * @param value - the `min` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMin(value: fhirUnsignedInt | undefined): this {
    if (isDefined<fhirUnsignedInt>(value)) {
      const optErrMsg = `Invalid ElementDefinition.min (${String(value)})`;
      this.min = new UnsignedIntType(parseFhirPrimitiveData(value, fhirUnsignedIntSchema, optErrMsg));
    } else {
      this.min = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `min` property exists and has a value; `false` otherwise
   */
  public hasMin(): boolean {
    return this.hasMinElement();
  }

  /**
   * @returns the `max` property value as a StringType object if defined; else an empty StringType object
   */
  public getMaxElement(): StringType {
    return this.max ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `max` property.
   *
   * @param element - the `max` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMaxElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.max; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.max = element;
    } else {
      this.max = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `max` property exists and has a value; `false` otherwise
   */
  public hasMaxElement(): boolean {
    return isDefined<StringType>(this.max) && !this.max.isEmpty();
  }

  /**
   * @returns the `max` property value as a fhirString if defined; else undefined
   */
  public getMax(): fhirString | undefined {
    return this.max?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `max` property.
   *
   * @param value - the `max` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMax(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid ElementDefinition.max (${String(value)})`;
      this.max = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.max = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `max` property exists and has a value; `false` otherwise
   */
  public hasMax(): boolean {
    return this.hasMaxElement();
  }

  /**
   * @returns the `base` property value as a ElementDefinitionBaseComponent object if defined; else an empty ElementDefinitionBaseComponent object
   */
  public getBase(): ElementDefinitionBaseComponent {
    return this.base ?? new ElementDefinitionBaseComponent();
  }

  /**
   * Assigns the provided Base object value to the `base` property.
   *
   * @param value - the `base` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setBase(value: ElementDefinitionBaseComponent | undefined): this {
    if (isDefined<ElementDefinitionBaseComponent>(value)) {
      const optErrMsg = `Invalid ElementDefinition.base; Provided element is not an instance of ElementDefinitionBaseComponent.`;
      assertFhirType<ElementDefinitionBaseComponent>(value, ElementDefinitionBaseComponent, optErrMsg);
      this.base = value;
    } else {
      this.base = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `base` property exists and has a value; `false` otherwise
   */
  public hasBase(): boolean {
    return isDefined<ElementDefinitionBaseComponent>(this.base) && !this.base.isEmpty();
  }

  /**
   * @returns the `contentReference` property value as a UriType object if defined; else an empty UriType object
   */
  public getContentReferenceElement(): UriType {
    return this.contentReference ?? new UriType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `contentReference` property.
   *
   * @param element - the `contentReference` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setContentReferenceElement(element: UriType | undefined): this {
    if (isDefined<UriType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.contentReference; Provided element is not an instance of UriType.`;
      assertFhirType<UriType>(element, UriType, optErrMsg);
      this.contentReference = element;
    } else {
      this.contentReference = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `contentReference` property exists and has a value; `false` otherwise
   */
  public hasContentReferenceElement(): boolean {
    return isDefined<UriType>(this.contentReference) && !this.contentReference.isEmpty();
  }

  /**
   * @returns the `contentReference` property value as a fhirUri if defined; else undefined
   */
  public getContentReference(): fhirUri | undefined {
    return this.contentReference?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `contentReference` property.
   *
   * @param value - the `contentReference` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setContentReference(value: fhirUri | undefined): this {
    if (isDefined<fhirUri>(value)) {
      const optErrMsg = `Invalid ElementDefinition.contentReference (${String(value)})`;
      this.contentReference = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    } else {
      this.contentReference = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `contentReference` property exists and has a value; `false` otherwise
   */
  public hasContentReference(): boolean {
    return this.hasContentReferenceElement();
  }

  /**
   * @returns the `type_` property value as a ElementDefinitionTypeComponent array
   */
  public getType(): ElementDefinitionTypeComponent[] {
    return this.type_ ?? ([] as ElementDefinitionTypeComponent[]);
  }

  /**
   * Assigns the provided ElementDefinitionTypeComponent array value to the `type_` property.
   *
   * @param value - the `type_` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setType(value: ElementDefinitionTypeComponent[] | undefined): this {
    if (isDefinedList<ElementDefinitionTypeComponent>(value)) {
      const optErrMsg = `Invalid ElementDefinition.type; Provided value array has an element that is not an instance of ElementDefinitionTypeComponent.`;
      assertFhirTypeList<ElementDefinitionTypeComponent>(value, ElementDefinitionTypeComponent, optErrMsg);
      this.type_ = value;
    } else {
      this.type_ = undefined;
    }
    return this;
  }

  /**
   * Add the provided ElementDefinitionTypeComponent value to the `type_` array property.
   *
   * @param value - the `type_` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addType(value: ElementDefinitionTypeComponent | undefined): this {
    if (isDefined<ElementDefinitionTypeComponent>(value)) {
      const optErrMsg = `Invalid ElementDefinition.type; Provided element is not an instance of ElementDefinitionTypeComponent.`;
      assertFhirType<ElementDefinitionTypeComponent>(value, ElementDefinitionTypeComponent, optErrMsg);
      this.initType();
      this.type_?.push(value);
    }
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasType(): boolean {
    return isDefinedList<ElementDefinitionTypeComponent>(this.type_) && this.type_.some((item: ElementDefinitionTypeComponent) => !item.isEmpty());
  }

  /**
   * Initialize the `type_` property
   */
  private initType(): void {
    if(!this.hasType()) {
      this.type_ = [] as ElementDefinitionTypeComponent[];
    }
  }

  /**
   * @returns the `defaultValue` property value as a DataType object if defined; else undefined
   */
  public getDefaultValue(): IDataType | undefined {
    return this.defaultValue;
  }

  /**
   * Assigns the provided DataType object value to the `defaultValue` property.
   *
   * @decorator `@ChoiceDataTypes('ElementDefinition.defaultValue[x]')`
   *
   * @param value - the `defaultValue` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  @ChoiceDataTypes('ElementDefinition.defaultValue[x]')
  public setDefaultValue(value: IDataType | undefined): this {
    if (isDefined<IDataType>(value)) {
      // assertFhirType<IDataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.defaultValue = value;
    } else {
      this.defaultValue = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `defaultValue` property exists and has a value; `false` otherwise
   */
  public hasDefaultValue(): boolean {
    return isDefined<IDataType>(this.defaultValue) && !this.defaultValue.isEmpty();
  }

  // *** NOTE ***
  // Following choice datatype-specific "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the `defaultValue` property value as a Base64BinaryType object if defined; else undefined
   */
  public getDefaultValueBase64BinaryType(): Base64BinaryType | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof Base64BinaryType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected Base64BinaryType but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a Base64BinaryType and has a value; `false` otherwise
   */
  public hasDefaultValueBase64BinaryType(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof Base64BinaryType;
  }

  /**
   * @returns the `defaultValue` property value as a BooleanType object if defined; else undefined
   */
  public getDefaultValueBooleanType(): BooleanType | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof BooleanType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected BooleanType but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a BooleanType and has a value; `false` otherwise
   */
  public hasDefaultValueBooleanType(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof BooleanType;
  }

  /**
   * @returns the `defaultValue` property value as a CanonicalType object if defined; else undefined
   */
  public getDefaultValueCanonicalType(): CanonicalType | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof CanonicalType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected CanonicalType but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a CanonicalType and has a value; `false` otherwise
   */
  public hasDefaultValueCanonicalType(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof CanonicalType;
  }

  /**
   * @returns the `defaultValue` property value as a CodeType object if defined; else undefined
   */
  public getDefaultValueCodeType(): CodeType | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof CodeType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected CodeType but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a CodeType and has a value; `false` otherwise
   */
  public hasDefaultValueCodeType(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof CodeType;
  }

  /**
   * @returns the `defaultValue` property value as a DateType object if defined; else undefined
   */
  public getDefaultValueDateType(): DateType | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof DateType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected DateType but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a DateType and has a value; `false` otherwise
   */
  public hasDefaultValueDateType(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof DateType;
  }

  /**
   * @returns the `defaultValue` property value as a DateTimeType object if defined; else undefined
   */
  public getDefaultValueDateTimeType(): DateTimeType | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof DateTimeType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected DateTimeType but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a DateTimeType and has a value; `false` otherwise
   */
  public hasDefaultValueDateTimeType(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof DateTimeType;
  }

  /**
   * @returns the `defaultValue` property value as a DecimalType object if defined; else undefined
   */
  public getDefaultValueDecimalType(): DecimalType | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof DecimalType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected DecimalType but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a DecimalType and has a value; `false` otherwise
   */
  public hasDefaultValueDecimalType(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof DecimalType;
  }

  /**
   * @returns the `defaultValue` property value as a IdType object if defined; else undefined
   */
  public getDefaultValueIdType(): IdType | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof IdType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected IdType but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a IdType and has a value; `false` otherwise
   */
  public hasDefaultValueIdType(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof IdType;
  }

  /**
   * @returns the `defaultValue` property value as a InstantType object if defined; else undefined
   */
  public getDefaultValueInstantType(): InstantType | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof InstantType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected InstantType but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a InstantType and has a value; `false` otherwise
   */
  public hasDefaultValueInstantType(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof InstantType;
  }

  /**
   * @returns the `defaultValue` property value as a IntegerType object if defined; else undefined
   */
  public getDefaultValueIntegerType(): IntegerType | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof IntegerType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected IntegerType but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a IntegerType and has a value; `false` otherwise
   */
  public hasDefaultValueIntegerType(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof IntegerType;
  }

  /**
   * @returns the `defaultValue` property value as a MarkdownType object if defined; else undefined
   */
  public getDefaultValueMarkdownType(): MarkdownType | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof MarkdownType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected MarkdownType but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a MarkdownType and has a value; `false` otherwise
   */
  public hasDefaultValueMarkdownType(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof MarkdownType;
  }

  /**
   * @returns the `defaultValue` property value as a OidType object if defined; else undefined
   */
  public getDefaultValueOidType(): OidType | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof OidType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected OidType but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a OidType and has a value; `false` otherwise
   */
  public hasDefaultValueOidType(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof OidType;
  }

  /**
   * @returns the `defaultValue` property value as a PositiveIntType object if defined; else undefined
   */
  public getDefaultValuePositiveIntType(): PositiveIntType | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof PositiveIntType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected PositiveIntType but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a PositiveIntType and has a value; `false` otherwise
   */
  public hasDefaultValuePositiveIntType(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof PositiveIntType;
  }

  /**
   * @returns the `defaultValue` property value as a StringType object if defined; else undefined
   */
  public getDefaultValueStringType(): StringType | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof StringType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected StringType but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a StringType and has a value; `false` otherwise
   */
  public hasDefaultValueStringType(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof StringType;
  }

  /**
   * @returns the `defaultValue` property value as a TimeType object if defined; else undefined
   */
  public getDefaultValueTimeType(): TimeType | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof TimeType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected TimeType but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a TimeType and has a value; `false` otherwise
   */
  public hasDefaultValueTimeType(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof TimeType;
  }

  /**
   * @returns the `defaultValue` property value as a UnsignedIntType object if defined; else undefined
   */
  public getDefaultValueUnsignedIntType(): UnsignedIntType | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof UnsignedIntType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected UnsignedIntType but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a UnsignedIntType and has a value; `false` otherwise
   */
  public hasDefaultValueUnsignedIntType(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof UnsignedIntType;
  }

  /**
   * @returns the `defaultValue` property value as a UriType object if defined; else undefined
   */
  public getDefaultValueUriType(): UriType | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof UriType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected UriType but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a UriType and has a value; `false` otherwise
   */
  public hasDefaultValueUriType(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof UriType;
  }

  /**
   * @returns the `defaultValue` property value as a UrlType object if defined; else undefined
   */
  public getDefaultValueUrlType(): UrlType | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof UrlType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected UrlType but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a UrlType and has a value; `false` otherwise
   */
  public hasDefaultValueUrlType(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof UrlType;
  }

  /**
   * @returns the `defaultValue` property value as a UuidType object if defined; else undefined
   */
  public getDefaultValueUuidType(): UuidType | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof UuidType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected UuidType but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a UuidType and has a value; `false` otherwise
   */
  public hasDefaultValueUuidType(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof UuidType;
  }

  /**
   * @returns the `defaultValue` property value as a Address object if defined; else undefined
   */
  public getDefaultValueAddress(): Address | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof Address)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected Address but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a Address and has a value; `false` otherwise
   */
  public hasDefaultValueAddress(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof Address;
  }

  /**
   * @returns the `defaultValue` property value as a Age object if defined; else undefined
   */
  public getDefaultValueAge(): Age | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof Age)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected Age but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a Age and has a value; `false` otherwise
   */
  public hasDefaultValueAge(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof Age;
  }

  /**
   * @returns the `defaultValue` property value as a Annotation object if defined; else undefined
   */
  public getDefaultValueAnnotation(): Annotation | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof Annotation)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected Annotation but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a Annotation and has a value; `false` otherwise
   */
  public hasDefaultValueAnnotation(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof Annotation;
  }

  /**
   * @returns the `defaultValue` property value as a Attachment object if defined; else undefined
   */
  public getDefaultValueAttachment(): Attachment | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof Attachment)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected Attachment but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a Attachment and has a value; `false` otherwise
   */
  public hasDefaultValueAttachment(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof Attachment;
  }

  /**
   * @returns the `defaultValue` property value as a CodeableConcept object if defined; else undefined
   */
  public getDefaultValueCodeableConcept(): CodeableConcept | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof CodeableConcept)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected CodeableConcept but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a CodeableConcept and has a value; `false` otherwise
   */
  public hasDefaultValueCodeableConcept(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof CodeableConcept;
  }

  /**
   * @returns the `defaultValue` property value as a CodeableReference object if defined; else undefined
   */
  public getDefaultValueCodeableReference(): CodeableReference | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof CodeableReference)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected CodeableReference but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a CodeableReference and has a value; `false` otherwise
   */
  public hasDefaultValueCodeableReference(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof CodeableReference;
  }

  /**
   * @returns the `defaultValue` property value as a Coding object if defined; else undefined
   */
  public getDefaultValueCoding(): Coding | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof Coding)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected Coding but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a Coding and has a value; `false` otherwise
   */
  public hasDefaultValueCoding(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof Coding;
  }

  /**
   * @returns the `defaultValue` property value as a ContactPoint object if defined; else undefined
   */
  public getDefaultValueContactPoint(): ContactPoint | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof ContactPoint)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected ContactPoint but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a ContactPoint and has a value; `false` otherwise
   */
  public hasDefaultValueContactPoint(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof ContactPoint;
  }

  /**
   * @returns the `defaultValue` property value as a Count object if defined; else undefined
   */
  public getDefaultValueCount(): Count | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof Count)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected Count but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a Count and has a value; `false` otherwise
   */
  public hasDefaultValueCount(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof Count;
  }

  /**
   * @returns the `defaultValue` property value as a Distance object if defined; else undefined
   */
  public getDefaultValueDistance(): Distance | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof Distance)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected Distance but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a Distance and has a value; `false` otherwise
   */
  public hasDefaultValueDistance(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof Distance;
  }

  /**
   * @returns the `defaultValue` property value as a Duration object if defined; else undefined
   */
  public getDefaultValueDuration(): Duration | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof Duration)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected Duration but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a Duration and has a value; `false` otherwise
   */
  public hasDefaultValueDuration(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof Duration;
  }

  /**
   * @returns the `defaultValue` property value as a HumanName object if defined; else undefined
   */
  public getDefaultValueHumanName(): HumanName | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof HumanName)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected HumanName but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a HumanName and has a value; `false` otherwise
   */
  public hasDefaultValueHumanName(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof HumanName;
  }

  /**
   * @returns the `defaultValue` property value as a Identifier object if defined; else undefined
   */
  public getDefaultValueIdentifier(): Identifier | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof Identifier)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected Identifier but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a Identifier and has a value; `false` otherwise
   */
  public hasDefaultValueIdentifier(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof Identifier;
  }

  /**
   * @returns the `defaultValue` property value as a Money object if defined; else undefined
   */
  public getDefaultValueMoney(): Money | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof Money)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected Money but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a Money and has a value; `false` otherwise
   */
  public hasDefaultValueMoney(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof Money;
  }

  /**
   * @returns the `defaultValue` property value as a Period object if defined; else undefined
   */
  public getDefaultValuePeriod(): Period | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof Period)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected Period but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a Period and has a value; `false` otherwise
   */
  public hasDefaultValuePeriod(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof Period;
  }

  /**
   * @returns the `defaultValue` property value as a Quantity object if defined; else undefined
   */
  public getDefaultValueQuantity(): Quantity | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof Quantity)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected Quantity but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a Quantity and has a value; `false` otherwise
   */
  public hasDefaultValueQuantity(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof Quantity;
  }

  /**
   * @returns the `defaultValue` property value as a Range object if defined; else undefined
   */
  public getDefaultValueRange(): Range | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof Range)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected Range but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a Range and has a value; `false` otherwise
   */
  public hasDefaultValueRange(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof Range;
  }

  /**
   * @returns the `defaultValue` property value as a Ratio object if defined; else undefined
   */
  public getDefaultValueRatio(): Ratio | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof Ratio)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected Ratio but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a Ratio and has a value; `false` otherwise
   */
  public hasDefaultValueRatio(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof Ratio;
  }

  /**
   * @returns the `defaultValue` property value as a RatioRange object if defined; else undefined
   */
  public getDefaultValueRatioRange(): RatioRange | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof RatioRange)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected RatioRange but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a RatioRange and has a value; `false` otherwise
   */
  public hasDefaultValueRatioRange(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof RatioRange;
  }

  /**
   * @returns the `defaultValue` property value as a Reference object if defined; else undefined
   */
  public getDefaultValueReference(): Reference | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof Reference)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected Reference but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a Reference and has a value; `false` otherwise
   */
  public hasDefaultValueReference(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof Reference;
  }

  /**
   * @returns the `defaultValue` property value as a SampledData object if defined; else undefined
   */
  public getDefaultValueSampledData(): SampledData | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof SampledData)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected SampledData but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a SampledData and has a value; `false` otherwise
   */
  public hasDefaultValueSampledData(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof SampledData;
  }

  /**
   * @returns the `defaultValue` property value as a Signature object if defined; else undefined
   */
  public getDefaultValueSignature(): Signature | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof Signature)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected Signature but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a Signature and has a value; `false` otherwise
   */
  public hasDefaultValueSignature(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof Signature;
  }

  /**
   * @returns the `defaultValue` property value as a Timing object if defined; else undefined
   */
  public getDefaultValueTiming(): Timing | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof Timing)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected Timing but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a Timing and has a value; `false` otherwise
   */
  public hasDefaultValueTiming(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof Timing;
  }

  /**
   * @returns the `defaultValue` property value as a ContactDetail object if defined; else undefined
   */
  public getDefaultValueContactDetail(): ContactDetail | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof ContactDetail)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected ContactDetail but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a ContactDetail and has a value; `false` otherwise
   */
  public hasDefaultValueContactDetail(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof ContactDetail;
  }

  /**
   * @returns the `defaultValue` property value as a Contributor object if defined; else undefined
   */
  public getDefaultValueContributor(): Contributor | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof Contributor)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected Contributor but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a Contributor and has a value; `false` otherwise
   */
  public hasDefaultValueContributor(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof Contributor;
  }

  /**
   * @returns the `defaultValue` property value as a DataRequirement object if defined; else undefined
   */
  public getDefaultValueDataRequirement(): DataRequirement | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof DataRequirement)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected DataRequirement but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a DataRequirement and has a value; `false` otherwise
   */
  public hasDefaultValueDataRequirement(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof DataRequirement;
  }

  /**
   * @returns the `defaultValue` property value as a Expression object if defined; else undefined
   */
  public getDefaultValueExpression(): Expression | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof Expression)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected Expression but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a Expression and has a value; `false` otherwise
   */
  public hasDefaultValueExpression(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof Expression;
  }

  /**
   * @returns the `defaultValue` property value as a ParameterDefinition object if defined; else undefined
   */
  public getDefaultValueParameterDefinition(): ParameterDefinition | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof ParameterDefinition)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected ParameterDefinition but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a ParameterDefinition and has a value; `false` otherwise
   */
  public hasDefaultValueParameterDefinition(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof ParameterDefinition;
  }

  /**
   * @returns the `defaultValue` property value as a RelatedArtifact object if defined; else undefined
   */
  public getDefaultValueRelatedArtifact(): RelatedArtifact | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof RelatedArtifact)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected RelatedArtifact but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a RelatedArtifact and has a value; `false` otherwise
   */
  public hasDefaultValueRelatedArtifact(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof RelatedArtifact;
  }

  /**
   * @returns the `defaultValue` property value as a TriggerDefinition object if defined; else undefined
   */
  public getDefaultValueTriggerDefinition(): TriggerDefinition | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof TriggerDefinition)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected TriggerDefinition but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a TriggerDefinition and has a value; `false` otherwise
   */
  public hasDefaultValueTriggerDefinition(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof TriggerDefinition;
  }

  /**
   * @returns the `defaultValue` property value as a UsageContext object if defined; else undefined
   */
  public getDefaultValueUsageContext(): UsageContext | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof UsageContext)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected UsageContext but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a UsageContext and has a value; `false` otherwise
   */
  public hasDefaultValueUsageContext(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof UsageContext;
  }

  /**
   * @returns the `defaultValue` property value as a Dosage object if defined; else undefined
   */
  public getDefaultValueDosage(): Dosage | undefined {
    if (!isDefined<IDataType | undefined>(this.defaultValue)) {
      return undefined;
    }
    if (!(this.defaultValue instanceof Dosage)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.defaultValue[x]: Expected Dosage but encountered ${this.defaultValue.fhirType()}`,
      );
    }
    return this.defaultValue;
  }

  /**
   * @returns `true` if the `defaultValue` property exists as a Dosage and has a value; `false` otherwise
   */
  public hasDefaultValueDosage(): boolean {
    return this.hasDefaultValue() && this.defaultValue instanceof Dosage;
  }

  // End of choice datatype-specific "get"/"has" methods

  /**
   * @returns the `meaningWhenMissing` property value as a MarkdownType object if defined; else an empty MarkdownType object
   */
  public getMeaningWhenMissingElement(): MarkdownType {
    return this.meaningWhenMissing ?? new MarkdownType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `meaningWhenMissing` property.
   *
   * @param element - the `meaningWhenMissing` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMeaningWhenMissingElement(element: MarkdownType | undefined): this {
    if (isDefined<MarkdownType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.meaningWhenMissing; Provided element is not an instance of MarkdownType.`;
      assertFhirType<MarkdownType>(element, MarkdownType, optErrMsg);
      this.meaningWhenMissing = element;
    } else {
      this.meaningWhenMissing = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `meaningWhenMissing` property exists and has a value; `false` otherwise
   */
  public hasMeaningWhenMissingElement(): boolean {
    return isDefined<MarkdownType>(this.meaningWhenMissing) && !this.meaningWhenMissing.isEmpty();
  }

  /**
   * @returns the `meaningWhenMissing` property value as a fhirMarkdown if defined; else undefined
   */
  public getMeaningWhenMissing(): fhirMarkdown | undefined {
    return this.meaningWhenMissing?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `meaningWhenMissing` property.
   *
   * @param value - the `meaningWhenMissing` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMeaningWhenMissing(value: fhirMarkdown | undefined): this {
    if (isDefined<fhirMarkdown>(value)) {
      const optErrMsg = `Invalid ElementDefinition.meaningWhenMissing (${String(value)})`;
      this.meaningWhenMissing = new MarkdownType(parseFhirPrimitiveData(value, fhirMarkdownSchema, optErrMsg));
    } else {
      this.meaningWhenMissing = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `meaningWhenMissing` property exists and has a value; `false` otherwise
   */
  public hasMeaningWhenMissing(): boolean {
    return this.hasMeaningWhenMissingElement();
  }

  /**
   * @returns the `orderMeaning` property value as a StringType object if defined; else an empty StringType object
   */
  public getOrderMeaningElement(): StringType {
    return this.orderMeaning ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `orderMeaning` property.
   *
   * @param element - the `orderMeaning` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setOrderMeaningElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.orderMeaning; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.orderMeaning = element;
    } else {
      this.orderMeaning = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `orderMeaning` property exists and has a value; `false` otherwise
   */
  public hasOrderMeaningElement(): boolean {
    return isDefined<StringType>(this.orderMeaning) && !this.orderMeaning.isEmpty();
  }

  /**
   * @returns the `orderMeaning` property value as a fhirString if defined; else undefined
   */
  public getOrderMeaning(): fhirString | undefined {
    return this.orderMeaning?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `orderMeaning` property.
   *
   * @param value - the `orderMeaning` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setOrderMeaning(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid ElementDefinition.orderMeaning (${String(value)})`;
      this.orderMeaning = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.orderMeaning = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `orderMeaning` property exists and has a value; `false` otherwise
   */
  public hasOrderMeaning(): boolean {
    return this.hasOrderMeaningElement();
  }

  /**
   * @returns the `fixed` property value as a DataType object if defined; else undefined
   */
  public getFixed(): IDataType | undefined {
    return this.fixed;
  }

  /**
   * Assigns the provided DataType object value to the `fixed` property.
   *
   * @decorator `@ChoiceDataTypes('ElementDefinition.fixed[x]')`
   *
   * @param value - the `fixed` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  @ChoiceDataTypes('ElementDefinition.fixed[x]')
  public setFixed(value: IDataType | undefined): this {
    if (isDefined<IDataType>(value)) {
      // assertFhirType<IDataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.fixed = value;
    } else {
      this.fixed = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `fixed` property exists and has a value; `false` otherwise
   */
  public hasFixed(): boolean {
    return isDefined<IDataType>(this.fixed) && !this.fixed.isEmpty();
  }

  // *** NOTE ***
  // Following choice datatype-specific "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the `fixed` property value as a Base64BinaryType object if defined; else undefined
   */
  public getFixedBase64BinaryType(): Base64BinaryType | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof Base64BinaryType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected Base64BinaryType but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a Base64BinaryType and has a value; `false` otherwise
   */
  public hasFixedBase64BinaryType(): boolean {
    return this.hasFixed() && this.fixed instanceof Base64BinaryType;
  }

  /**
   * @returns the `fixed` property value as a BooleanType object if defined; else undefined
   */
  public getFixedBooleanType(): BooleanType | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof BooleanType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected BooleanType but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a BooleanType and has a value; `false` otherwise
   */
  public hasFixedBooleanType(): boolean {
    return this.hasFixed() && this.fixed instanceof BooleanType;
  }

  /**
   * @returns the `fixed` property value as a CanonicalType object if defined; else undefined
   */
  public getFixedCanonicalType(): CanonicalType | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof CanonicalType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected CanonicalType but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a CanonicalType and has a value; `false` otherwise
   */
  public hasFixedCanonicalType(): boolean {
    return this.hasFixed() && this.fixed instanceof CanonicalType;
  }

  /**
   * @returns the `fixed` property value as a CodeType object if defined; else undefined
   */
  public getFixedCodeType(): CodeType | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof CodeType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected CodeType but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a CodeType and has a value; `false` otherwise
   */
  public hasFixedCodeType(): boolean {
    return this.hasFixed() && this.fixed instanceof CodeType;
  }

  /**
   * @returns the `fixed` property value as a DateType object if defined; else undefined
   */
  public getFixedDateType(): DateType | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof DateType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected DateType but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a DateType and has a value; `false` otherwise
   */
  public hasFixedDateType(): boolean {
    return this.hasFixed() && this.fixed instanceof DateType;
  }

  /**
   * @returns the `fixed` property value as a DateTimeType object if defined; else undefined
   */
  public getFixedDateTimeType(): DateTimeType | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof DateTimeType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected DateTimeType but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a DateTimeType and has a value; `false` otherwise
   */
  public hasFixedDateTimeType(): boolean {
    return this.hasFixed() && this.fixed instanceof DateTimeType;
  }

  /**
   * @returns the `fixed` property value as a DecimalType object if defined; else undefined
   */
  public getFixedDecimalType(): DecimalType | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof DecimalType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected DecimalType but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a DecimalType and has a value; `false` otherwise
   */
  public hasFixedDecimalType(): boolean {
    return this.hasFixed() && this.fixed instanceof DecimalType;
  }

  /**
   * @returns the `fixed` property value as a IdType object if defined; else undefined
   */
  public getFixedIdType(): IdType | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof IdType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected IdType but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a IdType and has a value; `false` otherwise
   */
  public hasFixedIdType(): boolean {
    return this.hasFixed() && this.fixed instanceof IdType;
  }

  /**
   * @returns the `fixed` property value as a InstantType object if defined; else undefined
   */
  public getFixedInstantType(): InstantType | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof InstantType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected InstantType but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a InstantType and has a value; `false` otherwise
   */
  public hasFixedInstantType(): boolean {
    return this.hasFixed() && this.fixed instanceof InstantType;
  }

  /**
   * @returns the `fixed` property value as a IntegerType object if defined; else undefined
   */
  public getFixedIntegerType(): IntegerType | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof IntegerType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected IntegerType but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a IntegerType and has a value; `false` otherwise
   */
  public hasFixedIntegerType(): boolean {
    return this.hasFixed() && this.fixed instanceof IntegerType;
  }

  /**
   * @returns the `fixed` property value as a MarkdownType object if defined; else undefined
   */
  public getFixedMarkdownType(): MarkdownType | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof MarkdownType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected MarkdownType but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a MarkdownType and has a value; `false` otherwise
   */
  public hasFixedMarkdownType(): boolean {
    return this.hasFixed() && this.fixed instanceof MarkdownType;
  }

  /**
   * @returns the `fixed` property value as a OidType object if defined; else undefined
   */
  public getFixedOidType(): OidType | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof OidType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected OidType but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a OidType and has a value; `false` otherwise
   */
  public hasFixedOidType(): boolean {
    return this.hasFixed() && this.fixed instanceof OidType;
  }

  /**
   * @returns the `fixed` property value as a PositiveIntType object if defined; else undefined
   */
  public getFixedPositiveIntType(): PositiveIntType | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof PositiveIntType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected PositiveIntType but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a PositiveIntType and has a value; `false` otherwise
   */
  public hasFixedPositiveIntType(): boolean {
    return this.hasFixed() && this.fixed instanceof PositiveIntType;
  }

  /**
   * @returns the `fixed` property value as a StringType object if defined; else undefined
   */
  public getFixedStringType(): StringType | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof StringType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected StringType but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a StringType and has a value; `false` otherwise
   */
  public hasFixedStringType(): boolean {
    return this.hasFixed() && this.fixed instanceof StringType;
  }

  /**
   * @returns the `fixed` property value as a TimeType object if defined; else undefined
   */
  public getFixedTimeType(): TimeType | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof TimeType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected TimeType but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a TimeType and has a value; `false` otherwise
   */
  public hasFixedTimeType(): boolean {
    return this.hasFixed() && this.fixed instanceof TimeType;
  }

  /**
   * @returns the `fixed` property value as a UnsignedIntType object if defined; else undefined
   */
  public getFixedUnsignedIntType(): UnsignedIntType | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof UnsignedIntType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected UnsignedIntType but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a UnsignedIntType and has a value; `false` otherwise
   */
  public hasFixedUnsignedIntType(): boolean {
    return this.hasFixed() && this.fixed instanceof UnsignedIntType;
  }

  /**
   * @returns the `fixed` property value as a UriType object if defined; else undefined
   */
  public getFixedUriType(): UriType | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof UriType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected UriType but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a UriType and has a value; `false` otherwise
   */
  public hasFixedUriType(): boolean {
    return this.hasFixed() && this.fixed instanceof UriType;
  }

  /**
   * @returns the `fixed` property value as a UrlType object if defined; else undefined
   */
  public getFixedUrlType(): UrlType | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof UrlType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected UrlType but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a UrlType and has a value; `false` otherwise
   */
  public hasFixedUrlType(): boolean {
    return this.hasFixed() && this.fixed instanceof UrlType;
  }

  /**
   * @returns the `fixed` property value as a UuidType object if defined; else undefined
   */
  public getFixedUuidType(): UuidType | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof UuidType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected UuidType but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a UuidType and has a value; `false` otherwise
   */
  public hasFixedUuidType(): boolean {
    return this.hasFixed() && this.fixed instanceof UuidType;
  }

  /**
   * @returns the `fixed` property value as a Address object if defined; else undefined
   */
  public getFixedAddress(): Address | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof Address)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected Address but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a Address and has a value; `false` otherwise
   */
  public hasFixedAddress(): boolean {
    return this.hasFixed() && this.fixed instanceof Address;
  }

  /**
   * @returns the `fixed` property value as a Age object if defined; else undefined
   */
  public getFixedAge(): Age | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof Age)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected Age but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a Age and has a value; `false` otherwise
   */
  public hasFixedAge(): boolean {
    return this.hasFixed() && this.fixed instanceof Age;
  }

  /**
   * @returns the `fixed` property value as a Annotation object if defined; else undefined
   */
  public getFixedAnnotation(): Annotation | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof Annotation)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected Annotation but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a Annotation and has a value; `false` otherwise
   */
  public hasFixedAnnotation(): boolean {
    return this.hasFixed() && this.fixed instanceof Annotation;
  }

  /**
   * @returns the `fixed` property value as a Attachment object if defined; else undefined
   */
  public getFixedAttachment(): Attachment | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof Attachment)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected Attachment but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a Attachment and has a value; `false` otherwise
   */
  public hasFixedAttachment(): boolean {
    return this.hasFixed() && this.fixed instanceof Attachment;
  }

  /**
   * @returns the `fixed` property value as a CodeableConcept object if defined; else undefined
   */
  public getFixedCodeableConcept(): CodeableConcept | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof CodeableConcept)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected CodeableConcept but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a CodeableConcept and has a value; `false` otherwise
   */
  public hasFixedCodeableConcept(): boolean {
    return this.hasFixed() && this.fixed instanceof CodeableConcept;
  }

  /**
   * @returns the `fixed` property value as a CodeableReference object if defined; else undefined
   */
  public getFixedCodeableReference(): CodeableReference | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof CodeableReference)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected CodeableReference but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a CodeableReference and has a value; `false` otherwise
   */
  public hasFixedCodeableReference(): boolean {
    return this.hasFixed() && this.fixed instanceof CodeableReference;
  }

  /**
   * @returns the `fixed` property value as a Coding object if defined; else undefined
   */
  public getFixedCoding(): Coding | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof Coding)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected Coding but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a Coding and has a value; `false` otherwise
   */
  public hasFixedCoding(): boolean {
    return this.hasFixed() && this.fixed instanceof Coding;
  }

  /**
   * @returns the `fixed` property value as a ContactPoint object if defined; else undefined
   */
  public getFixedContactPoint(): ContactPoint | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof ContactPoint)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected ContactPoint but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a ContactPoint and has a value; `false` otherwise
   */
  public hasFixedContactPoint(): boolean {
    return this.hasFixed() && this.fixed instanceof ContactPoint;
  }

  /**
   * @returns the `fixed` property value as a Count object if defined; else undefined
   */
  public getFixedCount(): Count | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof Count)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected Count but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a Count and has a value; `false` otherwise
   */
  public hasFixedCount(): boolean {
    return this.hasFixed() && this.fixed instanceof Count;
  }

  /**
   * @returns the `fixed` property value as a Distance object if defined; else undefined
   */
  public getFixedDistance(): Distance | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof Distance)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected Distance but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a Distance and has a value; `false` otherwise
   */
  public hasFixedDistance(): boolean {
    return this.hasFixed() && this.fixed instanceof Distance;
  }

  /**
   * @returns the `fixed` property value as a Duration object if defined; else undefined
   */
  public getFixedDuration(): Duration | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof Duration)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected Duration but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a Duration and has a value; `false` otherwise
   */
  public hasFixedDuration(): boolean {
    return this.hasFixed() && this.fixed instanceof Duration;
  }

  /**
   * @returns the `fixed` property value as a HumanName object if defined; else undefined
   */
  public getFixedHumanName(): HumanName | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof HumanName)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected HumanName but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a HumanName and has a value; `false` otherwise
   */
  public hasFixedHumanName(): boolean {
    return this.hasFixed() && this.fixed instanceof HumanName;
  }

  /**
   * @returns the `fixed` property value as a Identifier object if defined; else undefined
   */
  public getFixedIdentifier(): Identifier | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof Identifier)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected Identifier but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a Identifier and has a value; `false` otherwise
   */
  public hasFixedIdentifier(): boolean {
    return this.hasFixed() && this.fixed instanceof Identifier;
  }

  /**
   * @returns the `fixed` property value as a Money object if defined; else undefined
   */
  public getFixedMoney(): Money | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof Money)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected Money but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a Money and has a value; `false` otherwise
   */
  public hasFixedMoney(): boolean {
    return this.hasFixed() && this.fixed instanceof Money;
  }

  /**
   * @returns the `fixed` property value as a Period object if defined; else undefined
   */
  public getFixedPeriod(): Period | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof Period)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected Period but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a Period and has a value; `false` otherwise
   */
  public hasFixedPeriod(): boolean {
    return this.hasFixed() && this.fixed instanceof Period;
  }

  /**
   * @returns the `fixed` property value as a Quantity object if defined; else undefined
   */
  public getFixedQuantity(): Quantity | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof Quantity)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected Quantity but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a Quantity and has a value; `false` otherwise
   */
  public hasFixedQuantity(): boolean {
    return this.hasFixed() && this.fixed instanceof Quantity;
  }

  /**
   * @returns the `fixed` property value as a Range object if defined; else undefined
   */
  public getFixedRange(): Range | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof Range)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected Range but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a Range and has a value; `false` otherwise
   */
  public hasFixedRange(): boolean {
    return this.hasFixed() && this.fixed instanceof Range;
  }

  /**
   * @returns the `fixed` property value as a Ratio object if defined; else undefined
   */
  public getFixedRatio(): Ratio | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof Ratio)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected Ratio but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a Ratio and has a value; `false` otherwise
   */
  public hasFixedRatio(): boolean {
    return this.hasFixed() && this.fixed instanceof Ratio;
  }

  /**
   * @returns the `fixed` property value as a RatioRange object if defined; else undefined
   */
  public getFixedRatioRange(): RatioRange | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof RatioRange)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected RatioRange but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a RatioRange and has a value; `false` otherwise
   */
  public hasFixedRatioRange(): boolean {
    return this.hasFixed() && this.fixed instanceof RatioRange;
  }

  /**
   * @returns the `fixed` property value as a Reference object if defined; else undefined
   */
  public getFixedReference(): Reference | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof Reference)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected Reference but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a Reference and has a value; `false` otherwise
   */
  public hasFixedReference(): boolean {
    return this.hasFixed() && this.fixed instanceof Reference;
  }

  /**
   * @returns the `fixed` property value as a SampledData object if defined; else undefined
   */
  public getFixedSampledData(): SampledData | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof SampledData)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected SampledData but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a SampledData and has a value; `false` otherwise
   */
  public hasFixedSampledData(): boolean {
    return this.hasFixed() && this.fixed instanceof SampledData;
  }

  /**
   * @returns the `fixed` property value as a Signature object if defined; else undefined
   */
  public getFixedSignature(): Signature | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof Signature)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected Signature but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a Signature and has a value; `false` otherwise
   */
  public hasFixedSignature(): boolean {
    return this.hasFixed() && this.fixed instanceof Signature;
  }

  /**
   * @returns the `fixed` property value as a Timing object if defined; else undefined
   */
  public getFixedTiming(): Timing | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof Timing)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected Timing but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a Timing and has a value; `false` otherwise
   */
  public hasFixedTiming(): boolean {
    return this.hasFixed() && this.fixed instanceof Timing;
  }

  /**
   * @returns the `fixed` property value as a ContactDetail object if defined; else undefined
   */
  public getFixedContactDetail(): ContactDetail | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof ContactDetail)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected ContactDetail but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a ContactDetail and has a value; `false` otherwise
   */
  public hasFixedContactDetail(): boolean {
    return this.hasFixed() && this.fixed instanceof ContactDetail;
  }

  /**
   * @returns the `fixed` property value as a Contributor object if defined; else undefined
   */
  public getFixedContributor(): Contributor | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof Contributor)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected Contributor but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a Contributor and has a value; `false` otherwise
   */
  public hasFixedContributor(): boolean {
    return this.hasFixed() && this.fixed instanceof Contributor;
  }

  /**
   * @returns the `fixed` property value as a DataRequirement object if defined; else undefined
   */
  public getFixedDataRequirement(): DataRequirement | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof DataRequirement)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected DataRequirement but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a DataRequirement and has a value; `false` otherwise
   */
  public hasFixedDataRequirement(): boolean {
    return this.hasFixed() && this.fixed instanceof DataRequirement;
  }

  /**
   * @returns the `fixed` property value as a Expression object if defined; else undefined
   */
  public getFixedExpression(): Expression | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof Expression)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected Expression but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a Expression and has a value; `false` otherwise
   */
  public hasFixedExpression(): boolean {
    return this.hasFixed() && this.fixed instanceof Expression;
  }

  /**
   * @returns the `fixed` property value as a ParameterDefinition object if defined; else undefined
   */
  public getFixedParameterDefinition(): ParameterDefinition | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof ParameterDefinition)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected ParameterDefinition but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a ParameterDefinition and has a value; `false` otherwise
   */
  public hasFixedParameterDefinition(): boolean {
    return this.hasFixed() && this.fixed instanceof ParameterDefinition;
  }

  /**
   * @returns the `fixed` property value as a RelatedArtifact object if defined; else undefined
   */
  public getFixedRelatedArtifact(): RelatedArtifact | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof RelatedArtifact)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected RelatedArtifact but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a RelatedArtifact and has a value; `false` otherwise
   */
  public hasFixedRelatedArtifact(): boolean {
    return this.hasFixed() && this.fixed instanceof RelatedArtifact;
  }

  /**
   * @returns the `fixed` property value as a TriggerDefinition object if defined; else undefined
   */
  public getFixedTriggerDefinition(): TriggerDefinition | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof TriggerDefinition)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected TriggerDefinition but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a TriggerDefinition and has a value; `false` otherwise
   */
  public hasFixedTriggerDefinition(): boolean {
    return this.hasFixed() && this.fixed instanceof TriggerDefinition;
  }

  /**
   * @returns the `fixed` property value as a UsageContext object if defined; else undefined
   */
  public getFixedUsageContext(): UsageContext | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof UsageContext)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected UsageContext but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a UsageContext and has a value; `false` otherwise
   */
  public hasFixedUsageContext(): boolean {
    return this.hasFixed() && this.fixed instanceof UsageContext;
  }

  /**
   * @returns the `fixed` property value as a Dosage object if defined; else undefined
   */
  public getFixedDosage(): Dosage | undefined {
    if (!isDefined<IDataType | undefined>(this.fixed)) {
      return undefined;
    }
    if (!(this.fixed instanceof Dosage)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.fixed[x]: Expected Dosage but encountered ${this.fixed.fhirType()}`,
      );
    }
    return this.fixed;
  }

  /**
   * @returns `true` if the `fixed` property exists as a Dosage and has a value; `false` otherwise
   */
  public hasFixedDosage(): boolean {
    return this.hasFixed() && this.fixed instanceof Dosage;
  }

  // End of choice datatype-specific "get"/"has" methods

  /**
   * @returns the `pattern` property value as a DataType object if defined; else undefined
   */
  public getPattern(): IDataType | undefined {
    return this.pattern;
  }

  /**
   * Assigns the provided DataType object value to the `pattern` property.
   *
   * @decorator `@ChoiceDataTypes('ElementDefinition.pattern[x]')`
   *
   * @param value - the `pattern` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  @ChoiceDataTypes('ElementDefinition.pattern[x]')
  public setPattern(value: IDataType | undefined): this {
    if (isDefined<IDataType>(value)) {
      // assertFhirType<IDataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.pattern = value;
    } else {
      this.pattern = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `pattern` property exists and has a value; `false` otherwise
   */
  public hasPattern(): boolean {
    return isDefined<IDataType>(this.pattern) && !this.pattern.isEmpty();
  }

  // *** NOTE ***
  // Following choice datatype-specific "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the `pattern` property value as a Base64BinaryType object if defined; else undefined
   */
  public getPatternBase64BinaryType(): Base64BinaryType | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof Base64BinaryType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected Base64BinaryType but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a Base64BinaryType and has a value; `false` otherwise
   */
  public hasPatternBase64BinaryType(): boolean {
    return this.hasPattern() && this.pattern instanceof Base64BinaryType;
  }

  /**
   * @returns the `pattern` property value as a BooleanType object if defined; else undefined
   */
  public getPatternBooleanType(): BooleanType | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof BooleanType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected BooleanType but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a BooleanType and has a value; `false` otherwise
   */
  public hasPatternBooleanType(): boolean {
    return this.hasPattern() && this.pattern instanceof BooleanType;
  }

  /**
   * @returns the `pattern` property value as a CanonicalType object if defined; else undefined
   */
  public getPatternCanonicalType(): CanonicalType | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof CanonicalType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected CanonicalType but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a CanonicalType and has a value; `false` otherwise
   */
  public hasPatternCanonicalType(): boolean {
    return this.hasPattern() && this.pattern instanceof CanonicalType;
  }

  /**
   * @returns the `pattern` property value as a CodeType object if defined; else undefined
   */
  public getPatternCodeType(): CodeType | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof CodeType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected CodeType but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a CodeType and has a value; `false` otherwise
   */
  public hasPatternCodeType(): boolean {
    return this.hasPattern() && this.pattern instanceof CodeType;
  }

  /**
   * @returns the `pattern` property value as a DateType object if defined; else undefined
   */
  public getPatternDateType(): DateType | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof DateType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected DateType but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a DateType and has a value; `false` otherwise
   */
  public hasPatternDateType(): boolean {
    return this.hasPattern() && this.pattern instanceof DateType;
  }

  /**
   * @returns the `pattern` property value as a DateTimeType object if defined; else undefined
   */
  public getPatternDateTimeType(): DateTimeType | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof DateTimeType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected DateTimeType but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a DateTimeType and has a value; `false` otherwise
   */
  public hasPatternDateTimeType(): boolean {
    return this.hasPattern() && this.pattern instanceof DateTimeType;
  }

  /**
   * @returns the `pattern` property value as a DecimalType object if defined; else undefined
   */
  public getPatternDecimalType(): DecimalType | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof DecimalType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected DecimalType but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a DecimalType and has a value; `false` otherwise
   */
  public hasPatternDecimalType(): boolean {
    return this.hasPattern() && this.pattern instanceof DecimalType;
  }

  /**
   * @returns the `pattern` property value as a IdType object if defined; else undefined
   */
  public getPatternIdType(): IdType | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof IdType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected IdType but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a IdType and has a value; `false` otherwise
   */
  public hasPatternIdType(): boolean {
    return this.hasPattern() && this.pattern instanceof IdType;
  }

  /**
   * @returns the `pattern` property value as a InstantType object if defined; else undefined
   */
  public getPatternInstantType(): InstantType | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof InstantType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected InstantType but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a InstantType and has a value; `false` otherwise
   */
  public hasPatternInstantType(): boolean {
    return this.hasPattern() && this.pattern instanceof InstantType;
  }

  /**
   * @returns the `pattern` property value as a IntegerType object if defined; else undefined
   */
  public getPatternIntegerType(): IntegerType | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof IntegerType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected IntegerType but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a IntegerType and has a value; `false` otherwise
   */
  public hasPatternIntegerType(): boolean {
    return this.hasPattern() && this.pattern instanceof IntegerType;
  }

  /**
   * @returns the `pattern` property value as a MarkdownType object if defined; else undefined
   */
  public getPatternMarkdownType(): MarkdownType | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof MarkdownType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected MarkdownType but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a MarkdownType and has a value; `false` otherwise
   */
  public hasPatternMarkdownType(): boolean {
    return this.hasPattern() && this.pattern instanceof MarkdownType;
  }

  /**
   * @returns the `pattern` property value as a OidType object if defined; else undefined
   */
  public getPatternOidType(): OidType | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof OidType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected OidType but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a OidType and has a value; `false` otherwise
   */
  public hasPatternOidType(): boolean {
    return this.hasPattern() && this.pattern instanceof OidType;
  }

  /**
   * @returns the `pattern` property value as a PositiveIntType object if defined; else undefined
   */
  public getPatternPositiveIntType(): PositiveIntType | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof PositiveIntType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected PositiveIntType but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a PositiveIntType and has a value; `false` otherwise
   */
  public hasPatternPositiveIntType(): boolean {
    return this.hasPattern() && this.pattern instanceof PositiveIntType;
  }

  /**
   * @returns the `pattern` property value as a StringType object if defined; else undefined
   */
  public getPatternStringType(): StringType | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof StringType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected StringType but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a StringType and has a value; `false` otherwise
   */
  public hasPatternStringType(): boolean {
    return this.hasPattern() && this.pattern instanceof StringType;
  }

  /**
   * @returns the `pattern` property value as a TimeType object if defined; else undefined
   */
  public getPatternTimeType(): TimeType | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof TimeType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected TimeType but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a TimeType and has a value; `false` otherwise
   */
  public hasPatternTimeType(): boolean {
    return this.hasPattern() && this.pattern instanceof TimeType;
  }

  /**
   * @returns the `pattern` property value as a UnsignedIntType object if defined; else undefined
   */
  public getPatternUnsignedIntType(): UnsignedIntType | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof UnsignedIntType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected UnsignedIntType but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a UnsignedIntType and has a value; `false` otherwise
   */
  public hasPatternUnsignedIntType(): boolean {
    return this.hasPattern() && this.pattern instanceof UnsignedIntType;
  }

  /**
   * @returns the `pattern` property value as a UriType object if defined; else undefined
   */
  public getPatternUriType(): UriType | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof UriType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected UriType but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a UriType and has a value; `false` otherwise
   */
  public hasPatternUriType(): boolean {
    return this.hasPattern() && this.pattern instanceof UriType;
  }

  /**
   * @returns the `pattern` property value as a UrlType object if defined; else undefined
   */
  public getPatternUrlType(): UrlType | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof UrlType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected UrlType but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a UrlType and has a value; `false` otherwise
   */
  public hasPatternUrlType(): boolean {
    return this.hasPattern() && this.pattern instanceof UrlType;
  }

  /**
   * @returns the `pattern` property value as a UuidType object if defined; else undefined
   */
  public getPatternUuidType(): UuidType | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof UuidType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected UuidType but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a UuidType and has a value; `false` otherwise
   */
  public hasPatternUuidType(): boolean {
    return this.hasPattern() && this.pattern instanceof UuidType;
  }

  /**
   * @returns the `pattern` property value as a Address object if defined; else undefined
   */
  public getPatternAddress(): Address | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof Address)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected Address but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a Address and has a value; `false` otherwise
   */
  public hasPatternAddress(): boolean {
    return this.hasPattern() && this.pattern instanceof Address;
  }

  /**
   * @returns the `pattern` property value as a Age object if defined; else undefined
   */
  public getPatternAge(): Age | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof Age)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected Age but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a Age and has a value; `false` otherwise
   */
  public hasPatternAge(): boolean {
    return this.hasPattern() && this.pattern instanceof Age;
  }

  /**
   * @returns the `pattern` property value as a Annotation object if defined; else undefined
   */
  public getPatternAnnotation(): Annotation | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof Annotation)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected Annotation but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a Annotation and has a value; `false` otherwise
   */
  public hasPatternAnnotation(): boolean {
    return this.hasPattern() && this.pattern instanceof Annotation;
  }

  /**
   * @returns the `pattern` property value as a Attachment object if defined; else undefined
   */
  public getPatternAttachment(): Attachment | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof Attachment)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected Attachment but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a Attachment and has a value; `false` otherwise
   */
  public hasPatternAttachment(): boolean {
    return this.hasPattern() && this.pattern instanceof Attachment;
  }

  /**
   * @returns the `pattern` property value as a CodeableConcept object if defined; else undefined
   */
  public getPatternCodeableConcept(): CodeableConcept | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof CodeableConcept)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected CodeableConcept but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a CodeableConcept and has a value; `false` otherwise
   */
  public hasPatternCodeableConcept(): boolean {
    return this.hasPattern() && this.pattern instanceof CodeableConcept;
  }

  /**
   * @returns the `pattern` property value as a CodeableReference object if defined; else undefined
   */
  public getPatternCodeableReference(): CodeableReference | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof CodeableReference)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected CodeableReference but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a CodeableReference and has a value; `false` otherwise
   */
  public hasPatternCodeableReference(): boolean {
    return this.hasPattern() && this.pattern instanceof CodeableReference;
  }

  /**
   * @returns the `pattern` property value as a Coding object if defined; else undefined
   */
  public getPatternCoding(): Coding | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof Coding)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected Coding but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a Coding and has a value; `false` otherwise
   */
  public hasPatternCoding(): boolean {
    return this.hasPattern() && this.pattern instanceof Coding;
  }

  /**
   * @returns the `pattern` property value as a ContactPoint object if defined; else undefined
   */
  public getPatternContactPoint(): ContactPoint | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof ContactPoint)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected ContactPoint but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a ContactPoint and has a value; `false` otherwise
   */
  public hasPatternContactPoint(): boolean {
    return this.hasPattern() && this.pattern instanceof ContactPoint;
  }

  /**
   * @returns the `pattern` property value as a Count object if defined; else undefined
   */
  public getPatternCount(): Count | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof Count)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected Count but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a Count and has a value; `false` otherwise
   */
  public hasPatternCount(): boolean {
    return this.hasPattern() && this.pattern instanceof Count;
  }

  /**
   * @returns the `pattern` property value as a Distance object if defined; else undefined
   */
  public getPatternDistance(): Distance | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof Distance)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected Distance but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a Distance and has a value; `false` otherwise
   */
  public hasPatternDistance(): boolean {
    return this.hasPattern() && this.pattern instanceof Distance;
  }

  /**
   * @returns the `pattern` property value as a Duration object if defined; else undefined
   */
  public getPatternDuration(): Duration | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof Duration)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected Duration but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a Duration and has a value; `false` otherwise
   */
  public hasPatternDuration(): boolean {
    return this.hasPattern() && this.pattern instanceof Duration;
  }

  /**
   * @returns the `pattern` property value as a HumanName object if defined; else undefined
   */
  public getPatternHumanName(): HumanName | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof HumanName)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected HumanName but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a HumanName and has a value; `false` otherwise
   */
  public hasPatternHumanName(): boolean {
    return this.hasPattern() && this.pattern instanceof HumanName;
  }

  /**
   * @returns the `pattern` property value as a Identifier object if defined; else undefined
   */
  public getPatternIdentifier(): Identifier | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof Identifier)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected Identifier but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a Identifier and has a value; `false` otherwise
   */
  public hasPatternIdentifier(): boolean {
    return this.hasPattern() && this.pattern instanceof Identifier;
  }

  /**
   * @returns the `pattern` property value as a Money object if defined; else undefined
   */
  public getPatternMoney(): Money | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof Money)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected Money but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a Money and has a value; `false` otherwise
   */
  public hasPatternMoney(): boolean {
    return this.hasPattern() && this.pattern instanceof Money;
  }

  /**
   * @returns the `pattern` property value as a Period object if defined; else undefined
   */
  public getPatternPeriod(): Period | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof Period)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected Period but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a Period and has a value; `false` otherwise
   */
  public hasPatternPeriod(): boolean {
    return this.hasPattern() && this.pattern instanceof Period;
  }

  /**
   * @returns the `pattern` property value as a Quantity object if defined; else undefined
   */
  public getPatternQuantity(): Quantity | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof Quantity)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected Quantity but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a Quantity and has a value; `false` otherwise
   */
  public hasPatternQuantity(): boolean {
    return this.hasPattern() && this.pattern instanceof Quantity;
  }

  /**
   * @returns the `pattern` property value as a Range object if defined; else undefined
   */
  public getPatternRange(): Range | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof Range)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected Range but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a Range and has a value; `false` otherwise
   */
  public hasPatternRange(): boolean {
    return this.hasPattern() && this.pattern instanceof Range;
  }

  /**
   * @returns the `pattern` property value as a Ratio object if defined; else undefined
   */
  public getPatternRatio(): Ratio | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof Ratio)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected Ratio but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a Ratio and has a value; `false` otherwise
   */
  public hasPatternRatio(): boolean {
    return this.hasPattern() && this.pattern instanceof Ratio;
  }

  /**
   * @returns the `pattern` property value as a RatioRange object if defined; else undefined
   */
  public getPatternRatioRange(): RatioRange | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof RatioRange)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected RatioRange but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a RatioRange and has a value; `false` otherwise
   */
  public hasPatternRatioRange(): boolean {
    return this.hasPattern() && this.pattern instanceof RatioRange;
  }

  /**
   * @returns the `pattern` property value as a Reference object if defined; else undefined
   */
  public getPatternReference(): Reference | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof Reference)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected Reference but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a Reference and has a value; `false` otherwise
   */
  public hasPatternReference(): boolean {
    return this.hasPattern() && this.pattern instanceof Reference;
  }

  /**
   * @returns the `pattern` property value as a SampledData object if defined; else undefined
   */
  public getPatternSampledData(): SampledData | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof SampledData)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected SampledData but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a SampledData and has a value; `false` otherwise
   */
  public hasPatternSampledData(): boolean {
    return this.hasPattern() && this.pattern instanceof SampledData;
  }

  /**
   * @returns the `pattern` property value as a Signature object if defined; else undefined
   */
  public getPatternSignature(): Signature | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof Signature)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected Signature but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a Signature and has a value; `false` otherwise
   */
  public hasPatternSignature(): boolean {
    return this.hasPattern() && this.pattern instanceof Signature;
  }

  /**
   * @returns the `pattern` property value as a Timing object if defined; else undefined
   */
  public getPatternTiming(): Timing | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof Timing)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected Timing but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a Timing and has a value; `false` otherwise
   */
  public hasPatternTiming(): boolean {
    return this.hasPattern() && this.pattern instanceof Timing;
  }

  /**
   * @returns the `pattern` property value as a ContactDetail object if defined; else undefined
   */
  public getPatternContactDetail(): ContactDetail | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof ContactDetail)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected ContactDetail but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a ContactDetail and has a value; `false` otherwise
   */
  public hasPatternContactDetail(): boolean {
    return this.hasPattern() && this.pattern instanceof ContactDetail;
  }

  /**
   * @returns the `pattern` property value as a Contributor object if defined; else undefined
   */
  public getPatternContributor(): Contributor | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof Contributor)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected Contributor but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a Contributor and has a value; `false` otherwise
   */
  public hasPatternContributor(): boolean {
    return this.hasPattern() && this.pattern instanceof Contributor;
  }

  /**
   * @returns the `pattern` property value as a DataRequirement object if defined; else undefined
   */
  public getPatternDataRequirement(): DataRequirement | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof DataRequirement)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected DataRequirement but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a DataRequirement and has a value; `false` otherwise
   */
  public hasPatternDataRequirement(): boolean {
    return this.hasPattern() && this.pattern instanceof DataRequirement;
  }

  /**
   * @returns the `pattern` property value as a Expression object if defined; else undefined
   */
  public getPatternExpression(): Expression | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof Expression)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected Expression but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a Expression and has a value; `false` otherwise
   */
  public hasPatternExpression(): boolean {
    return this.hasPattern() && this.pattern instanceof Expression;
  }

  /**
   * @returns the `pattern` property value as a ParameterDefinition object if defined; else undefined
   */
  public getPatternParameterDefinition(): ParameterDefinition | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof ParameterDefinition)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected ParameterDefinition but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a ParameterDefinition and has a value; `false` otherwise
   */
  public hasPatternParameterDefinition(): boolean {
    return this.hasPattern() && this.pattern instanceof ParameterDefinition;
  }

  /**
   * @returns the `pattern` property value as a RelatedArtifact object if defined; else undefined
   */
  public getPatternRelatedArtifact(): RelatedArtifact | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof RelatedArtifact)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected RelatedArtifact but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a RelatedArtifact and has a value; `false` otherwise
   */
  public hasPatternRelatedArtifact(): boolean {
    return this.hasPattern() && this.pattern instanceof RelatedArtifact;
  }

  /**
   * @returns the `pattern` property value as a TriggerDefinition object if defined; else undefined
   */
  public getPatternTriggerDefinition(): TriggerDefinition | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof TriggerDefinition)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected TriggerDefinition but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a TriggerDefinition and has a value; `false` otherwise
   */
  public hasPatternTriggerDefinition(): boolean {
    return this.hasPattern() && this.pattern instanceof TriggerDefinition;
  }

  /**
   * @returns the `pattern` property value as a UsageContext object if defined; else undefined
   */
  public getPatternUsageContext(): UsageContext | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof UsageContext)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected UsageContext but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a UsageContext and has a value; `false` otherwise
   */
  public hasPatternUsageContext(): boolean {
    return this.hasPattern() && this.pattern instanceof UsageContext;
  }

  /**
   * @returns the `pattern` property value as a Dosage object if defined; else undefined
   */
  public getPatternDosage(): Dosage | undefined {
    if (!isDefined<IDataType | undefined>(this.pattern)) {
      return undefined;
    }
    if (!(this.pattern instanceof Dosage)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.pattern[x]: Expected Dosage but encountered ${this.pattern.fhirType()}`,
      );
    }
    return this.pattern;
  }

  /**
   * @returns `true` if the `pattern` property exists as a Dosage and has a value; `false` otherwise
   */
  public hasPatternDosage(): boolean {
    return this.hasPattern() && this.pattern instanceof Dosage;
  }

  // End of choice datatype-specific "get"/"has" methods

  /**
   * @returns the `example` property value as a ElementDefinitionExampleComponent array
   */
  public getExample(): ElementDefinitionExampleComponent[] {
    return this.example ?? ([] as ElementDefinitionExampleComponent[]);
  }

  /**
   * Assigns the provided ElementDefinitionExampleComponent array value to the `example` property.
   *
   * @param value - the `example` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setExample(value: ElementDefinitionExampleComponent[] | undefined): this {
    if (isDefinedList<ElementDefinitionExampleComponent>(value)) {
      const optErrMsg = `Invalid ElementDefinition.example; Provided value array has an element that is not an instance of ElementDefinitionExampleComponent.`;
      assertFhirTypeList<ElementDefinitionExampleComponent>(value, ElementDefinitionExampleComponent, optErrMsg);
      this.example = value;
    } else {
      this.example = undefined;
    }
    return this;
  }

  /**
   * Add the provided ElementDefinitionExampleComponent value to the `example` array property.
   *
   * @param value - the `example` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addExample(value: ElementDefinitionExampleComponent | undefined): this {
    if (isDefined<ElementDefinitionExampleComponent>(value)) {
      const optErrMsg = `Invalid ElementDefinition.example; Provided element is not an instance of ElementDefinitionExampleComponent.`;
      assertFhirType<ElementDefinitionExampleComponent>(value, ElementDefinitionExampleComponent, optErrMsg);
      this.initExample();
      this.example?.push(value);
    }
    return this;
  }

  /**
   * @returns `true` if the `example` property exists and has a value; `false` otherwise
   */
  public hasExample(): boolean {
    return isDefinedList<ElementDefinitionExampleComponent>(this.example) && this.example.some((item: ElementDefinitionExampleComponent) => !item.isEmpty());
  }

  /**
   * Initialize the `example` property
   */
  private initExample(): void {
    if(!this.hasExample()) {
      this.example = [] as ElementDefinitionExampleComponent[];
    }
  }

  /**
   * @returns the `minValue` property value as a DataType object if defined; else undefined
   */
  public getMinValue(): IDataType | undefined {
    return this.minValue;
  }

  /**
   * Assigns the provided DataType object value to the `minValue` property.
   *
   * @decorator `@ChoiceDataTypes('ElementDefinition.minValue[x]')`
   *
   * @param value - the `minValue` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  @ChoiceDataTypes('ElementDefinition.minValue[x]')
  public setMinValue(value: IDataType | undefined): this {
    if (isDefined<IDataType>(value)) {
      // assertFhirType<IDataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.minValue = value;
    } else {
      this.minValue = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `minValue` property exists and has a value; `false` otherwise
   */
  public hasMinValue(): boolean {
    return isDefined<IDataType>(this.minValue) && !this.minValue.isEmpty();
  }

  // *** NOTE ***
  // Following choice datatype-specific "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the `minValue` property value as a DateType object if defined; else undefined
   */
  public getMinValueDateType(): DateType | undefined {
    if (!isDefined<IDataType | undefined>(this.minValue)) {
      return undefined;
    }
    if (!(this.minValue instanceof DateType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.minValue[x]: Expected DateType but encountered ${this.minValue.fhirType()}`,
      );
    }
    return this.minValue;
  }

  /**
   * @returns `true` if the `minValue` property exists as a DateType and has a value; `false` otherwise
   */
  public hasMinValueDateType(): boolean {
    return this.hasMinValue() && this.minValue instanceof DateType;
  }

  /**
   * @returns the `minValue` property value as a DateTimeType object if defined; else undefined
   */
  public getMinValueDateTimeType(): DateTimeType | undefined {
    if (!isDefined<IDataType | undefined>(this.minValue)) {
      return undefined;
    }
    if (!(this.minValue instanceof DateTimeType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.minValue[x]: Expected DateTimeType but encountered ${this.minValue.fhirType()}`,
      );
    }
    return this.minValue;
  }

  /**
   * @returns `true` if the `minValue` property exists as a DateTimeType and has a value; `false` otherwise
   */
  public hasMinValueDateTimeType(): boolean {
    return this.hasMinValue() && this.minValue instanceof DateTimeType;
  }

  /**
   * @returns the `minValue` property value as a InstantType object if defined; else undefined
   */
  public getMinValueInstantType(): InstantType | undefined {
    if (!isDefined<IDataType | undefined>(this.minValue)) {
      return undefined;
    }
    if (!(this.minValue instanceof InstantType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.minValue[x]: Expected InstantType but encountered ${this.minValue.fhirType()}`,
      );
    }
    return this.minValue;
  }

  /**
   * @returns `true` if the `minValue` property exists as a InstantType and has a value; `false` otherwise
   */
  public hasMinValueInstantType(): boolean {
    return this.hasMinValue() && this.minValue instanceof InstantType;
  }

  /**
   * @returns the `minValue` property value as a TimeType object if defined; else undefined
   */
  public getMinValueTimeType(): TimeType | undefined {
    if (!isDefined<IDataType | undefined>(this.minValue)) {
      return undefined;
    }
    if (!(this.minValue instanceof TimeType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.minValue[x]: Expected TimeType but encountered ${this.minValue.fhirType()}`,
      );
    }
    return this.minValue;
  }

  /**
   * @returns `true` if the `minValue` property exists as a TimeType and has a value; `false` otherwise
   */
  public hasMinValueTimeType(): boolean {
    return this.hasMinValue() && this.minValue instanceof TimeType;
  }

  /**
   * @returns the `minValue` property value as a DecimalType object if defined; else undefined
   */
  public getMinValueDecimalType(): DecimalType | undefined {
    if (!isDefined<IDataType | undefined>(this.minValue)) {
      return undefined;
    }
    if (!(this.minValue instanceof DecimalType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.minValue[x]: Expected DecimalType but encountered ${this.minValue.fhirType()}`,
      );
    }
    return this.minValue;
  }

  /**
   * @returns `true` if the `minValue` property exists as a DecimalType and has a value; `false` otherwise
   */
  public hasMinValueDecimalType(): boolean {
    return this.hasMinValue() && this.minValue instanceof DecimalType;
  }

  /**
   * @returns the `minValue` property value as a IntegerType object if defined; else undefined
   */
  public getMinValueIntegerType(): IntegerType | undefined {
    if (!isDefined<IDataType | undefined>(this.minValue)) {
      return undefined;
    }
    if (!(this.minValue instanceof IntegerType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.minValue[x]: Expected IntegerType but encountered ${this.minValue.fhirType()}`,
      );
    }
    return this.minValue;
  }

  /**
   * @returns `true` if the `minValue` property exists as a IntegerType and has a value; `false` otherwise
   */
  public hasMinValueIntegerType(): boolean {
    return this.hasMinValue() && this.minValue instanceof IntegerType;
  }

  /**
   * @returns the `minValue` property value as a PositiveIntType object if defined; else undefined
   */
  public getMinValuePositiveIntType(): PositiveIntType | undefined {
    if (!isDefined<IDataType | undefined>(this.minValue)) {
      return undefined;
    }
    if (!(this.minValue instanceof PositiveIntType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.minValue[x]: Expected PositiveIntType but encountered ${this.minValue.fhirType()}`,
      );
    }
    return this.minValue;
  }

  /**
   * @returns `true` if the `minValue` property exists as a PositiveIntType and has a value; `false` otherwise
   */
  public hasMinValuePositiveIntType(): boolean {
    return this.hasMinValue() && this.minValue instanceof PositiveIntType;
  }

  /**
   * @returns the `minValue` property value as a UnsignedIntType object if defined; else undefined
   */
  public getMinValueUnsignedIntType(): UnsignedIntType | undefined {
    if (!isDefined<IDataType | undefined>(this.minValue)) {
      return undefined;
    }
    if (!(this.minValue instanceof UnsignedIntType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.minValue[x]: Expected UnsignedIntType but encountered ${this.minValue.fhirType()}`,
      );
    }
    return this.minValue;
  }

  /**
   * @returns `true` if the `minValue` property exists as a UnsignedIntType and has a value; `false` otherwise
   */
  public hasMinValueUnsignedIntType(): boolean {
    return this.hasMinValue() && this.minValue instanceof UnsignedIntType;
  }

  /**
   * @returns the `minValue` property value as a Quantity object if defined; else undefined
   */
  public getMinValueQuantity(): Quantity | undefined {
    if (!isDefined<IDataType | undefined>(this.minValue)) {
      return undefined;
    }
    if (!(this.minValue instanceof Quantity)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.minValue[x]: Expected Quantity but encountered ${this.minValue.fhirType()}`,
      );
    }
    return this.minValue;
  }

  /**
   * @returns `true` if the `minValue` property exists as a Quantity and has a value; `false` otherwise
   */
  public hasMinValueQuantity(): boolean {
    return this.hasMinValue() && this.minValue instanceof Quantity;
  }

  // End of choice datatype-specific "get"/"has" methods

  /**
   * @returns the `maxValue` property value as a DataType object if defined; else undefined
   */
  public getMaxValue(): IDataType | undefined {
    return this.maxValue;
  }

  /**
   * Assigns the provided DataType object value to the `maxValue` property.
   *
   * @decorator `@ChoiceDataTypes('ElementDefinition.maxValue[x]')`
   *
   * @param value - the `maxValue` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  @ChoiceDataTypes('ElementDefinition.maxValue[x]')
  public setMaxValue(value: IDataType | undefined): this {
    if (isDefined<IDataType>(value)) {
      // assertFhirType<IDataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.maxValue = value;
    } else {
      this.maxValue = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `maxValue` property exists and has a value; `false` otherwise
   */
  public hasMaxValue(): boolean {
    return isDefined<IDataType>(this.maxValue) && !this.maxValue.isEmpty();
  }

  // *** NOTE ***
  // Following choice datatype-specific "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the `maxValue` property value as a DateType object if defined; else undefined
   */
  public getMaxValueDateType(): DateType | undefined {
    if (!isDefined<IDataType | undefined>(this.maxValue)) {
      return undefined;
    }
    if (!(this.maxValue instanceof DateType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.maxValue[x]: Expected DateType but encountered ${this.maxValue.fhirType()}`,
      );
    }
    return this.maxValue;
  }

  /**
   * @returns `true` if the `maxValue` property exists as a DateType and has a value; `false` otherwise
   */
  public hasMaxValueDateType(): boolean {
    return this.hasMaxValue() && this.maxValue instanceof DateType;
  }

  /**
   * @returns the `maxValue` property value as a DateTimeType object if defined; else undefined
   */
  public getMaxValueDateTimeType(): DateTimeType | undefined {
    if (!isDefined<IDataType | undefined>(this.maxValue)) {
      return undefined;
    }
    if (!(this.maxValue instanceof DateTimeType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.maxValue[x]: Expected DateTimeType but encountered ${this.maxValue.fhirType()}`,
      );
    }
    return this.maxValue;
  }

  /**
   * @returns `true` if the `maxValue` property exists as a DateTimeType and has a value; `false` otherwise
   */
  public hasMaxValueDateTimeType(): boolean {
    return this.hasMaxValue() && this.maxValue instanceof DateTimeType;
  }

  /**
   * @returns the `maxValue` property value as a InstantType object if defined; else undefined
   */
  public getMaxValueInstantType(): InstantType | undefined {
    if (!isDefined<IDataType | undefined>(this.maxValue)) {
      return undefined;
    }
    if (!(this.maxValue instanceof InstantType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.maxValue[x]: Expected InstantType but encountered ${this.maxValue.fhirType()}`,
      );
    }
    return this.maxValue;
  }

  /**
   * @returns `true` if the `maxValue` property exists as a InstantType and has a value; `false` otherwise
   */
  public hasMaxValueInstantType(): boolean {
    return this.hasMaxValue() && this.maxValue instanceof InstantType;
  }

  /**
   * @returns the `maxValue` property value as a TimeType object if defined; else undefined
   */
  public getMaxValueTimeType(): TimeType | undefined {
    if (!isDefined<IDataType | undefined>(this.maxValue)) {
      return undefined;
    }
    if (!(this.maxValue instanceof TimeType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.maxValue[x]: Expected TimeType but encountered ${this.maxValue.fhirType()}`,
      );
    }
    return this.maxValue;
  }

  /**
   * @returns `true` if the `maxValue` property exists as a TimeType and has a value; `false` otherwise
   */
  public hasMaxValueTimeType(): boolean {
    return this.hasMaxValue() && this.maxValue instanceof TimeType;
  }

  /**
   * @returns the `maxValue` property value as a DecimalType object if defined; else undefined
   */
  public getMaxValueDecimalType(): DecimalType | undefined {
    if (!isDefined<IDataType | undefined>(this.maxValue)) {
      return undefined;
    }
    if (!(this.maxValue instanceof DecimalType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.maxValue[x]: Expected DecimalType but encountered ${this.maxValue.fhirType()}`,
      );
    }
    return this.maxValue;
  }

  /**
   * @returns `true` if the `maxValue` property exists as a DecimalType and has a value; `false` otherwise
   */
  public hasMaxValueDecimalType(): boolean {
    return this.hasMaxValue() && this.maxValue instanceof DecimalType;
  }

  /**
   * @returns the `maxValue` property value as a IntegerType object if defined; else undefined
   */
  public getMaxValueIntegerType(): IntegerType | undefined {
    if (!isDefined<IDataType | undefined>(this.maxValue)) {
      return undefined;
    }
    if (!(this.maxValue instanceof IntegerType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.maxValue[x]: Expected IntegerType but encountered ${this.maxValue.fhirType()}`,
      );
    }
    return this.maxValue;
  }

  /**
   * @returns `true` if the `maxValue` property exists as a IntegerType and has a value; `false` otherwise
   */
  public hasMaxValueIntegerType(): boolean {
    return this.hasMaxValue() && this.maxValue instanceof IntegerType;
  }

  /**
   * @returns the `maxValue` property value as a PositiveIntType object if defined; else undefined
   */
  public getMaxValuePositiveIntType(): PositiveIntType | undefined {
    if (!isDefined<IDataType | undefined>(this.maxValue)) {
      return undefined;
    }
    if (!(this.maxValue instanceof PositiveIntType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.maxValue[x]: Expected PositiveIntType but encountered ${this.maxValue.fhirType()}`,
      );
    }
    return this.maxValue;
  }

  /**
   * @returns `true` if the `maxValue` property exists as a PositiveIntType and has a value; `false` otherwise
   */
  public hasMaxValuePositiveIntType(): boolean {
    return this.hasMaxValue() && this.maxValue instanceof PositiveIntType;
  }

  /**
   * @returns the `maxValue` property value as a UnsignedIntType object if defined; else undefined
   */
  public getMaxValueUnsignedIntType(): UnsignedIntType | undefined {
    if (!isDefined<IDataType | undefined>(this.maxValue)) {
      return undefined;
    }
    if (!(this.maxValue instanceof UnsignedIntType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.maxValue[x]: Expected UnsignedIntType but encountered ${this.maxValue.fhirType()}`,
      );
    }
    return this.maxValue;
  }

  /**
   * @returns `true` if the `maxValue` property exists as a UnsignedIntType and has a value; `false` otherwise
   */
  public hasMaxValueUnsignedIntType(): boolean {
    return this.hasMaxValue() && this.maxValue instanceof UnsignedIntType;
  }

  /**
   * @returns the `maxValue` property value as a Quantity object if defined; else undefined
   */
  public getMaxValueQuantity(): Quantity | undefined {
    if (!isDefined<IDataType | undefined>(this.maxValue)) {
      return undefined;
    }
    if (!(this.maxValue instanceof Quantity)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.maxValue[x]: Expected Quantity but encountered ${this.maxValue.fhirType()}`,
      );
    }
    return this.maxValue;
  }

  /**
   * @returns `true` if the `maxValue` property exists as a Quantity and has a value; `false` otherwise
   */
  public hasMaxValueQuantity(): boolean {
    return this.hasMaxValue() && this.maxValue instanceof Quantity;
  }

  // End of choice datatype-specific "get"/"has" methods

  /**
   * @returns the `maxLength` property value as a IntegerType object if defined; else an empty IntegerType object
   */
  public getMaxLengthElement(): IntegerType {
    return this.maxLength ?? new IntegerType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `maxLength` property.
   *
   * @param element - the `maxLength` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMaxLengthElement(element: IntegerType | undefined): this {
    if (isDefined<IntegerType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.maxLength; Provided element is not an instance of IntegerType.`;
      assertFhirType<IntegerType>(element, IntegerType, optErrMsg);
      this.maxLength = element;
    } else {
      this.maxLength = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `maxLength` property exists and has a value; `false` otherwise
   */
  public hasMaxLengthElement(): boolean {
    return isDefined<IntegerType>(this.maxLength) && !this.maxLength.isEmpty();
  }

  /**
   * @returns the `maxLength` property value as a fhirInteger if defined; else undefined
   */
  public getMaxLength(): fhirInteger | undefined {
    return this.maxLength?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `maxLength` property.
   *
   * @param value - the `maxLength` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMaxLength(value: fhirInteger | undefined): this {
    if (isDefined<fhirInteger>(value)) {
      const optErrMsg = `Invalid ElementDefinition.maxLength (${String(value)})`;
      this.maxLength = new IntegerType(parseFhirPrimitiveData(value, fhirIntegerSchema, optErrMsg));
    } else {
      this.maxLength = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `maxLength` property exists and has a value; `false` otherwise
   */
  public hasMaxLength(): boolean {
    return this.hasMaxLengthElement();
  }

  /**
   * @returns the `condition` property value as a IdType array
   */
  public getConditionElement(): IdType[] {
    return this.condition ?? ([] as IdType[]);
  }

  /**
   * Assigns the provided IdType array value to the `condition` property.
   *
   * @param element - the `condition` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setConditionElement(element: IdType[] | undefined): this {
    if (isDefinedList<IdType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.condition; Provided value array has an element that is not an instance of IdType.`;
      assertFhirTypeList<IdType>(element, IdType, optErrMsg);
      this.condition = element;
    } else {
      this.condition = undefined;
    }
    return this;
  }

  /**
   * Add the provided IdType value to the `condition` array property.
   *
   * @param element - the `condition` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addConditionElement(element: IdType | undefined): this {
    if (isDefined<IdType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.condition; Provided element is not an instance of IdType.`;
      assertFhirType<IdType>(element, IdType, optErrMsg);
      this.initCondition();
      this.condition?.push(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `condition` property exists and has a value; `false` otherwise
   */
  public hasConditionElement(): boolean {
    return isDefinedList<IdType>(this.condition) && this.condition.some((item: IdType) => !item.isEmpty());
  }

  /**
   * @returns the `condition` property value as a fhirId array
   */
  public getCondition(): fhirId[] {
    this.initCondition();
    const conditionValues = [] as fhirId[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.condition!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        conditionValues.push(value);
      }
    }
    return conditionValues;
  }

  /**
   * Assigns the provided primitive value array to the `condition` property.
   *
   * @param value - the `condition` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCondition(value: fhirId[] | undefined): this {
    if (isDefinedList<fhirId>(value)) {
      const conditionElements = [] as IdType[];
      for (const conditionValue of value) {
        const optErrMsg = `Invalid ElementDefinition.condition array item (${String(conditionValue)})`;
        const element = new IdType(parseFhirPrimitiveData(conditionValue, fhirIdSchema, optErrMsg));
        conditionElements.push(element);
      }
      this.condition = conditionElements;
    } else {
      this.condition = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the `condition` array property.
   *
   * @param value - the `condition` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addCondition(value: fhirId | undefined): this {
    if (isDefined<fhirId>(value)) {
      const optErrMsg = `Invalid ElementDefinition.condition array item (${String(value)})`;
      const element = new IdType(parseFhirPrimitiveData(value, fhirIdSchema, optErrMsg));
      this.initCondition();
      this.addConditionElement(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `condition` property exists and has a value; `false` otherwise
   */
  public hasCondition(): boolean {
    return this.hasConditionElement();
  }

  /**
   * Initialize the `condition` property
   */
  private initCondition(): void {
    if (!this.hasCondition()) {
      this.condition = [] as IdType[];
    }
  }

  /**
   * @returns the `constraint` property value as a ElementDefinitionConstraintComponent array
   */
  public getConstraint(): ElementDefinitionConstraintComponent[] {
    return this.constraint ?? ([] as ElementDefinitionConstraintComponent[]);
  }

  /**
   * Assigns the provided ElementDefinitionConstraintComponent array value to the `constraint` property.
   *
   * @param value - the `constraint` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setConstraint(value: ElementDefinitionConstraintComponent[] | undefined): this {
    if (isDefinedList<ElementDefinitionConstraintComponent>(value)) {
      const optErrMsg = `Invalid ElementDefinition.constraint; Provided value array has an element that is not an instance of ElementDefinitionConstraintComponent.`;
      assertFhirTypeList<ElementDefinitionConstraintComponent>(value, ElementDefinitionConstraintComponent, optErrMsg);
      this.constraint = value;
    } else {
      this.constraint = undefined;
    }
    return this;
  }

  /**
   * Add the provided ElementDefinitionConstraintComponent value to the `constraint` array property.
   *
   * @param value - the `constraint` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addConstraint(value: ElementDefinitionConstraintComponent | undefined): this {
    if (isDefined<ElementDefinitionConstraintComponent>(value)) {
      const optErrMsg = `Invalid ElementDefinition.constraint; Provided element is not an instance of ElementDefinitionConstraintComponent.`;
      assertFhirType<ElementDefinitionConstraintComponent>(value, ElementDefinitionConstraintComponent, optErrMsg);
      this.initConstraint();
      this.constraint?.push(value);
    }
    return this;
  }

  /**
   * @returns `true` if the `constraint` property exists and has a value; `false` otherwise
   */
  public hasConstraint(): boolean {
    return isDefinedList<ElementDefinitionConstraintComponent>(this.constraint) && this.constraint.some((item: ElementDefinitionConstraintComponent) => !item.isEmpty());
  }

  /**
   * Initialize the `constraint` property
   */
  private initConstraint(): void {
    if(!this.hasConstraint()) {
      this.constraint = [] as ElementDefinitionConstraintComponent[];
    }
  }

  /**
   * @returns the `mustSupport` property value as a BooleanType object if defined; else an empty BooleanType object
   */
  public getMustSupportElement(): BooleanType {
    return this.mustSupport ?? new BooleanType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `mustSupport` property.
   *
   * @param element - the `mustSupport` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMustSupportElement(element: BooleanType | undefined): this {
    if (isDefined<BooleanType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.mustSupport; Provided element is not an instance of BooleanType.`;
      assertFhirType<BooleanType>(element, BooleanType, optErrMsg);
      this.mustSupport = element;
    } else {
      this.mustSupport = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `mustSupport` property exists and has a value; `false` otherwise
   */
  public hasMustSupportElement(): boolean {
    return isDefined<BooleanType>(this.mustSupport) && !this.mustSupport.isEmpty();
  }

  /**
   * @returns the `mustSupport` property value as a fhirBoolean if defined; else undefined
   */
  public getMustSupport(): fhirBoolean | undefined {
    return this.mustSupport?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `mustSupport` property.
   *
   * @param value - the `mustSupport` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMustSupport(value: fhirBoolean | undefined): this {
    if (isDefined<fhirBoolean>(value)) {
      const optErrMsg = `Invalid ElementDefinition.mustSupport (${String(value)})`;
      this.mustSupport = new BooleanType(parseFhirPrimitiveData(value, fhirBooleanSchema, optErrMsg));
    } else {
      this.mustSupport = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `mustSupport` property exists and has a value; `false` otherwise
   */
  public hasMustSupport(): boolean {
    return this.hasMustSupportElement();
  }

  /**
   * @returns the `isModifier` property value as a BooleanType object if defined; else an empty BooleanType object
   */
  public getIsModifierElement(): BooleanType {
    return this.isModifier ?? new BooleanType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `isModifier` property.
   *
   * @param element - the `isModifier` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setIsModifierElement(element: BooleanType | undefined): this {
    if (isDefined<BooleanType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.isModifier; Provided element is not an instance of BooleanType.`;
      assertFhirType<BooleanType>(element, BooleanType, optErrMsg);
      this.isModifier = element;
    } else {
      this.isModifier = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `isModifier` property exists and has a value; `false` otherwise
   */
  public hasIsModifierElement(): boolean {
    return isDefined<BooleanType>(this.isModifier) && !this.isModifier.isEmpty();
  }

  /**
   * @returns the `isModifier` property value as a fhirBoolean if defined; else undefined
   */
  public getIsModifier(): fhirBoolean | undefined {
    return this.isModifier?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `isModifier` property.
   *
   * @param value - the `isModifier` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setIsModifier(value: fhirBoolean | undefined): this {
    if (isDefined<fhirBoolean>(value)) {
      const optErrMsg = `Invalid ElementDefinition.isModifier (${String(value)})`;
      this.isModifier = new BooleanType(parseFhirPrimitiveData(value, fhirBooleanSchema, optErrMsg));
    } else {
      this.isModifier = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `isModifier` property exists and has a value; `false` otherwise
   */
  public hasIsModifier(): boolean {
    return this.hasIsModifierElement();
  }

  /**
   * @returns the `isModifierReason` property value as a StringType object if defined; else an empty StringType object
   */
  public getIsModifierReasonElement(): StringType {
    return this.isModifierReason ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `isModifierReason` property.
   *
   * @param element - the `isModifierReason` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setIsModifierReasonElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.isModifierReason; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.isModifierReason = element;
    } else {
      this.isModifierReason = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `isModifierReason` property exists and has a value; `false` otherwise
   */
  public hasIsModifierReasonElement(): boolean {
    return isDefined<StringType>(this.isModifierReason) && !this.isModifierReason.isEmpty();
  }

  /**
   * @returns the `isModifierReason` property value as a fhirString if defined; else undefined
   */
  public getIsModifierReason(): fhirString | undefined {
    return this.isModifierReason?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `isModifierReason` property.
   *
   * @param value - the `isModifierReason` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setIsModifierReason(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid ElementDefinition.isModifierReason (${String(value)})`;
      this.isModifierReason = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.isModifierReason = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `isModifierReason` property exists and has a value; `false` otherwise
   */
  public hasIsModifierReason(): boolean {
    return this.hasIsModifierReasonElement();
  }

  /**
   * @returns the `isSummary` property value as a BooleanType object if defined; else an empty BooleanType object
   */
  public getIsSummaryElement(): BooleanType {
    return this.isSummary ?? new BooleanType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `isSummary` property.
   *
   * @param element - the `isSummary` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setIsSummaryElement(element: BooleanType | undefined): this {
    if (isDefined<BooleanType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.isSummary; Provided element is not an instance of BooleanType.`;
      assertFhirType<BooleanType>(element, BooleanType, optErrMsg);
      this.isSummary = element;
    } else {
      this.isSummary = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `isSummary` property exists and has a value; `false` otherwise
   */
  public hasIsSummaryElement(): boolean {
    return isDefined<BooleanType>(this.isSummary) && !this.isSummary.isEmpty();
  }

  /**
   * @returns the `isSummary` property value as a fhirBoolean if defined; else undefined
   */
  public getIsSummary(): fhirBoolean | undefined {
    return this.isSummary?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `isSummary` property.
   *
   * @param value - the `isSummary` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setIsSummary(value: fhirBoolean | undefined): this {
    if (isDefined<fhirBoolean>(value)) {
      const optErrMsg = `Invalid ElementDefinition.isSummary (${String(value)})`;
      this.isSummary = new BooleanType(parseFhirPrimitiveData(value, fhirBooleanSchema, optErrMsg));
    } else {
      this.isSummary = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `isSummary` property exists and has a value; `false` otherwise
   */
  public hasIsSummary(): boolean {
    return this.hasIsSummaryElement();
  }

  /**
   * @returns the `binding` property value as a ElementDefinitionBindingComponent object if defined; else an empty ElementDefinitionBindingComponent object
   */
  public getBinding(): ElementDefinitionBindingComponent {
    return this.binding ?? new ElementDefinitionBindingComponent();
  }

  /**
   * Assigns the provided Binding object value to the `binding` property.
   *
   * @param value - the `binding` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setBinding(value: ElementDefinitionBindingComponent | undefined): this {
    if (isDefined<ElementDefinitionBindingComponent>(value)) {
      const optErrMsg = `Invalid ElementDefinition.binding; Provided element is not an instance of ElementDefinitionBindingComponent.`;
      assertFhirType<ElementDefinitionBindingComponent>(value, ElementDefinitionBindingComponent, optErrMsg);
      this.binding = value;
    } else {
      this.binding = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `binding` property exists and has a value; `false` otherwise
   */
  public hasBinding(): boolean {
    return isDefined<ElementDefinitionBindingComponent>(this.binding) && !this.binding.isEmpty();
  }

  /**
   * @returns the `mapping` property value as a ElementDefinitionMappingComponent array
   */
  public getMapping(): ElementDefinitionMappingComponent[] {
    return this.mapping ?? ([] as ElementDefinitionMappingComponent[]);
  }

  /**
   * Assigns the provided ElementDefinitionMappingComponent array value to the `mapping` property.
   *
   * @param value - the `mapping` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setMapping(value: ElementDefinitionMappingComponent[] | undefined): this {
    if (isDefinedList<ElementDefinitionMappingComponent>(value)) {
      const optErrMsg = `Invalid ElementDefinition.mapping; Provided value array has an element that is not an instance of ElementDefinitionMappingComponent.`;
      assertFhirTypeList<ElementDefinitionMappingComponent>(value, ElementDefinitionMappingComponent, optErrMsg);
      this.mapping = value;
    } else {
      this.mapping = undefined;
    }
    return this;
  }

  /**
   * Add the provided ElementDefinitionMappingComponent value to the `mapping` array property.
   *
   * @param value - the `mapping` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addMapping(value: ElementDefinitionMappingComponent | undefined): this {
    if (isDefined<ElementDefinitionMappingComponent>(value)) {
      const optErrMsg = `Invalid ElementDefinition.mapping; Provided element is not an instance of ElementDefinitionMappingComponent.`;
      assertFhirType<ElementDefinitionMappingComponent>(value, ElementDefinitionMappingComponent, optErrMsg);
      this.initMapping();
      this.mapping?.push(value);
    }
    return this;
  }

  /**
   * @returns `true` if the `mapping` property exists and has a value; `false` otherwise
   */
  public hasMapping(): boolean {
    return isDefinedList<ElementDefinitionMappingComponent>(this.mapping) && this.mapping.some((item: ElementDefinitionMappingComponent) => !item.isEmpty());
  }

  /**
   * Initialize the `mapping` property
   */
  private initMapping(): void {
    if(!this.hasMapping()) {
      this.mapping = [] as ElementDefinitionMappingComponent[];
    }
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'ElementDefinition';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.path,
      this.representation,
      this.sliceName,
      this.sliceIsConstraining,
      this.label,
      this.code,
      this.slicing,
      this.short,
      this.definition,
      this.comment,
      this.requirements,
      this.alias,
      this.min,
      this.max,
      this.base,
      this.contentReference,
      this.type_,
      this.defaultValue,
      this.meaningWhenMissing,
      this.orderMeaning,
      this.fixed,
      this.pattern,
      this.example,
      this.minValue,
      this.maxValue,
      this.maxLength,
      this.condition,
      this.constraint,
      this.mustSupport,
      this.isModifier,
      this.isModifierReason,
      this.isSummary,
      this.binding,
      this.mapping,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): ElementDefinition {
    const dest = new ElementDefinition();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: ElementDefinition): void {
    super.copyValues(dest);
    dest.path = this.path ? this.path.copy() : null;
    const representationList = copyListValues<EnumCodeType>(this.representation);
    dest.representation = representationList.length === 0 ? undefined : representationList;
    dest.sliceName = this.sliceName?.copy();
    dest.sliceIsConstraining = this.sliceIsConstraining?.copy();
    dest.label = this.label?.copy();
    const codeList = copyListValues<Coding>(this.code);
    dest.code = codeList.length === 0 ? undefined : codeList;
    dest.slicing = this.slicing?.copy();
    dest.short = this.short?.copy();
    dest.definition = this.definition?.copy();
    dest.comment = this.comment?.copy();
    dest.requirements = this.requirements?.copy();
    const aliasList = copyListValues<StringType>(this.alias);
    dest.alias = aliasList.length === 0 ? undefined : aliasList;
    dest.min = this.min?.copy();
    dest.max = this.max?.copy();
    dest.base = this.base?.copy();
    dest.contentReference = this.contentReference?.copy();
    const typeList = copyListValues<ElementDefinitionTypeComponent>(this.type_);
    dest.type_ = typeList.length === 0 ? undefined : typeList;
    dest.defaultValue = this.defaultValue?.copy() as IDataType;
    dest.meaningWhenMissing = this.meaningWhenMissing?.copy();
    dest.orderMeaning = this.orderMeaning?.copy();
    dest.fixed = this.fixed?.copy() as IDataType;
    dest.pattern = this.pattern?.copy() as IDataType;
    const exampleList = copyListValues<ElementDefinitionExampleComponent>(this.example);
    dest.example = exampleList.length === 0 ? undefined : exampleList;
    dest.minValue = this.minValue?.copy() as IDataType;
    dest.maxValue = this.maxValue?.copy() as IDataType;
    dest.maxLength = this.maxLength?.copy();
    const conditionList = copyListValues<IdType>(this.condition);
    dest.condition = conditionList.length === 0 ? undefined : conditionList;
    const constraintList = copyListValues<ElementDefinitionConstraintComponent>(this.constraint);
    dest.constraint = constraintList.length === 0 ? undefined : constraintList;
    dest.mustSupport = this.mustSupport?.copy();
    dest.isModifier = this.isModifier?.copy();
    dest.isModifierReason = this.isModifierReason?.copy();
    dest.isSummary = this.isSummary?.copy();
    dest.binding = this.binding?.copy();
    const mappingList = copyListValues<ElementDefinitionMappingComponent>(this.mapping);
    dest.mapping = mappingList.length === 0 ? undefined : mappingList;
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasPathElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirString>(this.getPathElement()!, 'path', jsonObj);
    } else {
      missingReqdProperties.push(`ElementDefinition.path`);
    }

    if (this.hasRepresentationElement()) {
      setFhirPrimitiveListJson<fhirCode>(this.getRepresentationElement(), 'representation', jsonObj);
    }

    if (this.hasSliceNameElement()) {
      setFhirPrimitiveJson<fhirString>(this.getSliceNameElement(), 'sliceName', jsonObj);
    }

    if (this.hasSliceIsConstrainingElement()) {
      setFhirPrimitiveJson<fhirBoolean>(this.getSliceIsConstrainingElement(), 'sliceIsConstraining', jsonObj);
    }

    if (this.hasLabelElement()) {
      setFhirPrimitiveJson<fhirString>(this.getLabelElement(), 'label', jsonObj);
    }

    if (this.hasCode()) {
      setFhirComplexListJson(this.getCode(), 'code', jsonObj);
    }

    if (this.hasSlicing()) {
      setFhirComplexJson(this.getSlicing(), 'slicing', jsonObj);
    }

    if (this.hasShortElement()) {
      setFhirPrimitiveJson<fhirString>(this.getShortElement(), 'short', jsonObj);
    }

    if (this.hasDefinitionElement()) {
      setFhirPrimitiveJson<fhirMarkdown>(this.getDefinitionElement(), 'definition', jsonObj);
    }

    if (this.hasCommentElement()) {
      setFhirPrimitiveJson<fhirMarkdown>(this.getCommentElement(), 'comment', jsonObj);
    }

    if (this.hasRequirementsElement()) {
      setFhirPrimitiveJson<fhirMarkdown>(this.getRequirementsElement(), 'requirements', jsonObj);
    }

    if (this.hasAlias()) {
      setFhirPrimitiveListJson(this.getAliasElement(), 'alias', jsonObj);
    }

    if (this.hasMinElement()) {
      setFhirPrimitiveJson<fhirUnsignedInt>(this.getMinElement(), 'min', jsonObj);
    }

    if (this.hasMaxElement()) {
      setFhirPrimitiveJson<fhirString>(this.getMaxElement(), 'max', jsonObj);
    }

    if (this.hasBase()) {
      setFhirComplexJson(this.getBase(), 'base', jsonObj);
    }

    if (this.hasContentReferenceElement()) {
      setFhirPrimitiveJson<fhirUri>(this.getContentReferenceElement(), 'contentReference', jsonObj);
    }

    if (this.hasType()) {
      setFhirComplexListJson(this.getType(), 'type', jsonObj);
    }

    if (this.hasDefaultValue()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getDefaultValue()!, 'defaultValue', jsonObj);
    }

    if (this.hasMeaningWhenMissingElement()) {
      setFhirPrimitiveJson<fhirMarkdown>(this.getMeaningWhenMissingElement(), 'meaningWhenMissing', jsonObj);
    }

    if (this.hasOrderMeaningElement()) {
      setFhirPrimitiveJson<fhirString>(this.getOrderMeaningElement(), 'orderMeaning', jsonObj);
    }

    if (this.hasFixed()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getFixed()!, 'fixed', jsonObj);
    }

    if (this.hasPattern()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getPattern()!, 'pattern', jsonObj);
    }

    if (this.hasExample()) {
      setFhirComplexListJson(this.getExample(), 'example', jsonObj);
    }

    if (this.hasMinValue()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getMinValue()!, 'minValue', jsonObj);
    }

    if (this.hasMaxValue()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getMaxValue()!, 'maxValue', jsonObj);
    }

    if (this.hasMaxLengthElement()) {
      setFhirPrimitiveJson<fhirInteger>(this.getMaxLengthElement(), 'maxLength', jsonObj);
    }

    if (this.hasCondition()) {
      setFhirPrimitiveListJson(this.getConditionElement(), 'condition', jsonObj);
    }

    if (this.hasConstraint()) {
      setFhirComplexListJson(this.getConstraint(), 'constraint', jsonObj);
    }

    if (this.hasMustSupportElement()) {
      setFhirPrimitiveJson<fhirBoolean>(this.getMustSupportElement(), 'mustSupport', jsonObj);
    }

    if (this.hasIsModifierElement()) {
      setFhirPrimitiveJson<fhirBoolean>(this.getIsModifierElement(), 'isModifier', jsonObj);
    }

    if (this.hasIsModifierReasonElement()) {
      setFhirPrimitiveJson<fhirString>(this.getIsModifierReasonElement(), 'isModifierReason', jsonObj);
    }

    if (this.hasIsSummaryElement()) {
      setFhirPrimitiveJson<fhirBoolean>(this.getIsSummaryElement(), 'isSummary', jsonObj);
    }

    if (this.hasBinding()) {
      setFhirComplexJson(this.getBinding(), 'binding', jsonObj);
    }

    if (this.hasMapping()) {
      setFhirComplexListJson(this.getMapping(), 'mapping', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_DO_NOT_EXIST} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
/**
 * ElementDefinitionSlicingComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** This element is sliced - slices follow
 * - **Definition:** Indicates that the element is sliced into a set of alternative definitions (i.e. in a structure definition, there are multiple different constraints on a single element in the base resource). Slicing can be used in any resource that has cardinality ..* on the base resource, or any resource with a choice of types. The set of slices is any elements that come after this in the element sequence that have the same path, until a shorter path occurs (the shorter path terminates the set).
 * - **Comment:** The first element in the sequence, the one that carries the slicing, is the definition that applies to all the slices. This is based on the unconstrained element, but can apply any constraints as appropriate. This may include the common constraints on the children of the element.
 *
 * @category Data Models: ComplexType
 * @see [FHIR ElementDefinition](http://hl7.org/fhir/StructureDefinition/ElementDefinition)
 */
export class ElementDefinitionSlicingComponent extends DataType implements IDataType {
  constructor(rules: EnumCodeType | CodeType | fhirCode | null = null) {
    super();

    this.resourceSlicingRulesEnum = new ResourceSlicingRulesEnum();

    this.rules = constructorCodeValueAsEnumCodeType<ResourceSlicingRulesEnum>(
      rules,
      ResourceSlicingRulesEnum,
      this.resourceSlicingRulesEnum,
      'ElementDefinition.slicing.rules',
    );
  }

  /**
   * Parse the provided `ElementDefinitionSlicingComponent` JSON to instantiate the ElementDefinitionSlicingComponent data model.
   *
   * @param sourceJson - JSON representing FHIR `ElementDefinitionSlicingComponent`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to ElementDefinitionSlicingComponent
   * @returns ElementDefinitionSlicingComponent data model or undefined for `ElementDefinitionSlicingComponent`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): ElementDefinitionSlicingComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'ElementDefinitionSlicingComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new ElementDefinitionSlicingComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'discriminator';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: ElementDefinitionSlicingDiscriminatorComponent | undefined = ElementDefinitionSlicingDiscriminatorComponent.parse(dataElementJson, `${sourceField}[${String(idx)}]`);
        if (datatype !== undefined) {
          instance.addDiscriminator(datatype);
        }
      });
    }

    fieldName = 'description';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setDescriptionElement(datatype);
    }

    fieldName = 'ordered';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'boolean';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: BooleanType | undefined = fhirParser.parseBooleanType(dtJson, dtSiblingJson);
      instance.setOrderedElement(datatype);
    }

    fieldName = 'rules';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setRulesElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_REQD_IN_JSON} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * ElementDefinition.slicing.discriminator Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Element values that are used to distinguish the slices
   * - **Definition:** Designates which child elements are used to discriminate between the slices when processing an instance. If one or more discriminators are provided, the value of the child elements in the instance data SHALL completely distinguish which slice the element in the resource matches based on the allowed values for those elements in each of the slices.
   * - **Comment:** If there is no discriminator, the content is hard to process, so this should be avoided.
   * - **FHIR Type:** `Element`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private discriminator?: ElementDefinitionSlicingDiscriminatorComponent[] | undefined;

  /**
   * ElementDefinition.slicing.description Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Text description of how slicing works (or not)
   * - **Definition:** A human-readable text description of how the slicing works. If there is no discriminator, this is required to be present to provide whatever information is possible about how the slices can be differentiated.
   * - **Comment:** If it\'s really not possible to differentiate them, the design should be re-evaluated to make the content usable.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private description?: StringType | undefined;

  /**
   * ElementDefinition.slicing.ordered Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** If elements must be in same order as slices
   * - **Definition:** If the matching elements have to occur in the same order as defined in the profile.
   * - **Comment:** Order should only be required when it is a pressing concern for presentation. Profile authors should consider making the order a feature of the rules about the narrative, not the rules about the data - requiring ordered data makes the profile much less re-usable.
   * - **FHIR Type:** `boolean`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private ordered?: BooleanType | undefined;

  /**
   * FHIR CodeSystem: ResourceSlicingRules
   *
   * @see {@link ResourceSlicingRulesEnum }
   */
  private readonly resourceSlicingRulesEnum: ResourceSlicingRulesEnum;

  /**
   * ElementDefinition.slicing.rules Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** closed | open | openAtEnd
   * - **Definition:** Whether additional slices are allowed or not. When the slices are ordered, profile authors can also say that additional slices are only allowed at the end.
   * - **Comment:** Allowing additional elements makes for a much for flexible template - it\'s open for use in wider contexts, but also means that the content of the resource is not closed, and applications have to decide how to handle content not described by the profile.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link ResourceSlicingRulesEnum }
   */
  private rules: EnumCodeType | null;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `discriminator` property value as a ElementDefinitionSlicingDiscriminatorComponent array
   */
  public getDiscriminator(): ElementDefinitionSlicingDiscriminatorComponent[] {
    return this.discriminator ?? ([] as ElementDefinitionSlicingDiscriminatorComponent[]);
  }

  /**
   * Assigns the provided ElementDefinitionSlicingDiscriminatorComponent array value to the `discriminator` property.
   *
   * @param value - the `discriminator` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setDiscriminator(value: ElementDefinitionSlicingDiscriminatorComponent[] | undefined): this {
    if (isDefinedList<ElementDefinitionSlicingDiscriminatorComponent>(value)) {
      const optErrMsg = `Invalid ElementDefinition.slicing.discriminator; Provided value array has an element that is not an instance of ElementDefinitionSlicingDiscriminatorComponent.`;
      assertFhirTypeList<ElementDefinitionSlicingDiscriminatorComponent>(value, ElementDefinitionSlicingDiscriminatorComponent, optErrMsg);
      this.discriminator = value;
    } else {
      this.discriminator = undefined;
    }
    return this;
  }

  /**
   * Add the provided ElementDefinitionSlicingDiscriminatorComponent value to the `discriminator` array property.
   *
   * @param value - the `discriminator` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addDiscriminator(value: ElementDefinitionSlicingDiscriminatorComponent | undefined): this {
    if (isDefined<ElementDefinitionSlicingDiscriminatorComponent>(value)) {
      const optErrMsg = `Invalid ElementDefinition.slicing.discriminator; Provided element is not an instance of ElementDefinitionSlicingDiscriminatorComponent.`;
      assertFhirType<ElementDefinitionSlicingDiscriminatorComponent>(value, ElementDefinitionSlicingDiscriminatorComponent, optErrMsg);
      this.initDiscriminator();
      this.discriminator?.push(value);
    }
    return this;
  }

  /**
   * @returns `true` if the `discriminator` property exists and has a value; `false` otherwise
   */
  public hasDiscriminator(): boolean {
    return isDefinedList<ElementDefinitionSlicingDiscriminatorComponent>(this.discriminator) && this.discriminator.some((item: ElementDefinitionSlicingDiscriminatorComponent) => !item.isEmpty());
  }

  /**
   * Initialize the `discriminator` property
   */
  private initDiscriminator(): void {
    if(!this.hasDiscriminator()) {
      this.discriminator = [] as ElementDefinitionSlicingDiscriminatorComponent[];
    }
  }

  /**
   * @returns the `description` property value as a StringType object if defined; else an empty StringType object
   */
  public getDescriptionElement(): StringType {
    return this.description ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `description` property.
   *
   * @param element - the `description` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDescriptionElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.slicing.description; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.description = element;
    } else {
      this.description = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `description` property exists and has a value; `false` otherwise
   */
  public hasDescriptionElement(): boolean {
    return isDefined<StringType>(this.description) && !this.description.isEmpty();
  }

  /**
   * @returns the `description` property value as a fhirString if defined; else undefined
   */
  public getDescription(): fhirString | undefined {
    return this.description?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `description` property.
   *
   * @param value - the `description` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDescription(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid ElementDefinition.slicing.description (${String(value)})`;
      this.description = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.description = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `description` property exists and has a value; `false` otherwise
   */
  public hasDescription(): boolean {
    return this.hasDescriptionElement();
  }

  /**
   * @returns the `ordered` property value as a BooleanType object if defined; else an empty BooleanType object
   */
  public getOrderedElement(): BooleanType {
    return this.ordered ?? new BooleanType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `ordered` property.
   *
   * @param element - the `ordered` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setOrderedElement(element: BooleanType | undefined): this {
    if (isDefined<BooleanType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.slicing.ordered; Provided element is not an instance of BooleanType.`;
      assertFhirType<BooleanType>(element, BooleanType, optErrMsg);
      this.ordered = element;
    } else {
      this.ordered = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `ordered` property exists and has a value; `false` otherwise
   */
  public hasOrderedElement(): boolean {
    return isDefined<BooleanType>(this.ordered) && !this.ordered.isEmpty();
  }

  /**
   * @returns the `ordered` property value as a fhirBoolean if defined; else undefined
   */
  public getOrdered(): fhirBoolean | undefined {
    return this.ordered?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `ordered` property.
   *
   * @param value - the `ordered` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setOrdered(value: fhirBoolean | undefined): this {
    if (isDefined<fhirBoolean>(value)) {
      const optErrMsg = `Invalid ElementDefinition.slicing.ordered (${String(value)})`;
      this.ordered = new BooleanType(parseFhirPrimitiveData(value, fhirBooleanSchema, optErrMsg));
    } else {
      this.ordered = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `ordered` property exists and has a value; `false` otherwise
   */
  public hasOrdered(): boolean {
    return this.hasOrderedElement();
  }

  /**
   * @returns the `rules` property value as a EnumCodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link ResourceSlicingRulesEnum }
   */
  public getRulesEnumType(): EnumCodeType | null {
    return this.rules;
  }

  /**
   * Assigns the provided EnumCodeType value to the `rules` property.
   *
   * @param enumType - the `rules` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ResourceSlicingRulesEnum }
   */
  public setRulesEnumType(enumType: EnumCodeType): this {
    assertIsDefined<EnumCodeType>(enumType, `ElementDefinition.slicing.rules is required`);
    const errMsgPrefix = `Invalid ElementDefinition.slicing.rules`;
    assertEnumCodeType<ResourceSlicingRulesEnum>(enumType, ResourceSlicingRulesEnum, errMsgPrefix);
    this.rules = enumType;
    return this;
  }

  /**
   * @returns `true` if the `rules` property exists and has a value; `false` otherwise
   */
  public hasRulesEnumType(): boolean {
    return isDefined<EnumCodeType>(this.rules) && !this.rules.isEmpty() && this.rules.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the `rules` property value as a CodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link ResourceSlicingRulesEnum }
   */
  public getRulesElement(): CodeType | null {
    if (this.rules === null) {
      return null;
    }
    return this.rules as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the `rules` property.
   *
   * @param element - the `rules` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ResourceSlicingRulesEnum }
   */
  public setRulesElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, `ElementDefinition.slicing.rules is required`);
    const optErrMsg = `Invalid ElementDefinition.slicing.rules; Provided value is not an instance of CodeType.`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.rules = new EnumCodeType(element, this.resourceSlicingRulesEnum);
    return this;
  }

  /**
   * @returns `true` if the `rules` property exists and has a value; `false` otherwise
   */
  public hasRulesElement(): boolean {
    return this.hasRulesEnumType();
  }

  /**
   * @returns the `rules` property value as a fhirCode if defined; else null
   *
   * @see CodeSystem Enumeration: {@link ResourceSlicingRulesEnum }
   */
  public getRules(): fhirCode | null {
    if (this.rules === null) {
      return null;
    }
    return this.rules.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the `rules` property.
   *
   * @param value - the `rules` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link ResourceSlicingRulesEnum }
   */
  public setRules(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, `ElementDefinition.slicing.rules is required`);
    const optErrMsg = `Invalid ElementDefinition.slicing.rules (${String(value)})`;
    this.rules = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.resourceSlicingRulesEnum);
    return this;
  }

  /**
   * @returns `true` if the `rules` property exists and has a value; `false` otherwise
   */
  public hasRules(): boolean {
    return this.hasRulesEnumType();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'ElementDefinition.slicing';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.discriminator,
      this.description,
      this.ordered,
      this.rules,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): ElementDefinitionSlicingComponent {
    const dest = new ElementDefinitionSlicingComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: ElementDefinitionSlicingComponent): void {
    super.copyValues(dest);
    const discriminatorList = copyListValues<ElementDefinitionSlicingDiscriminatorComponent>(this.discriminator);
    dest.discriminator = discriminatorList.length === 0 ? undefined : discriminatorList;
    dest.description = this.description?.copy();
    dest.ordered = this.ordered?.copy();
    dest.rules = this.rules ? this.rules.copy() : null;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasDiscriminator()) {
      setFhirComplexListJson(this.getDiscriminator(), 'discriminator', jsonObj);
    }

    if (this.hasDescriptionElement()) {
      setFhirPrimitiveJson<fhirString>(this.getDescriptionElement(), 'description', jsonObj);
    }

    if (this.hasOrderedElement()) {
      setFhirPrimitiveJson<fhirBoolean>(this.getOrderedElement(), 'ordered', jsonObj);
    }

    if (this.hasRulesElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getRulesElement()!, 'rules', jsonObj);
    } else {
      missingReqdProperties.push(`ElementDefinition.slicing.rules`);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_DO_NOT_EXIST} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
/**
 * ElementDefinitionSlicingDiscriminatorComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Element values that are used to distinguish the slices
 * - **Definition:** Designates which child elements are used to discriminate between the slices when processing an instance. If one or more discriminators are provided, the value of the child elements in the instance data SHALL completely distinguish which slice the element in the resource matches based on the allowed values for those elements in each of the slices.
 * - **Comment:** If there is no discriminator, the content is hard to process, so this should be avoided.
 *
 * @category Data Models: ComplexType
 * @see [FHIR ElementDefinition](http://hl7.org/fhir/StructureDefinition/ElementDefinition)
 */
export class ElementDefinitionSlicingDiscriminatorComponent extends DataType implements IDataType {
  constructor(type_: EnumCodeType | CodeType | fhirCode | null = null, path: StringType | fhirString | null = null) {
    super();

    this.discriminatorTypeEnum = new DiscriminatorTypeEnum();

    this.type_ = constructorCodeValueAsEnumCodeType<DiscriminatorTypeEnum>(
      type_,
      DiscriminatorTypeEnum,
      this.discriminatorTypeEnum,
      'ElementDefinition.slicing.discriminator.type',
    );

    this.path = null;
    if (isDefined<StringType | fhirString>(path)) {
      if (path instanceof PrimitiveType) {
        this.setPathElement(path);
      } else {
        this.setPath(path);
      }
    }
  }

  /**
   * Parse the provided `ElementDefinitionSlicingDiscriminatorComponent` JSON to instantiate the ElementDefinitionSlicingDiscriminatorComponent data model.
   *
   * @param sourceJson - JSON representing FHIR `ElementDefinitionSlicingDiscriminatorComponent`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to ElementDefinitionSlicingDiscriminatorComponent
   * @returns ElementDefinitionSlicingDiscriminatorComponent data model or undefined for `ElementDefinitionSlicingDiscriminatorComponent`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): ElementDefinitionSlicingDiscriminatorComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'ElementDefinitionSlicingDiscriminatorComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new ElementDefinitionSlicingDiscriminatorComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'type';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setTypeElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'path';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setPathElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_REQD_IN_JSON} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: DiscriminatorType
   *
   * @see {@link DiscriminatorTypeEnum }
   */
  private readonly discriminatorTypeEnum: DiscriminatorTypeEnum;

  /**
   * ElementDefinition.slicing.discriminator.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** value | exists | pattern | type | profile
   * - **Definition:** How the element value is interpreted when discrimination is evaluated.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link DiscriminatorTypeEnum }
   */
  private type_: EnumCodeType | null;

  /**
   * ElementDefinition.slicing.discriminator.path Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Path to element value
   * - **Definition:** A FHIRPath expression, using [the simple subset of FHIRPath](https://hl7.org/fhir/fhirpath.html#simple), that is used to identify the element on which discrimination is based.
   * - **Comment:** The only FHIRPath functions that are allowed are as(type), resolve(), and extension(url).
   * - **FHIR Type:** `string`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private path: StringType | null;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `type_` property value as a EnumCodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link DiscriminatorTypeEnum }
   */
  public getTypeEnumType(): EnumCodeType | null {
    return this.type_;
  }

  /**
   * Assigns the provided EnumCodeType value to the `type_` property.
   *
   * @param enumType - the `type_` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link DiscriminatorTypeEnum }
   */
  public setTypeEnumType(enumType: EnumCodeType): this {
    assertIsDefined<EnumCodeType>(enumType, `ElementDefinition.slicing.discriminator.type is required`);
    const errMsgPrefix = `Invalid ElementDefinition.slicing.discriminator.type`;
    assertEnumCodeType<DiscriminatorTypeEnum>(enumType, DiscriminatorTypeEnum, errMsgPrefix);
    this.type_ = enumType;
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasTypeEnumType(): boolean {
    return isDefined<EnumCodeType>(this.type_) && !this.type_.isEmpty() && this.type_.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the `type_` property value as a CodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link DiscriminatorTypeEnum }
   */
  public getTypeElement(): CodeType | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_ as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the `type_` property.
   *
   * @param element - the `type_` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link DiscriminatorTypeEnum }
   */
  public setTypeElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, `ElementDefinition.slicing.discriminator.type is required`);
    const optErrMsg = `Invalid ElementDefinition.slicing.discriminator.type; Provided value is not an instance of CodeType.`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.type_ = new EnumCodeType(element, this.discriminatorTypeEnum);
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasTypeElement(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the `type_` property value as a fhirCode if defined; else null
   *
   * @see CodeSystem Enumeration: {@link DiscriminatorTypeEnum }
   */
  public getType(): fhirCode | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the `type_` property.
   *
   * @param value - the `type_` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link DiscriminatorTypeEnum }
   */
  public setType(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, `ElementDefinition.slicing.discriminator.type is required`);
    const optErrMsg = `Invalid ElementDefinition.slicing.discriminator.type (${String(value)})`;
    this.type_ = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.discriminatorTypeEnum);
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasType(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the `path` property value as a StringType object if defined; else null
   */
  public getPathElement(): StringType | null {
    return this.path;
  }

  /**
   * Assigns the provided PrimitiveType value to the `path` property.
   *
   * @param element - the `path` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPathElement(element: StringType): this {
    assertIsDefined<StringType>(element, `ElementDefinition.slicing.discriminator.path is required`);
    const optErrMsg = `Invalid ElementDefinition.slicing.discriminator.path; Provided value is not an instance of StringType.`;
    assertFhirType<StringType>(element, StringType, optErrMsg);
    this.path = element;
    return this;
  }

  /**
   * @returns `true` if the `path` property exists and has a value; `false` otherwise
   */
  public hasPathElement(): boolean {
    return isDefined<StringType>(this.path) && !this.path.isEmpty();
  }

  /**
   * @returns the `path` property value as a fhirString if defined; else null
   */
  public getPath(): fhirString | null {
    if (this.path?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.path.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the `path` property.
   *
   * @param value - the `path` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPath(value: fhirString): this {
    assertIsDefined<fhirString>(value, `ElementDefinition.slicing.discriminator.path is required`);
    const optErrMsg = `Invalid ElementDefinition.slicing.discriminator.path (${String(value)})`;
    this.path = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    return this;
  }

  /**
   * @returns `true` if the `path` property exists and has a value; `false` otherwise
   */
  public hasPath(): boolean {
    return this.hasPathElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'ElementDefinition.slicing.discriminator';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.type_,
      this.path,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): ElementDefinitionSlicingDiscriminatorComponent {
    const dest = new ElementDefinitionSlicingDiscriminatorComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: ElementDefinitionSlicingDiscriminatorComponent): void {
    super.copyValues(dest);
    dest.type_ = this.type_ ? this.type_.copy() : null;
    dest.path = this.path ? this.path.copy() : null;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasTypeElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getTypeElement()!, 'type', jsonObj);
    } else {
      missingReqdProperties.push(`ElementDefinition.slicing.discriminator.type`);
    }

    if (this.hasPathElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirString>(this.getPathElement()!, 'path', jsonObj);
    } else {
      missingReqdProperties.push(`ElementDefinition.slicing.discriminator.path`);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_DO_NOT_EXIST} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
/**
 * ElementDefinitionBaseComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Base definition information for tools
 * - **Definition:** Information about the base definition of the element, provided to make it unnecessary for tools to trace the deviation of the element through the derived and related profiles. When the element definition is not the original definition of an element - i.g. either in a constraint on another type, or for elements from a super type in a snap shot - then the information in provided in the element definition may be different to the base definition. On the original definition of the element, it will be same.
 * - **Comment:** The base information does not carry any information that could not be determined from the path and related profiles, but making this determination requires both that the related profiles are available, and that the algorithm to determine them be available. For tooling simplicity, the base information must always be populated in element definitions in snap shots, even if it is the same.
 *
 * @category Data Models: ComplexType
 * @see [FHIR ElementDefinition](http://hl7.org/fhir/StructureDefinition/ElementDefinition)
 */
export class ElementDefinitionBaseComponent extends DataType implements IDataType {
  constructor(path: StringType | fhirString | null = null, min: UnsignedIntType | fhirUnsignedInt | null = null, max: StringType | fhirString | null = null) {
    super();

    this.path = null;
    if (isDefined<StringType | fhirString>(path)) {
      if (path instanceof PrimitiveType) {
        this.setPathElement(path);
      } else {
        this.setPath(path);
      }
    }

    this.min = null;
    if (isDefined<UnsignedIntType | fhirUnsignedInt>(min)) {
      if (min instanceof PrimitiveType) {
        this.setMinElement(min);
      } else {
        this.setMin(min);
      }
    }

    this.max = null;
    if (isDefined<StringType | fhirString>(max)) {
      if (max instanceof PrimitiveType) {
        this.setMaxElement(max);
      } else {
        this.setMax(max);
      }
    }
  }

  /**
   * Parse the provided `ElementDefinitionBaseComponent` JSON to instantiate the ElementDefinitionBaseComponent data model.
   *
   * @param sourceJson - JSON representing FHIR `ElementDefinitionBaseComponent`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to ElementDefinitionBaseComponent
   * @returns ElementDefinitionBaseComponent data model or undefined for `ElementDefinitionBaseComponent`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): ElementDefinitionBaseComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'ElementDefinitionBaseComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new ElementDefinitionBaseComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'path';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setPathElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'min';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UnsignedIntType | undefined = fhirParser.parseUnsignedIntType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setMinElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'max';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setMaxElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_REQD_IN_JSON} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * ElementDefinition.base.path Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Path that identifies the base element
   * - **Definition:** The Path that identifies the base element - this matches the ElementDefinition.path for that element. Across FHIR, there is only one base definition of any element - that is, an element definition on a [StructureDefinition](https://hl7.org/fhir/structuredefinition.html#) without a StructureDefinition.base.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private path: StringType | null;

  /**
   * ElementDefinition.base.min Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Min cardinality of the base element
   * - **Definition:** Minimum cardinality of the base element identified by the path.
   * - **Comment:** This is provided for consistency with max, and may affect code generation of mandatory elements of the base resource are generated differently (some reference implementations have done this).
   * - **FHIR Type:** `unsignedInt`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private min: UnsignedIntType | null;

  /**
   * ElementDefinition.base.max Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Max cardinality of the base element
   * - **Definition:** Maximum cardinality of the base element identified by the path.
   * - **Comment:** This is provided to code generation, since the serialization representation in JSON differs depending on whether the base element has max > 1. Also, some forms of code generation may differ.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private max: StringType | null;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `path` property value as a StringType object if defined; else null
   */
  public getPathElement(): StringType | null {
    return this.path;
  }

  /**
   * Assigns the provided PrimitiveType value to the `path` property.
   *
   * @param element - the `path` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPathElement(element: StringType): this {
    assertIsDefined<StringType>(element, `ElementDefinition.base.path is required`);
    const optErrMsg = `Invalid ElementDefinition.base.path; Provided value is not an instance of StringType.`;
    assertFhirType<StringType>(element, StringType, optErrMsg);
    this.path = element;
    return this;
  }

  /**
   * @returns `true` if the `path` property exists and has a value; `false` otherwise
   */
  public hasPathElement(): boolean {
    return isDefined<StringType>(this.path) && !this.path.isEmpty();
  }

  /**
   * @returns the `path` property value as a fhirString if defined; else null
   */
  public getPath(): fhirString | null {
    if (this.path?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.path.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the `path` property.
   *
   * @param value - the `path` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPath(value: fhirString): this {
    assertIsDefined<fhirString>(value, `ElementDefinition.base.path is required`);
    const optErrMsg = `Invalid ElementDefinition.base.path (${String(value)})`;
    this.path = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    return this;
  }

  /**
   * @returns `true` if the `path` property exists and has a value; `false` otherwise
   */
  public hasPath(): boolean {
    return this.hasPathElement();
  }

  /**
   * @returns the `min` property value as a UnsignedIntType object if defined; else null
   */
  public getMinElement(): UnsignedIntType | null {
    return this.min;
  }

  /**
   * Assigns the provided PrimitiveType value to the `min` property.
   *
   * @param element - the `min` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMinElement(element: UnsignedIntType): this {
    assertIsDefined<UnsignedIntType>(element, `ElementDefinition.base.min is required`);
    const optErrMsg = `Invalid ElementDefinition.base.min; Provided value is not an instance of UnsignedIntType.`;
    assertFhirType<UnsignedIntType>(element, UnsignedIntType, optErrMsg);
    this.min = element;
    return this;
  }

  /**
   * @returns `true` if the `min` property exists and has a value; `false` otherwise
   */
  public hasMinElement(): boolean {
    return isDefined<UnsignedIntType>(this.min) && !this.min.isEmpty();
  }

  /**
   * @returns the `min` property value as a fhirUnsignedInt if defined; else null
   */
  public getMin(): fhirUnsignedInt | null {
    if (this.min?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.min.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the `min` property.
   *
   * @param value - the `min` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMin(value: fhirUnsignedInt): this {
    assertIsDefined<fhirUnsignedInt>(value, `ElementDefinition.base.min is required`);
    const optErrMsg = `Invalid ElementDefinition.base.min (${String(value)})`;
    this.min = new UnsignedIntType(parseFhirPrimitiveData(value, fhirUnsignedIntSchema, optErrMsg));
    return this;
  }

  /**
   * @returns `true` if the `min` property exists and has a value; `false` otherwise
   */
  public hasMin(): boolean {
    return this.hasMinElement();
  }

  /**
   * @returns the `max` property value as a StringType object if defined; else null
   */
  public getMaxElement(): StringType | null {
    return this.max;
  }

  /**
   * Assigns the provided PrimitiveType value to the `max` property.
   *
   * @param element - the `max` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMaxElement(element: StringType): this {
    assertIsDefined<StringType>(element, `ElementDefinition.base.max is required`);
    const optErrMsg = `Invalid ElementDefinition.base.max; Provided value is not an instance of StringType.`;
    assertFhirType<StringType>(element, StringType, optErrMsg);
    this.max = element;
    return this;
  }

  /**
   * @returns `true` if the `max` property exists and has a value; `false` otherwise
   */
  public hasMaxElement(): boolean {
    return isDefined<StringType>(this.max) && !this.max.isEmpty();
  }

  /**
   * @returns the `max` property value as a fhirString if defined; else null
   */
  public getMax(): fhirString | null {
    if (this.max?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.max.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the `max` property.
   *
   * @param value - the `max` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMax(value: fhirString): this {
    assertIsDefined<fhirString>(value, `ElementDefinition.base.max is required`);
    const optErrMsg = `Invalid ElementDefinition.base.max (${String(value)})`;
    this.max = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    return this;
  }

  /**
   * @returns `true` if the `max` property exists and has a value; `false` otherwise
   */
  public hasMax(): boolean {
    return this.hasMaxElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'ElementDefinition.base';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.path,
      this.min,
      this.max,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): ElementDefinitionBaseComponent {
    const dest = new ElementDefinitionBaseComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: ElementDefinitionBaseComponent): void {
    super.copyValues(dest);
    dest.path = this.path ? this.path.copy() : null;
    dest.min = this.min ? this.min.copy() : null;
    dest.max = this.max ? this.max.copy() : null;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasPathElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirString>(this.getPathElement()!, 'path', jsonObj);
    } else {
      missingReqdProperties.push(`ElementDefinition.base.path`);
    }

    if (this.hasMinElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirUnsignedInt>(this.getMinElement()!, 'min', jsonObj);
    } else {
      missingReqdProperties.push(`ElementDefinition.base.min`);
    }

    if (this.hasMaxElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirString>(this.getMaxElement()!, 'max', jsonObj);
    } else {
      missingReqdProperties.push(`ElementDefinition.base.max`);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_DO_NOT_EXIST} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
/**
 * ElementDefinitionTypeComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Data type and Profile for this element
 * - **Definition:** The data type or resource that the value of this element is permitted to be.
 * - **Comment:** The Type of the element can be left blank in a differential constraint, in which case the type is inherited from the resource. Abstract types are not permitted to appear as a type when multiple types are listed.  (I.e. Abstract types cannot be part of a choice).
 *
 * @category Data Models: ComplexType
 * @see [FHIR ElementDefinition](http://hl7.org/fhir/StructureDefinition/ElementDefinition)
 */
export class ElementDefinitionTypeComponent extends DataType implements IDataType {
  constructor(code: UriType | fhirUri | null = null) {
    super();

    this.resourceAggregationModeEnum = new ResourceAggregationModeEnum();
    this.referenceVersionRulesEnum = new ReferenceVersionRulesEnum();

    this.code = null;
    if (isDefined<UriType | fhirUri>(code)) {
      if (code instanceof PrimitiveType) {
        this.setCodeElement(code);
      } else {
        this.setCode(code);
      }
    }
  }

  /**
   * Parse the provided `ElementDefinitionTypeComponent` JSON to instantiate the ElementDefinitionTypeComponent data model.
   *
   * @param sourceJson - JSON representing FHIR `ElementDefinitionTypeComponent`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to ElementDefinitionTypeComponent
   * @returns ElementDefinitionTypeComponent data model or undefined for `ElementDefinitionTypeComponent`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): ElementDefinitionTypeComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'ElementDefinitionTypeComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new ElementDefinitionTypeComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'code';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = fhirParser.parseUriType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setCodeElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'profile';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: CanonicalType | undefined = fhirParser.parseCanonicalType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addProfileElement(datatype);
        }
      });
    }

    fieldName = 'targetProfile';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: CanonicalType | undefined = fhirParser.parseCanonicalType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addTargetProfileElement(datatype);
        }
      });
    }

    fieldName = 'aggregation';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: CodeType | undefined = fhirParser.parseCodeType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addAggregationElement(datatype);
        }
      });
    }

    fieldName = 'versioning';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setVersioningElement(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_REQD_IN_JSON} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * ElementDefinition.type.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Data type or Resource (reference to definition)
   * - **Definition:** URL of Data type or Resource that is a(or the) type used for this element. References are URLs that are relative to http://hl7.org/fhir/StructureDefinition e.g. "string" is a reference to http://hl7.org/fhir/StructureDefinition/string. Absolute URLs are only allowed in logical models.
   * - **Comment:** If the element is a reference to another resource, this element contains "Reference", and the targetProfile element defines what resources can be referenced. The targetProfile may be a reference to the general definition of a resource (e.g. http://hl7.org/fhir/StructureDefinition/Patient).
   * - **FHIR Type:** `uri`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code: UriType | null;

  /**
   * ElementDefinition.type.profile Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Profiles (StructureDefinition or IG) - one must apply
   * - **Definition:** Identifies a profile structure or implementation Guide that applies to the datatype this element refers to. If any profiles are specified, then the content must conform to at least one of them. The URL can be a local reference - to a contained StructureDefinition, or a reference to another StructureDefinition or Implementation Guide by a canonical URL. When an implementation guide is specified, the type SHALL conform to at least one profile defined in the implementation guide.
   * - **Comment:** It is possible to profile  backbone element (e.g. part of a resource), using the [profile-element](https://hl7.org/fhir/extension-elementdefinition-profile-element.html) extension.
   * - **FHIR Type:** `canonical`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/StructureDefinition',
   *       'http://hl7.org/fhir/StructureDefinition/ImplementationGuide',
   *     ]
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private profile?: CanonicalType[] | undefined;

  /**
   * ElementDefinition.type.targetProfile Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Profile (StructureDefinition or IG) on the Reference/canonical target - one must apply
   * - **Definition:** Used when the type is "Reference" or "canonical", and identifies a profile structure or implementation Guide that applies to the target of the reference this element refers to. If any profiles are specified, then the content must conform to at least one of them. The URL can be a local reference - to a contained StructureDefinition, or a reference to another StructureDefinition or Implementation Guide by a canonical URL. When an implementation guide is specified, the target resource SHALL conform to at least one profile defined in the implementation guide.
   * - **FHIR Type:** `canonical`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/StructureDefinition',
   *       'http://hl7.org/fhir/StructureDefinition/ImplementationGuide',
   *     ]
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private targetProfile?: CanonicalType[] | undefined;

  /**
   * FHIR CodeSystem: ResourceAggregationMode
   *
   * @see {@link ResourceAggregationModeEnum }
   */
  private readonly resourceAggregationModeEnum: ResourceAggregationModeEnum;

  /**
   * ElementDefinition.type.aggregation Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** contained | referenced | bundled - how aggregated
   * - **Definition:** If the type is a reference to another resource, how the resource is or can be aggregated - is it a contained resource, or a reference, and if the context is a bundle, is it included in the bundle.
   * - **Comment:** See [Aggregation Rules](https://hl7.org/fhir/elementdefinition.html#aggregation) for further clarification.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link ResourceAggregationModeEnum }
   */
  private aggregation?: EnumCodeType[] | undefined;

  /**
   * FHIR CodeSystem: ReferenceVersionRules
   *
   * @see {@link ReferenceVersionRulesEnum }
   */
  private readonly referenceVersionRulesEnum: ReferenceVersionRulesEnum;

  /**
   * ElementDefinition.type.versioning Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** either | independent | specific
   * - **Definition:** Whether this reference needs to be version specific or version independent, or whether either can be used.
   * - **Comment:** The base specification never makes a rule as to which form is allowed, but implementation guides may do this. See [Aggregation Rules](https://hl7.org/fhir/elementdefinition.html#aggregation) for further clarification.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link ReferenceVersionRulesEnum }
   */
  private versioning?: EnumCodeType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `code` property value as a UriType object if defined; else null
   */
  public getCodeElement(): UriType | null {
    return this.code;
  }

  /**
   * Assigns the provided PrimitiveType value to the `code` property.
   *
   * @param element - the `code` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCodeElement(element: UriType): this {
    assertIsDefined<UriType>(element, `ElementDefinition.type.code is required`);
    const optErrMsg = `Invalid ElementDefinition.type.code; Provided value is not an instance of UriType.`;
    assertFhirType<UriType>(element, UriType, optErrMsg);
    this.code = element;
    return this;
  }

  /**
   * @returns `true` if the `code` property exists and has a value; `false` otherwise
   */
  public hasCodeElement(): boolean {
    return isDefined<UriType>(this.code) && !this.code.isEmpty();
  }

  /**
   * @returns the `code` property value as a fhirUri if defined; else null
   */
  public getCode(): fhirUri | null {
    if (this.code?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.code.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the `code` property.
   *
   * @param value - the `code` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCode(value: fhirUri): this {
    assertIsDefined<fhirUri>(value, `ElementDefinition.type.code is required`);
    const optErrMsg = `Invalid ElementDefinition.type.code (${String(value)})`;
    this.code = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    return this;
  }

  /**
   * @returns `true` if the `code` property exists and has a value; `false` otherwise
   */
  public hasCode(): boolean {
    return this.hasCodeElement();
  }

  /**
   * @returns the `profile` property value as a CanonicalType array
   */
  public getProfileElement(): CanonicalType[] {
    return this.profile ?? ([] as CanonicalType[]);
  }

  /**
   * Assigns the provided CanonicalType array value to the `profile` property.
   *
   * @param element - the `profile` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setProfileElement(element: CanonicalType[] | undefined): this {
    if (isDefinedList<CanonicalType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.type.profile; Provided value array has an element that is not an instance of CanonicalType.`;
      assertFhirTypeList<CanonicalType>(element, CanonicalType, optErrMsg);
      this.profile = element;
    } else {
      this.profile = undefined;
    }
    return this;
  }

  /**
   * Add the provided CanonicalType value to the `profile` array property.
   *
   * @param element - the `profile` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addProfileElement(element: CanonicalType | undefined): this {
    if (isDefined<CanonicalType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.type.profile; Provided element is not an instance of CanonicalType.`;
      assertFhirType<CanonicalType>(element, CanonicalType, optErrMsg);
      this.initProfile();
      this.profile?.push(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `profile` property exists and has a value; `false` otherwise
   */
  public hasProfileElement(): boolean {
    return isDefinedList<CanonicalType>(this.profile) && this.profile.some((item: CanonicalType) => !item.isEmpty());
  }

  /**
   * @returns the `profile` property value as a fhirCanonical array
   */
  public getProfile(): fhirCanonical[] {
    this.initProfile();
    const profileValues = [] as fhirCanonical[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.profile!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        profileValues.push(value);
      }
    }
    return profileValues;
  }

  /**
   * Assigns the provided primitive value array to the `profile` property.
   *
   * @param value - the `profile` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setProfile(value: fhirCanonical[] | undefined): this {
    if (isDefinedList<fhirCanonical>(value)) {
      const profileElements = [] as CanonicalType[];
      for (const profileValue of value) {
        const optErrMsg = `Invalid ElementDefinition.type.profile array item (${String(profileValue)})`;
        const element = new CanonicalType(parseFhirPrimitiveData(profileValue, fhirCanonicalSchema, optErrMsg));
        profileElements.push(element);
      }
      this.profile = profileElements;
    } else {
      this.profile = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the `profile` array property.
   *
   * @param value - the `profile` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addProfile(value: fhirCanonical | undefined): this {
    if (isDefined<fhirCanonical>(value)) {
      const optErrMsg = `Invalid ElementDefinition.type.profile array item (${String(value)})`;
      const element = new CanonicalType(parseFhirPrimitiveData(value, fhirCanonicalSchema, optErrMsg));
      this.initProfile();
      this.addProfileElement(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `profile` property exists and has a value; `false` otherwise
   */
  public hasProfile(): boolean {
    return this.hasProfileElement();
  }

  /**
   * Initialize the `profile` property
   */
  private initProfile(): void {
    if (!this.hasProfile()) {
      this.profile = [] as CanonicalType[];
    }
  }

  /**
   * @returns the `targetProfile` property value as a CanonicalType array
   */
  public getTargetProfileElement(): CanonicalType[] {
    return this.targetProfile ?? ([] as CanonicalType[]);
  }

  /**
   * Assigns the provided CanonicalType array value to the `targetProfile` property.
   *
   * @param element - the `targetProfile` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTargetProfileElement(element: CanonicalType[] | undefined): this {
    if (isDefinedList<CanonicalType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.type.targetProfile; Provided value array has an element that is not an instance of CanonicalType.`;
      assertFhirTypeList<CanonicalType>(element, CanonicalType, optErrMsg);
      this.targetProfile = element;
    } else {
      this.targetProfile = undefined;
    }
    return this;
  }

  /**
   * Add the provided CanonicalType value to the `targetProfile` array property.
   *
   * @param element - the `targetProfile` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addTargetProfileElement(element: CanonicalType | undefined): this {
    if (isDefined<CanonicalType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.type.targetProfile; Provided element is not an instance of CanonicalType.`;
      assertFhirType<CanonicalType>(element, CanonicalType, optErrMsg);
      this.initTargetProfile();
      this.targetProfile?.push(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `targetProfile` property exists and has a value; `false` otherwise
   */
  public hasTargetProfileElement(): boolean {
    return isDefinedList<CanonicalType>(this.targetProfile) && this.targetProfile.some((item: CanonicalType) => !item.isEmpty());
  }

  /**
   * @returns the `targetProfile` property value as a fhirCanonical array
   */
  public getTargetProfile(): fhirCanonical[] {
    this.initTargetProfile();
    const targetProfileValues = [] as fhirCanonical[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.targetProfile!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        targetProfileValues.push(value);
      }
    }
    return targetProfileValues;
  }

  /**
   * Assigns the provided primitive value array to the `targetProfile` property.
   *
   * @param value - the `targetProfile` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTargetProfile(value: fhirCanonical[] | undefined): this {
    if (isDefinedList<fhirCanonical>(value)) {
      const targetProfileElements = [] as CanonicalType[];
      for (const targetProfileValue of value) {
        const optErrMsg = `Invalid ElementDefinition.type.targetProfile array item (${String(targetProfileValue)})`;
        const element = new CanonicalType(parseFhirPrimitiveData(targetProfileValue, fhirCanonicalSchema, optErrMsg));
        targetProfileElements.push(element);
      }
      this.targetProfile = targetProfileElements;
    } else {
      this.targetProfile = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the `targetProfile` array property.
   *
   * @param value - the `targetProfile` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addTargetProfile(value: fhirCanonical | undefined): this {
    if (isDefined<fhirCanonical>(value)) {
      const optErrMsg = `Invalid ElementDefinition.type.targetProfile array item (${String(value)})`;
      const element = new CanonicalType(parseFhirPrimitiveData(value, fhirCanonicalSchema, optErrMsg));
      this.initTargetProfile();
      this.addTargetProfileElement(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `targetProfile` property exists and has a value; `false` otherwise
   */
  public hasTargetProfile(): boolean {
    return this.hasTargetProfileElement();
  }

  /**
   * Initialize the `targetProfile` property
   */
  private initTargetProfile(): void {
    if (!this.hasTargetProfile()) {
      this.targetProfile = [] as CanonicalType[];
    }
  }

  /**
   * @returns the `aggregation` property value as a EnumCodeType array
   *
   * @see CodeSystem Enumeration: {@link ResourceAggregationModeEnum }
   */
  public getAggregationEnumType(): EnumCodeType[] {
    return this.aggregation ?? ([] as EnumCodeType[]);
  }

  /**
   * Assigns the provided EnumCodeType array value to the `aggregation` property.
   *
   * @param enumType - the `aggregation` array value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ResourceAggregationModeEnum }
   */
  public setAggregationEnumType(enumType: EnumCodeType[] | undefined): this {
    if (isDefinedList<EnumCodeType>(enumType)) {
      const errMsgPrefix = `Invalid ElementDefinition.type.aggregation`;
      assertEnumCodeTypeList<ResourceAggregationModeEnum>(enumType, ResourceAggregationModeEnum, errMsgPrefix);
      this.aggregation = enumType;
    } else {
      this.aggregation = undefined;
    }
    return this;
  }

  /**
   * Add the provided EnumCodeType value to the `aggregation` array property.
   *
   * @param enumType - the `aggregation` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   *
   * @see CodeSystem Enumeration: {@link ResourceAggregationModeEnum }
   */
  public addAggregationEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = `Invalid ElementDefinition.type.aggregation`;
      assertEnumCodeType<ResourceAggregationModeEnum>(enumType, ResourceAggregationModeEnum, errMsgPrefix);
      this.initAggregation();
      this.aggregation?.push(enumType);
    }
    return this;
  }

  /**
   * @returns `true` if the `aggregation` property exists and has a value; `false` otherwise
   */
  public hasAggregationEnumType(): boolean {
    return isDefinedList<EnumCodeType>(this.aggregation) && this.aggregation.some((item: EnumCodeType) => !item.isEmpty()) && this.aggregation.every((item: EnumCodeType) => item.fhirCodeEnumeration.length > 0);
  }

  /**
   * @returns the `aggregation` property value as a CodeType array
   *
   * @see CodeSystem Enumeration: {@link ResourceAggregationModeEnum }
   */
  public getAggregationElement(): CodeType[] {
    if (this.aggregation === undefined) {
      return [] as CodeType[];
    }
    return this.aggregation as CodeType[];
  }

  /**
   * Assigns the provided PrimitiveType array value to the `aggregation` property.
   *
   * @param element - the `aggregation` array value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ResourceAggregationModeEnum }
   */
  public setAggregationElement(element: CodeType[] | undefined): this {
    if (isDefinedList<CodeType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.type.aggregation; Provided element array has an element that is not an instance of CodeType.`;
      assertFhirTypeList<CodeType>(element, CodeType, optErrMsg);
      const enumCodeTypes = [] as EnumCodeType[];
      element.forEach((type: CodeType) => {
        enumCodeTypes.push(new EnumCodeType(type, this.resourceAggregationModeEnum));
      });
      this.aggregation = enumCodeTypes;
    } else {
      this.aggregation = undefined;
    }
    return this;
  }

  /**
   * Add the provided PrimitiveType value to the `aggregation` array property.
   *
   * @param element - the `aggregation` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ResourceAggregationModeEnum }
   */
  public addAggregationElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.type.aggregation; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.initAggregation();
      this.aggregation?.push(new EnumCodeType(element, this.resourceAggregationModeEnum));
    }
    return this;
  }

  /**
   * @returns `true` if the `aggregation` property exists and has a value; `false` otherwise
   */
  public hasAggregationElement(): boolean {
    return this.hasAggregationEnumType();
  }

  /**
   * @returns the `aggregation` property value as a fhirCode array
   *
   * @see CodeSystem Enumeration: {@link ResourceAggregationModeEnum }
   */
  public getAggregation(): fhirCode[] {
    if (this.aggregation === undefined) {
      return [] as fhirCode[];
    }
    const values = [] as fhirCode[];
    for (const item of this.aggregation) {
      values.push(item.fhirCode.code);
    }
    return values;
  }

  /**
   * Assigns the provided primitive value array to the `aggregation` property.
   *
   * @param value - the `aggregation` value array
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link ResourceAggregationModeEnum }
   */
  public setAggregation(value: fhirCode[] | undefined): this {
    if (isDefinedList<fhirCode>(value)) {
      const enumCodeTypes = [] as EnumCodeType[];
      const optErrMsg = `Invalid ElementDefinition.type.aggregation; Provided value is not an instance of fhirCode.`;
      value.forEach((val: fhirCode) => {
        enumCodeTypes.push(new EnumCodeType(parseFhirPrimitiveData(val, fhirCodeSchema, optErrMsg), this.resourceAggregationModeEnum));
      });
      this.aggregation = enumCodeTypes;
    } else {
      this.aggregation = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the `aggregation` array property.
   *
   * @param value - the `aggregation` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link ResourceAggregationModeEnum }
   */
  public addAggregation(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      this.initAggregation();
      const optErrMsg = `Invalid ElementDefinition.type.aggregation; Provided value is not an instance of fhirCode.`;
      this.aggregation?.push(new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.resourceAggregationModeEnum));
    }
    return this;
  }

  /**
   * @returns `true` if the `aggregation` property exists and has a value; `false` otherwise
   */
  public hasAggregation(): boolean {
    return this.hasAggregationEnumType();
  }

  /**
   * Initialize the aggregation property
   */
  private initAggregation(): void {
    if(!this.hasAggregationEnumType()) {
      this.aggregation = [] as EnumCodeType[];
    }
  }

  /**
   * @returns the `versioning` property value as a EnumCodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link ReferenceVersionRulesEnum }
   */
  public getVersioningEnumType(): EnumCodeType | undefined {
    return this.versioning;
  }

  /**
   * Assigns the provided EnumCodeType value to the `versioning` property.
   *
   * @param enumType - the `versioning` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code values
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ReferenceVersionRulesEnum }
   */
  public setVersioningEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid ElementDefinition.type.versioning';
      assertEnumCodeType<ReferenceVersionRulesEnum>(enumType, ReferenceVersionRulesEnum, errMsgPrefix);
      this.versioning = enumType;
    } else {
      this.versioning = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `versioning` property exists and has a value; `false` otherwise
   */
  public hasVersioningEnumType(): boolean {
    return isDefined<EnumCodeType>(this.versioning) && !this.versioning.isEmpty() && this.versioning.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the `versioning` property value as a CodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link ReferenceVersionRulesEnum }
   */
  public getVersioningElement(): CodeType | undefined {
    if (this.versioning === undefined) {
      return undefined;
    }
    return this.versioning as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the `versioning` property.
   *
   * @param element - the `versioning` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ReferenceVersionRulesEnum }
   */
  public setVersioningElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.type.versioning; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.versioning = new EnumCodeType(element, this.referenceVersionRulesEnum);
    } else {
      this.versioning = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `versioning` property exists and has a value; `false` otherwise
   */
  public hasVersioningElement(): boolean {
    return this.hasVersioningEnumType();
  }

  /**
   * @returns the `versioning` property value as a fhirCode if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link ReferenceVersionRulesEnum }
   */
  public getVersioning(): fhirCode | undefined {
    if (this.versioning === undefined) {
      return undefined;
    }
    return this.versioning.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the `versioning` property.
   *
   * @param value - the `versioning` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link ReferenceVersionRulesEnum }
   */
  public setVersioning(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid ElementDefinition.type.versioning; Provided value is not an instance of fhirCode.`;
      this.versioning = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.referenceVersionRulesEnum);
    } else {
      this.versioning = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `versioning` property exists and has a value; `false` otherwise
   */
  public hasVersioning(): boolean {
    return this.hasVersioningEnumType();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'ElementDefinition.type';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.code,
      this.profile,
      this.targetProfile,
      this.aggregation,
      this.versioning,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): ElementDefinitionTypeComponent {
    const dest = new ElementDefinitionTypeComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: ElementDefinitionTypeComponent): void {
    super.copyValues(dest);
    dest.code = this.code ? this.code.copy() : null;
    const profileList = copyListValues<CanonicalType>(this.profile);
    dest.profile = profileList.length === 0 ? undefined : profileList;
    const targetProfileList = copyListValues<CanonicalType>(this.targetProfile);
    dest.targetProfile = targetProfileList.length === 0 ? undefined : targetProfileList;
    const aggregationList = copyListValues<EnumCodeType>(this.aggregation);
    dest.aggregation = aggregationList.length === 0 ? undefined : aggregationList;
    dest.versioning = this.versioning?.copy();
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasCodeElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirUri>(this.getCodeElement()!, 'code', jsonObj);
    } else {
      missingReqdProperties.push(`ElementDefinition.type.code`);
    }

    if (this.hasProfile()) {
      setFhirPrimitiveListJson(this.getProfileElement(), 'profile', jsonObj);
    }

    if (this.hasTargetProfile()) {
      setFhirPrimitiveListJson(this.getTargetProfileElement(), 'targetProfile', jsonObj);
    }

    if (this.hasAggregationElement()) {
      setFhirPrimitiveListJson<fhirCode>(this.getAggregationElement(), 'aggregation', jsonObj);
    }

    if (this.hasVersioningElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getVersioningElement()!, 'versioning', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_DO_NOT_EXIST} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
/**
 * ElementDefinitionExampleComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Example value (as defined for type)
 * - **Definition:** A sample value for this element demonstrating the type of information that would typically be found in the element.
 * - **Comment:** Examples will most commonly be present for data where it\'s not implicitly obvious from either the data type or value set what the values might be.  (I.e. Example values for dates or quantities would generally be unnecessary.)  If the example value is fully populated, the publication tool can generate an instance automatically.
 *
 * @category Data Models: ComplexType
 * @see [FHIR ElementDefinition](http://hl7.org/fhir/StructureDefinition/ElementDefinition)
 */
export class ElementDefinitionExampleComponent extends DataType implements IDataType {
  constructor(label: StringType | fhirString | null = null, value: IDataType | null = null) {
    super();

    this.label = null;
    if (isDefined<StringType | fhirString>(label)) {
      if (label instanceof PrimitiveType) {
        this.setLabelElement(label);
      } else {
        this.setLabel(label);
      }
    }

    this.value = null;
    if (isDefined<IDataType>(value)) {
      this.setValue(value);
    }

  }

  /**
   * Parse the provided `ElementDefinitionExampleComponent` JSON to instantiate the ElementDefinitionExampleComponent data model.
   *
   * @param sourceJson - JSON representing FHIR `ElementDefinitionExampleComponent`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to ElementDefinitionExampleComponent
   * @returns ElementDefinitionExampleComponent data model or undefined for `ElementDefinitionExampleComponent`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): ElementDefinitionExampleComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'ElementDefinitionExampleComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new ElementDefinitionExampleComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    

    const classMetadata: DecoratorMetadataObject | null = ElementDefinitionExampleComponent[Symbol.metadata];
    const errorMessage = `DecoratorMetadataObject does not exist for ElementDefinitionExampleComponent`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    const missingReqdProperties: string[] = [];

    fieldName = 'label';
    sourceField = `${optSourceValue}.${fieldName}`;
    const primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setLabelElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'value[x]';
    sourceField = `${optSourceValue}.${fieldName}`;
    const value: IDataType | undefined = fhirParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    if (value === undefined) {
      missingReqdProperties.push(sourceField);
    } else {
      instance.setValue(value);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_REQD_IN_JSON} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * ElementDefinition.example.label Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Describes the purpose of this example
   * - **Definition:** Describes the purpose of this example amoung the set of examples.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private label: StringType | null;

  /**
   * ElementDefinition.example.value[x] Element
   *
   * @decorator `@ChoiceDataTypesMeta('ElementDefinition.example.value[x]', ['base64Binary','boolean','canonical','code','date','dateTime','decimal','id','instant','integer','markdown','oid','positiveInt','string','time','unsignedInt','uri','url','uuid','Address','Age','Annotation','Attachment','CodeableConcept','CodeableReference','Coding','ContactPoint','Count','Distance','Duration','HumanName','Identifier','Money','Period','Quantity','Range','Ratio','RatioRange','Reference','SampledData','Signature','Timing','ContactDetail','Contributor','DataRequirement','Expression','ParameterDefinition','RelatedArtifact','TriggerDefinition','UsageContext','Dosage',]`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Value of Example (one of allowed types)
   * - **Definition:** The actual value for the element, which must be one of the types allowed for this element.
   * - **FHIR Types:**
   *     'base64Binary',
   *     'boolean',
   *     'canonical',
   *     'code',
   *     'date',
   *     'dateTime',
   *     'decimal',
   *     'id',
   *     'instant',
   *     'integer',
   *     'markdown',
   *     'oid',
   *     'positiveInt',
   *     'string',
   *     'time',
   *     'unsignedInt',
   *     'uri',
   *     'url',
   *     'uuid',
   *     'Address',
   *     'Age',
   *     'Annotation',
   *     'Attachment',
   *     'CodeableConcept',
   *     'CodeableReference',
   *     'Coding',
   *     'ContactPoint',
   *     'Count',
   *     'Distance',
   *     'Duration',
   *     'HumanName',
   *     'Identifier',
   *     'Money',
   *     'Period',
   *     'Quantity',
   *     'Range',
   *     'Ratio',
   *     'RatioRange',
   *     'Reference',
   *     'SampledData',
   *     'Signature',
   *     'Timing',
   *     'ContactDetail',
   *     'Contributor',
   *     'DataRequirement',
   *     'Expression',
   *     'ParameterDefinition',
   *     'RelatedArtifact',
   *     'TriggerDefinition',
   *     'UsageContext',
   *     'Dosage',
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('ElementDefinition.example.value[x]',[
    'base64Binary',
    'boolean',
    'canonical',
    'code',
    'date',
    'dateTime',
    'decimal',
    'id',
    'instant',
    'integer',
    'markdown',
    'oid',
    'positiveInt',
    'string',
    'time',
    'unsignedInt',
    'uri',
    'url',
    'uuid',
    'Address',
    'Age',
    'Annotation',
    'Attachment',
    'CodeableConcept',
    'CodeableReference',
    'Coding',
    'ContactPoint',
    'Count',
    'Distance',
    'Duration',
    'HumanName',
    'Identifier',
    'Money',
    'Period',
    'Quantity',
    'Range',
    'Ratio',
    'RatioRange',
    'Reference',
    'SampledData',
    'Signature',
    'Timing',
    'ContactDetail',
    'Contributor',
    'DataRequirement',
    'Expression',
    'ParameterDefinition',
    'RelatedArtifact',
    'TriggerDefinition',
    'UsageContext',
    'Dosage',
  ])
  private value: IDataType | null;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `label` property value as a StringType object if defined; else null
   */
  public getLabelElement(): StringType | null {
    return this.label;
  }

  /**
   * Assigns the provided PrimitiveType value to the `label` property.
   *
   * @param element - the `label` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLabelElement(element: StringType): this {
    assertIsDefined<StringType>(element, `ElementDefinition.example.label is required`);
    const optErrMsg = `Invalid ElementDefinition.example.label; Provided value is not an instance of StringType.`;
    assertFhirType<StringType>(element, StringType, optErrMsg);
    this.label = element;
    return this;
  }

  /**
   * @returns `true` if the `label` property exists and has a value; `false` otherwise
   */
  public hasLabelElement(): boolean {
    return isDefined<StringType>(this.label) && !this.label.isEmpty();
  }

  /**
   * @returns the `label` property value as a fhirString if defined; else null
   */
  public getLabel(): fhirString | null {
    if (this.label?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.label.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the `label` property.
   *
   * @param value - the `label` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLabel(value: fhirString): this {
    assertIsDefined<fhirString>(value, `ElementDefinition.example.label is required`);
    const optErrMsg = `Invalid ElementDefinition.example.label (${String(value)})`;
    this.label = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    return this;
  }

  /**
   * @returns `true` if the `label` property exists and has a value; `false` otherwise
   */
  public hasLabel(): boolean {
    return this.hasLabelElement();
  }

  /**
   * @returns the `value` property value as a DataType object; else null
   */
  public getValue(): IDataType | null {
    return this.value;
  }

  /**
   * Assigns the provided DataType object value to the `value` property.
   *
   * @decorator `@ChoiceDataTypes('ElementDefinition.example.value[x]')`
   *
   * @param value - the `value` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  @ChoiceDataTypes('ElementDefinition.example.value[x]')
  public setValue(value: IDataType): this {
    assertIsDefined<IDataType>(value, `ElementDefinition.example.value[x] is required`);
    // assertFhirType<IDataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
    this.value = value;
    return this;
  }

  /**
   * @returns `true` if the `value` property exists and has a value; `false` otherwise
   */
  public hasValue(): boolean {
    return isDefined<IDataType>(this.value) && !this.value.isEmpty();
  }

  // *** NOTE ***
  // Following choice datatype-specific "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the `value` property value as a Base64BinaryType object if defined; else null
   */
  public getValueBase64BinaryType(): Base64BinaryType | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Base64BinaryType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected Base64BinaryType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a Base64BinaryType and has a value; `false` otherwise
   */
  public hasValueBase64BinaryType(): boolean {
    return this.hasValue() && this.value instanceof Base64BinaryType;
  }

  /**
   * @returns the `value` property value as a BooleanType object if defined; else null
   */
  public getValueBooleanType(): BooleanType | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof BooleanType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected BooleanType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a BooleanType and has a value; `false` otherwise
   */
  public hasValueBooleanType(): boolean {
    return this.hasValue() && this.value instanceof BooleanType;
  }

  /**
   * @returns the `value` property value as a CanonicalType object if defined; else null
   */
  public getValueCanonicalType(): CanonicalType | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof CanonicalType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected CanonicalType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a CanonicalType and has a value; `false` otherwise
   */
  public hasValueCanonicalType(): boolean {
    return this.hasValue() && this.value instanceof CanonicalType;
  }

  /**
   * @returns the `value` property value as a CodeType object if defined; else null
   */
  public getValueCodeType(): CodeType | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof CodeType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected CodeType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a CodeType and has a value; `false` otherwise
   */
  public hasValueCodeType(): boolean {
    return this.hasValue() && this.value instanceof CodeType;
  }

  /**
   * @returns the `value` property value as a DateType object if defined; else null
   */
  public getValueDateType(): DateType | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof DateType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected DateType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a DateType and has a value; `false` otherwise
   */
  public hasValueDateType(): boolean {
    return this.hasValue() && this.value instanceof DateType;
  }

  /**
   * @returns the `value` property value as a DateTimeType object if defined; else null
   */
  public getValueDateTimeType(): DateTimeType | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof DateTimeType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected DateTimeType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a DateTimeType and has a value; `false` otherwise
   */
  public hasValueDateTimeType(): boolean {
    return this.hasValue() && this.value instanceof DateTimeType;
  }

  /**
   * @returns the `value` property value as a DecimalType object if defined; else null
   */
  public getValueDecimalType(): DecimalType | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof DecimalType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected DecimalType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a DecimalType and has a value; `false` otherwise
   */
  public hasValueDecimalType(): boolean {
    return this.hasValue() && this.value instanceof DecimalType;
  }

  /**
   * @returns the `value` property value as a IdType object if defined; else null
   */
  public getValueIdType(): IdType | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof IdType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected IdType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a IdType and has a value; `false` otherwise
   */
  public hasValueIdType(): boolean {
    return this.hasValue() && this.value instanceof IdType;
  }

  /**
   * @returns the `value` property value as a InstantType object if defined; else null
   */
  public getValueInstantType(): InstantType | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof InstantType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected InstantType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a InstantType and has a value; `false` otherwise
   */
  public hasValueInstantType(): boolean {
    return this.hasValue() && this.value instanceof InstantType;
  }

  /**
   * @returns the `value` property value as a IntegerType object if defined; else null
   */
  public getValueIntegerType(): IntegerType | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof IntegerType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected IntegerType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a IntegerType and has a value; `false` otherwise
   */
  public hasValueIntegerType(): boolean {
    return this.hasValue() && this.value instanceof IntegerType;
  }

  /**
   * @returns the `value` property value as a MarkdownType object if defined; else null
   */
  public getValueMarkdownType(): MarkdownType | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof MarkdownType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected MarkdownType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a MarkdownType and has a value; `false` otherwise
   */
  public hasValueMarkdownType(): boolean {
    return this.hasValue() && this.value instanceof MarkdownType;
  }

  /**
   * @returns the `value` property value as a OidType object if defined; else null
   */
  public getValueOidType(): OidType | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof OidType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected OidType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a OidType and has a value; `false` otherwise
   */
  public hasValueOidType(): boolean {
    return this.hasValue() && this.value instanceof OidType;
  }

  /**
   * @returns the `value` property value as a PositiveIntType object if defined; else null
   */
  public getValuePositiveIntType(): PositiveIntType | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof PositiveIntType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected PositiveIntType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a PositiveIntType and has a value; `false` otherwise
   */
  public hasValuePositiveIntType(): boolean {
    return this.hasValue() && this.value instanceof PositiveIntType;
  }

  /**
   * @returns the `value` property value as a StringType object if defined; else null
   */
  public getValueStringType(): StringType | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof StringType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected StringType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a StringType and has a value; `false` otherwise
   */
  public hasValueStringType(): boolean {
    return this.hasValue() && this.value instanceof StringType;
  }

  /**
   * @returns the `value` property value as a TimeType object if defined; else null
   */
  public getValueTimeType(): TimeType | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof TimeType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected TimeType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a TimeType and has a value; `false` otherwise
   */
  public hasValueTimeType(): boolean {
    return this.hasValue() && this.value instanceof TimeType;
  }

  /**
   * @returns the `value` property value as a UnsignedIntType object if defined; else null
   */
  public getValueUnsignedIntType(): UnsignedIntType | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof UnsignedIntType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected UnsignedIntType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a UnsignedIntType and has a value; `false` otherwise
   */
  public hasValueUnsignedIntType(): boolean {
    return this.hasValue() && this.value instanceof UnsignedIntType;
  }

  /**
   * @returns the `value` property value as a UriType object if defined; else null
   */
  public getValueUriType(): UriType | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof UriType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected UriType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a UriType and has a value; `false` otherwise
   */
  public hasValueUriType(): boolean {
    return this.hasValue() && this.value instanceof UriType;
  }

  /**
   * @returns the `value` property value as a UrlType object if defined; else null
   */
  public getValueUrlType(): UrlType | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof UrlType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected UrlType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a UrlType and has a value; `false` otherwise
   */
  public hasValueUrlType(): boolean {
    return this.hasValue() && this.value instanceof UrlType;
  }

  /**
   * @returns the `value` property value as a UuidType object if defined; else null
   */
  public getValueUuidType(): UuidType | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof UuidType)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected UuidType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a UuidType and has a value; `false` otherwise
   */
  public hasValueUuidType(): boolean {
    return this.hasValue() && this.value instanceof UuidType;
  }

  /**
   * @returns the `value` property value as a Address object if defined; else null
   */
  public getValueAddress(): Address | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Address)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected Address but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a Address and has a value; `false` otherwise
   */
  public hasValueAddress(): boolean {
    return this.hasValue() && this.value instanceof Address;
  }

  /**
   * @returns the `value` property value as a Age object if defined; else null
   */
  public getValueAge(): Age | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Age)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected Age but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a Age and has a value; `false` otherwise
   */
  public hasValueAge(): boolean {
    return this.hasValue() && this.value instanceof Age;
  }

  /**
   * @returns the `value` property value as a Annotation object if defined; else null
   */
  public getValueAnnotation(): Annotation | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Annotation)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected Annotation but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a Annotation and has a value; `false` otherwise
   */
  public hasValueAnnotation(): boolean {
    return this.hasValue() && this.value instanceof Annotation;
  }

  /**
   * @returns the `value` property value as a Attachment object if defined; else null
   */
  public getValueAttachment(): Attachment | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Attachment)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected Attachment but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a Attachment and has a value; `false` otherwise
   */
  public hasValueAttachment(): boolean {
    return this.hasValue() && this.value instanceof Attachment;
  }

  /**
   * @returns the `value` property value as a CodeableConcept object if defined; else null
   */
  public getValueCodeableConcept(): CodeableConcept | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof CodeableConcept)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected CodeableConcept but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a CodeableConcept and has a value; `false` otherwise
   */
  public hasValueCodeableConcept(): boolean {
    return this.hasValue() && this.value instanceof CodeableConcept;
  }

  /**
   * @returns the `value` property value as a CodeableReference object if defined; else null
   */
  public getValueCodeableReference(): CodeableReference | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof CodeableReference)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected CodeableReference but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a CodeableReference and has a value; `false` otherwise
   */
  public hasValueCodeableReference(): boolean {
    return this.hasValue() && this.value instanceof CodeableReference;
  }

  /**
   * @returns the `value` property value as a Coding object if defined; else null
   */
  public getValueCoding(): Coding | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Coding)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected Coding but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a Coding and has a value; `false` otherwise
   */
  public hasValueCoding(): boolean {
    return this.hasValue() && this.value instanceof Coding;
  }

  /**
   * @returns the `value` property value as a ContactPoint object if defined; else null
   */
  public getValueContactPoint(): ContactPoint | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof ContactPoint)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected ContactPoint but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a ContactPoint and has a value; `false` otherwise
   */
  public hasValueContactPoint(): boolean {
    return this.hasValue() && this.value instanceof ContactPoint;
  }

  /**
   * @returns the `value` property value as a Count object if defined; else null
   */
  public getValueCount(): Count | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Count)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected Count but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a Count and has a value; `false` otherwise
   */
  public hasValueCount(): boolean {
    return this.hasValue() && this.value instanceof Count;
  }

  /**
   * @returns the `value` property value as a Distance object if defined; else null
   */
  public getValueDistance(): Distance | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Distance)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected Distance but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a Distance and has a value; `false` otherwise
   */
  public hasValueDistance(): boolean {
    return this.hasValue() && this.value instanceof Distance;
  }

  /**
   * @returns the `value` property value as a Duration object if defined; else null
   */
  public getValueDuration(): Duration | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Duration)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected Duration but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a Duration and has a value; `false` otherwise
   */
  public hasValueDuration(): boolean {
    return this.hasValue() && this.value instanceof Duration;
  }

  /**
   * @returns the `value` property value as a HumanName object if defined; else null
   */
  public getValueHumanName(): HumanName | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof HumanName)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected HumanName but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a HumanName and has a value; `false` otherwise
   */
  public hasValueHumanName(): boolean {
    return this.hasValue() && this.value instanceof HumanName;
  }

  /**
   * @returns the `value` property value as a Identifier object if defined; else null
   */
  public getValueIdentifier(): Identifier | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Identifier)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected Identifier but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a Identifier and has a value; `false` otherwise
   */
  public hasValueIdentifier(): boolean {
    return this.hasValue() && this.value instanceof Identifier;
  }

  /**
   * @returns the `value` property value as a Money object if defined; else null
   */
  public getValueMoney(): Money | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Money)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected Money but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a Money and has a value; `false` otherwise
   */
  public hasValueMoney(): boolean {
    return this.hasValue() && this.value instanceof Money;
  }

  /**
   * @returns the `value` property value as a Period object if defined; else null
   */
  public getValuePeriod(): Period | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Period)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected Period but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a Period and has a value; `false` otherwise
   */
  public hasValuePeriod(): boolean {
    return this.hasValue() && this.value instanceof Period;
  }

  /**
   * @returns the `value` property value as a Quantity object if defined; else null
   */
  public getValueQuantity(): Quantity | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Quantity)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected Quantity but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a Quantity and has a value; `false` otherwise
   */
  public hasValueQuantity(): boolean {
    return this.hasValue() && this.value instanceof Quantity;
  }

  /**
   * @returns the `value` property value as a Range object if defined; else null
   */
  public getValueRange(): Range | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Range)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected Range but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a Range and has a value; `false` otherwise
   */
  public hasValueRange(): boolean {
    return this.hasValue() && this.value instanceof Range;
  }

  /**
   * @returns the `value` property value as a Ratio object if defined; else null
   */
  public getValueRatio(): Ratio | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Ratio)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected Ratio but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a Ratio and has a value; `false` otherwise
   */
  public hasValueRatio(): boolean {
    return this.hasValue() && this.value instanceof Ratio;
  }

  /**
   * @returns the `value` property value as a RatioRange object if defined; else null
   */
  public getValueRatioRange(): RatioRange | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof RatioRange)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected RatioRange but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a RatioRange and has a value; `false` otherwise
   */
  public hasValueRatioRange(): boolean {
    return this.hasValue() && this.value instanceof RatioRange;
  }

  /**
   * @returns the `value` property value as a Reference object if defined; else null
   */
  public getValueReference(): Reference | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Reference)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected Reference but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a Reference and has a value; `false` otherwise
   */
  public hasValueReference(): boolean {
    return this.hasValue() && this.value instanceof Reference;
  }

  /**
   * @returns the `value` property value as a SampledData object if defined; else null
   */
  public getValueSampledData(): SampledData | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof SampledData)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected SampledData but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a SampledData and has a value; `false` otherwise
   */
  public hasValueSampledData(): boolean {
    return this.hasValue() && this.value instanceof SampledData;
  }

  /**
   * @returns the `value` property value as a Signature object if defined; else null
   */
  public getValueSignature(): Signature | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Signature)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected Signature but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a Signature and has a value; `false` otherwise
   */
  public hasValueSignature(): boolean {
    return this.hasValue() && this.value instanceof Signature;
  }

  /**
   * @returns the `value` property value as a Timing object if defined; else null
   */
  public getValueTiming(): Timing | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Timing)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected Timing but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a Timing and has a value; `false` otherwise
   */
  public hasValueTiming(): boolean {
    return this.hasValue() && this.value instanceof Timing;
  }

  /**
   * @returns the `value` property value as a ContactDetail object if defined; else null
   */
  public getValueContactDetail(): ContactDetail | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof ContactDetail)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected ContactDetail but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a ContactDetail and has a value; `false` otherwise
   */
  public hasValueContactDetail(): boolean {
    return this.hasValue() && this.value instanceof ContactDetail;
  }

  /**
   * @returns the `value` property value as a Contributor object if defined; else null
   */
  public getValueContributor(): Contributor | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Contributor)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected Contributor but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a Contributor and has a value; `false` otherwise
   */
  public hasValueContributor(): boolean {
    return this.hasValue() && this.value instanceof Contributor;
  }

  /**
   * @returns the `value` property value as a DataRequirement object if defined; else null
   */
  public getValueDataRequirement(): DataRequirement | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof DataRequirement)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected DataRequirement but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a DataRequirement and has a value; `false` otherwise
   */
  public hasValueDataRequirement(): boolean {
    return this.hasValue() && this.value instanceof DataRequirement;
  }

  /**
   * @returns the `value` property value as a Expression object if defined; else null
   */
  public getValueExpression(): Expression | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Expression)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected Expression but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a Expression and has a value; `false` otherwise
   */
  public hasValueExpression(): boolean {
    return this.hasValue() && this.value instanceof Expression;
  }

  /**
   * @returns the `value` property value as a ParameterDefinition object if defined; else null
   */
  public getValueParameterDefinition(): ParameterDefinition | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof ParameterDefinition)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected ParameterDefinition but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a ParameterDefinition and has a value; `false` otherwise
   */
  public hasValueParameterDefinition(): boolean {
    return this.hasValue() && this.value instanceof ParameterDefinition;
  }

  /**
   * @returns the `value` property value as a RelatedArtifact object if defined; else null
   */
  public getValueRelatedArtifact(): RelatedArtifact | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof RelatedArtifact)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected RelatedArtifact but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a RelatedArtifact and has a value; `false` otherwise
   */
  public hasValueRelatedArtifact(): boolean {
    return this.hasValue() && this.value instanceof RelatedArtifact;
  }

  /**
   * @returns the `value` property value as a TriggerDefinition object if defined; else null
   */
  public getValueTriggerDefinition(): TriggerDefinition | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof TriggerDefinition)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected TriggerDefinition but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a TriggerDefinition and has a value; `false` otherwise
   */
  public hasValueTriggerDefinition(): boolean {
    return this.hasValue() && this.value instanceof TriggerDefinition;
  }

  /**
   * @returns the `value` property value as a UsageContext object if defined; else null
   */
  public getValueUsageContext(): UsageContext | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof UsageContext)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected UsageContext but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a UsageContext and has a value; `false` otherwise
   */
  public hasValueUsageContext(): boolean {
    return this.hasValue() && this.value instanceof UsageContext;
  }

  /**
   * @returns the `value` property value as a Dosage object if defined; else null
   */
  public getValueDosage(): Dosage | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Dosage)) {
      throw new InvalidTypeError(
        `DataType mismatch for ElementDefinition.example.value[x]: Expected Dosage but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a Dosage and has a value; `false` otherwise
   */
  public hasValueDosage(): boolean {
    return this.hasValue() && this.value instanceof Dosage;
  }

  // End of choice datatype-specific "get"/"has" methods

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'ElementDefinition.example';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.label,
      this.value,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): ElementDefinitionExampleComponent {
    const dest = new ElementDefinitionExampleComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: ElementDefinitionExampleComponent): void {
    super.copyValues(dest);
    dest.label = this.label ? this.label.copy() : null;
    dest.value = this.value ? this.value.copy() as IDataType : null;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasLabelElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirString>(this.getLabelElement()!, 'label', jsonObj);
    } else {
      missingReqdProperties.push(`ElementDefinition.example.label`);
    }

    if (this.hasValue()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getValue()!, 'value', jsonObj);
    } else {
      missingReqdProperties.push(`ElementDefinition.example.value[x]`);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_DO_NOT_EXIST} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
/**
 * ElementDefinitionConstraintComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Condition that must evaluate to true
 * - **Definition:** Formal constraints such as co-occurrence and other constraints that can be computationally evaluated within the context of the instance.
 * - **Comment:** Constraints should be declared on the "context" element - the lowest element in the hierarchy that is common to all nodes referenced by the constraint.
 *
 * @category Data Models: ComplexType
 * @see [FHIR ElementDefinition](http://hl7.org/fhir/StructureDefinition/ElementDefinition)
 */
export class ElementDefinitionConstraintComponent extends DataType implements IDataType {
  constructor(key: IdType | fhirId | null = null, severity: EnumCodeType | CodeType | fhirCode | null = null, human: StringType | fhirString | null = null) {
    super();

    this.constraintSeverityEnum = new ConstraintSeverityEnum();

    this.key = null;
    if (isDefined<IdType | fhirId>(key)) {
      if (key instanceof PrimitiveType) {
        this.setKeyElement(key);
      } else {
        this.setKey(key);
      }
    }

    this.severity = constructorCodeValueAsEnumCodeType<ConstraintSeverityEnum>(
      severity,
      ConstraintSeverityEnum,
      this.constraintSeverityEnum,
      'ElementDefinition.constraint.severity',
    );

    this.human = null;
    if (isDefined<StringType | fhirString>(human)) {
      if (human instanceof PrimitiveType) {
        this.setHumanElement(human);
      } else {
        this.setHuman(human);
      }
    }
  }

  /**
   * Parse the provided `ElementDefinitionConstraintComponent` JSON to instantiate the ElementDefinitionConstraintComponent data model.
   *
   * @param sourceJson - JSON representing FHIR `ElementDefinitionConstraintComponent`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to ElementDefinitionConstraintComponent
   * @returns ElementDefinitionConstraintComponent data model or undefined for `ElementDefinitionConstraintComponent`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): ElementDefinitionConstraintComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'ElementDefinitionConstraintComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new ElementDefinitionConstraintComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'key';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: IdType | undefined = fhirParser.parseIdType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setKeyElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'requirements';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setRequirementsElement(datatype);
    }

    fieldName = 'severity';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setSeverityElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'human';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setHumanElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'expression';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setExpressionElement(datatype);
    }

    fieldName = 'xpath';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setXpathElement(datatype);
    }

    fieldName = 'source';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CanonicalType | undefined = fhirParser.parseCanonicalType(dtJson, dtSiblingJson);
      instance.setSourceElement(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_REQD_IN_JSON} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * ElementDefinition.constraint.key Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Target of \'condition\' reference above
   * - **Definition:** Allows identification of which elements have their cardinalities impacted by the constraint.  Will not be referenced for constraints that do not affect cardinality.
   * - **FHIR Type:** `id`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private key: IdType | null;

  /**
   * ElementDefinition.constraint.requirements Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Why this constraint is necessary or appropriate
   * - **Definition:** Description of why this constraint is necessary or appropriate.
   * - **Comment:** To be used if the reason for the constraint might not be intuitive to all implementers.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private requirements?: StringType | undefined;

  /**
   * FHIR CodeSystem: ConstraintSeverity
   *
   * @see {@link ConstraintSeverityEnum }
   */
  private readonly constraintSeverityEnum: ConstraintSeverityEnum;

  /**
   * ElementDefinition.constraint.severity Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** error | warning
   * - **Definition:** Identifies the impact constraint violation has on the conformance of the instance.
   * - **Comment:** This allows constraints to be asserted as "shall" (error) and "should" (warning).
   * - **FHIR Type:** `code`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link ConstraintSeverityEnum }
   */
  private severity: EnumCodeType | null;

  /**
   * ElementDefinition.constraint.human Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Human description of constraint
   * - **Definition:** Text that can be used to describe the constraint in messages identifying that the constraint has been violated.
   * - **Comment:** Should be expressed in business terms as much as possible.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private human: StringType | null;

  /**
   * ElementDefinition.constraint.expression Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** FHIRPath expression of constraint
   * - **Definition:** A [FHIRPath](https://hl7.org/fhir/fhirpath.html) expression of constraint that can be executed to see if this constraint is met.
   * - **Comment:** In the absense of an expression, the expression is likely not enforceable by validators, and might be missed by many systems.
   * - **Requirements:** Used by validation tooling tests of the validity of the resource.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private expression?: StringType | undefined;

  /**
   * ElementDefinition.constraint.xpath Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** XPath expression of constraint
   * - **Definition:** An XPath expression of constraint that can be executed to see if this constraint is met.
   * - **Comment:** Elements SHALL use "f" as the namespace prefix for the FHIR namespace, and "x" for the xhtml namespace, and SHALL NOT use any other prefixes.     Note: XPath is generally considered not useful because it does not apply to JSON and other formats and because of XSLT implementation issues, and may be removed in the future.
   * - **Requirements:** Used in Schematron tests of the validity of the resource.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private xpath?: StringType | undefined;

  /**
   * ElementDefinition.constraint.source Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Reference to original source of constraint
   * - **Definition:** A reference to the original source of the constraint, for traceability purposes.
   * - **Comment:** This is used when, e.g. rendering, where it is not useful to present inherited constraints when rendering the snapshot.
   * - **FHIR Type:** `canonical`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/StructureDefinition',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private source?: CanonicalType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `key` property value as a IdType object if defined; else null
   */
  public getKeyElement(): IdType | null {
    return this.key;
  }

  /**
   * Assigns the provided PrimitiveType value to the `key` property.
   *
   * @param element - the `key` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setKeyElement(element: IdType): this {
    assertIsDefined<IdType>(element, `ElementDefinition.constraint.key is required`);
    const optErrMsg = `Invalid ElementDefinition.constraint.key; Provided value is not an instance of IdType.`;
    assertFhirType<IdType>(element, IdType, optErrMsg);
    this.key = element;
    return this;
  }

  /**
   * @returns `true` if the `key` property exists and has a value; `false` otherwise
   */
  public hasKeyElement(): boolean {
    return isDefined<IdType>(this.key) && !this.key.isEmpty();
  }

  /**
   * @returns the `key` property value as a fhirId if defined; else null
   */
  public getKey(): fhirId | null {
    if (this.key?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.key.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the `key` property.
   *
   * @param value - the `key` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setKey(value: fhirId): this {
    assertIsDefined<fhirId>(value, `ElementDefinition.constraint.key is required`);
    const optErrMsg = `Invalid ElementDefinition.constraint.key (${String(value)})`;
    this.key = new IdType(parseFhirPrimitiveData(value, fhirIdSchema, optErrMsg));
    return this;
  }

  /**
   * @returns `true` if the `key` property exists and has a value; `false` otherwise
   */
  public hasKey(): boolean {
    return this.hasKeyElement();
  }

  /**
   * @returns the `requirements` property value as a StringType object if defined; else an empty StringType object
   */
  public getRequirementsElement(): StringType {
    return this.requirements ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `requirements` property.
   *
   * @param element - the `requirements` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setRequirementsElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.constraint.requirements; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.requirements = element;
    } else {
      this.requirements = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `requirements` property exists and has a value; `false` otherwise
   */
  public hasRequirementsElement(): boolean {
    return isDefined<StringType>(this.requirements) && !this.requirements.isEmpty();
  }

  /**
   * @returns the `requirements` property value as a fhirString if defined; else undefined
   */
  public getRequirements(): fhirString | undefined {
    return this.requirements?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `requirements` property.
   *
   * @param value - the `requirements` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setRequirements(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid ElementDefinition.constraint.requirements (${String(value)})`;
      this.requirements = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.requirements = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `requirements` property exists and has a value; `false` otherwise
   */
  public hasRequirements(): boolean {
    return this.hasRequirementsElement();
  }

  /**
   * @returns the `severity` property value as a EnumCodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link ConstraintSeverityEnum }
   */
  public getSeverityEnumType(): EnumCodeType | null {
    return this.severity;
  }

  /**
   * Assigns the provided EnumCodeType value to the `severity` property.
   *
   * @param enumType - the `severity` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ConstraintSeverityEnum }
   */
  public setSeverityEnumType(enumType: EnumCodeType): this {
    assertIsDefined<EnumCodeType>(enumType, `ElementDefinition.constraint.severity is required`);
    const errMsgPrefix = `Invalid ElementDefinition.constraint.severity`;
    assertEnumCodeType<ConstraintSeverityEnum>(enumType, ConstraintSeverityEnum, errMsgPrefix);
    this.severity = enumType;
    return this;
  }

  /**
   * @returns `true` if the `severity` property exists and has a value; `false` otherwise
   */
  public hasSeverityEnumType(): boolean {
    return isDefined<EnumCodeType>(this.severity) && !this.severity.isEmpty() && this.severity.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the `severity` property value as a CodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link ConstraintSeverityEnum }
   */
  public getSeverityElement(): CodeType | null {
    if (this.severity === null) {
      return null;
    }
    return this.severity as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the `severity` property.
   *
   * @param element - the `severity` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link ConstraintSeverityEnum }
   */
  public setSeverityElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, `ElementDefinition.constraint.severity is required`);
    const optErrMsg = `Invalid ElementDefinition.constraint.severity; Provided value is not an instance of CodeType.`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.severity = new EnumCodeType(element, this.constraintSeverityEnum);
    return this;
  }

  /**
   * @returns `true` if the `severity` property exists and has a value; `false` otherwise
   */
  public hasSeverityElement(): boolean {
    return this.hasSeverityEnumType();
  }

  /**
   * @returns the `severity` property value as a fhirCode if defined; else null
   *
   * @see CodeSystem Enumeration: {@link ConstraintSeverityEnum }
   */
  public getSeverity(): fhirCode | null {
    if (this.severity === null) {
      return null;
    }
    return this.severity.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the `severity` property.
   *
   * @param value - the `severity` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link ConstraintSeverityEnum }
   */
  public setSeverity(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, `ElementDefinition.constraint.severity is required`);
    const optErrMsg = `Invalid ElementDefinition.constraint.severity (${String(value)})`;
    this.severity = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.constraintSeverityEnum);
    return this;
  }

  /**
   * @returns `true` if the `severity` property exists and has a value; `false` otherwise
   */
  public hasSeverity(): boolean {
    return this.hasSeverityEnumType();
  }

  /**
   * @returns the `human` property value as a StringType object if defined; else null
   */
  public getHumanElement(): StringType | null {
    return this.human;
  }

  /**
   * Assigns the provided PrimitiveType value to the `human` property.
   *
   * @param element - the `human` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setHumanElement(element: StringType): this {
    assertIsDefined<StringType>(element, `ElementDefinition.constraint.human is required`);
    const optErrMsg = `Invalid ElementDefinition.constraint.human; Provided value is not an instance of StringType.`;
    assertFhirType<StringType>(element, StringType, optErrMsg);
    this.human = element;
    return this;
  }

  /**
   * @returns `true` if the `human` property exists and has a value; `false` otherwise
   */
  public hasHumanElement(): boolean {
    return isDefined<StringType>(this.human) && !this.human.isEmpty();
  }

  /**
   * @returns the `human` property value as a fhirString if defined; else null
   */
  public getHuman(): fhirString | null {
    if (this.human?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.human.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the `human` property.
   *
   * @param value - the `human` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setHuman(value: fhirString): this {
    assertIsDefined<fhirString>(value, `ElementDefinition.constraint.human is required`);
    const optErrMsg = `Invalid ElementDefinition.constraint.human (${String(value)})`;
    this.human = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    return this;
  }

  /**
   * @returns `true` if the `human` property exists and has a value; `false` otherwise
   */
  public hasHuman(): boolean {
    return this.hasHumanElement();
  }

  /**
   * @returns the `expression` property value as a StringType object if defined; else an empty StringType object
   */
  public getExpressionElement(): StringType {
    return this.expression ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `expression` property.
   *
   * @param element - the `expression` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setExpressionElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.constraint.expression; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.expression = element;
    } else {
      this.expression = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `expression` property exists and has a value; `false` otherwise
   */
  public hasExpressionElement(): boolean {
    return isDefined<StringType>(this.expression) && !this.expression.isEmpty();
  }

  /**
   * @returns the `expression` property value as a fhirString if defined; else undefined
   */
  public getExpression(): fhirString | undefined {
    return this.expression?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `expression` property.
   *
   * @param value - the `expression` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setExpression(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid ElementDefinition.constraint.expression (${String(value)})`;
      this.expression = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.expression = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `expression` property exists and has a value; `false` otherwise
   */
  public hasExpression(): boolean {
    return this.hasExpressionElement();
  }

  /**
   * @returns the `xpath` property value as a StringType object if defined; else an empty StringType object
   */
  public getXpathElement(): StringType {
    return this.xpath ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `xpath` property.
   *
   * @param element - the `xpath` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setXpathElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.constraint.xpath; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.xpath = element;
    } else {
      this.xpath = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `xpath` property exists and has a value; `false` otherwise
   */
  public hasXpathElement(): boolean {
    return isDefined<StringType>(this.xpath) && !this.xpath.isEmpty();
  }

  /**
   * @returns the `xpath` property value as a fhirString if defined; else undefined
   */
  public getXpath(): fhirString | undefined {
    return this.xpath?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `xpath` property.
   *
   * @param value - the `xpath` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setXpath(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid ElementDefinition.constraint.xpath (${String(value)})`;
      this.xpath = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.xpath = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `xpath` property exists and has a value; `false` otherwise
   */
  public hasXpath(): boolean {
    return this.hasXpathElement();
  }

  /**
   * @returns the `source` property value as a CanonicalType object if defined; else an empty CanonicalType object
   */
  public getSourceElement(): CanonicalType {
    return this.source ?? new CanonicalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `source` property.
   *
   * @param element - the `source` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSourceElement(element: CanonicalType | undefined): this {
    if (isDefined<CanonicalType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.constraint.source; Provided element is not an instance of CanonicalType.`;
      assertFhirType<CanonicalType>(element, CanonicalType, optErrMsg);
      this.source = element;
    } else {
      this.source = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `source` property exists and has a value; `false` otherwise
   */
  public hasSourceElement(): boolean {
    return isDefined<CanonicalType>(this.source) && !this.source.isEmpty();
  }

  /**
   * @returns the `source` property value as a fhirCanonical if defined; else undefined
   */
  public getSource(): fhirCanonical | undefined {
    return this.source?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `source` property.
   *
   * @param value - the `source` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSource(value: fhirCanonical | undefined): this {
    if (isDefined<fhirCanonical>(value)) {
      const optErrMsg = `Invalid ElementDefinition.constraint.source (${String(value)})`;
      this.source = new CanonicalType(parseFhirPrimitiveData(value, fhirCanonicalSchema, optErrMsg));
    } else {
      this.source = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `source` property exists and has a value; `false` otherwise
   */
  public hasSource(): boolean {
    return this.hasSourceElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'ElementDefinition.constraint';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.key,
      this.requirements,
      this.severity,
      this.human,
      this.expression,
      this.xpath,
      this.source,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): ElementDefinitionConstraintComponent {
    const dest = new ElementDefinitionConstraintComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: ElementDefinitionConstraintComponent): void {
    super.copyValues(dest);
    dest.key = this.key ? this.key.copy() : null;
    dest.requirements = this.requirements?.copy();
    dest.severity = this.severity ? this.severity.copy() : null;
    dest.human = this.human ? this.human.copy() : null;
    dest.expression = this.expression?.copy();
    dest.xpath = this.xpath?.copy();
    dest.source = this.source?.copy();
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasKeyElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirId>(this.getKeyElement()!, 'key', jsonObj);
    } else {
      missingReqdProperties.push(`ElementDefinition.constraint.key`);
    }

    if (this.hasRequirementsElement()) {
      setFhirPrimitiveJson<fhirString>(this.getRequirementsElement(), 'requirements', jsonObj);
    }

    if (this.hasSeverityElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getSeverityElement()!, 'severity', jsonObj);
    } else {
      missingReqdProperties.push(`ElementDefinition.constraint.severity`);
    }

    if (this.hasHumanElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirString>(this.getHumanElement()!, 'human', jsonObj);
    } else {
      missingReqdProperties.push(`ElementDefinition.constraint.human`);
    }

    if (this.hasExpressionElement()) {
      setFhirPrimitiveJson<fhirString>(this.getExpressionElement(), 'expression', jsonObj);
    }

    if (this.hasXpathElement()) {
      setFhirPrimitiveJson<fhirString>(this.getXpathElement(), 'xpath', jsonObj);
    }

    if (this.hasSourceElement()) {
      setFhirPrimitiveJson<fhirCanonical>(this.getSourceElement(), 'source', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_DO_NOT_EXIST} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
/**
 * ElementDefinitionBindingComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** ValueSet details if this is coded
 * - **Definition:** Binds to a value set if this element is coded (code, Coding, CodeableConcept, Quantity), or the data types (string, uri).
 * - **Comment:** For a CodeableConcept, when no codes are allowed - only text, use a binding of strength "required" with a description explaining that no coded values are allowed and what sort of information to put in the "text" element.
 *
 * @category Data Models: ComplexType
 * @see [FHIR ElementDefinition](http://hl7.org/fhir/StructureDefinition/ElementDefinition)
 */
export class ElementDefinitionBindingComponent extends DataType implements IDataType {
  constructor(strength: EnumCodeType | CodeType | fhirCode | null = null) {
    super();

    this.bindingStrengthEnum = new BindingStrengthEnum();

    this.strength = constructorCodeValueAsEnumCodeType<BindingStrengthEnum>(
      strength,
      BindingStrengthEnum,
      this.bindingStrengthEnum,
      'ElementDefinition.binding.strength',
    );
  }

  /**
   * Parse the provided `ElementDefinitionBindingComponent` JSON to instantiate the ElementDefinitionBindingComponent data model.
   *
   * @param sourceJson - JSON representing FHIR `ElementDefinitionBindingComponent`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to ElementDefinitionBindingComponent
   * @returns ElementDefinitionBindingComponent data model or undefined for `ElementDefinitionBindingComponent`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): ElementDefinitionBindingComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'ElementDefinitionBindingComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new ElementDefinitionBindingComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'strength';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setStrengthElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'description';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setDescriptionElement(datatype);
    }

    fieldName = 'valueSet';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CanonicalType | undefined = fhirParser.parseCanonicalType(dtJson, dtSiblingJson);
      instance.setValueSetElement(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_REQD_IN_JSON} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: BindingStrength
   *
   * @see {@link BindingStrengthEnum }
   */
  private readonly bindingStrengthEnum: BindingStrengthEnum;

  /**
   * ElementDefinition.binding.strength Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** required | extensible | preferred | example
   * - **Definition:** Indicates the degree of conformance expectations associated with this binding - that is, the degree to which the provided value set must be adhered to in the instances.
   * - **Comment:** For further discussion, see [Using Terminologies](https://hl7.org/fhir/terminologies.html).
   * - **FHIR Type:** `code`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link BindingStrengthEnum }
   */
  private strength: EnumCodeType | null;

  /**
   * ElementDefinition.binding.description Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Human explanation of the value set
   * - **Definition:** Describes the intended use of this particular set of codes.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private description?: StringType | undefined;

  /**
   * ElementDefinition.binding.valueSet Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Source of value set
   * - **Definition:** Refers to the value set that identifies the set of codes the binding refers to.
   * - **Comment:** The reference may be version-specific or not (e.g. have a |[version] at the end of the canonical URL).
   * - **FHIR Type:** `canonical`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/ValueSet',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private valueSet?: CanonicalType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `strength` property value as a EnumCodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link BindingStrengthEnum }
   */
  public getStrengthEnumType(): EnumCodeType | null {
    return this.strength;
  }

  /**
   * Assigns the provided EnumCodeType value to the `strength` property.
   *
   * @param enumType - the `strength` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link BindingStrengthEnum }
   */
  public setStrengthEnumType(enumType: EnumCodeType): this {
    assertIsDefined<EnumCodeType>(enumType, `ElementDefinition.binding.strength is required`);
    const errMsgPrefix = `Invalid ElementDefinition.binding.strength`;
    assertEnumCodeType<BindingStrengthEnum>(enumType, BindingStrengthEnum, errMsgPrefix);
    this.strength = enumType;
    return this;
  }

  /**
   * @returns `true` if the `strength` property exists and has a value; `false` otherwise
   */
  public hasStrengthEnumType(): boolean {
    return isDefined<EnumCodeType>(this.strength) && !this.strength.isEmpty() && this.strength.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the `strength` property value as a CodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link BindingStrengthEnum }
   */
  public getStrengthElement(): CodeType | null {
    if (this.strength === null) {
      return null;
    }
    return this.strength as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the `strength` property.
   *
   * @param element - the `strength` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link BindingStrengthEnum }
   */
  public setStrengthElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, `ElementDefinition.binding.strength is required`);
    const optErrMsg = `Invalid ElementDefinition.binding.strength; Provided value is not an instance of CodeType.`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.strength = new EnumCodeType(element, this.bindingStrengthEnum);
    return this;
  }

  /**
   * @returns `true` if the `strength` property exists and has a value; `false` otherwise
   */
  public hasStrengthElement(): boolean {
    return this.hasStrengthEnumType();
  }

  /**
   * @returns the `strength` property value as a fhirCode if defined; else null
   *
   * @see CodeSystem Enumeration: {@link BindingStrengthEnum }
   */
  public getStrength(): fhirCode | null {
    if (this.strength === null) {
      return null;
    }
    return this.strength.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the `strength` property.
   *
   * @param value - the `strength` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link BindingStrengthEnum }
   */
  public setStrength(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, `ElementDefinition.binding.strength is required`);
    const optErrMsg = `Invalid ElementDefinition.binding.strength (${String(value)})`;
    this.strength = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.bindingStrengthEnum);
    return this;
  }

  /**
   * @returns `true` if the `strength` property exists and has a value; `false` otherwise
   */
  public hasStrength(): boolean {
    return this.hasStrengthEnumType();
  }

  /**
   * @returns the `description` property value as a StringType object if defined; else an empty StringType object
   */
  public getDescriptionElement(): StringType {
    return this.description ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `description` property.
   *
   * @param element - the `description` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDescriptionElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.binding.description; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.description = element;
    } else {
      this.description = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `description` property exists and has a value; `false` otherwise
   */
  public hasDescriptionElement(): boolean {
    return isDefined<StringType>(this.description) && !this.description.isEmpty();
  }

  /**
   * @returns the `description` property value as a fhirString if defined; else undefined
   */
  public getDescription(): fhirString | undefined {
    return this.description?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `description` property.
   *
   * @param value - the `description` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDescription(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid ElementDefinition.binding.description (${String(value)})`;
      this.description = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.description = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `description` property exists and has a value; `false` otherwise
   */
  public hasDescription(): boolean {
    return this.hasDescriptionElement();
  }

  /**
   * @returns the `valueSet` property value as a CanonicalType object if defined; else an empty CanonicalType object
   */
  public getValueSetElement(): CanonicalType {
    return this.valueSet ?? new CanonicalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `valueSet` property.
   *
   * @param element - the `valueSet` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValueSetElement(element: CanonicalType | undefined): this {
    if (isDefined<CanonicalType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.binding.valueSet; Provided element is not an instance of CanonicalType.`;
      assertFhirType<CanonicalType>(element, CanonicalType, optErrMsg);
      this.valueSet = element;
    } else {
      this.valueSet = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `valueSet` property exists and has a value; `false` otherwise
   */
  public hasValueSetElement(): boolean {
    return isDefined<CanonicalType>(this.valueSet) && !this.valueSet.isEmpty();
  }

  /**
   * @returns the `valueSet` property value as a fhirCanonical if defined; else undefined
   */
  public getValueSet(): fhirCanonical | undefined {
    return this.valueSet?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `valueSet` property.
   *
   * @param value - the `valueSet` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValueSet(value: fhirCanonical | undefined): this {
    if (isDefined<fhirCanonical>(value)) {
      const optErrMsg = `Invalid ElementDefinition.binding.valueSet (${String(value)})`;
      this.valueSet = new CanonicalType(parseFhirPrimitiveData(value, fhirCanonicalSchema, optErrMsg));
    } else {
      this.valueSet = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `valueSet` property exists and has a value; `false` otherwise
   */
  public hasValueSet(): boolean {
    return this.hasValueSetElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'ElementDefinition.binding';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.strength,
      this.description,
      this.valueSet,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): ElementDefinitionBindingComponent {
    const dest = new ElementDefinitionBindingComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: ElementDefinitionBindingComponent): void {
    super.copyValues(dest);
    dest.strength = this.strength ? this.strength.copy() : null;
    dest.description = this.description?.copy();
    dest.valueSet = this.valueSet?.copy();
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasStrengthElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getStrengthElement()!, 'strength', jsonObj);
    } else {
      missingReqdProperties.push(`ElementDefinition.binding.strength`);
    }

    if (this.hasDescriptionElement()) {
      setFhirPrimitiveJson<fhirString>(this.getDescriptionElement(), 'description', jsonObj);
    }

    if (this.hasValueSetElement()) {
      setFhirPrimitiveJson<fhirCanonical>(this.getValueSetElement(), 'valueSet', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_DO_NOT_EXIST} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}
/**
 * ElementDefinitionMappingComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** Map element to another set of definitions
 * - **Definition:** Identifies a concept from an external specification that roughly corresponds to this element.
 * - **Comment:** Mappings are not necessarily specific enough for safe translation.
 * - **Requirements:** Provides guidance to implementers familiar with or converting content from other specifications.
 *
 * @category Data Models: ComplexType
 * @see [FHIR ElementDefinition](http://hl7.org/fhir/StructureDefinition/ElementDefinition)
 */
export class ElementDefinitionMappingComponent extends DataType implements IDataType {
  constructor(identity: IdType | fhirId | null = null, map: StringType | fhirString | null = null) {
    super();

    this.identity = null;
    if (isDefined<IdType | fhirId>(identity)) {
      if (identity instanceof PrimitiveType) {
        this.setIdentityElement(identity);
      } else {
        this.setIdentity(identity);
      }
    }

    this.map = null;
    if (isDefined<StringType | fhirString>(map)) {
      if (map instanceof PrimitiveType) {
        this.setMapElement(map);
      } else {
        this.setMap(map);
      }
    }
  }

  /**
   * Parse the provided `ElementDefinitionMappingComponent` JSON to instantiate the ElementDefinitionMappingComponent data model.
   *
   * @param sourceJson - JSON representing FHIR `ElementDefinitionMappingComponent`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to ElementDefinitionMappingComponent
   * @returns ElementDefinitionMappingComponent data model or undefined for `ElementDefinitionMappingComponent`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): ElementDefinitionMappingComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'ElementDefinitionMappingComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new ElementDefinitionMappingComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'identity';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: IdType | undefined = fhirParser.parseIdType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setIdentityElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'language';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setLanguageElement(datatype);
    }

    fieldName = 'map';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setMapElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'comment';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setCommentElement(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_REQD_IN_JSON} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * ElementDefinition.mapping.identity Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Reference to mapping declaration
   * - **Definition:** An internal reference to the definition of a mapping.
   * - **FHIR Type:** `id`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private identity: IdType | null;

  /**
   * ElementDefinition.mapping.language Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Computable language of mapping
   * - **Definition:** Identifies the computable language in which mapping.map is expressed.
   * - **Comment:** If omitted, then there can be no expectation of computational interpretation of the mapping.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private language?: CodeType | undefined;

  /**
   * ElementDefinition.mapping.map Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Details of the mapping
   * - **Definition:** Expresses what part of the target specification corresponds to this element.
   * - **Comment:** For most mappings, the syntax is undefined.  Syntax will be provided for mappings to the RIM.  Multiple mappings may be possible and may include constraints on other resource elements that identify when a particular mapping applies.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private map: StringType | null;

  /**
   * ElementDefinition.mapping.comment Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Comments about the mapping or its use
   * - **Definition:** Comments that provide information about the mapping or its use.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private comment?: StringType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `identity` property value as a IdType object if defined; else null
   */
  public getIdentityElement(): IdType | null {
    return this.identity;
  }

  /**
   * Assigns the provided PrimitiveType value to the `identity` property.
   *
   * @param element - the `identity` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setIdentityElement(element: IdType): this {
    assertIsDefined<IdType>(element, `ElementDefinition.mapping.identity is required`);
    const optErrMsg = `Invalid ElementDefinition.mapping.identity; Provided value is not an instance of IdType.`;
    assertFhirType<IdType>(element, IdType, optErrMsg);
    this.identity = element;
    return this;
  }

  /**
   * @returns `true` if the `identity` property exists and has a value; `false` otherwise
   */
  public hasIdentityElement(): boolean {
    return isDefined<IdType>(this.identity) && !this.identity.isEmpty();
  }

  /**
   * @returns the `identity` property value as a fhirId if defined; else null
   */
  public getIdentity(): fhirId | null {
    if (this.identity?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.identity.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the `identity` property.
   *
   * @param value - the `identity` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setIdentity(value: fhirId): this {
    assertIsDefined<fhirId>(value, `ElementDefinition.mapping.identity is required`);
    const optErrMsg = `Invalid ElementDefinition.mapping.identity (${String(value)})`;
    this.identity = new IdType(parseFhirPrimitiveData(value, fhirIdSchema, optErrMsg));
    return this;
  }

  /**
   * @returns `true` if the `identity` property exists and has a value; `false` otherwise
   */
  public hasIdentity(): boolean {
    return this.hasIdentityElement();
  }

  /**
   * @returns the `language` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getLanguageElement(): CodeType {
    return this.language ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `language` property.
   *
   * @param element - the `language` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLanguageElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.mapping.language; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.language = element;
    } else {
      this.language = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `language` property exists and has a value; `false` otherwise
   */
  public hasLanguageElement(): boolean {
    return isDefined<CodeType>(this.language) && !this.language.isEmpty();
  }

  /**
   * @returns the `language` property value as a fhirCode if defined; else undefined
   */
  public getLanguage(): fhirCode | undefined {
    return this.language?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `language` property.
   *
   * @param value - the `language` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLanguage(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid ElementDefinition.mapping.language (${String(value)})`;
      this.language = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.language = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `language` property exists and has a value; `false` otherwise
   */
  public hasLanguage(): boolean {
    return this.hasLanguageElement();
  }

  /**
   * @returns the `map` property value as a StringType object if defined; else null
   */
  public getMapElement(): StringType | null {
    return this.map;
  }

  /**
   * Assigns the provided PrimitiveType value to the `map` property.
   *
   * @param element - the `map` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMapElement(element: StringType): this {
    assertIsDefined<StringType>(element, `ElementDefinition.mapping.map is required`);
    const optErrMsg = `Invalid ElementDefinition.mapping.map; Provided value is not an instance of StringType.`;
    assertFhirType<StringType>(element, StringType, optErrMsg);
    this.map = element;
    return this;
  }

  /**
   * @returns `true` if the `map` property exists and has a value; `false` otherwise
   */
  public hasMapElement(): boolean {
    return isDefined<StringType>(this.map) && !this.map.isEmpty();
  }

  /**
   * @returns the `map` property value as a fhirString if defined; else null
   */
  public getMap(): fhirString | null {
    if (this.map?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.map.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the `map` property.
   *
   * @param value - the `map` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMap(value: fhirString): this {
    assertIsDefined<fhirString>(value, `ElementDefinition.mapping.map is required`);
    const optErrMsg = `Invalid ElementDefinition.mapping.map (${String(value)})`;
    this.map = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    return this;
  }

  /**
   * @returns `true` if the `map` property exists and has a value; `false` otherwise
   */
  public hasMap(): boolean {
    return this.hasMapElement();
  }

  /**
   * @returns the `comment` property value as a StringType object if defined; else an empty StringType object
   */
  public getCommentElement(): StringType {
    return this.comment ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `comment` property.
   *
   * @param element - the `comment` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCommentElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid ElementDefinition.mapping.comment; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.comment = element;
    } else {
      this.comment = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `comment` property exists and has a value; `false` otherwise
   */
  public hasCommentElement(): boolean {
    return isDefined<StringType>(this.comment) && !this.comment.isEmpty();
  }

  /**
   * @returns the `comment` property value as a fhirString if defined; else undefined
   */
  public getComment(): fhirString | undefined {
    return this.comment?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `comment` property.
   *
   * @param value - the `comment` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setComment(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid ElementDefinition.mapping.comment (${String(value)})`;
      this.comment = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.comment = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `comment` property exists and has a value; `false` otherwise
   */
  public hasComment(): boolean {
    return this.hasCommentElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'ElementDefinition.mapping';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.identity,
      this.language,
      this.map,
      this.comment,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): ElementDefinitionMappingComponent {
    const dest = new ElementDefinitionMappingComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: ElementDefinitionMappingComponent): void {
    super.copyValues(dest);
    dest.identity = this.identity ? this.identity.copy() : null;
    dest.language = this.language?.copy();
    dest.map = this.map ? this.map.copy() : null;
    dest.comment = this.comment?.copy();
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasIdentityElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirId>(this.getIdentityElement()!, 'identity', jsonObj);
    } else {
      missingReqdProperties.push(`ElementDefinition.mapping.identity`);
    }

    if (this.hasLanguageElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getLanguageElement(), 'language', jsonObj);
    }

    if (this.hasMapElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirString>(this.getMapElement()!, 'map', jsonObj);
    } else {
      missingReqdProperties.push(`ElementDefinition.mapping.map`);
    }

    if (this.hasCommentElement()) {
      setFhirPrimitiveJson<fhirString>(this.getCommentElement(), 'comment', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_DO_NOT_EXIST} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

/**
 * Expression Class
 *
 * @remarks
 * Base StructureDefinition for Expression Type: A expression that is evaluated in a specified context and returns a value. The context of use of the expression must specify the context in which the expression is evaluated, and how the result of the expression is used.
 *
 * **FHIR Specification**
 * - **Short:** An expression that can be used to generate a value
 * - **Definition:** A expression that is evaluated in a specified context and returns a value. The context of use of the expression must specify the context in which the expression is evaluated, and how the result of the expression is used.
 * - **FHIR Version:** 4.3.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR Expression](http://hl7.org/fhir/StructureDefinition/Expression)
 */
export class Expression extends DataType implements IDataType {
  constructor(language: CodeType | fhirCode | null = null) {
    super();

    this.language = null;
    if (isDefined<CodeType | fhirCode>(language)) {
      if (language instanceof PrimitiveType) {
        this.setLanguageElement(language);
      } else {
        this.setLanguage(language);
      }
    }
  }

  /**
   * Parse the provided `Expression` JSON to instantiate the Expression data model.
   *
   * @param sourceJson - JSON representing FHIR `Expression`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to Expression
   * @returns Expression data model or undefined for `Expression`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Expression | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Expression';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new Expression();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'description';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setDescriptionElement(datatype);
    }

    fieldName = 'name';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: IdType | undefined = fhirParser.parseIdType(dtJson, dtSiblingJson);
      instance.setNameElement(datatype);
    }

    fieldName = 'language';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setLanguageElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'expression';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setExpressionElement(datatype);
    }

    fieldName = 'reference';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = fhirParser.parseUriType(dtJson, dtSiblingJson);
      instance.setReferenceElement(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_REQD_IN_JSON} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Expression.description Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Natural language description of the condition
   * - **Definition:** A brief, natural language description of the condition that effectively communicates the intended semantics.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private description?: StringType | undefined;

  /**
   * Expression.name Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Short name assigned to expression for reuse
   * - **Definition:** A short name assigned to the expression to allow for multiple reuse of the expression in the context where it is defined.
   * - **FHIR Type:** `id`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private name?: IdType | undefined;

  /**
   * Expression.language Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** text/cql | text/fhirpath | application/x-fhir-query | text/cql-identifier | text/cql-expression | etc.
   * - **Definition:** The media type of the language for the expression.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private language: CodeType | null;

  /**
   * Expression.expression Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Expression in specified language
   * - **Definition:** An expression in the specified language that returns a value.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private expression?: StringType | undefined;

  /**
   * Expression.reference Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Where the expression is found
   * - **Definition:** A URI that defines where the expression is found.
   * - **Comment:** If both a reference and an expression is found, the reference SHALL point to the same expression.
   * - **FHIR Type:** `uri`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private reference?: UriType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `description` property value as a StringType object if defined; else an empty StringType object
   */
  public getDescriptionElement(): StringType {
    return this.description ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `description` property.
   *
   * @param element - the `description` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDescriptionElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid Expression.description; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.description = element;
    } else {
      this.description = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `description` property exists and has a value; `false` otherwise
   */
  public hasDescriptionElement(): boolean {
    return isDefined<StringType>(this.description) && !this.description.isEmpty();
  }

  /**
   * @returns the `description` property value as a fhirString if defined; else undefined
   */
  public getDescription(): fhirString | undefined {
    return this.description?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `description` property.
   *
   * @param value - the `description` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDescription(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid Expression.description (${String(value)})`;
      this.description = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.description = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `description` property exists and has a value; `false` otherwise
   */
  public hasDescription(): boolean {
    return this.hasDescriptionElement();
  }

  /**
   * @returns the `name` property value as a IdType object if defined; else an empty IdType object
   */
  public getNameElement(): IdType {
    return this.name ?? new IdType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `name` property.
   *
   * @param element - the `name` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setNameElement(element: IdType | undefined): this {
    if (isDefined<IdType>(element)) {
      const optErrMsg = `Invalid Expression.name; Provided element is not an instance of IdType.`;
      assertFhirType<IdType>(element, IdType, optErrMsg);
      this.name = element;
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `name` property exists and has a value; `false` otherwise
   */
  public hasNameElement(): boolean {
    return isDefined<IdType>(this.name) && !this.name.isEmpty();
  }

  /**
   * @returns the `name` property value as a fhirId if defined; else undefined
   */
  public getName(): fhirId | undefined {
    return this.name?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `name` property.
   *
   * @param value - the `name` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setName(value: fhirId | undefined): this {
    if (isDefined<fhirId>(value)) {
      const optErrMsg = `Invalid Expression.name (${String(value)})`;
      this.name = new IdType(parseFhirPrimitiveData(value, fhirIdSchema, optErrMsg));
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `name` property exists and has a value; `false` otherwise
   */
  public hasName(): boolean {
    return this.hasNameElement();
  }

  /**
   * @returns the `language` property value as a CodeType object if defined; else null
   */
  public getLanguageElement(): CodeType | null {
    return this.language;
  }

  /**
   * Assigns the provided PrimitiveType value to the `language` property.
   *
   * @param element - the `language` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLanguageElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, `Expression.language is required`);
    const optErrMsg = `Invalid Expression.language; Provided value is not an instance of CodeType.`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.language = element;
    return this;
  }

  /**
   * @returns `true` if the `language` property exists and has a value; `false` otherwise
   */
  public hasLanguageElement(): boolean {
    return isDefined<CodeType>(this.language) && !this.language.isEmpty();
  }

  /**
   * @returns the `language` property value as a fhirCode if defined; else null
   */
  public getLanguage(): fhirCode | null {
    if (this.language?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.language.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the `language` property.
   *
   * @param value - the `language` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLanguage(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, `Expression.language is required`);
    const optErrMsg = `Invalid Expression.language (${String(value)})`;
    this.language = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    return this;
  }

  /**
   * @returns `true` if the `language` property exists and has a value; `false` otherwise
   */
  public hasLanguage(): boolean {
    return this.hasLanguageElement();
  }

  /**
   * @returns the `expression` property value as a StringType object if defined; else an empty StringType object
   */
  public getExpressionElement(): StringType {
    return this.expression ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `expression` property.
   *
   * @param element - the `expression` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setExpressionElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid Expression.expression; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.expression = element;
    } else {
      this.expression = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `expression` property exists and has a value; `false` otherwise
   */
  public hasExpressionElement(): boolean {
    return isDefined<StringType>(this.expression) && !this.expression.isEmpty();
  }

  /**
   * @returns the `expression` property value as a fhirString if defined; else undefined
   */
  public getExpression(): fhirString | undefined {
    return this.expression?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `expression` property.
   *
   * @param value - the `expression` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setExpression(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid Expression.expression (${String(value)})`;
      this.expression = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.expression = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `expression` property exists and has a value; `false` otherwise
   */
  public hasExpression(): boolean {
    return this.hasExpressionElement();
  }

  /**
   * @returns the `reference` property value as a UriType object if defined; else an empty UriType object
   */
  public getReferenceElement(): UriType {
    return this.reference ?? new UriType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `reference` property.
   *
   * @param element - the `reference` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setReferenceElement(element: UriType | undefined): this {
    if (isDefined<UriType>(element)) {
      const optErrMsg = `Invalid Expression.reference; Provided element is not an instance of UriType.`;
      assertFhirType<UriType>(element, UriType, optErrMsg);
      this.reference = element;
    } else {
      this.reference = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `reference` property exists and has a value; `false` otherwise
   */
  public hasReferenceElement(): boolean {
    return isDefined<UriType>(this.reference) && !this.reference.isEmpty();
  }

  /**
   * @returns the `reference` property value as a fhirUri if defined; else undefined
   */
  public getReference(): fhirUri | undefined {
    return this.reference?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `reference` property.
   *
   * @param value - the `reference` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setReference(value: fhirUri | undefined): this {
    if (isDefined<fhirUri>(value)) {
      const optErrMsg = `Invalid Expression.reference (${String(value)})`;
      this.reference = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    } else {
      this.reference = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `reference` property exists and has a value; `false` otherwise
   */
  public hasReference(): boolean {
    return this.hasReferenceElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Expression';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.description,
      this.name,
      this.language,
      this.expression,
      this.reference,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Expression {
    const dest = new Expression();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Expression): void {
    super.copyValues(dest);
    dest.description = this.description?.copy();
    dest.name = this.name?.copy();
    dest.language = this.language ? this.language.copy() : null;
    dest.expression = this.expression?.copy();
    dest.reference = this.reference?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasDescriptionElement()) {
      setFhirPrimitiveJson<fhirString>(this.getDescriptionElement(), 'description', jsonObj);
    }

    if (this.hasNameElement()) {
      setFhirPrimitiveJson<fhirId>(this.getNameElement(), 'name', jsonObj);
    }

    if (this.hasLanguageElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getLanguageElement()!, 'language', jsonObj);
    } else {
      missingReqdProperties.push(`Expression.language`);
    }

    if (this.hasExpressionElement()) {
      setFhirPrimitiveJson<fhirString>(this.getExpressionElement(), 'expression', jsonObj);
    }

    if (this.hasReferenceElement()) {
      setFhirPrimitiveJson<fhirUri>(this.getReferenceElement(), 'reference', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_DO_NOT_EXIST} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

/**
 * Extension Class
 *
 * @remarks
 * Base StructureDefinition for Extension Type: Optional Extension Element - found in all resources.
 *
 * The ability to add extensions in a structured way is what keeps FHIR resources simple.
 *
 * **FHIR Specification**
 * - **Short:** Optional Extensions Element
 * - **Definition:** Optional Extension Element - found in all resources.
 * - **FHIR Version:** 4.3.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR Extension](http://hl7.org/fhir/StructureDefinition/Extension)
 */
export class Extension extends CoreExtension {
  constructor(url: fhirUri | null = null, value?: IDataType) {
    super(url, value);
  }

  // *** NOTE ***
  // Following "get"/"has" methods are added for each open data type - one pair of methods for each open data type

  /**
   * @returns the `value` property value as a Base64BinaryType object if defined; else undefined
   */
  public getValueBase64BinaryType(): Base64BinaryType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Base64BinaryType)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected Base64BinaryType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a Base64BinaryType and has a value; `false` otherwise
   */
  public hasValueBase64BinaryType(): boolean {
    return this.hasValue() && this.value instanceof Base64BinaryType;
  }

  /**
   * @returns the `value` property value as a BooleanType object if defined; else undefined
   */
  public getValueBooleanType(): BooleanType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof BooleanType)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected BooleanType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a BooleanType and has a value; `false` otherwise
   */
  public hasValueBooleanType(): boolean {
    return this.hasValue() && this.value instanceof BooleanType;
  }

  /**
   * @returns the `value` property value as a CanonicalType object if defined; else undefined
   */
  public getValueCanonicalType(): CanonicalType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof CanonicalType)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected CanonicalType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a CanonicalType and has a value; `false` otherwise
   */
  public hasValueCanonicalType(): boolean {
    return this.hasValue() && this.value instanceof CanonicalType;
  }

  /**
   * @returns the `value` property value as a CodeType object if defined; else undefined
   */
  public getValueCodeType(): CodeType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof CodeType)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected CodeType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a CodeType and has a value; `false` otherwise
   */
  public hasValueCodeType(): boolean {
    return this.hasValue() && this.value instanceof CodeType;
  }

  /**
   * @returns the `value` property value as a DateType object if defined; else undefined
   */
  public getValueDateType(): DateType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof DateType)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected DateType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a DateType and has a value; `false` otherwise
   */
  public hasValueDateType(): boolean {
    return this.hasValue() && this.value instanceof DateType;
  }

  /**
   * @returns the `value` property value as a DateTimeType object if defined; else undefined
   */
  public getValueDateTimeType(): DateTimeType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof DateTimeType)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected DateTimeType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a DateTimeType and has a value; `false` otherwise
   */
  public hasValueDateTimeType(): boolean {
    return this.hasValue() && this.value instanceof DateTimeType;
  }

  /**
   * @returns the `value` property value as a DecimalType object if defined; else undefined
   */
  public getValueDecimalType(): DecimalType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof DecimalType)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected DecimalType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a DecimalType and has a value; `false` otherwise
   */
  public hasValueDecimalType(): boolean {
    return this.hasValue() && this.value instanceof DecimalType;
  }

  /**
   * @returns the `value` property value as a IdType object if defined; else undefined
   */
  public getValueIdType(): IdType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof IdType)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected IdType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a IdType and has a value; `false` otherwise
   */
  public hasValueIdType(): boolean {
    return this.hasValue() && this.value instanceof IdType;
  }

  /**
   * @returns the `value` property value as a InstantType object if defined; else undefined
   */
  public getValueInstantType(): InstantType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof InstantType)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected InstantType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a InstantType and has a value; `false` otherwise
   */
  public hasValueInstantType(): boolean {
    return this.hasValue() && this.value instanceof InstantType;
  }

  /**
   * @returns the `value` property value as a IntegerType object if defined; else undefined
   */
  public getValueIntegerType(): IntegerType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof IntegerType)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected IntegerType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a IntegerType and has a value; `false` otherwise
   */
  public hasValueIntegerType(): boolean {
    return this.hasValue() && this.value instanceof IntegerType;
  }

  /**
   * @returns the `value` property value as a MarkdownType object if defined; else undefined
   */
  public getValueMarkdownType(): MarkdownType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof MarkdownType)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected MarkdownType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a MarkdownType and has a value; `false` otherwise
   */
  public hasValueMarkdownType(): boolean {
    return this.hasValue() && this.value instanceof MarkdownType;
  }

  /**
   * @returns the `value` property value as a OidType object if defined; else undefined
   */
  public getValueOidType(): OidType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof OidType)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected OidType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a OidType and has a value; `false` otherwise
   */
  public hasValueOidType(): boolean {
    return this.hasValue() && this.value instanceof OidType;
  }

  /**
   * @returns the `value` property value as a PositiveIntType object if defined; else undefined
   */
  public getValuePositiveIntType(): PositiveIntType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof PositiveIntType)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected PositiveIntType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a PositiveIntType and has a value; `false` otherwise
   */
  public hasValuePositiveIntType(): boolean {
    return this.hasValue() && this.value instanceof PositiveIntType;
  }

  /**
   * @returns the `value` property value as a StringType object if defined; else undefined
   */
  public getValueStringType(): StringType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof StringType)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected StringType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a StringType and has a value; `false` otherwise
   */
  public hasValueStringType(): boolean {
    return this.hasValue() && this.value instanceof StringType;
  }

  /**
   * @returns the `value` property value as a TimeType object if defined; else undefined
   */
  public getValueTimeType(): TimeType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof TimeType)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected TimeType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a TimeType and has a value; `false` otherwise
   */
  public hasValueTimeType(): boolean {
    return this.hasValue() && this.value instanceof TimeType;
  }

  /**
   * @returns the `value` property value as a UnsignedIntType object if defined; else undefined
   */
  public getValueUnsignedIntType(): UnsignedIntType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof UnsignedIntType)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected UnsignedIntType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a UnsignedIntType and has a value; `false` otherwise
   */
  public hasValueUnsignedIntType(): boolean {
    return this.hasValue() && this.value instanceof UnsignedIntType;
  }

  /**
   * @returns the `value` property value as a UriType object if defined; else undefined
   */
  public getValueUriType(): UriType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof UriType)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected UriType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a UriType and has a value; `false` otherwise
   */
  public hasValueUriType(): boolean {
    return this.hasValue() && this.value instanceof UriType;
  }

  /**
   * @returns the `value` property value as a UrlType object if defined; else undefined
   */
  public getValueUrlType(): UrlType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof UrlType)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected UrlType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a UrlType and has a value; `false` otherwise
   */
  public hasValueUrlType(): boolean {
    return this.hasValue() && this.value instanceof UrlType;
  }

  /**
   * @returns the `value` property value as a UuidType object if defined; else undefined
   */
  public getValueUuidType(): UuidType | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof UuidType)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected UuidType but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a UuidType and has a value; `false` otherwise
   */
  public hasValueUuidType(): boolean {
    return this.hasValue() && this.value instanceof UuidType;
  }

  /**
   * @returns the `value` property value as a Address object if defined; else undefined
   */
  public getValueAddress(): Address | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Address)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected Address but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a Address and has a value; `false` otherwise
   */
  public hasValueAddress(): boolean {
    return this.hasValue() && this.value instanceof Address;
  }

  /**
   * @returns the `value` property value as a Age object if defined; else undefined
   */
  public getValueAge(): Age | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Age)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected Age but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a Age and has a value; `false` otherwise
   */
  public hasValueAge(): boolean {
    return this.hasValue() && this.value instanceof Age;
  }

  /**
   * @returns the `value` property value as a Annotation object if defined; else undefined
   */
  public getValueAnnotation(): Annotation | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Annotation)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected Annotation but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a Annotation and has a value; `false` otherwise
   */
  public hasValueAnnotation(): boolean {
    return this.hasValue() && this.value instanceof Annotation;
  }

  /**
   * @returns the `value` property value as a Attachment object if defined; else undefined
   */
  public getValueAttachment(): Attachment | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Attachment)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected Attachment but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a Attachment and has a value; `false` otherwise
   */
  public hasValueAttachment(): boolean {
    return this.hasValue() && this.value instanceof Attachment;
  }

  /**
   * @returns the `value` property value as a CodeableConcept object if defined; else undefined
   */
  public getValueCodeableConcept(): CodeableConcept | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof CodeableConcept)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected CodeableConcept but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a CodeableConcept and has a value; `false` otherwise
   */
  public hasValueCodeableConcept(): boolean {
    return this.hasValue() && this.value instanceof CodeableConcept;
  }

  /**
   * @returns the `value` property value as a CodeableReference object if defined; else undefined
   */
  public getValueCodeableReference(): CodeableReference | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof CodeableReference)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected CodeableReference but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a CodeableReference and has a value; `false` otherwise
   */
  public hasValueCodeableReference(): boolean {
    return this.hasValue() && this.value instanceof CodeableReference;
  }

  /**
   * @returns the `value` property value as a Coding object if defined; else undefined
   */
  public getValueCoding(): Coding | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Coding)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected Coding but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a Coding and has a value; `false` otherwise
   */
  public hasValueCoding(): boolean {
    return this.hasValue() && this.value instanceof Coding;
  }

  /**
   * @returns the `value` property value as a ContactPoint object if defined; else undefined
   */
  public getValueContactPoint(): ContactPoint | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof ContactPoint)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected ContactPoint but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a ContactPoint and has a value; `false` otherwise
   */
  public hasValueContactPoint(): boolean {
    return this.hasValue() && this.value instanceof ContactPoint;
  }

  /**
   * @returns the `value` property value as a Count object if defined; else undefined
   */
  public getValueCount(): Count | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Count)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected Count but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a Count and has a value; `false` otherwise
   */
  public hasValueCount(): boolean {
    return this.hasValue() && this.value instanceof Count;
  }

  /**
   * @returns the `value` property value as a Distance object if defined; else undefined
   */
  public getValueDistance(): Distance | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Distance)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected Distance but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a Distance and has a value; `false` otherwise
   */
  public hasValueDistance(): boolean {
    return this.hasValue() && this.value instanceof Distance;
  }

  /**
   * @returns the `value` property value as a Duration object if defined; else undefined
   */
  public getValueDuration(): Duration | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Duration)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected Duration but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a Duration and has a value; `false` otherwise
   */
  public hasValueDuration(): boolean {
    return this.hasValue() && this.value instanceof Duration;
  }

  /**
   * @returns the `value` property value as a HumanName object if defined; else undefined
   */
  public getValueHumanName(): HumanName | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof HumanName)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected HumanName but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a HumanName and has a value; `false` otherwise
   */
  public hasValueHumanName(): boolean {
    return this.hasValue() && this.value instanceof HumanName;
  }

  /**
   * @returns the `value` property value as a Identifier object if defined; else undefined
   */
  public getValueIdentifier(): Identifier | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Identifier)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected Identifier but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a Identifier and has a value; `false` otherwise
   */
  public hasValueIdentifier(): boolean {
    return this.hasValue() && this.value instanceof Identifier;
  }

  /**
   * @returns the `value` property value as a Money object if defined; else undefined
   */
  public getValueMoney(): Money | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Money)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected Money but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a Money and has a value; `false` otherwise
   */
  public hasValueMoney(): boolean {
    return this.hasValue() && this.value instanceof Money;
  }

  /**
   * @returns the `value` property value as a Period object if defined; else undefined
   */
  public getValuePeriod(): Period | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Period)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected Period but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a Period and has a value; `false` otherwise
   */
  public hasValuePeriod(): boolean {
    return this.hasValue() && this.value instanceof Period;
  }

  /**
   * @returns the `value` property value as a Quantity object if defined; else undefined
   */
  public getValueQuantity(): Quantity | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Quantity)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected Quantity but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a Quantity and has a value; `false` otherwise
   */
  public hasValueQuantity(): boolean {
    return this.hasValue() && this.value instanceof Quantity;
  }

  /**
   * @returns the `value` property value as a Range object if defined; else undefined
   */
  public getValueRange(): Range | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Range)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected Range but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a Range and has a value; `false` otherwise
   */
  public hasValueRange(): boolean {
    return this.hasValue() && this.value instanceof Range;
  }

  /**
   * @returns the `value` property value as a Ratio object if defined; else undefined
   */
  public getValueRatio(): Ratio | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Ratio)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected Ratio but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a Ratio and has a value; `false` otherwise
   */
  public hasValueRatio(): boolean {
    return this.hasValue() && this.value instanceof Ratio;
  }

  /**
   * @returns the `value` property value as a RatioRange object if defined; else undefined
   */
  public getValueRatioRange(): RatioRange | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof RatioRange)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected RatioRange but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a RatioRange and has a value; `false` otherwise
   */
  public hasValueRatioRange(): boolean {
    return this.hasValue() && this.value instanceof RatioRange;
  }

  /**
   * @returns the `value` property value as a Reference object if defined; else undefined
   */
  public getValueReference(): Reference | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Reference)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected Reference but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a Reference and has a value; `false` otherwise
   */
  public hasValueReference(): boolean {
    return this.hasValue() && this.value instanceof Reference;
  }

  /**
   * @returns the `value` property value as a SampledData object if defined; else undefined
   */
  public getValueSampledData(): SampledData | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof SampledData)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected SampledData but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a SampledData and has a value; `false` otherwise
   */
  public hasValueSampledData(): boolean {
    return this.hasValue() && this.value instanceof SampledData;
  }

  /**
   * @returns the `value` property value as a Signature object if defined; else undefined
   */
  public getValueSignature(): Signature | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Signature)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected Signature but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a Signature and has a value; `false` otherwise
   */
  public hasValueSignature(): boolean {
    return this.hasValue() && this.value instanceof Signature;
  }

  /**
   * @returns the `value` property value as a Timing object if defined; else undefined
   */
  public getValueTiming(): Timing | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Timing)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected Timing but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a Timing and has a value; `false` otherwise
   */
  public hasValueTiming(): boolean {
    return this.hasValue() && this.value instanceof Timing;
  }

  /**
   * @returns the `value` property value as a ContactDetail object if defined; else undefined
   */
  public getValueContactDetail(): ContactDetail | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof ContactDetail)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected ContactDetail but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a ContactDetail and has a value; `false` otherwise
   */
  public hasValueContactDetail(): boolean {
    return this.hasValue() && this.value instanceof ContactDetail;
  }

  /**
   * @returns the `value` property value as a Contributor object if defined; else undefined
   */
  public getValueContributor(): Contributor | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Contributor)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected Contributor but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a Contributor and has a value; `false` otherwise
   */
  public hasValueContributor(): boolean {
    return this.hasValue() && this.value instanceof Contributor;
  }

  /**
   * @returns the `value` property value as a DataRequirement object if defined; else undefined
   */
  public getValueDataRequirement(): DataRequirement | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof DataRequirement)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected DataRequirement but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a DataRequirement and has a value; `false` otherwise
   */
  public hasValueDataRequirement(): boolean {
    return this.hasValue() && this.value instanceof DataRequirement;
  }

  /**
   * @returns the `value` property value as a Expression object if defined; else undefined
   */
  public getValueExpression(): Expression | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Expression)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected Expression but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a Expression and has a value; `false` otherwise
   */
  public hasValueExpression(): boolean {
    return this.hasValue() && this.value instanceof Expression;
  }

  /**
   * @returns the `value` property value as a ParameterDefinition object if defined; else undefined
   */
  public getValueParameterDefinition(): ParameterDefinition | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof ParameterDefinition)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected ParameterDefinition but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a ParameterDefinition and has a value; `false` otherwise
   */
  public hasValueParameterDefinition(): boolean {
    return this.hasValue() && this.value instanceof ParameterDefinition;
  }

  /**
   * @returns the `value` property value as a RelatedArtifact object if defined; else undefined
   */
  public getValueRelatedArtifact(): RelatedArtifact | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof RelatedArtifact)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected RelatedArtifact but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a RelatedArtifact and has a value; `false` otherwise
   */
  public hasValueRelatedArtifact(): boolean {
    return this.hasValue() && this.value instanceof RelatedArtifact;
  }

  /**
   * @returns the `value` property value as a TriggerDefinition object if defined; else undefined
   */
  public getValueTriggerDefinition(): TriggerDefinition | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof TriggerDefinition)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected TriggerDefinition but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a TriggerDefinition and has a value; `false` otherwise
   */
  public hasValueTriggerDefinition(): boolean {
    return this.hasValue() && this.value instanceof TriggerDefinition;
  }

  /**
   * @returns the `value` property value as a UsageContext object if defined; else undefined
   */
  public getValueUsageContext(): UsageContext | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof UsageContext)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected UsageContext but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a UsageContext and has a value; `false` otherwise
   */
  public hasValueUsageContext(): boolean {
    return this.hasValue() && this.value instanceof UsageContext;
  }

  /**
   * @returns the `value` property value as a Dosage object if defined; else undefined
   */
  public getValueDosage(): Dosage | undefined {
    if (!isDefined<IDataType | undefined>(this.value)) {
      return undefined;
    }
    if (!(this.value instanceof Dosage)) {
      throw new InvalidTypeError(
        `DataType mismatch for Extension.value[x]: Expected Dosage but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `value` property exists as a Dosage and has a value; `false` otherwise
   */
  public hasValueDosage(): boolean {
    return this.hasValue() && this.value instanceof Dosage;
  }
}

/**
 * HumanName Class
 *
 * @remarks
 * Base StructureDefinition for HumanName Type: A human\'s name with the ability to identify parts and usage.
 *
 * Need to be able to record names, along with notes about their use.
 *
 * **FHIR Specification**
 * - **Short:** Name of a human - parts and usage
 * - **Definition:** A human\'s name with the ability to identify parts and usage.
 * - **Comment:** Names may be changed, or repudiated, or people may have different names in different contexts. Names may be divided into parts of different type that have variable significance depending on context, though the division into parts does not always matter. With personal names, the different parts might or might not be imbued with some implicit meaning; various cultures associate different importance with the name parts and the degree to which systems must care about name parts around the world varies widely.
 * - **FHIR Version:** 4.3.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR HumanName](http://hl7.org/fhir/StructureDefinition/HumanName)
 */
export class HumanName extends DataType implements IDataType {
  constructor() {
    super();

    this.nameUseEnum = new NameUseEnum();
  }

  /**
   * Parse the provided `HumanName` JSON to instantiate the HumanName data model.
   *
   * @param sourceJson - JSON representing FHIR `HumanName`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to HumanName
   * @returns HumanName data model or undefined for `HumanName`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): HumanName | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'HumanName';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new HumanName();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'use';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setUseElement(datatype);
    }

    fieldName = 'text';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setTextElement(datatype);
    }

    fieldName = 'family';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setFamilyElement(datatype);
    }

    fieldName = 'given';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: StringType | undefined = fhirParser.parseStringType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addGivenElement(datatype);
        }
      });
    }

    fieldName = 'prefix';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: StringType | undefined = fhirParser.parseStringType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addPrefixElement(datatype);
        }
      });
    }

    fieldName = 'suffix';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: StringType | undefined = fhirParser.parseStringType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addSuffixElement(datatype);
        }
      });
    }

    fieldName = 'period';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Period | undefined = Period.parse(classJsonObj[fieldName]!, sourceField);
      instance.setPeriod(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: NameUse
   *
   * @see {@link NameUseEnum }
   */
  private readonly nameUseEnum: NameUseEnum;

  /**
   * HumanName.use Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** usual | official | temp | nickname | anonymous | old | maiden
   * - **Definition:** Identifies the purpose for this name.
   * - **Comment:** Applications can assume that a name is current unless it explicitly says that it is temporary or old.
   * - **Requirements:** Allows the appropriate name for a particular context of use to be selected from among a set of names.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** true
   * - **isModifierReason:** This is labeled as &quot;Is Modifier&quot; because applications should not mistake a temporary or old name etc.for a current/permanent one
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link NameUseEnum }
   */
  private use?: EnumCodeType | undefined;

  /**
   * HumanName.text Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Text representation of the full name
   * - **Definition:** Specifies the entire name as it should be displayed e.g. on an application UI. This may be provided instead of or as well as the specific parts.
   * - **Comment:** Can provide both a text representation and parts. Applications updating a name SHALL ensure that when both text and parts are present,  no content is included in the text that isn\'t found in a part.
   * - **Requirements:** A renderable, unencoded form.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private text?: StringType | undefined;

  /**
   * HumanName.family Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Family name (often called \'Surname\')
   * - **Definition:** The part of a name that links to the genealogy. In some cultures (e.g. Eritrea) the family name of a son is the first name of his father.
   * - **Comment:** Family Name may be decomposed into specific parts using extensions (de, nl, es related cultures).
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private family?: StringType | undefined;

  /**
   * HumanName.given Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Given names (not always \'first\'). Includes middle names
   * - **Definition:** Given name.
   * - **Comment:** If only initials are recorded, they may be used in place of the full name parts. Initials may be separated into multiple given names but often aren\'t due to paractical limitations.  This element is not called "first name" since given names do not always come first.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private given?: StringType[] | undefined;

  /**
   * HumanName.prefix Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Parts that come before the name
   * - **Definition:** Part of the name that is acquired as a title due to academic, legal, employment or nobility status, etc. and that appears at the start of the name.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private prefix?: StringType[] | undefined;

  /**
   * HumanName.suffix Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Parts that come after the name
   * - **Definition:** Part of the name that is acquired as a title due to academic, legal, employment or nobility status, etc. and that appears at the end of the name.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private suffix?: StringType[] | undefined;

  /**
   * HumanName.period Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Time period when name was/is in use
   * - **Definition:** Indicates the period of time when this name was valid for the named person.
   * - **Requirements:** Allows names to be placed in historical context.
   * - **FHIR Type:** `Period`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private period?: Period | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `use` property value as a EnumCodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link NameUseEnum }
   */
  public getUseEnumType(): EnumCodeType | undefined {
    return this.use;
  }

  /**
   * Assigns the provided EnumCodeType value to the `use` property.
   *
   * @param enumType - the `use` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code values
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link NameUseEnum }
   */
  public setUseEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid HumanName.use';
      assertEnumCodeType<NameUseEnum>(enumType, NameUseEnum, errMsgPrefix);
      this.use = enumType;
    } else {
      this.use = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `use` property exists and has a value; `false` otherwise
   */
  public hasUseEnumType(): boolean {
    return isDefined<EnumCodeType>(this.use) && !this.use.isEmpty() && this.use.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the `use` property value as a CodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link NameUseEnum }
   */
  public getUseElement(): CodeType | undefined {
    if (this.use === undefined) {
      return undefined;
    }
    return this.use as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the `use` property.
   *
   * @param element - the `use` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link NameUseEnum }
   */
  public setUseElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid HumanName.use; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.use = new EnumCodeType(element, this.nameUseEnum);
    } else {
      this.use = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `use` property exists and has a value; `false` otherwise
   */
  public hasUseElement(): boolean {
    return this.hasUseEnumType();
  }

  /**
   * @returns the `use` property value as a fhirCode if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link NameUseEnum }
   */
  public getUse(): fhirCode | undefined {
    if (this.use === undefined) {
      return undefined;
    }
    return this.use.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the `use` property.
   *
   * @param value - the `use` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link NameUseEnum }
   */
  public setUse(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid HumanName.use; Provided value is not an instance of fhirCode.`;
      this.use = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.nameUseEnum);
    } else {
      this.use = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `use` property exists and has a value; `false` otherwise
   */
  public hasUse(): boolean {
    return this.hasUseEnumType();
  }

  /**
   * @returns the `text` property value as a StringType object if defined; else an empty StringType object
   */
  public getTextElement(): StringType {
    return this.text ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `text` property.
   *
   * @param element - the `text` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTextElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid HumanName.text; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.text = element;
    } else {
      this.text = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `text` property exists and has a value; `false` otherwise
   */
  public hasTextElement(): boolean {
    return isDefined<StringType>(this.text) && !this.text.isEmpty();
  }

  /**
   * @returns the `text` property value as a fhirString if defined; else undefined
   */
  public getText(): fhirString | undefined {
    return this.text?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `text` property.
   *
   * @param value - the `text` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setText(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid HumanName.text (${String(value)})`;
      this.text = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.text = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `text` property exists and has a value; `false` otherwise
   */
  public hasText(): boolean {
    return this.hasTextElement();
  }

  /**
   * @returns the `family` property value as a StringType object if defined; else an empty StringType object
   */
  public getFamilyElement(): StringType {
    return this.family ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `family` property.
   *
   * @param element - the `family` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setFamilyElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid HumanName.family; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.family = element;
    } else {
      this.family = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `family` property exists and has a value; `false` otherwise
   */
  public hasFamilyElement(): boolean {
    return isDefined<StringType>(this.family) && !this.family.isEmpty();
  }

  /**
   * @returns the `family` property value as a fhirString if defined; else undefined
   */
  public getFamily(): fhirString | undefined {
    return this.family?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `family` property.
   *
   * @param value - the `family` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setFamily(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid HumanName.family (${String(value)})`;
      this.family = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.family = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `family` property exists and has a value; `false` otherwise
   */
  public hasFamily(): boolean {
    return this.hasFamilyElement();
  }

  /**
   * @returns the `given` property value as a StringType array
   */
  public getGivenElement(): StringType[] {
    return this.given ?? ([] as StringType[]);
  }

  /**
   * Assigns the provided StringType array value to the `given` property.
   *
   * @param element - the `given` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setGivenElement(element: StringType[] | undefined): this {
    if (isDefinedList<StringType>(element)) {
      const optErrMsg = `Invalid HumanName.given; Provided value array has an element that is not an instance of StringType.`;
      assertFhirTypeList<StringType>(element, StringType, optErrMsg);
      this.given = element;
    } else {
      this.given = undefined;
    }
    return this;
  }

  /**
   * Add the provided StringType value to the `given` array property.
   *
   * @param element - the `given` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addGivenElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid HumanName.given; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.initGiven();
      this.given?.push(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `given` property exists and has a value; `false` otherwise
   */
  public hasGivenElement(): boolean {
    return isDefinedList<StringType>(this.given) && this.given.some((item: StringType) => !item.isEmpty());
  }

  /**
   * @returns the `given` property value as a fhirString array
   */
  public getGiven(): fhirString[] {
    this.initGiven();
    const givenValues = [] as fhirString[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.given!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        givenValues.push(value);
      }
    }
    return givenValues;
  }

  /**
   * Assigns the provided primitive value array to the `given` property.
   *
   * @param value - the `given` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setGiven(value: fhirString[] | undefined): this {
    if (isDefinedList<fhirString>(value)) {
      const givenElements = [] as StringType[];
      for (const givenValue of value) {
        const optErrMsg = `Invalid HumanName.given array item (${String(givenValue)})`;
        const element = new StringType(parseFhirPrimitiveData(givenValue, fhirStringSchema, optErrMsg));
        givenElements.push(element);
      }
      this.given = givenElements;
    } else {
      this.given = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the `given` array property.
   *
   * @param value - the `given` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addGiven(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid HumanName.given array item (${String(value)})`;
      const element = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
      this.initGiven();
      this.addGivenElement(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `given` property exists and has a value; `false` otherwise
   */
  public hasGiven(): boolean {
    return this.hasGivenElement();
  }

  /**
   * Initialize the `given` property
   */
  private initGiven(): void {
    if (!this.hasGiven()) {
      this.given = [] as StringType[];
    }
  }

  /**
   * @returns the `prefix` property value as a StringType array
   */
  public getPrefixElement(): StringType[] {
    return this.prefix ?? ([] as StringType[]);
  }

  /**
   * Assigns the provided StringType array value to the `prefix` property.
   *
   * @param element - the `prefix` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPrefixElement(element: StringType[] | undefined): this {
    if (isDefinedList<StringType>(element)) {
      const optErrMsg = `Invalid HumanName.prefix; Provided value array has an element that is not an instance of StringType.`;
      assertFhirTypeList<StringType>(element, StringType, optErrMsg);
      this.prefix = element;
    } else {
      this.prefix = undefined;
    }
    return this;
  }

  /**
   * Add the provided StringType value to the `prefix` array property.
   *
   * @param element - the `prefix` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addPrefixElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid HumanName.prefix; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.initPrefix();
      this.prefix?.push(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `prefix` property exists and has a value; `false` otherwise
   */
  public hasPrefixElement(): boolean {
    return isDefinedList<StringType>(this.prefix) && this.prefix.some((item: StringType) => !item.isEmpty());
  }

  /**
   * @returns the `prefix` property value as a fhirString array
   */
  public getPrefix(): fhirString[] {
    this.initPrefix();
    const prefixValues = [] as fhirString[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.prefix!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        prefixValues.push(value);
      }
    }
    return prefixValues;
  }

  /**
   * Assigns the provided primitive value array to the `prefix` property.
   *
   * @param value - the `prefix` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPrefix(value: fhirString[] | undefined): this {
    if (isDefinedList<fhirString>(value)) {
      const prefixElements = [] as StringType[];
      for (const prefixValue of value) {
        const optErrMsg = `Invalid HumanName.prefix array item (${String(prefixValue)})`;
        const element = new StringType(parseFhirPrimitiveData(prefixValue, fhirStringSchema, optErrMsg));
        prefixElements.push(element);
      }
      this.prefix = prefixElements;
    } else {
      this.prefix = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the `prefix` array property.
   *
   * @param value - the `prefix` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addPrefix(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid HumanName.prefix array item (${String(value)})`;
      const element = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
      this.initPrefix();
      this.addPrefixElement(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `prefix` property exists and has a value; `false` otherwise
   */
  public hasPrefix(): boolean {
    return this.hasPrefixElement();
  }

  /**
   * Initialize the `prefix` property
   */
  private initPrefix(): void {
    if (!this.hasPrefix()) {
      this.prefix = [] as StringType[];
    }
  }

  /**
   * @returns the `suffix` property value as a StringType array
   */
  public getSuffixElement(): StringType[] {
    return this.suffix ?? ([] as StringType[]);
  }

  /**
   * Assigns the provided StringType array value to the `suffix` property.
   *
   * @param element - the `suffix` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSuffixElement(element: StringType[] | undefined): this {
    if (isDefinedList<StringType>(element)) {
      const optErrMsg = `Invalid HumanName.suffix; Provided value array has an element that is not an instance of StringType.`;
      assertFhirTypeList<StringType>(element, StringType, optErrMsg);
      this.suffix = element;
    } else {
      this.suffix = undefined;
    }
    return this;
  }

  /**
   * Add the provided StringType value to the `suffix` array property.
   *
   * @param element - the `suffix` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addSuffixElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid HumanName.suffix; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.initSuffix();
      this.suffix?.push(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `suffix` property exists and has a value; `false` otherwise
   */
  public hasSuffixElement(): boolean {
    return isDefinedList<StringType>(this.suffix) && this.suffix.some((item: StringType) => !item.isEmpty());
  }

  /**
   * @returns the `suffix` property value as a fhirString array
   */
  public getSuffix(): fhirString[] {
    this.initSuffix();
    const suffixValues = [] as fhirString[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.suffix!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        suffixValues.push(value);
      }
    }
    return suffixValues;
  }

  /**
   * Assigns the provided primitive value array to the `suffix` property.
   *
   * @param value - the `suffix` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSuffix(value: fhirString[] | undefined): this {
    if (isDefinedList<fhirString>(value)) {
      const suffixElements = [] as StringType[];
      for (const suffixValue of value) {
        const optErrMsg = `Invalid HumanName.suffix array item (${String(suffixValue)})`;
        const element = new StringType(parseFhirPrimitiveData(suffixValue, fhirStringSchema, optErrMsg));
        suffixElements.push(element);
      }
      this.suffix = suffixElements;
    } else {
      this.suffix = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the `suffix` array property.
   *
   * @param value - the `suffix` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addSuffix(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid HumanName.suffix array item (${String(value)})`;
      const element = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
      this.initSuffix();
      this.addSuffixElement(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `suffix` property exists and has a value; `false` otherwise
   */
  public hasSuffix(): boolean {
    return this.hasSuffixElement();
  }

  /**
   * Initialize the `suffix` property
   */
  private initSuffix(): void {
    if (!this.hasSuffix()) {
      this.suffix = [] as StringType[];
    }
  }

  /**
   * @returns the `period` property value as a Period object if defined; else an empty Period object
   */
  public getPeriod(): Period {
    return this.period ?? new Period();
  }

  /**
   * Assigns the provided Period object value to the `period` property.
   *
   * @param value - the `period` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setPeriod(value: Period | undefined): this {
    if (isDefined<Period>(value)) {
      const optErrMsg = `Invalid HumanName.period; Provided element is not an instance of Period.`;
      assertFhirType<Period>(value, Period, optErrMsg);
      this.period = value;
    } else {
      this.period = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `period` property exists and has a value; `false` otherwise
   */
  public hasPeriod(): boolean {
    return isDefined<Period>(this.period) && !this.period.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'HumanName';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.use,
      this.text,
      this.family,
      this.given,
      this.prefix,
      this.suffix,
      this.period,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): HumanName {
    const dest = new HumanName();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: HumanName): void {
    super.copyValues(dest);
    dest.use = this.use?.copy();
    dest.text = this.text?.copy();
    dest.family = this.family?.copy();
    const givenList = copyListValues<StringType>(this.given);
    dest.given = givenList.length === 0 ? undefined : givenList;
    const prefixList = copyListValues<StringType>(this.prefix);
    dest.prefix = prefixList.length === 0 ? undefined : prefixList;
    const suffixList = copyListValues<StringType>(this.suffix);
    dest.suffix = suffixList.length === 0 ? undefined : suffixList;
    dest.period = this.period?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasUseElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getUseElement()!, 'use', jsonObj);
    }

    if (this.hasTextElement()) {
      setFhirPrimitiveJson<fhirString>(this.getTextElement(), 'text', jsonObj);
    }

    if (this.hasFamilyElement()) {
      setFhirPrimitiveJson<fhirString>(this.getFamilyElement(), 'family', jsonObj);
    }

    if (this.hasGiven()) {
      setFhirPrimitiveListJson(this.getGivenElement(), 'given', jsonObj);
    }

    if (this.hasPrefix()) {
      setFhirPrimitiveListJson(this.getPrefixElement(), 'prefix', jsonObj);
    }

    if (this.hasSuffix()) {
      setFhirPrimitiveListJson(this.getSuffixElement(), 'suffix', jsonObj);
    }

    if (this.hasPeriod()) {
      setFhirComplexJson(this.getPeriod(), 'period', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * MarketingStatus Class
 *
 * @remarks
 * Base StructureDefinition for MarketingStatus Type: The marketing status describes the date when a medicinal product is actually put on the market or the date as of which it is no longer available.
 *
 * **FHIR Specification**
 * - **Short:** The marketing status describes the date when a medicinal product is actually put on the market or the date as of which it is no longer available
 * - **Definition:** The marketing status describes the date when a medicinal product is actually put on the market or the date as of which it is no longer available.
 * - **FHIR Version:** 4.3.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR MarketingStatus](http://hl7.org/fhir/StructureDefinition/MarketingStatus)
 */
export class MarketingStatus extends BackboneType implements IBackboneType {
  constructor(status: CodeableConcept | null = null) {
    super();

    this.status = null;
    if (isDefined<CodeableConcept>(status)) {
      this.setStatus(status);
    }
  }

  /**
   * Parse the provided `MarketingStatus` JSON to instantiate the MarketingStatus data model.
   *
   * @param sourceJson - JSON representing FHIR `MarketingStatus`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to MarketingStatus
   * @returns MarketingStatus data model or undefined for `MarketingStatus`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): MarketingStatus | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'MarketingStatus';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new MarketingStatus();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneTypeJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    

    const missingReqdProperties: string[] = [];

    fieldName = 'country';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = CodeableConcept.parse(classJsonObj[fieldName]!, sourceField);
      instance.setCountry(datatype);
    }

    fieldName = 'jurisdiction';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = CodeableConcept.parse(classJsonObj[fieldName]!, sourceField);
      instance.setJurisdiction(datatype);
    }

    fieldName = 'status';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = CodeableConcept.parse(classJsonObj[fieldName]!, sourceField);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setStatus(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'dateRange';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Period | undefined = Period.parse(classJsonObj[fieldName]!, sourceField);
      instance.setDateRange(datatype);
    }

    fieldName = 'restoreDate';
    sourceField = `${optSourceValue}.${fieldName}`;
    const primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DateTimeType | undefined = fhirParser.parseDateTimeType(dtJson, dtSiblingJson);
      instance.setRestoreDateElement(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_REQD_IN_JSON} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * MarketingStatus.country Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The country in which the marketing authorisation has been granted shall be specified It should be specified using the ISO 3166 - 1 alpha-2 code elements
   * - **Definition:** The country in which the marketing authorisation has been granted shall be specified It should be specified using the ISO 3166 - 1 alpha-2 code elements.
   * - **FHIR Type:** `CodeableConcept`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private country?: CodeableConcept | undefined;

  /**
   * MarketingStatus.jurisdiction Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Where a Medicines Regulatory Agency has granted a marketing authorisation for which specific provisions within a jurisdiction apply, the jurisdiction can be specified using an appropriate controlled terminology The controlled term and the controlled term identifier shall be specified
   * - **Definition:** Where a Medicines Regulatory Agency has granted a marketing authorisation for which specific provisions within a jurisdiction apply, the jurisdiction can be specified using an appropriate controlled terminology The controlled term and the controlled term identifier shall be specified.
   * - **FHIR Type:** `CodeableConcept`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private jurisdiction?: CodeableConcept | undefined;

  /**
   * MarketingStatus.status Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** This attribute provides information on the status of the marketing of the medicinal product See ISO/TS 20443 for more information and examples
   * - **Definition:** This attribute provides information on the status of the marketing of the medicinal product See ISO/TS 20443 for more information and examples.
   * - **FHIR Type:** `CodeableConcept`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private status: CodeableConcept | null;

  /**
   * MarketingStatus.dateRange Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The date when the Medicinal Product is placed on the market by the Marketing Authorisation Holder (or where applicable, the manufacturer/distributor) in a country and/or jurisdiction shall be provided A complete date consisting of day, month and year shall be specified using the ISO 8601 date format NOTE "Placed on the market" refers to the release of the Medicinal Product into the distribution chain
   * - **Definition:** The date when the Medicinal Product is placed on the market by the Marketing Authorisation Holder (or where applicable, the manufacturer/distributor) in a country and/or jurisdiction shall be provided A complete date consisting of day, month and year shall be specified using the ISO 8601 date format NOTE "Placed on the market" refers to the release of the Medicinal Product into the distribution chain.
   * - **FHIR Type:** `Period`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private dateRange?: Period | undefined;

  /**
   * MarketingStatus.restoreDate Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The date when the Medicinal Product is placed on the market by the Marketing Authorisation Holder (or where applicable, the manufacturer/distributor) in a country and/or jurisdiction shall be provided A complete date consisting of day, month and year shall be specified using the ISO 8601 date format NOTE "Placed on the market" refers to the release of the Medicinal Product into the distribution chain
   * - **Definition:** The date when the Medicinal Product is placed on the market by the Marketing Authorisation Holder (or where applicable, the manufacturer/distributor) in a country and/or jurisdiction shall be provided A complete date consisting of day, month and year shall be specified using the ISO 8601 date format NOTE "Placed on the market" refers to the release of the Medicinal Product into the distribution chain.
   * - **FHIR Type:** `dateTime`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private restoreDate?: DateTimeType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `country` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getCountry(): CodeableConcept {
    return this.country ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Country object value to the `country` property.
   *
   * @param value - the `country` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setCountry(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = `Invalid MarketingStatus.country; Provided element is not an instance of CodeableConcept.`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.country = value;
    } else {
      this.country = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `country` property exists and has a value; `false` otherwise
   */
  public hasCountry(): boolean {
    return isDefined<CodeableConcept>(this.country) && !this.country.isEmpty();
  }

  /**
   * @returns the `jurisdiction` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getJurisdiction(): CodeableConcept {
    return this.jurisdiction ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Jurisdiction object value to the `jurisdiction` property.
   *
   * @param value - the `jurisdiction` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setJurisdiction(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = `Invalid MarketingStatus.jurisdiction; Provided element is not an instance of CodeableConcept.`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.jurisdiction = value;
    } else {
      this.jurisdiction = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `jurisdiction` property exists and has a value; `false` otherwise
   */
  public hasJurisdiction(): boolean {
    return isDefined<CodeableConcept>(this.jurisdiction) && !this.jurisdiction.isEmpty();
  }

  /**
   * @returns the `status` property value as a CodeableConcept object if defined; else null
   */
  public getStatus(): CodeableConcept | null {
    return this.status;
  }

  /**
   * Assigns the provided CodeableConcept object value to the `status` property.
   *
   * @param value - the `status` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setStatus(value: CodeableConcept): this {
    assertIsDefined<CodeableConcept>(value, `MarketingStatus.status is required`);
    const optErrMsg = `Invalid MarketingStatus.status; Provided element is not an instance of CodeableConcept.`;
    assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
    this.status = value;
    return this;
  }

  /**
   * @returns `true` if the `status` property exists and has a value; `false` otherwise
   */
  public hasStatus(): boolean {
    return isDefined<CodeableConcept>(this.status) && !this.status.isEmpty();
  }

  /**
   * @returns the `dateRange` property value as a Period object if defined; else an empty Period object
   */
  public getDateRange(): Period {
    return this.dateRange ?? new Period();
  }

  /**
   * Assigns the provided DateRange object value to the `dateRange` property.
   *
   * @param value - the `dateRange` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setDateRange(value: Period | undefined): this {
    if (isDefined<Period>(value)) {
      const optErrMsg = `Invalid MarketingStatus.dateRange; Provided element is not an instance of Period.`;
      assertFhirType<Period>(value, Period, optErrMsg);
      this.dateRange = value;
    } else {
      this.dateRange = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `dateRange` property exists and has a value; `false` otherwise
   */
  public hasDateRange(): boolean {
    return isDefined<Period>(this.dateRange) && !this.dateRange.isEmpty();
  }

  /**
   * @returns the `restoreDate` property value as a DateTimeType object if defined; else an empty DateTimeType object
   */
  public getRestoreDateElement(): DateTimeType {
    return this.restoreDate ?? new DateTimeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `restoreDate` property.
   *
   * @param element - the `restoreDate` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setRestoreDateElement(element: DateTimeType | undefined): this {
    if (isDefined<DateTimeType>(element)) {
      const optErrMsg = `Invalid MarketingStatus.restoreDate; Provided element is not an instance of DateTimeType.`;
      assertFhirType<DateTimeType>(element, DateTimeType, optErrMsg);
      this.restoreDate = element;
    } else {
      this.restoreDate = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `restoreDate` property exists and has a value; `false` otherwise
   */
  public hasRestoreDateElement(): boolean {
    return isDefined<DateTimeType>(this.restoreDate) && !this.restoreDate.isEmpty();
  }

  /**
   * @returns the `restoreDate` property value as a fhirDateTime if defined; else undefined
   */
  public getRestoreDate(): fhirDateTime | undefined {
    return this.restoreDate?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `restoreDate` property.
   *
   * @param value - the `restoreDate` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setRestoreDate(value: fhirDateTime | undefined): this {
    if (isDefined<fhirDateTime>(value)) {
      const optErrMsg = `Invalid MarketingStatus.restoreDate (${String(value)})`;
      this.restoreDate = new DateTimeType(parseFhirPrimitiveData(value, fhirDateTimeSchema, optErrMsg));
    } else {
      this.restoreDate = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `restoreDate` property exists and has a value; `false` otherwise
   */
  public hasRestoreDate(): boolean {
    return this.hasRestoreDateElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'MarketingStatus';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.country,
      this.jurisdiction,
      this.status,
      this.dateRange,
      this.restoreDate,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): MarketingStatus {
    const dest = new MarketingStatus();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: MarketingStatus): void {
    super.copyValues(dest);
    dest.country = this.country?.copy();
    dest.jurisdiction = this.jurisdiction?.copy();
    dest.status = this.status ? this.status.copy() : null;
    dest.dateRange = this.dateRange?.copy();
    dest.restoreDate = this.restoreDate?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasCountry()) {
      setFhirComplexJson(this.getCountry(), 'country', jsonObj);
    }

    if (this.hasJurisdiction()) {
      setFhirComplexJson(this.getJurisdiction(), 'jurisdiction', jsonObj);
    }

    if (this.hasStatus()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirComplexJson(this.getStatus()!, 'status', jsonObj);
    } else {
      missingReqdProperties.push(`MarketingStatus.status`);
    }

    if (this.hasDateRange()) {
      setFhirComplexJson(this.getDateRange(), 'dateRange', jsonObj);
    }

    if (this.hasRestoreDateElement()) {
      setFhirPrimitiveJson<fhirDateTime>(this.getRestoreDateElement(), 'restoreDate', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_DO_NOT_EXIST} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

/**
 * Money Class
 *
 * @remarks
 * Base StructureDefinition for Money Type: An amount of economic utility in some recognized currency.
 *
 * **FHIR Specification**
 * - **Short:** An amount of economic utility in some recognized currency
 * - **Definition:** An amount of economic utility in some recognized currency.
 * - **FHIR Version:** 4.3.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR Money](http://hl7.org/fhir/StructureDefinition/Money)
 */
export class Money extends DataType implements IDataType {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided `Money` JSON to instantiate the Money data model.
   *
   * @param sourceJson - JSON representing FHIR `Money`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to Money
   * @returns Money data model or undefined for `Money`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Money | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Money';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new Money();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'value';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setValueElement(datatype);
    }

    fieldName = 'currency';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setCurrencyElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Money.value Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Numerical value (with implicit precision)
   * - **Definition:** Numerical value (with implicit precision).
   * - **Comment:** Monetary values have their own rules for handling precision (refer to standard accounting text books).
   * - **Requirements:** The amount of the currency. The value includes an implicit precision in the presentation of the value.
   * - **FHIR Type:** `decimal`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private value?: DecimalType | undefined;

  /**
   * Money.currency Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** ISO 4217 Currency Code
   * - **Definition:** ISO 4217 Currency Code.
   * - **Requirements:** A code indicating the currency, taken from ISO 4217.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private currency?: CodeType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `value` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getValueElement(): DecimalType {
    return this.value ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `value` property.
   *
   * @param element - the `value` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValueElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = `Invalid Money.value; Provided element is not an instance of DecimalType.`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.value = element;
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `value` property exists and has a value; `false` otherwise
   */
  public hasValueElement(): boolean {
    return isDefined<DecimalType>(this.value) && !this.value.isEmpty();
  }

  /**
   * @returns the `value` property value as a fhirDecimal if defined; else undefined
   */
  public getValue(): fhirDecimal | undefined {
    return this.value?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `value` property.
   *
   * @param value - the `value` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValue(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = `Invalid Money.value (${String(value)})`;
      this.value = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `value` property exists and has a value; `false` otherwise
   */
  public hasValue(): boolean {
    return this.hasValueElement();
  }

  /**
   * @returns the `currency` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getCurrencyElement(): CodeType {
    return this.currency ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `currency` property.
   *
   * @param element - the `currency` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCurrencyElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid Money.currency; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.currency = element;
    } else {
      this.currency = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `currency` property exists and has a value; `false` otherwise
   */
  public hasCurrencyElement(): boolean {
    return isDefined<CodeType>(this.currency) && !this.currency.isEmpty();
  }

  /**
   * @returns the `currency` property value as a fhirCode if defined; else undefined
   */
  public getCurrency(): fhirCode | undefined {
    return this.currency?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `currency` property.
   *
   * @param value - the `currency` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCurrency(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid Money.currency (${String(value)})`;
      this.currency = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.currency = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `currency` property exists and has a value; `false` otherwise
   */
  public hasCurrency(): boolean {
    return this.hasCurrencyElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Money';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.value,
      this.currency,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Money {
    const dest = new Money();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Money): void {
    super.copyValues(dest);
    dest.value = this.value?.copy();
    dest.currency = this.currency?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasValueElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getValueElement(), 'value', jsonObj);
    }

    if (this.hasCurrencyElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getCurrencyElement(), 'currency', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * ParameterDefinition Class
 *
 * @remarks
 * Base StructureDefinition for ParameterDefinition Type: The parameters to the module. This collection specifies both the input and output parameters. Input parameters are provided by the caller as part of the $evaluate operation. Output parameters are included in the GuidanceResponse.
 *
 * **FHIR Specification**
 * - **Short:** Definition of a parameter to a module
 * - **Definition:** The parameters to the module. This collection specifies both the input and output parameters. Input parameters are provided by the caller as part of the $evaluate operation. Output parameters are included in the GuidanceResponse.
 * - **FHIR Version:** 4.3.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR ParameterDefinition](http://hl7.org/fhir/StructureDefinition/ParameterDefinition)
 */
export class ParameterDefinition extends DataType implements IDataType {
  constructor(use: EnumCodeType | CodeType | fhirCode | null = null, type_: CodeType | fhirCode | null = null) {
    super();

    this.operationParameterUseEnum = new OperationParameterUseEnum();

    this.use = constructorCodeValueAsEnumCodeType<OperationParameterUseEnum>(
      use,
      OperationParameterUseEnum,
      this.operationParameterUseEnum,
      'ParameterDefinition.use',
    );

    this.type_ = null;
    if (isDefined<CodeType | fhirCode>(type_)) {
      if (type_ instanceof PrimitiveType) {
        this.setTypeElement(type_);
      } else {
        this.setType(type_);
      }
    }
  }

  /**
   * Parse the provided `ParameterDefinition` JSON to instantiate the ParameterDefinition data model.
   *
   * @param sourceJson - JSON representing FHIR `ParameterDefinition`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to ParameterDefinition
   * @returns ParameterDefinition data model or undefined for `ParameterDefinition`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): ParameterDefinition | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'ParameterDefinition';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new ParameterDefinition();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'name';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setNameElement(datatype);
    }

    fieldName = 'use';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setUseElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'min';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: IntegerType | undefined = fhirParser.parseIntegerType(dtJson, dtSiblingJson);
      instance.setMinElement(datatype);
    }

    fieldName = 'max';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setMaxElement(datatype);
    }

    fieldName = 'documentation';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setDocumentationElement(datatype);
    }

    fieldName = 'type';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setTypeElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'profile';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CanonicalType | undefined = fhirParser.parseCanonicalType(dtJson, dtSiblingJson);
      instance.setProfileElement(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_REQD_IN_JSON} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * ParameterDefinition.name Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Name used to access the parameter value
   * - **Definition:** The name of the parameter used to allow access to the value of the parameter in evaluation contexts.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private name?: CodeType | undefined;

  /**
   * FHIR CodeSystem: OperationParameterUse
   *
   * @see {@link OperationParameterUseEnum }
   */
  private readonly operationParameterUseEnum: OperationParameterUseEnum;

  /**
   * ParameterDefinition.use Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** in | out
   * - **Definition:** Whether the parameter is input or output for the module.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link OperationParameterUseEnum }
   */
  private use: EnumCodeType | null;

  /**
   * ParameterDefinition.min Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Minimum cardinality
   * - **Definition:** The minimum number of times this parameter SHALL appear in the request or response.
   * - **FHIR Type:** `integer`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private min?: IntegerType | undefined;

  /**
   * ParameterDefinition.max Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Maximum cardinality (a number of *)
   * - **Definition:** The maximum number of times this element is permitted to appear in the request or response.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private max?: StringType | undefined;

  /**
   * ParameterDefinition.documentation Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** A brief description of the parameter
   * - **Definition:** A brief discussion of what the parameter is for and how it is used by the module.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private documentation?: StringType | undefined;

  /**
   * ParameterDefinition.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** What type of value
   * - **Definition:** The type of the parameter.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private type_: CodeType | null;

  /**
   * ParameterDefinition.profile Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** What profile the value is expected to be
   * - **Definition:** If specified, this indicates a profile that the input data must conform to, or that the output data will conform to.
   * - **FHIR Type:** `canonical`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/StructureDefinition',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private profile?: CanonicalType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `name` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getNameElement(): CodeType {
    return this.name ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `name` property.
   *
   * @param element - the `name` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setNameElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid ParameterDefinition.name; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.name = element;
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `name` property exists and has a value; `false` otherwise
   */
  public hasNameElement(): boolean {
    return isDefined<CodeType>(this.name) && !this.name.isEmpty();
  }

  /**
   * @returns the `name` property value as a fhirCode if defined; else undefined
   */
  public getName(): fhirCode | undefined {
    return this.name?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `name` property.
   *
   * @param value - the `name` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setName(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid ParameterDefinition.name (${String(value)})`;
      this.name = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `name` property exists and has a value; `false` otherwise
   */
  public hasName(): boolean {
    return this.hasNameElement();
  }

  /**
   * @returns the `use` property value as a EnumCodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link OperationParameterUseEnum }
   */
  public getUseEnumType(): EnumCodeType | null {
    return this.use;
  }

  /**
   * Assigns the provided EnumCodeType value to the `use` property.
   *
   * @param enumType - the `use` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link OperationParameterUseEnum }
   */
  public setUseEnumType(enumType: EnumCodeType): this {
    assertIsDefined<EnumCodeType>(enumType, `ParameterDefinition.use is required`);
    const errMsgPrefix = `Invalid ParameterDefinition.use`;
    assertEnumCodeType<OperationParameterUseEnum>(enumType, OperationParameterUseEnum, errMsgPrefix);
    this.use = enumType;
    return this;
  }

  /**
   * @returns `true` if the `use` property exists and has a value; `false` otherwise
   */
  public hasUseEnumType(): boolean {
    return isDefined<EnumCodeType>(this.use) && !this.use.isEmpty() && this.use.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the `use` property value as a CodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link OperationParameterUseEnum }
   */
  public getUseElement(): CodeType | null {
    if (this.use === null) {
      return null;
    }
    return this.use as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the `use` property.
   *
   * @param element - the `use` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link OperationParameterUseEnum }
   */
  public setUseElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, `ParameterDefinition.use is required`);
    const optErrMsg = `Invalid ParameterDefinition.use; Provided value is not an instance of CodeType.`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.use = new EnumCodeType(element, this.operationParameterUseEnum);
    return this;
  }

  /**
   * @returns `true` if the `use` property exists and has a value; `false` otherwise
   */
  public hasUseElement(): boolean {
    return this.hasUseEnumType();
  }

  /**
   * @returns the `use` property value as a fhirCode if defined; else null
   *
   * @see CodeSystem Enumeration: {@link OperationParameterUseEnum }
   */
  public getUse(): fhirCode | null {
    if (this.use === null) {
      return null;
    }
    return this.use.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the `use` property.
   *
   * @param value - the `use` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link OperationParameterUseEnum }
   */
  public setUse(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, `ParameterDefinition.use is required`);
    const optErrMsg = `Invalid ParameterDefinition.use (${String(value)})`;
    this.use = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.operationParameterUseEnum);
    return this;
  }

  /**
   * @returns `true` if the `use` property exists and has a value; `false` otherwise
   */
  public hasUse(): boolean {
    return this.hasUseEnumType();
  }

  /**
   * @returns the `min` property value as a IntegerType object if defined; else an empty IntegerType object
   */
  public getMinElement(): IntegerType {
    return this.min ?? new IntegerType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `min` property.
   *
   * @param element - the `min` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMinElement(element: IntegerType | undefined): this {
    if (isDefined<IntegerType>(element)) {
      const optErrMsg = `Invalid ParameterDefinition.min; Provided element is not an instance of IntegerType.`;
      assertFhirType<IntegerType>(element, IntegerType, optErrMsg);
      this.min = element;
    } else {
      this.min = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `min` property exists and has a value; `false` otherwise
   */
  public hasMinElement(): boolean {
    return isDefined<IntegerType>(this.min) && !this.min.isEmpty();
  }

  /**
   * @returns the `min` property value as a fhirInteger if defined; else undefined
   */
  public getMin(): fhirInteger | undefined {
    return this.min?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `min` property.
   *
   * @param value - the `min` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMin(value: fhirInteger | undefined): this {
    if (isDefined<fhirInteger>(value)) {
      const optErrMsg = `Invalid ParameterDefinition.min (${String(value)})`;
      this.min = new IntegerType(parseFhirPrimitiveData(value, fhirIntegerSchema, optErrMsg));
    } else {
      this.min = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `min` property exists and has a value; `false` otherwise
   */
  public hasMin(): boolean {
    return this.hasMinElement();
  }

  /**
   * @returns the `max` property value as a StringType object if defined; else an empty StringType object
   */
  public getMaxElement(): StringType {
    return this.max ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `max` property.
   *
   * @param element - the `max` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMaxElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid ParameterDefinition.max; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.max = element;
    } else {
      this.max = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `max` property exists and has a value; `false` otherwise
   */
  public hasMaxElement(): boolean {
    return isDefined<StringType>(this.max) && !this.max.isEmpty();
  }

  /**
   * @returns the `max` property value as a fhirString if defined; else undefined
   */
  public getMax(): fhirString | undefined {
    return this.max?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `max` property.
   *
   * @param value - the `max` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setMax(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid ParameterDefinition.max (${String(value)})`;
      this.max = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.max = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `max` property exists and has a value; `false` otherwise
   */
  public hasMax(): boolean {
    return this.hasMaxElement();
  }

  /**
   * @returns the `documentation` property value as a StringType object if defined; else an empty StringType object
   */
  public getDocumentationElement(): StringType {
    return this.documentation ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `documentation` property.
   *
   * @param element - the `documentation` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDocumentationElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid ParameterDefinition.documentation; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.documentation = element;
    } else {
      this.documentation = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `documentation` property exists and has a value; `false` otherwise
   */
  public hasDocumentationElement(): boolean {
    return isDefined<StringType>(this.documentation) && !this.documentation.isEmpty();
  }

  /**
   * @returns the `documentation` property value as a fhirString if defined; else undefined
   */
  public getDocumentation(): fhirString | undefined {
    return this.documentation?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `documentation` property.
   *
   * @param value - the `documentation` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDocumentation(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid ParameterDefinition.documentation (${String(value)})`;
      this.documentation = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.documentation = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `documentation` property exists and has a value; `false` otherwise
   */
  public hasDocumentation(): boolean {
    return this.hasDocumentationElement();
  }

  /**
   * @returns the `type_` property value as a CodeType object if defined; else null
   */
  public getTypeElement(): CodeType | null {
    return this.type_;
  }

  /**
   * Assigns the provided PrimitiveType value to the `type_` property.
   *
   * @param element - the `type_` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTypeElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, `ParameterDefinition.type is required`);
    const optErrMsg = `Invalid ParameterDefinition.type; Provided value is not an instance of CodeType.`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.type_ = element;
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasTypeElement(): boolean {
    return isDefined<CodeType>(this.type_) && !this.type_.isEmpty();
  }

  /**
   * @returns the `type_` property value as a fhirCode if defined; else null
   */
  public getType(): fhirCode | null {
    if (this.type_?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.type_.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the `type_` property.
   *
   * @param value - the `type_` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setType(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, `ParameterDefinition.type is required`);
    const optErrMsg = `Invalid ParameterDefinition.type (${String(value)})`;
    this.type_ = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasType(): boolean {
    return this.hasTypeElement();
  }

  /**
   * @returns the `profile` property value as a CanonicalType object if defined; else an empty CanonicalType object
   */
  public getProfileElement(): CanonicalType {
    return this.profile ?? new CanonicalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `profile` property.
   *
   * @param element - the `profile` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setProfileElement(element: CanonicalType | undefined): this {
    if (isDefined<CanonicalType>(element)) {
      const optErrMsg = `Invalid ParameterDefinition.profile; Provided element is not an instance of CanonicalType.`;
      assertFhirType<CanonicalType>(element, CanonicalType, optErrMsg);
      this.profile = element;
    } else {
      this.profile = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `profile` property exists and has a value; `false` otherwise
   */
  public hasProfileElement(): boolean {
    return isDefined<CanonicalType>(this.profile) && !this.profile.isEmpty();
  }

  /**
   * @returns the `profile` property value as a fhirCanonical if defined; else undefined
   */
  public getProfile(): fhirCanonical | undefined {
    return this.profile?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `profile` property.
   *
   * @param value - the `profile` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setProfile(value: fhirCanonical | undefined): this {
    if (isDefined<fhirCanonical>(value)) {
      const optErrMsg = `Invalid ParameterDefinition.profile (${String(value)})`;
      this.profile = new CanonicalType(parseFhirPrimitiveData(value, fhirCanonicalSchema, optErrMsg));
    } else {
      this.profile = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `profile` property exists and has a value; `false` otherwise
   */
  public hasProfile(): boolean {
    return this.hasProfileElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'ParameterDefinition';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.name,
      this.use,
      this.min,
      this.max,
      this.documentation,
      this.type_,
      this.profile,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): ParameterDefinition {
    const dest = new ParameterDefinition();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: ParameterDefinition): void {
    super.copyValues(dest);
    dest.name = this.name?.copy();
    dest.use = this.use ? this.use.copy() : null;
    dest.min = this.min?.copy();
    dest.max = this.max?.copy();
    dest.documentation = this.documentation?.copy();
    dest.type_ = this.type_ ? this.type_.copy() : null;
    dest.profile = this.profile?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasNameElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getNameElement(), 'name', jsonObj);
    }

    if (this.hasUseElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getUseElement()!, 'use', jsonObj);
    } else {
      missingReqdProperties.push(`ParameterDefinition.use`);
    }

    if (this.hasMinElement()) {
      setFhirPrimitiveJson<fhirInteger>(this.getMinElement(), 'min', jsonObj);
    }

    if (this.hasMaxElement()) {
      setFhirPrimitiveJson<fhirString>(this.getMaxElement(), 'max', jsonObj);
    }

    if (this.hasDocumentationElement()) {
      setFhirPrimitiveJson<fhirString>(this.getDocumentationElement(), 'documentation', jsonObj);
    }

    if (this.hasTypeElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getTypeElement()!, 'type', jsonObj);
    } else {
      missingReqdProperties.push(`ParameterDefinition.type`);
    }

    if (this.hasProfileElement()) {
      setFhirPrimitiveJson<fhirCanonical>(this.getProfileElement(), 'profile', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_DO_NOT_EXIST} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

/**
 * Population Class
 *
 * @remarks
 * Base StructureDefinition for Population Type: A populatioof people with some set of grouping criteria.
 *
 * **FHIR Specification**
 * - **Short:** A definition of a set of people that apply to some clinically related context, for example people contraindicated for a certain medication
 * - **Definition:** A populatioof people with some set of grouping criteria.
 * - **FHIR Version:** 4.3.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR Population](http://hl7.org/fhir/StructureDefinition/Population)
 */
export class Population extends BackboneType implements IBackboneType {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided `Population` JSON to instantiate the Population data model.
   *
   * @param sourceJson - JSON representing FHIR `Population`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to Population
   * @returns Population data model or undefined for `Population`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Population | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Population';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new Population();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneTypeJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';

    const classMetadata: DecoratorMetadataObject | null = Population[Symbol.metadata];
    const errorMessage = `DecoratorMetadataObject does not exist for Population`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    fieldName = 'age[x]';
    sourceField = `${optSourceValue}.${fieldName}`;
    const age: IDataType | undefined = fhirParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setAge(age);

    fieldName = 'gender';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = CodeableConcept.parse(classJsonObj[fieldName]!, sourceField);
      instance.setGender(datatype);
    }

    fieldName = 'race';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = CodeableConcept.parse(classJsonObj[fieldName]!, sourceField);
      instance.setRace(datatype);
    }

    fieldName = 'physiologicalCondition';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = CodeableConcept.parse(classJsonObj[fieldName]!, sourceField);
      instance.setPhysiologicalCondition(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Population.age[x] Element
   *
   * @decorator `@ChoiceDataTypesMeta('Population.age[x]', ['Range','CodeableConcept',]`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The age of the specific population
   * - **Definition:** The age of the specific population.
   * - **FHIR Types:**
   *     'Range',
   *     'CodeableConcept',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('Population.age[x]',[
    'Range',
    'CodeableConcept',
  ])
  private age?: IDataType | undefined;

  /**
   * Population.gender Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The gender of the specific population
   * - **Definition:** The gender of the specific population.
   * - **FHIR Type:** `CodeableConcept`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private gender?: CodeableConcept | undefined;

  /**
   * Population.race Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Race of the specific population
   * - **Definition:** Race of the specific population.
   * - **FHIR Type:** `CodeableConcept`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private race?: CodeableConcept | undefined;

  /**
   * Population.physiologicalCondition Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The existing physiological conditions of the specific population to which this applies
   * - **Definition:** The existing physiological conditions of the specific population to which this applies.
   * - **FHIR Type:** `CodeableConcept`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private physiologicalCondition?: CodeableConcept | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `age` property value as a DataType object if defined; else undefined
   */
  public getAge(): IDataType | undefined {
    return this.age;
  }

  /**
   * Assigns the provided DataType object value to the `age` property.
   *
   * @decorator `@ChoiceDataTypes('Population.age[x]')`
   *
   * @param value - the `age` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  @ChoiceDataTypes('Population.age[x]')
  public setAge(value: IDataType | undefined): this {
    if (isDefined<IDataType>(value)) {
      // assertFhirType<IDataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.age = value;
    } else {
      this.age = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `age` property exists and has a value; `false` otherwise
   */
  public hasAge(): boolean {
    return isDefined<IDataType>(this.age) && !this.age.isEmpty();
  }

  // *** NOTE ***
  // Following choice datatype-specific "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the `age` property value as a Range object if defined; else undefined
   */
  public getAgeRange(): Range | undefined {
    if (!isDefined<IDataType | undefined>(this.age)) {
      return undefined;
    }
    if (!(this.age instanceof Range)) {
      throw new InvalidTypeError(
        `DataType mismatch for Population.age[x]: Expected Range but encountered ${this.age.fhirType()}`,
      );
    }
    return this.age;
  }

  /**
   * @returns `true` if the `age` property exists as a Range and has a value; `false` otherwise
   */
  public hasAgeRange(): boolean {
    return this.hasAge() && this.age instanceof Range;
  }

  /**
   * @returns the `age` property value as a CodeableConcept object if defined; else undefined
   */
  public getAgeCodeableConcept(): CodeableConcept | undefined {
    if (!isDefined<IDataType | undefined>(this.age)) {
      return undefined;
    }
    if (!(this.age instanceof CodeableConcept)) {
      throw new InvalidTypeError(
        `DataType mismatch for Population.age[x]: Expected CodeableConcept but encountered ${this.age.fhirType()}`,
      );
    }
    return this.age;
  }

  /**
   * @returns `true` if the `age` property exists as a CodeableConcept and has a value; `false` otherwise
   */
  public hasAgeCodeableConcept(): boolean {
    return this.hasAge() && this.age instanceof CodeableConcept;
  }

  // End of choice datatype-specific "get"/"has" methods

  /**
   * @returns the `gender` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getGender(): CodeableConcept {
    return this.gender ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Gender object value to the `gender` property.
   *
   * @param value - the `gender` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setGender(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = `Invalid Population.gender; Provided element is not an instance of CodeableConcept.`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.gender = value;
    } else {
      this.gender = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `gender` property exists and has a value; `false` otherwise
   */
  public hasGender(): boolean {
    return isDefined<CodeableConcept>(this.gender) && !this.gender.isEmpty();
  }

  /**
   * @returns the `race` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getRace(): CodeableConcept {
    return this.race ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Race object value to the `race` property.
   *
   * @param value - the `race` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setRace(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = `Invalid Population.race; Provided element is not an instance of CodeableConcept.`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.race = value;
    } else {
      this.race = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `race` property exists and has a value; `false` otherwise
   */
  public hasRace(): boolean {
    return isDefined<CodeableConcept>(this.race) && !this.race.isEmpty();
  }

  /**
   * @returns the `physiologicalCondition` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getPhysiologicalCondition(): CodeableConcept {
    return this.physiologicalCondition ?? new CodeableConcept();
  }

  /**
   * Assigns the provided PhysiologicalCondition object value to the `physiologicalCondition` property.
   *
   * @param value - the `physiologicalCondition` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setPhysiologicalCondition(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = `Invalid Population.physiologicalCondition; Provided element is not an instance of CodeableConcept.`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.physiologicalCondition = value;
    } else {
      this.physiologicalCondition = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `physiologicalCondition` property exists and has a value; `false` otherwise
   */
  public hasPhysiologicalCondition(): boolean {
    return isDefined<CodeableConcept>(this.physiologicalCondition) && !this.physiologicalCondition.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Population';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.age,
      this.gender,
      this.race,
      this.physiologicalCondition,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Population {
    const dest = new Population();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Population): void {
    super.copyValues(dest);
    dest.age = this.age?.copy() as IDataType;
    dest.gender = this.gender?.copy();
    dest.race = this.race?.copy();
    dest.physiologicalCondition = this.physiologicalCondition?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasAge()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getAge()!, 'age', jsonObj);
    }

    if (this.hasGender()) {
      setFhirComplexJson(this.getGender(), 'gender', jsonObj);
    }

    if (this.hasRace()) {
      setFhirComplexJson(this.getRace(), 'race', jsonObj);
    }

    if (this.hasPhysiologicalCondition()) {
      setFhirComplexJson(this.getPhysiologicalCondition(), 'physiologicalCondition', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * ProdCharacteristic Class
 *
 * @remarks
 * Base StructureDefinition for ProdCharacteristic Type: The marketing status describes the date when a medicinal product is actually put on the market or the date as of which it is no longer available.
 *
 * **FHIR Specification**
 * - **Short:** The marketing status describes the date when a medicinal product is actually put on the market or the date as of which it is no longer available
 * - **Definition:** The marketing status describes the date when a medicinal product is actually put on the market or the date as of which it is no longer available.
 * - **FHIR Version:** 4.3.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR ProdCharacteristic](http://hl7.org/fhir/StructureDefinition/ProdCharacteristic)
 */
export class ProdCharacteristic extends BackboneType implements IBackboneType {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided `ProdCharacteristic` JSON to instantiate the ProdCharacteristic data model.
   *
   * @param sourceJson - JSON representing FHIR `ProdCharacteristic`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to ProdCharacteristic
   * @returns ProdCharacteristic data model or undefined for `ProdCharacteristic`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): ProdCharacteristic | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'ProdCharacteristic';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new ProdCharacteristic();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneTypeJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'height';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = Quantity.parse(classJsonObj[fieldName]!, sourceField);
      instance.setHeight(datatype);
    }

    fieldName = 'width';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = Quantity.parse(classJsonObj[fieldName]!, sourceField);
      instance.setWidth(datatype);
    }

    fieldName = 'depth';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = Quantity.parse(classJsonObj[fieldName]!, sourceField);
      instance.setDepth(datatype);
    }

    fieldName = 'weight';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = Quantity.parse(classJsonObj[fieldName]!, sourceField);
      instance.setWeight(datatype);
    }

    fieldName = 'nominalVolume';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = Quantity.parse(classJsonObj[fieldName]!, sourceField);
      instance.setNominalVolume(datatype);
    }

    fieldName = 'externalDiameter';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = Quantity.parse(classJsonObj[fieldName]!, sourceField);
      instance.setExternalDiameter(datatype);
    }

    fieldName = 'shape';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setShapeElement(datatype);
    }

    fieldName = 'color';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: StringType | undefined = fhirParser.parseStringType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addColorElement(datatype);
        }
      });
    }

    fieldName = 'imprint';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: StringType | undefined = fhirParser.parseStringType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addImprintElement(datatype);
        }
      });
    }

    fieldName = 'image';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Attachment | undefined = Attachment.parse(dataElementJson, `${sourceField}[${String(idx)}]`);
        if (datatype !== undefined) {
          instance.addImage(datatype);
        }
      });
    }

    fieldName = 'scoring';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = CodeableConcept.parse(classJsonObj[fieldName]!, sourceField);
      instance.setScoring(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * ProdCharacteristic.height Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Where applicable, the height can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used
   * - **Definition:** Where applicable, the height can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used.
   * - **FHIR Type:** `Quantity`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private height?: Quantity | undefined;

  /**
   * ProdCharacteristic.width Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Where applicable, the width can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used
   * - **Definition:** Where applicable, the width can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used.
   * - **FHIR Type:** `Quantity`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private width?: Quantity | undefined;

  /**
   * ProdCharacteristic.depth Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Where applicable, the depth can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used
   * - **Definition:** Where applicable, the depth can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used.
   * - **FHIR Type:** `Quantity`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private depth?: Quantity | undefined;

  /**
   * ProdCharacteristic.weight Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Where applicable, the weight can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used
   * - **Definition:** Where applicable, the weight can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used.
   * - **FHIR Type:** `Quantity`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private weight?: Quantity | undefined;

  /**
   * ProdCharacteristic.nominalVolume Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Where applicable, the nominal volume can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used
   * - **Definition:** Where applicable, the nominal volume can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used.
   * - **FHIR Type:** `Quantity`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private nominalVolume?: Quantity | undefined;

  /**
   * ProdCharacteristic.externalDiameter Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Where applicable, the external diameter can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used
   * - **Definition:** Where applicable, the external diameter can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used.
   * - **FHIR Type:** `Quantity`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private externalDiameter?: Quantity | undefined;

  /**
   * ProdCharacteristic.shape Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Where applicable, the shape can be specified An appropriate controlled vocabulary shall be used The term and the term identifier shall be used
   * - **Definition:** Where applicable, the shape can be specified An appropriate controlled vocabulary shall be used The term and the term identifier shall be used.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private shape?: StringType | undefined;

  /**
   * ProdCharacteristic.color Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Where applicable, the color can be specified An appropriate controlled vocabulary shall be used The term and the term identifier shall be used
   * - **Definition:** Where applicable, the color can be specified An appropriate controlled vocabulary shall be used The term and the term identifier shall be used.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private color?: StringType[] | undefined;

  /**
   * ProdCharacteristic.imprint Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Where applicable, the imprint can be specified as text
   * - **Definition:** Where applicable, the imprint can be specified as text.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private imprint?: StringType[] | undefined;

  /**
   * ProdCharacteristic.image Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Where applicable, the image can be provided The format of the image attachment shall be specified by regional implementations
   * - **Definition:** Where applicable, the image can be provided The format of the image attachment shall be specified by regional implementations.
   * - **FHIR Type:** `Attachment`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private image?: Attachment[] | undefined;

  /**
   * ProdCharacteristic.scoring Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Where applicable, the scoring can be specified An appropriate controlled vocabulary shall be used The term and the term identifier shall be used
   * - **Definition:** Where applicable, the scoring can be specified An appropriate controlled vocabulary shall be used The term and the term identifier shall be used.
   * - **FHIR Type:** `CodeableConcept`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private scoring?: CodeableConcept | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `height` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getHeight(): Quantity {
    return this.height ?? new Quantity();
  }

  /**
   * Assigns the provided Height object value to the `height` property.
   *
   * @param value - the `height` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setHeight(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = `Invalid ProdCharacteristic.height; Provided element is not an instance of Quantity.`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.height = value;
    } else {
      this.height = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `height` property exists and has a value; `false` otherwise
   */
  public hasHeight(): boolean {
    return isDefined<Quantity>(this.height) && !this.height.isEmpty();
  }

  /**
   * @returns the `width` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getWidth(): Quantity {
    return this.width ?? new Quantity();
  }

  /**
   * Assigns the provided Width object value to the `width` property.
   *
   * @param value - the `width` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setWidth(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = `Invalid ProdCharacteristic.width; Provided element is not an instance of Quantity.`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.width = value;
    } else {
      this.width = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `width` property exists and has a value; `false` otherwise
   */
  public hasWidth(): boolean {
    return isDefined<Quantity>(this.width) && !this.width.isEmpty();
  }

  /**
   * @returns the `depth` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getDepth(): Quantity {
    return this.depth ?? new Quantity();
  }

  /**
   * Assigns the provided Depth object value to the `depth` property.
   *
   * @param value - the `depth` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setDepth(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = `Invalid ProdCharacteristic.depth; Provided element is not an instance of Quantity.`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.depth = value;
    } else {
      this.depth = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `depth` property exists and has a value; `false` otherwise
   */
  public hasDepth(): boolean {
    return isDefined<Quantity>(this.depth) && !this.depth.isEmpty();
  }

  /**
   * @returns the `weight` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getWeight(): Quantity {
    return this.weight ?? new Quantity();
  }

  /**
   * Assigns the provided Weight object value to the `weight` property.
   *
   * @param value - the `weight` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setWeight(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = `Invalid ProdCharacteristic.weight; Provided element is not an instance of Quantity.`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.weight = value;
    } else {
      this.weight = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `weight` property exists and has a value; `false` otherwise
   */
  public hasWeight(): boolean {
    return isDefined<Quantity>(this.weight) && !this.weight.isEmpty();
  }

  /**
   * @returns the `nominalVolume` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getNominalVolume(): Quantity {
    return this.nominalVolume ?? new Quantity();
  }

  /**
   * Assigns the provided NominalVolume object value to the `nominalVolume` property.
   *
   * @param value - the `nominalVolume` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setNominalVolume(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = `Invalid ProdCharacteristic.nominalVolume; Provided element is not an instance of Quantity.`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.nominalVolume = value;
    } else {
      this.nominalVolume = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `nominalVolume` property exists and has a value; `false` otherwise
   */
  public hasNominalVolume(): boolean {
    return isDefined<Quantity>(this.nominalVolume) && !this.nominalVolume.isEmpty();
  }

  /**
   * @returns the `externalDiameter` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getExternalDiameter(): Quantity {
    return this.externalDiameter ?? new Quantity();
  }

  /**
   * Assigns the provided ExternalDiameter object value to the `externalDiameter` property.
   *
   * @param value - the `externalDiameter` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setExternalDiameter(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = `Invalid ProdCharacteristic.externalDiameter; Provided element is not an instance of Quantity.`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.externalDiameter = value;
    } else {
      this.externalDiameter = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `externalDiameter` property exists and has a value; `false` otherwise
   */
  public hasExternalDiameter(): boolean {
    return isDefined<Quantity>(this.externalDiameter) && !this.externalDiameter.isEmpty();
  }

  /**
   * @returns the `shape` property value as a StringType object if defined; else an empty StringType object
   */
  public getShapeElement(): StringType {
    return this.shape ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `shape` property.
   *
   * @param element - the `shape` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setShapeElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid ProdCharacteristic.shape; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.shape = element;
    } else {
      this.shape = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `shape` property exists and has a value; `false` otherwise
   */
  public hasShapeElement(): boolean {
    return isDefined<StringType>(this.shape) && !this.shape.isEmpty();
  }

  /**
   * @returns the `shape` property value as a fhirString if defined; else undefined
   */
  public getShape(): fhirString | undefined {
    return this.shape?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `shape` property.
   *
   * @param value - the `shape` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setShape(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid ProdCharacteristic.shape (${String(value)})`;
      this.shape = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.shape = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `shape` property exists and has a value; `false` otherwise
   */
  public hasShape(): boolean {
    return this.hasShapeElement();
  }

  /**
   * @returns the `color` property value as a StringType array
   */
  public getColorElement(): StringType[] {
    return this.color ?? ([] as StringType[]);
  }

  /**
   * Assigns the provided StringType array value to the `color` property.
   *
   * @param element - the `color` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setColorElement(element: StringType[] | undefined): this {
    if (isDefinedList<StringType>(element)) {
      const optErrMsg = `Invalid ProdCharacteristic.color; Provided value array has an element that is not an instance of StringType.`;
      assertFhirTypeList<StringType>(element, StringType, optErrMsg);
      this.color = element;
    } else {
      this.color = undefined;
    }
    return this;
  }

  /**
   * Add the provided StringType value to the `color` array property.
   *
   * @param element - the `color` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addColorElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid ProdCharacteristic.color; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.initColor();
      this.color?.push(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `color` property exists and has a value; `false` otherwise
   */
  public hasColorElement(): boolean {
    return isDefinedList<StringType>(this.color) && this.color.some((item: StringType) => !item.isEmpty());
  }

  /**
   * @returns the `color` property value as a fhirString array
   */
  public getColor(): fhirString[] {
    this.initColor();
    const colorValues = [] as fhirString[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.color!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        colorValues.push(value);
      }
    }
    return colorValues;
  }

  /**
   * Assigns the provided primitive value array to the `color` property.
   *
   * @param value - the `color` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setColor(value: fhirString[] | undefined): this {
    if (isDefinedList<fhirString>(value)) {
      const colorElements = [] as StringType[];
      for (const colorValue of value) {
        const optErrMsg = `Invalid ProdCharacteristic.color array item (${String(colorValue)})`;
        const element = new StringType(parseFhirPrimitiveData(colorValue, fhirStringSchema, optErrMsg));
        colorElements.push(element);
      }
      this.color = colorElements;
    } else {
      this.color = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the `color` array property.
   *
   * @param value - the `color` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addColor(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid ProdCharacteristic.color array item (${String(value)})`;
      const element = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
      this.initColor();
      this.addColorElement(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `color` property exists and has a value; `false` otherwise
   */
  public hasColor(): boolean {
    return this.hasColorElement();
  }

  /**
   * Initialize the `color` property
   */
  private initColor(): void {
    if (!this.hasColor()) {
      this.color = [] as StringType[];
    }
  }

  /**
   * @returns the `imprint` property value as a StringType array
   */
  public getImprintElement(): StringType[] {
    return this.imprint ?? ([] as StringType[]);
  }

  /**
   * Assigns the provided StringType array value to the `imprint` property.
   *
   * @param element - the `imprint` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setImprintElement(element: StringType[] | undefined): this {
    if (isDefinedList<StringType>(element)) {
      const optErrMsg = `Invalid ProdCharacteristic.imprint; Provided value array has an element that is not an instance of StringType.`;
      assertFhirTypeList<StringType>(element, StringType, optErrMsg);
      this.imprint = element;
    } else {
      this.imprint = undefined;
    }
    return this;
  }

  /**
   * Add the provided StringType value to the `imprint` array property.
   *
   * @param element - the `imprint` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addImprintElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid ProdCharacteristic.imprint; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.initImprint();
      this.imprint?.push(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `imprint` property exists and has a value; `false` otherwise
   */
  public hasImprintElement(): boolean {
    return isDefinedList<StringType>(this.imprint) && this.imprint.some((item: StringType) => !item.isEmpty());
  }

  /**
   * @returns the `imprint` property value as a fhirString array
   */
  public getImprint(): fhirString[] {
    this.initImprint();
    const imprintValues = [] as fhirString[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.imprint!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        imprintValues.push(value);
      }
    }
    return imprintValues;
  }

  /**
   * Assigns the provided primitive value array to the `imprint` property.
   *
   * @param value - the `imprint` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setImprint(value: fhirString[] | undefined): this {
    if (isDefinedList<fhirString>(value)) {
      const imprintElements = [] as StringType[];
      for (const imprintValue of value) {
        const optErrMsg = `Invalid ProdCharacteristic.imprint array item (${String(imprintValue)})`;
        const element = new StringType(parseFhirPrimitiveData(imprintValue, fhirStringSchema, optErrMsg));
        imprintElements.push(element);
      }
      this.imprint = imprintElements;
    } else {
      this.imprint = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the `imprint` array property.
   *
   * @param value - the `imprint` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addImprint(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid ProdCharacteristic.imprint array item (${String(value)})`;
      const element = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
      this.initImprint();
      this.addImprintElement(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `imprint` property exists and has a value; `false` otherwise
   */
  public hasImprint(): boolean {
    return this.hasImprintElement();
  }

  /**
   * Initialize the `imprint` property
   */
  private initImprint(): void {
    if (!this.hasImprint()) {
      this.imprint = [] as StringType[];
    }
  }

  /**
   * @returns the `image` property value as a Attachment array
   */
  public getImage(): Attachment[] {
    return this.image ?? ([] as Attachment[]);
  }

  /**
   * Assigns the provided Attachment array value to the `image` property.
   *
   * @param value - the `image` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setImage(value: Attachment[] | undefined): this {
    if (isDefinedList<Attachment>(value)) {
      const optErrMsg = `Invalid ProdCharacteristic.image; Provided value array has an element that is not an instance of Attachment.`;
      assertFhirTypeList<Attachment>(value, Attachment, optErrMsg);
      this.image = value;
    } else {
      this.image = undefined;
    }
    return this;
  }

  /**
   * Add the provided Attachment value to the `image` array property.
   *
   * @param value - the `image` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addImage(value: Attachment | undefined): this {
    if (isDefined<Attachment>(value)) {
      const optErrMsg = `Invalid ProdCharacteristic.image; Provided element is not an instance of Attachment.`;
      assertFhirType<Attachment>(value, Attachment, optErrMsg);
      this.initImage();
      this.image?.push(value);
    }
    return this;
  }

  /**
   * @returns `true` if the `image` property exists and has a value; `false` otherwise
   */
  public hasImage(): boolean {
    return isDefinedList<Attachment>(this.image) && this.image.some((item: Attachment) => !item.isEmpty());
  }

  /**
   * Initialize the `image` property
   */
  private initImage(): void {
    if(!this.hasImage()) {
      this.image = [] as Attachment[];
    }
  }

  /**
   * @returns the `scoring` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getScoring(): CodeableConcept {
    return this.scoring ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Scoring object value to the `scoring` property.
   *
   * @param value - the `scoring` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setScoring(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = `Invalid ProdCharacteristic.scoring; Provided element is not an instance of CodeableConcept.`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.scoring = value;
    } else {
      this.scoring = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `scoring` property exists and has a value; `false` otherwise
   */
  public hasScoring(): boolean {
    return isDefined<CodeableConcept>(this.scoring) && !this.scoring.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'ProdCharacteristic';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.height,
      this.width,
      this.depth,
      this.weight,
      this.nominalVolume,
      this.externalDiameter,
      this.shape,
      this.color,
      this.imprint,
      this.image,
      this.scoring,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): ProdCharacteristic {
    const dest = new ProdCharacteristic();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: ProdCharacteristic): void {
    super.copyValues(dest);
    dest.height = this.height?.copy();
    dest.width = this.width?.copy();
    dest.depth = this.depth?.copy();
    dest.weight = this.weight?.copy();
    dest.nominalVolume = this.nominalVolume?.copy();
    dest.externalDiameter = this.externalDiameter?.copy();
    dest.shape = this.shape?.copy();
    const colorList = copyListValues<StringType>(this.color);
    dest.color = colorList.length === 0 ? undefined : colorList;
    const imprintList = copyListValues<StringType>(this.imprint);
    dest.imprint = imprintList.length === 0 ? undefined : imprintList;
    const imageList = copyListValues<Attachment>(this.image);
    dest.image = imageList.length === 0 ? undefined : imageList;
    dest.scoring = this.scoring?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasHeight()) {
      setFhirComplexJson(this.getHeight(), 'height', jsonObj);
    }

    if (this.hasWidth()) {
      setFhirComplexJson(this.getWidth(), 'width', jsonObj);
    }

    if (this.hasDepth()) {
      setFhirComplexJson(this.getDepth(), 'depth', jsonObj);
    }

    if (this.hasWeight()) {
      setFhirComplexJson(this.getWeight(), 'weight', jsonObj);
    }

    if (this.hasNominalVolume()) {
      setFhirComplexJson(this.getNominalVolume(), 'nominalVolume', jsonObj);
    }

    if (this.hasExternalDiameter()) {
      setFhirComplexJson(this.getExternalDiameter(), 'externalDiameter', jsonObj);
    }

    if (this.hasShapeElement()) {
      setFhirPrimitiveJson<fhirString>(this.getShapeElement(), 'shape', jsonObj);
    }

    if (this.hasColor()) {
      setFhirPrimitiveListJson(this.getColorElement(), 'color', jsonObj);
    }

    if (this.hasImprint()) {
      setFhirPrimitiveListJson(this.getImprintElement(), 'imprint', jsonObj);
    }

    if (this.hasImage()) {
      setFhirComplexListJson(this.getImage(), 'image', jsonObj);
    }

    if (this.hasScoring()) {
      setFhirComplexJson(this.getScoring(), 'scoring', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * ProductShelfLife Class
 *
 * @remarks
 * Base StructureDefinition for ProductShelfLife Type: The shelf-life and storage information for a medicinal product item or container can be described using this class.
 *
 * **FHIR Specification**
 * - **Short:** The shelf-life and storage information for a medicinal product item or container can be described using this class
 * - **Definition:** The shelf-life and storage information for a medicinal product item or container can be described using this class.
 * - **FHIR Version:** 4.3.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR ProductShelfLife](http://hl7.org/fhir/StructureDefinition/ProductShelfLife)
 */
export class ProductShelfLife extends BackboneType implements IBackboneType {
  constructor(type_: CodeableConcept | null = null, period: Quantity | null = null) {
    super();

    this.type_ = null;
    if (isDefined<CodeableConcept>(type_)) {
      this.setType(type_);
    }

    this.period = null;
    if (isDefined<Quantity>(period)) {
      this.setPeriod(period);
    }
  }

  /**
   * Parse the provided `ProductShelfLife` JSON to instantiate the ProductShelfLife data model.
   *
   * @param sourceJson - JSON representing FHIR `ProductShelfLife`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to ProductShelfLife
   * @returns ProductShelfLife data model or undefined for `ProductShelfLife`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): ProductShelfLife | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'ProductShelfLife';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new ProductShelfLife();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneTypeJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';

    const missingReqdProperties: string[] = [];

    fieldName = 'identifier';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Identifier | undefined = Identifier.parse(classJsonObj[fieldName]!, sourceField);
      instance.setIdentifier(datatype);
    }

    fieldName = 'type';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = CodeableConcept.parse(classJsonObj[fieldName]!, sourceField);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setType(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'period';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = Quantity.parse(classJsonObj[fieldName]!, sourceField);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setPeriod(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'specialPrecautionsForStorage';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: CodeableConcept | undefined = CodeableConcept.parse(dataElementJson, `${sourceField}[${String(idx)}]`);
        if (datatype !== undefined) {
          instance.addSpecialPrecautionsForStorage(datatype);
        }
      });
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_REQD_IN_JSON} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * ProductShelfLife.identifier Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Unique identifier for the packaged Medicinal Product
   * - **Definition:** Unique identifier for the packaged Medicinal Product.
   * - **FHIR Type:** `Identifier`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private identifier?: Identifier | undefined;

  /**
   * ProductShelfLife.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** This describes the shelf life, taking into account various scenarios such as shelf life of the packaged Medicinal Product itself, shelf life after transformation where necessary and shelf life after the first opening of a bottle, etc. The shelf life type shall be specified using an appropriate controlled vocabulary The controlled term and the controlled term identifier shall be specified
   * - **Definition:** This describes the shelf life, taking into account various scenarios such as shelf life of the packaged Medicinal Product itself, shelf life after transformation where necessary and shelf life after the first opening of a bottle, etc. The shelf life type shall be specified using an appropriate controlled vocabulary The controlled term and the controlled term identifier shall be specified.
   * - **FHIR Type:** `CodeableConcept`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private type_: CodeableConcept | null;

  /**
   * ProductShelfLife.period Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The shelf life time period can be specified using a numerical value for the period of time and its unit of time measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used
   * - **Definition:** The shelf life time period can be specified using a numerical value for the period of time and its unit of time measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used.
   * - **FHIR Type:** `Quantity`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private period: Quantity | null;

  /**
   * ProductShelfLife.specialPrecautionsForStorage Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Special precautions for storage, if any, can be specified using an appropriate controlled vocabulary The controlled term and the controlled term identifier shall be specified
   * - **Definition:** Special precautions for storage, if any, can be specified using an appropriate controlled vocabulary The controlled term and the controlled term identifier shall be specified.
   * - **FHIR Type:** `CodeableConcept`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private specialPrecautionsForStorage?: CodeableConcept[] | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `identifier` property value as a Identifier object if defined; else an empty Identifier object
   */
  public getIdentifier(): Identifier {
    return this.identifier ?? new Identifier();
  }

  /**
   * Assigns the provided Identifier object value to the `identifier` property.
   *
   * @param value - the `identifier` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setIdentifier(value: Identifier | undefined): this {
    if (isDefined<Identifier>(value)) {
      const optErrMsg = `Invalid ProductShelfLife.identifier; Provided element is not an instance of Identifier.`;
      assertFhirType<Identifier>(value, Identifier, optErrMsg);
      this.identifier = value;
    } else {
      this.identifier = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `identifier` property exists and has a value; `false` otherwise
   */
  public hasIdentifier(): boolean {
    return isDefined<Identifier>(this.identifier) && !this.identifier.isEmpty();
  }

  /**
   * @returns the `type_` property value as a CodeableConcept object if defined; else null
   */
  public getType(): CodeableConcept | null {
    return this.type_;
  }

  /**
   * Assigns the provided CodeableConcept object value to the `type_` property.
   *
   * @param value - the `type_` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setType(value: CodeableConcept): this {
    assertIsDefined<CodeableConcept>(value, `ProductShelfLife.type is required`);
    const optErrMsg = `Invalid ProductShelfLife.type; Provided element is not an instance of CodeableConcept.`;
    assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
    this.type_ = value;
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasType(): boolean {
    return isDefined<CodeableConcept>(this.type_) && !this.type_.isEmpty();
  }

  /**
   * @returns the `period` property value as a Quantity object if defined; else null
   */
  public getPeriod(): Quantity | null {
    return this.period;
  }

  /**
   * Assigns the provided Quantity object value to the `period` property.
   *
   * @param value - the `period` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setPeriod(value: Quantity): this {
    assertIsDefined<Quantity>(value, `ProductShelfLife.period is required`);
    const optErrMsg = `Invalid ProductShelfLife.period; Provided element is not an instance of Quantity.`;
    assertFhirType<Quantity>(value, Quantity, optErrMsg);
    this.period = value;
    return this;
  }

  /**
   * @returns `true` if the `period` property exists and has a value; `false` otherwise
   */
  public hasPeriod(): boolean {
    return isDefined<Quantity>(this.period) && !this.period.isEmpty();
  }

  /**
   * @returns the `specialPrecautionsForStorage` property value as a CodeableConcept array
   */
  public getSpecialPrecautionsForStorage(): CodeableConcept[] {
    return this.specialPrecautionsForStorage ?? ([] as CodeableConcept[]);
  }

  /**
   * Assigns the provided CodeableConcept array value to the `specialPrecautionsForStorage` property.
   *
   * @param value - the `specialPrecautionsForStorage` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setSpecialPrecautionsForStorage(value: CodeableConcept[] | undefined): this {
    if (isDefinedList<CodeableConcept>(value)) {
      const optErrMsg = `Invalid ProductShelfLife.specialPrecautionsForStorage; Provided value array has an element that is not an instance of CodeableConcept.`;
      assertFhirTypeList<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.specialPrecautionsForStorage = value;
    } else {
      this.specialPrecautionsForStorage = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeableConcept value to the `specialPrecautionsForStorage` array property.
   *
   * @param value - the `specialPrecautionsForStorage` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addSpecialPrecautionsForStorage(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = `Invalid ProductShelfLife.specialPrecautionsForStorage; Provided element is not an instance of CodeableConcept.`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.initSpecialPrecautionsForStorage();
      this.specialPrecautionsForStorage?.push(value);
    }
    return this;
  }

  /**
   * @returns `true` if the `specialPrecautionsForStorage` property exists and has a value; `false` otherwise
   */
  public hasSpecialPrecautionsForStorage(): boolean {
    return isDefinedList<CodeableConcept>(this.specialPrecautionsForStorage) && this.specialPrecautionsForStorage.some((item: CodeableConcept) => !item.isEmpty());
  }

  /**
   * Initialize the `specialPrecautionsForStorage` property
   */
  private initSpecialPrecautionsForStorage(): void {
    if(!this.hasSpecialPrecautionsForStorage()) {
      this.specialPrecautionsForStorage = [] as CodeableConcept[];
    }
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'ProductShelfLife';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.identifier,
      this.type_,
      this.period,
      this.specialPrecautionsForStorage,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): ProductShelfLife {
    const dest = new ProductShelfLife();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: ProductShelfLife): void {
    super.copyValues(dest);
    dest.identifier = this.identifier?.copy();
    dest.type_ = this.type_ ? this.type_.copy() : null;
    dest.period = this.period ? this.period.copy() : null;
    const specialPrecautionsForStorageList = copyListValues<CodeableConcept>(this.specialPrecautionsForStorage);
    dest.specialPrecautionsForStorage = specialPrecautionsForStorageList.length === 0 ? undefined : specialPrecautionsForStorageList;
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasIdentifier()) {
      setFhirComplexJson(this.getIdentifier(), 'identifier', jsonObj);
    }

    if (this.hasType()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirComplexJson(this.getType()!, 'type', jsonObj);
    } else {
      missingReqdProperties.push(`ProductShelfLife.type`);
    }

    if (this.hasPeriod()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirComplexJson(this.getPeriod()!, 'period', jsonObj);
    } else {
      missingReqdProperties.push(`ProductShelfLife.period`);
    }

    if (this.hasSpecialPrecautionsForStorage()) {
      setFhirComplexListJson(this.getSpecialPrecautionsForStorage(), 'specialPrecautionsForStorage', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_DO_NOT_EXIST} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

/**
 * Quantity Class
 *
 * @remarks
 * Base StructureDefinition for Quantity Type: A measured amount (or an amount that can potentially be measured). Note that measured amounts include amounts that are not precisely quantified, including amounts involving arbitrary units and floating currencies.
 *
 * Need to able to capture all sorts of measured values, even if the measured value are not precisely quantified. Values include exact measures such as 3.51g, customary units such as 3 tablets, and currencies such as $100.32USD.
 *
 * **FHIR Specification**
 * - **Short:** A measured or measurable amount
 * - **Definition:** A measured amount (or an amount that can potentially be measured). Note that measured amounts include amounts that are not precisely quantified, including amounts involving arbitrary units and floating currencies.
 * - **Comment:** The context of use may frequently define what kind of quantity this is and therefore what kind of units can be used. The context of use may also restrict the values for the comparator.
 * - **FHIR Version:** 4.3.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR Quantity](http://hl7.org/fhir/StructureDefinition/Quantity)
 */
export class Quantity extends DataType implements IDataType {
  constructor() {
    super();

    this.quantityComparatorEnum = new QuantityComparatorEnum();
  }

  /**
   * Parse the provided `Quantity` JSON to instantiate the Quantity data model.
   *
   * @param sourceJson - JSON representing FHIR `Quantity`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to Quantity
   * @returns Quantity data model or undefined for `Quantity`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Quantity | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Quantity';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new Quantity();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    fieldName = 'value';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setValueElement(datatype);
    }

    fieldName = 'comparator';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setComparatorElement(datatype);
    }

    fieldName = 'unit';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setUnitElement(datatype);
    }

    fieldName = 'system';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UriType | undefined = fhirParser.parseUriType(dtJson, dtSiblingJson);
      instance.setSystemElement(datatype);
    }

    fieldName = 'code';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setCodeElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Quantity.value Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Numerical value (with implicit precision)
   * - **Definition:** The value of the measured amount. The value includes an implicit precision in the presentation of the value.
   * - **Comment:** The implicit precision in the value should always be honored. Monetary values have their own rules for handling precision (refer to standard accounting text books).
   * - **Requirements:** Precision is handled implicitly in almost all cases of measurement.
   * - **FHIR Type:** `decimal`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private value?: DecimalType | undefined;

  /**
   * FHIR CodeSystem: QuantityComparator
   *
   * @see {@link QuantityComparatorEnum }
   */
  private readonly quantityComparatorEnum: QuantityComparatorEnum;

  /**
   * Quantity.comparator Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** < | <= | >= | > - how to understand the value
   * - **Definition:** How the value should be understood and represented - whether the actual value is greater or less than the stated value due to measurement issues; e.g. if the comparator is "<" , then the real value is < stated value.
   * - **Requirements:** Need a framework for handling measures where the value is <5ug/L or >400mg/L due to the limitations of measuring methodology.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** true
   * - **isModifierReason:** This is labeled as &quot;Is Modifier&quot; because the comparator modifies the interpretation of the value significantly. If there is no comparator, then there is no modification of the value
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  private comparator?: EnumCodeType | undefined;

  /**
   * Quantity.unit Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Unit representation
   * - **Definition:** A human-readable form of the unit.
   * - **Requirements:** There are many representations for units of measure and in many contexts, particular representations are fixed and required. I.e. mcg for micrograms.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private unit?: StringType | undefined;

  /**
   * Quantity.system Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** System that defines coded unit form
   * - **Definition:** The identification of the system that provides the coded form of the unit.
   * - **Requirements:** Need to know the system that defines the coded form of the unit.
   * - **FHIR Type:** `uri`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private system?: UriType | undefined;

  /**
   * Quantity.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Coded form of the unit
   * - **Definition:** A computer processable form of the unit in some unit representation system.
   * - **Comment:** The preferred system is UCUM, but SNOMED CT can also be used (for customary units) or ISO 4217 for currency.  The context of use may additionally require a code from a particular system.
   * - **Requirements:** Need a computable form of the unit that is fixed across all forms. UCUM provides this for quantities, but SNOMED CT provides many units of interest.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code?: CodeType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `value` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getValueElement(): DecimalType {
    return this.value ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `value` property.
   *
   * @param element - the `value` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValueElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = `Invalid Quantity.value; Provided element is not an instance of DecimalType.`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.value = element;
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `value` property exists and has a value; `false` otherwise
   */
  public hasValueElement(): boolean {
    return isDefined<DecimalType>(this.value) && !this.value.isEmpty();
  }

  /**
   * @returns the `value` property value as a fhirDecimal if defined; else undefined
   */
  public getValue(): fhirDecimal | undefined {
    return this.value?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `value` property.
   *
   * @param value - the `value` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setValue(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = `Invalid Quantity.value (${String(value)})`;
      this.value = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.value = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `value` property exists and has a value; `false` otherwise
   */
  public hasValue(): boolean {
    return this.hasValueElement();
  }

  /**
   * @returns the `comparator` property value as a EnumCodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public getComparatorEnumType(): EnumCodeType | undefined {
    return this.comparator;
  }

  /**
   * Assigns the provided EnumCodeType value to the `comparator` property.
   *
   * @param enumType - the `comparator` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code values
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public setComparatorEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = 'Invalid Quantity.comparator';
      assertEnumCodeType<QuantityComparatorEnum>(enumType, QuantityComparatorEnum, errMsgPrefix);
      this.comparator = enumType;
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `comparator` property exists and has a value; `false` otherwise
   */
  public hasComparatorEnumType(): boolean {
    return isDefined<EnumCodeType>(this.comparator) && !this.comparator.isEmpty() && this.comparator.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the `comparator` property value as a CodeType if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public getComparatorElement(): CodeType | undefined {
    if (this.comparator === undefined) {
      return undefined;
    }
    return this.comparator as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the `comparator` property.
   *
   * @param element - the `comparator` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public setComparatorElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid Quantity.comparator; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.comparator = new EnumCodeType(element, this.quantityComparatorEnum);
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `comparator` property exists and has a value; `false` otherwise
   */
  public hasComparatorElement(): boolean {
    return this.hasComparatorEnumType();
  }

  /**
   * @returns the `comparator` property value as a fhirCode if defined; else undefined
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public getComparator(): fhirCode | undefined {
    if (this.comparator === undefined) {
      return undefined;
    }
    return this.comparator.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the `comparator` property.
   *
   * @param value - the `comparator` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link QuantityComparatorEnum }
   */
  public setComparator(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid Quantity.comparator; Provided value is not an instance of fhirCode.`;
      this.comparator = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.quantityComparatorEnum);
    } else {
      this.comparator = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `comparator` property exists and has a value; `false` otherwise
   */
  public hasComparator(): boolean {
    return this.hasComparatorEnumType();
  }

  /**
   * @returns the `unit` property value as a StringType object if defined; else an empty StringType object
   */
  public getUnitElement(): StringType {
    return this.unit ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `unit` property.
   *
   * @param element - the `unit` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUnitElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid Quantity.unit; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.unit = element;
    } else {
      this.unit = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `unit` property exists and has a value; `false` otherwise
   */
  public hasUnitElement(): boolean {
    return isDefined<StringType>(this.unit) && !this.unit.isEmpty();
  }

  /**
   * @returns the `unit` property value as a fhirString if defined; else undefined
   */
  public getUnit(): fhirString | undefined {
    return this.unit?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `unit` property.
   *
   * @param value - the `unit` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUnit(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid Quantity.unit (${String(value)})`;
      this.unit = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.unit = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `unit` property exists and has a value; `false` otherwise
   */
  public hasUnit(): boolean {
    return this.hasUnitElement();
  }

  /**
   * @returns the `system` property value as a UriType object if defined; else an empty UriType object
   */
  public getSystemElement(): UriType {
    return this.system ?? new UriType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `system` property.
   *
   * @param element - the `system` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSystemElement(element: UriType | undefined): this {
    if (isDefined<UriType>(element)) {
      const optErrMsg = `Invalid Quantity.system; Provided element is not an instance of UriType.`;
      assertFhirType<UriType>(element, UriType, optErrMsg);
      this.system = element;
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `system` property exists and has a value; `false` otherwise
   */
  public hasSystemElement(): boolean {
    return isDefined<UriType>(this.system) && !this.system.isEmpty();
  }

  /**
   * @returns the `system` property value as a fhirUri if defined; else undefined
   */
  public getSystem(): fhirUri | undefined {
    return this.system?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `system` property.
   *
   * @param value - the `system` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSystem(value: fhirUri | undefined): this {
    if (isDefined<fhirUri>(value)) {
      const optErrMsg = `Invalid Quantity.system (${String(value)})`;
      this.system = new UriType(parseFhirPrimitiveData(value, fhirUriSchema, optErrMsg));
    } else {
      this.system = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `system` property exists and has a value; `false` otherwise
   */
  public hasSystem(): boolean {
    return this.hasSystemElement();
  }

  /**
   * @returns the `code` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getCodeElement(): CodeType {
    return this.code ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `code` property.
   *
   * @param element - the `code` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCodeElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid Quantity.code; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.code = element;
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `code` property exists and has a value; `false` otherwise
   */
  public hasCodeElement(): boolean {
    return isDefined<CodeType>(this.code) && !this.code.isEmpty();
  }

  /**
   * @returns the `code` property value as a fhirCode if defined; else undefined
   */
  public getCode(): fhirCode | undefined {
    return this.code?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `code` property.
   *
   * @param value - the `code` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCode(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid Quantity.code (${String(value)})`;
      this.code = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `code` property exists and has a value; `false` otherwise
   */
  public hasCode(): boolean {
    return this.hasCodeElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Quantity';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.value,
      this.comparator,
      this.unit,
      this.system,
      this.code,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Quantity {
    const dest = new Quantity();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Quantity): void {
    super.copyValues(dest);
    dest.value = this.value?.copy();
    dest.comparator = this.comparator?.copy();
    dest.unit = this.unit?.copy();
    dest.system = this.system?.copy();
    dest.code = this.code?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasValueElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getValueElement(), 'value', jsonObj);
    }

    if (this.hasComparatorElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getComparatorElement()!, 'comparator', jsonObj);
    }

    if (this.hasUnitElement()) {
      setFhirPrimitiveJson<fhirString>(this.getUnitElement(), 'unit', jsonObj);
    }

    if (this.hasSystemElement()) {
      setFhirPrimitiveJson<fhirUri>(this.getSystemElement(), 'system', jsonObj);
    }

    if (this.hasCodeElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getCodeElement(), 'code', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * Range Class
 *
 * @remarks
 * Base StructureDefinition for Range Type: A set of ordered Quantities defined by a low and high limit.
 *
 * Need to be able to specify ranges of values.
 *
 * **FHIR Specification**
 * - **Short:** Set of values bounded by low and high
 * - **Definition:** A set of ordered Quantities defined by a low and high limit.
 * - **Comment:** The stated low and high value are assumed to have arbitrarily high precision when it comes to determining which values are in the range. I.e. 1.99 is not in the range 2 -> 3.
 * - **FHIR Version:** 4.3.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR Range](http://hl7.org/fhir/StructureDefinition/Range)
 */
export class Range extends DataType implements IDataType {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided `Range` JSON to instantiate the Range data model.
   *
   * @param sourceJson - JSON representing FHIR `Range`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to Range
   * @returns Range data model or undefined for `Range`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Range | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Range';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new Range();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';

    fieldName = 'low';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = Quantity.parse(classJsonObj[fieldName]!, sourceField);
      instance.setLow(datatype);
    }

    fieldName = 'high';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = Quantity.parse(classJsonObj[fieldName]!, sourceField);
      instance.setHigh(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Range.low Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Low limit
   * - **Definition:** The low limit. The boundary is inclusive.
   * - **Comment:** If the low element is missing, the low boundary is not known.
   * - **FHIR Type:** `Quantity`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private low?: Quantity | undefined;

  /**
   * Range.high Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** High limit
   * - **Definition:** The high limit. The boundary is inclusive.
   * - **Comment:** If the high element is missing, the high boundary is not known.
   * - **FHIR Type:** `Quantity`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private high?: Quantity | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `low` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getLow(): Quantity {
    return this.low ?? new Quantity();
  }

  /**
   * Assigns the provided Low object value to the `low` property.
   *
   * @param value - the `low` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setLow(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = `Invalid Range.low; Provided element is not an instance of Quantity.`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.low = value;
    } else {
      this.low = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `low` property exists and has a value; `false` otherwise
   */
  public hasLow(): boolean {
    return isDefined<Quantity>(this.low) && !this.low.isEmpty();
  }

  /**
   * @returns the `high` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getHigh(): Quantity {
    return this.high ?? new Quantity();
  }

  /**
   * Assigns the provided High object value to the `high` property.
   *
   * @param value - the `high` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setHigh(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = `Invalid Range.high; Provided element is not an instance of Quantity.`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.high = value;
    } else {
      this.high = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `high` property exists and has a value; `false` otherwise
   */
  public hasHigh(): boolean {
    return isDefined<Quantity>(this.high) && !this.high.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Range';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.low,
      this.high,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Range {
    const dest = new Range();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Range): void {
    super.copyValues(dest);
    dest.low = this.low?.copy();
    dest.high = this.high?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasLow()) {
      setFhirComplexJson(this.getLow(), 'low', jsonObj);
    }

    if (this.hasHigh()) {
      setFhirComplexJson(this.getHigh(), 'high', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * Ratio Class
 *
 * @remarks
 * Base StructureDefinition for Ratio Type: A relationship of two Quantity values - expressed as a numerator and a denominator.
 *
 * Need to able to capture ratios for some measurements (titers) and some rates (costs).
 *
 * **FHIR Specification**
 * - **Short:** A ratio of two Quantity values - a numerator and a denominator
 * - **Definition:** A relationship of two Quantity values - expressed as a numerator and a denominator.
 * - **Comment:** The Ratio datatype should only be used to express a relationship of two numbers if the relationship cannot be suitably expressed using a Quantity and a common unit.  Where the denominator value is known to be fixed to "1", Quantity should be used instead of Ratio.
 * - **FHIR Version:** 4.3.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR Ratio](http://hl7.org/fhir/StructureDefinition/Ratio)
 */
export class Ratio extends DataType implements IDataType {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided `Ratio` JSON to instantiate the Ratio data model.
   *
   * @param sourceJson - JSON representing FHIR `Ratio`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to Ratio
   * @returns Ratio data model or undefined for `Ratio`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Ratio | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Ratio';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new Ratio();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';

    fieldName = 'numerator';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = Quantity.parse(classJsonObj[fieldName]!, sourceField);
      instance.setNumerator(datatype);
    }

    fieldName = 'denominator';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = Quantity.parse(classJsonObj[fieldName]!, sourceField);
      instance.setDenominator(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Ratio.numerator Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Numerator value
   * - **Definition:** The value of the numerator.
   * - **FHIR Type:** `Quantity`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private numerator?: Quantity | undefined;

  /**
   * Ratio.denominator Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Denominator value
   * - **Definition:** The value of the denominator.
   * - **FHIR Type:** `Quantity`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private denominator?: Quantity | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `numerator` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getNumerator(): Quantity {
    return this.numerator ?? new Quantity();
  }

  /**
   * Assigns the provided Numerator object value to the `numerator` property.
   *
   * @param value - the `numerator` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setNumerator(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = `Invalid Ratio.numerator; Provided element is not an instance of Quantity.`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.numerator = value;
    } else {
      this.numerator = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `numerator` property exists and has a value; `false` otherwise
   */
  public hasNumerator(): boolean {
    return isDefined<Quantity>(this.numerator) && !this.numerator.isEmpty();
  }

  /**
   * @returns the `denominator` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getDenominator(): Quantity {
    return this.denominator ?? new Quantity();
  }

  /**
   * Assigns the provided Denominator object value to the `denominator` property.
   *
   * @param value - the `denominator` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setDenominator(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = `Invalid Ratio.denominator; Provided element is not an instance of Quantity.`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.denominator = value;
    } else {
      this.denominator = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `denominator` property exists and has a value; `false` otherwise
   */
  public hasDenominator(): boolean {
    return isDefined<Quantity>(this.denominator) && !this.denominator.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Ratio';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.numerator,
      this.denominator,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Ratio {
    const dest = new Ratio();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Ratio): void {
    super.copyValues(dest);
    dest.numerator = this.numerator?.copy();
    dest.denominator = this.denominator?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasNumerator()) {
      setFhirComplexJson(this.getNumerator(), 'numerator', jsonObj);
    }

    if (this.hasDenominator()) {
      setFhirComplexJson(this.getDenominator(), 'denominator', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * RatioRange Class
 *
 * @remarks
 * Base StructureDefinition for RatioRange Type: A range of ratios expressed as a low and high numerator and a denominator.
 *
 * Need to be able to specify ranges of ratios.
 *
 * **FHIR Specification**
 * - **Short:** Range of ratio values
 * - **Definition:** A range of ratios expressed as a low and high numerator and a denominator.
 * - **Comment:** The stated low and high value are assumed to have arbitrarily high precision when it comes to determining which values are in the range. I.e. 1.99 is not in the range 2 -> 3.
 * - **FHIR Version:** 4.3.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR RatioRange](http://hl7.org/fhir/StructureDefinition/RatioRange)
 */
export class RatioRange extends DataType implements IDataType {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided `RatioRange` JSON to instantiate the RatioRange data model.
   *
   * @param sourceJson - JSON representing FHIR `RatioRange`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to RatioRange
   * @returns RatioRange data model or undefined for `RatioRange`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): RatioRange | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'RatioRange';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new RatioRange();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';

    fieldName = 'lowNumerator';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = Quantity.parse(classJsonObj[fieldName]!, sourceField);
      instance.setLowNumerator(datatype);
    }

    fieldName = 'highNumerator';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = Quantity.parse(classJsonObj[fieldName]!, sourceField);
      instance.setHighNumerator(datatype);
    }

    fieldName = 'denominator';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = Quantity.parse(classJsonObj[fieldName]!, sourceField);
      instance.setDenominator(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * RatioRange.lowNumerator Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Low Numerator limit
   * - **Definition:** The value of the low limit numerator.
   * - **Comment:** If the low element is missing, the low boundary is not known.
   * - **FHIR Type:** `Quantity`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private lowNumerator?: Quantity | undefined;

  /**
   * RatioRange.highNumerator Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** High Numerator limit
   * - **Definition:** The value of the high limit numerator.
   * - **Comment:** If the high element is missing, the high boundary is not known.
   * - **FHIR Type:** `Quantity`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private highNumerator?: Quantity | undefined;

  /**
   * RatioRange.denominator Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Denominator value
   * - **Definition:** The value of the denominator.
   * - **FHIR Type:** `Quantity`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private denominator?: Quantity | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `lowNumerator` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getLowNumerator(): Quantity {
    return this.lowNumerator ?? new Quantity();
  }

  /**
   * Assigns the provided LowNumerator object value to the `lowNumerator` property.
   *
   * @param value - the `lowNumerator` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setLowNumerator(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = `Invalid RatioRange.lowNumerator; Provided element is not an instance of Quantity.`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.lowNumerator = value;
    } else {
      this.lowNumerator = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `lowNumerator` property exists and has a value; `false` otherwise
   */
  public hasLowNumerator(): boolean {
    return isDefined<Quantity>(this.lowNumerator) && !this.lowNumerator.isEmpty();
  }

  /**
   * @returns the `highNumerator` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getHighNumerator(): Quantity {
    return this.highNumerator ?? new Quantity();
  }

  /**
   * Assigns the provided HighNumerator object value to the `highNumerator` property.
   *
   * @param value - the `highNumerator` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setHighNumerator(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = `Invalid RatioRange.highNumerator; Provided element is not an instance of Quantity.`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.highNumerator = value;
    } else {
      this.highNumerator = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `highNumerator` property exists and has a value; `false` otherwise
   */
  public hasHighNumerator(): boolean {
    return isDefined<Quantity>(this.highNumerator) && !this.highNumerator.isEmpty();
  }

  /**
   * @returns the `denominator` property value as a Quantity object if defined; else an empty Quantity object
   */
  public getDenominator(): Quantity {
    return this.denominator ?? new Quantity();
  }

  /**
   * Assigns the provided Denominator object value to the `denominator` property.
   *
   * @param value - the `denominator` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setDenominator(value: Quantity | undefined): this {
    if (isDefined<Quantity>(value)) {
      const optErrMsg = `Invalid RatioRange.denominator; Provided element is not an instance of Quantity.`;
      assertFhirType<Quantity>(value, Quantity, optErrMsg);
      this.denominator = value;
    } else {
      this.denominator = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `denominator` property exists and has a value; `false` otherwise
   */
  public hasDenominator(): boolean {
    return isDefined<Quantity>(this.denominator) && !this.denominator.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'RatioRange';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.lowNumerator,
      this.highNumerator,
      this.denominator,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): RatioRange {
    const dest = new RatioRange();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: RatioRange): void {
    super.copyValues(dest);
    dest.lowNumerator = this.lowNumerator?.copy();
    dest.highNumerator = this.highNumerator?.copy();
    dest.denominator = this.denominator?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasLowNumerator()) {
      setFhirComplexJson(this.getLowNumerator(), 'lowNumerator', jsonObj);
    }

    if (this.hasHighNumerator()) {
      setFhirComplexJson(this.getHighNumerator(), 'highNumerator', jsonObj);
    }

    if (this.hasDenominator()) {
      setFhirComplexJson(this.getDenominator(), 'denominator', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * RelatedArtifact Class
 *
 * @remarks
 * Base StructureDefinition for RelatedArtifact Type: Related artifacts such as additional documentation, justification, or bibliographic references.
 *
 * Knowledge resources must be able to provide enough information for consumers of the content (and/or interventions or results produced by the content) to be able to determine and understand the justification for and evidence in support of the content.
 *
 * **FHIR Specification**
 * - **Short:** Related artifacts for a knowledge resource
 * - **Definition:** Related artifacts such as additional documentation, justification, or bibliographic references.
 * - **Comment:** Each related artifact is either an attachment, or a reference to another knowledge resource, but not both.
 * - **FHIR Version:** 4.3.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR RelatedArtifact](http://hl7.org/fhir/StructureDefinition/RelatedArtifact)
 */
export class RelatedArtifact extends DataType implements IDataType {
  constructor(type_: EnumCodeType | CodeType | fhirCode | null = null) {
    super();

    this.relatedArtifactTypeEnum = new RelatedArtifactTypeEnum();

    this.type_ = constructorCodeValueAsEnumCodeType<RelatedArtifactTypeEnum>(
      type_,
      RelatedArtifactTypeEnum,
      this.relatedArtifactTypeEnum,
      'RelatedArtifact.type',
    );
  }

  /**
   * Parse the provided `RelatedArtifact` JSON to instantiate the RelatedArtifact data model.
   *
   * @param sourceJson - JSON representing FHIR `RelatedArtifact`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to RelatedArtifact
   * @returns RelatedArtifact data model or undefined for `RelatedArtifact`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): RelatedArtifact | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'RelatedArtifact';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new RelatedArtifact();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'type';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setTypeElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'label';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setLabelElement(datatype);
    }

    fieldName = 'display';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setDisplayElement(datatype);
    }

    fieldName = 'citation';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: MarkdownType | undefined = fhirParser.parseMarkdownType(dtJson, dtSiblingJson);
      instance.setCitationElement(datatype);
    }

    fieldName = 'url';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UrlType | undefined = fhirParser.parseUrlType(dtJson, dtSiblingJson);
      instance.setUrlElement(datatype);
    }

    fieldName = 'document';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Attachment | undefined = Attachment.parse(classJsonObj[fieldName]!, sourceField);
      instance.setDocument(datatype);
    }

    fieldName = 'resource';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CanonicalType | undefined = fhirParser.parseCanonicalType(dtJson, dtSiblingJson);
      instance.setResourceElement(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_REQD_IN_JSON} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: RelatedArtifactType
   *
   * @see {@link RelatedArtifactTypeEnum }
   */
  private readonly relatedArtifactTypeEnum: RelatedArtifactTypeEnum;

  /**
   * RelatedArtifact.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** documentation | justification | citation | predecessor | successor | derived-from | depends-on | composed-of
   * - **Definition:** The type of relationship to the related artifact.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link RelatedArtifactTypeEnum }
   */
  private type_: EnumCodeType | null;

  /**
   * RelatedArtifact.label Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Short label
   * - **Definition:** A short label that can be used to reference the citation from elsewhere in the containing artifact, such as a footnote index.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private label?: StringType | undefined;

  /**
   * RelatedArtifact.display Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Brief description of the related artifact
   * - **Definition:** A brief description of the document or knowledge resource being referenced, suitable for display to a consumer.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private display?: StringType | undefined;

  /**
   * RelatedArtifact.citation Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Bibliographic citation for the artifact
   * - **Definition:** A bibliographic citation for the related artifact. This text SHOULD be formatted according to an accepted citation format.
   * - **Comment:** Additional structured information about citations should be captured as extensions.
   * - **FHIR Type:** `markdown`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private citation?: MarkdownType | undefined;

  /**
   * RelatedArtifact.url Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Where the artifact can be accessed
   * - **Definition:** A url for the artifact that can be followed to access the actual content.
   * - **Comment:** If a document or resource element is present, this element SHALL NOT be provided (use the url or reference in the Attachment or resource reference).
   * - **FHIR Type:** `url`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private url?: UrlType | undefined;

  /**
   * RelatedArtifact.document Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** What document is being referenced
   * - **Definition:** The document being referenced, represented as an attachment. This is exclusive with the resource element.
   * - **FHIR Type:** `Attachment`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private document?: Attachment | undefined;

  /**
   * RelatedArtifact.resource Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** What resource is being referenced
   * - **Definition:** The related resource, such as a library, value set, profile, or other knowledge resource.
   * - **Comment:** If the type is predecessor, this is a reference to the succeeding knowledge resource. If the type is successor, this is a reference to the prior knowledge resource.
   * - **FHIR Type:** `canonical`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Resource',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private resource?: CanonicalType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `type_` property value as a EnumCodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link RelatedArtifactTypeEnum }
   */
  public getTypeEnumType(): EnumCodeType | null {
    return this.type_;
  }

  /**
   * Assigns the provided EnumCodeType value to the `type_` property.
   *
   * @param enumType - the `type_` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link RelatedArtifactTypeEnum }
   */
  public setTypeEnumType(enumType: EnumCodeType): this {
    assertIsDefined<EnumCodeType>(enumType, `RelatedArtifact.type is required`);
    const errMsgPrefix = `Invalid RelatedArtifact.type`;
    assertEnumCodeType<RelatedArtifactTypeEnum>(enumType, RelatedArtifactTypeEnum, errMsgPrefix);
    this.type_ = enumType;
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasTypeEnumType(): boolean {
    return isDefined<EnumCodeType>(this.type_) && !this.type_.isEmpty() && this.type_.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the `type_` property value as a CodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link RelatedArtifactTypeEnum }
   */
  public getTypeElement(): CodeType | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_ as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the `type_` property.
   *
   * @param element - the `type_` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link RelatedArtifactTypeEnum }
   */
  public setTypeElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, `RelatedArtifact.type is required`);
    const optErrMsg = `Invalid RelatedArtifact.type; Provided value is not an instance of CodeType.`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.type_ = new EnumCodeType(element, this.relatedArtifactTypeEnum);
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasTypeElement(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the `type_` property value as a fhirCode if defined; else null
   *
   * @see CodeSystem Enumeration: {@link RelatedArtifactTypeEnum }
   */
  public getType(): fhirCode | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the `type_` property.
   *
   * @param value - the `type_` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link RelatedArtifactTypeEnum }
   */
  public setType(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, `RelatedArtifact.type is required`);
    const optErrMsg = `Invalid RelatedArtifact.type (${String(value)})`;
    this.type_ = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.relatedArtifactTypeEnum);
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasType(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the `label` property value as a StringType object if defined; else an empty StringType object
   */
  public getLabelElement(): StringType {
    return this.label ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `label` property.
   *
   * @param element - the `label` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLabelElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid RelatedArtifact.label; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.label = element;
    } else {
      this.label = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `label` property exists and has a value; `false` otherwise
   */
  public hasLabelElement(): boolean {
    return isDefined<StringType>(this.label) && !this.label.isEmpty();
  }

  /**
   * @returns the `label` property value as a fhirString if defined; else undefined
   */
  public getLabel(): fhirString | undefined {
    return this.label?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `label` property.
   *
   * @param value - the `label` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLabel(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid RelatedArtifact.label (${String(value)})`;
      this.label = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.label = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `label` property exists and has a value; `false` otherwise
   */
  public hasLabel(): boolean {
    return this.hasLabelElement();
  }

  /**
   * @returns the `display` property value as a StringType object if defined; else an empty StringType object
   */
  public getDisplayElement(): StringType {
    return this.display ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `display` property.
   *
   * @param element - the `display` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDisplayElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid RelatedArtifact.display; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.display = element;
    } else {
      this.display = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `display` property exists and has a value; `false` otherwise
   */
  public hasDisplayElement(): boolean {
    return isDefined<StringType>(this.display) && !this.display.isEmpty();
  }

  /**
   * @returns the `display` property value as a fhirString if defined; else undefined
   */
  public getDisplay(): fhirString | undefined {
    return this.display?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `display` property.
   *
   * @param value - the `display` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDisplay(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid RelatedArtifact.display (${String(value)})`;
      this.display = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.display = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `display` property exists and has a value; `false` otherwise
   */
  public hasDisplay(): boolean {
    return this.hasDisplayElement();
  }

  /**
   * @returns the `citation` property value as a MarkdownType object if defined; else an empty MarkdownType object
   */
  public getCitationElement(): MarkdownType {
    return this.citation ?? new MarkdownType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `citation` property.
   *
   * @param element - the `citation` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCitationElement(element: MarkdownType | undefined): this {
    if (isDefined<MarkdownType>(element)) {
      const optErrMsg = `Invalid RelatedArtifact.citation; Provided element is not an instance of MarkdownType.`;
      assertFhirType<MarkdownType>(element, MarkdownType, optErrMsg);
      this.citation = element;
    } else {
      this.citation = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `citation` property exists and has a value; `false` otherwise
   */
  public hasCitationElement(): boolean {
    return isDefined<MarkdownType>(this.citation) && !this.citation.isEmpty();
  }

  /**
   * @returns the `citation` property value as a fhirMarkdown if defined; else undefined
   */
  public getCitation(): fhirMarkdown | undefined {
    return this.citation?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `citation` property.
   *
   * @param value - the `citation` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCitation(value: fhirMarkdown | undefined): this {
    if (isDefined<fhirMarkdown>(value)) {
      const optErrMsg = `Invalid RelatedArtifact.citation (${String(value)})`;
      this.citation = new MarkdownType(parseFhirPrimitiveData(value, fhirMarkdownSchema, optErrMsg));
    } else {
      this.citation = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `citation` property exists and has a value; `false` otherwise
   */
  public hasCitation(): boolean {
    return this.hasCitationElement();
  }

  /**
   * @returns the `url` property value as a UrlType object if defined; else an empty UrlType object
   */
  public getUrlElement(): UrlType {
    return this.url ?? new UrlType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `url` property.
   *
   * @param element - the `url` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUrlElement(element: UrlType | undefined): this {
    if (isDefined<UrlType>(element)) {
      const optErrMsg = `Invalid RelatedArtifact.url; Provided element is not an instance of UrlType.`;
      assertFhirType<UrlType>(element, UrlType, optErrMsg);
      this.url = element;
    } else {
      this.url = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `url` property exists and has a value; `false` otherwise
   */
  public hasUrlElement(): boolean {
    return isDefined<UrlType>(this.url) && !this.url.isEmpty();
  }

  /**
   * @returns the `url` property value as a fhirUrl if defined; else undefined
   */
  public getUrl(): fhirUrl | undefined {
    return this.url?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `url` property.
   *
   * @param value - the `url` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUrl(value: fhirUrl | undefined): this {
    if (isDefined<fhirUrl>(value)) {
      const optErrMsg = `Invalid RelatedArtifact.url (${String(value)})`;
      this.url = new UrlType(parseFhirPrimitiveData(value, fhirUrlSchema, optErrMsg));
    } else {
      this.url = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `url` property exists and has a value; `false` otherwise
   */
  public hasUrl(): boolean {
    return this.hasUrlElement();
  }

  /**
   * @returns the `document` property value as a Attachment object if defined; else an empty Attachment object
   */
  public getDocument(): Attachment {
    return this.document ?? new Attachment();
  }

  /**
   * Assigns the provided Document object value to the `document` property.
   *
   * @param value - the `document` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setDocument(value: Attachment | undefined): this {
    if (isDefined<Attachment>(value)) {
      const optErrMsg = `Invalid RelatedArtifact.document; Provided element is not an instance of Attachment.`;
      assertFhirType<Attachment>(value, Attachment, optErrMsg);
      this.document = value;
    } else {
      this.document = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `document` property exists and has a value; `false` otherwise
   */
  public hasDocument(): boolean {
    return isDefined<Attachment>(this.document) && !this.document.isEmpty();
  }

  /**
   * @returns the `resource` property value as a CanonicalType object if defined; else an empty CanonicalType object
   */
  public getResourceElement(): CanonicalType {
    return this.resource ?? new CanonicalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `resource` property.
   *
   * @param element - the `resource` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setResourceElement(element: CanonicalType | undefined): this {
    if (isDefined<CanonicalType>(element)) {
      const optErrMsg = `Invalid RelatedArtifact.resource; Provided element is not an instance of CanonicalType.`;
      assertFhirType<CanonicalType>(element, CanonicalType, optErrMsg);
      this.resource = element;
    } else {
      this.resource = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `resource` property exists and has a value; `false` otherwise
   */
  public hasResourceElement(): boolean {
    return isDefined<CanonicalType>(this.resource) && !this.resource.isEmpty();
  }

  /**
   * @returns the `resource` property value as a fhirCanonical if defined; else undefined
   */
  public getResource(): fhirCanonical | undefined {
    return this.resource?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `resource` property.
   *
   * @param value - the `resource` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setResource(value: fhirCanonical | undefined): this {
    if (isDefined<fhirCanonical>(value)) {
      const optErrMsg = `Invalid RelatedArtifact.resource (${String(value)})`;
      this.resource = new CanonicalType(parseFhirPrimitiveData(value, fhirCanonicalSchema, optErrMsg));
    } else {
      this.resource = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `resource` property exists and has a value; `false` otherwise
   */
  public hasResource(): boolean {
    return this.hasResourceElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'RelatedArtifact';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.type_,
      this.label,
      this.display,
      this.citation,
      this.url,
      this.document,
      this.resource,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): RelatedArtifact {
    const dest = new RelatedArtifact();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: RelatedArtifact): void {
    super.copyValues(dest);
    dest.type_ = this.type_ ? this.type_.copy() : null;
    dest.label = this.label?.copy();
    dest.display = this.display?.copy();
    dest.citation = this.citation?.copy();
    dest.url = this.url?.copy();
    dest.document = this.document?.copy();
    dest.resource = this.resource?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasTypeElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getTypeElement()!, 'type', jsonObj);
    } else {
      missingReqdProperties.push(`RelatedArtifact.type`);
    }

    if (this.hasLabelElement()) {
      setFhirPrimitiveJson<fhirString>(this.getLabelElement(), 'label', jsonObj);
    }

    if (this.hasDisplayElement()) {
      setFhirPrimitiveJson<fhirString>(this.getDisplayElement(), 'display', jsonObj);
    }

    if (this.hasCitationElement()) {
      setFhirPrimitiveJson<fhirMarkdown>(this.getCitationElement(), 'citation', jsonObj);
    }

    if (this.hasUrlElement()) {
      setFhirPrimitiveJson<fhirUrl>(this.getUrlElement(), 'url', jsonObj);
    }

    if (this.hasDocument()) {
      setFhirComplexJson(this.getDocument(), 'document', jsonObj);
    }

    if (this.hasResourceElement()) {
      setFhirPrimitiveJson<fhirCanonical>(this.getResourceElement(), 'resource', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_DO_NOT_EXIST} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

/**
 * SampledData Class
 *
 * @remarks
 * Base StructureDefinition for SampledData Type: A series of measurements taken by a device, with upper and lower limits. There may be more than one dimension in the data.
 *
 * There is a need for a concise way to handle the data produced by devices that sample a physical state at a high frequency.
 *
 * **FHIR Specification**
 * - **Short:** A series of measurements taken by a device
 * - **Definition:** A series of measurements taken by a device, with upper and lower limits. There may be more than one dimension in the data.
 * - **Comment:** The data is not interpretable without at least origin, period, and dimensions, but these are optional to allow a separation between the template of measurement and the actual measurement, such as between DeviceCapabilities and DeviceLog.  When providing a summary view (for example with Observation.value[x]) SampledData should be represented with a brief display text such as "Sampled Data".
 * - **FHIR Version:** 4.3.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR SampledData](http://hl7.org/fhir/StructureDefinition/SampledData)
 */
export class SampledData extends DataType implements IDataType {
  constructor(origin: Quantity | null = null, period: DecimalType | fhirDecimal | null = null, dimensions: PositiveIntType | fhirPositiveInt | null = null) {
    super();

    this.origin = null;
    if (isDefined<Quantity>(origin)) {
      this.setOrigin(origin);
    }

    this.period = null;
    if (isDefined<DecimalType | fhirDecimal>(period)) {
      if (period instanceof PrimitiveType) {
        this.setPeriodElement(period);
      } else {
        this.setPeriod(period);
      }
    }

    this.dimensions = null;
    if (isDefined<PositiveIntType | fhirPositiveInt>(dimensions)) {
      if (dimensions instanceof PrimitiveType) {
        this.setDimensionsElement(dimensions);
      } else {
        this.setDimensions(dimensions);
      }
    }
  }

  /**
   * Parse the provided `SampledData` JSON to instantiate the SampledData data model.
   *
   * @param sourceJson - JSON representing FHIR `SampledData`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to SampledData
   * @returns SampledData data model or undefined for `SampledData`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): SampledData | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'SampledData';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new SampledData();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'origin';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Quantity | undefined = Quantity.parse(classJsonObj[fieldName]!, sourceField);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setOrigin(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'period';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setPeriodElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'factor';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setFactorElement(datatype);
    }

    fieldName = 'lowerLimit';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setLowerLimitElement(datatype);
    }

    fieldName = 'upperLimit';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setUpperLimitElement(datatype);
    }

    fieldName = 'dimensions';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = fhirParser.parsePositiveIntType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setDimensionsElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'data';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setDataElement(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_REQD_IN_JSON} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * SampledData.origin Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Zero value and units
   * - **Definition:** The base quantity that a measured value of zero represents. In addition, this provides the units of the entire measurement series.
   * - **FHIR Type:** `Quantity`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private origin: Quantity | null;

  /**
   * SampledData.period Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Number of milliseconds between samples
   * - **Definition:** The length of time between sampling times, measured in milliseconds.
   * - **Comment:** This is usually a whole number.
   * - **FHIR Type:** `decimal`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private period: DecimalType | null;

  /**
   * SampledData.factor Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Multiply data by this before adding to origin
   * - **Definition:** A correction factor that is applied to the sampled data points before they are added to the origin.
   * - **FHIR Type:** `decimal`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private factor?: DecimalType | undefined;

  /**
   * SampledData.lowerLimit Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Lower limit of detection
   * - **Definition:** The lower limit of detection of the measured points. This is needed if any of the data points have the value "L" (lower than detection limit).
   * - **FHIR Type:** `decimal`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private lowerLimit?: DecimalType | undefined;

  /**
   * SampledData.upperLimit Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Upper limit of detection
   * - **Definition:** The upper limit of detection of the measured points. This is needed if any of the data points have the value "U" (higher than detection limit).
   * - **FHIR Type:** `decimal`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private upperLimit?: DecimalType | undefined;

  /**
   * SampledData.dimensions Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Number of sample points at each time point
   * - **Definition:** The number of sample points at each time point. If this value is greater than one, then the dimensions will be interlaced - all the sample points for a point in time will be recorded at once.
   * - **Comment:** If there is more than one dimension, the code for the type of data will define the meaning of the dimensions (typically ECG data).
   * - **FHIR Type:** `positiveInt`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private dimensions: PositiveIntType | null;

  /**
   * SampledData.data Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Decimal values with spaces, or "E" | "U" | "L"
   * - **Definition:** A series of data points which are decimal values separated by a single space (character u20). The special values "E" (error), "L" (below detection limit) and "U" (above detection limit) can also be used in place of a decimal value.
   * - **Comment:** Data may be missing if it is omitted for summarization purposes. In general, data is required for any actual use of a SampledData.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private data?: StringType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `origin` property value as a Quantity object if defined; else null
   */
  public getOrigin(): Quantity | null {
    return this.origin;
  }

  /**
   * Assigns the provided Quantity object value to the `origin` property.
   *
   * @param value - the `origin` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setOrigin(value: Quantity): this {
    assertIsDefined<Quantity>(value, `SampledData.origin is required`);
    const optErrMsg = `Invalid SampledData.origin; Provided element is not an instance of Quantity.`;
    assertFhirType<Quantity>(value, Quantity, optErrMsg);
    this.origin = value;
    return this;
  }

  /**
   * @returns `true` if the `origin` property exists and has a value; `false` otherwise
   */
  public hasOrigin(): boolean {
    return isDefined<Quantity>(this.origin) && !this.origin.isEmpty();
  }

  /**
   * @returns the `period` property value as a DecimalType object if defined; else null
   */
  public getPeriodElement(): DecimalType | null {
    return this.period;
  }

  /**
   * Assigns the provided PrimitiveType value to the `period` property.
   *
   * @param element - the `period` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPeriodElement(element: DecimalType): this {
    assertIsDefined<DecimalType>(element, `SampledData.period is required`);
    const optErrMsg = `Invalid SampledData.period; Provided value is not an instance of DecimalType.`;
    assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
    this.period = element;
    return this;
  }

  /**
   * @returns `true` if the `period` property exists and has a value; `false` otherwise
   */
  public hasPeriodElement(): boolean {
    return isDefined<DecimalType>(this.period) && !this.period.isEmpty();
  }

  /**
   * @returns the `period` property value as a fhirDecimal if defined; else null
   */
  public getPeriod(): fhirDecimal | null {
    if (this.period?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.period.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the `period` property.
   *
   * @param value - the `period` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPeriod(value: fhirDecimal): this {
    assertIsDefined<fhirDecimal>(value, `SampledData.period is required`);
    const optErrMsg = `Invalid SampledData.period (${String(value)})`;
    this.period = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    return this;
  }

  /**
   * @returns `true` if the `period` property exists and has a value; `false` otherwise
   */
  public hasPeriod(): boolean {
    return this.hasPeriodElement();
  }

  /**
   * @returns the `factor` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getFactorElement(): DecimalType {
    return this.factor ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `factor` property.
   *
   * @param element - the `factor` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setFactorElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = `Invalid SampledData.factor; Provided element is not an instance of DecimalType.`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.factor = element;
    } else {
      this.factor = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `factor` property exists and has a value; `false` otherwise
   */
  public hasFactorElement(): boolean {
    return isDefined<DecimalType>(this.factor) && !this.factor.isEmpty();
  }

  /**
   * @returns the `factor` property value as a fhirDecimal if defined; else undefined
   */
  public getFactor(): fhirDecimal | undefined {
    return this.factor?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `factor` property.
   *
   * @param value - the `factor` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setFactor(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = `Invalid SampledData.factor (${String(value)})`;
      this.factor = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.factor = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `factor` property exists and has a value; `false` otherwise
   */
  public hasFactor(): boolean {
    return this.hasFactorElement();
  }

  /**
   * @returns the `lowerLimit` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getLowerLimitElement(): DecimalType {
    return this.lowerLimit ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `lowerLimit` property.
   *
   * @param element - the `lowerLimit` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLowerLimitElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = `Invalid SampledData.lowerLimit; Provided element is not an instance of DecimalType.`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.lowerLimit = element;
    } else {
      this.lowerLimit = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `lowerLimit` property exists and has a value; `false` otherwise
   */
  public hasLowerLimitElement(): boolean {
    return isDefined<DecimalType>(this.lowerLimit) && !this.lowerLimit.isEmpty();
  }

  /**
   * @returns the `lowerLimit` property value as a fhirDecimal if defined; else undefined
   */
  public getLowerLimit(): fhirDecimal | undefined {
    return this.lowerLimit?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `lowerLimit` property.
   *
   * @param value - the `lowerLimit` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setLowerLimit(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = `Invalid SampledData.lowerLimit (${String(value)})`;
      this.lowerLimit = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.lowerLimit = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `lowerLimit` property exists and has a value; `false` otherwise
   */
  public hasLowerLimit(): boolean {
    return this.hasLowerLimitElement();
  }

  /**
   * @returns the `upperLimit` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getUpperLimitElement(): DecimalType {
    return this.upperLimit ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `upperLimit` property.
   *
   * @param element - the `upperLimit` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUpperLimitElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = `Invalid SampledData.upperLimit; Provided element is not an instance of DecimalType.`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.upperLimit = element;
    } else {
      this.upperLimit = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `upperLimit` property exists and has a value; `false` otherwise
   */
  public hasUpperLimitElement(): boolean {
    return isDefined<DecimalType>(this.upperLimit) && !this.upperLimit.isEmpty();
  }

  /**
   * @returns the `upperLimit` property value as a fhirDecimal if defined; else undefined
   */
  public getUpperLimit(): fhirDecimal | undefined {
    return this.upperLimit?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `upperLimit` property.
   *
   * @param value - the `upperLimit` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setUpperLimit(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = `Invalid SampledData.upperLimit (${String(value)})`;
      this.upperLimit = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.upperLimit = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `upperLimit` property exists and has a value; `false` otherwise
   */
  public hasUpperLimit(): boolean {
    return this.hasUpperLimitElement();
  }

  /**
   * @returns the `dimensions` property value as a PositiveIntType object if defined; else null
   */
  public getDimensionsElement(): PositiveIntType | null {
    return this.dimensions;
  }

  /**
   * Assigns the provided PrimitiveType value to the `dimensions` property.
   *
   * @param element - the `dimensions` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDimensionsElement(element: PositiveIntType): this {
    assertIsDefined<PositiveIntType>(element, `SampledData.dimensions is required`);
    const optErrMsg = `Invalid SampledData.dimensions; Provided value is not an instance of PositiveIntType.`;
    assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
    this.dimensions = element;
    return this;
  }

  /**
   * @returns `true` if the `dimensions` property exists and has a value; `false` otherwise
   */
  public hasDimensionsElement(): boolean {
    return isDefined<PositiveIntType>(this.dimensions) && !this.dimensions.isEmpty();
  }

  /**
   * @returns the `dimensions` property value as a fhirPositiveInt if defined; else null
   */
  public getDimensions(): fhirPositiveInt | null {
    if (this.dimensions?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.dimensions.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the `dimensions` property.
   *
   * @param value - the `dimensions` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDimensions(value: fhirPositiveInt): this {
    assertIsDefined<fhirPositiveInt>(value, `SampledData.dimensions is required`);
    const optErrMsg = `Invalid SampledData.dimensions (${String(value)})`;
    this.dimensions = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    return this;
  }

  /**
   * @returns `true` if the `dimensions` property exists and has a value; `false` otherwise
   */
  public hasDimensions(): boolean {
    return this.hasDimensionsElement();
  }

  /**
   * @returns the `data` property value as a StringType object if defined; else an empty StringType object
   */
  public getDataElement(): StringType {
    return this.data ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `data` property.
   *
   * @param element - the `data` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDataElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid SampledData.data; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.data = element;
    } else {
      this.data = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `data` property exists and has a value; `false` otherwise
   */
  public hasDataElement(): boolean {
    return isDefined<StringType>(this.data) && !this.data.isEmpty();
  }

  /**
   * @returns the `data` property value as a fhirString if defined; else undefined
   */
  public getData(): fhirString | undefined {
    return this.data?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `data` property.
   *
   * @param value - the `data` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setData(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid SampledData.data (${String(value)})`;
      this.data = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.data = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `data` property exists and has a value; `false` otherwise
   */
  public hasData(): boolean {
    return this.hasDataElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'SampledData';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.origin,
      this.period,
      this.factor,
      this.lowerLimit,
      this.upperLimit,
      this.dimensions,
      this.data,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): SampledData {
    const dest = new SampledData();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: SampledData): void {
    super.copyValues(dest);
    dest.origin = this.origin ? this.origin.copy() : null;
    dest.period = this.period ? this.period.copy() : null;
    dest.factor = this.factor?.copy();
    dest.lowerLimit = this.lowerLimit?.copy();
    dest.upperLimit = this.upperLimit?.copy();
    dest.dimensions = this.dimensions ? this.dimensions.copy() : null;
    dest.data = this.data?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasOrigin()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirComplexJson(this.getOrigin()!, 'origin', jsonObj);
    } else {
      missingReqdProperties.push(`SampledData.origin`);
    }

    if (this.hasPeriodElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirDecimal>(this.getPeriodElement()!, 'period', jsonObj);
    } else {
      missingReqdProperties.push(`SampledData.period`);
    }

    if (this.hasFactorElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getFactorElement(), 'factor', jsonObj);
    }

    if (this.hasLowerLimitElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getLowerLimitElement(), 'lowerLimit', jsonObj);
    }

    if (this.hasUpperLimitElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getUpperLimitElement(), 'upperLimit', jsonObj);
    }

    if (this.hasDimensionsElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirPositiveInt>(this.getDimensionsElement()!, 'dimensions', jsonObj);
    } else {
      missingReqdProperties.push(`SampledData.dimensions`);
    }

    if (this.hasDataElement()) {
      setFhirPrimitiveJson<fhirString>(this.getDataElement(), 'data', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_DO_NOT_EXIST} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

/**
 * Signature Class
 *
 * @remarks
 * Base StructureDefinition for Signature Type: A signature along with supporting context. The signature may be a digital signature that is cryptographic in nature, or some other signature acceptable to the domain. This other signature may be as simple as a graphical image representing a hand-written signature, or a signature ceremony Different signature approaches have different utilities.
 *
 * There are a number of places where content must be signed in healthcare.
 *
 * **FHIR Specification**
 * - **Short:** A Signature - XML DigSig, JWS, Graphical image of signature, etc.
 * - **Definition:** A signature along with supporting context. The signature may be a digital signature that is cryptographic in nature, or some other signature acceptable to the domain. This other signature may be as simple as a graphical image representing a hand-written signature, or a signature ceremony Different signature approaches have different utilities.
 * - **Comment:** The elements of the Signature Resource are for ease of access of these elements. For digital signatures (Xml DigSig, JWS), the non-repudiation proof comes from the Signature  validation, which includes validation of the referenced objects (e.g. Resources) (a.k.a., Content) in the XML-Signature Detached form.
 * - **FHIR Version:** 4.3.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR Signature](http://hl7.org/fhir/StructureDefinition/Signature)
 */
export class Signature extends DataType implements IDataType {
  constructor(type_: Coding[] | null = null, when: InstantType | fhirInstant | null = null, who: Reference | null = null) {
    super();

    this.type_ = null;
    if (isDefinedList<Coding>(type_)) {
      this.setType(type_);
    }

    this.when = null;
    if (isDefined<InstantType | fhirInstant>(when)) {
      if (when instanceof PrimitiveType) {
        this.setWhenElement(when);
      } else {
        this.setWhen(when);
      }
    }

    this.who = null;
    if (isDefined<Reference>(who)) {
      this.setWho(who);
    }
  }

  /**
   * Parse the provided `Signature` JSON to instantiate the Signature data model.
   *
   * @param sourceJson - JSON representing FHIR `Signature`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to Signature
   * @returns Signature data model or undefined for `Signature`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Signature | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Signature';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new Signature();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const missingReqdProperties: string[] = [];

    fieldName = 'type';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: Coding | undefined = Coding.parse(dataElementJson, `${sourceField}[${String(idx)}]`);
        if (datatype === undefined) {
          missingReqdProperties.push(`${sourceField}[${String(idx)}]`);
        } else {
          instance.addType(datatype);
        }
      });
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'when';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: InstantType | undefined = fhirParser.parseInstantType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setWhenElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'who';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = Reference.parse(classJsonObj[fieldName]!, sourceField);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setWho(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'onBehalfOf';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Reference | undefined = Reference.parse(classJsonObj[fieldName]!, sourceField);
      instance.setOnBehalfOf(datatype);
    }

    fieldName = 'targetFormat';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setTargetFormatElement(datatype);
    }

    fieldName = 'sigFormat';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setSigFormatElement(datatype);
    }

    fieldName = 'data';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: Base64BinaryType | undefined = fhirParser.parseBase64BinaryType(dtJson, dtSiblingJson);
      instance.setDataElement(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_REQD_IN_JSON} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Signature.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Indication of the reason the entity signed the object(s)
   * - **Definition:** An indication of the reason that the entity signed this document. This may be explicitly included as part of the signature information and can be used when determining accountability for various actions concerning the document.
   * - **Comment:** Examples include attesting to: authorship, correct transcription, and witness of specific event. Also known as a &quot;Commitment Type Indication&quot;.
   * - **FHIR Type:** `Coding`
   * - **Cardinality:** 1..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private type_: Coding[] | null;

  /**
   * Signature.when Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** When the signature was created
   * - **Definition:** When the digital signature was signed.
   * - **Comment:** This should agree with the information in the signature.
   * - **FHIR Type:** `instant`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private when: InstantType | null;

  /**
   * Signature.who Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Who signed
   * - **Definition:** A reference to an application-usable description of the identity that signed  (e.g. the signature used their private key).
   * - **Comment:** This should agree with the information in the signature.
   * - **FHIR Type:** `Reference`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Practitioner',
   *       'http://hl7.org/fhir/StructureDefinition/PractitionerRole',
   *       'http://hl7.org/fhir/StructureDefinition/RelatedPerson',
   *       'http://hl7.org/fhir/StructureDefinition/Patient',
   *       'http://hl7.org/fhir/StructureDefinition/Device',
   *       'http://hl7.org/fhir/StructureDefinition/Organization',
   *     ]
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private who: Reference | null;

  /**
   * Signature.onBehalfOf Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The party represented
   * - **Definition:** A reference to an application-usable description of the identity that is represented by the signature.
   * - **Comment:** The party that can\'t sign. For example a child.
   * - **Requirements:** used when the signature is on behalf of a non-signer.
   * - **FHIR Type:** `Reference`
   *   - _TargetProfiles_: [
   *       'http://hl7.org/fhir/StructureDefinition/Practitioner',
   *       'http://hl7.org/fhir/StructureDefinition/PractitionerRole',
   *       'http://hl7.org/fhir/StructureDefinition/RelatedPerson',
   *       'http://hl7.org/fhir/StructureDefinition/Patient',
   *       'http://hl7.org/fhir/StructureDefinition/Device',
   *       'http://hl7.org/fhir/StructureDefinition/Organization',
   *     ]
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private onBehalfOf?: Reference | undefined;

  /**
   * Signature.targetFormat Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The technical format of the signed resources
   * - **Definition:** A mime type that indicates the technical format of the target resources signed by the signature.
   * - **Comment:** "xml", "json" and "ttl" are allowed, which describe the simple encodings described in the specification (and imply appropriate bundle support). Otherwise, mime types are legal here.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private targetFormat?: CodeType | undefined;

  /**
   * Signature.sigFormat Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The technical format of the signature
   * - **Definition:** A mime type that indicates the technical format of the signature. Important mime types are application/signature+xml for X ML DigSig, application/jose for JWS, and image/* for a graphical image of a signature, etc.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private sigFormat?: CodeType | undefined;

  /**
   * Signature.data Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** The actual signature content (XML DigSig. JWS, picture, etc.)
   * - **Definition:** The base64 encoding of the Signature content. When signature is not recorded electronically this element would be empty.
   * - **Comment:** Where the signature type is an XML DigSig, the signed content is a FHIR Resource(s), the signature is of the XML form of the Resource(s) using  XML-Signature (XMLDIG) "Detached Signature" form.
   * - **FHIR Type:** `base64Binary`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** false
   */
  private data?: Base64BinaryType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `type_` property value as a Coding array
   */
  public getType(): Coding[] {
    return this.type_ ?? ([] as Coding[]);
  }

  /**
   * Assigns the provided Coding array value to the `type_` property.
   *
   * @param value - the `type_` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setType(value: Coding[]): this {
    assertIsDefinedList<Coding>(value, `Signature.type is required`);
    const optErrMsg = `Invalid Signature.type; Provided value array has an element that is not an instance of Coding.`;
    assertFhirTypeList<Coding>(value, Coding, optErrMsg);
    this.type_ = value;
    return this;
  }

  /**
   * Add the provided Coding value to the `type_` array property.
   *
   * @param value - the `type_` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addType(value: Coding | undefined): this {
    if (isDefined<Coding>(value)) {
      const optErrMsg = `Invalid Signature.type; Provided element is not an instance of Coding.`;
      assertFhirType<Coding>(value, Coding, optErrMsg);
      this.initType();
      this.type_?.push(value);
    }
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasType(): boolean {
    return isDefinedList<Coding>(this.type_) && this.type_.some((item: Coding) => !item.isEmpty());
  }

  /**
   * Initialize the `type_` property
   */
  private initType(): void {
    if(!this.hasType()) {
      this.type_ = [] as Coding[];
    }
  }

  /**
   * @returns the `when` property value as a InstantType object if defined; else null
   */
  public getWhenElement(): InstantType | null {
    return this.when;
  }

  /**
   * Assigns the provided PrimitiveType value to the `when` property.
   *
   * @param element - the `when` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setWhenElement(element: InstantType): this {
    assertIsDefined<InstantType>(element, `Signature.when is required`);
    const optErrMsg = `Invalid Signature.when; Provided value is not an instance of InstantType.`;
    assertFhirType<InstantType>(element, InstantType, optErrMsg);
    this.when = element;
    return this;
  }

  /**
   * @returns `true` if the `when` property exists and has a value; `false` otherwise
   */
  public hasWhenElement(): boolean {
    return isDefined<InstantType>(this.when) && !this.when.isEmpty();
  }

  /**
   * @returns the `when` property value as a fhirInstant if defined; else null
   */
  public getWhen(): fhirInstant | null {
    if (this.when?.getValue() === undefined) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.when.getValue()!;
  }

  /**
   * Assigns the provided primitive value to the `when` property.
   *
   * @param value - the `when` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setWhen(value: fhirInstant): this {
    assertIsDefined<fhirInstant>(value, `Signature.when is required`);
    const optErrMsg = `Invalid Signature.when (${String(value)})`;
    this.when = new InstantType(parseFhirPrimitiveData(value, fhirInstantSchema, optErrMsg));
    return this;
  }

  /**
   * @returns `true` if the `when` property exists and has a value; `false` otherwise
   */
  public hasWhen(): boolean {
    return this.hasWhenElement();
  }

  /**
   * @returns the `who` property value as a Reference object if defined; else null
   */
  public getWho(): Reference | null {
    return this.who;
  }

  /**
   * Assigns the provided Who object value to the `who` property.
   *
   * @decorator `@ReferenceTargets('Signature.who', ['Practitioner','PractitionerRole','RelatedPerson','Patient','Device','Organization',])`
   *
   * @param value - the `who` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('Signature.who', [
    'Practitioner',
  
    'PractitionerRole',
  
    'RelatedPerson',
  
    'Patient',
  
    'Device',
  
    'Organization',
  ])
  public setWho(value: Reference): this {
    assertIsDefined<Reference>(value, `Signature.who is required`);
    // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
    this.who = value;
    return this;
  }

  /**
   * @returns `true` if the `who` property exists and has a value; `false` otherwise
   */
  public hasWho(): boolean {
    return isDefined<Reference>(this.who) && !this.who.isEmpty();
  }

  /**
   * @returns the `onBehalfOf` property value as a Reference object; else an empty Reference object
   */
  public getOnBehalfOf(): Reference {
    return this.onBehalfOf ?? new Reference();
  }

  /**
   * Assigns the provided OnBehalfOf object value to the `onBehalfOf` property.
   *
   * @decorator `@ReferenceTargets('Signature.onBehalfOf', ['Practitioner','PractitionerRole','RelatedPerson','Patient','Device','Organization',])`
   *
   * @param value - the `onBehalfOf` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data type or reference value
   */
  @ReferenceTargets('Signature.onBehalfOf', [
    'Practitioner',
  
    'PractitionerRole',
  
    'RelatedPerson',
  
    'Patient',
  
    'Device',
  
    'Organization',
  ])
  public setOnBehalfOf(value: Reference | undefined): this {
    if (isDefined<Reference>(value)) {
      // assertFhirType<Reference>(value, Reference) unnecessary because @ReferenceTargets decorator ensures proper type/value
      this.onBehalfOf = value;
    } else {
      this.onBehalfOf = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `onBehalfOf` property exists and has a value; `false` otherwise
   */
  public hasOnBehalfOf(): boolean {
    return isDefined<Reference>(this.onBehalfOf) && !this.onBehalfOf.isEmpty();
  }

  /**
   * @returns the `targetFormat` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getTargetFormatElement(): CodeType {
    return this.targetFormat ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `targetFormat` property.
   *
   * @param element - the `targetFormat` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTargetFormatElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid Signature.targetFormat; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.targetFormat = element;
    } else {
      this.targetFormat = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `targetFormat` property exists and has a value; `false` otherwise
   */
  public hasTargetFormatElement(): boolean {
    return isDefined<CodeType>(this.targetFormat) && !this.targetFormat.isEmpty();
  }

  /**
   * @returns the `targetFormat` property value as a fhirCode if defined; else undefined
   */
  public getTargetFormat(): fhirCode | undefined {
    return this.targetFormat?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `targetFormat` property.
   *
   * @param value - the `targetFormat` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTargetFormat(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid Signature.targetFormat (${String(value)})`;
      this.targetFormat = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.targetFormat = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `targetFormat` property exists and has a value; `false` otherwise
   */
  public hasTargetFormat(): boolean {
    return this.hasTargetFormatElement();
  }

  /**
   * @returns the `sigFormat` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getSigFormatElement(): CodeType {
    return this.sigFormat ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `sigFormat` property.
   *
   * @param element - the `sigFormat` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSigFormatElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid Signature.sigFormat; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.sigFormat = element;
    } else {
      this.sigFormat = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `sigFormat` property exists and has a value; `false` otherwise
   */
  public hasSigFormatElement(): boolean {
    return isDefined<CodeType>(this.sigFormat) && !this.sigFormat.isEmpty();
  }

  /**
   * @returns the `sigFormat` property value as a fhirCode if defined; else undefined
   */
  public getSigFormat(): fhirCode | undefined {
    return this.sigFormat?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `sigFormat` property.
   *
   * @param value - the `sigFormat` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setSigFormat(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid Signature.sigFormat (${String(value)})`;
      this.sigFormat = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.sigFormat = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `sigFormat` property exists and has a value; `false` otherwise
   */
  public hasSigFormat(): boolean {
    return this.hasSigFormatElement();
  }

  /**
   * @returns the `data` property value as a Base64BinaryType object if defined; else an empty Base64BinaryType object
   */
  public getDataElement(): Base64BinaryType {
    return this.data ?? new Base64BinaryType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `data` property.
   *
   * @param element - the `data` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDataElement(element: Base64BinaryType | undefined): this {
    if (isDefined<Base64BinaryType>(element)) {
      const optErrMsg = `Invalid Signature.data; Provided element is not an instance of Base64BinaryType.`;
      assertFhirType<Base64BinaryType>(element, Base64BinaryType, optErrMsg);
      this.data = element;
    } else {
      this.data = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `data` property exists and has a value; `false` otherwise
   */
  public hasDataElement(): boolean {
    return isDefined<Base64BinaryType>(this.data) && !this.data.isEmpty();
  }

  /**
   * @returns the `data` property value as a fhirBase64Binary if defined; else undefined
   */
  public getData(): fhirBase64Binary | undefined {
    return this.data?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `data` property.
   *
   * @param value - the `data` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setData(value: fhirBase64Binary | undefined): this {
    if (isDefined<fhirBase64Binary>(value)) {
      const optErrMsg = `Invalid Signature.data (${String(value)})`;
      this.data = new Base64BinaryType(parseFhirPrimitiveData(value, fhirBase64BinarySchema, optErrMsg));
    } else {
      this.data = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `data` property exists and has a value; `false` otherwise
   */
  public hasData(): boolean {
    return this.hasDataElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Signature';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.type_,
      this.when,
      this.who,
      this.onBehalfOf,
      this.targetFormat,
      this.sigFormat,
      this.data,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Signature {
    const dest = new Signature();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Signature): void {
    super.copyValues(dest);
    const typeList = copyListValues<Coding>(this.type_);
    dest.type_ = typeList.length === 0 ? null : typeList;
    dest.when = this.when ? this.when.copy() : null;
    dest.who = this.who ? this.who.copy() : null;
    dest.onBehalfOf = this.onBehalfOf?.copy();
    dest.targetFormat = this.targetFormat?.copy();
    dest.sigFormat = this.sigFormat?.copy();
    dest.data = this.data?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasType()) {
      setFhirComplexListJson(this.getType(), 'type', jsonObj);
    } else {
      missingReqdProperties.push(`Signature.type`);
    }

    if (this.hasWhenElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirInstant>(this.getWhenElement()!, 'when', jsonObj);
    } else {
      missingReqdProperties.push(`Signature.when`);
    }

    if (this.hasWho()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirComplexJson(this.getWho()!, 'who', jsonObj);
    } else {
      missingReqdProperties.push(`Signature.who`);
    }

    if (this.hasOnBehalfOf()) {
      setFhirComplexJson(this.getOnBehalfOf(), 'onBehalfOf', jsonObj);
    }

    if (this.hasTargetFormatElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getTargetFormatElement(), 'targetFormat', jsonObj);
    }

    if (this.hasSigFormatElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getSigFormatElement(), 'sigFormat', jsonObj);
    }

    if (this.hasDataElement()) {
      setFhirPrimitiveJson<fhirBase64Binary>(this.getDataElement(), 'data', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_DO_NOT_EXIST} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

/**
 * Timing Class
 *
 * @remarks
 * Base StructureDefinition for Timing Type: Specifies an event that may occur multiple times. Timing schedules are used to record when things are planned, expected or requested to occur. The most common usage is in dosage instructions for medications. They are also used when planning care of various kinds, and may be used for reporting the schedule to which past regular activities were carried out.
 *
 * Need to able to track proposed timing schedules. There are several different ways to do this: one or more specified times, a simple rules like three times a day, or  before/after meals.
 *
 * **FHIR Specification**
 * - **Short:** A timing schedule that specifies an event that may occur multiple times
 * - **Definition:** Specifies an event that may occur multiple times. Timing schedules are used to record when things are planned, expected or requested to occur. The most common usage is in dosage instructions for medications. They are also used when planning care of various kinds, and may be used for reporting the schedule to which past regular activities were carried out.
 * - **Comment:** Describes the occurrence of an event that may occur multiple times. Timing schedules are used for specifying when events are expected or requested to occur, and may also be used to represent the summary of a past or ongoing event.  For simplicity, the definitions of Timing components are expressed as \'future\' events, but such components can also be used to describe historic or ongoing events. A Timing schedule can be a list of events and/or criteria for when the event happens, which can be expressed in a structured form and/or as a code. When both event and a repeating specification are provided, the list of events should be understood as an interpretation of the information in the repeat structure.
 * - **FHIR Version:** 4.3.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR Timing](http://hl7.org/fhir/StructureDefinition/Timing)
 */
export class Timing extends BackboneType implements IBackboneType {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }

  /**
   * Parse the provided `Timing` JSON to instantiate the Timing data model.
   *
   * @param sourceJson - JSON representing FHIR `Timing`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to Timing
   * @returns Timing data model or undefined for `Timing`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): Timing | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'Timing';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new Timing();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processBackboneTypeJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    

    fieldName = 'event';
    sourceField = `${optSourceValue}.${fieldName}`;
    const primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: DateTimeType | undefined = fhirParser.parseDateTimeType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addEventElement(datatype);
        }
      });
    }

    fieldName = 'repeat';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: TimingRepeatComponent | undefined = TimingRepeatComponent.parse(classJsonObj[fieldName]!, sourceField);
      instance.setRepeat(datatype);
    }

    fieldName = 'code';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: CodeableConcept | undefined = CodeableConcept.parse(classJsonObj[fieldName]!, sourceField);
      instance.setCode(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Timing.event Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** When the event occurs
   * - **Definition:** Identifies specific times when the event occurs.
   * - **Requirements:** In a Medication Administration Record, for instance, you need to take a general specification, and turn it into a precise specification.
   * - **FHIR Type:** `dateTime`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private event?: DateTimeType[] | undefined;

  /**
   * Timing.repeat Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** When the event is to occur
   * - **Definition:** A set of rules that describe when the event is scheduled.
   * - **Requirements:** Many timing schedules are determined by regular repetitions.
   * - **FHIR Type:** `Element`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private repeat?: TimingRepeatComponent | undefined;

  /**
   * Timing.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** BID | TID | QID | AM | PM | QD | QOD | +
   * - **Definition:** A code for the timing schedule (or just text in code.text). Some codes such as BID are ubiquitous, but many institutions define their own additional codes. If a code is provided, the code is understood to be a complete statement of whatever is specified in the structured timing data, and either the code or the data may be used to interpret the Timing, with the exception that .repeat.bounds still applies over the code (and is not contained in the code).
   * - **Comment:** BID etc. are defined as \'at institutionally specified times\'. For example, an institution may choose that BID is "always at 7am and 6pm".  If it is inappropriate for this choice to be made, the code BID should not be used. Instead, a distinct organization-specific code should be used in place of the HL7-defined BID code and/or a structured representation should be used (in this case, specifying the two event times).
   * - **FHIR Type:** `CodeableConcept`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code?: CodeableConcept | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `event` property value as a DateTimeType array
   */
  public getEventElement(): DateTimeType[] {
    return this.event ?? ([] as DateTimeType[]);
  }

  /**
   * Assigns the provided DateTimeType array value to the `event` property.
   *
   * @param element - the `event` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setEventElement(element: DateTimeType[] | undefined): this {
    if (isDefinedList<DateTimeType>(element)) {
      const optErrMsg = `Invalid Timing.event; Provided value array has an element that is not an instance of DateTimeType.`;
      assertFhirTypeList<DateTimeType>(element, DateTimeType, optErrMsg);
      this.event = element;
    } else {
      this.event = undefined;
    }
    return this;
  }

  /**
   * Add the provided DateTimeType value to the `event` array property.
   *
   * @param element - the `event` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addEventElement(element: DateTimeType | undefined): this {
    if (isDefined<DateTimeType>(element)) {
      const optErrMsg = `Invalid Timing.event; Provided element is not an instance of DateTimeType.`;
      assertFhirType<DateTimeType>(element, DateTimeType, optErrMsg);
      this.initEvent();
      this.event?.push(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `event` property exists and has a value; `false` otherwise
   */
  public hasEventElement(): boolean {
    return isDefinedList<DateTimeType>(this.event) && this.event.some((item: DateTimeType) => !item.isEmpty());
  }

  /**
   * @returns the `event` property value as a fhirDateTime array
   */
  public getEvent(): fhirDateTime[] {
    this.initEvent();
    const eventValues = [] as fhirDateTime[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.event!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        eventValues.push(value);
      }
    }
    return eventValues;
  }

  /**
   * Assigns the provided primitive value array to the `event` property.
   *
   * @param value - the `event` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setEvent(value: fhirDateTime[] | undefined): this {
    if (isDefinedList<fhirDateTime>(value)) {
      const eventElements = [] as DateTimeType[];
      for (const eventValue of value) {
        const optErrMsg = `Invalid Timing.event array item (${String(eventValue)})`;
        const element = new DateTimeType(parseFhirPrimitiveData(eventValue, fhirDateTimeSchema, optErrMsg));
        eventElements.push(element);
      }
      this.event = eventElements;
    } else {
      this.event = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the `event` array property.
   *
   * @param value - the `event` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addEvent(value: fhirDateTime | undefined): this {
    if (isDefined<fhirDateTime>(value)) {
      const optErrMsg = `Invalid Timing.event array item (${String(value)})`;
      const element = new DateTimeType(parseFhirPrimitiveData(value, fhirDateTimeSchema, optErrMsg));
      this.initEvent();
      this.addEventElement(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `event` property exists and has a value; `false` otherwise
   */
  public hasEvent(): boolean {
    return this.hasEventElement();
  }

  /**
   * Initialize the `event` property
   */
  private initEvent(): void {
    if (!this.hasEvent()) {
      this.event = [] as DateTimeType[];
    }
  }

  /**
   * @returns the `repeat` property value as a TimingRepeatComponent object if defined; else an empty TimingRepeatComponent object
   */
  public getRepeat(): TimingRepeatComponent {
    return this.repeat ?? new TimingRepeatComponent();
  }

  /**
   * Assigns the provided Repeat object value to the `repeat` property.
   *
   * @param value - the `repeat` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setRepeat(value: TimingRepeatComponent | undefined): this {
    if (isDefined<TimingRepeatComponent>(value)) {
      const optErrMsg = `Invalid Timing.repeat; Provided element is not an instance of TimingRepeatComponent.`;
      assertFhirType<TimingRepeatComponent>(value, TimingRepeatComponent, optErrMsg);
      this.repeat = value;
    } else {
      this.repeat = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `repeat` property exists and has a value; `false` otherwise
   */
  public hasRepeat(): boolean {
    return isDefined<TimingRepeatComponent>(this.repeat) && !this.repeat.isEmpty();
  }

  /**
   * @returns the `code` property value as a CodeableConcept object if defined; else an empty CodeableConcept object
   */
  public getCode(): CodeableConcept {
    return this.code ?? new CodeableConcept();
  }

  /**
   * Assigns the provided Code object value to the `code` property.
   *
   * @param value - the `code` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setCode(value: CodeableConcept | undefined): this {
    if (isDefined<CodeableConcept>(value)) {
      const optErrMsg = `Invalid Timing.code; Provided element is not an instance of CodeableConcept.`;
      assertFhirType<CodeableConcept>(value, CodeableConcept, optErrMsg);
      this.code = value;
    } else {
      this.code = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `code` property exists and has a value; `false` otherwise
   */
  public hasCode(): boolean {
    return isDefined<CodeableConcept>(this.code) && !this.code.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Timing';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.event,
      this.repeat,
      this.code,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): Timing {
    const dest = new Timing();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: Timing): void {
    super.copyValues(dest);
    const eventList = copyListValues<DateTimeType>(this.event);
    dest.event = eventList.length === 0 ? undefined : eventList;
    dest.repeat = this.repeat?.copy();
    dest.code = this.code?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasEvent()) {
      setFhirPrimitiveListJson(this.getEventElement(), 'event', jsonObj);
    }

    if (this.hasRepeat()) {
      setFhirComplexJson(this.getRepeat(), 'repeat', jsonObj);
    }

    if (this.hasCode()) {
      setFhirComplexJson(this.getCode(), 'code', jsonObj);
    }

    return jsonObj;
  }
}
/**
 * TimingRepeatComponent Class
 *
 * @remarks
 * **FHIR Specification**
 * - **Short:** When the event is to occur
 * - **Definition:** A set of rules that describe when the event is scheduled.
 * - **Requirements:** Many timing schedules are determined by regular repetitions.
 *
 * @category Data Models: ComplexType
 * @see [FHIR Timing](http://hl7.org/fhir/StructureDefinition/Timing)
 */
export class TimingRepeatComponent extends DataType implements IDataType {
  constructor() {
    super();

    this.daysOfWeekEnum = new DaysOfWeekEnum();
  }

  /**
   * Parse the provided `TimingRepeatComponent` JSON to instantiate the TimingRepeatComponent data model.
   *
   * @param sourceJson - JSON representing FHIR `TimingRepeatComponent`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to TimingRepeatComponent
   * @returns TimingRepeatComponent data model or undefined for `TimingRepeatComponent`
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): TimingRepeatComponent | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'TimingRepeatComponent';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new TimingRepeatComponent();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const classMetadata: DecoratorMetadataObject | null = TimingRepeatComponent[Symbol.metadata];
    const errorMessage = `DecoratorMetadataObject does not exist for TimingRepeatComponent`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    fieldName = 'bounds[x]';
    sourceField = `${optSourceValue}.${fieldName}`;
    const bounds: IDataType | undefined = fhirParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setBounds(bounds);

    fieldName = 'count';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = fhirParser.parsePositiveIntType(dtJson, dtSiblingJson);
      instance.setCountElement(datatype);
    }

    fieldName = 'countMax';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = fhirParser.parsePositiveIntType(dtJson, dtSiblingJson);
      instance.setCountMaxElement(datatype);
    }

    fieldName = 'duration';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setDurationElement(datatype);
    }

    fieldName = 'durationMax';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setDurationMaxElement(datatype);
    }

    fieldName = 'durationUnit';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setDurationUnitElement(datatype);
    }

    fieldName = 'frequency';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = fhirParser.parsePositiveIntType(dtJson, dtSiblingJson);
      instance.setFrequencyElement(datatype);
    }

    fieldName = 'frequencyMax';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: PositiveIntType | undefined = fhirParser.parsePositiveIntType(dtJson, dtSiblingJson);
      instance.setFrequencyMaxElement(datatype);
    }

    fieldName = 'period';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setPeriodElement(datatype);
    }

    fieldName = 'periodMax';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: DecimalType | undefined = fhirParser.parseDecimalType(dtJson, dtSiblingJson);
      instance.setPeriodMaxElement(datatype);
    }

    fieldName = 'periodUnit';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      instance.setPeriodUnitElement(datatype);
    }

    fieldName = 'dayOfWeek';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: CodeType | undefined = fhirParser.parseCodeType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addDayOfWeekElement(datatype);
        }
      });
    }

    fieldName = 'timeOfDay';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: TimeType | undefined = fhirParser.parseTimeType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addTimeOfDayElement(datatype);
        }
      });
    }

    fieldName = 'when';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const dataJsonArray: PrimitiveTypeJson[] = getPrimitiveTypeListJson(
        classJsonObj,
        sourceField,
        fieldName,
        primitiveJsonType,
      );
      dataJsonArray.forEach((dataJson: PrimitiveTypeJson) => {
        const datatype: CodeType | undefined = fhirParser.parseCodeType(dataJson.dtJson, dataJson.dtSiblingJson);
        if (datatype !== undefined) {
          instance.addWhenElement(datatype);
        }
      });
    }

    fieldName = 'offset';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'number';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: UnsignedIntType | undefined = fhirParser.parseUnsignedIntType(dtJson, dtSiblingJson);
      instance.setOffsetElement(datatype);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * Timing.repeat.bounds[x] Element
   *
   * @decorator `@ChoiceDataTypesMeta('Timing.repeat.bounds[x]', ['Duration','Range','Period',]`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Length/Range of lengths, or (Start and/or end) limits
   * - **Definition:** Either a duration for the length of the timing schedule, a range of possible length, or outer bounds for start and/or end limits of the timing schedule.
   * - **FHIR Types:**
   *     'Duration',
   *     'Range',
   *     'Period',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('Timing.repeat.bounds[x]',[
    'Duration',
    'Range',
    'Period',
  ])
  private bounds?: IDataType | undefined;

  /**
   * Timing.repeat.count Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Number of times to repeat
   * - **Definition:** A total count of the desired number of repetitions across the duration of the entire timing specification. If countMax is present, this element indicates the lower bound of the allowed range of count values.
   * - **Comment:** If you have both bounds and count, then this should be understood as within the bounds period, until count times happens.
   * - **Requirements:** Repetitions may be limited by end time or total occurrences.
   * - **FHIR Type:** `positiveInt`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private count?: PositiveIntType | undefined;

  /**
   * Timing.repeat.countMax Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Maximum number of times to repeat
   * - **Definition:** If present, indicates that the count is a range - so to perform the action between [count] and [countMax] times.
   * - **FHIR Type:** `positiveInt`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private countMax?: PositiveIntType | undefined;

  /**
   * Timing.repeat.duration Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** How long when it happens
   * - **Definition:** How long this thing happens for when it happens. If durationMax is present, this element indicates the lower bound of the allowed range of the duration.
   * - **Comment:** For some events the duration is part of the definition of the event (e.g. IV infusions, where the duration is implicit in the specified quantity and rate). For others, it\'s part of the timing specification (e.g. exercise).
   * - **Requirements:** Some activities are not instantaneous and need to be maintained for a period of time.
   * - **FHIR Type:** `decimal`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private duration?: DecimalType | undefined;

  /**
   * Timing.repeat.durationMax Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** How long when it happens (Max)
   * - **Definition:** If present, indicates that the duration is a range - so to perform the action between [duration] and [durationMax] time length.
   * - **Comment:** For some events the duration is part of the definition of the event (e.g. IV infusions, where the duration is implicit in the specified quantity and rate). For others, it\'s part of the timing specification (e.g. exercise).
   * - **Requirements:** Some activities are not instantaneous and need to be maintained for a period of time.
   * - **FHIR Type:** `decimal`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private durationMax?: DecimalType | undefined;

  /**
   * Timing.repeat.durationUnit Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** s | min | h | d | wk | mo | a - unit of time (UCUM)
   * - **Definition:** The units of time for the duration, in UCUM units.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private durationUnit?: CodeType | undefined;

  /**
   * Timing.repeat.frequency Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Event occurs frequency times per period
   * - **Definition:** The number of times to repeat the action within the specified period. If frequencyMax is present, this element indicates the lower bound of the allowed range of the frequency.
   * - **FHIR Type:** `positiveInt`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private frequency?: PositiveIntType | undefined;

  /**
   * Timing.repeat.frequencyMax Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Event occurs up to frequencyMax times per period
   * - **Definition:** If present, indicates that the frequency is a range - so to repeat between [frequency] and [frequencyMax] times within the period or period range.
   * - **FHIR Type:** `positiveInt`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private frequencyMax?: PositiveIntType | undefined;

  /**
   * Timing.repeat.period Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Event occurs frequency times per period
   * - **Definition:** Indicates the duration of time over which repetitions are to occur; e.g. to express "3 times per day", 3 would be the frequency and "1 day" would be the period. If periodMax is present, this element indicates the lower bound of the allowed range of the period length.
   * - **FHIR Type:** `decimal`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private period?: DecimalType | undefined;

  /**
   * Timing.repeat.periodMax Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Upper limit of period (3-4 hours)
   * - **Definition:** If present, indicates that the period is a range from [period] to [periodMax], allowing expressing concepts such as "do this once every 3-5 days.
   * - **FHIR Type:** `decimal`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private periodMax?: DecimalType | undefined;

  /**
   * Timing.repeat.periodUnit Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** s | min | h | d | wk | mo | a - unit of time (UCUM)
   * - **Definition:** The units of time for the period in UCUM units.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private periodUnit?: CodeType | undefined;

  /**
   * FHIR CodeSystem: DaysOfWeek
   *
   * @see {@link DaysOfWeekEnum }
   */
  private readonly daysOfWeekEnum: DaysOfWeekEnum;

  /**
   * Timing.repeat.dayOfWeek Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** mon | tue | wed | thu | fri | sat | sun
   * - **Definition:** If one or more days of week is provided, then the action happens only on the specified day(s).
   * - **Comment:** If no days are specified, the action is assumed to happen every day as otherwise specified. The elements frequency and period cannot be used as well as dayOfWeek.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  private dayOfWeek?: EnumCodeType[] | undefined;

  /**
   * Timing.repeat.timeOfDay Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Time of day for action
   * - **Definition:** Specified time of day for action to take place.
   * - **Comment:** When time of day is specified, it is inferred that the action happens every day (as filtered by dayofWeek) on the specified times. The elements when, frequency and period cannot be used as well as timeOfDay.
   * - **FHIR Type:** `time`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private timeOfDay?: TimeType[] | undefined;

  /**
   * Timing.repeat.when Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Code for time period of occurrence
   * - **Definition:** An approximate time period during the day, potentially linked to an event of daily living that indicates when the action should occur.
   * - **Comment:** When more than one event is listed, the event is tied to the union of the specified events.
   * - **Requirements:** Timings are frequently determined by occurrences such as waking, eating and sleep.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private when?: CodeType[] | undefined;

  /**
   * Timing.repeat.offset Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Minutes from event (before or after)
   * - **Definition:** The number of minutes from the event. If the event code does not indicate whether the minutes is before or after the event, then the offset is assumed to be after the event.
   * - **FHIR Type:** `unsignedInt`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private offset?: UnsignedIntType | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `bounds` property value as a DataType object if defined; else undefined
   */
  public getBounds(): IDataType | undefined {
    return this.bounds;
  }

  /**
   * Assigns the provided DataType object value to the `bounds` property.
   *
   * @decorator `@ChoiceDataTypes('Timing.repeat.bounds[x]')`
   *
   * @param value - the `bounds` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  @ChoiceDataTypes('Timing.repeat.bounds[x]')
  public setBounds(value: IDataType | undefined): this {
    if (isDefined<IDataType>(value)) {
      // assertFhirType<IDataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.bounds = value;
    } else {
      this.bounds = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `bounds` property exists and has a value; `false` otherwise
   */
  public hasBounds(): boolean {
    return isDefined<IDataType>(this.bounds) && !this.bounds.isEmpty();
  }

  // *** NOTE ***
  // Following choice datatype-specific "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the `bounds` property value as a Duration object if defined; else undefined
   */
  public getBoundsDuration(): Duration | undefined {
    if (!isDefined<IDataType | undefined>(this.bounds)) {
      return undefined;
    }
    if (!(this.bounds instanceof Duration)) {
      throw new InvalidTypeError(
        `DataType mismatch for Timing.repeat.bounds[x]: Expected Duration but encountered ${this.bounds.fhirType()}`,
      );
    }
    return this.bounds;
  }

  /**
   * @returns `true` if the `bounds` property exists as a Duration and has a value; `false` otherwise
   */
  public hasBoundsDuration(): boolean {
    return this.hasBounds() && this.bounds instanceof Duration;
  }

  /**
   * @returns the `bounds` property value as a Range object if defined; else undefined
   */
  public getBoundsRange(): Range | undefined {
    if (!isDefined<IDataType | undefined>(this.bounds)) {
      return undefined;
    }
    if (!(this.bounds instanceof Range)) {
      throw new InvalidTypeError(
        `DataType mismatch for Timing.repeat.bounds[x]: Expected Range but encountered ${this.bounds.fhirType()}`,
      );
    }
    return this.bounds;
  }

  /**
   * @returns `true` if the `bounds` property exists as a Range and has a value; `false` otherwise
   */
  public hasBoundsRange(): boolean {
    return this.hasBounds() && this.bounds instanceof Range;
  }

  /**
   * @returns the `bounds` property value as a Period object if defined; else undefined
   */
  public getBoundsPeriod(): Period | undefined {
    if (!isDefined<IDataType | undefined>(this.bounds)) {
      return undefined;
    }
    if (!(this.bounds instanceof Period)) {
      throw new InvalidTypeError(
        `DataType mismatch for Timing.repeat.bounds[x]: Expected Period but encountered ${this.bounds.fhirType()}`,
      );
    }
    return this.bounds;
  }

  /**
   * @returns `true` if the `bounds` property exists as a Period and has a value; `false` otherwise
   */
  public hasBoundsPeriod(): boolean {
    return this.hasBounds() && this.bounds instanceof Period;
  }

  // End of choice datatype-specific "get"/"has" methods

  /**
   * @returns the `count` property value as a PositiveIntType object if defined; else an empty PositiveIntType object
   */
  public getCountElement(): PositiveIntType {
    return this.count ?? new PositiveIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `count` property.
   *
   * @param element - the `count` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCountElement(element: PositiveIntType | undefined): this {
    if (isDefined<PositiveIntType>(element)) {
      const optErrMsg = `Invalid Timing.repeat.count; Provided element is not an instance of PositiveIntType.`;
      assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
      this.count = element;
    } else {
      this.count = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `count` property exists and has a value; `false` otherwise
   */
  public hasCountElement(): boolean {
    return isDefined<PositiveIntType>(this.count) && !this.count.isEmpty();
  }

  /**
   * @returns the `count` property value as a fhirPositiveInt if defined; else undefined
   */
  public getCount(): fhirPositiveInt | undefined {
    return this.count?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `count` property.
   *
   * @param value - the `count` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCount(value: fhirPositiveInt | undefined): this {
    if (isDefined<fhirPositiveInt>(value)) {
      const optErrMsg = `Invalid Timing.repeat.count (${String(value)})`;
      this.count = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    } else {
      this.count = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `count` property exists and has a value; `false` otherwise
   */
  public hasCount(): boolean {
    return this.hasCountElement();
  }

  /**
   * @returns the `countMax` property value as a PositiveIntType object if defined; else an empty PositiveIntType object
   */
  public getCountMaxElement(): PositiveIntType {
    return this.countMax ?? new PositiveIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `countMax` property.
   *
   * @param element - the `countMax` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCountMaxElement(element: PositiveIntType | undefined): this {
    if (isDefined<PositiveIntType>(element)) {
      const optErrMsg = `Invalid Timing.repeat.countMax; Provided element is not an instance of PositiveIntType.`;
      assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
      this.countMax = element;
    } else {
      this.countMax = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `countMax` property exists and has a value; `false` otherwise
   */
  public hasCountMaxElement(): boolean {
    return isDefined<PositiveIntType>(this.countMax) && !this.countMax.isEmpty();
  }

  /**
   * @returns the `countMax` property value as a fhirPositiveInt if defined; else undefined
   */
  public getCountMax(): fhirPositiveInt | undefined {
    return this.countMax?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `countMax` property.
   *
   * @param value - the `countMax` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setCountMax(value: fhirPositiveInt | undefined): this {
    if (isDefined<fhirPositiveInt>(value)) {
      const optErrMsg = `Invalid Timing.repeat.countMax (${String(value)})`;
      this.countMax = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    } else {
      this.countMax = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `countMax` property exists and has a value; `false` otherwise
   */
  public hasCountMax(): boolean {
    return this.hasCountMaxElement();
  }

  /**
   * @returns the `duration` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getDurationElement(): DecimalType {
    return this.duration ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `duration` property.
   *
   * @param element - the `duration` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDurationElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = `Invalid Timing.repeat.duration; Provided element is not an instance of DecimalType.`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.duration = element;
    } else {
      this.duration = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `duration` property exists and has a value; `false` otherwise
   */
  public hasDurationElement(): boolean {
    return isDefined<DecimalType>(this.duration) && !this.duration.isEmpty();
  }

  /**
   * @returns the `duration` property value as a fhirDecimal if defined; else undefined
   */
  public getDuration(): fhirDecimal | undefined {
    return this.duration?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `duration` property.
   *
   * @param value - the `duration` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDuration(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = `Invalid Timing.repeat.duration (${String(value)})`;
      this.duration = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.duration = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `duration` property exists and has a value; `false` otherwise
   */
  public hasDuration(): boolean {
    return this.hasDurationElement();
  }

  /**
   * @returns the `durationMax` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getDurationMaxElement(): DecimalType {
    return this.durationMax ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `durationMax` property.
   *
   * @param element - the `durationMax` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDurationMaxElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = `Invalid Timing.repeat.durationMax; Provided element is not an instance of DecimalType.`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.durationMax = element;
    } else {
      this.durationMax = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `durationMax` property exists and has a value; `false` otherwise
   */
  public hasDurationMaxElement(): boolean {
    return isDefined<DecimalType>(this.durationMax) && !this.durationMax.isEmpty();
  }

  /**
   * @returns the `durationMax` property value as a fhirDecimal if defined; else undefined
   */
  public getDurationMax(): fhirDecimal | undefined {
    return this.durationMax?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `durationMax` property.
   *
   * @param value - the `durationMax` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDurationMax(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = `Invalid Timing.repeat.durationMax (${String(value)})`;
      this.durationMax = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.durationMax = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `durationMax` property exists and has a value; `false` otherwise
   */
  public hasDurationMax(): boolean {
    return this.hasDurationMaxElement();
  }

  /**
   * @returns the `durationUnit` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getDurationUnitElement(): CodeType {
    return this.durationUnit ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `durationUnit` property.
   *
   * @param element - the `durationUnit` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDurationUnitElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid Timing.repeat.durationUnit; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.durationUnit = element;
    } else {
      this.durationUnit = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `durationUnit` property exists and has a value; `false` otherwise
   */
  public hasDurationUnitElement(): boolean {
    return isDefined<CodeType>(this.durationUnit) && !this.durationUnit.isEmpty();
  }

  /**
   * @returns the `durationUnit` property value as a fhirCode if defined; else undefined
   */
  public getDurationUnit(): fhirCode | undefined {
    return this.durationUnit?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `durationUnit` property.
   *
   * @param value - the `durationUnit` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setDurationUnit(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid Timing.repeat.durationUnit (${String(value)})`;
      this.durationUnit = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.durationUnit = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `durationUnit` property exists and has a value; `false` otherwise
   */
  public hasDurationUnit(): boolean {
    return this.hasDurationUnitElement();
  }

  /**
   * @returns the `frequency` property value as a PositiveIntType object if defined; else an empty PositiveIntType object
   */
  public getFrequencyElement(): PositiveIntType {
    return this.frequency ?? new PositiveIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `frequency` property.
   *
   * @param element - the `frequency` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setFrequencyElement(element: PositiveIntType | undefined): this {
    if (isDefined<PositiveIntType>(element)) {
      const optErrMsg = `Invalid Timing.repeat.frequency; Provided element is not an instance of PositiveIntType.`;
      assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
      this.frequency = element;
    } else {
      this.frequency = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `frequency` property exists and has a value; `false` otherwise
   */
  public hasFrequencyElement(): boolean {
    return isDefined<PositiveIntType>(this.frequency) && !this.frequency.isEmpty();
  }

  /**
   * @returns the `frequency` property value as a fhirPositiveInt if defined; else undefined
   */
  public getFrequency(): fhirPositiveInt | undefined {
    return this.frequency?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `frequency` property.
   *
   * @param value - the `frequency` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setFrequency(value: fhirPositiveInt | undefined): this {
    if (isDefined<fhirPositiveInt>(value)) {
      const optErrMsg = `Invalid Timing.repeat.frequency (${String(value)})`;
      this.frequency = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    } else {
      this.frequency = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `frequency` property exists and has a value; `false` otherwise
   */
  public hasFrequency(): boolean {
    return this.hasFrequencyElement();
  }

  /**
   * @returns the `frequencyMax` property value as a PositiveIntType object if defined; else an empty PositiveIntType object
   */
  public getFrequencyMaxElement(): PositiveIntType {
    return this.frequencyMax ?? new PositiveIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `frequencyMax` property.
   *
   * @param element - the `frequencyMax` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setFrequencyMaxElement(element: PositiveIntType | undefined): this {
    if (isDefined<PositiveIntType>(element)) {
      const optErrMsg = `Invalid Timing.repeat.frequencyMax; Provided element is not an instance of PositiveIntType.`;
      assertFhirType<PositiveIntType>(element, PositiveIntType, optErrMsg);
      this.frequencyMax = element;
    } else {
      this.frequencyMax = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `frequencyMax` property exists and has a value; `false` otherwise
   */
  public hasFrequencyMaxElement(): boolean {
    return isDefined<PositiveIntType>(this.frequencyMax) && !this.frequencyMax.isEmpty();
  }

  /**
   * @returns the `frequencyMax` property value as a fhirPositiveInt if defined; else undefined
   */
  public getFrequencyMax(): fhirPositiveInt | undefined {
    return this.frequencyMax?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `frequencyMax` property.
   *
   * @param value - the `frequencyMax` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setFrequencyMax(value: fhirPositiveInt | undefined): this {
    if (isDefined<fhirPositiveInt>(value)) {
      const optErrMsg = `Invalid Timing.repeat.frequencyMax (${String(value)})`;
      this.frequencyMax = new PositiveIntType(parseFhirPrimitiveData(value, fhirPositiveIntSchema, optErrMsg));
    } else {
      this.frequencyMax = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `frequencyMax` property exists and has a value; `false` otherwise
   */
  public hasFrequencyMax(): boolean {
    return this.hasFrequencyMaxElement();
  }

  /**
   * @returns the `period` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getPeriodElement(): DecimalType {
    return this.period ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `period` property.
   *
   * @param element - the `period` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPeriodElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = `Invalid Timing.repeat.period; Provided element is not an instance of DecimalType.`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.period = element;
    } else {
      this.period = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `period` property exists and has a value; `false` otherwise
   */
  public hasPeriodElement(): boolean {
    return isDefined<DecimalType>(this.period) && !this.period.isEmpty();
  }

  /**
   * @returns the `period` property value as a fhirDecimal if defined; else undefined
   */
  public getPeriod(): fhirDecimal | undefined {
    return this.period?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `period` property.
   *
   * @param value - the `period` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPeriod(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = `Invalid Timing.repeat.period (${String(value)})`;
      this.period = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.period = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `period` property exists and has a value; `false` otherwise
   */
  public hasPeriod(): boolean {
    return this.hasPeriodElement();
  }

  /**
   * @returns the `periodMax` property value as a DecimalType object if defined; else an empty DecimalType object
   */
  public getPeriodMaxElement(): DecimalType {
    return this.periodMax ?? new DecimalType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `periodMax` property.
   *
   * @param element - the `periodMax` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPeriodMaxElement(element: DecimalType | undefined): this {
    if (isDefined<DecimalType>(element)) {
      const optErrMsg = `Invalid Timing.repeat.periodMax; Provided element is not an instance of DecimalType.`;
      assertFhirType<DecimalType>(element, DecimalType, optErrMsg);
      this.periodMax = element;
    } else {
      this.periodMax = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `periodMax` property exists and has a value; `false` otherwise
   */
  public hasPeriodMaxElement(): boolean {
    return isDefined<DecimalType>(this.periodMax) && !this.periodMax.isEmpty();
  }

  /**
   * @returns the `periodMax` property value as a fhirDecimal if defined; else undefined
   */
  public getPeriodMax(): fhirDecimal | undefined {
    return this.periodMax?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `periodMax` property.
   *
   * @param value - the `periodMax` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPeriodMax(value: fhirDecimal | undefined): this {
    if (isDefined<fhirDecimal>(value)) {
      const optErrMsg = `Invalid Timing.repeat.periodMax (${String(value)})`;
      this.periodMax = new DecimalType(parseFhirPrimitiveData(value, fhirDecimalSchema, optErrMsg));
    } else {
      this.periodMax = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `periodMax` property exists and has a value; `false` otherwise
   */
  public hasPeriodMax(): boolean {
    return this.hasPeriodMaxElement();
  }

  /**
   * @returns the `periodUnit` property value as a CodeType object if defined; else an empty CodeType object
   */
  public getPeriodUnitElement(): CodeType {
    return this.periodUnit ?? new CodeType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `periodUnit` property.
   *
   * @param element - the `periodUnit` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPeriodUnitElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid Timing.repeat.periodUnit; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.periodUnit = element;
    } else {
      this.periodUnit = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `periodUnit` property exists and has a value; `false` otherwise
   */
  public hasPeriodUnitElement(): boolean {
    return isDefined<CodeType>(this.periodUnit) && !this.periodUnit.isEmpty();
  }

  /**
   * @returns the `periodUnit` property value as a fhirCode if defined; else undefined
   */
  public getPeriodUnit(): fhirCode | undefined {
    return this.periodUnit?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `periodUnit` property.
   *
   * @param value - the `periodUnit` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setPeriodUnit(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid Timing.repeat.periodUnit (${String(value)})`;
      this.periodUnit = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
    } else {
      this.periodUnit = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `periodUnit` property exists and has a value; `false` otherwise
   */
  public hasPeriodUnit(): boolean {
    return this.hasPeriodUnitElement();
  }

  /**
   * @returns the `dayOfWeek` property value as a EnumCodeType array
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public getDayOfWeekEnumType(): EnumCodeType[] {
    return this.dayOfWeek ?? ([] as EnumCodeType[]);
  }

  /**
   * Assigns the provided EnumCodeType array value to the `dayOfWeek` property.
   *
   * @param enumType - the `dayOfWeek` array value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public setDayOfWeekEnumType(enumType: EnumCodeType[] | undefined): this {
    if (isDefinedList<EnumCodeType>(enumType)) {
      const errMsgPrefix = `Invalid Timing.repeat.dayOfWeek`;
      assertEnumCodeTypeList<DaysOfWeekEnum>(enumType, DaysOfWeekEnum, errMsgPrefix);
      this.dayOfWeek = enumType;
    } else {
      this.dayOfWeek = undefined;
    }
    return this;
  }

  /**
   * Add the provided EnumCodeType value to the `dayOfWeek` array property.
   *
   * @param enumType - the `dayOfWeek` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public addDayOfWeekEnumType(enumType: EnumCodeType | undefined): this {
    if (isDefined<EnumCodeType>(enumType)) {
      const errMsgPrefix = `Invalid Timing.repeat.dayOfWeek`;
      assertEnumCodeType<DaysOfWeekEnum>(enumType, DaysOfWeekEnum, errMsgPrefix);
      this.initDayOfWeek();
      this.dayOfWeek?.push(enumType);
    }
    return this;
  }

  /**
   * @returns `true` if the `dayOfWeek` property exists and has a value; `false` otherwise
   */
  public hasDayOfWeekEnumType(): boolean {
    return isDefinedList<EnumCodeType>(this.dayOfWeek) && this.dayOfWeek.some((item: EnumCodeType) => !item.isEmpty()) && this.dayOfWeek.every((item: EnumCodeType) => item.fhirCodeEnumeration.length > 0);
  }

  /**
   * @returns the `dayOfWeek` property value as a CodeType array
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public getDayOfWeekElement(): CodeType[] {
    if (this.dayOfWeek === undefined) {
      return [] as CodeType[];
    }
    return this.dayOfWeek as CodeType[];
  }

  /**
   * Assigns the provided PrimitiveType array value to the `dayOfWeek` property.
   *
   * @param element - the `dayOfWeek` array value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public setDayOfWeekElement(element: CodeType[] | undefined): this {
    if (isDefinedList<CodeType>(element)) {
      const optErrMsg = `Invalid Timing.repeat.dayOfWeek; Provided element array has an element that is not an instance of CodeType.`;
      assertFhirTypeList<CodeType>(element, CodeType, optErrMsg);
      const enumCodeTypes = [] as EnumCodeType[];
      element.forEach((type: CodeType) => {
        enumCodeTypes.push(new EnumCodeType(type, this.daysOfWeekEnum));
      });
      this.dayOfWeek = enumCodeTypes;
    } else {
      this.dayOfWeek = undefined;
    }
    return this;
  }

  /**
   * Add the provided PrimitiveType value to the `dayOfWeek` array property.
   *
   * @param element - the `dayOfWeek` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public addDayOfWeekElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid Timing.repeat.dayOfWeek; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.initDayOfWeek();
      this.dayOfWeek?.push(new EnumCodeType(element, this.daysOfWeekEnum));
    }
    return this;
  }

  /**
   * @returns `true` if the `dayOfWeek` property exists and has a value; `false` otherwise
   */
  public hasDayOfWeekElement(): boolean {
    return this.hasDayOfWeekEnumType();
  }

  /**
   * @returns the `dayOfWeek` property value as a fhirCode array
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public getDayOfWeek(): fhirCode[] {
    if (this.dayOfWeek === undefined) {
      return [] as fhirCode[];
    }
    const values = [] as fhirCode[];
    for (const item of this.dayOfWeek) {
      values.push(item.fhirCode.code);
    }
    return values;
  }

  /**
   * Assigns the provided primitive value array to the `dayOfWeek` property.
   *
   * @param value - the `dayOfWeek` value array
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public setDayOfWeek(value: fhirCode[] | undefined): this {
    if (isDefinedList<fhirCode>(value)) {
      const enumCodeTypes = [] as EnumCodeType[];
      const optErrMsg = `Invalid Timing.repeat.dayOfWeek; Provided value is not an instance of fhirCode.`;
      value.forEach((val: fhirCode) => {
        enumCodeTypes.push(new EnumCodeType(parseFhirPrimitiveData(val, fhirCodeSchema, optErrMsg), this.daysOfWeekEnum));
      });
      this.dayOfWeek = enumCodeTypes;
    } else {
      this.dayOfWeek = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the `dayOfWeek` array property.
   *
   * @param value - the `dayOfWeek` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link DaysOfWeekEnum }
   */
  public addDayOfWeek(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      this.initDayOfWeek();
      const optErrMsg = `Invalid Timing.repeat.dayOfWeek; Provided value is not an instance of fhirCode.`;
      this.dayOfWeek?.push(new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.daysOfWeekEnum));
    }
    return this;
  }

  /**
   * @returns `true` if the `dayOfWeek` property exists and has a value; `false` otherwise
   */
  public hasDayOfWeek(): boolean {
    return this.hasDayOfWeekEnumType();
  }

  /**
   * Initialize the dayOfWeek property
   */
  private initDayOfWeek(): void {
    if(!this.hasDayOfWeekEnumType()) {
      this.dayOfWeek = [] as EnumCodeType[];
    }
  }

  /**
   * @returns the `timeOfDay` property value as a TimeType array
   */
  public getTimeOfDayElement(): TimeType[] {
    return this.timeOfDay ?? ([] as TimeType[]);
  }

  /**
   * Assigns the provided TimeType array value to the `timeOfDay` property.
   *
   * @param element - the `timeOfDay` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTimeOfDayElement(element: TimeType[] | undefined): this {
    if (isDefinedList<TimeType>(element)) {
      const optErrMsg = `Invalid Timing.repeat.timeOfDay; Provided value array has an element that is not an instance of TimeType.`;
      assertFhirTypeList<TimeType>(element, TimeType, optErrMsg);
      this.timeOfDay = element;
    } else {
      this.timeOfDay = undefined;
    }
    return this;
  }

  /**
   * Add the provided TimeType value to the `timeOfDay` array property.
   *
   * @param element - the `timeOfDay` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addTimeOfDayElement(element: TimeType | undefined): this {
    if (isDefined<TimeType>(element)) {
      const optErrMsg = `Invalid Timing.repeat.timeOfDay; Provided element is not an instance of TimeType.`;
      assertFhirType<TimeType>(element, TimeType, optErrMsg);
      this.initTimeOfDay();
      this.timeOfDay?.push(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `timeOfDay` property exists and has a value; `false` otherwise
   */
  public hasTimeOfDayElement(): boolean {
    return isDefinedList<TimeType>(this.timeOfDay) && this.timeOfDay.some((item: TimeType) => !item.isEmpty());
  }

  /**
   * @returns the `timeOfDay` property value as a fhirTime array
   */
  public getTimeOfDay(): fhirTime[] {
    this.initTimeOfDay();
    const timeOfDayValues = [] as fhirTime[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.timeOfDay!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        timeOfDayValues.push(value);
      }
    }
    return timeOfDayValues;
  }

  /**
   * Assigns the provided primitive value array to the `timeOfDay` property.
   *
   * @param value - the `timeOfDay` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setTimeOfDay(value: fhirTime[] | undefined): this {
    if (isDefinedList<fhirTime>(value)) {
      const timeOfDayElements = [] as TimeType[];
      for (const timeOfDayValue of value) {
        const optErrMsg = `Invalid Timing.repeat.timeOfDay array item (${String(timeOfDayValue)})`;
        const element = new TimeType(parseFhirPrimitiveData(timeOfDayValue, fhirTimeSchema, optErrMsg));
        timeOfDayElements.push(element);
      }
      this.timeOfDay = timeOfDayElements;
    } else {
      this.timeOfDay = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the `timeOfDay` array property.
   *
   * @param value - the `timeOfDay` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addTimeOfDay(value: fhirTime | undefined): this {
    if (isDefined<fhirTime>(value)) {
      const optErrMsg = `Invalid Timing.repeat.timeOfDay array item (${String(value)})`;
      const element = new TimeType(parseFhirPrimitiveData(value, fhirTimeSchema, optErrMsg));
      this.initTimeOfDay();
      this.addTimeOfDayElement(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `timeOfDay` property exists and has a value; `false` otherwise
   */
  public hasTimeOfDay(): boolean {
    return this.hasTimeOfDayElement();
  }

  /**
   * Initialize the `timeOfDay` property
   */
  private initTimeOfDay(): void {
    if (!this.hasTimeOfDay()) {
      this.timeOfDay = [] as TimeType[];
    }
  }

  /**
   * @returns the `when` property value as a CodeType array
   */
  public getWhenElement(): CodeType[] {
    return this.when ?? ([] as CodeType[]);
  }

  /**
   * Assigns the provided CodeType array value to the `when` property.
   *
   * @param element - the `when` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setWhenElement(element: CodeType[] | undefined): this {
    if (isDefinedList<CodeType>(element)) {
      const optErrMsg = `Invalid Timing.repeat.when; Provided value array has an element that is not an instance of CodeType.`;
      assertFhirTypeList<CodeType>(element, CodeType, optErrMsg);
      this.when = element;
    } else {
      this.when = undefined;
    }
    return this;
  }

  /**
   * Add the provided CodeType value to the `when` array property.
   *
   * @param element - the `when` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addWhenElement(element: CodeType | undefined): this {
    if (isDefined<CodeType>(element)) {
      const optErrMsg = `Invalid Timing.repeat.when; Provided element is not an instance of CodeType.`;
      assertFhirType<CodeType>(element, CodeType, optErrMsg);
      this.initWhen();
      this.when?.push(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `when` property exists and has a value; `false` otherwise
   */
  public hasWhenElement(): boolean {
    return isDefinedList<CodeType>(this.when) && this.when.some((item: CodeType) => !item.isEmpty());
  }

  /**
   * @returns the `when` property value as a fhirCode array
   */
  public getWhen(): fhirCode[] {
    this.initWhen();
    const whenValues = [] as fhirCode[];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    for (const arrayItem of this.when!) {
      const value = arrayItem.getValue();
      if (value !== undefined) {
        whenValues.push(value);
      }
    }
    return whenValues;
  }

  /**
   * Assigns the provided primitive value array to the `when` property.
   *
   * @param value - the `when` value array
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setWhen(value: fhirCode[] | undefined): this {
    if (isDefinedList<fhirCode>(value)) {
      const whenElements = [] as CodeType[];
      for (const whenValue of value) {
        const optErrMsg = `Invalid Timing.repeat.when array item (${String(whenValue)})`;
        const element = new CodeType(parseFhirPrimitiveData(whenValue, fhirCodeSchema, optErrMsg));
        whenElements.push(element);
      }
      this.when = whenElements;
    } else {
      this.when = undefined;
    }
    return this;
  }

  /**
   * Add the provided primitive value to the `when` array property.
   *
   * @param value - the `when` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public addWhen(value: fhirCode | undefined): this {
    if (isDefined<fhirCode>(value)) {
      const optErrMsg = `Invalid Timing.repeat.when array item (${String(value)})`;
      const element = new CodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg));
      this.initWhen();
      this.addWhenElement(element);
    }
    return this;
  }

  /**
   * @returns `true` if the `when` property exists and has a value; `false` otherwise
   */
  public hasWhen(): boolean {
    return this.hasWhenElement();
  }

  /**
   * Initialize the `when` property
   */
  private initWhen(): void {
    if (!this.hasWhen()) {
      this.when = [] as CodeType[];
    }
  }

  /**
   * @returns the `offset` property value as a UnsignedIntType object if defined; else an empty UnsignedIntType object
   */
  public getOffsetElement(): UnsignedIntType {
    return this.offset ?? new UnsignedIntType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `offset` property.
   *
   * @param element - the `offset` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setOffsetElement(element: UnsignedIntType | undefined): this {
    if (isDefined<UnsignedIntType>(element)) {
      const optErrMsg = `Invalid Timing.repeat.offset; Provided element is not an instance of UnsignedIntType.`;
      assertFhirType<UnsignedIntType>(element, UnsignedIntType, optErrMsg);
      this.offset = element;
    } else {
      this.offset = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `offset` property exists and has a value; `false` otherwise
   */
  public hasOffsetElement(): boolean {
    return isDefined<UnsignedIntType>(this.offset) && !this.offset.isEmpty();
  }

  /**
   * @returns the `offset` property value as a fhirUnsignedInt if defined; else undefined
   */
  public getOffset(): fhirUnsignedInt | undefined {
    return this.offset?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `offset` property.
   *
   * @param value - the `offset` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setOffset(value: fhirUnsignedInt | undefined): this {
    if (isDefined<fhirUnsignedInt>(value)) {
      const optErrMsg = `Invalid Timing.repeat.offset (${String(value)})`;
      this.offset = new UnsignedIntType(parseFhirPrimitiveData(value, fhirUnsignedIntSchema, optErrMsg));
    } else {
      this.offset = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `offset` property exists and has a value; `false` otherwise
   */
  public hasOffset(): boolean {
    return this.hasOffsetElement();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'Timing.repeat';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.bounds,
      this.count,
      this.countMax,
      this.duration,
      this.durationMax,
      this.durationUnit,
      this.frequency,
      this.frequencyMax,
      this.period,
      this.periodMax,
      this.periodUnit,
      this.dayOfWeek,
      this.timeOfDay,
      this.when,
      this.offset,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): TimingRepeatComponent {
    const dest = new TimingRepeatComponent();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: TimingRepeatComponent): void {
    super.copyValues(dest);
    dest.bounds = this.bounds?.copy() as IDataType;
    dest.count = this.count?.copy();
    dest.countMax = this.countMax?.copy();
    dest.duration = this.duration?.copy();
    dest.durationMax = this.durationMax?.copy();
    dest.durationUnit = this.durationUnit?.copy();
    dest.frequency = this.frequency?.copy();
    dest.frequencyMax = this.frequencyMax?.copy();
    dest.period = this.period?.copy();
    dest.periodMax = this.periodMax?.copy();
    dest.periodUnit = this.periodUnit?.copy();
    const dayOfWeekList = copyListValues<EnumCodeType>(this.dayOfWeek);
    dest.dayOfWeek = dayOfWeekList.length === 0 ? undefined : dayOfWeekList;
    const timeOfDayList = copyListValues<TimeType>(this.timeOfDay);
    dest.timeOfDay = timeOfDayList.length === 0 ? undefined : timeOfDayList;
    const whenList = copyListValues<CodeType>(this.when);
    dest.when = whenList.length === 0 ? undefined : whenList;
    dest.offset = this.offset?.copy();
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   */
  public override toJSON(): JSON.Value | undefined {
    if (this.isEmpty()) {
      return undefined;
    }

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    if (this.hasBounds()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getBounds()!, 'bounds', jsonObj);
    }

    if (this.hasCountElement()) {
      setFhirPrimitiveJson<fhirPositiveInt>(this.getCountElement(), 'count', jsonObj);
    }

    if (this.hasCountMaxElement()) {
      setFhirPrimitiveJson<fhirPositiveInt>(this.getCountMaxElement(), 'countMax', jsonObj);
    }

    if (this.hasDurationElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getDurationElement(), 'duration', jsonObj);
    }

    if (this.hasDurationMaxElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getDurationMaxElement(), 'durationMax', jsonObj);
    }

    if (this.hasDurationUnitElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getDurationUnitElement(), 'durationUnit', jsonObj);
    }

    if (this.hasFrequencyElement()) {
      setFhirPrimitiveJson<fhirPositiveInt>(this.getFrequencyElement(), 'frequency', jsonObj);
    }

    if (this.hasFrequencyMaxElement()) {
      setFhirPrimitiveJson<fhirPositiveInt>(this.getFrequencyMaxElement(), 'frequencyMax', jsonObj);
    }

    if (this.hasPeriodElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getPeriodElement(), 'period', jsonObj);
    }

    if (this.hasPeriodMaxElement()) {
      setFhirPrimitiveJson<fhirDecimal>(this.getPeriodMaxElement(), 'periodMax', jsonObj);
    }

    if (this.hasPeriodUnitElement()) {
      setFhirPrimitiveJson<fhirCode>(this.getPeriodUnitElement(), 'periodUnit', jsonObj);
    }

    if (this.hasDayOfWeekElement()) {
      setFhirPrimitiveListJson<fhirCode>(this.getDayOfWeekElement(), 'dayOfWeek', jsonObj);
    }

    if (this.hasTimeOfDay()) {
      setFhirPrimitiveListJson(this.getTimeOfDayElement(), 'timeOfDay', jsonObj);
    }

    if (this.hasWhen()) {
      setFhirPrimitiveListJson(this.getWhenElement(), 'when', jsonObj);
    }

    if (this.hasOffsetElement()) {
      setFhirPrimitiveJson<fhirUnsignedInt>(this.getOffsetElement(), 'offset', jsonObj);
    }

    return jsonObj;
  }
}

/**
 * TriggerDefinition Class
 *
 * @remarks
 * Base StructureDefinition for TriggerDefinition Type: A description of a triggering event. Triggering events can be named events, data events, or periodic, as determined by the type element.
 *
 * **FHIR Specification**
 * - **Short:** Defines an expected trigger for a module
 * - **Definition:** A description of a triggering event. Triggering events can be named events, data events, or periodic, as determined by the type element.
 * - **Comment:** If an event is a named-event, it means the event is completely pre-coordinated, and no other information can be specified for the event. If the event is one of the data- events, the data and condition elements specify the triggering criteria. The data element specifies the structured component, and the condition element provides additional optional refinement of that structured component. If the event is periodic, the timing element defines when the event is triggered. For both data- and periodic events, a name can be provided as a shorthand for the formal semantics provided by the other elements.
 * - **FHIR Version:** 4.3.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR TriggerDefinition](http://hl7.org/fhir/StructureDefinition/TriggerDefinition)
 */
export class TriggerDefinition extends DataType implements IDataType {
  constructor(type_: EnumCodeType | CodeType | fhirCode | null = null) {
    super();

    this.triggerTypeEnum = new TriggerTypeEnum();

    this.type_ = constructorCodeValueAsEnumCodeType<TriggerTypeEnum>(
      type_,
      TriggerTypeEnum,
      this.triggerTypeEnum,
      'TriggerDefinition.type',
    );
  }

  /**
   * Parse the provided `TriggerDefinition` JSON to instantiate the TriggerDefinition data model.
   *
   * @param sourceJson - JSON representing FHIR `TriggerDefinition`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to TriggerDefinition
   * @returns TriggerDefinition data model or undefined for `TriggerDefinition`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): TriggerDefinition | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'TriggerDefinition';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new TriggerDefinition();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';
    let primitiveJsonType: 'boolean' | 'number' | 'string' = 'string';

    const classMetadata: DecoratorMetadataObject | null = TriggerDefinition[Symbol.metadata];
    const errorMessage = `DecoratorMetadataObject does not exist for TriggerDefinition`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    const missingReqdProperties: string[] = [];

    fieldName = 'type';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: CodeType | undefined = fhirParser.parseCodeType(dtJson, dtSiblingJson);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setTypeElement(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'name';
    sourceField = `${optSourceValue}.${fieldName}`;
    primitiveJsonType = 'string';
    if (fieldName in classJsonObj) {
      const { dtJson, dtSiblingJson } = getPrimitiveTypeJson(classJsonObj, sourceField, fieldName, primitiveJsonType);
      const datatype: StringType | undefined = fhirParser.parseStringType(dtJson, dtSiblingJson);
      instance.setNameElement(datatype);
    }

    fieldName = 'timing[x]';
    sourceField = `${optSourceValue}.${fieldName}`;
    const timing: IDataType | undefined = fhirParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    instance.setTiming(timing);

    fieldName = 'data';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const dataElementJsonArray: JSON.Array = JSON.asArray(classJsonObj[fieldName]!, sourceField);
      dataElementJsonArray.forEach((dataElementJson: JSON.Value, idx) => {
        const datatype: DataRequirement | undefined = DataRequirement.parse(dataElementJson, `${sourceField}[${String(idx)}]`);
        if (datatype !== undefined) {
          instance.addData(datatype);
        }
      });
    }

    fieldName = 'condition';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Expression | undefined = Expression.parse(classJsonObj[fieldName]!, sourceField);
      instance.setCondition(datatype);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_REQD_IN_JSON} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * FHIR CodeSystem: TriggerType
   *
   * @see {@link TriggerTypeEnum }
   */
  private readonly triggerTypeEnum: TriggerTypeEnum;

  /**
   * TriggerDefinition.type Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** named-event | periodic | data-changed | data-added | data-modified | data-removed | data-accessed | data-access-ended
   * - **Definition:** The type of triggering event.
   * - **FHIR Type:** `code`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   *
   * @see CodeSystem Enumeration: {@link TriggerTypeEnum }
   */
  private type_: EnumCodeType | null;

  /**
   * TriggerDefinition.name Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Name or URI that identifies the event
   * - **Definition:** A formal name for the event. This may be an absolute URI that identifies the event formally (e.g. from a trigger registry), or a simple relative URI that identifies the event in a local context.
   * - **Comment:** An event name can be provided for all event types, but is required for named events. If a name is provided for a type other than named events, it is considered to be a shorthand for the semantics described by the formal description of the event.
   * - **FHIR Type:** `string`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private name?: StringType | undefined;

  /**
   * TriggerDefinition.timing[x] Element
   *
   * @decorator `@ChoiceDataTypesMeta('TriggerDefinition.timing[x]', ['Timing','Reference','date','dateTime',]`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Timing of the event
   * - **Definition:** The timing of the event (if this is a periodic trigger).
   * - **FHIR Types:**
   *     'Timing',
   *     'Reference',
   *     'date',
   *     'dateTime',
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('TriggerDefinition.timing[x]',[
    'Timing',
    'Reference',
    'date',
    'dateTime',
  ])
  private timing?: IDataType | undefined;

  /**
   * TriggerDefinition.data Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Triggering data of the event (multiple = \'and\')
   * - **Definition:** The triggering data of the event (if this is a data trigger). If more than one data is requirement is specified, then all the data requirements must be true.
   * - **Comment:** This element shall be present for any data type trigger.
   * - **FHIR Type:** `DataRequirement`
   * - **Cardinality:** 0..*
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private data?: DataRequirement[] | undefined;

  /**
   * TriggerDefinition.condition Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Whether the event triggers (boolean expression)
   * - **Definition:** A boolean-valued expression that is evaluated in the context of the container of the trigger definition and returns whether or not the trigger fires.
   * - **Comment:** This element can be only be specified for data type triggers and provides additional semantics for the trigger. The context available within the condition is based on the type of data event. For all events, the current resource will be available as context. In addition, for modification events, the previous resource will also be available. The expression may be inlined, or may be a simple absolute URI, which is a reference to a named expression within a logic library referenced by a library element or extension within the containing resource. If the expression is a FHIR Path expression, it evaluates in the context of a resource of one of the type identified in the data requirement, and may also refer to the variable %previous for delta comparisons on events of type data-changed, data-modified, and data-deleted which will always have the same type.
   * - **Requirements:** Need to be able to formally describe the triggering criteria.
   * - **FHIR Type:** `Expression`
   * - **Cardinality:** 0..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private condition?: Expression | undefined;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `type_` property value as a EnumCodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link TriggerTypeEnum }
   */
  public getTypeEnumType(): EnumCodeType | null {
    return this.type_;
  }

  /**
   * Assigns the provided EnumCodeType value to the `type_` property.
   *
   * @param enumType - the `type_` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link TriggerTypeEnum }
   */
  public setTypeEnumType(enumType: EnumCodeType): this {
    assertIsDefined<EnumCodeType>(enumType, `TriggerDefinition.type is required`);
    const errMsgPrefix = `Invalid TriggerDefinition.type`;
    assertEnumCodeType<TriggerTypeEnum>(enumType, TriggerTypeEnum, errMsgPrefix);
    this.type_ = enumType;
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasTypeEnumType(): boolean {
    return isDefined<EnumCodeType>(this.type_) && !this.type_.isEmpty() && this.type_.fhirCodeEnumeration.length > 0;
  }

  /**
   * @returns the `type_` property value as a CodeType if defined; else null
   *
   * @see CodeSystem Enumeration: {@link TriggerTypeEnum }
   */
  public getTypeElement(): CodeType | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_ as CodeType;
  }

  /**
   * Assigns the provided PrimitiveType value to the `type_` property.
   *
   * @param element - the `type_` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link InvalidTypeError} for invalid data types
   *
   * @see CodeSystem Enumeration: {@link TriggerTypeEnum }
   */
  public setTypeElement(element: CodeType): this {
    assertIsDefined<CodeType>(element, `TriggerDefinition.type is required`);
    const optErrMsg = `Invalid TriggerDefinition.type; Provided value is not an instance of CodeType.`;
    assertFhirType<CodeType>(element, CodeType, optErrMsg);
    this.type_ = new EnumCodeType(element, this.triggerTypeEnum);
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasTypeElement(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the `type_` property value as a fhirCode if defined; else null
   *
   * @see CodeSystem Enumeration: {@link TriggerTypeEnum }
   */
  public getType(): fhirCode | null {
    if (this.type_ === null) {
      return null;
    }
    return this.type_.fhirCode.code;
  }

  /**
   * Assigns the provided primitive value to the `type_` property.
   *
   * @param value - the `type_` value
   * @returns this
   * @throws {@link InvalidCodeError} for invalid code value
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   *
   * @see CodeSystem Enumeration: {@link TriggerTypeEnum }
   */
  public setType(value: fhirCode): this {
    assertIsDefined<fhirCode>(value, `TriggerDefinition.type is required`);
    const optErrMsg = `Invalid TriggerDefinition.type (${String(value)})`;
    this.type_ = new EnumCodeType(parseFhirPrimitiveData(value, fhirCodeSchema, optErrMsg), this.triggerTypeEnum);
    return this;
  }

  /**
   * @returns `true` if the `type_` property exists and has a value; `false` otherwise
   */
  public hasType(): boolean {
    return this.hasTypeEnumType();
  }

  /**
   * @returns the `name` property value as a StringType object if defined; else an empty StringType object
   */
  public getNameElement(): StringType {
    return this.name ?? new StringType();
  }

  /**
   * Assigns the provided PrimitiveType value to the `name` property.
   *
   * @param element - the `name` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setNameElement(element: StringType | undefined): this {
    if (isDefined<StringType>(element)) {
      const optErrMsg = `Invalid TriggerDefinition.name; Provided element is not an instance of StringType.`;
      assertFhirType<StringType>(element, StringType, optErrMsg);
      this.name = element;
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `name` property exists and has a value; `false` otherwise
   */
  public hasNameElement(): boolean {
    return isDefined<StringType>(this.name) && !this.name.isEmpty();
  }

  /**
   * @returns the `name` property value as a fhirString if defined; else undefined
   */
  public getName(): fhirString | undefined {
    return this.name?.getValue();
  }

  /**
   * Assigns the provided primitive value to the `name` property.
   *
   * @param value - the `name` value
   * @returns this
   * @throws {@link PrimitiveTypeError} for invalid primitive types
   */
  public setName(value: fhirString | undefined): this {
    if (isDefined<fhirString>(value)) {
      const optErrMsg = `Invalid TriggerDefinition.name (${String(value)})`;
      this.name = new StringType(parseFhirPrimitiveData(value, fhirStringSchema, optErrMsg));
    } else {
      this.name = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `name` property exists and has a value; `false` otherwise
   */
  public hasName(): boolean {
    return this.hasNameElement();
  }

  /**
   * @returns the `timing` property value as a DataType object if defined; else undefined
   */
  public getTiming(): IDataType | undefined {
    return this.timing;
  }

  /**
   * Assigns the provided DataType object value to the `timing` property.
   *
   * @decorator `@ChoiceDataTypes('TriggerDefinition.timing[x]')`
   *
   * @param value - the `timing` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  @ChoiceDataTypes('TriggerDefinition.timing[x]')
  public setTiming(value: IDataType | undefined): this {
    if (isDefined<IDataType>(value)) {
      // assertFhirType<IDataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
      this.timing = value;
    } else {
      this.timing = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `timing` property exists and has a value; `false` otherwise
   */
  public hasTiming(): boolean {
    return isDefined<IDataType>(this.timing) && !this.timing.isEmpty();
  }

  // *** NOTE ***
  // Following choice datatype-specific "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the `timing` property value as a Timing object if defined; else undefined
   */
  public getTimingTiming(): Timing | undefined {
    if (!isDefined<IDataType | undefined>(this.timing)) {
      return undefined;
    }
    if (!(this.timing instanceof Timing)) {
      throw new InvalidTypeError(
        `DataType mismatch for TriggerDefinition.timing[x]: Expected Timing but encountered ${this.timing.fhirType()}`,
      );
    }
    return this.timing;
  }

  /**
   * @returns `true` if the `timing` property exists as a Timing and has a value; `false` otherwise
   */
  public hasTimingTiming(): boolean {
    return this.hasTiming() && this.timing instanceof Timing;
  }

  /**
   * @returns the `timing` property value as a Reference object if defined; else undefined
   */
  public getTimingReference(): Reference | undefined {
    if (!isDefined<IDataType | undefined>(this.timing)) {
      return undefined;
    }
    if (!(this.timing instanceof Reference)) {
      throw new InvalidTypeError(
        `DataType mismatch for TriggerDefinition.timing[x]: Expected Reference but encountered ${this.timing.fhirType()}`,
      );
    }
    return this.timing;
  }

  /**
   * @returns `true` if the `timing` property exists as a Reference and has a value; `false` otherwise
   */
  public hasTimingReference(): boolean {
    return this.hasTiming() && this.timing instanceof Reference;
  }

  /**
   * @returns the `timing` property value as a DateType object if defined; else undefined
   */
  public getTimingDateType(): DateType | undefined {
    if (!isDefined<IDataType | undefined>(this.timing)) {
      return undefined;
    }
    if (!(this.timing instanceof DateType)) {
      throw new InvalidTypeError(
        `DataType mismatch for TriggerDefinition.timing[x]: Expected DateType but encountered ${this.timing.fhirType()}`,
      );
    }
    return this.timing;
  }

  /**
   * @returns `true` if the `timing` property exists as a DateType and has a value; `false` otherwise
   */
  public hasTimingDateType(): boolean {
    return this.hasTiming() && this.timing instanceof DateType;
  }

  /**
   * @returns the `timing` property value as a DateTimeType object if defined; else undefined
   */
  public getTimingDateTimeType(): DateTimeType | undefined {
    if (!isDefined<IDataType | undefined>(this.timing)) {
      return undefined;
    }
    if (!(this.timing instanceof DateTimeType)) {
      throw new InvalidTypeError(
        `DataType mismatch for TriggerDefinition.timing[x]: Expected DateTimeType but encountered ${this.timing.fhirType()}`,
      );
    }
    return this.timing;
  }

  /**
   * @returns `true` if the `timing` property exists as a DateTimeType and has a value; `false` otherwise
   */
  public hasTimingDateTimeType(): boolean {
    return this.hasTiming() && this.timing instanceof DateTimeType;
  }

  // End of choice datatype-specific "get"/"has" methods

  /**
   * @returns the `data` property value as a DataRequirement array
   */
  public getData(): DataRequirement[] {
    return this.data ?? ([] as DataRequirement[]);
  }

  /**
   * Assigns the provided DataRequirement array value to the `data` property.
   *
   * @param value - the `data` array value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setData(value: DataRequirement[] | undefined): this {
    if (isDefinedList<DataRequirement>(value)) {
      const optErrMsg = `Invalid TriggerDefinition.data; Provided value array has an element that is not an instance of DataRequirement.`;
      assertFhirTypeList<DataRequirement>(value, DataRequirement, optErrMsg);
      this.data = value;
    } else {
      this.data = undefined;
    }
    return this;
  }

  /**
   * Add the provided DataRequirement value to the `data` array property.
   *
   * @param value - the `data` value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public addData(value: DataRequirement | undefined): this {
    if (isDefined<DataRequirement>(value)) {
      const optErrMsg = `Invalid TriggerDefinition.data; Provided element is not an instance of DataRequirement.`;
      assertFhirType<DataRequirement>(value, DataRequirement, optErrMsg);
      this.initData();
      this.data?.push(value);
    }
    return this;
  }

  /**
   * @returns `true` if the `data` property exists and has a value; `false` otherwise
   */
  public hasData(): boolean {
    return isDefinedList<DataRequirement>(this.data) && this.data.some((item: DataRequirement) => !item.isEmpty());
  }

  /**
   * Initialize the `data` property
   */
  private initData(): void {
    if(!this.hasData()) {
      this.data = [] as DataRequirement[];
    }
  }

  /**
   * @returns the `condition` property value as a Expression object if defined; else an empty Expression object
   */
  public getCondition(): Expression {
    return this.condition ?? new Expression();
  }

  /**
   * Assigns the provided Condition object value to the `condition` property.
   *
   * @param value - the `condition` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setCondition(value: Expression | undefined): this {
    if (isDefined<Expression>(value)) {
      const optErrMsg = `Invalid TriggerDefinition.condition; Provided element is not an instance of Expression.`;
      assertFhirType<Expression>(value, Expression, optErrMsg);
      this.condition = value;
    } else {
      this.condition = undefined;
    }
    return this;
  }

  /**
   * @returns `true` if the `condition` property exists and has a value; `false` otherwise
   */
  public hasCondition(): boolean {
    return isDefined<Expression>(this.condition) && !this.condition.isEmpty();
  }

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'TriggerDefinition';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.type_,
      this.name,
      this.timing,
      this.data,
      this.condition,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): TriggerDefinition {
    const dest = new TriggerDefinition();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: TriggerDefinition): void {
    super.copyValues(dest);
    dest.type_ = this.type_ ? this.type_.copy() : null;
    dest.name = this.name?.copy();
    dest.timing = this.timing?.copy() as IDataType;
    const dataList = copyListValues<DataRequirement>(this.data);
    dest.data = dataList.length === 0 ? undefined : dataList;
    dest.condition = this.condition?.copy();
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasTypeElement()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirPrimitiveJson<fhirCode>(this.getTypeElement()!, 'type', jsonObj);
    } else {
      missingReqdProperties.push(`TriggerDefinition.type`);
    }

    if (this.hasNameElement()) {
      setFhirPrimitiveJson<fhirString>(this.getNameElement(), 'name', jsonObj);
    }

    if (this.hasTiming()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getTiming()!, 'timing', jsonObj);
    }

    if (this.hasData()) {
      setFhirComplexListJson(this.getData(), 'data', jsonObj);
    }

    if (this.hasCondition()) {
      setFhirComplexJson(this.getCondition(), 'condition', jsonObj);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_DO_NOT_EXIST} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

/**
 * UsageContext Class
 *
 * @remarks
 * Base StructureDefinition for UsageContext Type: Specifies clinical/business/etc. metadata that can be used to retrieve, index and/or categorize an artifact. This metadata can either be specific to the applicable population (e.g., age category, DRG) or the specific context of care (e.g., venue, care setting, provider of care).
 *
 * Consumers of the resource must be able to determine the intended applicability for the resource. Ideally, this information would be used programmatically to determine when and how it should be incorporated or exposed.
 *
 * **FHIR Specification**
 * - **Short:** Describes the context of use for a conformance or knowledge resource
 * - **Definition:** Specifies clinical/business/etc. metadata that can be used to retrieve, index and/or categorize an artifact. This metadata can either be specific to the applicable population (e.g., age category, DRG) or the specific context of care (e.g., venue, care setting, provider of care).
 * - **FHIR Version:** 4.3.0
 *
 * @category Data Models: ComplexType
 * @see [FHIR UsageContext](http://hl7.org/fhir/StructureDefinition/UsageContext)
 */
export class UsageContext extends DataType implements IDataType {
  constructor(code: Coding | null = null, value: IDataType | null = null) {
    super();

    this.code = null;
    if (isDefined<Coding>(code)) {
      this.setCode(code);
    }

    this.value = null;
    if (isDefined<IDataType>(value)) {
      this.setValue(value);
    }

  }

  /**
   * Parse the provided `UsageContext` JSON to instantiate the UsageContext data model.
   *
   * @param sourceJson - JSON representing FHIR `UsageContext`
   * @param optSourceField - Optional data source field (e.g. `<complexTypeName>.<complexTypeFieldName>`); defaults to UsageContext
   * @returns UsageContext data model or undefined for `UsageContext`
   * @throws {@link FhirError} if the provided JSON is missing required properties
   * @throws {@link JsonError} if the provided JSON is not a valid JSON object
   */
  public static parse(sourceJson: JSON.Value, optSourceField?: string): UsageContext | undefined {
    if (!isDefined<JSON.Value>(sourceJson) || (JSON.isJsonObject(sourceJson) && isEmpty(sourceJson))) {
      return undefined;
    }

    const optSourceValue = isDefined<string>(optSourceField) ? optSourceField : 'UsageContext';
    const classJsonObj: JSON.Object = JSON.asObject(sourceJson, `${optSourceValue} JSON`);
    const instance = new UsageContext();

    const fhirParser = new FhirParser(PARSABLE_DATATYPE_MAP, PARSABLE_RESOURCE_MAP);
    fhirParser.processElementJson(instance, classJsonObj);

    let fieldName = '';
    let sourceField = '';

    const classMetadata: DecoratorMetadataObject | null = UsageContext[Symbol.metadata];
    const errorMessage = `DecoratorMetadataObject does not exist for UsageContext`;
    assertIsDefined<DecoratorMetadataObject>(classMetadata, errorMessage);

    const missingReqdProperties: string[] = [];

    fieldName = 'code';
    sourceField = `${optSourceValue}.${fieldName}`;
    if (fieldName in classJsonObj) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const datatype: Coding | undefined = Coding.parse(classJsonObj[fieldName]!, sourceField);
      if (datatype === undefined) {
        missingReqdProperties.push(sourceField);
      } else {
        instance.setCode(datatype);
      }
    } else {
      missingReqdProperties.push(sourceField);
    }

    fieldName = 'value[x]';
    sourceField = `${optSourceValue}.${fieldName}`;
    const value: IDataType | undefined = fhirParser.parsePolymorphicDataType(
      classJsonObj,
      sourceField,
      fieldName,
      classMetadata,
    );
    if (value === undefined) {
      missingReqdProperties.push(sourceField);
    } else {
      instance.setValue(value);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_REQD_IN_JSON} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    assert(!instance.isEmpty(), INSTANCE_EMPTY_ERROR_MSG);
    return instance;
  }

  /**
   * UsageContext.code Element
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Type of context being specified
   * - **Definition:** A code that identifies the type of context being specified by this usage context.
   * - **FHIR Type:** `Coding`
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  private code: Coding | null;

  /**
   * UsageContext.value[x] Element
   *
   * @decorator `@ChoiceDataTypesMeta('UsageContext.value[x]', ['CodeableConcept','Quantity','Range','Reference',]`
   *
   * @remarks
   * **FHIR Specification**
   * - **Short:** Value that defines the context
   * - **Definition:** A value that defines the context specified in this context of use. The interpretation of the value is defined by the code.
   * - **FHIR Types:**
   *     'CodeableConcept',
   *     'Quantity',
   *     'Range',
   *     'Reference',
   * - **Cardinality:** 1..1
   * - **isModifier:** false
   * - **isSummary:** true
   */
  @ChoiceDataTypesMeta('UsageContext.value[x]',[
    'CodeableConcept',
    'Quantity',
    'Range',
    'Reference',
  ])
  private value: IDataType | null;

  /* eslint-disable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the `code` property value as a Coding object if defined; else null
   */
  public getCode(): Coding | null {
    return this.code;
  }

  /**
   * Assigns the provided Coding object value to the `code` property.
   *
   * @param value - the `code` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  public setCode(value: Coding): this {
    assertIsDefined<Coding>(value, `UsageContext.code is required`);
    const optErrMsg = `Invalid UsageContext.code; Provided element is not an instance of Coding.`;
    assertFhirType<Coding>(value, Coding, optErrMsg);
    this.code = value;
    return this;
  }

  /**
   * @returns `true` if the `code` property exists and has a value; `false` otherwise
   */
  public hasCode(): boolean {
    return isDefined<Coding>(this.code) && !this.code.isEmpty();
  }

  /**
   * @returns the `value` property value as a DataType object; else null
   */
  public getValue(): IDataType | null {
    return this.value;
  }

  /**
   * Assigns the provided DataType object value to the `value` property.
   *
   * @decorator `@ChoiceDataTypes('UsageContext.value[x]')`
   *
   * @param value - the `value` object value
   * @returns this
   * @throws {@link InvalidTypeError} for invalid data types
   */
  @ChoiceDataTypes('UsageContext.value[x]')
  public setValue(value: IDataType): this {
    assertIsDefined<IDataType>(value, `UsageContext.value[x] is required`);
    // assertFhirType<IDataType>(value, DataType) unnecessary because @ChoiceDataTypes decorator ensures proper type/value
    this.value = value;
    return this;
  }

  /**
   * @returns `true` if the `value` property exists and has a value; `false` otherwise
   */
  public hasValue(): boolean {
    return isDefined<IDataType>(this.value) && !this.value.isEmpty();
  }

  // *** NOTE ***
  // Following choice datatype-specific "get"/"has" methods are added for each choice data type - one pair of methods for each choice data type

  /**
   * @returns the `value` property value as a CodeableConcept object if defined; else null
   */
  public getValueCodeableConcept(): CodeableConcept | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof CodeableConcept)) {
      throw new InvalidTypeError(
        `DataType mismatch for UsageContext.value[x]: Expected CodeableConcept but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a CodeableConcept and has a value; `false` otherwise
   */
  public hasValueCodeableConcept(): boolean {
    return this.hasValue() && this.value instanceof CodeableConcept;
  }

  /**
   * @returns the `value` property value as a Quantity object if defined; else null
   */
  public getValueQuantity(): Quantity | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Quantity)) {
      throw new InvalidTypeError(
        `DataType mismatch for UsageContext.value[x]: Expected Quantity but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a Quantity and has a value; `false` otherwise
   */
  public hasValueQuantity(): boolean {
    return this.hasValue() && this.value instanceof Quantity;
  }

  /**
   * @returns the `value` property value as a Range object if defined; else null
   */
  public getValueRange(): Range | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Range)) {
      throw new InvalidTypeError(
        `DataType mismatch for UsageContext.value[x]: Expected Range but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a Range and has a value; `false` otherwise
   */
  public hasValueRange(): boolean {
    return this.hasValue() && this.value instanceof Range;
  }

  /**
   * @returns the `value` property value as a Reference object if defined; else null
   */
  public getValueReference(): Reference | null {
    if (!isDefined<IDataType>(this.value)) {
      return null;
    }
    if (!(this.value instanceof Reference)) {
      throw new InvalidTypeError(
        `DataType mismatch for UsageContext.value[x]: Expected Reference but encountered ${this.value.fhirType()}`,
      );
    }
    return this.value;
  }

  /**
   * @returns `true` if the `` property exists as a Reference and has a value; `false` otherwise
   */
  public hasValueReference(): boolean {
    return this.hasValue() && this.value instanceof Reference;
  }

  // End of choice datatype-specific "get"/"has" methods

  /* eslint-enable @typescript-eslint/no-unnecessary-type-conversion */

  /**
   * @returns the FHIR type defined in the FHIR standard
   */
  public override fhirType(): string {
    return 'UsageContext';
  }

  /**
   * @returns `true` if the instance is empty; `false` otherwise
   */
  public override isEmpty(): boolean {
    return super.isEmpty() && isElementEmpty(
      this.code,
      this.value,
    );
  }

  /**
   * Creates a copy of the current instance.
   *
   * @returns the a new instance copied from the current instance
   */
  public override copy(): UsageContext {
    const dest = new UsageContext();
    this.copyValues(dest);
    return dest;
  }

  /**
   * Copies the current instance's elements into the provided object.
   *
   * @param dest - the copied instance
   * @protected
   */
  protected override copyValues(dest: UsageContext): void {
    super.copyValues(dest);
    dest.code = this.code ? this.code.copy() : null;
    dest.value = this.value ? this.value.copy() as IDataType : null;
  }

  /**
   * @returns `true` if the instance is a FHIR complex datatype; `false` otherwise
   */
  public override isComplexDataType(): boolean {
    return true;
  }

  /**
   * @returns the complex or primitive data model type name (e.g., 'Period", 'StringType', `UriType', etc.)
   */
  public override dataTypeName(): string {
    return this.constructor.name;
  }

  /**
   * @returns the JSON value or undefined if the instance is empty
   * @throws {@link FhirError} if the instance is missing required properties
   */
  public override toJSON(): JSON.Value | undefined {
    // Required class properties exist (have a min cardinality > 0); therefore, do not check for this.isEmpty()!

    let jsonObj = super.toJSON() as JSON.Object | undefined;
    jsonObj ??= {} as JSON.Object;

    const missingReqdProperties: string[] = [];

    if (this.hasCode()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setFhirComplexJson(this.getCode()!, 'code', jsonObj);
    } else {
      missingReqdProperties.push(`UsageContext.code`);
    }

    if (this.hasValue()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setPolymorphicValueJson(this.getValue()!, 'value', jsonObj);
    } else {
      missingReqdProperties.push(`UsageContext.value[x]`);
    }

    if (missingReqdProperties.length > 0) {
      const errMsg = `${REQUIRED_PROPERTIES_DO_NOT_EXIST} ${missingReqdProperties.join(', ')}`;
      throw new FhirError(errMsg);
    }

    return jsonObj;
  }
}

/**
 * PARSABLE_DATATYPE_MAP
 *
 * @remarks
 * Map of all parsable DataTypes where the key is the name of the DataType and the value is its ParsableDataType<DataType> class.
 *
 * @internal
 */
export const PARSABLE_DATATYPE_MAP = new Map<string, ParsableDataType<DataType>>();
PARSABLE_DATATYPE_MAP.set('Address', Address);
PARSABLE_DATATYPE_MAP.set('Age', Age);
PARSABLE_DATATYPE_MAP.set('Annotation', Annotation);
PARSABLE_DATATYPE_MAP.set('Attachment', Attachment);
PARSABLE_DATATYPE_MAP.set('CodeableConcept', CodeableConcept);
PARSABLE_DATATYPE_MAP.set('CodeableReference', CodeableReference);
PARSABLE_DATATYPE_MAP.set('Coding', Coding);
PARSABLE_DATATYPE_MAP.set('ContactDetail', ContactDetail);
PARSABLE_DATATYPE_MAP.set('ContactPoint', ContactPoint);
PARSABLE_DATATYPE_MAP.set('Contributor', Contributor);
PARSABLE_DATATYPE_MAP.set('Count', Count);
PARSABLE_DATATYPE_MAP.set('DataRequirement', DataRequirement);
PARSABLE_DATATYPE_MAP.set('Distance', Distance);
PARSABLE_DATATYPE_MAP.set('Dosage', Dosage);
PARSABLE_DATATYPE_MAP.set('Duration', Duration);
PARSABLE_DATATYPE_MAP.set('ElementDefinition', ElementDefinition);
PARSABLE_DATATYPE_MAP.set('Expression', Expression);
PARSABLE_DATATYPE_MAP.set('HumanName', HumanName);
PARSABLE_DATATYPE_MAP.set('Identifier', Identifier);
PARSABLE_DATATYPE_MAP.set('MarketingStatus', MarketingStatus);
PARSABLE_DATATYPE_MAP.set('Meta', Meta);
PARSABLE_DATATYPE_MAP.set('Money', Money);
PARSABLE_DATATYPE_MAP.set('Narrative', Narrative);
PARSABLE_DATATYPE_MAP.set('ParameterDefinition', ParameterDefinition);
PARSABLE_DATATYPE_MAP.set('Period', Period);
PARSABLE_DATATYPE_MAP.set('Population', Population);
PARSABLE_DATATYPE_MAP.set('ProdCharacteristic', ProdCharacteristic);
PARSABLE_DATATYPE_MAP.set('ProductShelfLife', ProductShelfLife);
PARSABLE_DATATYPE_MAP.set('Quantity', Quantity);
PARSABLE_DATATYPE_MAP.set('Range', Range);
PARSABLE_DATATYPE_MAP.set('Ratio', Ratio);
PARSABLE_DATATYPE_MAP.set('RatioRange', RatioRange);
PARSABLE_DATATYPE_MAP.set('Reference', Reference);
PARSABLE_DATATYPE_MAP.set('RelatedArtifact', RelatedArtifact);
PARSABLE_DATATYPE_MAP.set('SampledData', SampledData);
PARSABLE_DATATYPE_MAP.set('Signature', Signature);
PARSABLE_DATATYPE_MAP.set('Timing', Timing);
PARSABLE_DATATYPE_MAP.set('TriggerDefinition', TriggerDefinition);
PARSABLE_DATATYPE_MAP.set('UsageContext', UsageContext);
